<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/17/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/17/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-GMOCK/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-GMOCK/" class="post-title-link" itemprop="url">GMOCK</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>gmock库笔记</li>
</ul>
<h2 id="C-gmock是什么"><a href="#C-gmock是什么" class="headerlink" title="C++ gmock是什么"></a>C++ gmock是什么</h2><p>Google Mock（gmock）是Google开发的C++的一个模拟对象库，用于进行单元测试时生成模拟（mock）对象。Google Mock结合Google Test（gtest），可以帮助开发人员进行单元测试，特别是在涉及到依赖对象（如外部库、接口等）的情况下。</p>
<p>以下是对 gmock 的主要特点和用法的简要说明：</p>
<h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ol>
<li><p><strong>模拟对象：</strong> gmock 允许你创建模拟对象，这些对象可以替代真实的对象，用于测试代码的各个部分。</p>
</li>
<li><p><strong>期望与行为：</strong> 你可以设置对模拟对象的期望，定义它应该如何被调用以及返回什么值。这允许你测试被测试对象与其依赖关系的交互。</p>
</li>
<li><p><strong>模拟方法：</strong> 通过使用 <code>ON_CALL</code> 宏，你可以为模拟对象的方法设置行为，使其在调用时返回指定的值。</p>
</li>
<li><p><strong>参数匹配：</strong> gmock 提供了多种参数匹配器，以灵活匹配模拟对象方法的参数。</p>
</li>
<li><p><strong>死亡测试（Death Tests）：</strong> 可以使用 <code>EXPECT_DEATH</code> 和 <code>ASSERT_DEATH</code> 宏测试代码是否导致了程序的异常退出。</p>
</li>
</ol>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><ol>
<li><p><strong>包含头文件：</strong> 在测试文件中，首先包含 <code>gmock/gmock.h</code> 头文件：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmock/gmock.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>定义模拟对象：</strong> 使用 <code>MOCK_METHOD</code> 宏定义一个模拟对象的方法。例如：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MockClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MOCK_METHOD</span>(<span class="type">int</span>, MyMethod, (<span class="type">int</span>, <span class="type">double</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置期望：</strong> 在测试用例中使用 gmock 的宏来设置对模拟对象的期望。例如：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MockClass mockObj;</span><br><span class="line"><span class="built_in">EXPECT_CALL</span>(mockObj, <span class="built_in">MyMethod</span>(<span class="number">42</span>, _))</span><br><span class="line">    .<span class="built_in">WillOnce</span>(<span class="built_in">Return</span>(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行测试：</strong> 在主函数中调用 <code>::testing::InitGoogleMock</code> 初始化 gmock，并运行所有测试用例：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ::testing::<span class="built_in">InitGoogleMock</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用模拟对象：</strong> 在测试代码中使用模拟对象：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MockClass mockObj;</span><br><span class="line"><span class="comment">// 使用 mockObj，调用 MyMethod(42, 3.14) 将返回 3</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>下面是一个简单的示例，演示如何使用 gmock 进行单元测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmock/gmock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockMyInterface</span> : <span class="keyword">public</span> MyInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MOCK_METHOD</span>(<span class="type">int</span>, GetValue, (), (<span class="type">const</span>, <span class="keyword">override</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(MyTestSuite, TestName) &#123;</span><br><span class="line">    MockMyInterface mockObj;</span><br><span class="line">    <span class="built_in">EXPECT_CALL</span>(mockObj, <span class="built_in">GetValue</span>())</span><br><span class="line">        .<span class="built_in">WillOnce</span>(::testing::<span class="built_in">Return</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = mockObj.<span class="built_in">GetValue</span>();</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result, <span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>MockMyInterface</code> 是 <code>MyInterface</code> 的模拟类，通过设置 <code>EXPECT_CALL</code> 宏来设置对 <code>GetValue</code> 方法的期望。在测试中，调用 <code>mockObj.GetValue()</code> 将返回预期的值。这使得我们能够独立地测试代码，而不依赖于真实的 <code>MyInterface</code> 实现。</p>
<h2 id="C-gmock库-详解"><a href="#C-gmock库-详解" class="headerlink" title="C++ gmock库 详解"></a>C++ gmock库 详解</h2><p>Google Mock（gmock）是Google Test框架的一部分，是一个用于C++的模拟对象库，用于进行单元测试。以下是对 <code>gmock</code> 库的一些详解：</p>
<h3 id="主要特性："><a href="#主要特性：" class="headerlink" title="主要特性："></a>主要特性：</h3><ol>
<li><p><strong>模拟类和接口：</strong> <code>gmock</code> 允许你创建模拟类和接口，以替代真实的实现，并且模拟对象的行为是可控制的。</p>
</li>
<li><p><strong>定义模拟方法：</strong> 使用 <code>MOCK_METHOD</code> 宏可以在模拟类或接口中定义虚拟方法，表示该方法是一个模拟方法。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置模拟方法的行为：</strong> 使用 <code>EXPECT_CALL</code> 宏来设置对模拟方法的期望。可以指定方法的调用次数、返回值、抛出异常等。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MockMyInterface mock;</span><br><span class="line"><span class="built_in">EXPECT_CALL</span>(mock, <span class="built_in">DoSomething</span>())</span><br><span class="line">    .<span class="built_in">Times</span>(<span class="number">2</span>)</span><br><span class="line">    .<span class="built_in">WillOnce</span>(<span class="built_in">Return</span>(<span class="number">42</span>))</span><br><span class="line">    .<span class="built_in">WillOnce</span>(<span class="built_in">Throw</span>(std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>)));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>参数匹配：</strong> <code>gmock</code> 提供了参数匹配器，可以灵活地匹配模拟方法的输入参数。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EXPECT_CALL</span>(mock, <span class="built_in">SomeMethod</span>(<span class="built_in">NotNull</span>(), _, <span class="number">5</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>委托模拟方法的行为：</strong> 使用 <code>WillByDefault</code> 宏可以指定模拟方法的默认行为。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ON_CALL</span>(mock, <span class="built_in">SomeMethod</span>(_))</span><br><span class="line">    .<span class="built_in">WillByDefault</span>(<span class="built_in">Invoke</span>(&amp;real_object, &amp;RealObject::SomeMethod));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用方法：-1"><a href="#使用方法：-1" class="headerlink" title="使用方法："></a>使用方法：</h3><ol>
<li><p><strong>包含头文件：</strong> 在测试文件中，首先包含 <code>gmock/gmock.h</code> 头文件：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmock/gmock.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>定义模拟类或接口：</strong> 使用 <code>MOCK_METHOD</code> 宏在模拟类或接口中定义虚拟方法。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置期望：</strong> 在测试用例中使用 <code>EXPECT_CALL</code> 宏设置对模拟方法的期望。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MockMyInterface mock;</span><br><span class="line"><span class="built_in">EXPECT_CALL</span>(mock, <span class="built_in">DoSomething</span>())</span><br><span class="line">    .<span class="built_in">Times</span>(<span class="number">2</span>)</span><br><span class="line">    .<span class="built_in">WillOnce</span>(<span class="built_in">Return</span>(<span class="number">42</span>))</span><br><span class="line">    .<span class="built_in">WillOnce</span>(<span class="built_in">Throw</span>(std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>)));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行测试：</strong> 在主函数中调用 <code>::testing::InitGoogleMock</code> 初始化 gmock，并运行所有测试用例。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ::testing::<span class="built_in">InitGoogleMock</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>下面是一个简单的示例，演示了如何使用 <code>gmock</code> 进行单元测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmock/gmock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockMyInterface</span> : <span class="keyword">public</span> MyInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MOCK_METHOD</span>(<span class="type">int</span>, GetValue, (), (<span class="type">const</span>, <span class="keyword">override</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(MyTestSuite, TestName) &#123;</span><br><span class="line">    MockMyInterface mockObj;</span><br><span class="line">    <span class="built_in">EXPECT_CALL</span>(mockObj, <span class="built_in">GetValue</span>())</span><br><span class="line">        .<span class="built_in">WillOnce</span>(::testing::<span class="built_in">Return</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = mockObj.<span class="built_in">GetValue</span>();</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result, <span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>MockMyInterface</code> 是 <code>MyInterface</code> 的模拟类，通过设置 <code>EXPECT_CALL</code> 宏来设置对 <code>GetValue</code> 方法的期望。在测试中，调用 <code>mockObj.GetValue()</code> 将返回预期的值。这使得我们能够独立地测试代码，而不依赖于真实的 <code>MyInterface</code> 实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-JavaScript/" class="post-title-link" itemprop="url">JavaScript</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>JavaScript 编程语言相关笔记</li>
</ul>
<h2 id="JavaScript和threeJS有什么区别"><a href="#JavaScript和threeJS有什么区别" class="headerlink" title="JavaScript和threeJS有什么区别"></a>JavaScript和threeJS有什么区别</h2><p>JavaScript和Three.js是两个相关但不同的概念。</p>
<ol>
<li><p><strong>JavaScript</strong>：<br>JavaScript是一种高级、解释型的编程语言，用于实现网页交互和动态效果。它是Web开发中最常用的语言之一，可以通过在HTML中嵌入 <code>&lt;script&gt;</code> 标签或外部文件来执行。JavaScript不仅限于网页开发，也可以用于服务器端（Node.js）、移动应用程序等。</p>
</li>
<li><p><strong>Three.js</strong>：<br>Three.js是一个基于JavaScript的3D图形库，用于创建和显示3D图形场景。它是建立在WebGL（Web图形库）之上的抽象层，简化了通过浏览器渲染3D图形所需的复杂性。Three.js提供了丰富的API和功能，使开发者能够轻松地创建各种3D场景、模型、动画等，并在Web上展示。</p>
</li>
</ol>
<p>区别：</p>
<ul>
<li>JavaScript是一种编程语言，而Three.js是建立在JavaScript之上的一个库或框架。</li>
<li>JavaScript是一种通用的编程语言，可用于多种用途，包括但不限于网页开发；而Three.js专注于3D图形的创建和展示，特别是用于在网页上实现复杂的3D场景和动画效果。</li>
<li>使用JavaScript可以进行各种编程任务，而Three.js主要用于处理和展示3D图形。</li>
</ul>
<p>简而言之，JavaScript是一种编程语言，而Three.js是一个建立在JavaScript之上的专门用于处理3D图形的库，它们共同协作可以在Web上实现复杂的交互式3D场景。</p>
<h2 id="JavaScript-和-VUE有什么区别"><a href="#JavaScript-和-VUE有什么区别" class="headerlink" title="JavaScript 和 VUE有什么区别"></a>JavaScript 和 VUE有什么区别</h2><p>JavaScript 和 Vue.js 是两个不同的概念：</p>
<ol>
<li><p><strong>JavaScript</strong>：<br>JavaScript是一种广泛使用的编程语言，用于网页开发、应用程序、服务器端开发等。它是一种通用的脚本语言，能够实现丰富的交互和动态效果。JavaScript是前端开发的核心，可以用于控制网页的行为、处理用户输入、与服务器通信等。</p>
</li>
<li><p><strong>Vue.js</strong>：<br>Vue.js是一个流行的JavaScript框架，专注于构建用户界面。它是一个用于构建Web界面的渐进式框架，它的核心库专注于视图层，也能够轻松地与其他库或项目整合。Vue.js提供了诸多工具和库，使得构建大型、高性能的单页面应用（SPA）变得更加简单和高效。</p>
</li>
</ol>
<p>区别：</p>
<ul>
<li><strong>JavaScript</strong> 是一种编程语言，而 <strong>Vue.js</strong> 是建立在 JavaScript 上的一个前端框架。</li>
<li>JavaScript 是一种通用的编程语言，可以执行各种任务和操作；而 Vue.js 是专门用于构建交互式用户界面的框架，提供了组件化开发、响应式数据绑定、路由管理等功能。</li>
<li>使用 JavaScript 可以进行各种编程任务，而 Vue.js 则更专注于前端界面的开发和管理。</li>
</ul>
<p>总的来说，JavaScript是一种编程语言，而Vue.js是一个建立在JavaScript之上的专门用于构建用户界面的前端框架，它们在前端开发中扮演着不同的角色。</p>
<h2 id="node-js是什么"><a href="#node-js是什么" class="headerlink" title="node.js是什么"></a>node.js是什么</h2><p>Node.js是一个基于Chrome V8引擎的JavaScript运行时环境，用于在服务器端运行JavaScript代码。Node.js允许开发者使用JavaScript编写服务器端的应用程序，而不仅仅局限于在浏览器中运行的客户端代码。</p>
<p>主要特点和用途包括：</p>
<ol>
<li><p><strong>服务器端运行</strong>：Node.js允许使用JavaScript编写服务器端代码，使得开发者可以在后端处理HTTP请求、搭建Web服务器、执行文件操作等。</p>
</li>
<li><p><strong>事件驱动和非阻塞I&#x2F;O模型</strong>：Node.js采用事件驱动、非阻塞I&#x2F;O模型，能够处理大量并发请求而不阻塞其他操作，使其在处理高并发请求时表现优异。</p>
</li>
<li><p><strong>跨平台</strong>：Node.js可在多个操作系统上运行，例如Windows、macOS和Linux等。</p>
</li>
<li><p><strong>构建Web应用</strong>：通过Node.js，开发者可以构建各种类型的Web应用，包括API服务器、实时聊天应用、博客平台等。</p>
</li>
<li><p><strong>包管理工具npm</strong>：Node.js附带了npm（Node Package Manager），是世界上最大的软件注册表，开发者可以使用npm安装、分享和管理代码包。</p>
</li>
</ol>
<p>Node.js在后端开发中具有广泛的应用，特别适用于构建实时的、高度交互性的网络应用程序。通过其异步、事件驱动的特性，Node.js能够有效处理大量并发请求，因此常被用于构建高性能、可扩展的服务器端应用。</p>
<h2 id="vscode-运行js单文件"><a href="#vscode-运行js单文件" class="headerlink" title="vscode 运行js单文件"></a>vscode 运行js单文件</h2><p>在Visual Studio Code（VSCode）中运行JavaScript单文件非常简单。你可以按照以下步骤进行：</p>
<ol>
<li><p><strong>安装Node.js</strong>：<br>确保你的计算机上安装了Node.js。你可以在 Node.js 官方网站上下载并安装最新版本：<a target="_blank" rel="noopener" href="https://nodejs.org/">https://nodejs.org/</a></p>
</li>
<li><p><strong>打开 VSCode</strong>：<br>打开你的Visual Studio Code编辑器。</p>
</li>
<li><p><strong>创建或打开 JavaScript 文件</strong>：<br>创建一个新的JavaScript文件（.js扩展名），或者打开已经存在的JavaScript文件。</p>
</li>
<li><p><strong>编写 JavaScript 代码</strong>：<br>在编辑器中编写你的JavaScript代码。</p>
</li>
<li><p><strong>运行 JavaScript 文件</strong>：</p>
</li>
</ol>
<ul>
<li>在VSCode中使用快捷键 <code>Ctrl + </code> 反引号键（在大部分键盘上位于Tab键的左侧）或者 <code>View -&gt; Terminal</code> 打开终端（Terminal）。</li>
<li>在终端中，通过 <code>cd</code> 命令进入存储JavaScript文件的文件夹。</li>
<li>使用 <code>node 文件名.js</code> 命令运行你的JavaScript文件。例如，如果你的文件名是 <code>example.js</code>，则命令是 <code>node example.js</code>。</li>
</ul>
<p>运行命令后，你将在终端中看到JavaScript文件的输出结果。</p>
<p>这样，你就可以在Visual Studio Code中运行JavaScript单文件了。记得在终端中使用Node.js的<code>node</code>命令，并提供你的JavaScript文件名来执行该文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Markdown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Markdown/" class="post-title-link" itemprop="url">Markdown</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>markdown文档的理论知识</li>
</ul>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>要在Markdown中插入图片，你可以使用以下的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![替代文本](图片链接)</span><br></pre></td></tr></table></figure>

<p>其中，替代文本是在图片无法显示时显示的文本描述，图片链接是指向你要插入的图片的URL。</p>
<p>请确保图片链接是公开可访问的，这样才能在Markdown中正确显示图片。</p>
<p>以下是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![可爱的猫咪](https://example.com/cat.jpg)</span><br></pre></td></tr></table></figure>

<p>当你将这段Markdown渲染成HTML时，它将显示一个名为”可爱的猫咪”的图片，图片的源自”<a target="_blank" rel="noopener" href="https://example.com/cat.jpg%22%E3%80%82">https://example.com/cat.jpg&quot;。</a></p>
<h2 id="markdown-删除线-命令"><a href="#markdown-删除线-命令" class="headerlink" title="markdown 删除线 命令"></a>markdown 删除线 命令</h2><p>在Markdown中，要创建删除线，你可以使用两个波浪线（~）将要删除的文本包围起来。具体来说，你可以按照以下格式编写Markdown删除线：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~这是要删除的文本~~</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，”这是要删除的文本”会被渲染为删除线文本。在实际的Markdown预览中，它会看起来像这样：</p>
<p><del>这是要删除的文本</del></p>
<p>只要将要删除的文本用两个波浪线包围起来，Markdown渲染器就会将其呈现为删除线。</p>
<h2 id="markdown-表格"><a href="#markdown-表格" class="headerlink" title="markdown 表格"></a>markdown 表格</h2><ul>
<li><p>要添加表，请使用三个或多个连字符（—）创建每列的标题，并使用管道（|）分隔每列。您可以选择在表的任一端添加管道。</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Header</td>
<td>Title</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
</tr>
</tbody></table>
</li>
<li><p>您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心</p>
<table>
<thead>
<tr>
<th align="left">Syntax</th>
<th align="center">Description</th>
<th align="right">Test Text</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Header</td>
<td align="center">Title</td>
<td align="right">Here’s this</td>
</tr>
<tr>
<td align="left">Paragraph</td>
<td align="center">Text</td>
<td align="right">And more</td>
</tr>
</tbody></table>
</li>
<li><p>您可以在表格中设置文本格式。例如，您可以添加链接，代码（仅反引号（&#96;）中的单词或短语，而不是代码块）和强调。</p>
</li>
<li><p>您不能添加标题，块引用，列表，水平规则，图像或HTML标签。</p>
</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-ImGUI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-ImGUI/" class="post-title-link" itemprop="url">ImGUI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ImGUI 相关理论基础</li>
</ul>
<h2 id="ImGUI-详解"><a href="#ImGUI-详解" class="headerlink" title="ImGUI 详解"></a>ImGUI 详解</h2><p>ImGui（Dear ImGui），全称为Immediate Mode Graphical User Interface，是一个开源的图形用户界面（GUI）库，用于创建简单、高效的界面，主要用于调试工具和游戏开发中的调试目的。ImGui是由Omar Cornut创建的，并在游戏开发者中广受欢迎，特别是C++语言的开发者。</p>
<p>下面是ImGui的一些主要特点和概念：</p>
<ol>
<li><p>即时模式GUI：与传统的GUI框架使用保留模式不同，ImGui遵循即时模式的思想。在即时模式中，GUI元素（小部件）在每一帧中直接在渲染循环中创建和绘制。这样可以简化GUI渲染过程，使其更加轻量级。</p>
</li>
<li><p>简单集成：ImGui设计易于集成到不同的渲染引擎和API中，例如OpenGL、DirectX、Vulkan等。它使用C++编写，并提供了C绑定，使得不同编程语言的开发者都能方便地使用。</p>
</li>
<li><p>小部件：ImGui提供了各种小部件，用于创建GUI元素，比如按钮、滑动条、输入框、复选框等。这些小部件可以轻松定制和样式化，以符合应用程序的视觉设计。</p>
</li>
<li><p>自定义：ImGui允许开发者创建自定义小部件，并修改现有小部件的外观，以满足特定需求。</p>
</li>
<li><p>调试工具：ImGui最初是为调试和开发工具而创建的。它提供了一种灵活方便的方式来在运行时可视化和修改变量、数据和设置。</p>
</li>
<li><p>轻量级和头文件库：ImGui设计为轻量级和仅包含头文件，这意味着您可以轻松地将ImGui头文件包含到项目中，而无需额外的库或依赖。</p>
</li>
<li><p>活跃的社区：ImGui拥有充满活力的社区，为库的开发做出贡献并向其他开发者提供支持。</p>
</li>
</ol>
<p>总体而言，ImGui是一个强大的工具，用于创建快速直观的图形用户界面，特别适用于调试场景和游戏开发环境。其简单性、易于集成和灵活性使其成为游戏开发者和图形编程人员中的首选。如果您正在开发一个需要即时模式GUI的项目，ImGui绝对值得考虑作为潜在的解决方案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-GTEST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-GTEST/" class="post-title-link" itemprop="url">GTEST</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>gtest库笔记</li>
</ul>
<h2 id="C-gtest是什么"><a href="#C-gtest是什么" class="headerlink" title="C++ gtest是什么"></a>C++ gtest是什么</h2><p><code>gtest</code> 是 Google Test 的简称，是一个由Google开发的C++测试框架。它用于编写和运行C++单元测试，旨在帮助开发人员进行测试驱动开发（TDD）和进行单元测试。以下是对 <code>gtest</code> 的一些主要特点和用法的简要说明：</p>
<h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ol>
<li><p><strong>模块化框架：</strong> <code>gtest</code> 提供了一个模块化的测试框架，可以轻松地编写和组织测试用例。</p>
</li>
<li><p><strong>测试用例：</strong> 通过定义测试用例，可以将一组相关的测试组织在一起。每个测试用例可以包含多个测试。</p>
</li>
<li><p><strong>断言：</strong> <code>gtest</code> 提供了一系列的断言宏，用于判断测试条件是否为真。例如，<code>ASSERT_EQ</code> 用于判断两个值是否相等，<code>ASSERT_TRUE</code> 用于判断条件是否为真等。</p>
</li>
<li><p><strong>丰富的输出：</strong> 在测试运行时，<code>gtest</code> 提供详细的输出，显示测试通过或失败的信息，以及失败时的具体条件和值。</p>
</li>
<li><p><strong>测试夹具（Fixture）：</strong> 可以使用测试夹具在多个测试之间共享共同的设置和状态。测试夹具提供了 <code>SetUp()</code> 和 <code>TearDown()</code> 方法，分别在测试开始和结束时执行。</p>
</li>
<li><p><strong>参数化测试：</strong> <code>gtest</code> 支持参数化测试，允许使用不同的输入参数运行相同的测试用例。</p>
</li>
</ol>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><ol>
<li><p><strong>安装 <code>gtest</code>：</strong> 下载 <code>gtest</code> 源代码，编译生成库文件，并将其集成到你的项目中。或者，可以使用包管理工具（如CMake、Conan等）直接获取 <code>gtest</code>。</p>
</li>
<li><p><strong>编写测试用例：</strong> 创建一个或多个测试文件，定义测试用例和测试函数。在测试函数中使用 <code>gtest</code> 提供的断言宏进行测试。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(MyTestSuite, MyTestCase) &#123;</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(MyTestSuite, AnotherTestCase) &#123;</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行测试：</strong> 使用测试框架运行测试。测试框架会执行所有测试用例，并输出测试结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看测试结果：</strong> 测试框架会输出详细的测试结果，显示每个测试用例的执行情况。</p>
</li>
</ol>
<p><code>gtest</code> 是一个强大而灵活的测试框架，被广泛用于C++项目中的单元测试。它可以帮助开发人员确保代码的质量，检测潜在的问题，并提供可靠的单元测试基础。</p>
<h2 id="C-gtest库-详解"><a href="#C-gtest库-详解" class="headerlink" title="C++ gtest库 详解"></a>C++ gtest库 详解</h2><p>Google Test（gtest）是一个C++的单元测试框架，由Google开发。它允许你编写测试，进行断言和生成测试报告。以下是对gtest库的详细解释：</p>
<h3 id="安装-gtest："><a href="#安装-gtest：" class="headerlink" title="安装 gtest："></a>安装 gtest：</h3><ol>
<li><p><strong>源代码下载：</strong> 从 <a target="_blank" rel="noopener" href="https://github.com/google/googletest">Google Test GitHub</a> 下载最新的源代码。</p>
</li>
<li><p><strong>编译 gtest：</strong> 使用CMake工具构建gtest库。在下载的gtest目录中创建一个build目录，进入该目录并运行：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p> 这将生成libgtest.a和libgtest_main.a库文件。</p>
</li>
<li><p><strong>集成到项目：</strong> 将生成的库文件集成到你的C++项目中，并包含gtest头文件。你可以将gtest的 <code>include</code> 目录添加到你的项目中，同时链接到生成的库文件。</p>
</li>
</ol>
<h3 id="编写测试用例："><a href="#编写测试用例：" class="headerlink" title="编写测试用例："></a>编写测试用例：</h3><ol>
<li><p><strong>包含头文件：</strong> 在测试文件中，首先包含gtest头文件：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>定义测试用例：</strong> 使用<code>TEST</code>宏定义测试用例：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(TestSuiteName, TestName) &#123;</span><br><span class="line">    <span class="comment">// Your test logic and assertions go here</span></span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行测试：</strong> 在主函数中调用 <code>::testing::InitGoogleTest</code> 初始化gtest，并运行所有测试用例：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="常用断言宏："><a href="#常用断言宏：" class="headerlink" title="常用断言宏："></a>常用断言宏：</h3><ul>
<li><code>ASSERT_TRUE(condition)</code>：如果条件为真，测试通过。</li>
<li><code>ASSERT_FALSE(condition)</code>：如果条件为假，测试通过。</li>
<li><code>ASSERT_EQ(expected, actual)</code>：如果两个值相等，测试通过。</li>
<li><code>ASSERT_NE(val1, val2)</code>：如果两个值不相等，测试通过。</li>
<li><code>ASSERT_LT(val1, val2)</code>：如果第一个值小于第二个值，测试通过。</li>
<li><code>ASSERT_LE(val1, val2)</code>：如果第一个值小于或等于第二个值，测试通过。</li>
<li><code>ASSERT_GT(val1, val2)</code>：如果第一个值大于第二个值，测试通过。</li>
<li><code>ASSERT_GE(val1, val2)</code>：如果第一个值大于或等于第二个值，测试通过。</li>
</ul>
<h3 id="测试夹具（Fixture）："><a href="#测试夹具（Fixture）：" class="headerlink" title="测试夹具（Fixture）："></a>测试夹具（Fixture）：</h3><p>测试夹具允许你在多个测试之间共享设置和状态。使用 <code>TEST_F</code> 宏定义测试用例，其中 <code>F</code> 表示测试夹具的名称：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTestFixture</span> : <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在测试用例执行前调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TearDown</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在测试用例执行后调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST_F</span>(MyTestFixture, TestName) &#123;</span><br><span class="line">    <span class="comment">// Your test logic and assertions go here</span></span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数化测试："><a href="#参数化测试：" class="headerlink" title="参数化测试："></a>参数化测试：</h3><p>gtest支持参数化测试，允许你以不同的参数运行相同的测试用例。使用 <code>INSTANTIATE_TEST_SUITE_P</code> 宏定义参数化测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyParameterizedTest</span> : <span class="keyword">public</span> ::testing::TestWithParam&lt;<span class="type">int</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">INSTANTIATE_TEST_SUITE_P</span>(MyTestSuite, MyParameterizedTest, ::testing::<span class="built_in">Values</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST_P</span>(MyParameterizedTest, TestName) &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="built_in">GetParam</span>();</span><br><span class="line">    <span class="comment">// Your test logic and assertions go here</span></span><br><span class="line">    <span class="built_in">ASSERT_GT</span>(value, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><code>gtest</code> 是一个强大的C++单元测试框架，提供了丰富的功能，使得编写、运行和维护测试用例变得相对简单。通过良好的集成和文档，gtest被广泛用于C++项目的测试中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-IOT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-IOT/" class="post-title-link" itemprop="url">IOT</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>物联网编程基础相关笔记</li>
</ul>
<h2 id="Arduino编程语言-ESP8266WiFi-h-详解"><a href="#Arduino编程语言-ESP8266WiFi-h-详解" class="headerlink" title="Arduino编程语言 ESP8266WiFi.h 详解"></a>Arduino编程语言 ESP8266WiFi.h 详解</h2><p><code>ESP8266WiFi.h</code> 是用于连接Arduino设备到WiFi网络的Arduino库，特别适用于使用ESP8266模块的项目。ESP8266是一款常用于物联网（IoT）应用的低成本、高性能WiFi模块。以下是对 <code>ESP8266WiFi.h</code> 库的一些常见函数和功能的详细解释：</p>
<p><strong>引入库</strong>：<br>要使用 <code>ESP8266WiFi.h</code> 库，你需要在Arduino代码中包含以下语句：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>WiFi连接</strong>：</p>
<ol>
<li><p><code>WiFi.begin(ssid, password)</code>：连接到指定的WiFi网络。你需要提供网络的SSID（无线网络名称）和密码。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid = <span class="string">&quot;YourNetworkSSID&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* password = <span class="string">&quot;YourNetworkPassword&quot;</span>;</span><br><span class="line"><span class="built_in">WiFi</span>.<span class="built_in">begin</span>(ssid, password);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>WiFi.disconnect()</code>：断开当前的WiFi连接。</p>
</li>
</ol>
<p><strong>WiFi状态</strong>：</p>
<ul>
<li><code>WiFi.status()</code>：返回WiFi连接的状态，可以是以下之一：<ul>
<li><code>WL_IDLE</code>：未连接到任何网络。</li>
<li><code>WL_CONNECTED</code>：已连接到WiFi网络。</li>
<li><code>WL_CONNECT_FAILED</code>：连接失败。</li>
</ul>
</li>
</ul>
<p><strong>获取网络信息</strong>：</p>
<ul>
<li><code>WiFi.localIP()</code>：返回分配给Arduino设备的本地IP地址。</li>
<li><code>WiFi.macAddress()</code>：返回设备的MAC地址。</li>
</ul>
<p><strong>获取信号强度</strong>：</p>
<ul>
<li><code>WiFi.RSSI()</code>：返回与当前WiFi网络的信号强度。</li>
</ul>
<p><strong>扫描WiFi网络</strong>：</p>
<ul>
<li><code>WiFi.scanNetworks()</code>：扫描可用的WiFi网络并返回一个WiFi列表。这个函数可以用于查找周围可用的网络，并选择要连接的网络。</li>
</ul>
<p><strong>例子</strong>：<br>下面是一个简单的Arduino代码示例，演示如何使用 <code>ESP8266WiFi.h</code> 连接到WiFi网络：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid = <span class="string">&quot;YourNetworkSSID&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* password = <span class="string">&quot;YourNetworkPassword&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试连接到WiFi网络</span></span><br><span class="line">  <span class="built_in">WiFi</span>.<span class="built_in">begin</span>(ssid, password);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">WiFi</span>.<span class="built_in">status</span>() != WL_CONNECTED) &#123;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="string">&quot;Connecting to WiFi...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="string">&quot;Connected to WiFi&quot;</span>);</span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">print</span>(<span class="string">&quot;IP address: &quot;</span>);</span><br><span class="line">  <span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="built_in">WiFi</span>.<span class="built_in">localIP</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在这里执行主要的循环逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何连接到WiFi网络，等待连接成功，然后输出本地IP地址到串口监视器。</p>
<p>使用 <code>ESP8266WiFi.h</code> 库，你可以创建连接到WiFi网络的Arduino应用，用于IoT项目、远程控制、数据传输等。此库支持与ESP8266模块的集成，并提供了一组函数来管理WiFi连接和网络通信。</p>
<h2 id="Arduino编程语言-WiFi的函数库-详解"><a href="#Arduino编程语言-WiFi的函数库-详解" class="headerlink" title="Arduino编程语言 WiFi的函数库 详解"></a>Arduino编程语言 WiFi的函数库 详解</h2><p>Arduino编程语言的WiFi库包括几个子库，如<code>WiFi.h</code>和<code>WiFiClient.h</code>，用于连接Arduino设备到无线网络。这些库支持不同的WiFi模块，如ESP8266、ESP32以及其他WiFi模块，使Arduino设备能够进行无线通信。以下是一些常用的WiFi库函数和子库的详细解释：</p>
<ol>
<li><p><strong>WiFi.h</strong>：</p>
<ul>
<li><code>WiFi.begin(ssid, password)</code>：用于连接到指定的WiFi网络，需要提供SSID（无线网络名称）和密码。</li>
<li><code>WiFi.disconnect()</code>：断开当前的WiFi连接。</li>
<li><code>WiFi.status()</code>：返回WiFi连接的状态，可以是WL_CONNECTED、WL_CONNECT_FAILED、WL_IDLE等。</li>
<li><code>WiFi.localIP()</code>：返回分配给Arduino设备的本地IP地址。</li>
<li><code>WiFi.macAddress()</code>：返回设备的MAC地址。</li>
<li><code>WiFi.RSSI()</code>：返回与当前WiFi网络的信号强度。</li>
<li><code>WiFi.scanNetworks()</code>：扫描可用的WiFi网络并返回一个列表。</li>
</ul>
</li>
<li><p><strong>WiFiClient.h</strong>：</p>
<ul>
<li><code>WiFiClient client</code>：创建一个WiFi客户端对象，用于建立和管理与远程服务器的连接。</li>
<li><code>client.connect(server, port)</code>：连接到指定的远程服务器和端口。</li>
<li><code>client.println(data)</code>：将数据发送到远程服务器。</li>
<li><code>client.available()</code>：检查是否有可用的数据可读。</li>
<li><code>client.read()</code>：从远程服务器读取一个字节的数据。</li>
<li><code>client.stop()</code>：断开与远程服务器的连接。</li>
</ul>
</li>
<li><p><strong>WiFiServer.h</strong>：</p>
<ul>
<li><code>WiFiServer server(port)</code>：创建一个WiFi服务器对象，用于侦听并接受客户端连接。</li>
<li><code>server.available()</code>：检查是否有客户端请求连接。</li>
<li><code>server.accept()</code>：接受客户端连接，并返回一个<code>WiFiClient</code>对象来处理连接。</li>
<li><code>server.begin()</code>：启动WiFi服务器。</li>
</ul>
</li>
<li><p><strong>WiFiUDP.h</strong>：</p>
<ul>
<li><code>WiFiUDP udp</code>：创建一个UDP连接对象，用于进行UDP通信。</li>
<li><code>udp.begin(localPort)</code>：开始UDP通信，指定本地端口。</li>
<li><code>udp.parsePacket()</code>：检查是否有数据包可用。</li>
<li><code>udp.read(data, length)</code>：读取接收到的UDP数据。</li>
<li><code>udp.beginPacket(ip, port)</code>：开始向指定IP地址和端口发送UDP数据包。</li>
<li><code>udp.write(data, length)</code>：将数据发送到指定IP地址和端口。</li>
<li><code>udp.endPacket()</code>：结束UDP数据包的发送。</li>
</ul>
</li>
</ol>
<p>这些函数和子库使Arduino设备能够轻松地连接到WiFi网络，执行数据通信、远程控制和监测等任务。使用WiFi库，你可以创建物联网设备、远程传感器、控制器等应用，从而实现无线连接和互联网通信。需要根据具体的Arduino板和WiFi模块，包括ESP8266、ESP32等，选择适合的库和函数来编写你的Arduino WiFi应用。</p>
<h2 id="Arduino编程语言-常用的函数库-详解"><a href="#Arduino编程语言-常用的函数库-详解" class="headerlink" title="Arduino编程语言 常用的函数库 详解"></a>Arduino编程语言 常用的函数库 详解</h2><p>Arduino编程语言与硬件平台结合使用，支持许多常用的函数库，以简化开发过程，包括与传感器、执行器、通信、显示等相关的库。以下是一些常用的Arduino函数库的详细解释：</p>
<ol>
<li><p><strong>Wire（I2C库）</strong>：<code>Wire</code> 库支持Arduino与I2C设备进行通信，如各种传感器、显示器、扩展板等。它提供了函数来初始化I2C通信、发送和接收数据。通过 <code>Wire</code> 库，你可以轻松连接和控制多个I2C设备。</p>
</li>
<li><p><strong>Servo库</strong>：<code>Servo</code> 库用于控制舵机。它提供了函数来附加、解除附加、设置角度、读取角度等操作，使你能够控制舵机的位置和运动。</p>
</li>
<li><p><strong>SPI库</strong>：<code>SPI</code> 库支持Arduino与SPI设备（如SD卡、显示器、无线模块）进行通信。它提供了函数来初始化SPI、发送和接收数据，以及操作SPI设备的其他功能。</p>
</li>
<li><p><strong>Ethernet库</strong>：<code>Ethernet</code> 库用于连接Arduino到以太网网络。它支持网络通信，允许你创建IoT设备，访问Internet、远程服务器和云平台。</p>
</li>
<li><p><strong>WiFi库</strong>：<code>WiFi</code> 库用于连接Arduino到Wi-Fi网络，实现无线通信。它支持连接到本地网络、远程服务器，以及进行云连接，使得创建Wi-Fi物联网设备更加容易。</p>
</li>
<li><p><strong>Adafruit NeoPixel库</strong>：这个库用于控制WS2812（NeoPixel）类型的彩色LED灯带。它提供了函数来控制LED的颜色、亮度、动画等，用于创建灯光效果和可视化。</p>
</li>
<li><p><strong>LiquidCrystal库</strong>：<code>LiquidCrystal</code> 库用于控制液晶显示器（LCD）。它支持字符型和图形型LCD，提供函数来初始化LCD、显示文本和自定义字符，以及控制光标位置。</p>
</li>
<li><p><strong>DHT库</strong>：<code>DHT</code> 库用于与DHT系列湿度和温度传感器通信。它提供函数来读取湿度和温度数据，以监测环境参数。</p>
</li>
<li><p><strong>Blynk库</strong>：<code>Blynk</code> 库是一个物联网平台，允许你通过移动应用远程控制和监测Arduino设备。它提供了函数来与Blynk服务器通信，创建可视化控件和监控Arduino设备。</p>
</li>
<li><p><strong>Adafruit GFX库</strong>：这个库用于图形显示，支持各种显示器和屏幕。它提供了函数来绘制图形、文本和形状，以创建自定义用户界面。</p>
</li>
</ol>
<p>这些函数库是Arduino编程的重要组成部分，可用于处理各种任务，从传感器读取到显示和通信。Arduino社区也提供了许多其他库，适用于特定用途，使得开发和扩展Arduino应用更加容易。你可以通过Arduino IDE的库管理器轻松安装和更新这些库，以满足项目需求。</p>
<h2 id="Arduino编程语言-详解"><a href="#Arduino编程语言-详解" class="headerlink" title="Arduino编程语言 详解"></a>Arduino编程语言 详解</h2><p>Arduino编程语言是基于C&#x2F;C++的编程语言的子集，专门用于Arduino开发平台。它经过了一些简化和定制，以适应嵌入式系统和物联网（IoT）应用的需求。以下是对Arduino编程语言的详细解释：</p>
<p><strong>基本语法和结构</strong>：</p>
<ol>
<li><p><strong>函数定义</strong>：Arduino程序从 <code>setup()</code> 函数开始执行，然后无限循环执行 <code>loop()</code> 函数。这是Arduino程序的基本结构，示例如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化设置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 主程序逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注释</strong>：你可以使用双斜线 <code>//</code> 来添加注释，用于解释代码的作用。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个注释</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据类型</strong>：Arduino支持整数（<code>int</code>）、浮点数（<code>float</code>）、字符（<code>char</code>）、布尔值（<code>boolean</code>）等数据类型。</p>
</li>
<li><p><strong>变量声明</strong>：你可以使用 <code>int</code>、<code>float</code>、<code>char</code> 等关键字来声明变量。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sensorValue;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>控制结构</strong>：Arduino支持条件语句（<code>if-else</code>、<code>switch-case</code>）和循环语句（<code>for</code>、<code>while</code>）来控制程序流程。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 执行语句</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 执行其他语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数调用</strong>：你可以定义和调用自定义函数，将一组操作封装在一个函数内。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">customFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 函数内的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引脚操作</strong>：使用 <code>pinMode()</code>、<code>digitalWrite()</code> 和 <code>digitalRead()</code> 函数来控制数字引脚的工作模式和电平状态，以及使用 <code>analogRead()</code> 函数来读取模拟引脚的值。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pinMode</span>(ledPin, <span class="literal">OUTPUT</span>);</span><br><span class="line"><span class="built_in">digitalWrite</span>(ledPin, <span class="literal">HIGH</span>);</span><br><span class="line"><span class="type">int</span> buttonState = <span class="built_in">digitalRead</span>(buttonPin);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>串口通信</strong>：通过使用 <code>Serial.begin()</code> 和 <code>Serial.println()</code> 函数，你可以与计算机或其他设备进行串口通信。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Serial</span>.<span class="built_in">begin</span>(<span class="number">9600</span>);</span><br><span class="line"><span class="built_in">Serial</span>.<span class="built_in">println</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>示例</strong>：</p>
<p>以下是一个简单的Arduino程序示例，该程序控制一个LED灯的闪烁：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ledPin = <span class="number">13</span>; <span class="comment">// 定义LED所连接的数字引脚</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(ledPin, <span class="literal">OUTPUT</span>); <span class="comment">// 设置LED引脚为输出模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">digitalWrite</span>(ledPin, <span class="literal">HIGH</span>); <span class="comment">// 打开LED</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 延迟1秒</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(ledPin, <span class="literal">LOW</span>); <span class="comment">// 关闭LED</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 延迟1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了变量声明、函数调用、引脚控制、循环操作等基本的Arduino编程概念。</p>
<p>总之，Arduino编程语言是一种适用于嵌入式系统和物联网应用的C&#x2F;C++子集，提供了一系列的函数和库来简化开发过程。它是一个强大的工具，可用于创建各种物联网应用，从简单的LED控制到复杂的传感器网络和自动化系统。Arduino的简单语法和丰富的社区支持使得学习和开发变得更加容易。</p>
<h2 id="Arduino-编程-详解"><a href="#Arduino-编程-详解" class="headerlink" title="Arduino 编程 详解"></a>Arduino 编程 详解</h2><p>Arduino编程是使用Arduino平台（硬件和软件）创建嵌入式系统和物联网（IoT）应用的过程。Arduino是一种开源的硬件平台，配备了易于使用的集成开发环境（IDE）和强大的编程库，使编程和原型设计变得更加简单。以下是对Arduino编程的详细解释：</p>
<p><strong>Arduino平台的基本组成</strong>：</p>
<ol>
<li><p><strong>Arduino板</strong>：Arduino硬件平台通常包括一个微控制器板，如Arduino Uno、Arduino Mega、Arduino Nano等。这个板上有数字引脚和模拟引脚，可用于连接传感器、执行器和其他外部设备。</p>
</li>
<li><p><strong>Arduino IDE</strong>：Arduino集成开发环境（IDE）是用于编程Arduino板的软件工具。它是基于Processing编程语言的，提供了简单的界面和丰富的库函数来开发Arduino应用。</p>
</li>
<li><p><strong>编程语言</strong>：Arduino编程使用C&#x2F;C++语言的一个子集。它是一种简化的编程语言，适用于嵌入式系统和物联网应用。</p>
</li>
</ol>
<p><strong>Arduino编程的基本概念</strong>：</p>
<ul>
<li><strong>Setup 和 Loop 函数</strong>：每个Arduino程序包含两个主要函数：<code>setup()</code> 和 <code>loop()</code>。<code>setup()</code> 函数在程序开始时执行一次，通常用于初始化设置。<code>loop()</code> 函数是一个无限循环，其中包含主要的程序逻辑，会不断执行。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化设置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 主程序逻辑，将不断执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>引脚控制</strong>：通过使用 <code>pinMode()</code> 函数来设置引脚的工作模式，使用 <code>digitalWrite()</code> 和 <code>digitalRead()</code> 函数控制数字引脚的电平状态，以及使用 <code>analogRead()</code> 和 <code>analogWrite()</code> 函数来处理模拟引脚的数据。</p>
</li>
<li><p><strong>变量和数据类型</strong>：Arduino支持整数、浮点数、字符、布尔值等不同的数据类型。你可以使用变量来存储数据，执行数学运算，以及进行条件判断和控制流操作。</p>
</li>
<li><p><strong>控制结构</strong>：Arduino编程支持条件语句（if-else、switch-case）、循环语句（for、while）和函数定义。这些结构用于控制程序的执行流程。</p>
</li>
<li><p><strong>函数库</strong>：Arduino IDE提供了许多内置函数库，用于执行各种任务，例如与传感器通信、驱动执行器、执行通信操作等。你还可以创建自己的库以扩展功能。</p>
</li>
</ul>
<p><strong>示例 Arduino 编程任务</strong>：</p>
<ol>
<li><p><strong>LED控制</strong>：通过控制数字引脚上的LED，实现LED的闪烁或呼吸效果。</p>
</li>
<li><p><strong>传感器读取</strong>：使用<code>analogRead()</code>函数从传感器（如温度传感器、光线传感器）读取数据，然后根据需要进行处理。</p>
</li>
<li><p><strong>通信</strong>：使用串口通信与计算机或其他设备通信，通过串口监视器查看和记录数据。</p>
</li>
<li><p><strong>运动控制</strong>：使用舵机、步进电机或直流电机控制机械装置的运动，如机器人或遥控车辆。</p>
</li>
<li><p><strong>网络通信</strong>：与Wi-Fi模块或以太网模块通信，实现物联网设备之间的数据传输。</p>
</li>
<li><p><strong>数据存储</strong>：将传感器数据存储在SD卡或外部存储设备上，以后进行分析或查询。</p>
</li>
<li><p><strong>显示</strong>：连接LCD、LED矩阵、OLED显示器或其他显示设备，以在屏幕上显示信息。</p>
</li>
<li><p><strong>云连接</strong>：与云平台（如AWS IoT、Google Cloud IoT、Azure IoT）通信，将数据上传到云中进行存储和分析。</p>
</li>
</ol>
<p>Arduino编程提供了一个强大的工具，用于创建各种物联网应用，从简单的LED控制到复杂的传感器网络和自动化系统。Arduino的社区和文档资源丰富，使得学习和开发更加容易。无论是初学者还是经验丰富的开发者，Arduino都是一个强大的平台，可用于快速原型设计和物联网项目的开发。</p>
<h2 id="IOT-map-函数-详解"><a href="#IOT-map-函数-详解" class="headerlink" title="IOT map() 函数 详解"></a>IOT map() 函数 详解</h2><p><code>map()</code> 函数是Arduino编程中的一个重要函数，用于将一个值从一个数值范围映射到另一个数值范围。在物联网（IoT）应用中，<code>map()</code> 函数通常用于将传感器数据映射到实际物理值，进行范围缩放或单位转换等操作。以下是对 <code>map()</code> 函数的详细解释：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(value, fromLow, fromHigh, toLow, toHigh);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>value</code>：要映射的输入值，通常是一个传感器读数或其他量测数据。</li>
<li><code>fromLow</code> 和 <code>fromHigh</code>：输入值的原始范围，<code>fromLow</code> 是原始范围的最小值，<code>fromHigh</code> 是原始范围的最大值。</li>
<li><code>toLow</code> 和 <code>toHigh</code>：要映射到的目标范围，<code>toLow</code> 是目标范围的最小值，<code>toHigh</code> 是目标范围的最大值。</li>
</ul>
<p><strong>工作原理</strong>：</p>
<ul>
<li><code>map()</code> 函数将输入值 <code>value</code> 从原始范围 <code>[fromLow, fromHigh]</code> 映射到目标范围 <code>[toLow, toHigh]</code>。</li>
<li>映射后的值将位于目标范围内，它的大小和位置与原始值成比例。</li>
<li>映射公式为：<code>mappedValue = (value - fromLow) * (toHigh - toLow) / (fromHigh - fromLow) + toLow</code></li>
</ul>
<p><strong>示例用法</strong>：<br>以下是一些使用 <code>map()</code> 函数的示例用法：</p>
<ol>
<li><p>从模拟传感器读取温度值，并将其映射到摄氏度范围：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sensorValue = <span class="built_in">analogRead</span>(sensorPin); <span class="comment">// 读取传感器值</span></span><br><span class="line"><span class="type">float</span> temperatureC = <span class="built_in">map</span>(sensorValue, <span class="number">0</span>, <span class="number">1023</span>, <span class="number">-10</span>, <span class="number">40</span>); <span class="comment">// 映射到温度范围-10°C到40°C</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从光线传感器读取光线强度，并将其映射到百分比范围：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lightValue = <span class="built_in">analogRead</span>(lightSensorPin); <span class="comment">// 读取光线传感器值</span></span><br><span class="line"><span class="type">int</span> lightPercentage = <span class="built_in">map</span>(lightValue, <span class="number">0</span>, <span class="number">1023</span>, <span class="number">0</span>, <span class="number">100</span>); <span class="comment">// 映射到百分比范围</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从电池电压传感器读取电压值，并将其映射到电池状态：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> voltageValue = <span class="built_in">analogRead</span>(voltageSensorPin); <span class="comment">// 读取电压传感器值</span></span><br><span class="line"><span class="type">int</span> batteryStatus = <span class="built_in">map</span>(voltageValue, <span class="number">0</span>, <span class="number">1023</span>, <span class="number">0</span>, <span class="number">100</span>); <span class="comment">// 映射到电池状态百分比</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意事项</strong>：</p>
<ul>
<li>使用 <code>map()</code> 函数时，确保输入值和目标范围都在你的预期范围内。</li>
<li>如果输入值超出原始范围，或目标值超出目标范围，映射可能不会产生正确的结果。</li>
<li><code>map()</code> 函数常用于将传感器数据转换为易于理解和处理的物理单位，以及将值映射到显示或控制范围。</li>
</ul>
<p><code>map()</code> 函数是在IoT应用中进行数据转换和映射的有用工具。它使你能够轻松地将传感器数据映射到实际物理值，以便更好地理解和使用数据。这对于监测、控制和显示IoT应用中的传感器数据非常有帮助。</p>
<h2 id="IOT-analogRead-函数-详解"><a href="#IOT-analogRead-函数-详解" class="headerlink" title="IOT analogRead() 函数 详解"></a>IOT analogRead() 函数 详解</h2><p><code>analogRead()</code> 函数是Arduino编程中的一个常用函数，用于读取模拟引脚（Analog Pin）上的模拟信号，并返回其数字表示。在物联网（IoT）应用中，<code>analogRead()</code> 函数通常用于从传感器读取模拟数据，如光线强度、温度、湿度等。以下是对 <code>analogRead()</code> 函数的详细解释：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">analogRead</span>(pin);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pin</code>：要读取的模拟引脚的引脚号。</li>
</ul>
<p><strong>工作原理</strong>：</p>
<ul>
<li><code>analogRead()</code> 函数用于读取指定模拟引脚上的电压值，并返回一个介于0和1023之间的整数，表示模拟信号的数字值。</li>
<li>这个返回值是通过将模拟电压转换为数字值的结果，通常称为模数转换（Analog-to-Digital Conversion，简称ADC）。</li>
<li>返回值0表示模拟引脚上的电压接近于0V，返回值1023表示电压接近于板上的参考电压（通常是5V或3.3V）。</li>
</ul>
<p><strong>示例用法</strong>：<br>以下是一些使用 <code>analogRead()</code> 函数的示例用法：</p>
<ol>
<li><p>读取光线传感器数据：</p>
<ul>
<li>使用 <code>analogRead()</code> 函数来读取连接到模拟引脚的光线传感器的数据。<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lightSensorPin = A0;</span><br><span class="line"><span class="type">int</span> sensorValue = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化设置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sensorValue = <span class="built_in">analogRead</span>(lightSensorPin);</span><br><span class="line">  <span class="comment">// 处理传感器值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>读取温度传感器数据：</p>
<ul>
<li>使用 <code>analogRead()</code> 函数来读取连接到模拟引脚的温度传感器的数据，然后进行温度转换。<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tempSensorPin = A1;</span><br><span class="line"><span class="type">int</span> sensorValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> temperature = <span class="number">0.0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化设置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sensorValue = <span class="built_in">analogRead</span>(tempSensorPin);</span><br><span class="line">  <span class="comment">// 进行温度转换</span></span><br><span class="line">  temperature = <span class="built_in">map</span>(sensorValue, <span class="number">0</span>, <span class="number">1023</span>, <span class="number">-10</span>, <span class="number">40</span>); <span class="comment">// 例子：将传感器值映射到温度范围</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>读取电池电压：</p>
<ul>
<li>使用 <code>analogRead()</code> 函数来读取连接到模拟引脚的电池电压，以监测电池状态。<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> batteryVoltagePin = A2;</span><br><span class="line"><span class="type">int</span> sensorValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> batteryVoltage = <span class="number">0.0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化设置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sensorValue = <span class="built_in">analogRead</span>(batteryVoltagePin);</span><br><span class="line">  <span class="comment">// 计算电池电压</span></span><br><span class="line">  batteryVoltage = (sensorValue / <span class="number">1023.0</span>) * referenceVoltage; <span class="comment">// 假设使用5V参考电压</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>注意事项</strong>：</p>
<ul>
<li>读取模拟信号时，需要了解模拟引脚的参考电压（reference voltage），因为它会影响 <code>analogRead()</code> 的返回值。通常，Arduino板的参考电压为5V或3.3V，但也可以通过编程设置其他值。</li>
<li><code>analogRead()</code> 返回的数值范围是0到1023，你可能需要将其映射到实际物理量（如温度、湿度等）的范围。</li>
<li>使用模拟传感器数据时，通常需要将其校准和转换为实际物理值，具体取决于传感器和应用需求。</li>
</ul>
<p><code>analogRead()</code> 函数是物联网应用中常用的函数，它允许你读取传感器数据，监测环境参数，从传感器获取信息，并执行相应的控制操作。在IoT开发中，了解如何使用 <code>analogRead()</code> 函数可以帮助你实现各种传感器相关的应用。</p>
<h2 id="IOT-delay-函数-详解"><a href="#IOT-delay-函数-详解" class="headerlink" title="IOT delay() 函数 详解"></a>IOT delay() 函数 详解</h2><p><code>delay()</code> 函数是Arduino编程中的一个重要函数，用于暂停程序的执行，延迟一定的时间。在物联网（IoT）应用中，<code>delay()</code> 函数通常用于创建时间间隔，控制执行时间，或在不需要实时操作的情况下进行简单的定时任务。以下是对 <code>delay()</code> 函数的详细解释：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delay</span>(ms);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ms</code>：要延迟的时间，以毫秒（milliseconds）为单位。例如，<code>delay(1000)</code> 表示要延迟1秒。</li>
</ul>
<p><strong>工作原理</strong>：</p>
<ul>
<li><code>delay()</code> 函数将程序的执行暂停（挂起）指定的时间，以毫秒为单位。在延迟期间，程序不执行任何其他操作，只是等待指定的时间过去。</li>
<li>当延迟时间结束后，程序将继续执行后续的代码。</li>
</ul>
<p><strong>示例用法</strong>：<br>以下是一些使用 <code>delay()</code> 函数的示例用法：</p>
<ol>
<li><p>简单的定时任务：</p>
<ul>
<li><code>delay()</code> 函数可用于创建简单的定时任务，例如每隔一定时间执行某个操作。<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化设置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 执行任务A</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 延迟1秒</span></span><br><span class="line">  <span class="comment">// 执行任务B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>控制LED闪烁：</p>
<ul>
<li><code>delay()</code> 可用于控制LED的闪烁频率。<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ledPin = <span class="number">13</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(ledPin, <span class="literal">OUTPUT</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">digitalWrite</span>(ledPin, <span class="literal">HIGH</span>); <span class="comment">// 打开LED</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 延迟1秒</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(ledPin, <span class="literal">LOW</span>); <span class="comment">// 关闭LED</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 延迟1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>时间测量：</p>
<ul>
<li><code>delay()</code> 可用于测量某个操作的执行时间。<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化设置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> startTime = <span class="built_in">millis</span>();</span><br><span class="line">  <span class="comment">// 执行需要测量时间的操作</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> endTime = <span class="built_in">millis</span>();</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> executionTime = endTime - startTime;</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span> - executionTime); <span class="comment">// 延迟剩余时间，以确保总时间达到1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>注意事项</strong>：</p>
<ul>
<li>在使用 <code>delay()</code> 函数时，程序会在延迟期间一直暂停，无法执行其他任务，这可能会导致程序的实时性问题。因此，在需要同时执行多个任务或实现实时操作的应用中，通常建议使用非阻塞的编程方法，例如使用 <code>millis()</code> 函数来管理时间。</li>
<li>长时间的延迟可能会导致程序的响应时间较差，因此应小心使用。</li>
</ul>
<p><code>delay()</code> 函数是一个简单但有用的工具，可以用于创建时间间隔、控制定时任务和暂停程序的执行。在某些IoT应用中，例如LED控制、简单传感器读取和简单任务执行，<code>delay()</code> 函数是一个方便的工具。但对于需要更高级的时间管理和实时性的应用，通常建议使用非阻塞的编程技术。</p>
<h2 id="IOT-digitalWrite-函数-详解"><a href="#IOT-digitalWrite-函数-详解" class="headerlink" title="IOT digitalWrite() 函数 详解"></a>IOT digitalWrite() 函数 详解</h2><p><code>digitalWrite()</code> 函数是Arduino编程中的一个常用函数，用于控制数字引脚（Digital Pin）的电平状态，使其输出高电平或低电平。在物联网（IoT）应用中，<code>digitalWrite()</code> 函数通常用于控制LED、继电器、传感器模块等外部设备，以实现各种功能。以下是对 <code>digitalWrite()</code> 函数的详细解释：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">digitalWrite</span>(pin, value);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pin</code>：要控制的数字引脚的引脚号。</li>
<li><code>value</code>：要设置的电平值，可以是 <code>HIGH</code>（高电平，通常表示3.3V或5V）或 <code>LOW</code>（低电平，通常表示0V）。</li>
</ul>
<p><strong>工作原理</strong>：</p>
<ul>
<li><code>digitalWrite()</code> 函数用于将指定引脚的电平状态设置为高电平或低电平。</li>
<li>当指定 <code>pin</code> 为某个数字引脚后，<code>value</code> 参数用于控制该引脚的电平状态。如果 <code>value</code> 为 <code>HIGH</code>，则引脚电平为高电平；如果 <code>value</code> 为 <code>LOW</code>，则引脚电平为低电平。</li>
</ul>
<p><strong>示例用法</strong>：<br>以下是一些使用 <code>digitalWrite()</code> 函数的示例用法：</p>
<ol>
<li><p>控制LED：</p>
<ul>
<li>通过 <code>digitalWrite()</code> 函数，你可以控制数字引脚上连接的LED的开和关。<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ledPin = <span class="number">13</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(ledPin, <span class="literal">OUTPUT</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">digitalWrite</span>(ledPin, <span class="literal">HIGH</span>); <span class="comment">// 打开LED</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 等待1秒</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(ledPin, <span class="literal">LOW</span>); <span class="comment">// 关闭LED</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 等待1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>控制继电器：</p>
<ul>
<li><code>digitalWrite()</code> 可以用于控制继电器，实现开关控制电路的连接和断开。<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> relayPin = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(relayPin, <span class="literal">OUTPUT</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">digitalWrite</span>(relayPin, <span class="literal">HIGH</span>); <span class="comment">// 打开继电器，连接电路</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 等待1秒</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(relayPin, <span class="literal">LOW</span>); <span class="comment">// 关闭继电器，断开电路</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 等待1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>读取开关状态：</p>
<ul>
<li><code>digitalWrite()</code> 可以与 <code>digitalRead()</code> 结合使用，以控制开关状态并读取其状态。<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buttonPin = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> ledPin = <span class="number">13</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(buttonPin, <span class="literal">INPUT</span>);</span><br><span class="line">  <span class="built_in">pinMode</span>(ledPin, <span class="literal">OUTPUT</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> buttonState = <span class="built_in">digitalRead</span>(buttonPin); <span class="comment">// 读取开关状态</span></span><br><span class="line">  <span class="keyword">if</span> (buttonState == <span class="literal">HIGH</span>) &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(ledPin, <span class="literal">HIGH</span>); <span class="comment">// 如果开关打开，点亮LED</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(ledPin, <span class="literal">LOW</span>); <span class="comment">// 如果开关关闭，关闭LED</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><code>digitalWrite()</code> 函数是物联网应用中常用的函数，它允许你控制外部设备的电平状态，从而实现各种控制和交互功能。它可以用于控制LED、继电器、传感器和其他外部设备，使你的IoT设备能够与环境互动并执行特定任务。</p>
<h2 id="IOT-Servo类-详解"><a href="#IOT-Servo类-详解" class="headerlink" title="IOT Servo类 详解"></a>IOT Servo类 详解</h2><p><code>Servo</code> 类是Arduino编程环境中的一个重要类，用于控制舵机（Servo）。舵机是一种旋转执行器，可以精确控制其轴的位置和角度。以下是对Arduino的 <code>Servo</code> 类的详细解释：</p>
<p><strong>创建 Servo 对象</strong>：<br>要使用 <code>Servo</code> 类，首先需要创建一个 <code>Servo</code> 对象。这可以通过以下方式完成：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Servo</span> myservo;</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为 <code>myservo</code> 的 <code>Servo</code> 对象，用于控制一个舵机。</p>
<p><strong>附加舵机</strong>：<br>在使用舵机之前，需要将舵机附加到Arduino板的一个特定引脚上。这可以通过 <code>attach()</code> 函数完成：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myservo.<span class="built_in">attach</span>(pinNumber);</span><br></pre></td></tr></table></figure>

<p>其中 <code>pinNumber</code> 是你想要连接舵机的引脚编号。附加后，<code>myservo</code> 对象将与该引脚相关联，允许你控制舵机的位置。</p>
<p><strong>设置舵机位置</strong>：<br>你可以使用 <code>write()</code> 函数设置舵机的目标位置。位置的范围通常在0到180度之间，具体取决于舵机型号。以下是如何使用 <code>write()</code> 设置舵机位置的示例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myservo.<span class="built_in">write</span>(angle);</span><br></pre></td></tr></table></figure>

<p>其中 <code>angle</code> 是目标位置的角度值。</p>
<p><strong>读取舵机位置</strong>：<br>你可以使用 <code>read()</code> 函数来读取当前舵机的位置。这可以帮助你了解舵机当前所在的角度：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pos = myservo.<span class="built_in">read</span>();</span><br></pre></td></tr></table></figure>

<p><strong>解除附加</strong>：<br>当你完成使用舵机后，可以使用 <code>detach()</code> 函数解除舵机与引脚的连接：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myservo.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure>

<p>这将释放舵机，使其不再受到控制。</p>
<p><strong>多个舵机控制</strong>：<br>如果你需要控制多个舵机，可以创建多个 <code>Servo</code> 对象，并分别将它们附加到不同的引脚上。这样，你可以独立控制多个舵机。</p>
<p><code>Servo</code> 类是一个非常有用的工具，可用于控制舵机的位置和角度，从而实现各种物联网应用，如机器人、相机控制、门锁、遮阳帘等。它提供了一种简单的方式来控制和调整舵机的位置，以满足特定应用的需求。</p>
<h2 id="IOT-Servo-h-头文件-详解"><a href="#IOT-Servo-h-头文件-详解" class="headerlink" title="IOT Servo.h 头文件 详解"></a>IOT Servo.h 头文件 详解</h2><p>在Arduino编程环境中，<code>Servo.h</code> 头文件用于支持和控制舵机（Servo）。这个头文件提供了一系列函数和类，使你能够轻松地控制舵机的位置和角度。以下是关于 <code>Servo.h</code> 头文件的详细解释：</p>
<p><strong>包括头文件</strong>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Servo 类</strong>：</p>
<ul>
<li><code>Servo.h</code> 头文件引入了 <code>Servo</code> 类，它允许你创建一个或多个舵机对象并与它们进行交互。</li>
<li>使用 <code>Servo</code> 类，你可以附加、解除附加和控制舵机的位置。</li>
</ul>
<p><strong>创建 Servo 对象</strong>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Servo</span> servo;</span><br></pre></td></tr></table></figure>

<p><strong>附加舵机</strong>：</p>
<ul>
<li>在你使用舵机之前，需要将舵机附加到一个特定的引脚。</li>
<li>使用 <code>attach()</code> 函数将舵机对象与指定的引脚相连。</li>
<li>示例：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servo.<span class="built_in">attach</span>(pinNumber);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>设置舵机位置</strong>：</p>
<ul>
<li>你可以使用 <code>write()</code> 函数设置舵机的目标位置。位置的范围通常在0到180度之间，具体取决于舵机型号。</li>
<li>示例：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servo.<span class="built_in">write</span>(angle);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>解除附加</strong>：</p>
<ul>
<li>当你完成使用舵机后，可以使用 <code>detach()</code> 函数解除舵机与引脚的连接。</li>
<li>示例：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servo.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>读取舵机位置</strong>：</p>
<ul>
<li>你可以使用 <code>read()</code> 函数读取当前舵机的位置。</li>
<li>示例：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pos = servo.<span class="built_in">read</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>要使用 <code>Servo</code> 类，你需要确保你的Arduino板支持舵机控制。不是所有的引脚都可以用于舵机控制，因此请查阅你的Arduino板的文档以确定可用的引脚。</li>
<li>使用 <code>Servo</code> 类控制多个舵机时，你可以创建多个 <code>Servo</code> 对象，每个对象代表一个舵机。</li>
</ul>
<p>总之，<code>Servo.h</code> 头文件提供了在Arduino中控制舵机的功能，包括附加舵机、设置位置、读取位置等。这使得在物联网应用中实现舵机控制变得更加容易，无论是用于相机控制、机器人运动、门锁或其他应用。使用 <code>Servo</code> 类，你可以精确地控制舵机的位置，以满足特定应用需求。</p>
<h2 id="IOT-Servo-详解"><a href="#IOT-Servo-详解" class="headerlink" title="IOT Servo 详解"></a>IOT Servo 详解</h2><p>在物联网（IoT）应用中，舵机（Servo）是一种常用的执行器，用于控制机械装置的位置或方向。舵机通常用于控制摄像头、机器人、门锁、遮阳帘等物理装置。以下是有关IoT中的舵机的详细解释：</p>
<p><strong>舵机（Servo）</strong>：</p>
<ul>
<li>舵机是一种特殊的旋转执行器，可以精确控制其轴的位置和角度。</li>
<li>舵机通常由电机、电子电路和控制系统组成。</li>
<li>舵机通常用于需要精确控制的应用，例如机器人运动、相机方向控制、门锁控制等。</li>
</ul>
<p><strong>IoT中的舵机应用</strong>：</p>
<ul>
<li>在IoT应用中，舵机可以与各种传感器和控制系统一起使用，以实现自动控制和远程控制功能。</li>
<li>以下是一些IoT中常见的舵机应用示例：<ol>
<li><strong>摄像头控制</strong>：在智能监控摄像头中，舵机可用于控制摄像头的方向和视野，使其能够远程调整视角。</li>
<li><strong>门锁控制</strong>：IoT门锁系统可以使用舵机控制门锁的开关，允许远程开锁或关闭。</li>
<li><strong>遮阳帘控制</strong>：IoT系统可以使用舵机控制窗帘或遮阳帘的开合，以自动适应光线或用户需求。</li>
<li><strong>机器人运动</strong>：IoT中的机器人可以使用舵机控制其关节，实现各种运动和任务。</li>
<li><strong>天线方向调整</strong>：在IoT通信应用中，舵机可用于远程控制天线的方向，以优化信号接收。</li>
</ol>
</li>
</ul>
<p><strong>舵机的控制</strong>：</p>
<ul>
<li>舵机的控制通常涉及到脉冲宽度调制（PWM）信号。</li>
<li>控制舵机时，通过发送不同脉冲宽度的PWM信号，可以指定舵机的位置或角度。</li>
<li>典型的PWM信号范围通常在1毫秒到2毫秒之间，其中1毫秒表示一个极限位置，2毫秒表示另一个极限位置，1.5毫秒通常是中间位置。</li>
<li>舵机的角度范围取决于其型号和设计。</li>
</ul>
<p><strong>舵机的选择</strong>：</p>
<ul>
<li>在IoT应用中，你需要根据特定应用需求选择合适的舵机。</li>
<li>选择舵机时需要考虑其扭矩、工作范围、速度、精度和控制接口等因素。</li>
<li>你还需要考虑电源供应和控制器与IoT系统的集成。</li>
</ul>
<p>总之，舵机是IoT应用中的常见执行器，用于精确控制机械装置的位置和方向。通过与传感器和控制系统的集成，舵机可以用于自动化和远程控制应用，如监控、安全系统、机器人和智能家居。选择适合特定应用需求的舵机非常重要，因为不同的舵机具有不同的性能特征和控制接口。</p>
<h2 id="IOT-pinMode-函数-详解"><a href="#IOT-pinMode-函数-详解" class="headerlink" title="IOT pinMode()函数 详解"></a>IOT pinMode()函数 详解</h2><p><code>pinMode()</code> 函数是用于控制物联网（IoT）设备上的数字引脚（GPIO引脚）的Arduino编程函数。它用于配置特定引脚的工作模式，以指定是作为输入还是输出引脚。以下是对 <code>pinMode()</code> 函数的详细解释：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pinMode</span>(pin, mode);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pin</code>：要配置的引脚的引脚号（数字引脚的编号）。</li>
<li><code>mode</code>：要设置的工作模式，可以是 <code>INPUT</code>、<code>OUTPUT</code>、<code>INPUT_PULLUP</code> 或 <code>INPUT_PULLDOWN</code>。</li>
</ul>
<p>下面是关于 <code>pinMode()</code> 函数中不同工作模式的详细解释：</p>
<ol>
<li><p><strong>INPUT</strong>：</p>
<ul>
<li><code>pinMode(pin, INPUT)</code> 用于将指定引脚配置为输入模式。在输入模式下，引脚将用于接收外部传感器数据或其他外部信号。</li>
<li>通常情况下，你会使用这个模式来读取传感器数据或接收其他外部设备的输入。</li>
</ul>
</li>
<li><p><strong>OUTPUT</strong>：</p>
<ul>
<li><code>pinMode(pin, OUTPUT)</code> 用于将指定引脚配置为输出模式。在输出模式下，引脚可以通过编程控制输出电压高低，驱动外部设备。</li>
<li>你可以使用这个模式来控制LED、电机、继电器或其他执行器。</li>
</ul>
</li>
<li><p><strong>INPUT_PULLUP</strong>：</p>
<ul>
<li><code>pinMode(pin, INPUT_PULLUP)</code> 用于将指定引脚配置为输入模式，并启用上拉电阻。上拉电阻会将引脚拉高，除非外部设备将引脚连接到地（GND）。</li>
<li>这个模式常用于读取开关状态，因为当开关关闭时，引脚将被上拉，当开关打开时，引脚将变为高电平。</li>
</ul>
</li>
<li><p><strong>INPUT_PULLDOWN</strong>：</p>
<ul>
<li><code>pinMode(pin, INPUT_PULLDOWN)</code> 类似于 <code>INPUT_PULLUP</code>，但它启用下拉电阻，将引脚拉低，除非外部设备将引脚连接到电源电压。</li>
<li>这个模式也常用于读取开关状态，但它会在开关打开时将引脚拉低。</li>
</ul>
</li>
</ol>
<p><code>pinMode()</code> 函数是Arduino编程中的一个重要函数，它允许你配置引脚以适应特定的应用需求。通过设置不同的工作模式，你可以实现输入、输出、开关检测和外部设备控制等功能。这对于物联网设备开发非常重要，因为它允许你与传感器和执行器进行交互，并实现各种IoT应用。</p>
<h2 id="IOT-Serial-函数-详解"><a href="#IOT-Serial-函数-详解" class="headerlink" title="IOT Serial 函数 详解"></a>IOT Serial 函数 详解</h2><p>在物联网（IoT）应用中，串口（Serial）函数通常用于进行串口通信，允许物联网设备与其他设备、计算机或外部模块之间进行数据交换。串口通信通常涉及到数据的发送和接收，以便传输命令、数据、状态信息等。以下是串口函数的详细解释，通常用于IoT设备的开发：</p>
<ol>
<li><p>**Serial.begin(baud_rate)**：</p>
<ul>
<li><code>Serial.begin()</code> 函数用于初始化串口通信，并设置波特率（baud rate）。</li>
<li>波特率是数据传输速率的单位，表示每秒传输的位数。通常用来匹配通信的双方，以确保数据正确传输。</li>
<li>例如，<code>Serial.begin(9600)</code> 初始化串口通信，并将波特率设置为9600 bps。</li>
</ul>
</li>
<li><p>**Serial.print() 和 Serial.println()**：</p>
<ul>
<li><code>Serial.print()</code> 和 <code>Serial.println()</code> 函数用于将数据发送到串口。</li>
<li><code>Serial.print()</code> 可以用于发送文本、数字和其他数据，而 <code>Serial.println()</code> 会在发送数据后自动添加换行符，使输出更易读。</li>
<li>例如，<code>Serial.println(&quot;Hello, IoT!&quot;)</code> 会发送字符串 “Hello, IoT!” 到串口，并在末尾添加一个换行符。</li>
</ul>
</li>
<li><p>**Serial.available()**：</p>
<ul>
<li><code>Serial.available()</code> 函数用于检查串口缓冲区中是否有可用的数据。</li>
<li>它返回可用的字节数，以便你可以知道是否有数据可读取。</li>
<li>你可以使用此函数来避免在没有可用数据时读取串口，以避免阻塞。</li>
</ul>
</li>
<li><p>**Serial.read()**：</p>
<ul>
<li><code>Serial.read()</code> 函数用于从串口接收一个字节的数据，并返回其ASCII值（0-255）。</li>
<li>你可以使用这个函数来读取从串口接收的数据。</li>
</ul>
</li>
<li><p>**Serial.write()**：</p>
<ul>
<li><code>Serial.write(data)</code> 函数用于将数据以字节形式发送到串口。</li>
<li><code>data</code> 可以是一个数字（0-255），也可以是一个字符或字节数组。</li>
</ul>
</li>
<li><p>**Serial.flush()**：</p>
<ul>
<li><code>Serial.flush()</code> 函数用于等待输出缓冲区中的所有数据都被发送完毕。这可以确保在关闭串口之前所有数据都被完全发送。</li>
</ul>
</li>
<li><p><strong>实际应用</strong>：</p>
<ul>
<li>串口通信在IoT应用中广泛用于与传感器、执行器、外部设备或计算机之间进行数据交换。</li>
<li>通过串口，IoT设备可以接收传感器数据、发送控制命令、与其他设备进行通信，以及与云服务进行数据传输。</li>
</ul>
</li>
</ol>
<p>串口函数是物联网设备开发中的重要工具，它们用于建立设备之间的通信链路，使设备能够与外部世界进行数据交换。通过适当使用串口函数，你可以实现各种IoT应用，包括数据采集、遥控操作、监控和云连接。</p>
<h2 id="IOT-常用的串口函数-详解"><a href="#IOT-常用的串口函数-详解" class="headerlink" title="IOT 常用的串口函数 详解"></a>IOT 常用的串口函数 详解</h2><p>在物联网（IoT）应用中，串口函数通常用于与传感器、外部设备、计算机或其他微控制器进行数据通信。以下是一些常用的串口函数，它们在IoT设备开发中非常有用：</p>
<ol>
<li><p>**Serial.begin(baud_rate)**：</p>
<ul>
<li><code>Serial.begin()</code> 函数用于初始化串口通信，并设置波特率（baud rate）。</li>
<li>波特率是数据传输速率的单位，表示每秒传输的位数。它需要与通信的对端设备匹配。</li>
<li>例如，<code>Serial.begin(9600)</code> 初始化串口通信，并将波特率设置为9600 bps。</li>
</ul>
</li>
<li><p>**Serial.print() 和 Serial.println()**：</p>
<ul>
<li><code>Serial.print()</code> 和 <code>Serial.println()</code> 函数用于将数据发送到串口。</li>
<li><code>Serial.print()</code> 可以用于发送文本、数字和其他数据，而 <code>Serial.println()</code> 会在发送数据后自动添加换行符，使输出更易读。</li>
<li>例如，<code>Serial.println(&quot;Hello, IoT!&quot;)</code> 会发送字符串 “Hello, IoT!” 到串口，并在末尾添加一个换行符。</li>
</ul>
</li>
<li><p>**Serial.available()**：</p>
<ul>
<li><code>Serial.available()</code> 函数用于检查串口缓冲区中是否有可用的数据。</li>
<li>它返回可用的字节数，以便你可以知道是否有数据可读取。</li>
<li>你可以使用此函数来避免在没有可用数据时读取串口，以避免阻塞。</li>
</ul>
</li>
<li><p>**Serial.read()**：</p>
<ul>
<li><code>Serial.read()</code> 函数用于从串口接收一个字节的数据，并返回其ASCII值（0-255）。</li>
<li>你可以使用这个函数来读取从串口接收的数据。</li>
</ul>
</li>
<li><p>**Serial.write()**：</p>
<ul>
<li><code>Serial.write(data)</code> 函数用于将数据以字节形式发送到串口。</li>
<li><code>data</code> 可以是一个数字（0-255），也可以是一个字符或字节数组。</li>
</ul>
</li>
<li><p>**Serial.flush()**：</p>
<ul>
<li><code>Serial.flush()</code> 函数用于等待输出缓冲区中的所有数据都被发送完毕。这可以确保在关闭串口之前所有数据都被完全发送。</li>
</ul>
</li>
<li><p><strong>其他串口函数</strong>：</p>
<ul>
<li>串口库通常还提供其他功能，如设置数据位数、奇偶校验、停止位数等。这些功能可以根据通信需求进行配置。</li>
</ul>
</li>
</ol>
<p>这些串口函数是物联网设备开发中的常用工具，用于与其他设备、传感器或计算机进行数据通信。它们允许设备接收传感器数据、发送控制指令、与云服务通信，以及与其他设备进行数据交换。在IoT开发中，熟练掌握这些函数非常重要，因为它们是实现各种IoT应用的基础。通过串口通信，IoT设备可以实现数据采集、遥控操作、监控和与其他设备的连接。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Makefile_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Makefile_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">Makefile_基础语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 Makefile 中，有一些内置的变量可以用于表示常见的目录路径。以下是一些常用的 Makefile 内置变量相关的目录：</p>
<ol>
<li><strong><code>$(CURDIR)</code></strong>: 当前工作目录的绝对路径。</li>
<li><strong><code>$(SRCDIR)</code></strong>: 源代码目录的路径。</li>
<li><strong><code>$(INCDIR)</code></strong>: 头文件目录的路径。</li>
<li><strong><code>$(BINDIR)</code></strong>: 可执行文件目录的路径。</li>
<li><strong><code>$(LIBDIR)</code></strong>: 库文件目录的路径。</li>
</ol>
<p>这些内置变量可以用于指定源代码、头文件、可执行文件和库文件的目录路径。你可以根据需要在 Makefile 中使用这些变量，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前工作目录</span></span><br><span class="line">CURRENT_DIR := <span class="variable">$(CURDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 源代码目录</span></span><br><span class="line">SRC_DIR := <span class="variable">$(CURRENT_DIR)</span>/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line">INC_DIR := <span class="variable">$(CURRENT_DIR)</span>/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行文件目录</span></span><br><span class="line">BIN_DIR := <span class="variable">$(CURRENT_DIR)</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 库文件目录</span></span><br><span class="line">LIB_DIR := <span class="variable">$(CURRENT_DIR)</span>/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译选项</span></span><br><span class="line">CXXFLAGS := -std=c++11 -Wall -I<span class="variable">$(INC_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件和可执行文件名</span></span><br><span class="line">TARGET := <span class="variable">$(BIN_DIR)</span>/myapp</span><br><span class="line">OBJS := <span class="variable">$(SRC_DIR)</span>/main.o <span class="variable">$(SRC_DIR)</span>/foo.o <span class="variable">$(SRC_DIR)</span>/bar.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译每个源文件</span></span><br><span class="line"><span class="variable">$(SRC_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.cpp</span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了 <code>$(CURDIR)</code> 变量获取当前工作目录的路径，并根据它构建了其他目录的路径。然后，我们使用这些路径变量来设置源代码、头文件、可执行文件和库文件的路径。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>编写 Makefile 是一种常用的方式来管理和构建 C++ 项目。下面是一个简单的示例 Makefile，展示了如何编写一个基本的 C++ 项目的 Makefile。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译器设置</span></span><br><span class="line">CXX = g++</span><br><span class="line">CXXFLAGS = -std=c++11 -Wall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件和可执行文件名</span></span><br><span class="line">TARGET = myapp</span><br><span class="line">OBJS = main.o foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译每个源文件</span></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了以下内容：</p>
<ul>
<li><code>CXX</code> 和 <code>CXXFLAGS</code> 变量用于设置编译器和编译选项。</li>
<li><code>TARGET</code> 变量用于指定最终生成的可执行文件名。</li>
<li><code>OBJS</code> 变量用于指定目标文件（即编译后的中间文件）。</li>
<li><code>all</code> 是默认目标，用于构建整个项目。它依赖于 <code>$(TARGET)</code>。</li>
<li><code>$(TARGET)</code> 目标用于生成最终的可执行文件。它依赖于 <code>$(OBJS)</code>。</li>
<li><code>%.o</code> 是一个模式规则，用于编译每个源文件。它依赖于对应的 <code>.cpp</code> 文件，并使用 <code>$&lt;</code> 和 <code>$@</code> 分别表示依赖和目标文件。</li>
<li><code>clean</code> 目标用于清理生成的目标文件和可执行文件。</li>
</ul>
<p>你可以根据实际项目的需要进行修改和扩展。例如，你可以添加更多的源文件、头文件目录、链接库等。</p>
<p>要使用上述 Makefile，只需在项目根目录下创建一个名为 <code>Makefile</code>（注意大小写），并将上述内容粘贴到文件中。然后，在项目根目录下执行 <code>make</code> 命令即可构建项目。执行 <code>make clean</code> 可以清理生成的文件。</p>
<p>请注意，Makefile 的编写可能会因具体的项目需求和构建环境而有所差异。上述示例仅为一个简单的起点，你可以根据自己的需要进行进一步的定制和优化。同时，还可以考虑使用更高级的构建工具和自动化构建系统（如 CMake、Autotools 等）来管理更复杂的项目。</p>
<h2 id="书写规则："><a href="#书写规则：" class="headerlink" title="书写规则："></a>书写规则：</h2><ul>
<li>依赖关系：生成目标的方法</li>
</ul>
<h2 id="规则语法："><a href="#规则语法：" class="headerlink" title="规则语法："></a>规则语法：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">targets:prerequisites</span><br><span class="line">    command</span><br><span class="line">targets：文件名，以空格分开，可以使用通配符</span><br><span class="line">command：命令行，如果不与prerequisites在一行，必须在下一行以Tab键开头，如果在一行，用分号做分割</span><br><span class="line">prerequisites：目标所依赖的文件</span><br><span class="line">反斜杠（\）：换行符</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li><code>make -C dir</code>, <code>--directory=dir</code> : Change to directory <code>dir</code> before reading the makefiles or doing anything else.</li>
</ul>
<h2 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h2><ul>
<li><p>变量在声明时，需要给予初值，而在使用时，需要给变量名前加上$符号，并且用小括号括起来</p>
</li>
<li><p>makefile中变量分为环境变量，内置变量和自动变量</p>
</li>
<li><p><strong>环境变量</strong></p>
<ul>
<li><code>DESKTOP_SESSION</code> : ubuntu</li>
<li><code>XDG_SESSION_TYPE</code>: x11</li>
<li><code>XAUTHORITY</code>      : &#x2F;run&#x2F;user&#x2F;1000&#x2F;gdm&#x2F;Xauthority</li>
<li><code>_</code>               : &#x2F;usr&#x2F;bin&#x2F;make</li>
</ul>
</li>
<li><p><strong>自动变量</strong></p>
<ul>
<li><code>$@</code> : 表示规则的目标文件名</li>
<li><code>$&lt;</code> : 规则的第一个依赖文件名。如果是一个目标文件使用隐含规则来重建，则代表由隐含规则加入的第一个依赖文件</li>
<li><code>$^</code> : 规则的所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有库成员(.0文件)名。一个文件可重复的出现在目标的依赖中，变量<code>$^</code>只记录它的一次引用情况。就是说变量<code>$^</code>会去掉重复的依赖文件。</li>
<li><code>$+</code> : 类似于<code>$^</code>，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合</li>
</ul>
</li>
<li><p><strong>内置变量</strong></p>
<ul>
<li><code>$(CURDIR)</code> : 显示当前路径</li>
<li><code>$(SHELL)</code>  : &#x2F;bin&#x2F;sh</li>
<li><code>$(CC)</code>     : cc , C语言编译器的名称</li>
<li><code>$(CPP)</code>    : $(CC) -E ， C语言预处理器的名称</li>
<li><code>$(CXX)</code>    : g++ , C++语言的编译器的名称</li>
<li><code>$(RM)</code>     : rm -f , 删除文件程序的名称</li>
<li><code>$(CFLAGS)</code> : C语言编译器的编译选项，无默认值</li>
<li><code>$(CXXFLAGS)</code>: C++语言编译器的编译选项，无默认值</li>
</ul>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p><code>?=</code></p>
<ul>
<li>条件变量分配运算符，它仅在尚未定义的变量时具有效果</li>
</ul>
</li>
<li><p><code>+=</code></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">variable = main.o merge.o</span><br><span class="line">variable += delete.o</span><br><span class="line"># ALL:$(variable)</span><br><span class="line">all:</span><br><span class="line">	@echo $&#123;variable&#125; </span><br><span class="line"># 输出: main.o merge.o delete.o</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p><code>$(abspath names...)</code> : 获取文件的绝对地址 </p>
</li>
<li><p><code>ifeq (condition1, condition2) ... endif</code>   </p>
<ul>
<li>如果<code>condition1</code> 等于 <code>conditon2</code> , 则执行下面的操作，否则不执行</li>
</ul>
</li>
<li><p><code>$&#123;addprefix &quot;前缀&quot;, filenames...&#125;</code>  </p>
<ul>
<li>为文件加前缀<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">variable = main.o merge.o</span><br><span class="line">variable += delete.o</span><br><span class="line">var = $&#123;addprefix -x/, $&#123;variable&#125;&#125;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	@echo $&#123;var&#125; </span><br><span class="line"><span class="comment"># 输出: -x/main.o -x/merge.o -x/delete.o</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>$&#123;wildcard /home/user/workspace/shell/*.sh&#125;</code>  </p>
<ul>
<li>获取指定路径下的指定文件<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var = $&#123;wildcard ./*.txt&#125;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	@echo $&#123;var&#125; </span><br><span class="line"><span class="comment"># 输出: ./foo.txt ./bar.txt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>$&#123;patsubst pattern, replacement, text&#125;</code> </p>
<ul>
<li>根据相应规则替换文件名<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var = $&#123;wildcard ./*.txt&#125;</span><br><span class="line">pat = $&#123;patsubst %.txt, %.md, $&#123;var&#125;&#125;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	@echo $&#123;var&#125; </span><br><span class="line">	@echo $&#123;pat&#125;</span><br><span class="line"><span class="comment"># 输出: ./foo.txt ./bar.txt   \  ./foo.md ./bar.md</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="Makefile中获取当前执行的Makefile所在路径"><a href="#Makefile中获取当前执行的Makefile所在路径" class="headerlink" title="Makefile中获取当前执行的Makefile所在路径"></a>Makefile中获取当前执行的Makefile所在路径</h3><ul>
<li><p>Linux下我们可以用pwd命令来获取当前所执行命令的目录，在Makefile中对应可用<code>PWD := $(shell pwd)</code>来获取。</p>
</li>
<li><p>但是如果子Makefile 文件是从别处执行的(通过<code>make -f .../Makefile</code> 执行)，那么<code>$(shell pwd)</code>得到的目录即为执行<code>make -f</code>命令的当前目录</p>
</li>
<li><p>在这种情况下</p>
<ul>
<li>根据gnu make定义，<code>gnu make</code> 会自动将所有读取的<code>makefile</code>路径都会加入到<code>MAKEFILE_LIST</code>变量中，而且是按照读取的先后顺序添加</li>
<li>所以可以通过<code>$(abspath $(lastword $(MAKEFILE_LIST)))</code>返回当前正在被执行的<code>Makefile</code>的绝对路径,然后通过<code>patsubst</code>去掉文件名得到绝对目录</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">makefile_path:=<span class="variable">$(<span class="built_in">abspath</span> $(<span class="built_in">lastword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span>)</span><br><span class="line">cur_makefile_path:=<span class="variable">$(<span class="built_in">patsubst</span> %/makefile, %/, $&#123;<span class="built_in">shell</span> ls <span class="variable">$(makefile_path)</span>&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	@echo $&#123;makefile_path&#125;</span><br><span class="line">	@echo $&#123;cur_makefile_path&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Nginx/" class="post-title-link" itemprop="url">Nginx</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>nginx 相关理论知识</li>
</ul>
<h2 id="nginx-是什么"><a href="#nginx-是什么" class="headerlink" title="nginx 是什么"></a>nginx 是什么</h2><p>Nginx（发音为”engine-x”）是一个开源的高性能的Web服务器和反向代理服务器。它最初由伊戈尔·赛索耶夫（Igor Sysoev）创建，并于2004年首次发布。Nginx专注于高并发性能、低资源消耗和稳定性，使其成为许多互联网公司和网站的首选Web服务器。</p>
<p>主要特点包括：</p>
<ol>
<li><p><strong>高性能：</strong> Nginx被设计为能够处理大量并发连接而不陷入性能问题。它采用事件驱动、非阻塞的架构，能够高效地处理数千个同时连接。</p>
</li>
<li><p><strong>低资源消耗：</strong> 相比一些传统的Web服务器，Nginx使用较少的内存和CPU资源，这使其在资源有限的环境中表现出色。</p>
</li>
<li><p><strong>反向代理：</strong> Nginx可以作为反向代理服务器，将请求从客户端传递到后端服务器，然后将响应返回给客户端。这使得它在负载均衡和提高应用程序性能方面非常有用。</p>
</li>
<li><p><strong>静态文件服务：</strong> Nginx优化了对静态文件的服务，能够快速地提供图片、CSS、JavaScript等静态文件，减轻了动态内容生成的压力。</p>
</li>
<li><p><strong>模块化设计：</strong> Nginx的模块化结构使得用户可以方便地扩展其功能，添加新的特性和功能。</p>
</li>
</ol>
<p>由于其性能和灵活性，Nginx常被用于搭建高流量的网站和应用，同时也广泛用于反向代理、负载均衡、缓存等场景。</p>
<h2 id="nginx-详解"><a href="#nginx-详解" class="headerlink" title="nginx 详解"></a>nginx 详解</h2><p>Nginx（发音为“engine-x”）是一个高性能的开源Web服务器软件，也可以用作反向代理服务器、负载均衡器和HTTP缓存等。在进行Nginx配置时，主要是编辑Nginx的配置文件，通常是<code>nginx.conf</code>，以及可能的其他配置文件，如虚拟主机配置文件等。以下是一个简要的Nginx配置详解：</p>
<ol>
<li><p><strong>基本语法和结构</strong>：<br>Nginx的配置文件使用简单的语法，主要由指令和块构成，块内可以包含多个指令。配置文件通常分为全局配置、http块和server块等。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"></span><br><span class="line"><span class="comment"># http块</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># http全局配置</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># server块</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># server配置</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>监听端口和虚拟主机</strong>：<br>使用<code>server</code>块可以配置虚拟主机，允许在同一台服务器上通过不同的域名或IP地址提供不同的网站。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 配置处理请求的规则</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反向代理和负载均衡</strong>：<br>Nginx经常被用作反向代理服务器，将客户端请求代理到后端服务器，并可以进行负载均衡以提高性能和可靠性。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> myapp.com;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_servers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> backend_servers &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态文件服务</strong>：<br>Nginx可以高效地提供静态文件，从而减轻后端服务器的负担。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> static.example.com;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /path/to/static/files;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SSL&#x2F;TLS加密</strong>：<br>配置Nginx支持安全的SSL&#x2F;TLS连接，用于加密数据传输。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> secure.example.com;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">ssl_certificate</span> /path/to/cert.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/cert.key;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># SSL配置</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重定向和URL重写</strong>：<br>Nginx可以执行URL的重定向和重写，以实现网站访问路径的优化和规范化。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> old-example.com;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^</span> https://new-example.com<span class="variable">$request_uri</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上只是Nginx配置的一些常见方面，实际上Nginx提供了丰富的配置选项，可以根据具体需求进行更复杂的配置。在编写Nginx配置文件时，建议参考官方文档以及其他可靠的资源，以确保正确配置并确保服务器的安全和性能。</p>
<h2 id="nginx-配置代理转发-示例"><a href="#nginx-配置代理转发-示例" class="headerlink" title="nginx 配置代理转发 示例"></a>nginx 配置代理转发 示例</h2><p>以下是一个基本的Nginx配置示例，用于将客户端请求代理转发到后端服务器。在这个示例中，Nginx将监听80端口，将客户端请求代理到名为<code>backend_server</code>的后端服务器。请根据您的实际情况进行适当的修改。</p>
<ol>
<li><p><strong>安装和启动Nginx</strong>：<br>在安装和启动Nginx之前，请确保您已经正确安装了Nginx，并且配置文件位于<code>/etc/nginx/nginx.conf</code>。以下是示例配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置代理转发</strong>：<br>在配置文件夹中创建一个新的文件，例如<code>/etc/nginx/conf.d/proxy.conf</code>，并添加以下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_server;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，将<code>your_domain.com</code>替换为您的域名，<code>backend_server</code>替换为实际的后端服务器地址（可以是IP地址或域名）。</p>
</li>
<li><p><strong>重新加载Nginx配置</strong>：<br>在进行任何配置更改后，都需要重新加载Nginx配置，以便使更改生效。使用以下命令重新加载Nginx配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nginx -t   <span class="comment"># 检查配置是否正确</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl reload nginx</span><br></pre></td></tr></table></figure>

<p>如果没有错误，Nginx将重新加载配置。</p>
</li>
</ol>
<p>这样，当客户端发送请求到您的域名（例如<code>http://your_domain.com</code>），Nginx将会代理转发请求到指定的后端服务器。在实际应用中，您可能还需要配置SSL&#x2F;TLS以实现安全的HTTPS连接，以及其他一些高级配置，取决于您的需求。</p>
<h2 id="nginx-模块化编程"><a href="#nginx-模块化编程" class="headerlink" title="nginx 模块化编程"></a>nginx 模块化编程</h2><p>Nginx支持模块化编程，允许您根据需求添加自定义功能和扩展。Nginx模块可以分为核心模块和第三方模块。核心模块是Nginx自带的，而第三方模块则是由社区或个人开发的。</p>
<p>下面是一个简要的Nginx模块化编程概述：</p>
<ol>
<li><p><strong>核心模块</strong>：<br>Nginx的核心模块包括各种基本功能，如HTTP、事件处理、文件I&#x2F;O等。核心模块在编译Nginx时包含在内，无需额外安装。例如：</p>
<ul>
<li><code>ngx_http_core_module</code>：处理HTTP请求、URI解析和请求分发。</li>
<li><code>ngx_http_proxy_module</code>：实现反向代理功能。</li>
<li><code>ngx_event_core_module</code>：管理事件循环和异步I&#x2F;O。</li>
<li><code>ngx_http_ssl_module</code>：提供SSL&#x2F;TLS支持等。</li>
</ul>
</li>
<li><p><strong>第三方模块</strong>：<br>第三方模块是由Nginx社区或个人开发的扩展，可以添加额外的功能和定制化选项。您可以选择性地将第三方模块添加到Nginx中。以下是一些常见的第三方模块示例：</p>
<ul>
<li><code>ngx_http_geoip_module</code>：使用GeoIP数据库进行地理位置识别。</li>
<li><code>ngx_http_lua_module</code>：在Nginx配置中嵌入Lua脚本。</li>
<li><code>ngx_http_gzip_static_module</code>：提供静态Gzip压缩功能。</li>
<li><code>ngx_http_upstream_module</code>：扩展负载均衡选项等。</li>
</ul>
</li>
<li><p><strong>编写自定义模块</strong>：<br>如果您需要添加特定的自定义功能，您可以编写自己的Nginx模块。编写Nginx模块需要对C语言编程有一定的了解。基本的步骤包括：</p>
<ul>
<li>编写模块代码：创建一个C文件，并实现模块的处理逻辑，例如请求处理、配置解析等。</li>
<li>修改配置：在Nginx配置文件中添加模块相关的配置指令。</li>
<li>编译安装：将模块源代码编译到Nginx中。</li>
</ul>
<p>请注意，编写自定义模块可能需要深入理解Nginx的内部机制和事件处理流程。在编写模块之前，建议您详细阅读Nginx的模块开发文档和示例。</p>
</li>
</ol>
<p>总之，Nginx的模块化架构使其非常灵活，可以根据需求轻松添加或定制功能。无论是使用核心模块还是第三方模块，都能够扩展Nginx的功能以满足不同的需求。</p>
<h2 id="linux下nginx配置-详解"><a href="#linux下nginx配置-详解" class="headerlink" title="linux下nginx配置 详解"></a>linux下nginx配置 详解</h2><p>在Linux系统下，Nginx的配置文件通常是<code>nginx.conf</code>。下面是一个简单的Nginx配置文件的详解：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局块</span></span><br><span class="line"><span class="attribute">user</span> nginx;         <span class="comment"># Nginx worker进程运行的用户</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">4</span>;  <span class="comment"># 启动的worker进程数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># error_log定义错误日志的路径</span></span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log <span class="literal">warn</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># events块定义Nginx的事件模型</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;  <span class="comment"># 每个worker进程允许的最大连接数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># http块是配置HTTP服务器的主要部分</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># server块定义具体的虚拟主机</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;  <span class="comment"># 监听的端口</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">server_name</span> example.com;  <span class="comment"># 域名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># location块定义不同URL的行为</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /path/to/your/files;  <span class="comment"># 根目录</span></span><br><span class="line">            <span class="attribute">index</span> index.html;          <span class="comment"># 默认首页</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># location块可以有多个，用于处理不同的URL</span></span><br><span class="line">        <span class="section">location</span> /api &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend-server;  <span class="comment"># 反向代理到后端服务器</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 静态文件缓存</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.(jpg|jpeg|png|gif|ico|css|js)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">1y</span>;</span><br><span class="line">            <span class="attribute">add_header</span> Cache-Control <span class="string">&quot;public, max-age=31536000&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 错误页面配置</span></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">        <span class="section">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">            internal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># SSL配置</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">ssl_certificate</span> /path/to/your/ssl_certificate.crt;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /path/to/your/ssl_certificate.key;</span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span> <span class="string">&#x27;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&#x27;</span>;</span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述配置文件简单地说明了Nginx的一些基本配置，包括全局配置、事件模型、HTTP服务器、虚拟主机、URL处理、反向代理、静态文件缓存、错误页面和SSL配置等。你可以根据自己的需要进行调整和扩展。</p>
<p>请注意，实际配置可能会根据具体的使用场景和需求有所不同。详细的配置可以查阅<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/">Nginx官方文档</a>。</p>
<h2 id="linux-web服务器-nginx反向代理是什么"><a href="#linux-web服务器-nginx反向代理是什么" class="headerlink" title="linux web服务器 nginx反向代理是什么"></a>linux web服务器 nginx反向代理是什么</h2><p>Nginx的反向代理是一种服务器架构，其中Nginx服务器接收客户端的请求，并将这些请求转发给后端的一组服务器。反向代理隐藏了真实的服务器，使得客户端无法直接访问到后端服务器，而是通过反向代理服务器进行中转。</p>
<p>具体来说，Nginx反向代理的工作流程如下：</p>
<ol>
<li><p><strong>客户端发送请求：</strong> 客户端发送HTTP请求到Nginx服务器。</p>
</li>
<li><p><strong>Nginx接收请求：</strong> Nginx服务器接收到客户端的请求。</p>
</li>
<li><p><strong>反向代理处理：</strong> 根据配置，Nginx决定将请求转发给后端的哪个服务器。这个后端服务器可以是一个应用服务器、负载均衡器，或者其他类型的服务器。</p>
</li>
<li><p><strong>向后端服务器发送请求：</strong> Nginx将接收到的请求转发给后端服务器。</p>
</li>
<li><p><strong>后端服务器处理请求：</strong> 后端服务器处理请求，并生成响应。</p>
</li>
<li><p><strong>响应返回给客户端：</strong> 后端服务器将生成的响应返回给Nginx。</p>
</li>
<li><p><strong>Nginx返回响应给客户端：</strong> Nginx将接收到的响应返回给客户端，客户端认为是直接从Nginx获取的响应。</p>
</li>
</ol>
<p>反向代理的优点包括：</p>
<ul>
<li><p><strong>负载均衡：</strong> 可以实现负载均衡，将请求分发到多个后端服务器，防止单一服务器负载过大。</p>
</li>
<li><p><strong>隐藏后端服务器：</strong> 客户端无法直接访问到后端服务器，增加了安全性。</p>
</li>
<li><p><strong>缓存和压缩：</strong> Nginx可以对后端服务器的响应进行缓存和压缩，提高性能。</p>
</li>
<li><p><strong>SSL终结：</strong> 可以在Nginx上进行SSL终结，解密加密的流量，减轻后端服务器的负担。</p>
</li>
</ul>
<p>反向代理是一种常见的服务器架构，特别适用于需要提高可用性、安全性和性能的场景。</p>
<h2 id="常见的服务器架构有哪些？"><a href="#常见的服务器架构有哪些？" class="headerlink" title="常见的服务器架构有哪些？"></a>常见的服务器架构有哪些？</h2><p>有许多常见的服务器架构，每种都有其适用的场景和优势。以下是一些常见的服务器架构类型：</p>
<ol>
<li><p><strong>单层架构（Single-Tier Architecture）：</strong></p>
<ul>
<li>单层架构是最简单的架构形式，将应用程序、数据库和用户界面等功能集成在一个单一的层中。</li>
<li>适用于小型应用和测试环境，但在大型和复杂应用中使用较少。</li>
</ul>
</li>
<li><p><strong>两层架构（Two-Tier Architecture）：</strong></p>
<ul>
<li>由客户端层和服务器层组成，客户端负责用户界面，而服务器负责处理业务逻辑和数据存储。</li>
<li>常见于传统的客户端-服务器应用，例如数据库应用。</li>
</ul>
</li>
<li><p><strong>三层架构（Three-Tier Architecture）：</strong></p>
<ul>
<li>包括客户端层、应用服务器层和数据库服务器层。</li>
<li>分离业务逻辑、数据处理和用户界面，提高灵活性和可维护性。</li>
</ul>
</li>
<li><p><strong>微服务架构（Microservices Architecture）：</strong></p>
<ul>
<li>将应用程序拆分成小型、独立的服务，每个服务专注于特定的业务功能。</li>
<li>提供弹性、可伸缩性和独立部署的优势，适用于大型、复杂的分布式系统。</li>
</ul>
</li>
<li><p><strong>服务导向架构（Service-Oriented Architecture, SOA）：</strong></p>
<ul>
<li>将应用程序拆分为可重用的服务，这些服务通过网络进行通信。</li>
<li>促进了松耦合和模块化，使得系统更易于维护和扩展。</li>
</ul>
</li>
<li><p><strong>反向代理架构（Reverse Proxy Architecture）：</strong></p>
<ul>
<li>使用反向代理服务器作为前端，将请求转发给后端服务器，隐藏真实的服务器。</li>
<li>常用于负载均衡、安全性增强和性能优化。</li>
</ul>
</li>
<li><p><strong>无服务器架构（Serverless Architecture）：</strong></p>
<ul>
<li>应用程序的开发和运行无需关心底层的服务器和基础设施。</li>
<li>利用云服务提供商的无服务器计算服务，按需执行代码。</li>
</ul>
</li>
</ol>
<p>这些架构类型根据应用程序的规模、需求和特点选择，每种架构都有其优势和劣势。在实际应用中，也可以采用混合架构，结合不同的组件和服务来满足特定的需求。</p>
<h2 id="在linux下使用nginx构建反响代理架构服务器"><a href="#在linux下使用nginx构建反响代理架构服务器" class="headerlink" title="在linux下使用nginx构建反响代理架构服务器"></a>在linux下使用nginx构建反响代理架构服务器</h2><p>在Linux下使用Nginx构建反向代理架构的服务器是相对简单的。以下是基本步骤：</p>
<h3 id="步骤一：安装Nginx"><a href="#步骤一：安装Nginx" class="headerlink" title="步骤一：安装Nginx"></a>步骤一：安装Nginx</h3><p>确保你的Linux系统中已经安装了Nginx。使用包管理工具，如<code>apt</code>、<code>yum</code>或<code>dnf</code>，执行以下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于基于Debian的系统（例如Ubuntu）</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于基于Red Hat的系统（例如CentOS）</span></span><br><span class="line"><span class="built_in">sudo</span> yum install epel-release</span><br><span class="line"><span class="built_in">sudo</span> yum install nginx</span><br></pre></td></tr></table></figure>

<h3 id="步骤二：编辑Nginx配置文件"><a href="#步骤二：编辑Nginx配置文件" class="headerlink" title="步骤二：编辑Nginx配置文件"></a>步骤二：编辑Nginx配置文件</h3><p>Nginx的主配置文件通常位于 <code>/etc/nginx/nginx.conf</code> 或 <code>/etc/nginx/conf.d/default.conf</code>。你可以使用文本编辑器（如<code>nano</code>或<code>vim</code>）编辑该文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure>

<p>在配置文件中，你需要配置反向代理的相关设置。以下是一个简单的例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;  <span class="comment"># 替换成你的域名或服务器IP</span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_server;  <span class="comment"># 替换成你的后端服务器地址</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保替换 <code>your_domain.com</code> 为你的域名或服务器IP，并将 <code>http://backend_server</code> 替换为你的后端服务器地址。</p>
<h3 id="步骤三：重启Nginx"><a href="#步骤三：重启Nginx" class="headerlink" title="步骤三：重启Nginx"></a>步骤三：重启Nginx</h3><p>完成配置后，保存并退出编辑器。然后，重新启动Nginx以使配置生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart nginx</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>你可能需要调整防火墙规则，确保Nginx监听的端口是开放的。</li>
<li>确保后端服务器上的应用程序正常运行，并且Nginx能够访问它。</li>
</ul>
<p>这只是一个简单的反向代理配置示例。实际应用中，你可能还需要考虑负载均衡、SSL&#x2F;TLS设置、缓存等其他配置，具体根据你的需求进行调整。请查阅<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/">Nginx官方文档</a>以获取更多详细信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-ModBus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-ModBus/" class="post-title-link" itemprop="url">ModBus</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ModBus 相关理论知识</li>
</ul>
<h2 id="Contexts-上下文-资源句柄"><a href="#Contexts-上下文-资源句柄" class="headerlink" title="Contexts 上下文 资源句柄"></a>Contexts 上下文 资源句柄</h2><ul>
<li>使用 modbus_new_rtu 申请，返回一个 modbus_t ，它包含所有必要的数据</li>
</ul>
<h2 id="modbus-协议-详解"><a href="#modbus-协议-详解" class="headerlink" title="modbus 协议 详解"></a>modbus 协议 详解</h2><p>Modbus（Modular Communications System）是一种通信协议，用于在不同设备之间进行数据通信和控制。它通常用于工业自动化领域，用于连接和控制各种设备，如传感器、执行器、PLC（可编程逻辑控制器）等。Modbus协议的详解包括以下几个方面：</p>
<ol>
<li><p><strong>协议类型</strong>：</p>
<ul>
<li>Modbus RTU：基于串行通信，以二进制格式传输数据。</li>
<li>Modbus ASCII：也是基于串行通信，但以ASCII字符形式传输数据。</li>
<li>Modbus TCP：基于TCP&#x2F;IP网络通信，用于以太网连接。</li>
</ul>
</li>
<li><p><strong>通信方式</strong>：</p>
<ul>
<li>Modbus是主从（Master-Slave）协议，其中有一个主设备（主站）可以向多个从设备（从站）发送请求，并接收它们的响应。</li>
<li>主站发出请求，从站回应请求，并提供所需的数据。</li>
</ul>
</li>
<li><p><strong>数据格式</strong>：</p>
<ul>
<li>Modbus通信包括读（读取从站的数据）和写（向从站写入数据）操作。</li>
<li>请求和响应消息通常包括功能码、数据字段、CRC校验等部分。</li>
</ul>
</li>
<li><p><strong>寄存器</strong>：</p>
<ul>
<li>Modbus协议使用寄存器来表示数据，寄存器可以是输入寄存器、保持寄存器、输入状态、线圈状态等不同类型。</li>
<li>输入寄存器通常用于表示只读数据，如传感器读数。</li>
<li>保持寄存器通常用于表示读写数据，如控制器的设置参数。</li>
</ul>
</li>
<li><p><strong>功能码</strong>：</p>
<ul>
<li>功能码用于指定要执行的操作，如读取输入寄存器、写入保持寄存器等。</li>
<li>常见的功能码包括读操作（功能码 3 和功能码 4）和写操作（功能码 6 和功能码 16）。</li>
</ul>
</li>
<li><p><strong>异常处理</strong>：</p>
<ul>
<li>Modbus协议包括异常码，用于指示错误情况，如无效功能码、寄存器不可用等。</li>
<li>异常响应通常包含一个特殊的异常功能码，以及一个描述异常的代码。</li>
</ul>
</li>
<li><p><strong>通信速率</strong>：</p>
<ul>
<li>Modbus RTU和Modbus ASCII的通信速率通常在9600、19200、38400等不同速率之间选择。</li>
<li>Modbus TCP通常使用以太网连接，通信速率由以太网规范确定。</li>
</ul>
</li>
<li><p><strong>安全性</strong>：</p>
<ul>
<li>Modbus协议在设计上没有内置安全性，因此在需要安全通信的环境中，通常需要使用其他协议或方法来加强安全性。</li>
</ul>
</li>
</ol>
<p>总的来说，Modbus协议是一种用于在工业自动化环境中进行设备间通信和控制的标准化协议。它有多种变体和实现，可以根据不同的通信需求和硬件来选择合适的协议类型。 Modbus协议的详细规范可以在Modbus.org等资源中找到。如果需要使用Modbus协议，通常需要查看相关设备的文档以了解如何配置和使用它。</p>
<h2 id="CRC-详解"><a href="#CRC-详解" class="headerlink" title="CRC 详解"></a>CRC 详解</h2><p>CRC (Cyclic Redundancy Check) 是一种错误检测码，用于验证数据的完整性。它是一种快速且广泛应用的校验算法，常用于通信协议、存储设备、网络传输等领域。</p>
<p>CRC 的基本原理是通过对数据进行多项式计算来生成校验值，这个校验值称为 CRC 值。发送方在传输数据前，会计算数据的 CRC 值，并将该值附加到数据后面一并传输。接收方在接收到数据后，也会计算接收到的数据的 CRC 值，并与接收到的 CRC 值进行比较。如果两个 CRC 值匹配，表示数据没有出现错误；如果 CRC 值不匹配，表示数据可能在传输过程中发生了错误或被篡改。</p>
<p>CRC 的特点包括：</p>
<ol>
<li><p>快速：CRC 是一种非常快速的校验算法，适用于实时数据传输和处理。</p>
</li>
<li><p>简单：CRC 的实现相对简单，通常用位操作来处理数据和多项式计算。</p>
</li>
<li><p>检测能力：CRC 能够检测不少常见的错误，但并不是绝对可靠，无法检测所有错误。</p>
</li>
<li><p>冗余：CRC 增加了一定的冗余数据，用于检测错误。</p>
</li>
</ol>
<p>在使用 CRC 时，需要事先定义一个生成多项式。不同的 CRC 标准使用不同的多项式，常见的标准有 CRC-16、CRC-32 等。选择合适的 CRC 标准取决于具体应用的要求。</p>
<p>总体而言，CRC 是一种简单、高效且广泛应用的错误检测码。它在数据传输和存储中起着重要的作用，帮助保障数据的完整性和可靠性。</p>
<h2 id="linux-libmodbus-库-详解"><a href="#linux-libmodbus-库-详解" class="headerlink" title="linux libmodbus 库 详解"></a>linux libmodbus 库 详解</h2><p><code>libmodbus</code> 是一个用于通信协议 Modbus 的开源C库，用于实现 Modbus 协议的通信。Modbus 是一种通信协议，用于连接工业自动化设备，使它们能够在不同设备之间进行数据传输。以下是关于 <code>libmodbus</code> 库的详细信息：</p>
<p><strong>安装 libmodbus 库</strong>：</p>
<p>你可以使用你的 Linux 发行版的包管理器来安装 <code>libmodbus</code> 库。例如，如果你使用的是 Ubuntu，可以使用以下命令安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libmodbus-dev</span><br></pre></td></tr></table></figure>

<p><strong>使用 libmodbus 库</strong>：</p>
<p>以下是一些关于 <code>libmodbus</code> 库的基本使用方法和功能：</p>
<ol>
<li><p><strong>创建 modbus 上下文</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">modbus_t</span>* ctx = modbus_new_rtu(<span class="string">&quot;/dev/ttyUSB0&quot;</span>, <span class="number">9600</span>, <span class="string">&#x27;N&#x27;</span>, <span class="number">8</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个用于串口通信的 Modbus 上下文。</p>
</li>
<li><p><strong>连接到 Modbus 设备</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (modbus_connect(ctx) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Connection failed&quot;</span>);</span><br><span class="line">    modbus_free(ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>modbus_connect</code> 函数连接到 Modbus 设备。</p>
</li>
<li><p><strong>读取和写入 Modbus 寄存器</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> data[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> num = modbus_read_registers(ctx, <span class="number">0</span>, <span class="number">5</span>, data);</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> value = <span class="number">1234</span>;</span><br><span class="line">modbus_write_register(ctx, <span class="number">10</span>, value);</span><br></pre></td></tr></table></figure>

<p>使用 <code>modbus_read_registers</code> 函数读取寄存器数据，使用 <code>modbus_write_register</code> 函数写入寄存器数据。</p>
</li>
<li><p><strong>关闭连接并释放资源</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modbus_close(ctx);</span><br><span class="line">modbus_free(ctx);</span><br></pre></td></tr></table></figure>

<p>在完成通信后，使用 <code>modbus_close</code> 函数关闭连接，并使用 <code>modbus_free</code> 函数释放资源。</p>
</li>
<li><p><strong>其他功能</strong>：</p>
<p><code>libmodbus</code> 还提供了其他一些功能，如 Modbus TCP&#x2F;IP 支持、异常处理、不同寄存器类型的读写等。</p>
</li>
</ol>
<p><code>libmodbus</code> 库使得在 Linux 下实现 Modbus 协议通信变得更加容易。你可以查阅官方文档或在线教程，深入了解 <code>libmodbus</code> 库的更多功能和用法。在编程中，你可以根据需要使用合适的函数来实现 Modbus 通信，并根据通信需求进行相应的设置和处理。</p>
<h2 id="linux-libmodbus-库-使用-详解-示例"><a href="#linux-libmodbus-库-使用-详解-示例" class="headerlink" title="linux libmodbus 库 使用 详解 示例"></a>linux libmodbus 库 使用 详解 示例</h2><p>下面是一个使用 <code>libmodbus</code> 库进行 Modbus 通信的简单示例。在这个示例中，我们将使用 Modbus RTU 通信协议通过串口与 Modbus 设备通信，并读取一些寄存器的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;modbus.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">modbus_t</span> *ctx;</span><br><span class="line">    <span class="type">uint16_t</span> data[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Modbus 上下文，串口路径为 &quot;/dev/ttyUSB0&quot;，波特率为 9600</span></span><br><span class="line">    ctx = modbus_new_rtu(<span class="string">&quot;/dev/ttyUSB0&quot;</span>, <span class="number">9600</span>, <span class="string">&#x27;N&#x27;</span>, <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to create Modbus context\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到 Modbus 设备</span></span><br><span class="line">    <span class="keyword">if</span> (modbus_connect(ctx) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Connection failed: %s\n&quot;</span>, modbus_strerror(errno));</span><br><span class="line">        modbus_free(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取寄存器数据，起始地址为 0，读取 5 个寄存器</span></span><br><span class="line">    <span class="type">int</span> num = modbus_read_registers(ctx, <span class="number">0</span>, <span class="number">5</span>, data);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Read error: %s\n&quot;</span>, modbus_strerror(errno));</span><br><span class="line">        modbus_close(ctx);</span><br><span class="line">        modbus_free(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印读取的寄存器值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Register %d: %d\n&quot;</span>, i, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接并释放资源</span></span><br><span class="line">    modbus_close(ctx);</span><br><span class="line">    modbus_free(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了一个 Modbus 上下文 <code>ctx</code>，然后使用 <code>modbus_connect</code> 函数连接到 Modbus 设备。接着，使用 <code>modbus_read_registers</code> 函数读取起始地址为 0 的连续 5 个寄存器的值。最后，我们打印出读取的寄存器值，并在完成通信后关闭连接和释放资源。</p>
<p>请注意，此示例是一个基本的用法演示。在实际应用中，你可能需要根据 Modbus 设备的配置和通信需求进行适当的设置和处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-OpenGL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-OpenGL/" class="post-title-link" itemprop="url">OpenGL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>OpenGL和图形应用程序开发相关基础知识笔记</li>
</ul>
<h2 id="GLFW-是什么"><a href="#GLFW-是什么" class="headerlink" title="GLFW 是什么"></a>GLFW 是什么</h2><p>GLFW (Graphics Library Framework) 是一个用于创建图形用户界面(GUI)和窗口管理的开源库。它提供了一个跨平台的、简单易用的接口，用于创建窗口、处理输入、处理OpenGL上下文和渲染等功能。</p>
<p>主要特性包括：</p>
<ol>
<li><p>创建窗口：GLFW 允许开发人员创建窗口和上下文，用于图形渲染。</p>
</li>
<li><p>处理输入：它提供了对键盘、鼠标和其他输入设备的处理，以便开发人员可以轻松地获取用户的输入。</p>
</li>
<li><p>多窗口和多监视器支持：GLFW 支持在多个窗口和多个监视器上创建和管理图形界面。</p>
</li>
<li><p>时间处理：GLFW 提供了一种机制来处理时间，比如定时器和时间间隔。</p>
</li>
<li><p>OpenGL 上下文管理：它可以与OpenGL图形库很好地集成，为OpenGL提供一个合适的渲染上下文。</p>
</li>
<li><p>跨平台：GLFW 被设计为跨平台的库，可以在多个操作系统上运行，包括Windows、macOS、Linux和其他一些系统。</p>
</li>
</ol>
<p>GLFW 是游戏开发、图形应用程序和其他需要图形界面的项目中常用的工具之一，它简化了窗口和输入处理的复杂性，让开发人员能够更专注于图形渲染和应用逻辑的实现。</p>
<hr>
<h2 id="OpenGL-详解"><a href="#OpenGL-详解" class="headerlink" title="OpenGL 详解"></a>OpenGL 详解</h2><p>OpenGL (Open Graphics Library) 是一种用于渲染2D和3D图形的跨平台图形库。它提供了一组用于绘制图形的函数，可以让开发人员利用计算机的GPU来生成高性能的图形效果。OpenGL 最初由SGI (Silicon Graphics, Inc.) 开发，并于1992年首次发布。如今，OpenGL 已成为图形编程中广泛使用的标准，并得到了许多硬件厂商和开发者的支持。</p>
<p>以下是一些关键的概念和特性，帮助你更详细地了解 OpenGL：</p>
<ol>
<li><p>三维图形：OpenGL 是一种专门用于渲染三维图形的图形库。它支持在三维空间中创建和渲染复杂的图形场景。</p>
</li>
<li><p>着色器：OpenGL 使用着色器来控制图形的绘制过程。着色器是运行在GPU上的小程序，包括顶点着色器(Vertex Shader)和片段着色器(Fragment Shader)。顶点着色器负责处理顶点的变换和光照计算，而片段着色器则负责计算像素的颜色。</p>
</li>
<li><p>缓冲区对象：OpenGL 使用缓冲区对象来管理图形数据。这些数据可以包括顶点坐标、颜色、法向量和纹理坐标等。缓冲区对象将数据存储在GPU的显存中，以便更快地访问。</p>
</li>
<li><p>纹理映射：OpenGL 支持纹理映射，可以将图片或图案映射到三维对象的表面，以增加细节和逼真感。</p>
</li>
<li><p>坐标系：OpenGL 使用右手坐标系来表示三维空间。X轴指向右边，Y轴指向上方，Z轴指向屏幕内部。</p>
</li>
<li><p>状态机：OpenGL 是一个基于状态机的图形库，意味着绘制图形之前需要设置一些状态，比如颜色、深度测试、剔除等。然后，OpenGL 根据当前状态来绘制图形。</p>
</li>
<li><p>执行管线：OpenGL 执行图形渲染的过程被称为图形管线。它包括几个阶段，比如顶点处理、几何处理、光栅化和片段处理等。</p>
</li>
<li><p>扩展和版本：OpenGL 是一个不断发展的图形库，每个版本都会引入新的特性和扩展。开发者可以根据需要选择合适的OpenGL版本。</p>
</li>
</ol>
<p>虽然OpenGL在图形编程中非常强大且广泛应用，但在一些情况下，也可以考虑使用更高级的图形库或API，比如Vulkan或DirectX，以获得更多的控制权和更高的性能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-PlatformIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-PlatformIO/" class="post-title-link" itemprop="url">PlatformIO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>嵌入式开发板编程IDE笔记</li>
<li>官方文档<ul>
<li><a target="_blank" rel="noopener" href="https://docs.platformio.org/en/latest/integration/ide/vscode.html#quick-start">https://docs.platformio.org/en/latest/integration/ide/vscode.html#quick-start</a></li>
</ul>
</li>
</ul>
<h2 id="platformIO-详解"><a href="#platformIO-详解" class="headerlink" title="platformIO 详解"></a>platformIO 详解</h2><p>PlatformIO 是一个开源的跨平台的物联网（IoT）开发生态系统，它用于嵌入式系统和嵌入式应用程序的开发。PlatformIO 提供了一个强大的集成开发环境（IDE），支持多种硬件平台，包括Arduino、ESP8266、ESP32、Raspberry Pi等，以及多种开发框架，如Arduino、Mbed、FreeRTOS等。以下是 PlatformIO 的主要特点和功能的详细解释：</p>
<ol>
<li><p><strong>多平台支持</strong>：PlatformIO 可以在不同的操作系统上运行，包括 Windows、macOS 和 Linux，因此可以轻松迁移到不同的开发环境。</p>
</li>
<li><p><strong>多硬件平台支持</strong>：PlatformIO 支持多种硬件平台，使开发人员能够在不同的嵌入式设备上进行开发，而无需为每个平台使用不同的开发工具。</p>
</li>
<li><p><strong>多框架支持</strong>：PlatformIO 支持多种开发框架和库，包括 Arduino、Mbed、ESP-IDF、STM32Cube等，使开发人员能够选择适合其项目的最佳框架。</p>
</li>
<li><p>**集成开发环境 (IDE)**：PlatformIO 提供了一个集成开发环境，使开发人员能够方便地编写、构建、上传和调试嵌入式应用程序。PlatformIO 支持 Visual Studio Code（VSCode）等流行的文本编辑器和IDE。</p>
</li>
<li><p><strong>自动依赖管理</strong>：PlatformIO 自动处理项目依赖关系，包括库、框架和工具链，以确保项目能够顺利构建和运行。</p>
</li>
<li><p><strong>自动固件升级</strong>：PlatformIO 具有内置的固件升级工具，使嵌入式设备的固件更新变得更加容易。</p>
</li>
<li><p><strong>强大的命令行工具</strong>：PlatformIO 还提供了命令行工具，使开发人员能够自动化和自定义开发流程，以满足其特定需求。</p>
</li>
<li><p><strong>丰富的插件生态系统</strong>：PlatformIO 的插件系统使开发人员能够扩展其功能，添加新硬件平台、框架、工具等。</p>
</li>
<li><p><strong>跨平台固件开发</strong>：PlatformIO 使开发人员能够开发跨不同平台的嵌入式固件，从单片机到嵌入式Linux系统。</p>
</li>
</ol>
<p>总的来说，PlatformIO 是一个强大且灵活的工具，适用于嵌入式系统开发人员，它简化了开发流程，提供了一体化的开发环境，支持多种硬件平台和开发框架，以及自动化依赖管理，从而大大提高了嵌入式开发的效率。如果您是嵌入式开发人员或对嵌入式系统感兴趣，PlatformIO 是一个值得考虑的工具。</p>
<h2 id="platformIO-VSCode插件-使用-详解"><a href="#platformIO-VSCode插件-使用-详解" class="headerlink" title="platformIO VSCode插件 使用 详解"></a>platformIO VSCode插件 使用 详解</h2><p>PlatformIO 在 Visual Studio Code（VSCode）中提供了一个功能强大的插件，使嵌入式系统开发变得更加便捷。以下是详细的 PlatformIO VSCode 插件的使用说明：</p>
<p><strong>1. 安装 PlatformIO 插件：</strong></p>
<ul>
<li>打开 Visual Studio Code (VSCode)。</li>
<li>在左侧的 Extensions (扩展) 面板中，搜索 “PlatformIO IDE” 并安装该插件。</li>
</ul>
<p><strong>2. 创建或打开 PlatformIO 项目：</strong></p>
<ul>
<li>如果您已有一个 PlatformIO 项目，可以直接在 VSCode 中打开它，或者您可以使用 <code>File</code> -&gt; <code>New Project</code> 创建一个新项目。</li>
</ul>
<p><strong>3. 配置项目：</strong></p>
<ul>
<li>在项目文件夹中，打开 <code>platformio.ini</code> 文件。这个文件用于配置项目的硬件平台、框架、依赖库等。</li>
<li>在 <code>platformio.ini</code> 文件中，您可以指定目标硬件板（<code>[env]</code> 部分）、选择框架、添加依赖库等。</li>
</ul>
<p><strong>4. 编写代码：</strong></p>
<ul>
<li>在 VSCode 中创建或打开源代码文件（通常是 <code>.cpp</code> 或 <code>.ino</code> 文件），然后开始编写嵌入式代码。</li>
</ul>
<p><strong>5. 构建项目：</strong></p>
<ul>
<li>使用 PlatformIO 插件，您可以构建项目。在 VSCode 中，点击底部工具栏的构建按钮（绿色的勾号），或者使用快捷键（通常是 Ctrl + Alt + B）来构建项目。</li>
</ul>
<p><strong>6. 上传固件：</strong></p>
<ul>
<li>构建成功后，您可以将固件上传到目标硬件板。在 VSCode 中，点击底部工具栏的上传按钮（右边的右箭头），或使用快捷键（通常是 Ctrl + Alt + U）来上传固件。</li>
</ul>
<p><strong>7. 调试项目（可选）：</strong></p>
<ul>
<li>如果您需要调试嵌入式应用程序，PlatformIO 插件支持硬件调试器。您可以配置调试器，设置断点，以及使用 VSCode 的调试功能进行嵌入式代码的调试。</li>
</ul>
<p><strong>8. 库管理：</strong></p>
<ul>
<li>PlatformIO 插件支持库管理。您可以搜索、安装、升级和删除依赖库，以简化项目的依赖管理。这可以在 VSCode 中的 PlatformIO Sidebar（侧边栏）中完成。</li>
</ul>
<p><strong>9. 终端和监控：</strong></p>
<ul>
<li>PlatformIO 插件集成了终端和监控功能。您可以在 VSCode 中的 PlatformIO Sidebar 中打开终端，以运行特定的命令。监控功能可用于查看串口输出。</li>
</ul>
<p><strong>10. 插件设置：</strong></p>
<ul>
<li>您可以通过点击 VSCode 左下角的齿轮图标（设置按钮）来访问 PlatformIO 插件的设置。这里您可以进行各种自定义设置，包括构建选项、上传速度、调试器配置等。</li>
</ul>
<p>PlatformIO 插件在 VSCode 中提供了一个完整的嵌入式开发环境，支持多种硬件平台和开发框架。通过 VSCode 的集成性和 PlatformIO 的功能，您可以在一个集成的环境中完成项目配置、编码、构建、上传和调试，提高了嵌入式开发的效率。如果您是嵌入式开发人员或对嵌入式系统感兴趣，PlatformIO 插件是一个强大的工具，使您能够更轻松地进行开发和调试。</p>
<h2 id="platformio-ini文件-常见的配置参数"><a href="#platformio-ini文件-常见的配置参数" class="headerlink" title="platformio.ini文件 常见的配置参数"></a>platformio.ini文件 常见的配置参数</h2><p><code>platformio.ini</code> 文件是PlatformIO项目的配置文件，用于指定项目的构建、上传、目标设备以及其他参数。以下是一些常见的<code>platformio.ini</code>配置参数：</p>
<ol>
<li><strong>平台和框架选择</strong>:<ul>
<li><code>platform</code>：指定目标平台，如Arduino、Espressif、Raspberry Pi等。</li>
<li><code>framework</code>：指定项目使用的框架，如Arduino、Mbed、ESP-IDF等。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">platform</span> = espressif8266</span><br><span class="line"><span class="attr">framework</span> = ardui<span class="literal">no</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>目标环境配置</strong>:<ul>
<li><code>board</code>：选择目标开发板型号。</li>
<li><code>board_build.mcu</code>：指定目标微控制器型号。</li>
<li><code>board_build.f_cpu</code>：指定目标CPU的时钟频率。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">board</span> = nodemcu</span><br><span class="line"><span class="attr">board_build.mcu</span> = esp8266</span><br><span class="line"><span class="attr">board_build.f_cpu</span> = <span class="number">80000000</span>L</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>串口配置</strong>:<ul>
<li><code>upload_port</code>：指定上传固件时的串口端口。</li>
<li><code>monitor_port</code>：指定监控串口端口。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">upload_port</span> = COM3</span><br><span class="line"><span class="attr">monitor_port</span> = COM3</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>编译参数</strong>:<ul>
<li><code>build_flags</code>：添加编译选项，如宏定义、编译标志等。</li>
<li><code>extra_scripts</code>：引用自定义脚本以进行更高级的构建操作。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">build_flags</span> = -D DEBUG_MODE</span><br><span class="line"><span class="attr">extra_scripts</span> = custom_script.py</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>库依赖</strong>:<ul>
<li><code>lib_deps</code>：指定项目所需的库依赖。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">lib_deps</span> =</span><br><span class="line">    Wire</span><br><span class="line">    Adafruit Unified Sensor</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>上传和调试工具配置</strong>:<ul>
<li><code>upload_protocol</code>：指定上传协议，如<code>stlink</code>、<code>espota</code>、<code>avr109</code>等。</li>
<li><code>debug_tool</code>：指定调试工具，如<code>stlink</code>, <code>esp-prog</code>, <code>jlink</code>等。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">upload_protocol</span> = espota</span><br><span class="line"><span class="attr">debug_tool</span> = esp-prog</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>上传速度和端口配置</strong>:<ul>
<li><code>upload_speed</code>：指定上传速度，如<code>115200</code>。</li>
<li><code>monitor_speed</code>：指定监控串口的波特率。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">upload_speed</span> = <span class="number">921600</span></span><br><span class="line"><span class="attr">monitor_speed</span> = <span class="number">115200</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li><strong>其他项目设置</strong>:<ul>
<li><code>platform_packages</code>：指定特定平台的软件包。</li>
<li><code>extra_configs</code>：引用其他配置文件。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">platform_packages</span> = framework-arduinoespressif8266</span><br><span class="line"><span class="attr">extra_configs</span> = additional_config.ini</span><br></pre></td></tr></table></figure>

<p>这些是一些常见的<code>platformio.ini</code>配置参数，您可以根据您的项目需求进行自定义。<code>platformio.ini</code>文件使您能够轻松配置PlatformIO项目的各个方面，以适应特定的硬件和软件需求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-PostgreSQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-PostgreSQL/" class="post-title-link" itemprop="url">PostgreSQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>PostgreSQL数据库</li>
</ul>
<h2 id="postgreSQL-数据库是什么"><a href="#postgreSQL-数据库是什么" class="headerlink" title="postgreSQL 数据库是什么"></a>postgreSQL 数据库是什么</h2><p>PostgreSQL是一个免费的开源关系型数据库管理系统（RDBMS），它采用了PostgreSQL许可证，允许用户免费使用、修改和分发它。PostgreSQL经常被简称为”Postgres”。它具有强大的功能和可扩展性，被广泛用于开发各种类型的应用程序。</p>
<p>一些 PostgreSQL 的关键特性包括：</p>
<ol>
<li><p><strong>关系型数据库管理系统（RDBMS）</strong>：PostgreSQL是一种基于关系模型的数据库系统，允许用户以表格的形式存储和管理数据。</p>
</li>
<li><p><strong>免费且开源</strong>：PostgreSQL是免费的，用户可以自由使用、修改和分发它。</p>
</li>
<li><p><strong>支持多种数据类型</strong>：除了常见的数据类型如整数、字符和日期等，PostgreSQL还支持JSON、数组、几何数据类型等多种复杂数据类型。</p>
</li>
<li><p><strong>支持SQL语言</strong>：它支持标准的结构化查询语言（SQL），允许用户进行数据查询、操作和管理。</p>
</li>
<li><p><strong>扩展性</strong>：PostgreSQL具有良好的扩展性，支持插件和扩展模块，允许用户添加额外的功能和特性。</p>
</li>
<li><p><strong>事务支持</strong>：它支持ACID（原子性、一致性、隔离性和持久性）属性，确保数据操作的完整性和一致性。</p>
</li>
<li><p><strong>触发器和存储过程</strong>：PostgreSQL支持触发器和存储过程，使得用户能够在特定事件发生时自动执行操作。</p>
</li>
<li><p><strong>复制和高可用性</strong>：提供复制功能，可以创建备份以及实现高可用性和故障容错。</p>
</li>
</ol>
<p>PostgreSQL是一个功能强大、稳定可靠且高度可定制的数据库管理系统，被广泛应用于各种类型的应用程序，从个人项目到大型企业级应用都可以使用它来存储和管理数据。</p>
<h2 id="PostgreSQL-详解"><a href="#PostgreSQL-详解" class="headerlink" title="PostgreSQL 详解"></a>PostgreSQL 详解</h2><p>PostgreSQL是一个功能强大的开源关系型数据库管理系统（RDBMS），具有许多特性和优势，适用于各种规模和类型的应用。以下是对PostgreSQL的一些详细解释：</p>
<h3 id="特性和功能："><a href="#特性和功能：" class="headerlink" title="特性和功能："></a>特性和功能：</h3><ol>
<li><p><strong>数据类型支持</strong>：除了标准的数据类型（整数、字符、日期等），PostgreSQL支持复杂数据类型如数组、JSON、几何数据等。</p>
</li>
<li><p><strong>多种编程语言扩展</strong>：允许使用多种编程语言编写存储过程、函数和触发器，如PL&#x2F;pgSQL、PL&#x2F;Python、PL&#x2F;Perl、PL&#x2F;Java等。</p>
</li>
<li><p><strong>ACID兼容</strong>：支持事务的ACID属性（原子性、一致性、隔离性、持久性），确保数据的完整性和一致性。</p>
</li>
<li><p><strong>扩展性</strong>：具有良好的扩展性，支持插件和扩展模块，可添加额外功能以满足特定需求。</p>
</li>
<li><p><strong>复杂查询优化</strong>：支持复杂的查询语句和联合查询，提供了强大的优化功能以提高查询性能。</p>
</li>
<li><p><strong>完整性约束</strong>：支持各种完整性约束，如主键约束、外键约束、唯一约束等，确保数据的完整性。</p>
</li>
<li><p><strong>触发器和存储过程</strong>：允许开发者定义触发器和存储过程，以实现在特定事件发生时自动执行的操作。</p>
</li>
<li><p><strong>并发控制</strong>：提供有效的并发控制机制，支持多个用户同时对数据库进行访问和操作。</p>
</li>
<li><p><strong>复制和高可用性</strong>：支持数据复制功能，可创建备份以及实现高可用性和故障容错。</p>
</li>
<li><p><strong>安全性</strong>：提供多种安全功能，包括访问控制、SSL支持、数据加密等，保护数据库免受未经授权的访问和攻击。</p>
</li>
</ol>
<h3 id="应用领域："><a href="#应用领域：" class="headerlink" title="应用领域："></a>应用领域：</h3><ol>
<li><p><strong>Web应用程序</strong>：用于存储和管理Web应用程序的数据，如电子商务平台、社交媒体网站等。</p>
</li>
<li><p><strong>企业级应用</strong>：被广泛用于企业级应用，用于数据分析、报告生成、客户关系管理等。</p>
</li>
<li><p><strong>地理信息系统（GIS）</strong>：由于其对地理空间数据的支持，常用于开发GIS应用。</p>
</li>
<li><p><strong>科学研究</strong>：用于处理大量数据和进行复杂查询，满足科学研究领域的需求。</p>
</li>
<li><p><strong>物联网（IoT）</strong>：适用于存储和管理大量物联网设备生成的数据。</p>
</li>
</ol>
<h3 id="社区和生态系统："><a href="#社区和生态系统：" class="headerlink" title="社区和生态系统："></a>社区和生态系统：</h3><ol>
<li><p><strong>活跃的社区支持</strong>：拥有一个活跃的开发社区，提供广泛的文档、教程和支持。</p>
</li>
<li><p><strong>丰富的第三方工具和扩展</strong>：有许多第三方工具和扩展可用于简化开发、监控和管理PostgreSQL数据库。</p>
</li>
</ol>
<p>总的来说，PostgreSQL是一个功能强大、稳定可靠且高度可定制的数据库管理系统，它的特性和灵活性使其成为许多应用程序开发者和企业的首选数据库之一。</p>
<h2 id="PostgreSQL-可以用哪些编程语言开发"><a href="#PostgreSQL-可以用哪些编程语言开发" class="headerlink" title="PostgreSQL 可以用哪些编程语言开发"></a>PostgreSQL 可以用哪些编程语言开发</h2><p>PostgreSQL本身是用C语言开发的，但它提供了许多支持扩展的方式，允许使用多种编程语言来开发扩展功能。这些扩展可以作为存储过程、函数、触发器等与数据库交互的组件，其中一些常用的开发语言包括：</p>
<ol>
<li><p><strong>PL&#x2F;pgSQL</strong>：这是PostgreSQL的内置过程式语言，类似于Oracle的PL&#x2F;SQL。它与SQL语句紧密集成，允许开发者编写存储过程和触发器等。</p>
</li>
<li><p><strong>PL&#x2F;Python</strong>：允许使用Python语言编写存储过程、函数和触发器。它使得开发者可以利用Python的强大功能来扩展数据库功能。</p>
</li>
<li><p><strong>PL&#x2F;Perl</strong>：允许使用Perl语言编写存储过程、函数和触发器。对于熟悉Perl的开发者来说，这是一个很好的选择。</p>
</li>
<li><p><strong>PL&#x2F;Java</strong>：允许使用Java语言编写存储过程、函数和触发器。这个扩展允许开发者利用Java的强大功能来扩展数据库。</p>
</li>
<li><p><strong>PL&#x2F;SQL</strong>：通过第三方扩展，允许在PostgreSQL中使用Oracle的PL&#x2F;SQL语言，从而方便那些熟悉Oracle数据库的开发者。</p>
</li>
<li><p><strong>其他语言扩展</strong>：除了上述常用的语言外，PostgreSQL还支持其他一些语言的扩展，如PL&#x2F;R（R语言）、PL&#x2F;V8（JavaScript）等。这些扩展使得开发者可以根据自己的需求选择适合的编程语言来开发数据库功能。</p>
</li>
</ol>
<p>通过这些扩展，开发者可以选择自己熟悉的编程语言来扩展PostgreSQL的功能，使其适应各种需求和场景。</p>
<h2 id="PostgreSQL-语法"><a href="#PostgreSQL-语法" class="headerlink" title="PostgreSQL 语法"></a>PostgreSQL 语法</h2><ul>
<li><p>默认情况下 PostgreSQL 安装完成后，自带了一个命令行工具 SQL Shell(psql)。</p>
</li>
<li><p>Linux 系统可以直接切换到 postgres 用户来开启命令行工具：</p>
<ul>
<li><h1 id="sudo-i-u-postgres"><a href="#sudo-i-u-postgres" class="headerlink" title="sudo -i -u postgres"></a>sudo -i -u postgres</h1></li>
</ul>
</li>
<li><p>进入命令行工具，我们可以使用 \help 来查看各个命令的语法 ：</p>
<ul>
<li>postgres-# \help <command_name></li>
</ul>
</li>
<li><p>SQL 语句</p>
<ul>
<li>一个 SQL 语句通常包含了关键字、标识符（字段）、常量、特殊符号等，下面是一个简单的 SQL 语句：</li>
<li>SELECT id, name FROM runoob</li>
</ul>
</li>
<li><p>PostgreSQL 命令</p>
<ul>
<li>ABORT<ul>
<li>ABORT 用于退出当前事务。</li>
<li>ABORT [ WORK | TRANSACTION ]</li>
</ul>
</li>
<li>ALTER AGGREGATE<ul>
<li>修改一个聚集函数的定义 。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> AGGREGATE _name_ ( _argtype_ [ , ... ] ) RENAME <span class="keyword">TO</span> _new_name_</span><br><span class="line"><span class="keyword">ALTER</span> AGGREGATE _name_ ( _argtype_ [ , ... ] ) OWNER <span class="keyword">TO</span> _new_owner_</span><br><span class="line"><span class="keyword">ALTER</span> AGGREGATE _name_ ( _argtype_ [ , ... ] ) <span class="keyword">SET</span> SCHEMA _new_schema_</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ALTER COLLATION<ul>
<li>修改一个排序规则定义 。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLLATION</span> _name_ RENAME <span class="keyword">TO</span> _new_name_</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLLATION</span> _name_ OWNER <span class="keyword">TO</span> _new_owner_</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLLATION</span> _name_ <span class="keyword">SET</span> SCHEMA _new_schema_</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ALTER CONVERSION<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> CONVERSION name RENAME <span class="keyword">TO</span> new_name</span><br><span class="line"><span class="keyword">ALTER</span> CONVERSION name OWNER <span class="keyword">TO</span> new_owner</span><br></pre></td></tr></table></figure></li>
<li>ALTER DATABASE<ul>
<li>修改一个数据库。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE name <span class="keyword">SET</span> <span class="keyword">parameter</span> &#123; <span class="keyword">TO</span> <span class="operator">|</span> <span class="operator">=</span> &#125; &#123; <span class="keyword">value</span> <span class="operator">|</span> <span class="keyword">DEFAULT</span> &#125;</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE name RESET <span class="keyword">parameter</span></span><br><span class="line"><span class="keyword">ALTER</span> DATABASE name RENAME <span class="keyword">TO</span> new_name</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE name OWNER <span class="keyword">TO</span> new_owner</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ALTER DEFAULT PRIVILEGES<ul>
<li>定义默认的访问权限。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES</span><br><span class="line">    [ <span class="keyword">FOR</span> &#123; ROLE <span class="operator">|</span> <span class="keyword">USER</span> &#125; target_role [, ...] ]</span><br><span class="line">    [ <span class="keyword">IN</span> SCHEMA schema_name [, ...] ]</span><br><span class="line">    abbreviated_grant_or_revoke</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> abbreviated_grant_or_revoke <span class="keyword">is</span> <span class="keyword">one</span> <span class="keyword">of</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> &#123; &#123; <span class="keyword">SELECT</span> <span class="operator">|</span> <span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> <span class="keyword">DELETE</span> <span class="operator">|</span> <span class="keyword">TRUNCATE</span> <span class="operator">|</span> <span class="keyword">REFERENCES</span> <span class="operator">|</span> <span class="keyword">TRIGGER</span> &#125;</span><br><span class="line">    [, ...] <span class="operator">|</span> <span class="keyword">ALL</span> [ PRIVILEGES ] &#125;</span><br><span class="line">    <span class="keyword">ON</span> TABLES</span><br><span class="line">    <span class="keyword">TO</span> &#123; [ <span class="keyword">GROUP</span> ] role_name <span class="operator">|</span> PUBLIC &#125; [, ...] [ <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-RESTful/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-RESTful/" class="post-title-link" itemprop="url">RESTful</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>RESTful接口相关笔记</li>
<li>表现层状态转换(Representational State Transfer, REST)</li>
</ul>
<h2 id="表现层状态转换"><a href="#表现层状态转换" class="headerlink" title="表现层状态转换"></a>表现层状态转换</h2><ul>
<li><p>表现层状态转换（英语：Representational State Transfer，缩写：REST）是Roy Thomas Fielding博士于2000年在他的博士论文[1]中提出来的一种万维网软件架构风格，目的是便于不同软件&#x2F;程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于超文本传输协议（HTTP）之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。符合或兼容于这种架构风格（简称为 REST 或 RESTful）的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。因此表现层状态转换提供了在互联网络的计算系统之间，彼此资源可交互使用的协作性质（interoperability）。相对于其它种类的网络服务，例如SOAP服务，则是以本身所定义的操作集，来访问网络上的资源。</p>
</li>
<li><p>目前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的Web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务执行图书查询；雅虎提供的Web服务也是REST风格的。</p>
</li>
</ul>
<h2 id="要点及标准"><a href="#要点及标准" class="headerlink" title="要点及标准"></a>要点及标准</h2><ul>
<li><p>需要注意的是，REST是设计风格而不是标准。REST通常基于HTTP、URI、XML以及HTML这些现有的广泛流行的协议和标准。</p>
</li>
<li><p>资源是由URI来指定。</p>
</li>
<li><p>对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。</p>
</li>
<li><p>通过操作资源的表现形式来操作资源。</p>
</li>
<li><p>资源的表现形式则是XML或者HTML，取决于读者是机器还是人、是消费Web服务的客户软件还是Web浏览器。当然也可以是任何其他的格式，例如JSON。</p>
</li>
<li><p>可重新表达的状态迁移的特征</p>
<ul>
<li>Uniform Interface：统一接口。<ul>
<li>以资源为基础<ul>
<li>每个资源都可以通过URI访问到。</li>
<li>也就是一个个可以认知的资源，比如文档，音乐，视频等信息，都可以通过唯一的URI确定。</li>
</ul>
</li>
<li>通过重表达的客户端可以管理原资源<ul>
<li>就是我们通过客户端可以修改原资源的状态。</li>
</ul>
</li>
<li>返回信息足够描述自己<ul>
<li>这样重表达的客户端可以知道如何处理。</li>
</ul>
</li>
<li>超媒体是应用状态的引擎<ul>
<li>处理以超媒体为基础的状态变化。</li>
</ul>
</li>
</ul>
</li>
<li>Stateless：无状态。</li>
<li>Cacheable：可缓存。</li>
<li>Client-Server：客户服务器分离模式，任何一个客户端与服务器都是可替换的。</li>
<li>Layered System：分层的系统，客户端不知道他联系的是不是最终服务器。</li>
<li>Code on Demand（可选）：服务器可以将能力扩展到客户端，如果客户端可以执行的话。这个功能是可选择的</li>
</ul>
</li>
</ul>
<h2 id="REST架构的限制条件"><a href="#REST架构的限制条件" class="headerlink" title="REST架构的限制条件"></a>REST架构的限制条件</h2><ul>
<li>REST架构风格最重要的架构限制有6个：<ol>
<li>客户端-服务器（Client-Server）</li>
</ol>
<ul>
<li>客户端-服务器结构限制的目的是将客户端和服务器端的关注点分离。将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来有助于提高用户界面的跨平台的可移植性。通过简化服务器模块也有助于服务器模块的可扩展性。</li>
</ul>
<ol start="2">
<li>无状态(Stateless)</li>
</ol>
<ul>
<li>服务器不能保存客户端的信息；每一次从客户端发送的请求中，要包含所有的必须的状态信息，会话信息由客户端保存，服务器端根据这些状态信息来处理请求。</li>
<li>服务器可以将会话状态信息传递给其他服务，比如数据库服务，这样可以保持一段时间的状态信息，从而实现认证功能。</li>
<li>当客户端可以切换到一个新状态的时候发送请求信息。</li>
<li>当一个或者多个请求被发送之后，客户端就处于一个状态变迁过程中。每一个应用的状态描述可以被客户端用来初始化下一次的状态变迁。</li>
</ul>
<ol start="3">
<li>缓存(Cacheability)</li>
</ol>
<ul>
<li>如同万维网一样，客户端和中间的通讯传递者可以将回复缓存起来。回复必须明确的或者间接的表明本身是否可以进行缓存，这可以预防客户端在将来进行请求的时候得到陈旧的或者不恰当的数据。管理良好的缓存机制可以减少客户端-服务器之间的交互，甚至完全避免客户端-服务器交互，这进一步提了高性能和可扩展性</li>
</ul>
<ol start="4">
<li>统一接口(Uniform Interface)</li>
</ol>
<ul>
<li>这是 RESTful 系统设计的基本出发点。它简化了系统架构，减少了耦合性，可以让所有模块各自独立的进行改进。包括下列四个限制：<ul>
<li>请求中包含资源的 ID（Resource identification in requests）<ul>
<li>请求中包含了各种独立资源的标识，例如，在Web服务中的URI。资源本身和发送给客户端的标识是独立。例如，服务器可以将自身的数据库信息以HTML、XML或者JSON的方式发送给客户端，但是这些可能都不是服务器的内部记录方式。</li>
</ul>
</li>
<li>资源通过标识来操作（Resource manipulation through representations）<ul>
<li>当客户端拥有一个资源的标识，包括附带的元数据，则它就有足够的信息来删除这个资源。</li>
</ul>
</li>
<li>消息的自我描述性（Self-descriptive messages）<ul>
<li>每一个消息都包含足够的信息来描述如何来处理这个信息. 例如，媒体类型 (media-type) 就可以确定需要什么样的分析器来分析媒体数据.</li>
</ul>
</li>
<li>用超媒体驱动应用状态（Hypermedia as the engine of application state (HATEOAS)）<ul>
<li>同用户访问Web服务器的Home页面相似，当一个 REST 客户端访问了最初的REST应用的URI之后，REST 客户端应该可以使用服务器端提供的链接，动态的发现所有的可用的资源和可执行的操作。随着访问的进行，服务器在响应中提供文字超链接，以便客户端可以得到当前可用的操作。客户端无需用确定的编码的方式记录下服务器端所提供的动态应用的结构信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="5">
<li>分层系统(Layered System)</li>
</ol>
<ul>
<li>客户端一般不知道是否直接连接到了最终的服务器，或者是路径上的中间服务器。中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性，这样可也便于安全策略的部署</li>
</ul>
<ol start="6">
<li>按需代码(Code-On-Demand, 可选)</li>
</ol>
<ul>
<li>服务器可以通过发送可执行代码给客户端的方式临时性的扩展功能或者定制功能，例如Java Applet、Flash或JavaScript。</li>
</ul>
</li>
</ul>
<h2 id="关于状态"><a href="#关于状态" class="headerlink" title="关于状态"></a>关于状态</h2><ul>
<li>应该注意区别应用的状态和连接协议的状态。HTTP连接是无状态的（也就是不记录每个连接的信息），而REST传输会包含应用的所有状态信息，因此可以大幅降低对HTTP连接的重复请求资源消耗</li>
</ul>
<h2 id="REST的优点"><a href="#REST的优点" class="headerlink" title="REST的优点"></a>REST的优点</h2><ul>
<li>可更高效利用缓存来提高响应速度</li>
<li>通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性</li>
<li>浏览器即可作为客户端，简化软件需求</li>
<li>相对于其他叠加在HTTP协议之上的机制，REST的软件依赖性更小</li>
<li>不需要额外的资源发现机制</li>
<li>在软件技术演进中的长期的兼容性更好</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Repo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Repo/" class="post-title-link" itemprop="url">Repo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>repo工具的笔记</li>
</ul>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>在Linux系统中，”repo” 是一个版本控制工具，用于协调多个Git存储库的管理和同步。它是Google为了管理Android开源项目而开发的，但也可用于其他项目。</p>
<p>repo工具基于Python编写，它提供了一个简化的方式来处理包含多个Git存储库的项目。使用repo工具，您可以轻松地进行跨多个存储库的代码同步、分支管理和代码审查等操作。</p>
<p>以下是repo工具的一些常见用法和功能：</p>
<ol>
<li><p>安装repo：要使用repo工具，您首先需要安装它。通常，您可以从Linux发行版的软件仓库中安装repo软件包。例如，在Ubuntu上可以使用以下命令安装repo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install repo</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化项目：要在一个新项目中使用repo工具，您需要创建一个包含一个特殊的仓库清单（manifest）文件的目录。这个清单文件描述了项目中的所有Git存储库以及它们的分支、路径等信息。然后，使用以下命令初始化项目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u &lt;manifest-url&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;manifest-url&gt;</code>是指向清单文件的URL。</p>
</li>
<li><p>同步代码：一旦项目初始化完成，您可以使用以下命令将代码同步到本地工作区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure>

<p>这将根据清单文件中定义的分支和路径，将各个Git存储库的代码下载到本地。</p>
</li>
<li><p>创建分支：使用repo工具可以轻松创建和切换Git分支。例如，要创建一个名为<code>mybranch</code>的分支，可以执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo start mybranch --all</span><br></pre></td></tr></table></figure>

<p>这将在所有Git存储库中创建名为<code>mybranch</code>的新分支。</p>
</li>
<li><p>提交更改：在进行代码更改后，可以使用普通的Git命令将更改提交到特定的存储库。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;repository-directory&gt;</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Commit message&quot;</span><br></pre></td></tr></table></figure>

<p>然后，使用<code>repo upload</code>命令将提交的更改推送到相应的存储库。</p>
</li>
</ol>
<p>这只是repo工具的一些基本用法，它还提供了其他功能，例如管理代码分支、处理代码审查等。您可以通过运行<code>repo help</code>命令获取更多的帮助和使用说明。</p>
<p>请注意，repo工具主要用于管理包含多个Git存储库的大型项目，因此在小型项目或单个存储库的情况下，可能没有必要使用repo工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Software_Development_Process_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Software_Development_Process_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" class="post-title-link" itemprop="url">Software_Development_Process_软件工程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>项目启动</p>
<ul>
<li>确定产品方向 -》需求调研，市场调研 -》业务梳理，思维导图 -》业务梳理，评审</li>
</ul>
</li>
<li><p>需求阶段</p>
<ul>
<li>产品原型 -》了解需求 -》 了解开发难度，评估开发工作量 -》 评估需求 -》项目里程碑，项目开发计划，项目任务分解 -》 需求概要</li>
</ul>
</li>
<li><p>设计阶段</p>
<ul>
<li>UI界面以及标注，UI设计规范 -》 需求规格 -》 概要设计，通讯协议，表结构设计</li>
</ul>
</li>
<li><p>开发阶段</p>
<ul>
<li>产品开发</li>
</ul>
</li>
<li><p>测试阶段</p>
<ul>
<li>修改bug -》 测试用例，测试结果报告，测试周报，用户体验</li>
</ul>
</li>
<li><p>系统上线</p>
<ul>
<li>上线</li>
</ul>
</li>
</ul>
<h2 id="开发流程-2"><a href="#开发流程-2" class="headerlink" title="开发流程 2"></a>开发流程 2</h2><ul>
<li><p>软件工程的思想主要集中于加强项目管理者的工作上</p>
</li>
<li><p>软件开发流程分为：</p>
<ul>
<li>可行性分析</li>
<li>需求分析</li>
<li>概要设计</li>
<li>详细设计</li>
<li>测试</li>
<li>运维</li>
</ul>
</li>
<li><p>可行性分析</p>
<ul>
<li>考虑要点：技术 经济 法律 市场；</li>
<li>说明：系统是否可以开发</li>
<li>查看文档人员：项目经理、技术总监、客户。</li>
</ul>
</li>
<li><p>需求分析</p>
<ul>
<li>说明：客户和开发人员进行沟通，为开发人员开发出来软件满足客户的需要提供依据</li>
<li>应有图：功能框架图、原型图 、用例图、功能模型图（ER图）、IPO、数据字典</li>
<li>查看文档人员：客户、需求分析人员、开发人员、测试人员</li>
</ul>
</li>
<li><p>概要设计</p>
<ul>
<li>说明：开发阶段对整体框架进行设计</li>
<li>应有图：架构图、包图、类图、接口图、流程图、功能模块对应图</li>
<li>查看文档人员：技术总监、开发人员</li>
</ul>
</li>
<li><p>详细设计</p>
<ul>
<li>说明：对程序进行详细的设计</li>
<li>应有图：时序图、协作图 、类图、活动图、状态图</li>
<li>查看文档人员：技术总监、开发人员</li>
</ul>
</li>
<li><p>数据库设计</p>
<ul>
<li>说明：指导数据库设计规划以及实现；</li>
<li>应有图：ER图、数据库关系图；</li>
<li>查看文档人员：数据库设计人员、数据库管理员、开发人员</li>
</ul>
</li>
<li><p>测试情况</p>
<ul>
<li>说明：对开发好的程序进行测试，以发现系统中出现的Bug；</li>
<li>应有图：测试用例</li>
<li>查看文档人员：测试人员、开发人员</li>
</ul>
</li>
<li><p>用户手册</p>
<ul>
<li>说明：让用户快速使用这个系统，并且在使用过程中出现问题可快速解决</li>
<li>应有图：界面截图；</li>
<li>查看文档人员：用户，文档审核人员</li>
</ul>
</li>
<li><p>运行与维护</p>
<ul>
<li>说明：交付东西——目标安装程序、数据库文件、用户手册、需求报告。</li>
<li>查看文档人员：用户、项目经理、文档审核人员</li>
</ul>
</li>
<li><p>小结</p>
<ul>
<li>系统要做就要有文档先行，要用文档驱动</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-NodeMCU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-NodeMCU/" class="post-title-link" itemprop="url">NodeMCU</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>NodeMCU 固件相关笔记</li>
</ul>
<h2 id="NodeMCU开发板-常见的内置宏"><a href="#NodeMCU开发板-常见的内置宏" class="headerlink" title="NodeMCU开发板 常见的内置宏"></a>NodeMCU开发板 常见的内置宏</h2><p>NodeMCU开发板在Arduino编程环境中通常具有以下常见的内置宏和引脚映射：</p>
<ol>
<li><p><code>LED_BUILTIN</code>：这个宏用于指代NodeMCU开发板上的内置LED引脚。通常映射到板上的一个特定引脚（如D4或GPIO2），用于方便控制内置LED。</p>
</li>
<li><p><code>D0</code> 到 <code>D8</code>：这些宏表示NodeMCU开发板上的数字引脚，从D0到D8。它们通常映射到相应的GPIO引脚，可用于连接外部设备。</p>
</li>
<li><p><code>A0</code>：这个宏表示NodeMCU开发板上的模拟引脚A0，通常用于模拟输入。</p>
</li>
<li><p><code>MISO</code>、<code>MOSI</code>、<code>SCK</code>、<code>SS</code>：这些宏表示SPI总线上的引脚，用于与SPI外设通信。NodeMCU开发板上通常有SPI接口。</p>
</li>
</ol>
<p>这些宏通常用于编程NodeMCU开发板，以便更轻松地访问和控制内置引脚和外部设备。请注意，NodeMCU开发板的具体引脚映射可能因不同版本和制造商而异，因此在编程时最好查看您使用的具体NodeMCU开发板的引脚映射表，以确保正确的引脚使用。</p>
<h2 id="nodemcu编程-LED-BUILTIN宏是什么-详解"><a href="#nodemcu编程-LED-BUILTIN宏是什么-详解" class="headerlink" title="nodemcu编程 LED_BUILTIN宏是什么 详解"></a>nodemcu编程 LED_BUILTIN宏是什么 详解</h2><p><code>LED_BUILTIN</code> 是一个常用于编程NodeMCU开发板的宏，通常在Arduino环境下使用。这个宏用于指代NodeMCU开发板上的内置LED引脚。</p>
<p>NodeMCU开发板通常内置了一个LED，它位于板子上的某个特定引脚。使用<code>LED_BUILTIN</code> 宏可以让您在编程中引用这个LED而不必记住实际引脚编号。这对于快速编程和示例代码非常方便，因为不同的NodeMCU版本可能具有不同的LED引脚。</p>
<p>在Arduino编程环境中，您可以使用<code>LED_BUILTIN</code> 宏来控制NodeMCU开发板上的内置LED，例如点亮或熄灭它。以下是一个简单的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_BUILTIN, OUTPUT); <span class="comment">// 将LED引脚设置为输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_BUILTIN, HIGH);   <span class="comment">// 点亮LED</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);                      <span class="comment">// 延时1秒</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_BUILTIN, LOW);    <span class="comment">// 熄灭LED</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);                      <span class="comment">// 延时1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中，<code>LED_BUILTIN</code> 宏会自动映射到NodeMCU开发板上的内置LED引脚，无需手动指定引脚编号。这样，代码在不同NodeMCU版本之间通常可以通用。</p>
<p>请注意，不同版本的NodeMCU开发板可能具有不同的LED引脚映射，因此使用<code>LED_BUILTIN</code> 宏可以提高代码的可移植性，而不必担心特定引脚编号。</p>
<h2 id="用于lua脚本上传到IOT开发板的工具-详解"><a href="#用于lua脚本上传到IOT开发板的工具-详解" class="headerlink" title="用于lua脚本上传到IOT开发板的工具 详解"></a>用于lua脚本上传到IOT开发板的工具 详解</h2><p>为了将Lua脚本上传到物联网（IoT）开发板，你可以使用各种工具和方法，具体取决于你的开发板类型和连接方式。以下是一些通用的工具和方法，以及它们的简要说明：</p>
<ol>
<li><p><strong>NodeMCU工具 - ESPlorer</strong>：</p>
<ul>
<li>ESPlorer是一个用于NodeMCU开发板的跨平台Lua文件上传工具。</li>
<li>它提供了文件管理、上传、下载、运行和调试Lua脚本的功能。</li>
<li>ESPlorer是一个开源工具，可以从GitHub上获得。</li>
</ul>
</li>
<li><p><strong>NodeMCU工具 - NodeMCU Flasher</strong>：</p>
<ul>
<li>NodeMCU Flasher是一个用于NodeMCU开发板的固件烧写工具，但它也允许上传Lua脚本。</li>
<li>你可以将Lua脚本文件添加到NodeMCU Flasher中，然后将它们上传到NodeMCU开发板。</li>
<li>这个工具适用于Windows环境。</li>
</ul>
</li>
<li><p><strong>Luatool</strong>：</p>
<ul>
<li>Luatool是一个命令行工具，用于上传Lua脚本到ESP8266（NodeMCU）开发板。</li>
<li>你可以使用命令行来指定要上传的Lua脚本文件以及开发板的串口端口。</li>
<li>Luatool支持Windows、Linux和macOS。</li>
</ul>
</li>
<li><p><strong>PlatformIO</strong>：</p>
<ul>
<li>如果你使用PlatformIO开发环境，你可以使用其内置的功能来上传Lua脚本到支持ESP8266的开发板。</li>
<li>PlatformIO提供了丰富的开发工具，包括代码编辑、编译、上传和监视。</li>
</ul>
</li>
<li><p><strong>Arduino IDE</strong>：</p>
<ul>
<li>如果你在Arduino IDE中编写Lua脚本，可以使用Arduino IDE的ESP8266支持来上传脚本。</li>
<li>你需要在Arduino IDE中选择适当的开发板和端口，然后将Lua脚本上传。</li>
</ul>
</li>
<li><p><strong>其他工具</strong>：</p>
<ul>
<li>根据你使用的硬件开发板和环境，还可以找到其他工具和方法来上传Lua脚本。请查看你的硬件制造商或社区的支持资源。</li>
</ul>
</li>
</ol>
<p>在使用这些工具之前，确保已正确配置串口端口、波特率和其他通信参数，以便与开发板进行通信。上传Lua脚本后，你可以通过串口监视器或其他方法运行和调试它们。请查看相关工具的文档和示例，以确保顺利上传和执行Lua脚本。</p>
<h2 id="IOT中的硬件开发板是什么-详解"><a href="#IOT中的硬件开发板是什么-详解" class="headerlink" title="IOT中的硬件开发板是什么 详解"></a>IOT中的硬件开发板是什么 详解</h2><p>在物联网（IoT）应用中，硬件开发板是一种特殊的硬件设备，通常用于构建和测试物联网设备和应用。这些硬件开发板提供了一种用于开发、原型制作和测试物联网项目的平台，通常包括微控制器、传感器、通信接口和其他必要的组件。以下是有关IoT中硬件开发板的详细解释：</p>
<ol>
<li><p><strong>硬件开发板的组成</strong>：</p>
<ul>
<li><strong>微控制器</strong>：硬件开发板通常包括一款嵌入式微控制器，如ESP8266、ESP32、Arduino、Raspberry Pi等。微控制器是硬件的大脑，用于控制和管理连接的设备、传感器和通信模块。</li>
<li><strong>传感器</strong>：硬件开发板通常配备了各种传感器，如温度传感器、湿度传感器、加速度传感器、光敏传感器等，用于监测环境和设备数据。</li>
<li><strong>通信接口</strong>：硬件开发板通常具备Wi-Fi、蓝牙、LoRa、Zigbee等通信接口，以便设备与其他设备或云服务进行通信。</li>
<li><strong>GPIO引脚</strong>：通用输入输出引脚可用于连接其他硬件组件，如执行器、LED、继电器等。</li>
</ul>
</li>
<li><p><strong>开发环境</strong>：</p>
<ul>
<li>硬件开发板通常与特定的开发环境（如Arduino IDE、PlatformIO、MicroPython、Raspberry Pi OS等）兼容，以便开发人员可以使用合适的编程语言和工具来编写和测试代码。</li>
<li>这些开发环境提供了用于编程和调试硬件的库、示例代码和工具。</li>
</ul>
</li>
<li><p><strong>应用领域</strong>：</p>
<ul>
<li>硬件开发板广泛应用于各种IoT应用领域，包括智能家居、工业自动化、农业、医疗保健、智能城市、车联网等。</li>
<li>它们可以用于监测环境数据、控制设备、收集传感器信息、与云服务通信等各种任务。</li>
</ul>
</li>
<li><p><strong>原型开发</strong>：</p>
<ul>
<li>硬件开发板是快速原型制作的理想选择，因为它们提供了一种简单的方式来构建和测试物联网设备的初始版本，无需进行大规模的硬件设计和制造。</li>
<li>开发人员可以在硬件开发板上快速验证其创意和概念。</li>
</ul>
</li>
<li><p><strong>生态系统</strong>：</p>
<ul>
<li>许多硬件开发板都有庞大的社区支持和生态系统，提供了丰富的资源、库和示例代码，使得IoT项目开发更容易。</li>
</ul>
</li>
</ol>
<p>总之，硬件开发板在物联网应用中扮演着重要的角色，它们为开发人员提供了一个用于构建、测试和原型制作物联网设备的平台。这些硬件开发板具有各种传感器和通信接口，可用于满足不同IoT应用的需求，并提供了相应的开发环境和资源，以简化IoT项目的开发流程。硬件开发板使得IoT的原型开发更加容易，促进了创新和新产品的推出。</p>
<h2 id="NodeMCU-详解"><a href="#NodeMCU-详解" class="headerlink" title="NodeMCU 详解"></a>NodeMCU 详解</h2><p>NodeMCU是一款开源的物联网（IoT）开发板，它使用了Espressif Systems的ESP8266模块，并提供了易于使用的硬件和软件接口，使得开发物联网项目变得非常方便。以下是有关NodeMCU的详细信息：</p>
<ol>
<li><p><strong>硬件特性</strong>：</p>
<ul>
<li><strong>微控制器</strong>：NodeMCU使用ESP8266模块，其中包括一个Tensilica L106 32位处理器，闪存（Flash）和SRAM内存。</li>
<li><strong>Wi-Fi</strong>：NodeMCU支持802.11b&#x2F;g&#x2F;n标准的Wi-Fi连接，允许设备通过无线网络连接到互联网。</li>
<li><strong>GPIO引脚</strong>：NodeMCU具有多个通用输入输出引脚，可用于连接传感器、执行器和其他外部设备。</li>
<li><strong>USB接口</strong>：NodeMCU板上集成了Micro USB接口，用于供电和连接到计算机。</li>
<li><strong>开发者友好</strong>：NodeMCU采用了模块化设计，具有易于使用的引脚标签，开发人员可以方便地连接和测试不同的传感器和设备。</li>
</ul>
</li>
<li><p><strong>开发环境</strong>：</p>
<ul>
<li><strong>Lua</strong>：NodeMCU最初以Lua编程环境为基础，使得编程变得简单。</li>
<li><strong>Arduino</strong>：NodeMCU还支持Arduino IDE，使用ESP8266核心，允许使用C&#x2F;C++编程语言进行开发。</li>
<li><strong>MicroPython</strong>：通过MicroPython，你可以使用Python语言进行NodeMCU开发。</li>
</ul>
</li>
<li><p><strong>电源供应</strong>：NodeMCU可以通过Micro USB接口供电，也可以通过外部电源供电。</p>
</li>
<li><p><strong>内置固件</strong>：NodeMCU通常预装了NodeMCU固件，该固件提供了Lua编程环境，因此开发人员可以通过串口监视器轻松执行Lua脚本。</p>
</li>
<li><p><strong>应用领域</strong>：</p>
<ul>
<li><strong>物联网（IoT）项目</strong>：NodeMCU广泛用于开发智能家居设备、传感器网络、监控系统和其他物联网应用。</li>
<li><strong>原型开发</strong>：它是快速原型开发的理想选择，因为它易于编程和集成。</li>
<li><strong>教育和学习</strong>：NodeMCU适用于学习嵌入式系统、物联网和编程，因为它提供了友好的硬件和软件界面。</li>
</ul>
</li>
<li><p><strong>社区和支持</strong>：NodeMCU拥有庞大的开发者社区，你可以在各种论坛、社交媒体平台和网站上找到关于NodeMCU的帮助、教程和示例代码。</p>
</li>
</ol>
<p>总之，NodeMCU是一款强大且易于使用的开发板，适用于开发物联网和嵌入式应用。它的灵活性、低成本和广泛的生态系统使其成为学习嵌入式系统和物联网的理想选择，也是原型开发的好工具。如果你有兴趣开发与NodeMCU相关的项目，可以使用支持的编程环境，如Lua、Arduino或MicroPython，来编写和测试你的代码。</p>
<h2 id="NodeMCU和ESP8266的关系-详解"><a href="#NodeMCU和ESP8266的关系-详解" class="headerlink" title="NodeMCU和ESP8266的关系 详解"></a>NodeMCU和ESP8266的关系 详解</h2><p>NodeMCU和ESP8266之间的关系比较容易混淆，因为它们之间存在一些密切的联系，但实际上它们代表了不同的概念和产品。下面是有关NodeMCU和ESP8266之间关系的详细解释：</p>
<ol>
<li><p><strong>ESP8266</strong>：</p>
<ul>
<li><strong>ESP8266</strong>是一个由乐鑫（Espressif Systems）开发制造的低成本、低功耗、高性能的Wi-Fi模块。</li>
<li>ESP8266模块内部包括一个Tensilica L106 32位微控制器、闪存（Flash）存储器和SRAM内存，以及Wi-Fi模块。</li>
<li>ESP8266模块可用于连接设备到Wi-Fi网络，并允许设备通过互联网进行通信。它常常被嵌入到各种硬件设备中，从传感器到智能家电，以实现物联网连接。</li>
</ul>
</li>
<li><p><strong>NodeMCU</strong>：</p>
<ul>
<li><strong>NodeMCU</strong>是一款开源的硬件平台，基于ESP8266模块构建。NodeMCU硬件板上集成了ESP8266模块，提供了额外的硬件支持，如USB接口、电源管理电路和GPIO引脚。</li>
<li>NodeMCU还预装了NodeMCU固件，该固件基于Lua编程语言，为开发人员提供了一个易于使用的编程环境，可以通过串口监视器直接执行Lua脚本。</li>
<li>NodeMCU是一种开发板，使得基于ESP8266的应用程序开发变得更加容易，无需额外的硬件设计。</li>
</ul>
</li>
<li><p><strong>关系</strong>：</p>
<ul>
<li>NodeMCU是一种硬件开发板，而ESP8266是一款Wi-Fi模块。</li>
<li>NodeMCU基于ESP8266，通过提供额外的硬件和固件支持，简化了ESP8266的开发和编程。</li>
<li>开发人员可以选择使用NodeMCU硬件板，也可以直接使用ESP8266模块进行开发。NodeMCU是一种加速开发的工具，它提供了便捷的开发环境，尤其适用于初学者和原型开发。</li>
</ul>
</li>
</ol>
<p>总之，NodeMCU是基于ESP8266的硬件开发板，它提供了额外的硬件支持和易于使用的编程环境，使得ESP8266的应用程序开发更加容易。ESP8266是NodeMCU的核心，而NodeMCU是一种简化开发流程的工具。你可以选择使用其中之一，具体取决于你的需求和经验水平。</p>
<h2 id="nodemcu-使用lua开发"><a href="#nodemcu-使用lua开发" class="headerlink" title="nodemcu 使用lua开发"></a>nodemcu 使用lua开发</h2><p>NodeMCU是一款支持Lua编程的开源硬件平台，通常基于ESP8266模块构建。使用NodeMCU和Lua编程，你可以轻松地开发物联网（IoT）应用程序，而无需太多的低级硬件编程知识。以下是一些基本步骤，演示如何在NodeMCU上使用Lua进行开发：</p>
<ol>
<li><p><strong>准备NodeMCU硬件</strong>：</p>
<ul>
<li>获取NodeMCU开发板。</li>
<li>通过Micro USB线连接NodeMCU开发板到计算机，以供电和进行数据传输。</li>
</ul>
</li>
<li><p><strong>安装驱动程序</strong>：</p>
<ul>
<li>在连接NodeMCU到计算机后，可能需要安装相应的USB驱动程序，以便计算机能够识别NodeMCU设备。</li>
</ul>
</li>
<li><p><strong>安装LuaLoader</strong>：</p>
<ul>
<li>为了编写、上传和运行Lua脚本，你可以使用名为”LuaLoader”的开发工具，它是NodeMCU Lua的一个集成开发环境（IDE）。</li>
<li>下载和安装LuaLoader，并确保它能够识别你的NodeMCU设备。</li>
</ul>
</li>
<li><p><strong>编写Lua脚本</strong>：</p>
<ul>
<li>使用LuaLoader或任何文本编辑器编写Lua脚本。示例Lua脚本如下：</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Blink LED on NodeMCU</span></span><br><span class="line">led_pin = <span class="number">4</span>  <span class="comment">-- GPIO4 on NodeMCU</span></span><br><span class="line"></span><br><span class="line">gpio.mode(led_pin, gpio.OUTPUT)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    gpio.<span class="built_in">write</span>(led_pin, gpio.LOW)</span><br><span class="line">    tmr.delay(<span class="number">1000000</span>) <span class="comment">-- 1 second</span></span><br><span class="line">    gpio.<span class="built_in">write</span>(led_pin, gpio.HIGH)</span><br><span class="line">    tmr.delay(<span class="number">1000000</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这是一个简单的示例，演示如何让NodeMCU上的LED闪烁。</p>
</li>
<li><p><strong>上传Lua脚本</strong>：</p>
<ul>
<li>使用LuaLoader将编写的Lua脚本上传到NodeMCU设备。通常，你需要连接到NodeMCU，选择要上传的脚本文件，并将其上传到设备。</li>
</ul>
</li>
<li><p><strong>运行Lua脚本</strong>：</p>
<ul>
<li>一旦上传完成，你可以运行Lua脚本。NodeMCU将执行脚本中的指令，从而实现特定的功能。</li>
<li>在这个示例中，NodeMCU将使连接到GPIO 4的LED灯闪烁。</li>
</ul>
</li>
</ol>
<p>这些是基本的步骤，演示如何在NodeMCU上使用Lua进行开发。你可以通过编写自定义Lua脚本来实现各种物联网应用，如传感器数据采集、远程控制、物联网通信等。LuaLoader提供了许多工具和示例代码，以帮助你开始编写和调试Lua脚本。请注意，NodeMCU还支持Arduino和MicroPython等编程环境，你可以根据自己的需求选择适当的开发工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Robot_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Robot_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Robot_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>机器人相关的理论基础知识</li>
</ul>
<h2 id="轴角"><a href="#轴角" class="headerlink" title="轴角"></a>轴角</h2><p>轴角（Axis-Angle）表示是一种用于描述三维空间中旋转的方法，它使用一个旋转轴的方向向量和一个旋转角度来表示旋转操作。轴角表示法具有直观性和数学简洁性，尤其在对大角度旋转和连续旋转的情况下很有用。</p>
<p>以下是轴角表示法的一些详细说明：</p>
<p><strong>1. 旋转轴向量：</strong> 旋转轴向量是一个单位向量，它指示了围绕它进行旋转的轴的方向。通常用一个三维向量 ( \mathbf{v} &#x3D; (x, y, z) ) 表示。这个向量不仅指明了旋转的方向，还表明了旋转的轴在三维空间中的位置。</p>
<p><strong>2. 旋转角度：</strong> 旋转角度是旋转操作的大小，通常以弧度为单位来度量。它决定了围绕旋转轴旋转多少弧度。正值表示逆时针旋转，负值表示顺时针旋转。</p>
<p><strong>3. 旋转矩阵：</strong> 使用轴角表示旋转，可以通过旋转矩阵来表示旋转操作。旋转矩阵是一个 3x3 的矩阵，它描述了绕指定轴旋转指定角度的操作。可以使用 Rodrigues 公式将轴角转换为旋转矩阵。公式如下：</p>
<p>[ \mathbf{R} &#x3D; \mathbf{I} + \sin(\theta)\mathbf{K} + (1 - \cos(\theta))\mathbf{K}^2 ]</p>
<p>其中 ( \mathbf{R} ) 是旋转矩阵，( \mathbf{I} ) 是单位矩阵，( \theta ) 是旋转角度，( \mathbf{K} ) 是由旋转轴向量构建的反对称矩阵。</p>
<p><strong>4. 应用领域：</strong> 轴角表示法在计算机图形学、计算机动画、机器人学等领域中得到广泛应用。它特别适用于模拟物体的旋转运动，例如在计算机游戏中模拟角色的转身、飞行器的定向等。</p>
<p><strong>5. 优点和缺点：</strong> 轴角表示法在大角度旋转情况下更加稳定，不会遇到欧拉角中的万向节死锁问题。然而，对于描述连续旋转过程，它可能不如四元数（Quaternions）表示法那么方便，因为连续旋转的组合操作可能导致旋转轴的不断变化，而轴角表示需要不断重新计算旋转轴。</p>
<p>综上所述，轴角表示法是一种有用且常见的方法，用于描述三维空间中的旋转操作。它通过一个旋转轴的方向和一个旋转角度来定义旋转，可以方便地将旋转转化为旋转矩阵进行计算和应用。</p>
<h2 id="旋转矩阵-欧拉角-旋转向量-四元数-详解"><a href="#旋转矩阵-欧拉角-旋转向量-四元数-详解" class="headerlink" title="旋转矩阵 欧拉角 旋转向量 四元数 详解"></a>旋转矩阵 欧拉角 旋转向量 四元数 详解</h2><p>在计算机图形学、计算机视觉、机器人学等领域，旋转是一个重要的概念，用于描述物体在三维空间中的姿态变化。为了表示旋转，存在多种方法，包括旋转矩阵、欧拉角、旋转向量和四元数。以下是对这些方法的详细解释：</p>
<p><strong>1. 旋转矩阵（Rotation Matrix）：</strong><br>旋转矩阵是一个3x3的矩阵，用于描述物体在三维空间中的旋转操作。矩阵的每一列和每一行都是一个单位向量，分别表示旋转后的X、Y和Z轴方向。旋转矩阵满足正交性质，即列向量和行向量都是正交归一的。旋转矩阵可以通过多种方式创建，例如使用轴角、欧拉角、四元数等。</p>
<p><strong>2. 欧拉角（Euler Angles）：</strong><br>欧拉角是一组用于描述旋转的三个角度，通常表示为 ( \phi, \theta, \psi ) 或者 Roll、Pitch、Yaw。它们分别表示绕X轴、Y轴和Z轴旋转的角度。尽管欧拉角在某些情况下很直观，但它们存在万向节死锁问题，当某个轴的角度接近90度时，其他轴的旋转将受到限制。</p>
<p><strong>3. 旋转向量（Rotation Vector）：</strong><br>旋转向量是一个三维向量，其方向指示旋转轴，大小表示旋转角度。旋转向量通常与轴角表示法相关联，其中向量的方向是旋转轴，向量的长度是旋转角度。旋转向量的优点之一是它在大角度旋转时较稳定。</p>
<p><strong>4. 四元数（Quaternions）：</strong><br>四元数是一种复数扩展，用于表示旋转。它们在旋转计算中非常有用，因为它们避免了欧拉角的问题，并且在连续旋转和插值计算中表现出色。四元数由一个实部和三个虚部组成，可以使用复数运算来进行旋转计算。</p>
<p>每种方法都有其优点和缺点，适用于不同的应用场景。选择正确的表示方法取决于您的需求，考虑到精度、稳定性和计算效率等因素。在实际应用中，通常会根据具体情况选择最适合的旋转表示方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Tesseract/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Tesseract/" class="post-title-link" itemprop="url">Tesseract</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Tesseract库</li>
</ul>
<h2 id="Tesseract是什么"><a href="#Tesseract是什么" class="headerlink" title="Tesseract是什么"></a>Tesseract是什么</h2><p>Tesseract是一个开源的OCR（光学字符识别）引擎，由HP实验室开发，并在2006年后由Google维护和发展。该引擎能够将图像中的文本转换成可编辑的文本格式，例如TXT、HTML或PDF。Tesseract能够处理多种语言，并且在某些情况下，它的识别准确率相当高。</p>
<p>Tesseract采用C++编写，但也提供了Python、Java等语言的接口，因此可以方便地在不同的编程环境中使用。它支持多种操作系统，包括Windows、Linux和macOS。</p>
<p>Tesseract的功能强大，应用广泛。它被用于许多领域，如文档扫描、数字化图书馆、自动化办公等。配合其他图像处理库，例如OpenCV，Tesseract能够实现更复杂的文本识别任务，并且被广泛应用于实际项目中。</p>
<h2 id="Tesseract-详解"><a href="#Tesseract-详解" class="headerlink" title="Tesseract 详解"></a>Tesseract 详解</h2><p>Tesseract是一个开源的OCR（光学字符识别）引擎，它能够将图像中的文本转换成可编辑的文本格式。以下是对Tesseract的详细解释：</p>
<ol>
<li><p><strong>历史</strong>：</p>
<ul>
<li>Tesseract最初由HP实验室开发，并于1985年首次发布。在2006年之后，Google接手了Tesseract的开发和维护，并进行了大幅改进和更新。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>文本识别：Tesseract能够从图像中识别文本，将其转换为计算机可编辑的文本格式，例如TXT、HTML或PDF。</li>
<li>多语言支持：Tesseract支持超过100种语言的识别，包括各种语种的拉丁字母、亚洲语言等。</li>
<li>精度和性能：Tesseract在一些情况下具有较高的识别准确率，特别是对于印刷体文本和标准字体。</li>
<li>配置灵活：用户可以通过配置文件来调整Tesseract的识别行为，例如指定识别语言、设置识别参数等。</li>
</ul>
</li>
<li><p><strong>使用</strong>：</p>
<ul>
<li>Tesseract提供了C++接口，但也支持其他编程语言的接口，如Python、Java等，因此可以方便地在不同的开发环境中使用。</li>
<li>通常，使用Tesseract进行文本识别的过程包括图像预处理、调用Tesseract进行识别、获取识别结果并处理。</li>
</ul>
</li>
<li><p><strong>应用领域</strong>：</p>
<ul>
<li>文档扫描和数字化：Tesseract常用于将扫描的文档转换为可搜索的文本，或将图书、报纸等内容数字化。</li>
<li>自动化办公：Tesseract可以用于自动化办公流程中的文本提取和识别，如自动化填写表单、识别发票、提取邮件内容等。</li>
<li>数据挖掘和信息检索：Tesseract也被用于数据挖掘和信息检索领域，以从图像中提取有用的信息和数据。</li>
</ul>
</li>
</ol>
<p>总的来说，Tesseract是一个功能强大且广泛应用的OCR引擎，它为用户提供了将图像中的文本转换为可编辑文本的解决方案，并在许多领域中发挥着重要作用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Software_development_base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Software_development_base/" class="post-title-link" itemprop="url">Software_development_base</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="计算机系统-–-基础知识"><a href="#计算机系统-–-基础知识" class="headerlink" title="计算机系统 –  基础知识"></a>计算机系统 –  基础知识</h2><ul>
<li><p>计算系统，是一个完整的工作系统。系统不仅包括计算机，还包括各种软件以及外部设备。</p>
</li>
<li><p>计算机就是用于执行指定操作的机器，这些操作通常是一组指令的集合，这些指令也称为软件(software)</p>
</li>
<li><p>计算机硬件(hardware)是系统的物理组成部分，是可以真真切切触摸到的</p>
</li>
<li><p>硬件包括计算机及其周边设备，例如键盘，鼠标，显示器，硬盘，打印机等</p>
</li>
<li><p>计算机软件是以电子形式在硬件中驻留和运行的程序，例如编译器，操作系统以及应用程序等。软件提供了人机接口(Human Computer Interface, HCI)，并定义了计算机应该执行的操作</p>
</li>
</ul>
<h3 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h3><ul>
<li><p>在冯·诺依曼的模型里，可以看到输入设备，输出设备，存储单元以及由控制单元(control unit)和带有累加器(accumulator)的算数逻辑单元(Arithmetic Logic Unit, ALU)构成的模块</p>
</li>
<li><p>存储单元存储数据，控制单元则控制数据的传输和数据的处理。</p>
</li>
<li><p>控制单元取回指令并对其进行译码后存入存储单元中，同时从输入设备接收数据，并将数据存入存储单元</p>
</li>
<li><p>控制单元对可执行指令进行译码，并将数据送入ALU。 ALU执行操作，控制单元则将计算结果送入输出设备。</p>
</li>
<li><p>这里的控制单元和ALU一起称为中央处理单元(Central Processing Unit, CPU)</p>
</li>
<li><p>ALU中的累加器是一组高速寄存器的集合，用作算术和逻辑操作的操作数和结果的临时存储</p>
</li>
<li><p>ALU中的寄存器大小对应着计算机的字长(word size)。</p>
</li>
<li><p>一般的字长有16位，32位，64位，这取决于处理器的设计方案</p>
</li>
<li><p>1位代表一个二进制位，而且处理器的字长都是2的幂</p>
</li>
</ul>
<h3 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h3><ul>
<li><p>计算机软甲包含了我们希望计算机执行的指令或者命令。</p>
</li>
<li><p>在计算机软件中的分类中有几类比较重要，包括操作系统，软件工具，各种程序语言的编译器</p>
</li>
<li><p>如果某个工程问题可以通过使用软件工具解决，通常来说，这比写一个程序来解决问题更高效。</p>
</li>
<li><p>然而，很多问题都不能通过现有软件工具来解决，或者软件工具在需要解决问题的计算机系统上不可用，因此，我们也需要知道如何使用计算机语言来写程序。</p>
</li>
<li><p>随着一些功能强大的软件的出现，这些软件除了支持专门的操作系统还包含了编程语言，这使得软件工具和计算机语言之间的区别变得越来越模糊</p>
</li>
</ul>
<h3 id="计算机语言"><a href="#计算机语言" class="headerlink" title="计算机语言"></a>计算机语言</h3><ul>
<li><p>计算机语言有不同的层次</p>
</li>
<li><p>机器语言(machine language)是最基础的语言，是与计算机硬件设计密切相关的</p>
</li>
<li><p>因为计算机的设计是建立在二态技术（类似的情况有电路的开合，开关的打开与关闭，电池的正负极）基础上的，所以机器语言也使用两种符号来编写，通常使用数字0和1来表示。</p>
</li>
<li><p>因此，机器语言也是一种二进制语言，它的指令都是使用由0和1组成的序列携程的，这些序列称为二进制串</p>
</li>
<li><p>因为机器语言是与计算机硬件紧密相关的，所以SUN计算机上与HP计算机上的机器语言是不同的</p>
</li>
<li><p>对于某种特定的计算机设计语言，汇编语言(assembly language)也是唯一的，但是汇编语言的指令是用可读性更好的符号语句而非二进制串编写的</p>
</li>
<li><p>汇编语言的语句类型通常并不是很多，在使用汇编语言时，必须了解与之相应的硬件信息，</p>
</li>
<li><p>包含微处理器的设备通常要求程序能够极快地执行，这样的程序称为实时程序(real-time program)</p>
</li>
<li><p>实时程序通常使用汇编语言编写，这样可以发挥特定计算机硬件的优势，以提高执行速度</p>
</li>
<li><p>高级语言(high-level language)是具有类似自然语言的命令和指令的计算机语言，C++，C, Fortran,Ada, Java,Basic等都是高级语言</p>
</li>
<li><p>执行计算机程序，要执行使用诸如C++这样的高级语言编写的程序，必须先将高级语言指令翻译成机器语言。</p>
</li>
<li><p>执行这种翻译任务的程序称为编译器(compiler)</p>
</li>
<li><p>在编译阶段出现的错误称作解析错误(parse error)或语法错误(syntax error)</p>
</li>
<li><p>当没有语法错误后，编译器就可以成功地翻译程序，并声称机器语言形式的程序，生成的程序将完成最开始C++程序所要执行的功能。</p>
<ul>
<li>这一，C++程序称为源文件(source file)，而生成的机器语言版本则称为目标文件(object file)</li>
<li>因此，源程序和目标程序所描述的功能是一致的，但是源程序使用高级语言编写的，而目标程序则是以机器语言的形式</li>
</ul>
</li>
<li><p>执行(execution)，这些步骤包括将目标程序与机器语言语句进行链接(linking)和把程序载入(loading)内存</p>
</li>
<li><p>在执行阶段出现的错误称为执行错误(execution error)，运行时错误(run-time error)或逻辑错误(logic error)，这些错误也叫做程序bug</p>
</li>
<li><p>如果执行错误是由于程序中所编写的语句产生的，必须在源程序中修改错误并重新进行编译，这个过程叫做调试(debugging)</p>
</li>
</ul>
<h3 id="数据的表示与存储"><a href="#数据的表示与存储" class="headerlink" title="数据的表示与存储"></a>数据的表示与存储</h3><ul>
<li><p>在数字计算机中，一个二进制位可以使用一个位(bit)表示。</p>
</li>
<li><p>位上的值在任何时候都只能是0或1.从硬件的角度来说，当该位处于关闭或低电位时，它的值为0，而当其处于打开或高电位时，其值为1</p>
</li>
<li><p>二进制数在内存中以序列的形式存储，位序列称为字(word)</p>
</li>
<li><p>字的长度每增加1位，字所表示的数的大小就以2的幂增加，而其所能表示的范围就翻一倍</p>
</li>
<li><p>内存中可用的字的数目称为内存空间，或者地址空间(address space)</p>
</li>
<li><p>字长决定了存储在某个地址中的数值范围，而地址空间则决定了可以存储多少个字</p>
</li>
<li><p>C++包含整型数，浮点数，字符和布尔值等内建的数据类型。每种数据类型都由一个以字节(byte)为单位来确定的预定义大小，1个字节就是一个8位的序列。</p>
</li>
<li><p>为了定义标识符(identifier)并为它分配空间，则需要使用类型声明语句(type declaration statement)。</p>
</li>
<li><p>当定义一个标识符时，便确定了其数据类型，并在内存中分配相应字节数的空间。</p>
</li>
<li><p>当数据存储在内存中时，它是以位序列存在的。</p>
</li>
<li><p>这些位序列可能是指令，数字，字符，图像或数字信号的一部分，或者是其他类型的数据</p>
<ul>
<li>负数的存储</li>
<li>浮点数的存储</li>
</ul>
</li>
</ul>
<h2 id="框架-Framework"><a href="#框架-Framework" class="headerlink" title="框架(Framework)"></a>框架(Framework)</h2><ul>
<li><p>什么是框架？</p>
<ul>
<li>框架(<code>Framework</code>)是构成一类特定软件可复用设计的一组相互协作的类。框架规定了你的应用的体系结构。</li>
<li>它定义了整体结构，类和对象的分割，各部分的主要责任，类和对象怎么协作，以及控制流程。框架预定义了这些设计参数，以便于应用设计者或实现者能集中精力于应用本身的特定细节</li>
<li>框架一般处在低层应用平台和高层业务逻辑之间的中间层</li>
</ul>
</li>
<li><p>为什么要用框架？</p>
<ul>
<li>因为软件系统发展到今天已经很复杂了，特别是服务器端软件，涉及到的知识，内容，问题太多。在某些方面使用别人成熟的框架，就相当于让别人帮你完成一些基础工作，你只需要集中精力完成系统的业务逻辑设计。</li>
<li>而且框架一般是成熟，稳健的，他可以处理系统很多细节问题，比如，事务处理，安全性，数据流控制等问题。</li>
<li>还有框架一般都经过很多人使用，所以结构很好，所以扩展性也很好，而且它是不断升级的，你可以直接享受别人升级代码带来的好处</li>
</ul>
</li>
<li><p>软件为什么要分层？</p>
</li>
</ul>
<ul>
<li>为了<strong>实现“高内聚、低耦合”</strong>。把问题划分开来各个解决，易于控制，易于延展，易于分配资源等</li>
</ul>
<ul>
<li><p>框架和设计模式</p>
<ul>
<li>构件通常是代码重用，而设计模式是设计重用，框架则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用</li>
<li>框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象</li>
<li>框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;</li>
<li>设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用</li>
</ul>
</li>
<li><p>构件(component)</p>
<ul>
<li>构件是面向软件体系架构的可复用软件模块。</li>
<li>构件是可复用的软件组成成份，可被用来构造其他软件。它可以是被封装的对象类、类树、一些功能模块、软件框架（framework）、软件构架（或体系结构Architectural）、文档、分析件、设计模式（Pattern）等</li>
<li>1995年，Ian Graham给出的构件定义如下：构件（Component）是指一个对象（接口规范、或二进制代码），它被用于复用，接口被明确定义</li>
<li>构件是作为一个逻辑紧密的程序代码包的形式出现的，有着良好的接口</li>
<li>采用构件软件不需要重新编译，也不需要源代码并且不局限于某一种编程语言。该过程叫做<strong>二进制复用（Binary Reuse）</strong>，因为它是建立在接口而不是源代码级别的复用之上的。虽然软件构件必须遵守一致的接口，但是它们的内部实现是完全自动的。因此，可以用过程语言和面向对象语言创建构件</li>
</ul>
</li>
<li><p>构件和面向对象设计的差别</p>
<ul>
<li>在纯面向对象的设计中，对象（类）、封装和继承三者缺一不可，但对构件可以没有继承性，只要实现封装即可</li>
<li>从构件和对象的生成方式上，对象生成属于实例化的过程，比较单一，而生成构件的方式较多</li>
<li><strong>构件是设计的概念，与具体编程语言无关，不像对象属于编程中的概念，要依赖于具体的编程语言</strong></li>
<li>在对构件操作时不允许直接操作构件中的数据，数据真正被封装了。而对象的操作通过公共接口部分，这样数据是可能被访问操作的</li>
<li>对象对软件复用是通过继承实现的，构件对软件复用不仅可以通过继承还可以通过组装时的引用来实现</li>
<li>因此，构件不是对象，只是与对象类似</li>
</ul>
</li>
<li><p>在软件生产中有三种级别的重用：</p>
<ul>
<li><strong>内部重用</strong>，即在同一应用中能公共使用的抽象块</li>
<li><strong>代码重用</strong>，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用</li>
<li><strong>应用框架的重用</strong>，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性</li>
</ul>
</li>
<li><p>框架开发</p>
<ul>
<li>框架的最大好处就是重用。面向对象系统获得的最大的复用方式就是框架，一个大的应用系统往往可能由多层互相协作的框架组成</li>
<li>由于框架能重用代码，因此从一已有构件库中建立应用变得非常容易，因为构件都采用框架统一定义的接口，从而使构件间的通信简单</li>
</ul>
</li>
<li><p>框架解决的问题</p>
<ul>
<li>框架要解决的最重要的一个问题是技术整合的问题</li>
<li>软件企业的研发将集中在应用的设计上，而不是具体的技术实现，技术实现是应用的底层支撑，它不应该直接对应用产生影响</li>
<li>举例：<ul>
<li>一个做视频流应用的软件企业，他为电广行业提供整体的解决方案。他的优势在于将各种各样的视频硬件、服务器、和管理结合起来，因此他扮演的是一个集成商的角色。因此他的核心价值在于使用软件技术将不同的硬件整合起来，并在硬件的整合层面上提供一个统一的管理平台。所以他的精力应该放在解决两个问题<ul>
<li>如何找到一种方法，将不同的硬件整合起来，注意，这里的整合并不是技术整合，而是一种思路上的整合 </li>
<li>如何描述这个管理系统的规范。你需要描述各种管理活动，以及管理中所涉及的不同实体。因为管理系统是针对硬件的管理，所以它是构架在硬件整合平台之上的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据模型-Data-Model"><a href="#数据模型-Data-Model" class="headerlink" title="数据模型(Data Model)"></a>数据模型(Data Model)</h2><ul>
<li><p>数据模型（Data Model）是数据特征的抽象，它从抽象层次上描述了系统的静态特征、动态行为和约束条件，<strong>为数据库系统的信息表示与操作提供一个抽象的框架</strong>。数据模型所描述的内容有三部分，分别是数据结构、数据操作和数据约束</p>
</li>
<li><p>模型可更形象、直观地揭示事物的本质特征，使人们对事物有一个更加全面、深入的认识，从而可以帮助人们更好地解决问题。利用模型对事物进行描述是人们在认识和改造世界过程中广泛采用的一种方法。计算机不能直接处理现实世界中的客观事物，而数据库系统正是使用计算机技术对客观事物进行管理，因此就需要对客观事物进行抽象、模拟，以建立适合于数据库系统进行管理的数据模型。数据模型是对现实世界数据特征的模拟和抽象</p>
</li>
<li><p>数据模型是数据库设计中用来对现实世界进行抽象的工具，是数据库中用于提供信息表示和操作手段的形式构架。数据模型是数据库系统的核心和基础</p>
</li>
<li><p>数据模型所描述的内容包括三个部分：数据结构、数据操作、数据约束</p>
<ul>
<li><strong>数据结构</strong>：数据模型中的数据结构主要描述数据的类型、内容、性质以及数据间的联系等。数据结构是数据模型的基础，数据操作和约束都建立在数据结构上。不同的数据结构具有不同的操作和约束</li>
<li><strong>数据操作</strong>：数据模型中数据操作主要描述在相应的数据结构上的操作类型和操作方式</li>
<li><strong>数据约束</strong>：数据模型中的数据约束主要描述数据结构内数据间的语法、词义联系、它们之间的制约和依存关系，以及数据动态变化的规则，以保证数据的正确、有效和相容</li>
</ul>
</li>
</ul>
<h2 id="如何分析和解决一个任务：思维方式"><a href="#如何分析和解决一个任务：思维方式" class="headerlink" title="如何分析和解决一个任务：思维方式"></a>如何分析和解决一个任务：思维方式</h2><ol>
<li>先从整体上有一个总体思路，比如各个模块之间如何通信、依赖等，然后从一个点开始，照着调用路径分析下去，不要看一个类中的每个方法，而是只看用到的方法。</li>
<li>把所想要完成的目标分步实现，如果思路不清晰，不知道如何去做，可以模拟现实中的步骤。<ol>
<li>要把想实现的东西转换成代码，不要想着最终结果好难，不知道怎么做。</li>
<li>先分步，一步一步完成，然后分别去想每一步是怎么实现的。第一次写完之后肯定是缺陷的，仔细反复调试，慢慢修改优化，不要看着目标就被吓到。</li>
</ol>
</li>
<li>函数最主要的作用就是将一个大型程序分解成多个易于管理的小部分，这一过程称为分解（decomposition）。而你所需做的应是将一个高层次问题细分为一系列低层次的函数，每一个函数有其自己独立的功能。然而，找到问题正确的细分方法有很大的挑战，需要不断练习、思考和尝试。编程是一门艺术，好的问题分解策略主要来源于实际经验。</li>
<li>然而，作为一种通用的规则，问题的分解过程一般从程序的主程序开始。此时，我们将整个程序视为一个整体，并尝试从中分析并抓取出其主要部分。一旦程序的最主要部分被识别出来，就可以将它们定义为一些相互独立的函数。由于某些函数可能本身依然复杂，因此通常需要将他们再分解为更小的部分。我们可以不断重复这一分解过程直到每个问题足够简单明了以便于解决。上述分解过程称为<strong>自顶向下的程序设计（top-down design）</strong>或<strong>逐步求精的方法（ste[wose refinement）</strong></li>
</ol>
<h2 id="深入理解计算机操作系统"><a href="#深入理解计算机操作系统" class="headerlink" title="深入理解计算机操作系统"></a>深入理解计算机操作系统</h2><p>过程是软件中一种很重要的抽象</p>
<ul>
<li>它提供了一种封装代码的方式,用一组指定的参数和一个可选的返回值实现了某种功能.然后,可以再程序中不同的地方调用这个函数,设计良好的软件用过程作为抽象机制,隐藏某个行为的具体实现,同时又提供清晰简洁的接口定义,说明要计算的是哪些值,过程会对程序状态产生什么样的影响.</li>
<li>不同编程语言中,过程的形式多样:函数(function),方法(method),子例程(subroutine),处理函数(handle)等等</li>
</ul>
<p>数据对齐</p>
<ul>
<li>许多计算机系统对基本数据类型的合法地址做出了一些限制,要求某种类型对象的地址必须是某个值K(通常是2,4或8)的倍数,这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计</li>
<li>强制对齐:<ul>
<li>对于大多数x86-64指令来说,保持数据对其能够提高效率,但是它不会影响程序的行为</li>
<li>另一方面,如果数据没有对齐,某些型号的Intel和AMD处理器对于有些实现多媒体操作的SSE指令,就无法正确执行.</li>
</ul>
</li>
</ul>
<p>理解指针</p>
<ul>
<li><p>指针以一种统一方式,对不同数据结构中的元素产生引用</p>
</li>
<li><p>每个指针都对应一个类型,这个类型表明该指针指向的是哪一类对象</p>
<ul>
<li><code>int* ip</code>表示变量ip是一个指向int类型对象的指针,<code>char** cpp</code>表示cpp指针指向的对象自身就是一个指向char类型对象的指针</li>
<li>通常,如果对象类型为<code>T</code>,那么指针的类型为<code>T*</code>;特殊的, <code>void *</code>类型代表通用指针.比如说,malloc函数返回一个通用指针,然后通过显式强制类型转换或者赋值操作那样的隐式强制类型转换,将它转换成一个有类型的指针.</li>
<li>指针类型不是机器代码中的一部分,它们是C语言提供的一种抽象,帮助程序员避免寻址错误</li>
<li>每个指针都有一个值,这个值是某个指定类型的对象的地址.特殊的NULL(0)值表示该指针没有指向任何地方</li>
<li>指针用<code>&amp;</code>运算符创建.这个运算符可以应用到任何<code>lvalue</code>类的C表达式上,<code>lvalue</code>表示可以出现在赋值语句左边的表达式</li>
<li><code>*</code>操作符用于间接引用指针,其结果是一个值,它的类型与该指针的类型一致,<strong>间接引用</strong>是用内存引用来实现的,要么是存储到一个指定的地址,要么是从指定的地址读取</li>
<li>数组与指针紧密联系.一个数组的名字可以像一个指针变量一样引用(但是不能修改).数组引用(例如<code>a[3]</code>)与指针运算和间接引用(例如<code>*(a + 3)</code>)有一样的效果.数组引用和指针运算都需要用对象大小对偏移量进行伸缩</li>
<li>将指针从一种类型强制转换成另一种类型,只改变它的类型,而不改变它的值.强制类型转换的一个效果是改变指针运算的伸缩</li>
<li>指针也可以指向函数.这提供了一个很强大的存储和向代码传递引用的功能,这些引用可以被程序的某个其他部分调用</li>
</ul>
</li>
<li><p>内存越界引用和缓冲区溢出</p>
<ol>
<li>模型相关的,b站视频</li>
<li>多看项目(github),多练</li>
<li>大厂的代码,main中变量的声明(amlogic, nvidia)</li>
<li>shell 不必花费太多精力,推荐:python,php(现在不要去学,单点击穿,现在主要学习C++)</li>
</ol>
</li>
</ul>
<h2 id="如何阅读大型项目的代码？"><a href="#如何阅读大型项目的代码？" class="headerlink" title="如何阅读大型项目的代码？"></a>如何阅读大型项目的代码？</h2><ul>
<li>目的性：读代码的时候如果有目的性是最好的。</li>
<li>时间：总体来讲，阅读大型项目的代码需要时间。</li>
<li>方法论：抽象地说，阅读代码有两种方向，自底向上和自顶向下。<ul>
<li>自底向上，从具体的文件到子模块，从子模块到功能集，再到整个项目，强调的是从具体实现出发总结出一般抽象。</li>
<li>自顶向下，从项目的顶层设计到责任分发，从责任分发到功能分发，再到具体的实现代码，强调的是从抽象设计出发落实到具体实现。</li>
<li>两种方法是两个不同的视角。实践中经常需要结合两种方向随时切换地采用，当对大方向了解不足的时候自顶向下的看，当对实现细节不够明确的时候自底向上的看</li>
</ul>
</li>
</ul>
<h2 id="上下文-context"><a href="#上下文-context" class="headerlink" title="上下文 context"></a>上下文 context</h2><ul>
<li><p>维基百科</p>
<ul>
<li>在计算机科学中，任务(task)的上下文(context)是一个任务所必不可少的一组数据（该任务可以是进程，线程）。</li>
<li>这些数据允许任务中断，在这之后仍可在同一个地方继续执行。上下文的这一概念在中断的任务的场景下具有重大意义。其中，任务在被中断之后，处理器保存上下文并提供中断处理(interrupt service routine)。因此，上下文越小，延迟越小。</li>
<li>上下文的数据可能存放于处理器寄存器，任务所利用的内存，某些操作系统管理的任务所使用的控制寄存器(control registers)</li>
</ul>
</li>
<li><p>通俗的理解，上下文，也就是执行任务所需要的相关信息。</p>
</li>
<li><p>这个任务可以是一段代码，一个线程，一个进程，一个函数。当这个“任务”相关的信息需要保存下来时，就可以使用<code>context</code>来记录。</p>
</li>
</ul>
<h2 id="关于业务对象（Business-Object）本质的思考"><a href="#关于业务对象（Business-Object）本质的思考" class="headerlink" title="关于业务对象（Business Object）本质的思考"></a>关于业务对象（Business Object）本质的思考</h2><ul>
<li><p>对于采用OO(<code>Object Oriented</code>)思想，并具有N层架构的计算机程序而言，业务对象（<code>Business Object</code>）一般位于业务逻辑层（也叫领域层[1]），作为领域模型元素的一部分，描述了来自于业务域中的一个人、事、物或概念[2]，主要用来解决商业逻辑（即业务操作）问题，是为实现当前软件（或系统）的某一（或某些）特定功能而服务的。因此，它仅仅是从当前业务域的角度，对现实世界的一次抽象。</p>
</li>
<li><p>业务对象、业务实体、实体、领域对象在某种程度上是可以互换的术语[此处仅仅说是“某种程度上”，目的在于分析BO三要素的实质，针对于不同的理论，这几个名词确实存在差别]</p>
</li>
<li><p>对象三要素</p>
<ul>
<li>标识（identity），是唯一区别其他对象的标志；</li>
<li>状态（state），描述对象所蕴含的信息；</li>
<li>行为（behavior），对象所持有的、描述对象如何被使用的方法</li>
</ul>
</li>
</ul>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li><p>相对于字段、变量、属性等词，用“状态”一词来描述对象的“性格特点”最为合适。字段、变量、属性等，无非是描述对象状态的不同表现手法</p>
</li>
<li><p>就目前个人对BO状态的理解而言，BO的状态信息有两类：固有信息和动态信息。</p>
<ul>
<li>固有信息，是对象从诞生时与生俱来的信息（就像一个新生命的诞生一样，出生年月日、肤色、性别等信息是生来就有的）；</li>
<li>动态信息，即随着BO的成长，它会走入某一个人生场景中，扮演了某一个角色，从而在这个场景中被赋予了一些额外的信息，如：小明是个学生（从入学时，学生的基本信息被赋予），某天他去市图书馆借阅图书，此时他在借书这个场景中扮演了借书者这个角色，从而具有了借阅证、借阅信息等动态信息。</li>
</ul>
</li>
<li><p><strong>固有信息</strong></p>
<ul>
<li>业务对象在被构建（初始化）后，应达到一个相对比较稳定，且具有一定业务含义的状态，即业务对象的属性应已进行了相应的初始化设置，这样的构建才算合理、完整</li>
<li>与人类世界类似，人在出生时，就已经构造好了婴儿的鼻子、眼睛、手等内容，虽然此时他还没有衣服、母语、身份证等信息，但他在出生时，是一个相对较稳定且有意义的个体，就可以完成婴儿的核心操作，如：哭、呼吸、挥手等。</li>
<li>提前构造好该构造好的信息（注意：不是所有的信息都要一股脑的全构造好）是保证BO不被滥用的第一步</li>
</ul>
</li>
<li><p>动态信息</p>
<ul>
<li>进入某一场景，扮演某一角色（我更喜欢用“戴上帽子”这个说法），将拥有额外的动态属性。同“固有属性”的构建，某一业务对象走入特定的场景，扮演了另一角色时，也应该将这些动态属性予以设置</li>
<li><strong>对象应尽量在构建自身的过程中完成自身状态的设置</strong>。</li>
</ul>
</li>
</ul>
<h3 id="属性封装"><a href="#属性封装" class="headerlink" title="属性封装"></a>属性封装</h3><ul>
<li><p>在OO的世界里，封装的概念是最简单的，但却是最关键且最难以把握的</p>
</li>
<li><p>信息不封装（或封装不完整）带来的副作用</p>
<ul>
<li>内聚，难。业务对象的信息过多的暴露出去，容易滋生强盗逻辑，想捏回去形成一团，难！信息全部都暴露给外界，调用者还需要你BO干嘛？原因很简单：我能够伸手拿到你的任何信息，想实现什么就实现什么，可以为所欲为。如果你还有胆量暴露一些更改BO属性的权限，那我岂不是想怎么改就怎么改</li>
<li>解耦，难。一个成语叫“覆水难收”，放出去的信息将被调用者肆意使用，而且呈现出快速蔓延的趋势，一张复杂的<strong>耦合网</strong>必然产生。等回头开始重构解耦时，发现堆积如山的代码、耦合似网的结构，已经让你无从下手。动一下，就引起全身阵痛</li>
<li>常见的做法<ul>
<li>刨一小块，改改变量名、方法名，移一些代码，用接口再包装一下（隔离嘛），循环的修改，最终发现进展依然是非常缓慢，几乎还没触及到业务核心；</li>
<li>先用方法（1）试试，一阵子后，MD，烦死了，直接推倒重新搞。这些做法还需要考虑一个问题：放出去的接口和信息已被调用者大量使用，怎么办？</li>
</ul>
</li>
</ul>
</li>
<li><p>针对上述的苦痛，推荐下面的做法：</p>
<ul>
<li>在对象构建时，把能设置的状态信息尽可能的予以赋值，提前封装；</li>
<li>尽可能的不要公布内部信息。能够<code>private</code>的，尽可能的私有。除非迫不得已，尽量不要将<code>setter()</code> 放出，仅使其<code>read only</code>。</li>
</ul>
</li>
</ul>
<h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><ul>
<li><p>业务行为才是软件真正所关注的问题，对象的行为方式是对象价值的重要体现，也是区别于其他对象的重要标志。</p>
</li>
<li><p><strong>因此，我们说“BO因职责而存在！”</strong></p>
</li>
<li><p>贫血VS充血</p>
<ul>
<li>贫血对象<ul>
<li>由不具有任何行为的业务对象形成的领域模型，称为“贫血模型”[2]。对只有属性的getter&#x2F;setter方法，不具有业务行为的BO，可认为是“贫血对象”。</li>
<li>丧失业务逻辑行为的贫血对象，和Value Oject类似，扮演了Data Container的角色，而在业务域中的逻辑操作方面将失去能力（或被遗弃、边缘化）</li>
</ul>
</li>
<li>充血对象</li>
<li>按大师的说法，与BO直接相关的行为职责将划归到BO中，使其在领域模型中扮演重要的角色</li>
</ul>
</li>
<li><p>但是二者不能绝对的说谁好、谁不好，应该一分为二的去看，它们各自具有其特点，应用在不同的场景中。特别地，对于那些需求难以完全吃透、明确，或许用贫血模型较充血模型要更好把控局势。</p>
</li>
<li><p><strong>用户需求——业务——领域</strong>是一个对知识掌握程度递增的过程，领域模型的建立应基于对客观业务域的透彻掌握，不能偏左，也不可以偏右（不就是博弈么？没有最优秀的东西，只存在考虑诸多因素下的较为合适的东西）</p>
</li>
<li><p>business core</p>
<ul>
<li>它应该是最精炼、纯粹、简单、直接、轻量级的业务核心。</li>
<li>因此，不属于核心业务逻辑范畴的职责和行为（如：持久化操作），尽量抛出去交给该处理它们的对象去处理。</li>
</ul>
</li>
<li><p>上帝类（God class）</p>
<ul>
<li>可以认为它就是一个充血充得快爆掉的对象</li>
<li>它几乎可以干所有涉及到它的工作，从而形成代码有几百行乃至上千行的牛X类</li>
<li>有了这么一个牛X类，其他类不就成了浮云和鸡肋了么？这样可能引发很多问题<ul>
<li>理解难。几千行的代码，没有几个人有耐心阅读，几乎没人能够完全理解其表达的业务含义。</li>
<li>修改难。没有很好的理解，如何修改？如何重构？</li>
<li>扩展难。丢了它玩不转，不丢它又引来一堆麻烦，对于一个几千行的实现类来说（除非大多都是public static 的方法），吃资源不说，接口隔离、应对扩展方面也是比较吃力的。</li>
</ul>
</li>
</ul>
</li>
<li><p>谁拥有数据，谁持有行为</p>
<ul>
<li>BO行为的本质是对BO自身状态的改变，以实现业务目标，并且这种状态的更改可能还需要其他协作者的参与（关联关系）。</li>
<li>因此，我们可以说“<strong>谁拥有数据，谁就持有更改这些数据（状态）的行为</strong>”</li>
<li>现实中，跟BO有关系的行为可能较多，全部纳入到BO中，会造成BO的臃肿和污染，违背SRP（职责单一）<ul>
<li>可重用度高或是对象固有、与BO状态密切关联的方法放在BO中</li>
<li>可重用度低或者不是对象所固有（而依赖于特定场景）、与BO状态没有密切联系的方法放在BO管理者或服务层</li>
</ul>
</li>
</ul>
</li>
<li><p>方法属于客户</p>
<ul>
<li>BO就是一个黑盒子，其中包含了逻辑和数据，而对象的使用者不知道里面有什么数据，也不知道实际的运行逻辑。使用者所能做的就是与对象进行交互，以完成当前的业务目标。因此，对象的行为是为客户而定</li>
<li>行为（方法、职责）是BO存在的根本，而行为就是为了交互，为供调用者所使用。</li>
<li>调用者会根据自己的需要，向它认为应该由谁提供行为的BO发出操作申请，一切都是以“客户（调用者）”为中心而服务的</li>
</ul>
</li>
</ul>
<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><ul>
<li><p>程序 &#x3D; 算法 + 模型 + 数据结构</p>
</li>
<li><p>传统的程序只是算法和数据结构的组合，但是在AI迅猛发展的今天，在程序里几乎都有个“模型”</p>
</li>
<li><p>模型，一般是指机器学习或深度学习训练出来的<code>Model</code>，里面既有逻辑又有数据，所以它既不是单纯的算法，也不是单纯的数据结构。</p>
</li>
<li><p>软件工程师 &#x3D; 程序员 + 软件工程知识</p>
</li>
<li><p>PM(Program Manager) &#x3D; 项目管理 + 产品管理，直译为程序经理，实际上是项目管理和产品管理的二合一角色</p>
</li>
<li><p>团队 &#x3D; PM + 软件工程师 + Designer</p>
<ul>
<li>Designer， 直译就是设计师，负责用户界面和交互的设计</li>
<li>通常情况下，PM和软件工程师是长期合作的，而Designer有自己的独立组织，与团队是临时合作</li>
</ul>
</li>
<li><p>软件工程 &#x3D; 团队 + 过程定义 + 执行</p>
</li>
<li><p>软件 &#x3D; 程序 + 软件工程</p>
</li>
<li><p>软件公司 &#x3D; 软件产品 + 商业模式</p>
</li>
</ul>
<h3 id="商业模式的三个概念：产品，-项目，-服务"><a href="#商业模式的三个概念：产品，-项目，-服务" class="headerlink" title="商业模式的三个概念：产品， 项目， 服务"></a>商业模式的三个概念：产品， 项目， 服务</h3><ul>
<li><p>产品，其特点由公司决定要做什么，给客户提供什么，具有长期规划，不断迭代</p>
</li>
<li><p>项目，包括两类：</p>
<ul>
<li>一种是狭义的，在销售给客户产品后，再同时开发&#x2F;提供一些定制软件，那么会有配套的开发人员进行售后服务</li>
<li>另一种是广义的，其宿主是服务或产品，完成其一个小功能</li>
</ul>
</li>
<li><p>服务，以云端服务为主，具有战略意义，这种服务的后台通常有超级复杂的架构体系支撑，在性能，可用性，可靠性上下足了功夫，高并发大容量</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Unit_testing_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Unit_testing_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Unit_testing_单元测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。至于“单元”的大小或范围，并没有一个明确的标准，“单元”可以是一个函数、方法、类、功能模块或者子系统。</li>
<li>单元测试通常和白盒测试联系到一起，如果单从概念上来讲两者是有区别的，不过我们通常所说的“单元测试”和“白盒测试”都认为是和代码有关系的，所以在某些语境下也通常认为这两者是同一个东西。还有一种理解方式，单元测试和白盒测试就是对开发人员所编写的代码进行测试</li>
</ul>
<h2 id="单元测试谁来做？"><a href="#单元测试谁来做？" class="headerlink" title="单元测试谁来做？"></a>单元测试谁来做？</h2><ul>
<li>单元测试一般是有开发人员或测试人员来做。谁来做并没有一个绝对的标准，要根据公司的实际情况来决定。接下来我们分析一下开发人员或测试人员做单元测试的优缺点：</li>
<li>开发人员做单元测试：<ul>
<li>优点：开发人员对代码最熟悉，而且开发人员编程技能相对比较强，所以开发人员自己写单元测试效率上和覆盖率上都比较高</li>
<li>缺点：开发人员平时写业务代码就要花费很多时间，有时候确实没有时间写单元测试；而且大部分开发人员没有太好的测试思想，单元测试可能只是写个最简单的用例就完了；自己写的代码自己测，往往都是不靠谱！</li>
</ul>
</li>
<li>测试人员做单元测试：<ul>
<li>优点：测试人员有比较系统的测试思想，可以更好地保证用例的覆盖。而且通过写单测测试能更好地了解具体代码结构、流程，对于后续的业务测试也非常有利。</li>
<li>缺点：测试人员的编程技能相对比较弱，如果不同编程是无法开展单元测试的。并且测试人员对代码没有开发人员熟悉，效率会比较低。</li>
</ul>
</li>
</ul>
<h2 id="单元测试怎么做？"><a href="#单元测试怎么做？" class="headerlink" title="单元测试怎么做？"></a>单元测试怎么做？</h2><ul>
<li><p>单元测试的实现方式包括：人工静态检查、动态执行跟踪</p>
<ul>
<li>人工静态检查：就是通常所说的“代码走读”，主要是保证代码逻辑的正确性</li>
<li>动态执行跟踪：就是把程序代码运行起来，检查实际的运行结果和预期结果是否一致</li>
</ul>
</li>
<li><p>人工静态检查包含的主要内容：</p>
<ul>
<li>检查算法的逻辑正确性</li>
<li>模块接口的正确性检查</li>
<li>输入参数有没有作正确性检查</li>
<li>调用其他方法接口的正确性</li>
<li>异常错误处理</li>
<li>保证表达式、SQL语句的正确性</li>
<li>检查常量或全局变量使用的正确性</li>
<li>程序风格的一致性、规范性</li>
<li>检查代码注释是否完整</li>
</ul>
</li>
<li><p>动态执行跟踪</p>
<ul>
<li>动态执行跟踪需要编写测试脚本调用业务代码进行测试，为了更好的管理维护测试脚本，一般会采用单元测试框架来管理，不同的语言有不同的单元测试框架：<ul>
<li>Java：JUnit、TestNG</li>
<li>Python：UintTest、pyTest</li>
<li>C++: Catch,googletest</li>
</ul>
</li>
</ul>
</li>
<li><p>单元测试的一个重要的衡量标准就是代码覆盖率，尽量做到代码的全覆盖。常见单元测试覆盖标准：</p>
<ul>
<li>语句覆盖</li>
<li>分支覆盖</li>
<li>条件覆盖</li>
<li>分支-条件覆盖</li>
<li>条件组合覆盖</li>
<li>路径覆盖</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
