<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/19/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/19/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-electron-ssr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-electron-ssr/" class="post-title-link" itemprop="url">electron-ssr</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p><a target="_blank" rel="noopener" href="https://sockboom.me/link/rQMVzREru56EaHvt?mu=1">https://sockboom.me/link/rQMVzREru56EaHvt?mu=1</a></p>
</li>
<li><p>fnyun</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dy.fnyun.online/api/v1/client/subscribe?token=f6a183b1076ff938ff5a8c2ce6806376">https://dy.fnyun.online/api/v1/client/subscribe?token=f6a183b1076ff938ff5a8c2ce6806376</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-dlib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-dlib/" class="post-title-link" itemprop="url">dlib</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>dlib库笔记</li>
</ul>
<h2 id="dlib库-是什么"><a href="#dlib库-是什么" class="headerlink" title="dlib库 是什么"></a>dlib库 是什么</h2><p>dlib库是一个C++库，用于进行机器学习、图像处理和计算机视觉任务。它提供了一系列功能，包括人脸检测、人脸关键点检测、面部表情分析、对象检测、图像处理等。dlib库在计算机视觉领域中非常受欢迎，因为它提供了高效且可靠的实现，广泛用于学术界和工业界的项目中。此外，dlib库还提供了Python接口，使得在Python环境下使用这些功能变得更加便捷。</p>
<h2 id="dlib库-详解"><a href="#dlib库-详解" class="headerlink" title="dlib库 详解"></a>dlib库 详解</h2><p>dlib库是一个功能强大的C++库，主要用于机器学习、图像处理和计算机视觉任务。下面是对dlib库的一些主要功能和特性的详细解释：</p>
<ol>
<li><p><strong>人脸检测和人脸关键点检测</strong>：</p>
<ul>
<li>dlib库提供了高效的人脸检测器，能够在图像中准确地定位人脸的位置。</li>
<li>它还提供了人脸关键点检测器，可以检测出人脸的关键点，如眼睛、鼻子、嘴巴等位置。</li>
</ul>
</li>
<li><p><strong>面部表情分析</strong>：</p>
<ul>
<li>dlib库可以进行面部表情分析，识别出人脸的表情，如快乐、悲伤、惊讶等。</li>
</ul>
</li>
<li><p><strong>对象检测</strong>：</p>
<ul>
<li>除了人脸检测之外，dlib库还支持对象检测，能够识别出图像中的其他物体，如汽车、猫、狗等。</li>
</ul>
</li>
<li><p><strong>图像处理</strong>：</p>
<ul>
<li>dlib库提供了许多图像处理功能，包括图像变换、滤波、边缘检测等，这些功能可以帮助用户对图像进行预处理或增强。</li>
</ul>
</li>
<li><p><strong>机器学习算法</strong>：</p>
<ul>
<li>dlib库包含了许多机器学习算法的实现，如支持向量机（SVM）、k近邻（k-NN）、决策树等，这些算法可用于分类、回归等任务。</li>
</ul>
</li>
<li><p><strong>计算机视觉工具</strong>：</p>
<ul>
<li>dlib库提供了一些计算机视觉工具，如图像配准、图像匹配等，这些工具可以帮助用户处理图像数据并提取有用信息。</li>
</ul>
</li>
<li><p><strong>跨平台支持</strong>：</p>
<ul>
<li>dlib库在多个平台上都可以运行，包括Windows、Linux和macOS，用户可以在不同的操作系统上使用相同的代码。</li>
</ul>
</li>
<li><p><strong>Python接口</strong>：</p>
<ul>
<li>dlib库提供了Python接口，使得在Python环境下使用这些功能变得更加方便。用户可以使用Python调用dlib库中的函数，并结合其他Python库进行开发。</li>
</ul>
</li>
</ol>
<p>总的来说，dlib库是一个功能强大且灵活的工具，适用于各种机器学习、图像处理和计算机视觉任务，因此在学术界和工业界都得到了广泛的应用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-face_recognition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-face_recognition/" class="post-title-link" itemprop="url">face_recognition</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>face_recognition库</li>
</ul>
<h2 id="face-recognition库-是什么"><a href="#face-recognition库-是什么" class="headerlink" title="face_recognition库 是什么"></a>face_recognition库 是什么</h2><p><code>face_recognition</code>库是一个用于人脸识别的Python库。它建立在dlib、OpenCV和NumPy等库之上，提供了简单而强大的接口，用于识别图像或视频中的人脸并进行匹配。<code>face_recognition</code>库的主要功能包括：</p>
<ol>
<li><p><strong>人脸检测</strong>：能够在图像或视频中检测出人脸的位置。</p>
</li>
<li><p><strong>人脸特征提取</strong>：提取出人脸图像的特征向量，用于后续的比较和识别。</p>
</li>
<li><p><strong>人脸识别</strong>：将提取的人脸特征与已知的人脸特征进行比较，从而识别人脸。</p>
</li>
<li><p><strong>人脸标志点检测</strong>：检测出人脸图像中的关键点，如眼睛、鼻子、嘴巴等位置。</p>
</li>
<li><p><strong>实时人脸识别</strong>：能够在视频流中进行实时的人脸识别。</p>
</li>
</ol>
<p><code>face_recognition</code>库的简单接口和易用性使得人脸识别变得更加容易，不需要深入了解复杂的机器学习算法或计算机视觉技术。因此，它在各种应用场景中都有着广泛的应用，包括安全监控、人脸解锁、社交媒体应用等。</p>
<h2 id="face-recognition库-详解"><a href="#face-recognition库-详解" class="headerlink" title="face_recognition库 详解"></a>face_recognition库 详解</h2><p><code>face_recognition</code>库是一个基于Python的人脸识别工具，它建立在dlib、OpenCV和NumPy等库之上，提供了简单而强大的接口，用于识别图像或视频中的人脸并进行匹配。下面是<code>face_recognition</code>库的一些详细解释：</p>
<ol>
<li><p><strong>人脸检测</strong>：<code>face_recognition</code>库使用基于深度学习的方法，能够在图像或视频中快速准确地检测出人脸的位置。</p>
</li>
<li><p><strong>人脸特征提取</strong>：一旦检测到人脸，<code>face_recognition</code>库会提取出人脸图像的特征向量。这些特征向量是通过深度学习模型生成的，具有较高的表征能力。</p>
</li>
<li><p><strong>人脸识别</strong>：提取的人脸特征向量可以用于后续的比较和识别。<code>face_recognition</code>库提供了简单的接口，让用户可以将提取的特征向量与已知的人脸特征进行比较，从而识别人脸。</p>
</li>
<li><p><strong>人脸标志点检测</strong>：除了识别人脸，<code>face_recognition</code>库还能够检测出人脸图像中的关键点，如眼睛、鼻子、嘴巴等位置。这些关键点对于许多人脸相关任务非常有用。</p>
</li>
<li><p><strong>实时人脸识别</strong>：<code>face_recognition</code>库支持在视频流中进行实时的人脸识别。这意味着它可以应用于需要实时响应的场景，如安全监控系统或人脸解锁应用等。</p>
</li>
<li><p><strong>简单易用的接口</strong>：<code>face_recognition</code>库提供了简单易用的Python接口，使得人脸识别变得更加容易。用户不需要深入了解复杂的机器学习算法或计算机视觉技术，只需几行代码就可以完成人脸识别任务。</p>
</li>
</ol>
<p>总的来说，<code>face_recognition</code>库是一个功能强大且易于使用的人脸识别工具，适用于各种应用场景，包括安全监控、人脸解锁、社交媒体应用等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-key_%E4%B8%93%E4%B8%9A%E5%90%8D%E8%AF%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-key_%E4%B8%93%E4%B8%9A%E5%90%8D%E8%AF%8D/" class="post-title-link" itemprop="url">key_专业名词</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>互联网专业名词的笔记</li>
</ul>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>POC展示是指将Proof of Concept（POC）演示给相关利益相关者、观众或用户的过程。在计算机安全领域，当安全研究人员或漏洞猎人发现一个漏洞，并成功开发了POC代码来证明其存在和影响时，他们通常会进行POC展示。</p>
<p>POC展示的目的是以实际的方式展示漏洞的潜在威胁或攻击效果。通过演示POC，安全研究人员可以向利益相关者、安全社区、软件开发商或系统管理员展示漏洞的实际工作原理和可能的影响。这种展示通常是以技术演示、演讲、演示视频或实际的操作演示的形式呈现。</p>
<p>POC展示的目的是增强人们对漏洞的认识，并促使相关方采取适当的措施来修复漏洞或提高系统的安全性。此外，POC展示也有助于推动安全研究和漏洞披露的进程，促进安全社区的知识共享和交流。</p>
<p>需要注意的是，在进行POC展示时，安全研究人员应该遵循道德和法律规定，确保在合适的环境中、合法的授权下进行演示，避免对他人的系统和数据造成未经授权的伤害或损失。</p>
<p>总而言之，POC展示是指将POC演示给相关观众或利益相关者的过程，旨在以实际的方式展示漏洞的工作原理和可能的影响，促使相关方采取适当的安全措施。</p>
<hr>
<h2 id="OEM"><a href="#OEM" class="headerlink" title="OEM"></a>OEM</h2><p>OEM协作是指原始设备制造商（Original Equipment Manufacturer）之间的合作关系和协作活动。在OEM协作中，一个公司（被称为“下游OEM”）与另一个公司（被称为“上游OEM”）合作，通常是为了共同开发、制造或销售某种产品。</p>
<p>下游OEM通常是产品的最终制造商，他们使用上游OEM提供的组件、零部件、技术或知识来生产和组装最终产品。下游OEM可能没有自己的生产能力或专业技术，因此他们与上游OEM合作，以便从上游OEM那里获得所需的资源和支持。</p>
<p>上游OEM则是提供组件、零部件、技术或知识的供应商。他们与下游OEM合作，为其提供所需的产品、技术或专业知识，以支持下游OEM的生产和组装过程。上游OEM通常拥有先进的研发和制造能力，可以为下游OEM提供高质量的组件和解决方案。</p>
<p>OEM协作可以带来多方面的好处，例如：</p>
<ol>
<li><p>专业技术支持：上游OEM可以提供技术咨询、培训和支持，帮助下游OEM提高产品质量和生产效率。</p>
</li>
<li><p>成本效益：通过与上游OEM合作，下游OEM可以获得成本效益，因为他们可以利用上游OEM的规模经济和采购能力来获得更好的价格和供应链优势。</p>
</li>
<li><p>加快产品开发和上市时间：通过与上游OEM合作，下游OEM可以共享上游OEM的研发成果和技术，从而加快产品的开发和上市时间。</p>
</li>
<li><p>扩大市场份额：OEM协作可以帮助下游OEM扩大市场份额，通过与上游OEM的品牌合作或合作销售，吸引更多的客户和业务机会。</p>
</li>
</ol>
<p>OEM协作是供应链管理中常见的合作模式之一，可以帮助各方在产品开发、制造和销售方面互相支持和受益。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-protobuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-protobuf/" class="post-title-link" itemprop="url">protobuf</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>protobuf库 笔记</li>
</ul>
<h2 id="C-protobuf是什么"><a href="#C-protobuf是什么" class="headerlink" title="C++ protobuf是什么"></a>C++ protobuf是什么</h2><p>Protocol Buffers（ProtoBuf）是由Google开发的一种轻量级、高效的数据交换格式，同时也是一种用于序列化结构化数据的协议。ProtoBuf 可以被用于多种应用场景，最常见的是在数据通信和数据存储中。</p>
<p>以下是对 Protocol Buffers 的一些主要特点和用法的解释：</p>
<h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ol>
<li><p><strong>可读性和可扩展性：</strong> ProtoBuf 使用二进制格式，相比于 XML 和 JSON 等文本格式，更加紧凑、高效。尤其在大规模数据传输场景下，ProtoBuf 的性能更为优越。</p>
</li>
<li><p><strong>数据结构定义：</strong> 使用简洁的语法定义结构化的数据模型。定义的数据结构称为消息（Message），通过 Protobuf 编译器生成对应的代码，用于序列化和反序列化数据。</p>
 <figure class="highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>跨语言支持：</strong> ProtoBuf 生成的代码支持多种编程语言，包括 C++, Java, Python, Go, Ruby, C#, JavaScript 等，使得数据在不同平台和语言间的交换变得简便。</p>
</li>
<li><p><strong>版本兼容性：</strong> ProtoBuf 具有向前和向后兼容性，允许在不破坏现有数据的情况下进行协议的演化。</p>
</li>
<li><p><strong>高性能：</strong> 序列化和反序列化速度快，占用的存储空间相对较小，适用于对性能有要求的场景。</p>
</li>
</ol>
<h3 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h3><ol>
<li><p><strong>定义消息：</strong> 使用 Protocol Buffers 的语法定义消息的数据结构。</p>
 <figure class="highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译器生成代码：</strong> 使用 Protobuf 编译器（protoc）将消息定义文件编译为相应语言的代码。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=<span class="variable">$SRC_DIR</span> --cpp_out=<span class="variable">$DST_DIR</span> <span class="variable">$SRC_DIR</span>/person.proto</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用生成的代码：</strong> 在程序中使用生成的代码进行消息的序列化和反序列化。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用生成的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Person 对象</span></span><br><span class="line">Person person;</span><br><span class="line">person.<span class="built_in">set_name</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">person.<span class="built_in">set_id</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化为字节流</span></span><br><span class="line">std::string serialized_data = person.<span class="built_in">SerializeAsString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">Person deserialized_person;</span><br><span class="line">deserialized_person.<span class="built_in">ParseFromString</span>(serialized_data);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>ProtoBuf 提供了简单、高效、可扩展的数据交换格式，广泛用于网络通信、存储、配置文件等场景。其优秀的性能和跨语言支持使得它成为许多大型项目和分布式系统中的首选数据格式。</p>
<h2 id="C-protobuf-详解"><a href="#C-protobuf-详解" class="headerlink" title="C++ protobuf 详解"></a>C++ protobuf 详解</h2><p>Protocol Buffers（ProtoBuf）是一种由Google设计的轻量级、高效的数据交换格式。它不仅用于定义数据结构，还提供了一种机制来序列化和反序列化这些数据。在 C++ 中，ProtoBuf 的使用涉及定义 <code>.proto</code> 文件、使用 Protocol Buffers 编译器（<code>protoc</code>）生成代码，以及在代码中使用生成的代码进行序列化和反序列化。</p>
<p>以下是使用 C++ 的 ProtoBuf 的基本步骤：</p>
<h3 id="步骤-1：定义-proto-文件"><a href="#步骤-1：定义-proto-文件" class="headerlink" title="步骤 1：定义 .proto 文件"></a>步骤 1：定义 <code>.proto</code> 文件</h3><p>首先，定义一个 <code>.proto</code> 文件来描述你的数据结构。例如，下面是一个简单的示例：</p>
<figure class="highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，定义了一个 <code>Person</code> 消息，包含 <code>name</code>、<code>id</code> 和可选的 <code>email</code> 字段。</p>
<h3 id="步骤-2：使用-protoc-编译器生成代码"><a href="#步骤-2：使用-protoc-编译器生成代码" class="headerlink" title="步骤 2：使用 protoc 编译器生成代码"></a>步骤 2：使用 <code>protoc</code> 编译器生成代码</h3><p>使用 <code>protoc</code> 编译器将 <code>.proto</code> 文件编译成相应语言的代码。在 C++ 中，你需要生成 C++ 代码，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=<span class="variable">$SRC_DIR</span> --cpp_out=<span class="variable">$DST_DIR</span> <span class="variable">$SRC_DIR</span>/person.proto</span><br></pre></td></tr></table></figure>

<p>其中，<code>$SRC_DIR</code> 是存放 <code>.proto</code> 文件的目录，<code>$DST_DIR</code> 是生成的 C++ 代码存放的目录。</p>
<h3 id="步骤-3：使用生成的代码"><a href="#步骤-3：使用生成的代码" class="headerlink" title="步骤 3：使用生成的代码"></a>步骤 3：使用生成的代码</h3><p>在你的 C++ 代码中，使用生成的代码进行序列化和反序列化。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Person 对象</span></span><br><span class="line">    Person person;</span><br><span class="line">    person.<span class="built_in">set_name</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">    person.<span class="built_in">set_id</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化为字节流</span></span><br><span class="line">    std::string serialized_data = person.<span class="built_in">SerializeAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    Person deserialized_person;</span><br><span class="line">    deserialized_person.<span class="built_in">ParseFromString</span>(serialized_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用反序列化后的数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; deserialized_person.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; deserialized_person.<span class="built_in">id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Email: &quot;</span> &lt;&lt; deserialized_person.<span class="built_in">email</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用生成的 <code>person.pb.h</code> 头文件中的 <code>Person</code> 类进行数据的操作。<code>SerializeAsString()</code> 方法用于将对象序列化为字符串，而 <code>ParseFromString()</code> 方法用于从字符串中反序列化对象。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><p><strong>字段规则：</strong> ProtoBuf 支持的字段规则包括 <code>required</code>、<code>optional</code> 和 <code>repeated</code>。在 ProtoBuf 3 中，<code>required</code> 已经被废弃，建议使用 <code>optional</code> 或 <code>repeated</code>。</p>
</li>
<li><p><strong>默认值：</strong> ProtoBuf 支持给字段设置默认值。在序列化时，如果字段的值等于默认值，则不会写入到输出流中。</p>
</li>
<li><p><strong>扩展性：</strong> ProtoBuf 具有良好的扩展性，可以通过扩展消息和字段来进行协议的演化，同时保持向前和向后兼容性。</p>
</li>
<li><p><strong>更多特性：</strong> ProtoBuf 还支持枚举、嵌套消息、扩展等高级特性，可以根据具体需求进行使用。</p>
</li>
</ul>
<p>总体而言，ProtoBuf 提供了一种高效、紧凑、可扩展的数据交换格式，适用于各种场景，特别是对性能和数据大小有要求的应用程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-leveldb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-leveldb/" class="post-title-link" itemprop="url">leveldb</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>leveldb 库 笔记</li>
</ul>
<h2 id="C-leveldb是什么"><a href="#C-leveldb是什么" class="headerlink" title="C++ leveldb是什么"></a>C++ leveldb是什么</h2><p>LevelDB（Level DataBase）是一个由Google开发的开源键值对存储库。它是一个基于 C++ 编写的持久化键值对存储引擎，设计用于提供快速的键值查询和范围查询。</p>
<p>以下是 LevelDB 的一些主要特点和特性：</p>
<h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ol>
<li><p><strong>键值对存储：</strong> LevelDB 是一个键值对存储引擎，每个键和值都是任意字节序列。这使得 LevelDB 能够存储和检索各种类型的数据。</p>
</li>
<li><p><strong>快速读写：</strong> LevelDB 提供了高性能的读写操作。它的设计目标是在随机读写和迭代范围查询方面都具有良好的性能。</p>
</li>
<li><p><strong>支持快照：</strong> LevelDB 支持快照（Snapshot），允许在不受并发写入影响的情况下进行读取操作。</p>
</li>
<li><p><strong>支持批量写入：</strong> LevelDB 支持批量写入（Write Batch），可以一次性提交多个写入操作，提高写入效率。</p>
</li>
<li><p><strong>支持前缀查询：</strong> LevelDB 支持按前缀进行范围查询，这对于检索某个特定前缀的所有键值对非常有用。</p>
</li>
<li><p><strong>支持单一写入者多读取者：</strong> LevelDB 支持单一写入者和多读取者，写入者和读取者可以并发操作，提高并发性。</p>
</li>
<li><p><strong>可移植性：</strong> LevelDB 可以在不同的平台上运行，并提供了各种语言的绑定，包括 C++、Java、Python 等。</p>
</li>
</ol>
<h3 id="LevelDB-的使用："><a href="#LevelDB-的使用：" class="headerlink" title="LevelDB 的使用："></a>LevelDB 的使用：</h3><p>LevelDB 提供了简单的 C++ 接口，允许开发者通过 C++ 代码与 LevelDB 进行交互。以下是一个简单的 LevelDB 使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    leveldb::DB* db;</span><br><span class="line">    leveldb::Options options;</span><br><span class="line">    options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;/path/to/db&quot;</span>, &amp;db);</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to open database: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    leveldb::WriteOptions writeOptions;</span><br><span class="line">    status = db-&gt;<span class="built_in">Put</span>(writeOptions, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error writing to database: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> db;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    leveldb::ReadOptions readOptions;</span><br><span class="line">    std::string value;</span><br><span class="line">    status = db-&gt;<span class="built_in">Get</span>(readOptions, <span class="string">&quot;key1&quot;</span>, &amp;value);</span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value for key1: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error reading from database: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> db;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，LevelDB 被用于打开数据库、写入数据、读取数据等操作。注意，这只是一个简单的示例，实际应用中可能需要更多的错误处理和配置选项。</p>
<h2 id="C-leveldb库-详解"><a href="#C-leveldb库-详解" class="headerlink" title="C++ leveldb库 详解"></a>C++ leveldb库 详解</h2><p>LevelDB 是一个由Google开发的开源键值对存储引擎，提供了一个轻量级、高性能的数据存储解决方案。下面是对 LevelDB 库的一些详细解释：</p>
<h3 id="LevelDB-主要特性："><a href="#LevelDB-主要特性：" class="headerlink" title="LevelDB 主要特性："></a>LevelDB 主要特性：</h3><ol>
<li><p><strong>键值对存储：</strong> LevelDB 是一个键值对存储引擎，每个键和值都是任意字节序列。这使得它适用于多种类型的数据。</p>
</li>
<li><p><strong>快速读写：</strong> LevelDB 设计用于提供高性能的读写操作。它在大量的数据读取和写入场景中表现得相当出色。</p>
</li>
<li><p><strong>支持快照：</strong> LevelDB 支持快照，允许在进行读取操作时创建数据的快照，从而避免被并发写入所影响。</p>
</li>
<li><p><strong>支持批量写入：</strong> 提供了批量写入操作，允许一次性提交多个写入操作，从而提高写入效率。</p>
</li>
<li><p><strong>支持前缀查询：</strong> LevelDB 支持按前缀进行范围查询，对于需要检索某个特定前缀的所有键值对的场景非常有用。</p>
</li>
<li><p><strong>单一写入者多读取者：</strong> LevelDB 支持单一写入者和多读取者，使得写入者和读取者能够并发操作，提高了并发性。</p>
</li>
<li><p><strong>数据持久性：</strong> 提供持久性数据存储，确保数据在系统重启后仍然可用。</p>
</li>
</ol>
<h3 id="LevelDB-的基本用法："><a href="#LevelDB-的基本用法：" class="headerlink" title="LevelDB 的基本用法："></a>LevelDB 的基本用法：</h3><p>以下是使用 LevelDB 的基本用法，包括数据库的打开、读写操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开数据库</span></span><br><span class="line">    leveldb::DB* db;</span><br><span class="line">    leveldb::Options options;</span><br><span class="line">    options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">    leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;/path/to/db&quot;</span>, &amp;db);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to open database: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    leveldb::WriteOptions writeOptions;</span><br><span class="line">    status = db-&gt;<span class="built_in">Put</span>(writeOptions, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error writing to database: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> db;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    leveldb::ReadOptions readOptions;</span><br><span class="line">    std::string value;</span><br><span class="line">    status = db-&gt;<span class="built_in">Get</span>(readOptions, <span class="string">&quot;key1&quot;</span>, &amp;value);</span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value for key1: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error reading from database: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭数据库</span></span><br><span class="line">    <span class="keyword">delete</span> db;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，首先打开 LevelDB 数据库，然后进行写入和读取操作，最后关闭数据库。</p>
<h3 id="LevelDB-的其他用法和配置："><a href="#LevelDB-的其他用法和配置：" class="headerlink" title="LevelDB 的其他用法和配置："></a>LevelDB 的其他用法和配置：</h3><ul>
<li><p><strong>迭代器（Iterator）：</strong> LevelDB 提供了迭代器用于遍历数据库中的键值对。</p>
</li>
<li><p><strong>删除数据：</strong> 使用 <code>Delete</code> 方法可以删除数据库中的键值对。</p>
</li>
<li><p><strong>配置选项：</strong> LevelDB 提供了丰富的配置选项，可以用于调整数据库的行为，如设置缓存大小、压缩选项等。</p>
</li>
<li><p><strong>并发控制：</strong> LevelDB 提供了基本的并发控制机制，允许多个读取者和一个写入者并发操作。</p>
</li>
<li><p><strong>性能调优：</strong> 可以通过调整参数和配置选项来优化 LevelDB 的性能，特别是在处理大规模数据时。</p>
</li>
</ul>
<p>总体而言，LevelDB 是一个灵活、高性能的键值对存储引擎，适用于多种应用场景，特别是需要快速读写和持久化存储的场景。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-%E5%B7%A5%E4%BD%9C%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-%E5%B7%A5%E4%BD%9C%E6%B5%81/" class="post-title-link" itemprop="url">工作流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>workflow，工作流</li>
</ul>
<h2 id="工作流是什么"><a href="#工作流是什么" class="headerlink" title="工作流是什么"></a>工作流是什么</h2><p>工作流（Workflow）是对工作流程及其各操作步骤之间业务规则的抽象、概括描述¹。工作流建模，即将工作流程中的工作如何前后组织在一起的逻辑和规则，在计算机中以恰当的模型表达并对其实施计算¹。工作流要解决的主要问题是：为实现某个业务目标，利用计算机在多个参与者之间按某种预定规则自动传递文档、信息或者任务¹。从代码层面上来说，工作流是对业务逻辑代码的按照指定的流程格式化¹。工作流引擎是实现驱动工作流的一套实现工具¹。工作流引擎负责对不同类别的工作流进行具体的定义和实现¹。工作流设计器，我们常说的工作流引擎，一般都包括设计器的能力，即负责对业务流程的拖拽式工具¹。通用型的工作流引擎，比较知名的有jBPM5与Activiti¹。</p>
<p>¹: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113387814">知乎专栏</a></p>
<p>Source: Conversation with Bing, 12&#x2F;19&#x2F;2023<br>(1) 一文读懂工作流 - 知乎 - 知乎专栏. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113387814">https://zhuanlan.zhihu.com/p/113387814</a>.<br>(2) C++输入流和输出流（超级详细） - 知乎 - 知乎专栏. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/270262116">https://zhuanlan.zhihu.com/p/270262116</a>.<br>(3) 什么是工作流？为什么程序员要用它？ - CSDN博客. <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41956016/article/details/107043485">https://blog.csdn.net/qq_41956016/article/details/107043485</a>.</p>
<h2 id="工作流是什么-chatgpt"><a href="#工作流是什么-chatgpt" class="headerlink" title="工作流是什么 (chatgpt)"></a>工作流是什么 (chatgpt)</h2><p>工作流（Workflow）是指一系列有序的任务、活动或流程，旨在完成特定的工作或目标。它涉及到将不同的任务或活动以特定的顺序结合起来，以实现预期的结果。工作流可以是手动的、自动化的，或者是二者的组合。</p>
<p>工作流可以在各种领域和行业中应用，如企业管理、生产制造、软件开发、客户服务、医疗保健等。它有助于提高效率、降低错误率、标准化流程、优化资源利用，从而提升组织的整体绩效。</p>
<p>通常，一个工作流包括以下几个要素：</p>
<ol>
<li><p><strong>任务或活动：</strong> 每个工作流都由一系列任务、活动或步骤组成，这些步骤按照特定顺序进行。</p>
</li>
<li><p><strong>流程逻辑：</strong> 描述了任务之间的依赖关系、执行顺序、条件和规则，确保工作流能够按照预期的方式运行。</p>
</li>
<li><p><strong>资源分配：</strong> 工作流通常涉及分配资源（人力、物力、时间）来执行各项任务。</p>
</li>
<li><p><strong>控制和监控：</strong> 对工作流进行监控、管理和控制，以确保它们按照设计的方式执行，并能够在需要时进行调整和优化。</p>
</li>
<li><p><strong>自动化：</strong> 某些工作流可能利用技术和自动化工具来加速执行过程，减少人为干预，提高效率和准确性。</p>
</li>
</ol>
<p>工作流可以通过各种方法进行建模和管理，包括流程图、流程建模工具、专门的工作流管理系统（Workflow Management System，WMS）等。</p>
<p>总的来说，工作流是组织和管理任务的一种方法，它有助于确保任务按照一定顺序和规则进行，以达到预期的业务目标。</p>
<h2 id="C-工作流是什么"><a href="#C-工作流是什么" class="headerlink" title="C++ 工作流是什么"></a>C++ 工作流是什么</h2><p>在C++中，工作流（Workflow）通常指的是一系列任务、步骤或操作的有序流程，旨在完成特定的工作或目标。C++本身是一种通用的编程语言，提供了丰富的功能和库，可以用于创建各种类型的应用程序，包括涉及工作流程的应用程序。</p>
<p>在C++中，工作流可以用于不同的应用场景，例如：</p>
<ol>
<li><p><strong>应用程序开发：</strong> 在软件开发中，工作流可以指代程序执行的特定步骤或模块，例如初始化、数据处理、用户交互、结果呈现等，它们按照特定的顺序组合成完整的应用程序。</p>
</li>
<li><p><strong>并行计算：</strong> 在并行编程领域，工作流可以指代并行任务的流程，将任务分解为多个步骤，并以特定的顺序执行，以实现并行计算或处理。</p>
</li>
<li><p><strong>数据处理和流程控制：</strong> C++可以用于创建处理数据的工作流，例如将数据流经过一系列处理步骤，执行特定的操作或转换，并最终产生期望的输出。</p>
</li>
</ol>
<p>要在C++中实现工作流，通常需要结合C++语言的特性，编写代码来定义和管理任务或操作的执行顺序，以及控制流程的逻辑。有时候，可以利用C++的类、函数和库来创建自定义的工作流管理系统，或者利用现有的工作流框架和库，例如Boost C++库中的一些组件，来简化工作流的实现和管理。</p>
<p>实际的C++工作流实现可能涉及任务调度、状态管理、数据传递、并发处理等方面的编程技巧和设计模式，以确保工作流能够按照预期的方式运行，并达到特定的业务或功能目标。</p>
<h2 id="工作流-详解"><a href="#工作流-详解" class="headerlink" title="工作流 详解"></a>工作流 详解</h2><p>工作流（Workflow）是指一系列有序的任务、活动或步骤，按照特定的规则和流程顺序进行，以完成特定的工作或达到某个目标。这个概念在不同领域和行业中被广泛应用，包括企业管理、软件开发、生产制造、服务行业等等。下面详细解释工作流的重要方面：</p>
<ol>
<li><p><strong>任务和步骤：</strong> 工作流由一系列任务或步骤组成，这些任务按照预定的顺序和规则执行。每个任务可能需要特定的输入并产生相应的输出，作为下一个任务的输入。</p>
</li>
<li><p><strong>流程设计和逻辑：</strong> 工作流的设计包括定义任务之间的顺序、条件和依赖关系。这些规则和逻辑决定了工作流程的执行顺序，确保任务按照预期的方式完成。</p>
</li>
<li><p><strong>资源分配和管理：</strong> 工作流需要合理分配和管理资源，包括人力、时间、物料和技术等。这确保了任务得以及时完成，并且资源得到最有效地利用。</p>
</li>
<li><p><strong>控制和监控：</strong> 对工作流进行监控、控制和管理是至关重要的。这意味着能够跟踪任务的执行进度，识别潜在的问题并进行调整，确保工作流能够按照预期达到目标。</p>
</li>
<li><p><strong>自动化和优化：</strong> 在一些情况下，工作流可以通过自动化工具、软件或系统来执行任务，提高效率并减少人为错误。不断优化工作流也是提高效率的关键，可以通过改进流程、去除瓶颈、提高自动化程度等方式实现。</p>
</li>
<li><p><strong>流程建模和管理工具：</strong> 为了更好地设计、分析和实施工作流，人们使用流程建模工具和专门的工作流管理系统（Workflow Management System）。这些工具有助于可视化工作流程、管理任务和资源、执行控制和监控等功能。</p>
</li>
</ol>
<p>总的来说，工作流是一种组织和管理任务的方法，旨在提高效率、降低错误率、优化资源利用并确保任务按照预期的方式完成。它是一个动态的概念，可以根据不同的需求和情境进行调整和优化，以满足特定的业务需求或目标。</p>
<h2 id="工作流建模是什么"><a href="#工作流建模是什么" class="headerlink" title="工作流建模是什么"></a>工作流建模是什么</h2><p>工作流建模指的是通过图形化或符号化的方式描述和表达工作流程。这种建模方法旨在清晰地展示任务、活动或步骤之间的关系、依赖性、顺序和流程逻辑，以便更好地理解、分析和管理工作流程。</p>
<p>在工作流建模中，常用的方法包括：</p>
<ol>
<li><p><strong>流程图：</strong> 流程图是最常见和常用的工作流建模方法之一。它使用各种符号（如圆形代表起始或结束点，矩形代表任务或活动，箭头表示流程的方向等）来描述任务或活动之间的顺序、逻辑和依赖关系。流程图可以使用不同的标准，如BPMN（Business Process Model and Notation）、UML（Unified Modeling Language）等。</p>
</li>
<li><p><strong>流程建模工具：</strong> 有许多专门的流程建模工具和软件可供使用，例如Microsoft Visio、Lucidchart、Bizagi Modeler等。这些工具提供了简单易用的界面和符号库，帮助用户创建、编辑和管理复杂的工作流模型。</p>
</li>
<li><p><strong>值流映射：</strong> 值流映射是一种工作流建模方法，侧重于识别和优化价值流程，以最大化价值并减少浪费。它通常用于精益生产和精益管理方法中。</p>
</li>
<li><p><strong>数据流程图：</strong> 数据流程图描述了数据如何在系统中流动和处理。它强调数据的来源、目的地和处理方式，有助于了解数据在整个流程中的传递和转换。</p>
</li>
</ol>
<p>工作流建模的目的是帮助团队和利益相关者更清晰地理解工作流程，发现潜在的瓶颈、问题或改进空间，并为优化工作流程提供参考依据。这种建模方法可以促进团队协作、沟通和对工作流程的改进，从而提高效率、降低成本，并确保任务按照规定的方式完成。</p>
<h2 id="工作流建模中的数据流程图-详解"><a href="#工作流建模中的数据流程图-详解" class="headerlink" title="工作流建模中的数据流程图 详解"></a>工作流建模中的数据流程图 详解</h2><p>数据流程图（Data Flow Diagram，DFD）是一种用于描述信息系统中数据流动和处理的图形化建模工具。它显示了系统内部数据的流向、处理过程和存储位置，以及数据与外部实体之间的交互关系。DFD 通常由一系列图表组成，用于表示不同层次和角度的数据流程。</p>
<p>DFD 包括以下主要元素：</p>
<ol>
<li><p><strong>实体（Entity）：</strong> 实体代表外部与系统交互的对象，可以是人、组织、其他系统或外部数据源。在 DFD 中，实体通常用方框表示，位于图的边缘，表示系统的边界。</p>
</li>
<li><p><strong>过程（Process）：</strong> 过程表示数据流动的处理过程或转换。它们是对数据执行的操作，可以是计算、转换、存储或其他操作。在 DFD 中，过程通常用圆角矩形表示。</p>
</li>
<li><p><strong>数据流（Data Flow）：</strong> 数据流代表数据在系统内部或系统与外部实体之间流动的路径。数据流表示数据从一个地方移动到另一个地方，通常用箭头表示。</p>
</li>
<li><p><strong>数据存储（Data Store）：</strong> 数据存储表示数据在系统中的持久存储位置，可以是数据库、文件或其他数据存储设备。在 DFD 中，数据存储通常用双条线矩形表示。</p>
</li>
</ol>
<p>DFD 通常分为多个层次，从整体上描述系统的概念，然后逐渐展开细节。DFD 的层次可以通过多个图表来表示，从顶层图开始，再逐步展开到更详细的层次，以便更好地理解系统的数据流动和处理逻辑。</p>
<p>DFD 的优点包括：</p>
<ul>
<li><strong>易于理解：</strong> DFD 使用图形化的表示方式，使得系统中数据的流动和处理逻辑更直观和易于理解。</li>
<li><strong>抽象表达：</strong> 它提供了对系统的高层次抽象表示，可以忽略细节，更关注系统的整体结构和功能。</li>
<li><strong>沟通与设计：</strong> DFD 有助于不同团队成员之间的沟通和协作，并且为系统设计和优化提供了基础。</li>
</ul>
<p>总的来说，数据流程图是一种有用的工具，用于描述信息系统中数据流动和处理的方式，有助于分析、设计和沟通系统的数据处理流程。</p>
<h2 id="工作流引擎是什么"><a href="#工作流引擎是什么" class="headerlink" title="工作流引擎是什么"></a>工作流引擎是什么</h2><p>工作流引擎（Workflow Engine）是一种软件工具或系统，用于管理、执行和自动化工作流程中的任务、活动和流程。它是一个核心组件，负责解释、控制和监视工作流程中的各个步骤，以确保任务按照预期的方式顺利执行。</p>
<p>工作流引擎通常具有以下功能和特点：</p>
<ol>
<li><p><strong>流程执行和控制：</strong> 它负责执行工作流程中的各个步骤，根据定义的流程规则和逻辑来控制任务的顺序和执行流程。</p>
</li>
<li><p><strong>任务调度和分配：</strong> 工作流引擎能够分配任务给适当的执行者，根据特定条件或规则自动调度任务。</p>
</li>
<li><p><strong>状态管理：</strong> 它跟踪任务或流程的状态，允许监控和管理流程的进展，并在需要时进行状态更新。</p>
</li>
<li><p><strong>规则引擎：</strong> 有些工作流引擎内置规则引擎，能够根据预定义的规则自动决定任务的流转和执行。</p>
</li>
<li><p><strong>通知和提醒：</strong> 引擎能够发送通知、提醒或警报，以便参与者知晓并及时处理任务。</p>
</li>
<li><p><strong>错误处理和异常流程：</strong> 处理工作流程中可能出现的异常情况，可以自动或手动进行错误处理。</p>
</li>
<li><p><strong>集成和扩展性：</strong> 可以集成到不同的应用程序或系统中，并具有扩展性，以满足不同的业务需求和场景。</p>
</li>
</ol>
<p>工作流引擎可以以多种方式实现，例如基于规则、状态机、图形化工作流编辑器等。它们通常支持标准的工作流建模语言，如BPMN（Business Process Model and Notation），这使得用户能够使用可视化工具轻松地定义和管理工作流程。</p>
<p>这些引擎被广泛应用于企业资源规划（ERP）、客户关系管理（CRM）、项目管理、服务台管理、工作流自动化等领域。通过使用工作流引擎，组织能够提高效率、降低成本、减少错误并加强对业务流程的控制和监督。</p>
<h2 id="工作流设计器是什么"><a href="#工作流设计器是什么" class="headerlink" title="工作流设计器是什么"></a>工作流设计器是什么</h2><p>工作流设计器（Workflow Designer）是一种软件工具，用于创建、设计和编辑工作流程图。它提供了一个图形化的界面，让用户能够直观地建模和定义工作流程，包括任务、活动、流程步骤、条件和规则等。</p>
<p>主要功能包括：</p>
<ol>
<li><p><strong>图形化建模：</strong> 工作流设计器通常提供了丰富的图形化工具和符号，让用户能够以直观的方式创建工作流程图。这些工具包括表示任务、活动、决策、状态、数据流等元素的图形符号。</p>
</li>
<li><p><strong>流程编辑和连接：</strong> 用户可以通过拖放图形符号来创建流程步骤，并通过连接线条来定义这些步骤之间的顺序和逻辑关系。这使得用户能够轻松地构建工作流程的结构。</p>
</li>
<li><p><strong>属性设置：</strong> 工作流设计器允许用户设置每个流程步骤或活动的属性，例如名称、描述、执行条件、执行者等信息。</p>
</li>
<li><p><strong>条件和规则定义：</strong> 用户可以定义触发任务执行的条件或规则。这些条件可以是时间触发、数据状态变化、外部事件等。</p>
</li>
<li><p><strong>实时预览和验证：</strong> 设计器通常提供实时预览功能，让用户在设计过程中可以预览工作流程的执行流程。同时也能够进行验证，确保工作流程的合法性和正确性。</p>
</li>
<li><p><strong>导出和集成：</strong> 完成工作流设计后，设计器通常支持将设计的工作流程导出为可执行的文件或配置，并且可以与其他应用程序或系统集成。</p>
</li>
</ol>
<p>工作流设计器广泛应用于企业资源规划（ERP）、客户关系管理（CRM）、项目管理、工作流自动化等领域。它们有助于团队和业务人员更轻松地创建、管理和优化工作流程，同时提高了可视化建模的效率和准确性。</p>
<h2 id="常用的工作流引擎"><a href="#常用的工作流引擎" class="headerlink" title="常用的工作流引擎"></a>常用的工作流引擎</h2><p>在软件开发和业务流程管理中，有许多常用的工作流引擎可供选择，每个引擎都有其独特的特点和适用场景。以下是一些常见的工作流引擎：</p>
<ol>
<li><p><strong>Apache Airflow：</strong> 一个开源的工作流编排工具，用于调度、监控和管理复杂的工作流程。它支持基于代码的工作流定义，并提供了丰富的插件生态系统和可视化界面。</p>
</li>
<li><p><strong>Activiti：</strong> 一个轻量级的开源BPM（Business Process Management）引擎，基于Java语言，用于设计、执行和管理业务流程。Activiti支持BPMN标准，提供了可扩展性和灵活性。</p>
</li>
<li><p><strong>Camunda：</strong> 一个基于Activiti的开源工作流和决策引擎，支持BPMN标准，可用于设计和执行复杂的业务流程。Camunda提供了高度可扩展性和灵活性，并提供了REST API以进行集成。</p>
</li>
<li><p><strong>JBoss jBPM：</strong> 一个开源的、基于Java的业务流程管理工具，支持BPMN2.0标准，用于设计、执行和监控业务流程。</p>
</li>
<li><p><strong>IBM Business Automation Workflow（BAW）：</strong> IBM提供的企业级工作流引擎，可用于建模和自动化复杂的业务流程，提供了业务决策管理和高级的分析功能。</p>
</li>
<li><p><strong>Microsoft Power Automate（以前称为Microsoft Flow）：</strong> Microsoft提供的工作流和自动化平台，可用于连接各种应用程序和服务，并创建自动化的工作流程，不需要编写代码。</p>
</li>
<li><p><strong>Nintex Workflow Platform：</strong> 一个可视化的工作流程和自动化平台，用于构建和管理业务流程，集成了许多常用的业务应用程序和系统。</p>
</li>
<li><p><strong>Zeebe：</strong> 一个分布式的工作流引擎，专注于高性能和水平扩展，可用于构建具有高吞吐量和可靠性要求的业务流程。</p>
</li>
</ol>
<p>每个工作流引擎都有其独特的特性和适用场景，选择合适的工作流引擎通常取决于项目需求、可扩展性、集成性能以及对标准支持的要求。</p>
<h2 id="C-如何实现工作流引擎"><a href="#C-如何实现工作流引擎" class="headerlink" title="C++如何实现工作流引擎"></a>C++如何实现工作流引擎</h2><p>在C++中实现工作流引擎需要一些基本的组件和设计模式，尤其是涉及到任务调度、状态管理和流程控制。下面是一些主要的步骤和概念，可以帮助你理解如何在C++中构建一个简单的工作流引擎：</p>
<ol>
<li><p><strong>任务定义：</strong> 定义任务或活动的抽象类或接口，表示工作流中的可执行单元。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Other necessary methods or properties</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>任务实现：</strong> 实现具体的任务类，继承自任务定义，并实现具体的任务逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteTaskA</span> : <span class="keyword">public</span> Task &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implement logic for task A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteTaskB</span> : <span class="keyword">public</span> Task &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implement logic for task B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>流程管理：</strong> 创建流程管理器，负责任务的调度和管理。这可能涉及队列、状态跟踪等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkflowEngine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;Task*&gt; tasksQueue;</span><br><span class="line">    <span class="comment">// Other necessary data structures</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task* task)</span> </span>&#123;</span><br><span class="line">        tasksQueue.<span class="built_in">push</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!tasksQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Task* currentTask = tasksQueue.<span class="built_in">front</span>();</span><br><span class="line">            currentTask-&gt;<span class="built_in">execute</span>();</span><br><span class="line">            tasksQueue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// Add logic for managing task flow, transitions, etc.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建和执行工作流程：</strong> 利用上述构建的任务和流程管理器，创建并执行工作流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WorkflowEngine workflowEngine;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define tasks</span></span><br><span class="line">    Task* taskA = <span class="keyword">new</span> <span class="built_in">ConcreteTaskA</span>();</span><br><span class="line">    Task* taskB = <span class="keyword">new</span> <span class="built_in">ConcreteTaskB</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add tasks to workflow</span></span><br><span class="line">    workflowEngine.<span class="built_in">addTask</span>(taskA);</span><br><span class="line">    workflowEngine.<span class="built_in">addTask</span>(taskB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the workflow</span></span><br><span class="line">    workflowEngine.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up tasks</span></span><br><span class="line">    <span class="keyword">delete</span> taskA;</span><br><span class="line">    <span class="keyword">delete</span> taskB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这是一个简单的示例，用于说明在C++中构建工作流引擎的基本思路。在实际的项目中，工作流引擎通常需要更复杂的功能，如条件分支、错误处理、状态管理、并发处理等。因此，在构建更完整和可扩展的工作流引擎时，可能需要更多的设计和实现工作。同时，考虑到复杂性和维护性，也可以考虑使用现有的开源工作流引擎或库，以便快速构建并具备更丰富功能的工作流系统。</p>
<h2 id="C-工作流引擎中常用的组件和设计模式"><a href="#C-工作流引擎中常用的组件和设计模式" class="headerlink" title="C++ 工作流引擎中常用的组件和设计模式"></a>C++ 工作流引擎中常用的组件和设计模式</h2><p>在C++中构建工作流引擎时，常用的组件和设计模式可以帮助实现更具可维护性和扩展性的系统。以下是一些常用的组件和设计模式：</p>
<h3 id="组件："><a href="#组件：" class="headerlink" title="组件："></a>组件：</h3><ol>
<li><p><strong>任务（Task）：</strong> 表示工作流中可执行的单元。每个任务应该是一个抽象类或接口，具体的任务类继承自这个接口。</p>
</li>
<li><p><strong>流程管理器（Workflow Manager）：</strong> 负责任务的调度、管理和执行。它可能包括任务队列、状态管理、任务执行逻辑等。</p>
</li>
<li><p><strong>任务执行上下文（Task Execution Context）：</strong> 用于在任务之间传递数据和状态。这可以是一个数据结构或对象，用于保存任务执行期间的上下文信息。</p>
</li>
<li><p><strong>触发器（Trigger）：</strong> 触发工作流中任务执行的条件或事件。这些可以是时间触发、数据状态变化触发等。</p>
</li>
</ol>
<h3 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a>设计模式：</h3><ol>
<li><p><strong>工厂模式（Factory Pattern）：</strong> 用于创建任务实例，根据需要实例化具体的任务对象。可以是简单工厂模式、工厂方法模式或抽象工厂模式。</p>
</li>
<li><p><strong>命令模式（Command Pattern）：</strong> 将任务封装成对象，以支持任务的参数化和延迟执行。这有助于将任务作为对象进行管理和执行。</p>
</li>
<li><p><strong>观察者模式（Observer Pattern）：</strong> 用于在任务执行时监视任务状态的变化。例如，通知其他组件或系统特定任务的执行状态。</p>
</li>
<li><p><strong>策略模式（Strategy Pattern）：</strong> 用于在工作流引擎中定义任务的执行策略。不同的任务可以有不同的执行策略。</p>
</li>
<li><p><strong>状态模式（State Pattern）：</strong> 用于管理任务的状态转换。任务可能有多种状态，状态模式可以帮助组织和管理状态转换的逻辑。</p>
</li>
<li><p><strong>责任链模式（Chain of Responsibility Pattern）：</strong> 用于构建任务执行的责任链。任务按照一定的顺序传递并执行，直到有任务能够处理该请求。</p>
</li>
<li><p><strong>享元模式（Flyweight Pattern）：</strong> 用于共享可能被多个任务所使用的共享对象或资源，以减少内存占用和提高性能。</p>
</li>
</ol>
<p>这些组件和设计模式可以在C++工作流引擎中使用，以创建更灵活、可扩展和易于维护的系统。具体的实现方式可能会根据项目需求和规模的不同而有所差异，但这些是常用的方法，有助于构建功能强大的工作流引擎。</p>
<h2 id="C-工作流怎么设计"><a href="#C-工作流怎么设计" class="headerlink" title="C++ 工作流怎么设计"></a>C++ 工作流怎么设计</h2><p>设计一个工作流引擎涉及多个方面，包括任务定义、流程管理、状态管理、任务调度等。以下是一个简单的示例，展示如何在C++中设计一个基本的工作流引擎：</p>
<h3 id="任务定义："><a href="#任务定义：" class="headerlink" title="任务定义："></a>任务定义：</h3><ol>
<li><p><strong>任务基类：</strong> 定义一个任务的抽象基类或接口，用于表示工作流中的可执行单元。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Other necessary methods or properties</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>具体任务类：</strong> 实现具体的任务，继承自任务基类，定义任务的具体逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteTaskA</span> : <span class="keyword">public</span> Task &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implement logic for task A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteTaskB</span> : <span class="keyword">public</span> Task &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implement logic for task B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="流程管理器："><a href="#流程管理器：" class="headerlink" title="流程管理器："></a>流程管理器：</h3><ol>
<li><p><strong>工作流引擎类：</strong> 创建一个流程管理器，负责任务的调度、管理和执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkflowEngine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Task*&gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task* task)</span> </span>&#123;</span><br><span class="line">        tasks.<span class="built_in">push_back</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Task* task : tasks) &#123;</span><br><span class="line">            task-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="创建和执行工作流程："><a href="#创建和执行工作流程：" class="headerlink" title="创建和执行工作流程："></a>创建和执行工作流程：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WorkflowEngine workflowEngine;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 定义具体的任务</span></span><br><span class="line">    Task* taskA = <span class="keyword">new</span> <span class="built_in">ConcreteTaskA</span>();</span><br><span class="line">    Task* taskB = <span class="keyword">new</span> <span class="built_in">ConcreteTaskB</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 添加任务到工作流引擎</span></span><br><span class="line">    workflowEngine.<span class="built_in">addTask</span>(taskA);</span><br><span class="line">    workflowEngine.<span class="built_in">addTask</span>(taskB);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 执行工作流程</span></span><br><span class="line">    workflowEngine.<span class="built_in">run</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="keyword">delete</span> taskA;</span><br><span class="line">    <span class="keyword">delete</span> taskB;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>这个示例是一个基本的工作流引擎，用于说明设计的基本思路。在实际应用中，需要考虑更多的复杂性和扩展性，例如任务状态管理、任务执行的条件控制、任务之间的依赖关系、错误处理等等。</li>
<li>为了更好地管理资源和防止内存泄漏，需要确保在不再需要时正确地清理任务对象。</li>
<li>需要考虑异常处理、并发任务的执行、任务执行顺序的控制等更复杂的情况。</li>
<li>这只是一个简单示例，实际的工作流引擎可能需要更多的设计和实现来满足特定的需求和复杂性。</li>
</ul>
<h2 id="C-工作流中的任务定义怎么设计-详解"><a href="#C-工作流中的任务定义怎么设计-详解" class="headerlink" title="C++ 工作流中的任务定义怎么设计 详解"></a>C++ 工作流中的任务定义怎么设计 详解</h2><p>在C++工作流中，任务定义的设计是工作流引擎的关键部分之一。任务定义指定了工作流中需要执行的具体操作或活动。下面详细解释如何设计C++中的任务定义：</p>
<h3 id="任务基类设计："><a href="#任务基类设计：" class="headerlink" title="任务基类设计："></a>任务基类设计：</h3><ol>
<li><p><strong>抽象任务基类（Abstract Task Base Class）：</strong> 定义一个抽象基类或接口，描述任务的基本特征和行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数，用于执行任务的具体逻辑</span></span><br><span class="line">    <span class="comment">// 可以包含其他虚函数或纯虚函数，用于获取任务信息或处理其他任务相关操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="具体任务类设计："><a href="#具体任务类设计：" class="headerlink" title="具体任务类设计："></a>具体任务类设计：</h3><ol start="2">
<li><p><strong>具体任务类（Concrete Task Classes）：</strong> 派生自任务基类的具体任务类，实现具体任务的逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteTaskA</span> : <span class="keyword">public</span> Task &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现具体任务A的逻辑</span></span><br><span class="line">        <span class="comment">// 可能包括操作、计算、调用其他函数等</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以包含其他私有或公有成员函数和数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteTaskB</span> : <span class="keyword">public</span> Task &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现具体任务B的逻辑</span></span><br><span class="line">        <span class="comment">// 可能包括操作、计算、调用其他函数等</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以包含其他私有或公有成员函数和数据成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="任务定义的要点："><a href="#任务定义的要点：" class="headerlink" title="任务定义的要点："></a>任务定义的要点：</h3><ul>
<li><p><strong>抽象基类的定义：</strong> 任务基类应该定义一组任务需要遵循的共同操作或接口。这些操作可能包括执行任务、获取任务信息、更新任务状态等。</p>
</li>
<li><p><strong>虚函数 execute()：</strong> 在任务基类中定义一个纯虚的 <code>execute()</code> 函数，它是任务的核心执行逻辑，由具体的任务类来实现。这种设计允许不同的任务类有不同的实现方式。</p>
</li>
<li><p><strong>多态性支持：</strong> 通过将具体任务类派生自抽象基类，利用多态性来处理不同类型的任务。这样可以在不修改基础架构的情况下，轻松地添加新的任务类型。</p>
</li>
<li><p><strong>扩展性和灵活性：</strong> 设计任务类的目的是使得系统能够轻松地添加新任务或修改现有任务的行为，以适应不同的业务需求。</p>
</li>
</ul>
<p>通过良好设计的任务定义，工作流引擎可以实现对任务的统一管理和执行，同时使得系统更加灵活和可扩展。</p>
<h2 id="C-工作流中的流程管理怎么设计-详解"><a href="#C-工作流中的流程管理怎么设计-详解" class="headerlink" title="C++ 工作流中的流程管理怎么设计 详解"></a>C++ 工作流中的流程管理怎么设计 详解</h2><p>在C++工作流中，流程管理是工作流引擎的关键部分之一，负责管理和执行定义好的任务序列、控制任务的执行顺序以及处理任务之间的依赖关系。下面详细解释如何设计C++中的流程管理：</p>
<h3 id="流程管理器设计："><a href="#流程管理器设计：" class="headerlink" title="流程管理器设计："></a>流程管理器设计：</h3><ol>
<li><p><strong>工作流引擎类（Workflow Engine Class）：</strong> 定义一个管理工作流程的类，负责添加、管理和执行任务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkflowEngine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Task*&gt; tasks; <span class="comment">// 任务容器，用于存储待执行的任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task* task)</span> </span>&#123;</span><br><span class="line">        tasks.<span class="built_in">push_back</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeWorkflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Task* task : tasks) &#123;</span><br><span class="line">            task-&gt;<span class="built_in">execute</span>(); <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="流程管理器要点："><a href="#流程管理器要点：" class="headerlink" title="流程管理器要点："></a>流程管理器要点：</h3><ul>
<li><p><strong>任务容器：</strong> 使用容器（如 <code>std::vector</code>）存储任务，以保持待执行任务的顺序。你也可以选择其他容器类型，如队列或链表，根据执行顺序的不同选择合适的数据结构。</p>
</li>
<li><p><strong>添加任务方法：</strong> 提供 <code>addTask()</code> 方法，用于向流程管理器中添加新的任务。这个方法可以动态地向工作流中添加不同类型的任务。</p>
</li>
<li><p><strong>执行工作流程方法：</strong> <code>executeWorkflow()</code> 方法用于遍历任务列表，并依次执行每个任务的 <code>execute()</code> 函数。这里假设任务已经按照执行顺序添加到了任务容器中。</p>
</li>
<li><p><strong>其他方法和属性：</strong> 根据实际需求，可以添加其他方法或属性来支持任务状态管理、错误处理、任务执行的条件控制等功能。</p>
</li>
</ul>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>这个示例是一个简单的流程管理器的概念示例，用于说明设计的基本思路。实际应用中，可能需要更多的逻辑和条件来管理复杂的工作流程。</li>
<li>考虑到任务之间的依赖关系，你可能需要在流程管理器中添加逻辑来确保任务按照正确的顺序执行，或者根据某些条件跳过特定的任务。</li>
<li>为了更好地模拟真实系统，可能需要添加更多的属性和方法来描述任务的属性和行为。</li>
<li>确保在不再需要时正确地清理任务对象，以避免内存泄漏。</li>
</ul>
<h2 id="C-工作流中的状态管理怎么设计-详解"><a href="#C-工作流中的状态管理怎么设计-详解" class="headerlink" title="C++ 工作流中的状态管理怎么设计 详解"></a>C++ 工作流中的状态管理怎么设计 详解</h2><p>在C++工作流中，状态管理是对任务执行状态的追踪和处理，以确保任务在执行过程中的正确性和可控性。以下是关于如何设计C++中的状态管理：</p>
<h3 id="状态管理器设计："><a href="#状态管理器设计：" class="headerlink" title="状态管理器设计："></a>状态管理器设计：</h3><ol>
<li><p><strong>任务状态枚举（Task Status Enum）：</strong> 定义任务的不同状态，例如：未开始、进行中、已完成、出错等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">TaskStatus</span> &#123;</span><br><span class="line">    NOT_STARTED,</span><br><span class="line">    IN_PROGRESS,</span><br><span class="line">    COMPLETED,</span><br><span class="line">    ERROR,</span><br><span class="line">    <span class="comment">// 其他可能的状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>任务状态属性：</strong> 在任务类中添加状态属性，用于追踪任务的执行状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaskStatus status; <span class="comment">// 任务的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>() : <span class="built_in">status</span>(TaskStatus::NOT_STARTED) &#123;&#125; <span class="comment">// 默认状态为未开始</span></span><br><span class="line"></span><br><span class="line">    <span class="function">TaskStatus <span class="title">getStatus</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStatus</span><span class="params">(TaskStatus newStatus)</span> </span>&#123;</span><br><span class="line">        status = newStatus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>状态更新逻辑：</strong> 在任务的执行过程中，在适当的时机更新任务的状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteTask</span> : <span class="keyword">public</span> Task &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在任务执行过程中更新状态</span></span><br><span class="line">        <span class="built_in">setStatus</span>(TaskStatus::IN_PROGRESS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现具体任务的逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务完成后更新状态为已完成</span></span><br><span class="line">        <span class="built_in">setStatus</span>(TaskStatus::COMPLETED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="状态管理器要点："><a href="#状态管理器要点：" class="headerlink" title="状态管理器要点："></a>状态管理器要点：</h3><ul>
<li><p><strong>状态枚举定义：</strong> 定义一个清晰的状态枚举，包含任务可能的所有状态。这有助于对任务状态的准确追踪和管理。</p>
</li>
<li><p><strong>任务类状态属性：</strong> 在任务基类或具体任务类中添加状态属性，用于存储任务的当前状态。</p>
</li>
<li><p><strong>状态更新逻辑：</strong> 在任务的执行过程中，根据任务的执行阶段更新状态。状态更新应该在适当的时机调用，以反映任务的实际状态。</p>
</li>
<li><p><strong>其他状态相关的功能：</strong> 可以根据需要添加其他状态管理的功能，例如状态查询方法、状态转换条件的验证、错误处理逻辑等。</p>
</li>
</ul>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>任务状态管理的设计应该是简洁且清晰的，以便准确追踪任务的状态。</li>
<li>考虑在状态管理器中添加错误处理机制，以处理任务执行过程中可能出现的错误状态。</li>
<li>状态管理的设计应该适应实际业务需求，根据任务的复杂性和执行过程的特点来进行设计和扩展。</li>
</ul>
<h2 id="C-工作流中的任务调度怎么设计-详解"><a href="#C-工作流中的任务调度怎么设计-详解" class="headerlink" title="C++ 工作流中的任务调度怎么设计 详解"></a>C++ 工作流中的任务调度怎么设计 详解</h2><p>任务调度在工作流中是管理任务执行顺序和控制任务执行的过程。下面是关于如何设计C++中的任务调度的解释：</p>
<h3 id="任务调度器设计："><a href="#任务调度器设计：" class="headerlink" title="任务调度器设计："></a>任务调度器设计：</h3><ol>
<li><p><strong>任务优先级枚举（Task Priority Enum）：</strong> 定义任务的不同优先级，用于确定任务执行的顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">TaskPriority</span> &#123;</span><br><span class="line">    LOW,</span><br><span class="line">    NORMAL,</span><br><span class="line">    HIGH,</span><br><span class="line">    <span class="comment">// 其他可能的优先级</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>任务带优先级属性：</strong> 在任务类中添加优先级属性，用于指定任务的优先级。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaskPriority priority; <span class="comment">// 任务的优先级</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>(TaskPriority prio) : <span class="built_in">priority</span>(prio) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TaskPriority <span class="title">getPriority</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>任务调度逻辑：</strong> 在工作流引擎中实现任务的调度逻辑，根据任务的优先级进行排序和执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkflowEngine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Task*&gt; tasks; <span class="comment">// 任务容器，用于存储待执行的任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task* task)</span> </span>&#123;</span><br><span class="line">        tasks.<span class="built_in">push_back</span>(task);</span><br><span class="line">        <span class="comment">// 在添加任务时，可能需要对任务进行排序以确保按优先级执行</span></span><br><span class="line">        <span class="built_in">sortTasksByPriority</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortTasksByPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据任务的优先级进行排序，例如使用 std::sort() 等排序算法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeWorkflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Task* task : tasks) &#123;</span><br><span class="line">            task-&gt;<span class="built_in">execute</span>(); <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="任务调度器要点："><a href="#任务调度器要点：" class="headerlink" title="任务调度器要点："></a>任务调度器要点：</h3><ul>
<li><p><strong>优先级枚举定义：</strong> 定义一个清晰的优先级枚举，包含任务可能的所有优先级。这有助于对任务按照优先级进行排序。</p>
</li>
<li><p><strong>任务类优先级属性：</strong> 在任务类中添加优先级属性，以便在任务调度时确定任务的执行顺序。</p>
</li>
<li><p><strong>任务调度逻辑：</strong> 在工作流引擎中实现任务的调度逻辑，可以在任务添加时进行排序，也可以在执行时动态根据优先级选择下一个要执行的任务。</p>
</li>
<li><p><strong>排序方法的实现：</strong> 实现一个合适的排序方法，根据任务的优先级对任务容器中的任务进行排序。</p>
</li>
</ul>
<h3 id="注意事项：-3"><a href="#注意事项：-3" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>任务调度器的设计应该适应实际业务需求，根据任务的复杂性和优先级要求来进行设计和扩展。</li>
<li>考虑添加其他调度策略，如循环调度、条件调度等，以满足不同场景下的任务调度需求。</li>
<li>确保在任务添加时或执行时对任务进行合适的排序，以保证按照优先级执行任务。</li>
</ul>
<h2 id="C-动态抓取工作流设计-示例"><a href="#C-动态抓取工作流设计-示例" class="headerlink" title="C++ 动态抓取工作流设计 示例"></a>C++ 动态抓取工作流设计 示例</h2><p>动态抓取工作流是指根据实际情况动态地抓取或创建工作流程。这种设计使得工作流程可以根据环境变化或特定条件进行动态调整。以下是一个简单的示例，展示如何设计一个简单的动态抓取工作流的思路：</p>
<h3 id="工作流定义："><a href="#工作流定义：" class="headerlink" title="工作流定义："></a>工作流定义：</h3><ol>
<li><p><strong>任务定义：</strong> 定义任务或活动的抽象类或接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Other necessary methods or properties</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>具体任务类：</strong> 实现具体的任务，继承自任务基类，定义任务的具体逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteTaskA</span> : <span class="keyword">public</span> Task &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implement logic for task A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteTaskB</span> : <span class="keyword">public</span> Task &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implement logic for task B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="动态工作流管理："><a href="#动态工作流管理：" class="headerlink" title="动态工作流管理："></a>动态工作流管理：</h3><ol>
<li><p><strong>工作流管理器类：</strong> 负责动态抓取和管理工作流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkflowManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Task*&gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task* task)</span> </span>&#123;</span><br><span class="line">        tasks.<span class="built_in">push_back</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeWorkflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Task* task : tasks) &#123;</span><br><span class="line">            task-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="创建和执行动态工作流程："><a href="#创建和执行动态工作流程：" class="headerlink" title="创建和执行动态工作流程："></a>创建和执行动态工作流程：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WorkflowManager workflowManager;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 动态抓取任务或根据条件添加任务到工作流程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*某些条件满足*/</span>) &#123;</span><br><span class="line">        workflowManager.<span class="built_in">addTask</span>(<span class="keyword">new</span> <span class="built_in">ConcreteTaskA</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        workflowManager.<span class="built_in">addTask</span>(<span class="keyword">new</span> <span class="built_in">ConcreteTaskB</span>());</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 执行动态工作流程</span></span><br><span class="line">    workflowManager.<span class="built_in">executeWorkflow</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项：-4"><a href="#注意事项：-4" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>这个示例是一个简单的动态抓取工作流的概念示例。实际应用中，根据具体需求和条件，可能需要更多的逻辑和条件来动态构建工作流程。</li>
<li>可能需要更复杂的逻辑来根据实时数据或外部条件动态添加、修改或删除工作流程中的任务。</li>
<li>在设计动态抓取工作流时，需考虑到任务之间的依赖关系、错误处理机制、任务状态管理等方面的复杂性。</li>
<li>确保在不再需要时正确地清理任务对象，以避免内存泄漏。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">数据模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>数据模型</li>
</ul>
<h2 id="数据模型是什么"><a href="#数据模型是什么" class="headerlink" title="数据模型是什么"></a>数据模型是什么</h2><ul>
<li>在软件工程中，数据模型是定义数据如何输入和与输出的一种模型。其主要作用是为信息系统提供数据的定义和格式。数据模型是数据库的核心和基础，现有的数据库系统都是基于某种模型而建立起来的。</li>
<li>数据模型的要求<ul>
<li>比较直观的模拟现实世界</li>
<li>容易为人理解</li>
<li>便于计算机实现</li>
</ul>
</li>
<li>数据模型的三要素<ul>
<li>数据结构：储存在数据库中对象类型的集合，作用是描述数据库组成对象以及对象之间的联系</li>
<li>数据操作：指对数据库中各种对象示例允许执行的操作的集合，包括操作及其相关的操作规则</li>
<li>数据完整性约束条件：指在给定的数据模型中，数据及其联系所遵守的一组通用的完整性规则，它能够保证数据的正确性和一致性。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3CPU%E7%9A%84%E5%9E%8B%E5%8F%B7,%E4%BB%A3%E9%99%85%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BE%AE%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3CPU%E7%9A%84%E5%9E%8B%E5%8F%B7,%E4%BB%A3%E9%99%85%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BE%AE%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">深入了解CPU的型号,代际架构与微架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>CPU在整个计算机硬件中，技术体系中都算是最重要的东西了。</li>
<li>以CPU型号是 Intel(R) Core(TM) i5-7200U CPU @2.50GHz 2.71GHz 为例</li>
</ul>
<h2 id="Intel的CPU型号规则"><a href="#Intel的CPU型号规则" class="headerlink" title="Intel的CPU型号规则"></a>Intel的CPU型号规则</h2><ul>
<li><p>无论是哪家CPU厂商，为了更好地管理自己生产的众多型号的产品，也为了能更好地让消费者对自己家的产品快速地了解。都会定义一套产品规则。</p>
</li>
<li><p>Intel把CPU的编号分成了 品牌标志，品牌修饰符，代际编号，SKU，产品线后缀 五个部分</p>
</li>
<li><p>第一部分是品牌标志。最常见的x86 CPU品牌包括Intel和AMD两家公司。而Intel又面向不同的市场需求，包括凌动，赛扬，奔腾，酷睿，志强等多个子品牌。</p>
<ul>
<li>酷睿(CORE)，赛扬(CELERON)，奔腾(PENTIUM)都是应用在家用PC电脑上的品牌。其中奔腾和赛扬这两个品牌已经算作是历史了。奔腾在1992年推出，之后在很长一段时间里是PC家用电脑的主流。赛扬是1998年时为了和AMD竞争低价市场推出的产品，可以理解为缩水版的奔腾。酷睿时2006年推出的，直到现在仍然是PC电脑里的主流品牌。</li>
<li>志强(Xeno)是企业级的CPU，多用于服务器和工作站。大家在工作中使用的线上服务器，基本都是这个子品牌旗下的产品。</li>
<li>凌动(Atom)主打省电和低功耗，主要用在手机平板等设备上。Intel也是做过手机CPU的，但因为功耗问题在竞争中被arm架构各家处理器厂商打败，在2016年后逐渐推出市场</li>
</ul>
</li>
<li><p>第二部分是品牌修饰符，这个部分是为了区分处理器的市场定位的，一般来说同一年代生产的CPU中，i3 i5 i7 i9 的性能是依次递增的。分别代表着低端，中端和高端的定位</p>
</li>
<li><p>第三部分是CPU的代际编号，这一部分有可能是一位数字也有可能是两位的数字在我们的举例中，代际编号是 7 。这个代际编号对应的是Intel于2016年推出的内部代号为Kaby Lake的CPU架构。一般来说，CPU代际编号越大，则代表架构推出的时间点越新。单核的性能也会更好</p>
</li>
<li><p>第四部分是SKU编号。这是CPU厂商为了方便对所有的产品进行库存管理而定制的编号。这类似于超市里商品的条形码，图书的ISBN号，方便查询和管理产品的库存量。一般来说，这个值月大性能越好但不绝对。</p>
</li>
<li><p>第五部分是产品线后缀。在笔记本电脑中，H代表的是高性能，U系列代表的是较低功耗，Y系列代表的是极低的功耗。在台式机中，X代表的是最高性能，K代表的是高性能，T代表的是功耗优化</p>
</li>
<li><p>CPU型号是 Intel(R) Core(TM) i5-7200U CPU @2.50GHz 2.71GHz 。这里面包含的含义是：</p>
<ul>
<li>这是一个Intel的酷睿子品牌的CPU，i7代表这中高端，代际编号是7,这个代际的处理器架构是2016年发布的采用的Kaby Lake架构生产的，SKU编号是200。产品线后缀的U代表的是低功耗，比较省电，同时也就代表着性能并不是最强的。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-vcpkg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-vcpkg/" class="post-title-link" itemprop="url">vcpkg</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>vcpkg</li>
</ul>
<h2 id="vcpkg-常用命令"><a href="#vcpkg-常用命令" class="headerlink" title="vcpkg 常用命令"></a>vcpkg 常用命令</h2><p><code>vcpkg</code> 是一个 C&#x2F;C++ 项目的包管理工具，用于简化在 Windows、Linux 和 macOS 等平台上管理第三方库的过程。以下是一些常用的 <code>vcpkg</code> 命令：</p>
<ol>
<li><p><strong>安装包：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install &lt;package_name&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install zlib</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>卸载包：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg remove &lt;package_name&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg remove zlib</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列出所有可用的包：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg search</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列出已安装的包：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg list</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>升级已安装的包：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg upgrade</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看特定包的信息：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg info &lt;package_name&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg info zlib</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在项目中使用已安装的包：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg integrate install</span><br></pre></td></tr></table></figure>
<p>这个命令会自动将所需的配置设置添加到项目中，使得项目能够找到和使用 <code>vcpkg</code> 安装的包。</p>
</li>
<li><p><strong>清理已安装的包：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg remove --outdated</span><br></pre></td></tr></table></figure>
<p>这会删除已安装的过时包。</p>
</li>
<li><p><strong>更新 <code>vcpkg</code> 本身：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br><span class="line">./bootstrap-vcpkg.sh</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg update</span><br></pre></td></tr></table></figure>
<p>注意：第一种方法需要在 <code>vcpkg</code> 目录下执行，第二种方法则可以在任何地方执行。</p>
</li>
<li><p><strong>帮助：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg help</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg help &lt;command&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg help install</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些是 <code>vcpkg</code> 中的一些常用命令，可以帮助你管理项目依赖的第三方库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-%E5%90%8E%E7%AB%AF%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-%E5%90%8E%E7%AB%AF%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">后端设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>后端开发，基本设计规则</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>后端开发工程师，主要的工作就是：如何把一个接口设计好</li>
</ul>
<h2 id="接口参数校验"><a href="#接口参数校验" class="headerlink" title="接口参数校验"></a>接口参数校验</h2><ul>
<li>入参出参校验是每个程序员必备的基本素养。你设计的接口，必须先校验参数。</li>
<li>比如入参是否允许为空，入参长度是否符合你的预期长度。</li>
</ul>
<h2 id="修改老接口时，注意接口的兼容性"><a href="#修改老接口时，注意接口的兼容性" class="headerlink" title="修改老接口时，注意接口的兼容性"></a>修改老接口时，注意接口的兼容性</h2><ul>
<li>如果需求是在原来的接口上修改，尤其是这个接口是对外提供服务的话，一定要考虑接口的兼容性<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">你加了一个参数C，就可以考虑这样处理：</span><br><span class="line"></span><br><span class="line"><span class="comment">//老接口</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">oldService</span><span class="params">(A,B)</span>&#123;</span><br><span class="line">  <span class="comment">//兼容新接口，传个null代替C</span></span><br><span class="line">  newService(A,B,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新接口，暂时不能删掉老接口，需要做兼容。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">newService</span><span class="params">(A,B,C)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="设计接口时，充分考虑接口的可扩展性"><a href="#设计接口时，充分考虑接口的可扩展性" class="headerlink" title="设计接口时，充分考虑接口的可扩展性"></a>设计接口时，充分考虑接口的可扩展性</h2><ul>
<li>要根据实际业务场景设计接口，充分考虑接口的可扩展性。</li>
</ul>
<h2 id="接口考虑是否需要防重处理"><a href="#接口考虑是否需要防重处理" class="headerlink" title="接口考虑是否需要防重处理"></a>接口考虑是否需要防重处理</h2><ul>
<li><p>如果前端重复请求，你的逻辑如何处理？是不是考虑接口去重处理</p>
</li>
<li><p>当然，如果是查询类的请求，其实不用防重。</p>
</li>
<li><p>如果是更新修改类的话，尤其是金融转账的，就要过滤重复请求了。</p>
</li>
<li><p>推荐使用数据库的防重表，以唯一流水号作为主键或者唯一索引</p>
</li>
</ul>
<h2 id="重点接口，考虑线程池隔离"><a href="#重点接口，考虑线程池隔离" class="headerlink" title="重点接口，考虑线程池隔离"></a>重点接口，考虑线程池隔离</h2><ul>
<li><p>一些登录，转账交易，下单等重要接口，考虑线程池隔离。</p>
</li>
<li><p>如果所有业务都公用一个线程池，有些业务出bug导致线程阻塞打满的话，所有业务都被影响了。</p>
</li>
<li><p>因此进行线程池隔离，重要业务多分配一点核心线程，就更好的保护业务。</p>
</li>
</ul>
<h2 id="调用第三方接口要考虑异常和超时处理"><a href="#调用第三方接口要考虑异常和超时处理" class="headerlink" title="调用第三方接口要考虑异常和超时处理"></a>调用第三方接口要考虑异常和超时处理</h2><ul>
<li><p>异常处理</p>
<ul>
<li>比如，调用了别人的接口，如果异常了，怎么处理，是重试还是当作失败还是告警处理</li>
</ul>
</li>
<li><p>接口超时</p>
<ul>
<li>没办法预估对方接口一般多久返回，一般设置一个超时断开时间，以保护你的接口。</li>
<li>一个生产问题：就是http调用不设置超时时间，最后响应进程假死，请求一直占着线程不释放，拖垮线程池</li>
</ul>
</li>
<li><p>重试次数</p>
</li>
</ul>
<h2 id="接口实现考虑熔断和降级"><a href="#接口实现考虑熔断和降级" class="headerlink" title="接口实现考虑熔断和降级"></a>接口实现考虑熔断和降级</h2><ul>
<li><p>当前互联网系统一般是分布式部署的。而分布式系统中经常会出现某个基础服务不可用，最终导致整个服务不可用的情况，这种现象被称为服务雪崩效应</p>
</li>
<li><p>为了应对服务雪崩，常见的作法就是熔断和降级。</p>
<ul>
<li>最简单的是加开关控制，当下游系统出问题时，开关降级，不在调用下游系统，还可以选用开源组件 Hystrix</li>
</ul>
</li>
</ul>
<h2 id="日志打印好，接口的关键代码一定要有日志"><a href="#日志打印好，接口的关键代码一定要有日志" class="headerlink" title="日志打印好，接口的关键代码一定要有日志"></a>日志打印好，接口的关键代码一定要有日志</h2><ul>
<li>入参之前打印一下参数</li>
<li>接口调用之后，打印一下异常</li>
</ul>
<h2 id="接口的功能定义要具备单一性"><a href="#接口的功能定义要具备单一性" class="headerlink" title="接口的功能定义要具备单一性"></a>接口的功能定义要具备单一性</h2><ul>
<li><p>单一性是指接口做的事情比较单一，专一</p>
<ul>
<li>比如一个登陆接口，它做的事情就只是校验账户名密码，然后返回登陆成功以及userId即可。但是如果你为了减少接口交互，把一些注册、一些配置查询等全放到登陆接口，就不太妥</li>
</ul>
</li>
<li><p>其实这也是微服务一些思想，接口的功能单一</p>
</li>
</ul>
<h2 id="接口有些场景，使用异步更合适"><a href="#接口有些场景，使用异步更合适" class="headerlink" title="接口有些场景，使用异步更合适"></a>接口有些场景，使用异步更合适</h2><ul>
<li><p>做异步的方式，简单的就是用线程池。还可以使用消息队列，就是用户注册成功后，生产者产生一个注册成功的消息，消费者拉到注册成功的消息，就发送通知</p>
</li>
<li><p>不是所有的接口都适合设计为同步接口。比如你要做一个转账的功能，如果你是单笔的转账，你是可以把接口设计同步。用户发起转账时，客户端在静静等待转账结果就好。如果你是批量转账，一个批次一千笔，甚至一万笔的，你则可以把接口设计为异步。就是用户发起批量转账时，持久化成功就先返回受理成功。然后用户隔十分钟或者十五分钟等再来查转账结果就好。又或者，批量转账成功后，再回调上游系统</p>
</li>
</ul>
<h2 id="优化接口耗时，远程串行考虑改为并行调用"><a href="#优化接口耗时，远程串行考虑改为并行调用" class="headerlink" title="优化接口耗时，远程串行考虑改为并行调用"></a>优化接口耗时，远程串行考虑改为并行调用</h2><h2 id="接口合并或者说-考虑批量处理思想"><a href="#接口合并或者说-考虑批量处理思想" class="headerlink" title="接口合并或者说 考虑批量处理思想"></a>接口合并或者说 考虑批量处理思想</h2><ul>
<li><p>数据库操作或者是 远程过程调用时，能够批量操作就不要for循环调用</p>
</li>
<li><p>kafka使用批量消息提升服务端处理能力</p>
</li>
</ul>
<h2 id="接口实现过程中，恰当使用缓存"><a href="#接口实现过程中，恰当使用缓存" class="headerlink" title="接口实现过程中，恰当使用缓存"></a>接口实现过程中，恰当使用缓存</h2><ul>
<li><p>哪些场景适合使用缓存？</p>
<ul>
<li>读多，写少且数据时效要求越低的场景</li>
</ul>
</li>
<li><p>缓存用的好，可以承载更多的请求，提升查询效率，减少数据库的压力</p>
</li>
</ul>
<h2 id="考虑接口热点数据隔离性"><a href="#考虑接口热点数据隔离性" class="headerlink" title="考虑接口热点数据隔离性"></a>考虑接口热点数据隔离性</h2><ul>
<li>瞬时间的高并发，可能会打垮你的系统。可以做一些热点数据隔离。比如业务隔离，系统隔离，用户隔离，数据隔离等等。</li>
</ul>
<h2 id="可变参数配置化，比如红包皮肤切换等"><a href="#可变参数配置化，比如红包皮肤切换等" class="headerlink" title="可变参数配置化，比如红包皮肤切换等"></a>可变参数配置化，比如红包皮肤切换等</h2><h2 id="接口考虑幂等性"><a href="#接口考虑幂等性" class="headerlink" title="接口考虑幂等性"></a>接口考虑幂等性</h2><ul>
<li><p>接口是需要考虑幂等性的。尤其抢红包、转账这些重要接口。最直观的业务场景，就是用户连着点击两次，你的接口有没有hold住。或者消息队列出现重复消费的情况，你的业务逻辑怎么控制？</p>
</li>
<li><p>什么是幂等？</p>
<ul>
<li>计算机科学中，幂等表示一次和多次请求某一个资源应该具有同样的副作用，或者说，多次请求所产生的影响与一次请求执行的影响效果相同。</li>
<li>大家别搞混哈，防重和幂等设计其实是有区别的。防重主要为了避免产生重复数据，把重复请求拦截下来即可。而幂等设计除了拦截已经处理的请求，还要求每次相同的请求都返回一样的效果。不过呢，很多时候，它们的处理流程、方案是类似的哈。</li>
</ul>
</li>
<li><p>接口幂等实现方案主要有8种：</p>
<ul>
<li>select+insert+主键&#x2F;唯一索引冲突</li>
<li>直接insert + 主键&#x2F;唯一索引冲突</li>
<li>状态机幂等</li>
<li>抽取防重表</li>
<li>token令牌</li>
<li>悲观锁</li>
<li>乐观锁</li>
<li>分布式锁</li>
</ul>
</li>
</ul>
<h2 id="读写分离，优先考虑读从库，注意主从延迟问题"><a href="#读写分离，优先考虑读从库，注意主从延迟问题" class="headerlink" title="读写分离，优先考虑读从库，注意主从延迟问题"></a>读写分离，优先考虑读从库，注意主从延迟问题</h2><ul>
<li><p>我们的数据库都是集群部署的，有主库也有从库，当前一般都是读写分离的。比如你写入数据，肯定是写入主库，但是对于读取实时性要求不高的数据，则优先考虑读从库，因为可以分担主库的压力。</p>
</li>
<li><p>如果读取从库的话，需要考虑主从延迟的问题</p>
</li>
</ul>
<h2 id="接口注意返回的数据量，如果数据大需要分页"><a href="#接口注意返回的数据量，如果数据大需要分页" class="headerlink" title="接口注意返回的数据量，如果数据大需要分页"></a>接口注意返回的数据量，如果数据大需要分页</h2><ul>
<li>一个接口返回报文，不应该包含过多的数据量。过多的数据量不仅处理复杂，并且数据量传输的压力也非常大。因此数量实在是比较大，可以分页返回，如果是功能不相关的报文，那应该考虑接口拆分</li>
</ul>
<h2 id="好的接口实现，离不开SQL优化"><a href="#好的接口实现，离不开SQL优化" class="headerlink" title="好的接口实现，离不开SQL优化"></a>好的接口实现，离不开SQL优化</h2><ul>
<li>SQLL优化从这几个维度思考：<ul>
<li>explain 分析SQL查询计划（重点关注type、extra、filtered字段）</li>
<li>show profile分析，了解SQL执行的线程的状态以及消耗的时间</li>
<li>索引优化 （覆盖索引、最左前缀原则、隐式转换、order by以及group by的优化、join优化）</li>
<li>大分页问题优化（延迟关联、记录上一页最大ID）</li>
<li>数据量太大（分库分表、同步到es，用es查询）</li>
</ul>
</li>
</ul>
<h2 id="代码锁的粒度控制好"><a href="#代码锁的粒度控制好" class="headerlink" title="代码锁的粒度控制好"></a>代码锁的粒度控制好</h2><ul>
<li>什么是加锁粒度呢？<ul>
<li>其实就是你要锁住的范围是多大</li>
</ul>
</li>
</ul>
<h2 id="接口状态和错误需要统一明确"><a href="#接口状态和错误需要统一明确" class="headerlink" title="接口状态和错误需要统一明确"></a>接口状态和错误需要统一明确</h2><ul>
<li>提供必要的接口调用状态信息。比如你的一个转账接口调用是成功、失败、处理中还是受理成功等，需要明确告诉客户端。如果接口失败，那么具体失败的原因是什么。这些必要的信息都必须要告诉给客户端，因此需要定义明确的错误码和对应的描述。同时，尽量对报错信息封装一下，不要把后端的异常信息完全抛出到客户端。</li>
</ul>
<h2 id="接口要考虑异常处理"><a href="#接口要考虑异常处理" class="headerlink" title="接口要考虑异常处理"></a>接口要考虑异常处理</h2><ul>
<li>实现一个好的接口，离不开优雅的异常处理。对于异常处理，提十个小建议吧：<ul>
<li>尽量不要使用e.printStackTrace(),而是使用log打印。因为e.printStackTrace()语句可能会导致内存占满。</li>
<li>catch住异常时，建议打印出具体的exception，利于更好定位问题</li>
<li>不要用一个Exception捕捉所有可能的异常</li>
<li>记得使用finally关闭流资源或者直接使用try-with-resource</li>
<li>捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类</li>
<li>捕获到的异常，不能忽略它，至少打点日志吧</li>
<li>注意异常对你的代码层次结构的侵染</li>
<li>自定义封装异常，不要丢弃原始异常的信息Throwable cause</li>
<li>运行时异常RuntimeException ，不应该通过catch的方式来处理，而是先预检查，比如：NullPointerException处理</li>
<li>注意异常匹配的顺序，优先捕获具体的异常</li>
</ul>
</li>
</ul>
<h2 id="优化程序逻辑"><a href="#优化程序逻辑" class="headerlink" title="优化程序逻辑"></a>优化程序逻辑</h2><ul>
<li><p>优化程序逻辑这块还是挺重要的，也就是说，你实现的业务代码，如果是比较复杂的话，建议把注释写清楚。还有，代码逻辑尽量清晰，代码尽量高效。</p>
</li>
<li><p>你要使用用户信息的属性，你根据session已经获取到userId了，然后就把用户信息从数据库查询出来，使用完后，后面可能又要用到用户信息的属性，有些小伙伴没想太多，反手就把userId再传进去，再查一次数据库。。。我在项目中，见过这种代码。。。直接把用户对象传下来不好嘛。。</p>
</li>
</ul>
<h2 id="接口实现过程中，注意大文件，大事务，大对象"><a href="#接口实现过程中，注意大文件，大事务，大对象" class="headerlink" title="接口实现过程中，注意大文件，大事务，大对象"></a>接口实现过程中，注意大文件，大事务，大对象</h2><ul>
<li>读取大文件时，不要Files.readAllBytes直接读取到内存，这样会OOM的，建议使用BufferedReader一行一行来。</li>
<li>大事务可能导致死锁、回滚时间长、主从延迟等问题，开发中尽量避免大事务。</li>
<li>注意一些大对象的使用，因为大对象是直接进入老年代的，可能会触发fullGC</li>
</ul>
<h2 id="你的接口，需要考虑限流"><a href="#你的接口，需要考虑限流" class="headerlink" title="你的接口，需要考虑限流"></a>你的接口，需要考虑限流</h2><ul>
<li><p>如果你的系统每秒扛住的请求是1000，如果一秒钟来了十万请求呢？换个角度就是说，高并发的时候，流量洪峰来了，超过系统的承载能力，怎么办呢？</p>
</li>
<li><p>如果不采取措施，所有的请求打过来，系统CPU、内存、Load负载飚的很高，最后请求处理不过来，所有的请求无法正常响应。</p>
</li>
<li><p>针对这种场景，我们可以采用限流方案。就是为了保护系统，多余的请求，直接丢弃。</p>
</li>
<li><p>限流定义：</p>
<ul>
<li>在计算机网络中，限流就是控制网络接口发送或接收请求的速率，它可防止DoS攻击和限制Web爬虫。限流，也称流量控制。是+ 指系统在面临高并发，或者大流量请求的情况下，限制新的请求对系统的访问，从而保证系统的稳定性。</li>
<li>可以使用Guava的RateLimiter单机版限流，也可以使用Redis分布式限流，还可以使用阿里开源组件sentinel限流</li>
</ul>
</li>
</ul>
<h2 id="代码实现时，注意运行时异常"><a href="#代码实现时，注意运行时异常" class="headerlink" title="代码实现时，注意运行时异常"></a>代码实现时，注意运行时异常</h2><ul>
<li>日常开发中，我们需要采取措施规避数组边界溢出，被零整除，空指针等运行时错误。类似代码比较常见：</li>
</ul>
<h2 id="保证接口安全性"><a href="#保证接口安全性" class="headerlink" title="保证接口安全性"></a>保证接口安全性</h2><ul>
<li><p>如果你的API接口是对外提供的，需要保证接口的安全性。保证接口的安全性有token机制和接口签名</p>
</li>
<li><p>机制身份验证方案还比较简单的，就是</p>
<ul>
<li>客户端发起请求，申请获取token。</li>
<li>服务端生成全局唯一的token，保存到redis中（一般会设置一个过期时间），然后返回给客户端。</li>
<li>客户端带着token，发起请求。</li>
<li>服务端去redis确认token是否存在，一般用 redis.del(token)的方式，如果存在会删除成功，即处理业务逻辑，如果删除失败不处理业务逻辑，直接返回结果。</li>
</ul>
</li>
<li><p>接口签名的方式，就是把接口请求相关信息（请求报文，包括请求时间戳、版本号、appid等），客户端私钥加签，然后服务端用公钥验签，验证通过才认为是合法的、没有被篡改过的请求。</p>
</li>
<li><p>除了加签验签和token机制，接口报文一般是要加密的。当然，用https协议是会对报文加密的。如果是我们服务层的话，如何加解密呢？</p>
</li>
<li><p>可以参考HTTPS的原理，就是服务端把公钥给客户端，然后客户端生成对称密钥，接着客户端用服务端的公钥加密对称密钥，再发到服务端，服务端用自己的私钥解密，得到客户端的对称密钥。这时候就可以愉快传输报文啦，客户端用对称密钥加密请求报文，服务端用对应的对称密钥解密报文。</p>
</li>
<li><p>有时候，接口的安全性，还包括手机号、身份证等信息的脱敏。就是说，用户的隐私数据，不能随便暴露</p>
</li>
</ul>
<h2 id="分布式事务，如何保证"><a href="#分布式事务，如何保证" class="headerlink" title="分布式事务，如何保证"></a>分布式事务，如何保证</h2><ul>
<li><p>分布式事务：就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单来说，分布式事务指的就是分布式系统中的事务，它的存在就是为了保证不同数据库节点的数据一致性。</p>
</li>
<li><p>分布式事务的几种解决方案：</p>
<ul>
<li>2PC(二阶段提交)方案、3PC</li>
<li>TCC（Try、Confirm、Cancel）</li>
<li>本地消息表</li>
<li>最大努力通知</li>
<li>seata</li>
</ul>
</li>
</ul>
<h2 id="事务失效的一些经典场景"><a href="#事务失效的一些经典场景" class="headerlink" title="事务失效的一些经典场景"></a>事务失效的一些经典场景</h2><ul>
<li>我们的接口开发过程中，经常需要使用到事务。所以需要避开事务失效的一些经典场景。<ul>
<li>方法的访问权限必须是public，其他private等权限，事务失效</li>
<li>方法被定义成了final的，这样会导致事务失效。</li>
<li>在同一个类中的方法直接内部调用，会导致事务失效。</li>
<li>一个方法如果没交给spring管理，就不会生成spring事务。</li>
<li>多线程调用，两个方法不在同一个线程中，获取到的数据库连接不一样的。</li>
<li>表的存储引擎不支持事务</li>
<li>如果自己try…catch误吞了异常，事务失效。</li>
<li>错误的传播特性</li>
</ul>
</li>
</ul>
<h2 id="掌握常用的设计模式"><a href="#掌握常用的设计模式" class="headerlink" title="掌握常用的设计模式"></a>掌握常用的设计模式</h2><ul>
<li>把代码写好，还是需要熟练常用的设计模式，比如策略模式、工厂模式、模板方法模式、观察者模式等等。设计模式，是代码设计经验的总结。使用设计模式可以可重用代码、让代码更容易被他人理解、保证代码可靠性。</li>
</ul>
<h2 id="写代码时，考虑线性安全问题"><a href="#写代码时，考虑线性安全问题" class="headerlink" title="写代码时，考虑线性安全问题"></a>写代码时，考虑线性安全问题</h2><ul>
<li>在高并发情况下，HashMap可能会出现死循环。因为它是非线性安全的，可以考虑使用ConcurrentHashMap。所以这个也尽量养成习惯，不要上来反手就是一个new HashMap();</li>
</ul>
<h2 id="接口定义清晰易懂，命名规范"><a href="#接口定义清晰易懂，命名规范" class="headerlink" title="接口定义清晰易懂，命名规范"></a>接口定义清晰易懂，命名规范</h2><ul>
<li>我们写代码，不仅仅是为了实现当前的功能，也要有利于后面的维护。说到维护，代码不仅仅是写给自己看的，也是给别人看的。所以接口定义要清晰易懂，命名规范。</li>
</ul>
<h2 id="接口的版本控制"><a href="#接口的版本控制" class="headerlink" title="接口的版本控制"></a>接口的版本控制</h2><ul>
<li>接口要做好版本控制。就是说，请求基础报文，应该包含version接口版本号字段，方便未来做接口兼容。其实这个点也算接口扩展性的一个体现点吧。</li>
<li>比如客户端APP某个功能优化了，新老版本会共存，这时候我们的version版本号就派上用场了，对version做升级，做好版本控制。</li>
</ul>
<h2 id="注意代码规范问题"><a href="#注意代码规范问题" class="headerlink" title="注意代码规范问题"></a>注意代码规范问题</h2><ul>
<li>注意一些常见的代码坏味道：<ul>
<li>大量重复代码（抽共用方法，设计模式）</li>
<li>方法参数过多（可封装成一个DTO对象）</li>
<li>方法过长（抽小函数）</li>
<li>判断条件太多（优化if…else）</li>
<li>不处理没用的代码</li>
<li>不注重代码格式</li>
<li>避免过度设计</li>
</ul>
</li>
</ul>
<h2 id="保证接口正确性，其实就是保证更少的bug"><a href="#保证接口正确性，其实就是保证更少的bug" class="headerlink" title="保证接口正确性，其实就是保证更少的bug"></a>保证接口正确性，其实就是保证更少的bug</h2><h2 id="学会沟通，跟前端沟通，跟产品沟通"><a href="#学会沟通，跟前端沟通，跟产品沟通" class="headerlink" title="学会沟通，跟前端沟通，跟产品沟通"></a>学会沟通，跟前端沟通，跟产品沟通</h2><ul>
<li>我把这一点放到最后，学会沟通是非常非常重要的。比如你开发定义接口时，一定不能上来就自己埋头把接口定义完了，需要跟客户端先对齐接口。遇到一些难点时，跟技术leader对齐方案。实现需求的过程中，有什么问题，及时跟产品沟通。</li>
<li>总之就是，开发接口过程中，一定要沟通好~</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" class="post-title-link" itemprop="url">配置文件格式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>不管是移动应用，桌面程序还是后台服务，经常需要从配置文件中读取配置信息，进行程序初始化和改变运行时的状态。以什么样的格式来存储配置信息，这是开发人员需要面临的一个文件。</li>
<li>常用的配置文件格式主要用：<ul>
<li>键值对</li>
<li>JSON</li>
<li>XML</li>
<li>YAML</li>
<li>TOML</li>
</ul>
</li>
</ul>
<h2 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h2><ul>
<li>键值对是一个非常简单易用的配置文件格式。每一个键值对表示一项配置，键值对的分隔符一般使用等号或者冒号。解析时，可以将#号开始的行视为注释行，以达到注释的功能</li>
<li>以键值对为表现形式的配置文件格式常见的用Windows .ini文件和Java中的.properties文件</li>
<li>例如下面是一个使用键值对表示的后台服务配置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># This is a comment</span><br><span class="line">name=UserProfileServer</span><br><span class="line">maxconns=1000</span><br><span class="line">queuecap=10000</span><br><span class="line">queuetimeout=300</span><br><span class="line">loglevel=ERROR</span><br><span class="line">logsize=10M</span><br><span class="line">lognum=10</span><br><span class="line">logpath=/usr/local/app/log</span><br></pre></td></tr></table></figure></li>
<li>在解析上面的配置时，可以按行读取，然后放到 map 中。下面以 Go 为例，完成对上面配置文件的解析。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line"> 	<span class="string">&quot;io&quot;</span></span><br><span class="line"> 	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseConf</span><span class="params">(confPath <span class="type">string</span>)</span></span> (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> confPath == <span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;param is ill&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	f, err := os.Open(confPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//store config info</span></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	</span><br><span class="line">	bfRd := bufio.NewReader(f)</span><br><span class="line">	<span class="comment">//read by line, the line terminator is &#x27;\n&#x27;</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		line, err := bfRd.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> || err == io.EOF&#123;</span><br><span class="line">			<span class="comment">//ignore blank and comment line</span></span><br><span class="line">			<span class="keyword">if</span> strings.TrimSpace(line) != <span class="string">&quot;&quot;</span> &amp;&amp; strings.TrimSpace(line)[<span class="number">0</span>] != <span class="string">&#x27;#&#x27;</span>&#123;</span><br><span class="line">				vKV := strings.Split(line, <span class="string">&quot;=&quot;</span>)</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(vKV) == <span class="number">2</span> &#123;</span><br><span class="line">					m[vKV[<span class="number">0</span>]] = vKV[<span class="number">1</span>]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF&#123;</span><br><span class="line">				<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mConf, _ := ParseConf(<span class="string">&quot;server.kv&quot;</span>)</span><br><span class="line">	fmt.Println(mConf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行结果：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[loglevel:ERROR</span><br><span class="line"> lognum:<span class="number">10</span></span><br><span class="line"> logpath:/usr/local/app/log</span><br><span class="line"> logsize:<span class="number">10</span>M</span><br><span class="line"> maxconns:<span class="number">1000</span></span><br><span class="line"> name:UserProfileServer</span><br><span class="line"> queuecap:<span class="number">10000</span></span><br><span class="line"> queuetimeout:<span class="number">300</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li><p>JSON(JavaScript Object Notion)，是轻量级的文本数据交换格式，独立于语言，具有自我描述性。JSON类似于XML，但是比XML更小，更快，更易解析</p>
</li>
<li><p>JSON语法是JavaScript对象表示法语法的子集：</p>
<ul>
<li>数据在名称&#x2F;值对中</li>
<li>数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
</li>
<li><p>名称&#x2F;值包括字段名称(在双引号中)，后面写一个冒号，然后是值</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个合法的JSON可以是：</p>
<ul>
<li>数字(整数或者浮点数)</li>
<li>字符串(在双引号中)</li>
<li>布尔(true或者 false)</li>
<li>数组(在方括号中)</li>
<li>对象(在花括号中)</li>
<li>null</li>
</ul>
</li>
<li><p>下面以 JSON 表示一个简单的后台服务配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;-name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UserProfileServer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;maxconns&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;queuecap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;queuetimeout&quot;</span><span class="punctuation">:</span> <span class="string">&quot;300&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;loginfo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;loglevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ERROR&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;logsize&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10M&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;lognum&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;logpath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/local/app/log&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>其中 -name 表示服务的名称，前面一个横杠表示该值可以转换为 XML 的标签属性。其它的键值对表示服务的各个配置项</p>
</li>
</ul>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><ul>
<li><p>XML(Extensible Markup Language)是可扩展标记语言，用来传输和存储数据。因为其允许用户自定义标记名称，具有自我描述性，可灵活地用于存储服务配置信息</p>
</li>
<li><p>XML文档结构是一种树结构，它从根部开始，然后扩展到枝叶。XML文档必须有一个唯一的根节点，根节点包含所有其他节点。所有节点均可拥有文本内容和属性(名称&#x2F;值的对)。XML节点也叫做XML元素</p>
</li>
</ul>
<h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h2><ul>
<li><p>YAML(YAML Ain’t a Markup Language)是专门用来写配置文件的语言，简洁强大，相比于JSON和XML，更加便于开发人员读写。</p>
</li>
<li><p>YAML配置文件后缀为.yml或者.yaml</p>
</li>
<li><p>YAML 的基本语法规则如下：</p>
<ul>
<li>数据结构采用键值对的形式 key: value。</li>
<li>键冒号后面要加空格（一般为 1 个空格）。</li>
<li>字母大小写敏感。</li>
<li>使用缩进表示层级关系。</li>
<li>缩进只允许使用空格，不允许使用 Tab 键。</li>
<li>缩进空格数可以任意，只要相同层级的元素左侧对齐即可。</li>
<li>字符串值一般不使用引号，必要时可使用。使用双引号表示字符串时，会转义字符串中的特殊字符（例如\n）。使用单引号时不会转义字符串中的特殊字符。</li>
<li>数组中的每个元素单独一行，并以 - 开头。或使用方括号，元素用逗号隔开。注意短横杆和逗号后面都要有空格。</li>
<li>对象中的每个成员单独一行，使用键值对形式。或者使用大括号并用逗号分开。</li>
<li>文档以三个连字符—表示开始，以三个点号…表示结束，二者都是可选的。</li>
<li>文档前面可能会有指令，在这种情况下，需要使用—来表示指令的结束。指令是一个%后跟一个标识符和一些形参。</li>
<li>目前只有两个指令：%YAML指定文档的 YAML 版本，%TAG用于 tag 简写。二者都很少使用。</li>
<li>#表示注释，从这个字符一直到行尾，都会被解析器忽略。</li>
</ul>
</li>
<li><p>YAML支持的数据结构有三种：</p>
<ul>
<li>对象：键值对的集合，又称为映射(mapping)，散列(hashes)，字典(dictionary)</li>
<li>数组：一组按次序排列的值，又称为序列(sequence)，列表(list)</li>
<li>标量：单个不可再分的值</li>
</ul>
</li>
<li><p>对象</p>
<ul>
<li>对象的一组键值对，使用冒号结构表示<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Steve</span></span><br></pre></td></tr></table></figure></li>
<li>YAML也允许另一种写法，将所有键值对写成一个行内对象<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">who:</span> &#123;<span class="attr">name:</span> <span class="string">Steve</span>, <span class="attr">age:</span> <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>当然，如果对象元素太多一行放不下，那么可以换行<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">who:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Steve</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li>一组以连字符开头的行，构成一个数组。注意，连字符后需要添加空格<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animals:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure></li>
<li>连字符前可以没有缩进，也就是说下面的这种写法也是OK的，但是还是建议缩进，因为更加易读<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animals:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure></li>
<li>数组也可以采用行内表示法<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> [<span class="string">Cat</span>, <span class="string">Dog</span>, <span class="string">Goldfish</span>]</span><br></pre></td></tr></table></figure></li>
<li>如果数组元素是一个数组，则可以在连字符下面再缩进输入一个数组<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animals:</span></span><br><span class="line">  <span class="bullet">-</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line">  <span class="bullet">-</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Fish</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure></li>
<li>如果是行内表示，则为：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animals:</span> [[<span class="string">Cat</span>, <span class="string">Dog</span>], [<span class="string">Fish</span>, <span class="string">Goldfish</span>]]</span><br></pre></td></tr></table></figure></li>
<li>如果数组元素是一个对象，可以写作：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animals:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">species:</span> <span class="string">dog</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">species:</span> <span class="string">cat</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">bar</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li>对应的 JSON 为：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;animals&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;species&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dog&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foo&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;species&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cat&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bar&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>对象和数组可以结合使用，形成复合结构。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">languages:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Ruby</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Perl</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Python</span> </span><br><span class="line"><span class="attr">websites:</span></span><br><span class="line"> <span class="attr">YAML:</span> <span class="string">yaml.org</span> </span><br><span class="line"> <span class="attr">Ruby:</span> <span class="string">ruby-lang.org</span> </span><br><span class="line"> <span class="attr">Python:</span> <span class="string">python.org</span> </span><br><span class="line"> <span class="attr">Perl:</span> <span class="string">use.perl.org</span> </span><br></pre></td></tr></table></figure></li>
<li>对应的 JSON 表示如下：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;languages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;Ruby&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Perl&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Python&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;websites&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;YAML&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yaml.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Ruby&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ruby-lang.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Python&quot;</span><span class="punctuation">:</span> <span class="string">&quot;python.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Perl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;use.perl.org&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>标量是最基本、不可再分的值。有以下 7 种：</p>
<ul>
<li>字符串</li>
<li>布尔值</li>
<li>整数</li>
<li>浮点数</li>
<li>Null</li>
<li>时间</li>
<li>日期</li>
</ul>
</li>
<li><p>使用一个例子来快速了解标量的基本使用：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">boolean:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="literal">TRUE</span>	<span class="comment"># true、True 都可以</span></span><br><span class="line">    <span class="bullet">-</span> <span class="literal">FALSE</span>	<span class="comment"># false、False 都可以</span></span><br><span class="line"><span class="attr">float:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">3.14</span>			<span class="comment"># 数值直接以字面量的形式表示</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">6.8523015e+5</span>	<span class="comment"># 可以使用科学计数法</span></span><br><span class="line"><span class="attr">int:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">123</span>							<span class="comment"># 数值直接以字面量的形式表示</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">0b1010_0111_0100_1010_1110</span>	<span class="comment"># 二进制表示</span></span><br><span class="line"><span class="attr">null:</span></span><br><span class="line">    <span class="attr">nodeName:</span> <span class="string">&#x27;node&#x27;</span></span><br><span class="line">    <span class="attr">parent:</span> <span class="string">~</span>  		 <span class="comment"># 使用~表示 null</span></span><br><span class="line"><span class="attr">string:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hello</span>			 <span class="comment"># 字符串默认不使用引号</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;Hello world&quot;</span>  <span class="comment"># 使用双引号或单引号包裹含有空格或特殊字符（如冒号）的字符串</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">newline</span></span><br><span class="line">      <span class="string">newline1</span>		 <span class="comment"># 字符串可以拆成多行，每一换行符会被转化成一个空格</span></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2018-02-17</span>     <span class="comment"># 日期必须使用 ISO 8601 格式，即 yyyy-MM-dd</span></span><br><span class="line"><span class="attr">datetime:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2018-02-17T15:02:31+08:00</span>    <span class="comment"># 时间使用 ISO 8601 格式，时间和日期之间使用 T 连接，+08:00 表示时区</span></span><br></pre></td></tr></table></figure></li>
<li><p>YAML 字符串有三种表示方式：</p>
<ul>
<li>无引号</li>
<li>单引号</li>
<li>双引号</li>
</ul>
</li>
<li><p>字符串默认不需要引号，但是如果字符串包含空格或特殊字符（如冒号），需要加引号。</p>
</li>
<li><p>双引号字符串允许在字符串中使用转义序列来表示特殊字符，例如 \n 表示换行，\t 表示制表符，以及 &quot; 表示双引号。</p>
</li>
<li><p>单引号字符串被视为纯粹的字面字符串，不支持转义序列。</p>
</li>
<li><p>如果字符串含有单引号，可以使用双引号包裹，反之亦然</p>
</li>
<li><p>锚点 &amp; 和别名 *，可以用来完成引用</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">defaults:</span> <span class="meta">&amp;defaults</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br></pre></td></tr></table></figure></li>
<li><p>等同于下面的配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">defaults:</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br></pre></td></tr></table></figure></li>
<li><p>&amp; 用来建立锚点（defaults），&lt;&lt; 表示合并到当前数据，* 用来引用锚点。</p>
</li>
<li><p>如果想引入多行的文本块，可以使用 |，|+，|-，&gt;，&gt;+，&gt;-</p>
</li>
<li><p>当内容换行时，保留换行符</p>
</li>
<li><p>如果最后一行有多个换行符，只保留一个换行符</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">linefeed1:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string">  text</span></span><br><span class="line"><span class="string"></span><span class="attr">linefeed2:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string">  text</span></span><br><span class="line"><span class="string"></span>  </span><br><span class="line"><span class="attr">linefeed3:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="string">text</span></span><br></pre></td></tr></table></figure></li>
<li><p>对应的 JSON 为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;linefeed1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some\ntext\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;linefeed2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some\ntext\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;linefeed3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some\n\ntext\n&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当内容换行时，保留换行符。</p>
</li>
<li><p>与 | 的区别是，如果最后一行有多个换行符，则保留实际数目。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;linefeed1&quot;:</span> <span class="string">&quot;some\ntext\n&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;linefeed2&quot;:</span> <span class="string">&quot;some\ntext\n\n&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;linefeed3&quot;:</span> <span class="string">&quot;some\n\ntext\n&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当内容换行时，保留换行符，但最后的换行符不保留</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">linefeed1:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string">  text</span></span><br><span class="line"><span class="string"></span><span class="attr">linefeed2:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string">  text</span></span><br><span class="line"><span class="string"></span>  </span><br><span class="line"><span class="attr">linefeed3:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="string">text</span></span><br></pre></td></tr></table></figure></li>
<li><p>对应的 JSON 为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;linefeed1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some\ntext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;linefeed2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some\ntext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;linefeed3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some\n\ntext&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当内容换行时，替换为空格，但保留最后一行的换行符</p>
</li>
<li><p>如果最后一行有多个换行符，只保留一个换行符</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">linefeed1:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string">  text</span></span><br><span class="line"><span class="string"></span><span class="attr">linefeed2:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string">  text</span></span><br><span class="line"><span class="string"></span>  </span><br><span class="line"><span class="attr">linefeed3:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="string">text</span></span><br></pre></td></tr></table></figure></li>
<li><p>对应的 JSON 为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;linefeed1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some text\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;linefeed2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some text\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;linefeed3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some\ntext\n&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当内容换行时，替换为空格，但保留最后一行的换行符。</p>
</li>
<li><p>与 &gt; 的区别是，如果最后一行有多个换行符，则保留实际数目。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">linefeed1:</span> <span class="string">&gt;+</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string">  text</span></span><br><span class="line"><span class="string"></span><span class="attr">linefeed2:</span> <span class="string">&gt;+</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string">  text</span></span><br><span class="line"><span class="string"></span>  </span><br><span class="line"><span class="attr">linefeed3:</span> <span class="string">&gt;+</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="string">text</span></span><br></pre></td></tr></table></figure></li>
<li><p>对应的 JSON 为</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;linefeed1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some text\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;linefeed2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some text\n\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;linefeed3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some\ntext\n&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p>-（缺省行为）</p>
</blockquote>
</li>
<li><p>当内容换行时，替换为空格，不保留最后一行的换行符。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">linefeed1:</span> <span class="string">&gt;-</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string">  text</span></span><br><span class="line"><span class="string"></span><span class="attr">linefeed2:</span> <span class="string">&gt;-</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string">  text</span></span><br><span class="line"><span class="string"></span>  </span><br><span class="line"><span class="attr">linefeed3:</span> <span class="string">&gt;-</span></span><br><span class="line"><span class="string">  some</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="string">text</span></span><br></pre></td></tr></table></figure></li>
<li><p>对应的 JSON 为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;linefeed1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;linefeed2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;linefeed3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some\ntext&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：以上 6 个特殊字符，|- 和 &gt;- 用得最多</p>
</li>
<li><p>有时我们需要显示指定某些值的类型，可以使用 !（感叹号）显式指定类型。! 单叹号通常是自定义类型，!! 双叹号是内置类型</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !!str 指定为字符串</span></span><br><span class="line"><span class="attr">string.value:</span> <span class="type">!!str</span> <span class="string">HelloWorld!</span></span><br><span class="line"><span class="comment"># !!timestamp 指定为日期时间类型</span></span><br><span class="line"><span class="attr">datetime.value:</span> <span class="type">!!timestamp</span> <span class="number">2021-04-13T02:31:00+08:00</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内置的类型如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">!!int</span><span class="string">：整数类型</span></span><br><span class="line"><span class="type">!!float</span><span class="string">：浮点类型</span></span><br><span class="line"><span class="type">!!bool</span><span class="string">：布尔类型</span></span><br><span class="line"><span class="type">!!str</span><span class="string">：字符串类型</span></span><br><span class="line"><span class="type">!!binary</span><span class="string">：二进制类型</span></span><br><span class="line"><span class="type">!!timestamp</span><span class="string">：日期时间类型</span></span><br><span class="line"><span class="type">!!null</span><span class="string">：空值</span></span><br><span class="line"><span class="type">!!set</span><span class="string">：集合类型</span></span><br><span class="line"><span class="type">!!omap</span><span class="string">，!!pairs：键值列表或对象列表</span></span><br><span class="line"><span class="type">!!seq</span><span class="string">：序列</span></span><br><span class="line"><span class="type">!!map</span><span class="string">：散列表类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个 yaml 文件可以包含多个 yaml 文档，使用三个连字符—分隔</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">b:</span> </span><br><span class="line">	<span class="bullet">-</span> <span class="number">1</span></span><br><span class="line">	<span class="bullet">-</span> <span class="number">2</span></span><br><span class="line">	<span class="bullet">-</span> <span class="number">3</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">a:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">b:</span> </span><br><span class="line">	<span class="bullet">-</span> <span class="number">4</span></span><br><span class="line">	<span class="bullet">-</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure></li>
<li><p>这种情况在 K8S 和 SpringBoot 中非常常见。</p>
</li>
<li><p>比如 SpringBoot 在一个 application.yml 文件中，通过 — 分隔多个不同配置，根据 spring.profiles.active 的值来决定启用哪个配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公共配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span> <span class="comment">#使用名为 prod 的配置，这里可以切换成 dev。</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test_db?serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 开发环境配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span> <span class="comment">#profiles属性代表配置的名称。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 生产环境配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面以 YAML 表示一个简单的后台服务配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">UserProfileServer</span></span><br><span class="line"><span class="attr">maxconns:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">queuecap:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">queuetimeout:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">loginfo:</span></span><br><span class="line">  <span class="attr">loglevel:</span> <span class="string">ERROR</span></span><br><span class="line">  <span class="attr">logsize:</span> <span class="string">10M</span></span><br><span class="line">  <span class="attr">lognum:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">logpath:</span> <span class="string">/usr/local/app/log</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TOML"><a href="#TOML" class="headerlink" title="TOML"></a>TOML</h2><ul>
<li><p>GitHub 联合创始人 Tom Preston-Werner 觉得 YAML 不够简洁优雅，如缩进要严格对齐，因此和其他几位开发者一起捣鼓了一个 TOML（Tom’s Obvious Minimal Language）。TOML 旨在成为一个语义显著且易于阅读的极简配置文件格式，能够无歧义地转化为哈希表，且能够简单地解析成形形色色语言中的数据结构，用于取代 YAML 和 JSON</p>
</li>
<li><p>TOML 的基本语法规则如下：</p>
<ul>
<li>TOML 是大小写敏感的</li>
<li>TOML 文件必须是合法的 UTF-8 编码的 Unicode 文档</li>
<li>空白的意思是 Tab（0x09）或空格（0x20）</li>
<li>换行的意思是 LF（0x0A）或 CRLF（0x0D0A）</li>
<li>井号将此行剩下的部分标记为注释</li>
</ul>
</li>
</ul>
<h2 id="配置文件格式的选择"><a href="#配置文件格式的选择" class="headerlink" title="配置文件格式的选择"></a>配置文件格式的选择</h2><ul>
<li><p>面对常见配置文件格式，使用时该如何选择呢？这里给几个选择的原则：</p>
<ul>
<li>支持嵌套结构。仅仅支持 KV 结构的键值对表达能力有点弱；</li>
<li>支持注释。不支持注释的 JSON 是给机器读的，不是给人读的；</li>
<li>支持不同的数据类型，而不仅仅是 string。这一点，键值对和 XML 表现的非常逊色；</li>
<li>最好支持 include 其他配置文件，方便配置模块化。复杂的配置也是无奈之举，但如果支持 include 语法，可以方便的把配置文件模块化。</li>
</ul>
</li>
<li><p>通过以上几个对配置文件的要求，发现键值对不支持层级关系，JSON 不支持注释，可读性较差，虽然 XML 支持注释和层级结构，且可读性较好，但是因为起始标签一定要有个与之对应的结束标签，文件内容较大，解析时占用较多内存，传输时占用较多带宽。所以这里推荐使用 YAML 和 TOML，很多语言都有其 library 实现，跨语言不成问题</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>算法</li>
<li>算法研究的目的是为了更有效的处理数据，提高数据运算效率。数据的运算是定义在数据的逻辑结构上，但运算的具体实现要在存储结构上进行。</li>
</ul>
<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><ul>
<li>检索：检索就是在数据结构里查找满足一定条件的节点。一般是给定一个某字段的值，找具有该字段值的节点。</li>
<li>插入：往数据结构中增加新的节点。</li>
<li>删除：把指定的结点从数据结构中去掉。</li>
<li>更新：改变指定节点的一个或多个字段的值。</li>
<li>排序：把节点按某种指定的顺序重新排列。例如递增或递减。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-%E8%8A%B1%E7%94%9F%E5%A3%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-%E8%8A%B1%E7%94%9F%E5%A3%B3/" class="post-title-link" itemprop="url">花生壳</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------------------------+</span><br><span class="line">|             Oray PeanutHull Linux 5.2.0          |</span><br><span class="line">+--------------------------------------------------+</span><br><span class="line">|  SN: oray6c9e9e0c15a5   Default password: admin  |</span><br><span class="line">+--------------------------------------------------+</span><br><span class="line">|    Remote Management Address http://b.oray.com   |</span><br><span class="line">+--------------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>官网：<code>https://console.hsk.oray.com/forward</code></p>
</li>
<li><p>ssh 登录公司内网</p>
<ul>
<li>用户名： 公司内网的主机用户名</li>
<li>IP地址：花生壳外网ip地址</li>
<li>端口：花生壳创建端口映射产生的随机端口</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><code>ssh -p 25397 user@g321z68399.goho.co</code></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Windows/2024-05-22-windows_01_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Windows/2024-05-22-windows_01_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">windows_01_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文介绍了 Microsoft Visual C++ (MSVC) 编译器工具集的基本概念和使用方法，包括其主要组件、功能和安装方法。还介绍了 C++&#x2F;WinRT 和 C++&#x2F;CX 的基本概念和用途，以及在 Windows 下使用 VSCode、CMake 和 Msbuild 构建 C++ 程序的方法。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/Windows/2024-05-22-windows_01_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Xenomai/2024-05-22-xenomai_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Xenomai/2024-05-22-xenomai_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">xenomai_2_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Xenomai/" itemprop="url" rel="index"><span itemprop="name">Xenomai</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>xenomai常用函数或数据结构</li>
</ul>
<h2 id="RT-TASK"><a href="#RT-TASK" class="headerlink" title="RT_TASK"></a>RT_TASK</h2><p>在 Xenomai 中，RT_TASK 是用于创建和管理实时任务的关键数据结构。它提供了一种有效的方式来定义和控制实时任务的属性、优先级、状态和行为。下面是对 Xenomai 的 RT_TASK 结构的详细解释：</p>
<ol>
<li><p><strong>任务标识符（Task Identifier）</strong>：RT_TASK 结构包含一个唯一标识符，用于标识特定的实时任务。每个实时任务都有一个唯一的标识符，可以使用该标识符来引用和操作特定的任务。</p>
</li>
<li><p><strong>任务名称（Task Name）</strong>：RT_TASK 结构还包含一个任务名称字段，用于指定实时任务的名称。任务名称是可选的，但它可以帮助开发人员标识和调试任务。</p>
</li>
<li><p><strong>任务状态（Task State）</strong>：RT_TASK 结构维护了实时任务的当前状态。任务可以处于几种不同的状态，例如就绪状态（ready）、运行状态（running）、暂停状态（suspended）等。任务的状态可以通过 Xenomai 的 API 进行查询和修改。</p>
</li>
<li><p><strong>任务优先级（Task Priority）</strong>：每个实时任务都有一个指定的优先级，用于确定任务在调度时的相对重要性。较高优先级的任务将在较低优先级的任务之前得到调度。RT_TASK 结构中包含了任务的优先级字段。</p>
</li>
<li><p><strong>任务入口点（Task Entry Point）</strong>：RT_TASK 结构存储了实时任务的入口点，即任务要执行的函数或方法。开发人员可以将自定义的函数指定为任务的入口点，并在其中编写实时任务的逻辑。</p>
</li>
<li><p><strong>任务堆栈（Task Stack）</strong>：每个实时任务都需要一个用于执行函数调用和保存局部变量的堆栈空间。RT_TASK 结构中包含了任务堆栈的信息，包括堆栈的大小和指针。</p>
</li>
<li><p><strong>任务控制块（Task Control Block）</strong>：RT_TASK 结构还包含一个任务控制块指针，用于管理实时任务的内部状态和资源。任务控制块包含了任务的上下文信息，包括寄存器状态、调度参数等。</p>
</li>
</ol>
<p>通过使用 RT_TASK 结构，开发人员可以使用 Xenomai 的 API 创建和管理实时任务。可以使用 API 函数如 <code>rt_task_create()</code> 创建任务，并通过设置任务的属性、优先级和堆栈等来定义任务的行为。任务可以在需要时启动、暂停、恢复和终止。开发人员还可以使用 RT_TASK 结构中的字段来查询和修改任务的状态和属性。</p>
<p>总之，RT_TASK 结构在 Xenomai 中扮演着关键的角色，允许开发人员创建、配置和控制实时任务，并通过任务标识符进行引用和操作。这种结构提供了对实时任务的灵活</p>
<p>性和可控性，帮助开发人员构建高效、可预测的实时应用程序。</p>
<hr>
<h2 id="rt-print-auto-init"><a href="#rt-print-auto-init" class="headerlink" title="rt_print_auto_init"></a>rt_print_auto_init</h2><ul>
<li><p>简介：</p>
<ul>
<li>rt_print_auto_init() 是一个函数，用于初始化实时打印功能</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rt_print_auto_init</span><span class="params">(<span class="type">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mode：指定实时打印模式的选项。可以是以下值之一<ul>
<li>0：禁用实时打印功能。</li>
<li>1：启用实时打印功能</li>
</ul>
</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>rt_print_auto_init() 函数用于控制 Xenomai 的实时打印功能的初始化和启用</li>
<li>实时打印功能允许实时任务在运行时向终端或系统日志输出信息，用于调试和跟踪应用程序的运行</li>
<li>当 mode 参数设置为非零值时，实时打印功能将被启用，并且实时任务可以使用实时打印函数（如 rt_printf()）输出信息</li>
<li>当 mode 参数设置为零时，实时打印功能将被禁用，实时任务将无法使用实时打印函数输出信息</li>
<li>通常在应用程序初始化时调用 rt_print_auto_init() 函数，以便在后续的实时任务中使用实时打印功能</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用实时打印功能可能会对实时性能产生一定的影响。因此，在实时应用程序中使用实时打印功能时，应谨慎使用，避免过多的打印输出，以确保实时性能不受影响</li>
</ul>
</li>
</ul>
<hr>
<h2 id="rt-printf"><a href="#rt-printf" class="headerlink" title="rt_printf"></a>rt_printf</h2><ul>
<li><p>简介：</p>
<ul>
<li>rt_printf() 是一个函数，用于在实时任务中进行格式化的输出。它类似于标准库函数 printf()，但是 rt_printf() 是 Xenomai 提供的特定实时打印函数。下面是对 rt_printf()</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rt_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>format：一个字符串，指定输出的格式，类似于 printf() 函数中的格式字符串。</li>
<li>…：可变数量的参数，用于根据格式字符串进行格式化输出</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回实际输出的字符数（不包括终止符）</li>
<li>失败时，返回一个负值</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>rt_printf() 函数用于在实时任务中进行格式化的输出，方便进行调试和跟踪实时应用程序的执行</li>
<li>rt_printf() 函数与标准库函数 printf() 的使用方式相似，支持使用格式化字符串和可变数量的参数进行输出</li>
<li>在实时任务中调用 rt_printf() 函数会将输出信息发送到控制台或系统日志，具体输出位置取决于实时打印功能的配置</li>
<li>实时任务中使用 rt_printf() 函数进行输出时，需要确保已启用实时打印功能（通过调用 rt_print_auto_init() 函数）</li>
<li>与标准库函数 printf() 不同，rt_printf() 是一个实时安全的函数，可以在 Xenomai 实时任务的上下文中使用，而不会引起不可预测的行为或破坏实时性能</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用实时打印功能可能会对实时性能产生一定的影响。因此，在实时应用程序中使用 rt_printf() 函数时，应谨慎使用，并避免过多的打印输出，以确保实时性能不受明显的影响</li>
</ul>
</li>
</ul>
<hr>
<h2 id="rt-task-create"><a href="#rt-task-create" class="headerlink" title="rt_task_create"></a>rt_task_create</h2><ul>
<li><p>简介：</p>
<ul>
<li>rt_task_create() 是用于创建实时任务的函数。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rt_task_create</span><span class="params">(RT_TASK* task, <span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> stack_size, <span class="type">int</span> priority, <span class="type">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>task：指向 RT_TASK 结构的指针，用于存储创建的任务。</li>
<li>name：字符串，表示任务的名称。</li>
<li>stack_size：整数，表示任务堆栈的大小（以字节为单位）。</li>
<li>priority：整数，表示任务的优先级。</li>
<li>mode：整数，表示任务的标志。可以是以下值之一<ul>
<li>T_JOINABLE：指示任务可以被其他任务等待和回收资源。</li>
<li>T_FPU：指示任务需要使用浮点运算单元（FPU）</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回一个负数表示错误码</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>rt_task_create() 函数用于创建实时任务，创建的任务可以在 Xenomai 实时环境中执行</li>
<li>函数通过提供任务名称、堆栈大小、优先级和其他选项来定义任务的属性</li>
<li>创建任务后，可以使用 task 指针引用该任务，并使用其他 Xenomai API 函数对其进行操作，如启动、暂停、恢复、设置优先级等。</li>
<li>任务名称是可选的，但可以帮助开发人员标识和调试任务</li>
<li>堆栈大小决定了任务可以使用的内存空间</li>
<li>优先级决定了任务在调度时的相对重要性，较高优先级的任务将在较低优先级的任务之前得到调度</li>
<li>通过设置 mode 参数，可以指定任务的附加标志，如可等待和使用 FPU</li>
<li>创建任务时，需要确保已经初始化 Xenomai 实时环境</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，rt_task_create() 函数只是创建实时任务的一部分。创建任务后，还需要使用其他 Xenomai API 函数来启动任务并执行实际的任务逻辑</li>
</ul>
</li>
</ul>
<hr>
<h2 id="rt-task-start"><a href="#rt-task-start" class="headerlink" title="rt_task_start"></a>rt_task_start</h2><ul>
<li><p>简介：</p>
<ul>
<li>rt_task_start() 是用于启动实时任务的函数</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rt_task_start</span><span class="params">(RT_TASK* task, <span class="type">void</span> (*entry)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>task：指向 RT_TASK 结构的指针，表示要启动的任务。</li>
<li>entry：函数指针，指向实时任务的入口函数。</li>
<li>arg：指针，传递给实时任务入口函数的参数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回一个负数表示错误码</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>rt_task_start() 函数用于启动实时任务，使其开始执行实时任务的入口函数。</li>
<li>函数通过指定任务指针、入口函数和参数来定义任务的执行。</li>
<li>入口函数是实时任务的主要逻辑，当任务启动后，它将从入口函数开始执行。</li>
<li>入口函数可以是任何符合特定签名 void (<em>)(void</em>) 的函数指针，接受一个 void* 类型的参数。</li>
<li>通过 arg 参数，可以将参数传递给实时任务的入口函数。</li>
<li>启动任务后，它将在 Xenomai 实时环境中被调度和执行</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，启动任务前，必须先使用 rt_task_create() 函数创建任务，并确保已经初始化 Xenomai 实时环境。在任务执行期间，可以使用其他 Xenomai API 函数来控制任务的行为，如暂停、恢复、设置优先级等</li>
</ul>
</li>
</ul>
<hr>
<h2 id="rt-task-delete"><a href="#rt-task-delete" class="headerlink" title="rt_task_delete"></a>rt_task_delete</h2><ul>
<li><p>简介：</p>
<ul>
<li>rt_task_delete() 是用于删除实时任务的函数</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rt_task_delete</span><span class="params">(RT_TASK* task)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>task：指向要删除的实时任务的 RT_TASK 结构的指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回一个负数表示错误码</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>rt_task_delete() 函数用于删除实时任务，并释放与该任务相关的资源。</li>
<li>在删除任务之前，应确保该任务已经被停止，即不再处于活动状态。</li>
<li>删除任务会释放任务所使用的堆栈内存和其他资源，使其可供其他任务使用。</li>
<li>删除任务后，与该任务关联的 RT_TASK 结构不再有效，不应再使用指向它的指针</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，删除任务可能会对其他正在使用该任务的代码产生影响，因此在删除任务之前，应确保不再有其他代码依赖该任务或与其进行通信。同时，为了避免资源泄漏，应确保在任务完成后及时删除不再需要的任务。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Video/2024-05-22-video_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Video/2024-05-22-video_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">video_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Video/" itemprop="url" rel="index"><span itemprop="name">Video</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>音视频开发相关的理论基础</li>
</ul>
<h2 id="h264-SVC-是什么"><a href="#h264-SVC-是什么" class="headerlink" title="h264 SVC 是什么"></a>h264 SVC 是什么</h2><p>H.264 SVC (Scalable Video Coding) 是一种视频编码标准，用于实现可扩展的视频压缩和传输。SVC 允许将视频编码为多个不同层次的数据流，这些数据流可以根据接收端的带宽和处理能力进行动态选择和组合。这使得 SVC 在网络传输和多设备适配性方面具有优势。</p>
<p>H.264 SVC 的主要特点和优势包括：</p>
<ol>
<li><p>可扩展性：SVC 允许将视频分成多个不同的层次，每个层次代表不同的质量级别或分辨率。这使得视频能够根据网络带宽和设备能力进行适应性传输和播放。</p>
</li>
<li><p>容错性：SVC 提供了冗余编码，即使在丢失部分数据的情况下，接收端仍然可以从其他层次中恢复并播放视频。</p>
</li>
<li><p>压缩效率：H.264 SVC 使用先进的压缩技术，能够在相同的比特率下提供更好的视频质量。</p>
</li>
<li><p>广泛支持：H.264 SVC 是一种广泛支持的视频编码标准，它被广泛应用于实时视频通信、视频会议、流媒体传输等领域。</p>
</li>
</ol>
<p>通过使用 H.264 SVC，视频可以根据不同的需求和网络条件进行适应性传输，以提供更好的用户体验和更高的压缩效率。</p>
<h2 id="h264-SVC-详解"><a href="#h264-SVC-详解" class="headerlink" title="h264 SVC 详解"></a>h264 SVC 详解</h2><p>H.264 SVC (Scalable Video Coding) 是一种视频编码标准，用于实现可扩展的视频压缩和传输。SVC 允许将视频编码为多个不同层次的数据流，这些数据流可以根据接收端的带宽和处理能力进行动态选择和组合。以下是对 H.264 SVC 的详细解释：</p>
<ol>
<li><p>可扩展性：H.264 SVC 允许将视频分成多个层次，每个层次代表不同的质量级别或分辨率。这些层次之间存在依赖关系，较高层次的数据可以通过添加较低层次的数据进行解码和恢复。这样，在网络传输过程中，根据接收端的带宽和处理能力，可以动态地选择和组合合适的层次，从而实现适应性的视频传输。</p>
</li>
<li><p>码率和质量控制：H.264 SVC 允许在不同的层次上设置不同的码率和质量，从而提供更高的灵活性和控制能力。通过调整每个层次的编码参数，可以根据应用需求进行码率和质量的平衡。</p>
</li>
<li><p>容错性：H.264 SVC 提供了冗余编码和依赖性传输，即使在部分数据丢失的情况下，接收端仍然可以从其他层次中恢复和播放视频。这提高了视频传输的容错性，减少了对网络丢包和错误的敏感性。</p>
</li>
<li><p>广泛支持：H.264 SVC 是一种广泛支持的视频编码标准，被广泛应用于实时视频通信、视频会议、流媒体传输等领域。它具有良好的兼容性，可以在各种设备和平台上进行解码和播放。</p>
</li>
<li><p>动态适应性：H.264 SVC 具有动态适应性的能力，可以根据网络条件的变化和接收端的能力进行实时调整。这使得视频传输可以在不同的网络环境下实现最佳性能和用户体验。</p>
</li>
</ol>
<p>通过使用 H.264 SVC，视频可以根据不同的需求和网络条件进行适应性传输，以提供更好的用户体验和更高的压缩效率。它是一种重要的视频编码技术，被广泛应用于实时视频通信和流媒体领域。</p>
<h2 id="h264-MVC-是什么"><a href="#h264-MVC-是什么" class="headerlink" title="h264 MVC 是什么"></a>h264 MVC 是什么</h2><p>H.264 MVC (Multiview Video Coding) 是一种视频编码标准，用于压缩和传输多视点（Multiview）视频数据。多视点视频是指从不同角度或位置拍摄的视频，例如立体3D视频或全景视频。H.264 MVC 通过压缩和编码多个视点的视频数据，以便在播放时实现多视点的呈现。</p>
<p>H.264 MVC 的主要特点和优势包括：</p>
<ol>
<li><p>多视点支持：H.264 MVC 支持压缩和传输多个视点的视频数据，这样观看者可以在播放时选择不同的视点或角度进行观看，从而提供更丰富的视觉体验。</p>
</li>
<li><p>视频压缩效率：H.264 MVC 使用先进的视频编码技术，如运动估计、帧间预测和熵编码，以提供高效的视频压缩。这使得多视点视频可以在有限的带宽和存储条件下传输和存储。</p>
</li>
<li><p>兼容性：H.264 MVC 是一种广泛支持的视频编码标准，可以在各种设备和平台上进行解码和播放。它在3D电视、虚拟现实（VR）和增强现实（AR）应用中得到广泛应用。</p>
</li>
</ol>
<p>通过使用 H.264 MVC，多视点视频可以以高效的方式进行编码和传输，为观众提供沉浸式的视觉体验。同时，H.264 MVC 也能够在现有的H.264解码器上进行向后兼容，这使得它成为多视点视频传输的一种常用编码标准。</p>
<h2 id="h264-MVC-详解"><a href="#h264-MVC-详解" class="headerlink" title="h264 MVC 详解"></a>h264 MVC 详解</h2><p>H.264 MVC (Multiview Video Coding) 是一种视频编码标准，用于压缩和传输多视点（Multiview）视频数据。多视点视频是指从不同角度或位置拍摄的视频，例如立体3D视频或全景视频。以下是对 H.264 MVC 的详细解释：</p>
<ol>
<li><p>多视点支持：H.264 MVC 可以对多个视点的视频数据进行压缩和编码。这使得观众可以在播放时选择不同的视点或角度进行观看，从而提供更丰富和沉浸式的视觉体验。每个视点的视频数据都被编码为一个独立的视点流。</p>
</li>
<li><p>视频压缩效率：H.264 MVC 使用先进的视频压缩技术，如运动估计、帧间预测和熵编码，以提供高效的视频压缩。这使得多视点视频可以在有限的带宽和存储条件下进行传输和存储。共享的编码信息可以在不同视点之间进行利用，从而提高压缩效率。</p>
</li>
<li><p>兼容性：H.264 MVC 是一种广泛支持的视频编码标准，可以在各种设备和平台上进行解码和播放。它被广泛应用于3D电视、虚拟现实（VR）、增强现实（AR）和全景视频等应用中。现有的H.264解码器可以通过解码共享的编码信息来解码多视点视频。</p>
</li>
<li><p>时空预测：H.264 MVC 还引入了时空预测的概念，以更好地利用多视点视频中的视点间和帧间的相关性。通过预测和编码视点间的运动以及时间上的相关性，可以进一步提高压缩效率。</p>
</li>
</ol>
<p>通过使用 H.264 MVC，多视点视频可以以高效的方式进行编码和传输，为观众提供沉浸式的视觉体验。H.264 MVC 的广泛支持和兼容性使得它成为多视点视频传输的一种常用编码标准。它在3D电视、虚拟现实（VR）、增强现实（AR）和全景视频等应用中发挥重要作用。</p>
<h2 id="h264-nalu-是什么"><a href="#h264-nalu-是什么" class="headerlink" title="h264 nalu 是什么"></a>h264 nalu 是什么</h2><p>H.264 NALU (Network Abstraction Layer Unit) 是 H.264 视频编码标准中的网络抽象层单元。NALU 是在 H.264 编码器中生成的基本数据单元，用于传输和解码视频。</p>
<p>在 H.264 编码过程中，视频帧被分割成一个个小的 NALU。每个 NALU 是一个独立的视频数据单元，包含了视频编码中的相关信息和数据。NALU 提供了对视频帧进行有效封装、传输和解码所需的单元结构。</p>
<p>每个 NALU 由以下几个部分组成：</p>
<ol>
<li><p>NALU 头（NALU Header）：NALU 头包含了 NALU 的类型信息和一些额外的元数据。它指示了该 NALU 的类型（例如关键帧、预测帧等）以及其重要性和优先级。</p>
</li>
<li><p>NALU 负载（NALU Payload）：NALU 负载是实际的视频数据，包含了经过压缩编码的视频帧或视频片段。它是解码器用来恢复原始图像或帧的数据。</p>
</li>
</ol>
<p>在视频传输中，NALU 被封装在特定的传输协议中，例如 RTP (Real-time Transport Protocol) 或 MP4 (MPEG-4 Part 14) 容器格式。这些传输协议负责将视频数据和相关的 NALU 传送到接收端进行解码和播放。</p>
<p>总之，H.264 NALU 是 H.264 视频编码标准中的网络抽象层单元，用于封装、传输和解码视频数据。它提供了对视频帧的有效管理和传输，并为视频编解码器和传输协议之间提供了一个统一的接口。</p>
<h2 id="h264-nalu-详解"><a href="#h264-nalu-详解" class="headerlink" title="h264 nalu 详解"></a>h264 nalu 详解</h2><p>H.264 NALU (Network Abstraction Layer Unit) 是 H.264 视频编码标准中的网络抽象层单元，用于封装和传输视频数据。以下是对 H.264 NALU 的详细解释：</p>
<ol>
<li><p>视频数据单元：H.264 NALU 是视频数据的基本单元。在 H.264 编码过程中，视频帧被分割成一个个小的 NALU。每个 NALU 是一个独立的视频数据单元，包含了经过压缩编码的视频帧或视频片段。</p>
</li>
<li><p>NALU 头：每个 NALU 都包含一个 NALU 头，其中包含了关于该 NALU 的重要信息。NALU 头中的字段指示了该 NALU 的类型、重要性和优先级。常见的 NALU 类型包括关键帧（I帧）、预测帧（P帧）、参考帧（B帧）等。</p>
</li>
<li><p>NALU 负载：NALU 负载是实际的视频数据，其中包含经过压缩编码的图像数据或视频片段。NALU 负载是解码器用来恢复原始图像或帧的数据。</p>
</li>
<li><p>NALU 之间的依赖关系：在 H.264 中，NALU 之间存在着依赖关系。例如，预测帧的解码可能需要参考之前的关键帧或其他预测帧。解码器根据 NALU 头中的信息来管理和解决这些依赖关系，以正确地重建和播放视频帧。</p>
</li>
<li><p>封装和传输：NALU 被封装在特定的传输协议中，以便在网络上进行传输。常见的传输协议包括 RTP (Real-time Transport Protocol)、MP4 (MPEG-4 Part 14) 容器格式等。这些传输协议负责将视频数据和相关的 NALU 传送到接收端进行解码和播放。</p>
</li>
</ol>
<p>通过使用 H.264 NALU，视频数据可以以适当的格式进行封装和传输，以便在接收端进行解码和播放。NALU 提供了对视频帧的有效管理和传输，并为视频编解码器和传输协议之间提供了一个统一的接口。</p>
<h2 id="h264-nalu-sps-是什么"><a href="#h264-nalu-sps-是什么" class="headerlink" title="h264 nalu sps 是什么"></a>h264 nalu sps 是什么</h2><p>H.264 NALU (Network Abstraction Layer Unit) SPS (Sequence Parameter Set) 是 H.264 视频编码标准中的一个特殊类型的 NALU，用于传输视频序列参数集。</p>
<p>SPS 是一种包含有关视频编码器设置和配置信息的数据结构，它描述了视频序列的属性，例如分辨率、帧率、图像参数等。SPS 通常包含在视频流的开始部分，以便接收端能够正确解码和播放视频。</p>
<p>在 H.264 中，SPS 是必需的，它提供了视频编码的关键参数，例如画面大小、帧率、图像结构、颜色空间等。SPS 为解码器提供了有关如何解码和呈现视频的重要信息。</p>
<p>SPS 在编码过程中只需发送一次，通常作为视频流的元数据一起传输。接收端在解码视频之前，首先解析 SPS 中的参数，然后使用这些参数来配置解码器，以确保正确解码和播放视频。</p>
<p>在 H.264 NALU 中，SPS 以特殊的 NALU 类型进行标识。例如，对于 SPS，其 NALU 类型（NAL unit type）为 7，标识为“Sequence Parameter Set”。</p>
<p>总之，H.264 NALU SPS 是用于传输视频序列参数集的一种特殊类型的 NALU。它包含视频编码器的关键设置和配置信息，描述了视频序列的属性。SPS 通过在视频流中传输，为接收端提供解码和播放视频所需的重要参数。</p>
<h2 id="h264-nalu-sps详解"><a href="#h264-nalu-sps详解" class="headerlink" title="h264 nalu sps详解"></a>h264 nalu sps详解</h2><p>H.264 NALU (Network Abstraction Layer Unit) SPS (Sequence Parameter Set) 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于传输视频序列参数集。</p>
<p>SPS 是一种包含有关视频编码器设置和配置信息的数据结构，它描述了视频序列的属性，例如分辨率、帧率、图像参数等。SPS 提供了解码器所需的重要参数，以正确解码和播放视频。</p>
<p>以下是对 H.264 NALU SPS 的详细解释：</p>
<ol>
<li><p>视频序列参数集：SPS 是一个具有固定格式的数据结构，包含了视频编码器的关键设置和配置信息。它描述了整个视频序列的属性，如画面大小、帧率、图像结构、颜色空间、采样精度等。</p>
</li>
<li><p>唯一性和共享性：每个视频序列只有一个对应的 SPS，它通常在视频流的开始部分作为元数据传输。所有的图像帧共享同一个 SPS，因为视频序列参数在一个视频序列中是不变的。</p>
</li>
<li><p>NALU 格式：SPS 作为 NALU 的一种特殊类型进行传输。它包含 NALU 头和负载数据。NALU 头指示了该 NALU 的类型，而负载数据部分包含了实际的 SPS 数据。</p>
</li>
<li><p>解码器配置：在接收端，解码器首先解析 SPS 中的参数，然后使用这些参数来配置解码器，以确保正确解码和呈现视频。SPS 提供了解码所需的信息，使解码器能够正确解析视频数据。</p>
</li>
<li><p>扩展性：SPS 还支持一些可选的扩展参数，例如 VUI (Video Usability Information) 参数，用于提供额外的图像和显示设置。</p>
</li>
</ol>
<p>总之，H.264 NALU SPS 是用于传输视频序列参数集的一种特殊类型的 NALU。它包含视频编码器的关键设置和配置信息，描述了整个视频序列的属性。SPS 在视频流的开始部分作为元数据进行传输，为解码器提供了解码和播放视频所需的重要参数。</p>
<h2 id="h264-nalu-sub-sps-是什么"><a href="#h264-nalu-sub-sps-是什么" class="headerlink" title="h264 nalu sub sps 是什么"></a>h264 nalu sub sps 是什么</h2><p>H.264 NALU (Network Abstraction Layer Unit) Sub SPS (Subset Sequence Parameter Set) 是 H.264 视频编码标准中的一个特殊类型的 NALU，用于传输视频序列参数集的子集。</p>
<p>SPS 是一种包含有关视频编码器设置和配置信息的数据结构，它描述了视频序列的属性，例如分辨率、帧率、图像参数等。SPS 通常包含在视频流的开始部分，以便接收端能够正确解码和播放视频。</p>
<p>在某些情况下，为了减少传输带宽或方便视频的处理和传输，H.264 规范引入了 Sub SPS 的概念。Sub SPS 是一个 SPS 的子集，它只包含 SPS 中的一部分参数，通常是与视频序列不变的参数。</p>
<p>通过使用 Sub SPS，视频编码器可以将部分固定的序列参数传输为一个 Sub SPS，然后在之后的视频流中只需传输 Sub SPS，而不需要重复传输完整的 SPS。这样可以减少传输开销和网络带宽消耗。</p>
<p>在 H.264 NALU 中，Sub SPS 以特殊的 NALU 类型进行标识。例如，对于 Sub SPS，其 NALU 类型（NAL unit type）为 15，标识为“Supplemental Enhancement Information (SEI) - Sub SPS”。</p>
<p>总之，H.264 NALU Sub SPS 是用于传输视频序列参数集的子集的一种特殊类型的 NALU。它允许视频编码器将部分固定的序列参数作为子集传输，以减少传输开销和网络带宽消耗。接收端可以根据 Sub SPS 了解视频序列的属性和配置信息，以正确解码和播放视频。</p>
<h2 id="h264-nalu-sub-sps-详解"><a href="#h264-nalu-sub-sps-详解" class="headerlink" title="h264 nalu sub sps 详解"></a>h264 nalu sub sps 详解</h2><p>H.264 NALU (Network Abstraction Layer Unit) Sub SPS (Subset Sequence Parameter Set) 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于传输视频序列参数集的子集。</p>
<p>Sub SPS 是从完整的 SPS 中提取的一部分参数，它包含了视频序列的部分设置和配置信息。Sub SPS 的存在是为了减少传输开销和网络带宽消耗，同时仍然能够提供必要的参数以支持解码和播放视频。</p>
<p>以下是对 H.264 NALU Sub SPS 的详细解释：</p>
<ol>
<li><p>参数子集：Sub SPS 是完整 SPS 的一个子集，只包含其中一部分参数，通常是与视频序列属性变化较小的参数。这些参数通常是视频序列中相对稳定的设置，如图像大小、帧率等。</p>
</li>
<li><p>减少传输开销：通过将部分固定的序列参数提取为 Sub SPS，并在传输过程中只发送 Sub SPS，可以减少传输的数据量和网络带宽消耗。这对于实时视频传输和低带宽环境下的视频传输非常有益。</p>
</li>
<li><p>编码器和解码器协作：发送端的视频编码器根据视频序列的特性和需求，决定哪些参数应该包含在 Sub SPS 中。接收端的解码器会根据接收到的 Sub SPS 进行配置和解码，以确保正确解析和播放视频。</p>
</li>
<li><p>Sub SPS 的 NALU 格式：Sub SPS 作为 NALU 的一种特殊类型进行传输，具有特定的 NALU 头和负载数据格式。NALU 头指示了该 NALU 的类型，而负载数据部分包含了实际的 Sub SPS 数据。</p>
</li>
</ol>
<p>总之，H.264 NALU Sub SPS 是用于传输视频序列参数集的子集的一种特殊类型的 NALU。通过提取视频序列中相对稳定的参数，Sub SPS 可以减少传输开销和网络带宽消耗。接收端的解码器使用 Sub SPS 进行配置和解码，以正确解析和播放视频。这在实时视频传输和低带宽环境下特别有用。</p>
<h2 id="h264-nalu-PPS-是什么"><a href="#h264-nalu-PPS-是什么" class="headerlink" title="h264 nalu PPS 是什么"></a>h264 nalu PPS 是什么</h2><p>H.264 NALU (Network Abstraction Layer Unit) PPS (Picture Parameter Set) 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于传输图像参数集。</p>
<p>PPS 是一个数据结构，包含了与图像编码有关的参数，如图像类型、参考帧索引、编码模式等。PPS 提供了解码器在解码图像时所需的图像参数信息。</p>
<p>以下是对 H.264 NALU PPS 的详细解释：</p>
<ol>
<li><p>图像参数集：PPS 是一个包含有关图像编码参数的数据结构。它描述了视频图像的属性和配置信息，如参考帧的选择、图像类型（I帧、P帧、B帧等）、编码模式、片组结构等。</p>
</li>
<li><p>唯一性和共享性：每个图像序列都有一个对应的 PPS，它通常在视频流的开始部分作为元数据传输。每个图像帧都与一个 PPS 关联，以提供解码所需的图像参数。</p>
</li>
<li><p>NALU 格式：PPS 以特殊的 NALU 类型进行传输。例如，对于 PPS，其 NALU 类型（NAL unit type）为 8，标识为“Picture Parameter Set”。</p>
</li>
<li><p>解码器配置：接收端的解码器使用接收到的 PPS 进行配置和解码。PPS 提供了解码图像所需的参数，使解码器能够正确解析和还原图像。</p>
</li>
<li><p>与 SPS 的关系：PPS 通常与 SPS（Sequence Parameter Set）一起传输，以提供完整的编码参数信息。SPS 包含视频序列的全局参数，而 PPS 包含特定图像帧的参数。</p>
</li>
</ol>
<p>总之，H.264 NALU PPS 是用于传输图像参数集的一种特殊类型的 NALU。它包含图像编码的关键参数，描述了图像的属性和配置信息。PPS 通过在视频流中传输，为接收端提供解码和还原图像所需的参数。PPS 与 SPS 一起提供完整的编码参数信息。</p>
<h2 id="h264-nalu-PPS-详解"><a href="#h264-nalu-PPS-详解" class="headerlink" title="h264 nalu PPS 详解"></a>h264 nalu PPS 详解</h2><p>H.264 NALU (Network Abstraction Layer Unit) PPS (Picture Parameter Set) 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于传输图像参数集。</p>
<p>以下是对 H.264 NALU PPS 的详细解释：</p>
<ol>
<li><p>图像参数集：PPS 是一个包含有关图像编码参数的数据结构，它描述了视频图像的属性和配置信息。PPS 提供了解码器在解码图像时所需的图像参数，如图像类型、参考帧索引、编码模式等。</p>
</li>
<li><p>独立性和共享性：每个图像序列都有一个对应的 PPS，它包含了该序列中所有图像帧共享的编码参数。PPS 在视频流中以 NALU 的形式进行传输，通常作为元数据的一部分。每个图像帧都与一个 PPS 关联，以提供解码所需的图像参数。</p>
</li>
<li><p>NALU 格式：PPS 作为 NALU 的一种特殊类型进行传输，具有特定的 NALU 头和负载数据格式。NALU 头指示了该 NALU 的类型，而负载数据部分包含了实际的 PPS 数据。</p>
</li>
<li><p>解码器配置：接收端的解码器使用接收到的 PPS 进行配置和解码。PPS 提供了解码图像所需的参数，使解码器能够正确解析和还原图像。解码器根据 PPS 中的参数设置图像的类型、参考帧索引、解码模式等，以正确解码和播放图像。</p>
</li>
<li><p>与 SPS 的关系：PPS 通常与 SPS（Sequence Parameter Set）一起传输，以提供完整的编码参数信息。SPS 包含视频序列的全局参数，而 PPS 包含特定图像帧的参数。SPS 提供视频序列的基本属性和配置，而 PPS 提供每个图像帧的特定参数。</p>
</li>
</ol>
<p>总之，H.264 NALU PPS 是用于传输图像参数集的一种特殊类型的 NALU。它包含图像编码的关键参数，描述了图像的属性和配置信息。PPS 通过在视频流中传输，为接收端提供解码和还原图像所需的参数。PPS 与 SPS 一起提供完整的编码参数信息，确保解码器能够正确解码和播放视频。</p>
<h2 id="h264-nalu-idr-是什么"><a href="#h264-nalu-idr-是什么" class="headerlink" title="h264 nalu idr 是什么"></a>h264 nalu idr 是什么</h2><p>H.264 NALU (Network Abstraction Layer Unit) IDR (Instantaneous Decoder Refresh) 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于实现即时解码器刷新。</p>
<p>以下是对 H.264 NALU IDR 的详细解释：</p>
<ol>
<li><p>解码器刷新：IDR 帧是一种关键帧（I帧），在视频序列中起到重要的作用。它是完整的、独立的图像帧，不依赖于其他图像帧进行解码。IDR 帧通常用作参考帧的起点，可以在接收端进行解码和播放。</p>
</li>
<li><p>关键帧：IDR 帧是视频序列中的关键帧，也称为自刷新帧。关键帧是编码序列中的重要帧，它提供了解码视频所需的完整图像信息。IDR 帧之后的预测帧（P帧）和双向预测帧（B帧）依赖于前面的关键帧或预测帧进行解码。</p>
</li>
<li><p>NALU 类型：IDR 帧以特殊的 NALU 类型进行标识。例如，对于 IDR 帧，其 NALU 类型（NAL unit type）为 5，标识为“Coded Slice of an IDR Picture”。</p>
</li>
<li><p>解码器刷新作用：IDR 帧的出现会导致解码器进行刷新，清除之前解码的参考图像和缓存，确保在 IDR 帧之后的解码正确性。IDR 帧的出现可以用于视频随机访问、错误恢复等应用场景。</p>
</li>
</ol>
<p>总之，H.264 NALU IDR 是一种特殊类型的 NALU，用于实现即时解码器刷新。IDR 帧是关键帧，在视频序列中起到重要的作用，提供了完整的图像信息。IDR 帧的出现导致解码器刷新，确保在 IDR 帧之后的解码正确性。</p>
<h2 id="h264-nalu-idr-详解"><a href="#h264-nalu-idr-详解" class="headerlink" title="h264 nalu idr 详解"></a>h264 nalu idr 详解</h2><p>H.264 NALU (Network Abstraction Layer Unit) IDR (Instantaneous Decoder Refresh) 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于实现即时解码器刷新。</p>
<p>以下是对 H.264 NALU IDR 的详细解释：</p>
<ol>
<li><p>解码器刷新：IDR 帧是一种关键帧（I帧），在视频序列中起到重要的作用。关键帧是完整的、独立的图像帧，不依赖于其他图像帧进行解码。IDR 帧通常用作解码器进行刷新的标志，以确保解码器处于正确的状态。</p>
</li>
<li><p>关键帧：IDR 帧是视频序列中的关键帧，也称为自刷新帧。关键帧是编码序列中的重要帧，它提供了解码视频所需的完整图像信息。在 IDR 帧之后的预测帧（P帧）和双向预测帧（B帧）依赖于前面的关键帧或预测帧进行解码。</p>
</li>
<li><p>NALU 类型：IDR 帧以特殊的 NALU 类型进行标识。在 H.264 中，其 NALU 类型（NAL unit type）为 5，标识为“Coded Slice of an IDR Picture”。这个特殊的 NALU 类型用于表示 IDR 帧。</p>
</li>
<li><p>解码器刷新作用：IDR 帧的出现会导致解码器进行刷新，清除之前解码的参考图像和缓存。这样可以确保在 IDR 帧之后的解码过程中不会受到之前图像的干扰，从而保证解码的正确性。IDR 帧的出现也可以用于视频随机访问、错误恢复等应用场景。</p>
</li>
</ol>
<p>总之，H.264 NALU IDR 是一种特殊类型的 NALU，用于实现即时解码器刷新。IDR 帧是关键帧，提供了完整的图像信息，不依赖于其他图像进行解码。IDR 帧的出现导致解码器进行刷新，确保解码的正确性，并用于视频随机访问和错误恢复等应用。</p>
<h2 id="h264-nalu-slice-是什么"><a href="#h264-nalu-slice-是什么" class="headerlink" title="h264 nalu slice 是什么"></a>h264 nalu slice 是什么</h2><p>H.264 NALU (Network Abstraction Layer Unit) Slice 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于传输图像帧的切片数据。</p>
<p>以下是对 H.264 NALU Slice 的详细解释：</p>
<ol>
<li><p>图像帧切片：在 H.264 视频编码中，图像帧被分割成一个个小的切片进行编码。切片是图像帧的分割单元，允许并行处理和传输视频数据。每个切片是一个独立的编码单元，包含了经过压缩编码的图像数据。</p>
</li>
<li><p>NALU 类型：Slice NALU 用于传输图像帧的切片数据。在 H.264 中，Slice NALU 的类型由 NAL unit type 字段指示，它表示图像切片的编码类型和特性。</p>
</li>
<li><p>切片类型：Slice NALU 包含了关于图像切片的重要信息，如切片类型、参考帧索引、宏块编码模式、运动矢量等。切片类型包括预测切片（P切片）、参考切片（B切片）和关键切片（I切片），用于描述图像切片的编码方式和参考帧的使用。</p>
</li>
<li><p>传输和解码：Slice NALU 被封装在特定的传输协议中，以便在网络上进行传输。接收端的解码器根据接收到的 Slice NALU 进行解码，以恢复原始的图像切片。解码器根据切片的类型和相关参数进行解码和重建图像。</p>
</li>
</ol>
<p>总之，H.264 NALU Slice 是一种特殊类型的 NALU，用于传输图像帧的切片数据。切片允许并行处理和传输视频数据，每个切片是一个独立的编码单元。Slice NALU 包含了关于图像切片的重要信息，如切片类型、参考帧索引等。解码器根据接收到的 Slice NALU 进行解码和重建图像切片。</p>
<h2 id="h264-nalu-slice-详解"><a href="#h264-nalu-slice-详解" class="headerlink" title="h264 nalu slice 详解"></a>h264 nalu slice 详解</h2><p>H.264 NALU (Network Abstraction Layer Unit) Slice 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于传输图像帧的切片数据。</p>
<p>以下是对 H.264 NALU Slice 的详细解释：</p>
<ol>
<li><p>图像帧切片：在 H.264 视频编码中，图像帧被分割成一个个小的切片进行编码和传输。切片是图像帧的分割单元，可以独立地进行编码和解码，实现并行处理和传输。每个切片是一个独立的编码单元，包含了经过压缩编码的图像数据。</p>
</li>
<li><p>NALU 类型：Slice NALU 是用于传输图像帧切片数据的一种特殊类型的 NALU。在 H.264 中，Slice NALU 的类型由 NAL unit type 字段指示，用于标识切片的编码类型和特性。不同的切片类型包括预测切片（P切片）、参考切片（B切片）和关键切片（I切片）。</p>
</li>
<li><p>切片头：Slice NALU 包含了切片头部信息，用于描述切片的属性和配置。切片头包含了切片类型、参考帧索引、宏块编码模式、运动矢量等参数，这些参数对于解码器恢复图像切片是必要的。</p>
</li>
<li><p>传输和解码：Slice NALU 被封装在特定的传输协议中进行传输，以便在网络上进行传输和接收。接收端的解码器根据接收到的 Slice NALU 进行解码和重建图像切片。解码器使用切片的类型和相关参数进行解码和重建图像，以还原原始图像。</p>
</li>
<li><p>依赖关系：切片之间存在依赖关系，前面的切片可能会被后续切片参考和利用进行解码和重建。解码器根据切片头中的参考帧索引和运动矢量等信息，获取参考图像数据以进行解码。</p>
</li>
</ol>
<p>总之，H.264 NALU Slice 是一种特殊类型的 NALU，用于传输图像帧的切片数据。切片是图像帧的分割单元，可以独立地进行编码和解码。Slice NALU 包含了切片的头部信息，描述了切片的属性和配置。解码器根据接收到的 Slice NALU 进行解码和重建图像切片，并根据切片之间的依赖关系进行参考图像的获取和利用。</p>
<h2 id="h264-nalu-sei-是什么"><a href="#h264-nalu-sei-是什么" class="headerlink" title="h264 nalu sei 是什么"></a>h264 nalu sei 是什么</h2><p>H.264 NALU (Network Abstraction Layer Unit) SEI (Supplemental Enhancement Information) 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于传输补充增强信息。</p>
<p>以下是对 H.264 NALU SEI 的详细解释：</p>
<ol>
<li><p>补充增强信息：SEI 是用于传输视频编码过程中的额外信息的一种机制。它可以包含一系列补充的元数据，如图像标签、时间戳、颜色空间信息、场景分析数据等。SEI 提供了一种向视频数据中注入附加信息的方式。</p>
</li>
<li><p>NALU 类型：SEI NALU 是用于传输补充增强信息的一种特殊类型的 NALU。在 H.264 中，SEI NALU 的类型由 NAL unit type 字段指示，用于标识该 NALU 中包含的补充增强信息。</p>
</li>
<li><p>可选性和灵活性：SEI 是可选的，视频编码器可以选择是否在每个图像帧中包含 SEI NALU。它提供了一种灵活的方式，使编码器能够向视频数据中添加自定义的元数据或其他辅助信息。</p>
</li>
<li><p>应用场景：SEI 用于广泛的应用场景，如视频压缩的参数设置、颜色空间的指定、字幕和水印的嵌入、视频质量调整和增强等。它提供了一种在视频编码和传输过程中携带额外信息的标准化机制。</p>
</li>
<li><p>解析和处理：接收端的解码器在解码过程中可以解析和处理 SEI NALU，以获取其中包含的补充增强信息。这样可以实现对视频数据的附加信息的解析和处理，例如显示字幕、处理附加的场景分析数据等。</p>
</li>
</ol>
<p>总之，H.264 NALU SEI 是一种特殊类型的 NALU，用于传输补充增强信息。SEI 提供了一种向视频数据中注入附加信息的方式，可以包含各种元数据和辅助信息。SEI NALU 在视频编码和传输中具有可选性和灵活性，并用于多种应用场景。解码器可以解析和处理 SEI NALU，以实现对视频数据附加信息的解析和处理。</p>
<h2 id="h264-nalu-sei-详解"><a href="#h264-nalu-sei-详解" class="headerlink" title="h264 nalu sei 详解"></a>h264 nalu sei 详解</h2><p>H.264 NALU (Network Abstraction Layer Unit) SEI (Supplemental Enhancement Information) 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于传输补充增强信息。</p>
<p>以下是对 H.264 NALU SEI 的详细解释：</p>
<ol>
<li><p>补充增强信息：SEI 是一种机制，用于在视频编码过程中传输额外的元数据和增强信息。SEI 可以包含各种补充的信息，如图像标签、时间戳、颜色空间信息、场景分析数据、字幕、水印等。这些信息可以提供视频数据的附加描述、辅助信息或应用特定的元数据。</p>
</li>
<li><p>NALU 类型：SEI NALU 是一种特殊类型的 NALU，用于传输补充增强信息。在 H.264 中，SEI NALU 的类型由 NAL unit type 字段指示，用于标识该 NALU 中包含的补充增强信息。SEI NALU 与其他类型的 NALU（如图像切片、序列参数集等）一起组成视频编码的数据流。</p>
</li>
<li><p>可选性和灵活性：SEI 是可选的，视频编码器可以选择是否在每个图像帧中包含 SEI NALU。这使得编码器具有灵活性，可以根据应用的需要选择性地添加自定义的元数据或其他辅助信息。</p>
</li>
<li><p>应用场景：SEI 可用于多种应用场景。例如，它可以用于指定视频的颜色空间信息，支持字幕和水印的嵌入，提供场景分析数据以供后续处理使用，以及进行视频质量调整和增强等。SEI 提供了一种标准化的方式，使编码器和解码器能够在视频编码和传输过程中处理和传递这些附加信息。</p>
</li>
<li><p>解析和处理：接收端的解码器可以解析和处理接收到的 SEI NALU，以获取其中的补充增强信息。解码器可以根据应用需要对这些信息进行解析和处理，例如显示字幕、处理场景分析数据等。</p>
</li>
</ol>
<p>总之，H.264 NALU SEI 是一种特殊类型的 NALU，用于传输补充增强信息。SEI 可以包含各种附加的元数据和增强信息，为视频数据提供额外的描述和辅助信息。SEI NALU 可选性强，具有灵活性，适用于多种应用场景。解码器可以解析和处理接收到的 SEI NALU，以实现对补充增强信息的解析和应用。</p>
<h2 id="h264-nalu-slc-ext"><a href="#h264-nalu-slc-ext" class="headerlink" title="h264 nalu slc ext"></a>h264 nalu slc ext</h2><p>H.264 NALU (Network Abstraction Layer Unit) SLC Ext (Slice Extension) 是 H.264 视频编码标准中的一种特殊类型的切片扩展 NALU。</p>
<p>以下是对 H.264 NALU SLC Ext 的详细解释：</p>
<ol>
<li><p>切片扩展：SLC Ext 是对 H.264 视频编码中的图像切片进行扩展的一种机制。它提供了额外的切片参数和信息，用于更精细的编码控制和图像处理。</p>
</li>
<li><p>NALU 类型：SLC Ext NALU 是用于传输切片扩展信息的一种特殊类型的 NALU。在 H.264 中，SLC Ext NALU 的类型由 NAL unit type 字段指示，用于标识该 NALU 中包含的切片扩展信息。</p>
</li>
<li><p>扩展参数：SLC Ext NALU 包含了一些扩展的切片参数，如片组类型、宏块类型、块间预测模式等。这些额外的参数和信息可以提供更多的编码控制选项和更复杂的编码结构，以优化视频编码的效果和性能。</p>
</li>
<li><p>编码控制和处理：SLC Ext NALU 的存在可以使编码器和解码器能够更好地控制和处理图像切片。编码器可以使用扩展参数进行更精细的编码控制和决策，而解码器可以根据扩展参数对图像切片进行更准确的解码和处理。</p>
</li>
<li><p>应用场景：SLC Ext NALU 可用于多种应用场景，如高级视频编码算法、增强的运动估计和补偿技术、更复杂的编码结构等。它为视频编码提供了更高级别的控制和处理能力。</p>
</li>
</ol>
<p>总之，H.264 NALU SLC Ext 是一种特殊类型的 NALU，用于传输切片扩展信息。SLC Ext NALU 包含了扩展的切片参数和信息，用于更精细的编码控制和图像处理。它可以优化视频编码的效果和性能，应用于高级编码算法和增强的编码结构。编码器和解码器可以根据扩展参数对图像切片进行更准确的编码和解码。</p>
<h2 id="h264-nalu-prefix"><a href="#h264-nalu-prefix" class="headerlink" title="h264 nalu prefix"></a>h264 nalu prefix</h2><p>H.264 NALU (Network Abstraction Layer Unit) Prefix 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于传输前缀数据。</p>
<p>以下是对 H.264 NALU Prefix 的详细解释：</p>
<ol>
<li><p>前缀数据：Prefix 是一种用于传输额外的前缀信息的机制。它可以包含各种与图像编码相关的附加信息，如编码参数、参考帧索引、帧类型、宏块编码模式等。</p>
</li>
<li><p>NALU 类型：Prefix NALU 是一种特殊类型的 NALU，用于传输前缀数据。在 H.264 中，Prefix NALU 的类型由 NAL unit type 字段指示，用于标识该 NALU 中包含的前缀信息。</p>
</li>
<li><p>增强编码结构：Prefix NALU 的存在可以为视频编码提供更复杂的编码结构和控制能力。它允许编码器在每个切片的开始处添加额外的前缀数据，以改变编码的行为或提供更高级别的控制选项。</p>
</li>
<li><p>解析和处理：接收端的解码器可以解析和处理接收到的 Prefix NALU，以获取其中包含的前缀信息。这样可以实现对视频编码过程中的附加信息的解析和处理，如改变解码器的配置参数、参考帧的使用策略等。</p>
</li>
<li><p>应用场景：Prefix NALU 可用于多种应用场景，如改变编码过程中的参数设置、参考帧的选择、自适应编码策略等。它提供了一种灵活的方式，使编码器和解码器能够在视频编码和解码过程中进行更精细的控制和优化。</p>
</li>
</ol>
<p>总之，H.264 NALU Prefix 是一种特殊类型的 NALU，用于传输前缀数据。它可以包含各种与图像编码相关的附加信息，为视频编码提供更复杂的编码结构和控制能力。解码器可以解析和处理接收到的 Prefix NALU，以实现对前缀数据的解析和应用。Prefix NALU 可应用于不同的场景，提供灵活的编码和解码控制选项。</p>
<h2 id="h264-nalu-aud"><a href="#h264-nalu-aud" class="headerlink" title="h264 nalu aud"></a>h264 nalu aud</h2><p>H.264 NALU (Network Abstraction Layer Unit) AUD (Access Unit Delimiter) 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于标识视频的访问单元边界。</p>
<p>以下是对 H.264 NALU AUD 的详细解释：</p>
<ol>
<li><p>访问单元边界：H.264 视频编码中，访问单元（Access Unit）是指视频数据的一个连续部分，通常对应于一个或多个图像帧。AUD NALU 用于标识访问单元的边界，即指示视频数据中一个访问单元的开始位置。</p>
</li>
<li><p>NALU 类型：AUD NALU 是一种特殊类型的 NALU，用于传输访问单元边界信息。在 H.264 中，AUD NALU 的类型由 NAL unit type 字段指示，用于标识该 NALU 为访问单元分隔符。</p>
</li>
<li><p>访问单元属性：AUD NALU 可以携带一些与访问单元相关的属性信息，如访问单元类型、访问单元大小等。这些属性信息可以帮助解码器在解码过程中正确识别访问单元的边界，并进行适当的处理。</p>
</li>
<li><p>解码器处理：接收端的解码器在解码过程中使用 AUD NALU 来确定访问单元的边界。当接收到 AUD NALU 时，解码器可以将当前的解码状态重置为一个新的访问单元的开始，并进行相应的解码操作。</p>
</li>
<li><p>访问单元的应用：访问单元在视频编码中起到重要的作用，它可以用于视频随机访问、错误恢复等应用场景。通过标识访问单元的边界，解码器能够正确解析视频数据并还原图像。</p>
</li>
</ol>
<p>总之，H.264 NALU AUD 是一种特殊类型的 NALU，用于标识视频数据的访问单元边界。它可以帮助解码器确定访问单元的开始位置，并进行相应的解码操作。访问单元在视频编码中具有重要作用，可以用于实现视频随机访问和错误恢复等功能。</p>
<h2 id="h264-nalu-eoseq"><a href="#h264-nalu-eoseq" class="headerlink" title="h264 nalu eoseq"></a>h264 nalu eoseq</h2><p>H.264 NALU (Network Abstraction Layer Unit) EOSEQ (End of Sequence) 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于标识视频序列的结束。</p>
<p>以下是对 H.264 NALU EOSEQ 的详细解释：</p>
<ol>
<li><p>视频序列结束：EOSEQ NALU 用于标识视频序列的结束。当视频编码器完成对整个视频序列的编码后，在视频流的末尾添加一个 EOSEQ NALU，表示视频序列的结束。</p>
</li>
<li><p>NALU 类型：EOSEQ NALU 是一种特殊类型的 NALU，用于传输视频序列结束信息。在 H.264 中，EOSEQ NALU 的类型由 NAL unit type 字段指示，用于标识该 NALU 为视频序列结束。</p>
</li>
<li><p>序列重置：EOSEQ NALU 的出现通常会导致解码器进行序列重置，即清除之前解码的图像数据和状态。解码器在接收到 EOSEQ NALU 后，会重新初始化以准备解码下一个视频序列。</p>
</li>
<li><p>应用场景：EOSEQ NALU 主要应用于视频编码的结束标识和视频序列的切换。它可以用于多段视频序列的串联，以及实现在视频流中切换不同的编码参数或分辨率等。</p>
</li>
</ol>
<p>总之，H.264 NALU EOSEQ 是一种特殊类型的 NALU，用于标识视频序列的结束。它在视频编码流的末尾添加，表示当前视频序列的编码结束。EOSEQ NALU 的出现会导致解码器进行序列重置，以准备解码下一个视频序列。EOSEQ NALU 主要应用于视频序列的结束标识和视频序列的切换。</p>
<h2 id="h264-nalu-eostream"><a href="#h264-nalu-eostream" class="headerlink" title="h264 nalu eostream"></a>h264 nalu eostream</h2><p>H.264 NALU (Network Abstraction Layer Unit) EOSTREAM (End of Stream) 是 H.264 视频编码标准中的一种特殊类型的 NALU，用于标识视频流的结束。</p>
<p>以下是对 H.264 NALU EOSTREAM 的详细解释：</p>
<ol>
<li><p>视频流结束：EOSTREAM NALU 用于标识视频流的结束。当视频编码器完成对整个视频流的编码后，在视频流的末尾添加一个 EOSTREAM NALU，表示视频流的结束。</p>
</li>
<li><p>NALU 类型：EOSTREAM NALU 是一种特殊类型的 NALU，用于传输视频流结束信息。在 H.264 中，EOSTREAM NALU 的类型由 NAL unit type 字段指示，用于标识该 NALU 为视频流结束。</p>
</li>
<li><p>解码器处理：接收端的解码器在解码过程中会根据接收到的 NALU 进行解码操作，当解码器接收到 EOSTREAM NALU 时，它会识别视频流的结束并进行相应的处理。</p>
</li>
<li><p>应用场景：EOSTREAM NALU 主要应用于标识视频流的结束，可以用于标记视频的结尾，帮助解码器识别视频流的结束点。</p>
</li>
</ol>
<p>总之，H.264 NALU EOSTREAM 是一种特殊类型的 NALU，用于标识视频流的结束。它在视频流的末尾添加，表示当前视频流的编码结束。EOSTREAM NALU 可以帮助解码器识别视频流的结束点，并进行相应的处理。主要应用于标记视频流的结束。</p>
<h2 id="h264-nalu-fill"><a href="#h264-nalu-fill" class="headerlink" title="h264 nalu fill"></a>h264 nalu fill</h2><p>在 H.264 视频编码中，”filler data”（填充数据）指的是在比特流中插入的额外数据，其目的是维持特定的比特率或对齐比特流的结构。</p>
<p>以下是对 H.264 NALU 填充数据的详细解释：</p>
<ol>
<li><p>目的：填充数据用于在视频编码过程中保持恒定的比特率。它有助于在网络传输或存储系统中保持数据流的稳定性。</p>
</li>
<li><p>NALU 类型：填充数据表示为具有特定 NAL 单元类型的 NALU，该类型被称为 “fill” NALU。填充数据的 NAL 单元类型没有进行标准化，因此在不同的实现中可能会有所变化。</p>
</li>
<li><p>插入点：填充数据通常插入在比特流的不同点，通常是在访问单元（AU）或视频帧之间。在需要保持特定目标比特率或符合所需数据传输速率时，会插入填充数据。</p>
</li>
<li><p>内容和解码：填充数据不包含任何有意义的视频信息，不会对解码后的视频帧产生影响。在解码过程中，解码器会简单地丢弃填充数据，而不会影响重建的视频帧。</p>
</li>
<li><p>比特率控制：填充数据的插入在比特率控制策略中起着作用。通过调整填充数据的数量，编码器可以对整体比特率进行微调，以确保符合特定的目标比特率或网络传输容量。</p>
</li>
<li><p>合规性和标准：填充数据的插入在 H.264 中是可选的，并非强制性的要求。在不同的编码器实现和应用程序中，对填充数据的使用和处理可能会有所不同。</p>
</li>
</ol>
<p>总结起来，在 H.264 视频编码中，填充数据（或填充 NALU）指的是在比特流中插入的额外数据，用于维持特定的比特率或比特流结构。填充数据不包含有意义的视频信息，解码过程中会被丢弃。填充数据的插入有助于比特率控制，确保视频传输或存储过程中数据流的稳定性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Windows/2024-05-22-windows_02_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Windows/2024-05-22-windows_02_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">windows_02_常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Windows下常用命令</li>
</ul>
<h2 id="windows-chcp命令-详解"><a href="#windows-chcp命令-详解" class="headerlink" title="windows chcp命令 详解"></a>windows chcp命令 详解</h2><p><code>CHCP</code>（Change Code Page）是 Windows 命令行中的一个命令，用于更改或显示当前的代码页（code page）。代码页决定了控制台显示和输入字符时所使用的字符集（字符编码）。不同代码页对应不同的字符集，比如 ANSI、UTF-8 或特定语言的字符集。</p>
<h3 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHCP [&lt;代码页&gt;]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>无参数时</strong>：显示当前活动的代码页。</li>
<li><strong>指定代码页时</strong>：更改当前控制台的代码页。</li>
</ul>
<h3 id="常见代码页"><a href="#常见代码页" class="headerlink" title="常见代码页"></a>常见代码页</h3><ul>
<li><code>437</code>：美国英语（默认的原始代码页）</li>
<li><code>936</code>：简体中文（GBK）</li>
<li><code>65001</code>：UTF-8（用于多语言支持）</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol>
<li><p><strong>查看当前代码页：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHCP</span><br></pre></td></tr></table></figure>
<p>输出例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">活动代码页: 936</span><br></pre></td></tr></table></figure>
<p>上述例子显示当前代码页是 936（简体中文）。</p>
</li>
<li><p><strong>更改为 UTF-8：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHCP 65001</span><br></pre></td></tr></table></figure>
<p>更改为 UTF-8 编码。执行后，控制台将使用 UTF-8 显示和输入字符。</p>
</li>
<li><p><strong>更改为简体中文：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHCP 936</span><br></pre></td></tr></table></figure>
<p>这会切换到简体中文字符集。</p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>更改代码页可能会影响控制台显示字符的正确性，尤其在涉及不同语言或特殊符号时。</li>
<li>有些程序可能对某些代码页支持有限，切换代码页后可能导致显示或输入异常。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>处理不同语言的文本输出。</li>
<li>使用脚本时确保字符集兼容性。</li>
<li>跨平台执行脚本时（如 UTF-8 兼容）。</li>
</ul>
<p>总之，<code>CHCP</code> 命令是用来管理控制台字符编码的重要工具，特别是在处理多语言环境时十分有用。</p>
<h2 id="windows-slmgr命令是什么"><a href="#windows-slmgr命令是什么" class="headerlink" title="windows slmgr命令是什么"></a>windows slmgr命令是什么</h2><p><code>slmgr</code> 是 Windows 操作系统中的软件许可证管理工具，主要用于管理和激活 Windows 许可证。<code>slmgr</code> 实际上是 <code>Software Licensing Management Tool</code> 的缩写，通常通过命令行使用。以下是一些常见的 <code>slmgr</code> 命令及其功能：</p>
<ol>
<li><strong><code>slmgr /dli</code></strong> - 显示当前的激活状态和许可证信息。</li>
<li><strong><code>slmgr /dlv</code></strong> - 显示更详细的许可证信息，包括激活 ID、安装 ID 等。</li>
<li><strong><code>slmgr /xpr</code></strong> - 显示当前 Windows 安装的许可证到期时间。</li>
<li><strong><code>slmgr /ipk &lt;产品密钥&gt;</code></strong> - 安装新的产品密钥。</li>
<li><strong><code>slmgr /ato</code></strong> - 激活 Windows。</li>
<li><strong><code>slmgr /rearm</code></strong> - 重置激活状态，允许重新激活。</li>
<li><strong><code>slmgr /upk</code></strong> - 卸载当前的产品密钥。</li>
</ol>
<p>使用这些命令时，需要在命令提示符（以管理员身份运行）中输入。例如，要查看当前激活状态，可以输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slmgr /dli</span><br></pre></td></tr></table></figure>

<p>运行后，系统会弹出一个窗口，显示当前的激活信息。</p>
<h2 id="windows-slmgr命令-详解"><a href="#windows-slmgr命令-详解" class="headerlink" title="windows slmgr命令 详解"></a>windows slmgr命令 详解</h2><p><code>slmgr</code> (Software Licensing Management Tool) 是 Windows 操作系统中的一个命令行工具，用于管理和激活 Windows 许可证。以下是 <code>slmgr</code> 命令的详细解释及其使用方法：</p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ol>
<li><p><strong><code>slmgr /dli</code></strong></p>
<ul>
<li><strong>功能</strong>：显示当前的激活信息，包括许可证状态、剩余宽限期、激活 ID 等基本信息。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /dli</code> 并回车。</li>
</ul>
</li>
<li><p><strong><code>slmgr /dlv</code></strong></p>
<ul>
<li><strong>功能</strong>：显示更详细的激活信息，包括激活 ID、安装 ID、许可证状态和其他详细信息。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /dlv</code> 并回车。</li>
</ul>
</li>
<li><p><strong><code>slmgr /xpr</code></strong></p>
<ul>
<li><strong>功能</strong>：显示当前 Windows 安装的许可证到期时间。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /xpr</code> 并回车。</li>
</ul>
</li>
</ol>
<h3 id="产品密钥管理"><a href="#产品密钥管理" class="headerlink" title="产品密钥管理"></a>产品密钥管理</h3><ol start="4">
<li><p><strong><code>slmgr /ipk &lt;产品密钥&gt;</code></strong></p>
<ul>
<li><strong>功能</strong>：安装新的产品密钥。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /ipk &lt;产品密钥&gt;</code>，用实际的产品密钥替换 <code>&lt;产品密钥&gt;</code>。</li>
</ul>
</li>
<li><p><strong><code>slmgr /cpky</code></strong></p>
<ul>
<li><strong>功能</strong>：从注册表中清除产品密钥，以保护隐私。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /cpky</code> 并回车。</li>
</ul>
</li>
<li><p><strong><code>slmgr /upk</code></strong></p>
<ul>
<li><strong>功能</strong>：卸载当前的产品密钥。这个命令可以用来删除当前系统中的产品密钥。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /upk</code> 并回车。</li>
</ul>
</li>
</ol>
<h3 id="激活管理"><a href="#激活管理" class="headerlink" title="激活管理"></a>激活管理</h3><ol start="7">
<li><p><strong><code>slmgr /ato</code></strong></p>
<ul>
<li><strong>功能</strong>：尝试在线激活 Windows。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /ato</code> 并回车。</li>
</ul>
</li>
<li><p><strong><code>slmgr /skms &lt;服务器地址&gt;</code></strong></p>
<ul>
<li><strong>功能</strong>：设置 KMS（Key Management Service） 服务器的地址。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /skms &lt;服务器地址&gt;</code>，用实际的服务器地址替换 <code>&lt;服务器地址&gt;</code>。</li>
</ul>
</li>
<li><p><strong><code>slmgr /ckms</code></strong></p>
<ul>
<li><strong>功能</strong>：清除现有的 KMS 服务器设置。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /ckms</code> 并回车。</li>
</ul>
</li>
<li><p><strong><code>slmgr /rearm</code></strong></p>
<ul>
<li><strong>功能</strong>：重置激活状态，这通常用于延长激活宽限期。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /rearm</code> 并回车。</li>
</ul>
</li>
</ol>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ol start="11">
<li><p><strong><code>slmgr /sprt &lt;端口号&gt;</code></strong></p>
<ul>
<li><strong>功能</strong>：设置 KMS 主机的端口号。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /sprt &lt;端口号&gt;</code>，用实际的端口号替换 <code>&lt;端口号&gt;</code>。</li>
</ul>
</li>
<li><p><strong><code>slmgr /dti</code></strong></p>
<ul>
<li><strong>功能</strong>：显示安装 ID，用于电话激活。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /dti</code> 并回车。</li>
</ul>
</li>
<li><p><strong><code>slmgr /sai &lt;激活间隔&gt;</code></strong></p>
<ul>
<li><strong>功能</strong>：设置自动激活间隔时间（以分钟为单位）。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /sai &lt;激活间隔&gt;</code>，用实际的时间间隔替换 <code>&lt;激活间隔&gt;</code>。</li>
</ul>
</li>
<li><p><strong><code>slmgr /sri &lt;更新间隔&gt;</code></strong></p>
<ul>
<li><strong>功能</strong>：设置 KMS 服务器的更新间隔时间（以分钟为单位）。</li>
<li><strong>使用</strong>：在命令提示符中输入 <code>slmgr /sri &lt;更新间隔&gt;</code>，用实际的时间间隔替换 <code>&lt;更新间隔&gt;</code>。</li>
</ul>
</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设你要查看当前的激活信息并安装一个新的产品密钥，可以按以下步骤操作：</p>
<ol>
<li><p>打开命令提示符（以管理员身份运行）。</p>
</li>
<li><p>输入以下命令并回车：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slmgr /dli</span><br></pre></td></tr></table></figure>
<p>查看当前激活状态。</p>
</li>
<li><p>输入以下命令并回车，安装新的产品密钥（用实际的产品密钥替换 <code>&lt;产品密钥&gt;</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slmgr /ipk &lt;产品密钥&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入以下命令并回车，激活 Windows：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过这些命令，你可以有效地管理和激活 Windows 系统的许可证。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>在 Windows 系统下，命令行（命令提示符、PowerShell 或 Windows Terminal）提供了许多常用的命令，用于执行各种任务。以下是一些常用的 Windows 命令行命令：</p>
<ol>
<li><p>文件和目录管理：</p>
<ul>
<li><code>dir</code>: 列出当前目录中的文件和子目录。</li>
<li><code>cd</code>: 更改当前目录。</li>
<li><code>mkdir</code>: 创建新目录。</li>
<li><code>rmdir</code>: 删除目录。</li>
<li><code>del</code>: 删除文件。</li>
<li><code>copy</code>: 复制文件或目录。</li>
<li><code>move</code>: 移动文件或目录。</li>
<li><code>ren</code>: 重命名文件。</li>
</ul>
</li>
<li><p>系统信息和配置：</p>
<ul>
<li><code>systeminfo</code>: 显示关于计算机系统的详细信息，如操作系统版本、内存等。</li>
<li><code>ipconfig</code>: 显示当前的网络配置信息，包括 IP 地址、子网掩码等。</li>
</ul>
</li>
<li><p>进程管理：</p>
<ul>
<li><code>tasklist</code>: 列出当前运行的进程。</li>
<li><code>taskkill</code>: 终止运行中的进程。</li>
</ul>
</li>
<li><p>网络相关：</p>
<ul>
<li><code>ping</code>: 测试与另一台计算机的连接。</li>
<li><code>tracert</code>: 跟踪数据包到目标主机的路由路径。</li>
<li><code>nslookup</code>: 查询 DNS 解析信息。</li>
</ul>
</li>
<li><p>文件查看和编辑：</p>
<ul>
<li><code>type</code>: 显示文本文件的内容。</li>
<li><code>more</code>: 逐页查看文本文件的内容。</li>
<li><code>find</code>: 在文本文件中搜索字符串。</li>
<li><code>edit</code>: 打开 MS-DOS 编辑器（仅限旧版本的 Windows）。</li>
<li><code>notepad</code>: 打开记事本应用程序。</li>
</ul>
</li>
<li><p>其他实用工具：</p>
<ul>
<li><code>help</code>: 显示帮助信息，了解其他命令的用法。例如，使用 <code>help dir</code> 查看 <code>dir</code> 命令的帮助。</li>
<li><code>cls</code>: 清屏。</li>
<li><code>echo</code>: 输出文本或环境变量的值。</li>
<li><code>date</code>: 显示或设置系统日期。</li>
<li><code>time</code>: 显示或设置系统时间。</li>
</ul>
</li>
</ol>
<p>这些只是 Windows 命令行中的一部分常用命令。还有许多其他命令可用于执行各种任务。您可以在命令提示符下键入 <code>help</code> 或者加上命令名称来获取有关特定命令的更多帮助信息，例如 <code>help dir</code> 或者 <code>dir /?</code>。</p>
<h2 id="windows-cmd-time命令-详解"><a href="#windows-cmd-time命令-详解" class="headerlink" title="windows cmd time命令 详解"></a>windows cmd time命令 详解</h2><p><code>time</code> 命令是 Windows 命令行中的一个内置命令，用于显示或设置系统的时间。它允许用户查看当前系统时间并进行时间的更改。以下是 <code>time</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time [时间]</span><br></pre></td></tr></table></figure>

<p>常见用法：</p>
<ol>
<li><p><strong>显示当前系统时间</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time</span><br></pre></td></tr></table></figure>

<p>这个命令将显示当前系统的时间。</p>
</li>
<li><p><strong>设置系统时间</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time HH:MM:SS</span><br></pre></td></tr></table></figure>

<p>这个命令将设置系统的时间为指定的时间，其中 <code>HH</code> 表示小时（00-23），<code>MM</code> 表示分钟（00-59），<code>SS</code> 表示秒（00-59）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time 14:30:00</span><br></pre></td></tr></table></figure>

<p>这个命令将设置系统时间为下午 2 点 30 分 0 秒。</p>
</li>
</ol>
<p>请注意，<code>time</code> 命令的可用选项和时间格式可能会因 Windows 版本而异。在某些版本中，您可能需要使用时间格式 <code>HH:MM AM/PM</code>，具体取决于您的系统设置。</p>
<p><code>time</code> 命令通常在批处理脚本或命令行中用于查看或更改系统时间。它可以用于各种用途，如生成时间戳、批处理文件日志等。要更改系统时间，通常需要管理员权限。如果您只是想查看当前系统时间，可以简单地运行 <code>time</code> 命令，而不需要管理员权限。</p>
<h2 id="windows-cmd-date命令-详解"><a href="#windows-cmd-date命令-详解" class="headerlink" title="windows cmd date命令 详解"></a>windows cmd date命令 详解</h2><p><code>date</code> 命令是 Windows 命令行中的一个内置命令，用于显示或设置系统的日期。它允许用户查看当前系统日期并进行日期的更改。以下是 <code>date</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date [日期]</span><br></pre></td></tr></table></figure>

<p>常见用法：</p>
<ol>
<li><p><strong>显示当前系统日期</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>

<p>这个命令将显示当前系统的日期。</p>
</li>
<li><p><strong>设置系统日期</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date MM-DD-YYYY</span><br></pre></td></tr></table></figure>

<p>这个命令将设置系统的日期为指定的日期，其中 <code>MM</code> 表示月份（01-12），<code>DD</code> 表示日期（01-31），<code>YYYY</code> 表示年份。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date 10-25-2023</span><br></pre></td></tr></table></figure>

<p>这个命令将设置系统日期为 2023 年 10 月 25 日。</p>
</li>
</ol>
<p>请注意，<code>date</code> 命令的可用选项和格式可能会因 Windows 版本而异。在某些版本中，您可能需要使用日期格式 <code>MM/DD/YYYY</code> 或 <code>YYYY-MM-DD</code>，具体取决于您的系统设置。</p>
<p><code>date</code> 命令通常在批处理脚本或命令行中用于查看或更改系统日期。它可以用于各种用途，如生成日期时间戳、批处理文件日志等。要更改系统日期，通常需要管理员权限。如果您只是想查看当前系统日期，可以简单地运行 <code>date</code> 命令，而不需要管理员权限。</p>
<h2 id="windows-cmd-echo命令-详解"><a href="#windows-cmd-echo命令-详解" class="headerlink" title="windows cmd echo命令 详解"></a>windows cmd echo命令 详解</h2><p><code>echo</code> 命令是 Windows 命令行中的一个内置命令，用于在命令提示符窗口上显示文本或启用或禁用命令回显。<code>echo</code> 命令在批处理脚本中和命令行中都非常有用。以下是 <code>echo</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo [参数] [文本]</span><br></pre></td></tr></table></figure>

<p>常见参数：</p>
<ol>
<li><p><strong>on</strong>：启用命令回显。这是默认设置，如果未指定参数，则回显会处于启用状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo on</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>off</strong>：禁用命令回显。当回显被禁用时，执行的命令和脚本中的文本将不会显示在命令提示符窗口上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo off</span><br></pre></td></tr></table></figure></li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>显示文本</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo Hello, World!</span><br></pre></td></tr></table></figure>

<p>这个命令将在命令提示符窗口上显示 “Hello, World!”。</p>
</li>
<li><p><strong>显示空行</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo.</span><br></pre></td></tr></table></figure>

<p>这个命令将在命令提示符窗口上显示一个空行。</p>
</li>
<li><p><strong>启用命令回显</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo on</span><br></pre></td></tr></table></figure>

<p>这个命令将启用命令回显，使命令行窗口开始显示执行的命令和脚本中的文本。</p>
</li>
<li><p><strong>禁用命令回显</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo off</span><br></pre></td></tr></table></figure>

<p>这个命令将禁用命令回显，使命令行窗口不再显示执行的命令和脚本中的文本。</p>
</li>
</ol>
<p><code>echo</code> 命令最常见的用途是在批处理脚本中用于显示消息、变量值或生成脚本输出。它还可以用于启用或禁用命令回显，这对于在批处理脚本中隐藏命令或显示调试信息非常有用。在交互式命令提示符窗口中，<code>echo</code> 命令通常用于显示文本或空行以提供视觉分隔或其他用途。</p>
<h2 id="windows-cmd-cls命令-详解"><a href="#windows-cmd-cls命令-详解" class="headerlink" title="windows cmd cls命令 详解"></a>windows cmd cls命令 详解</h2><p><code>cls</code> 命令是 Windows 命令行中的一个实用工具，用于清除命令提示符窗口的内容，从而创建一个空白的命令行界面。<code>cls</code> 命令对于清除命令历史记录、命令输出或屏幕上的文本非常有用，以便开始一个新的命令或清空命令行界面。以下是 <code>cls</code> 命令的基本语法和用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cls</span><br></pre></td></tr></table></figure>

<p>用法示例：</p>
<ol>
<li><p><strong>清除命令行窗口内容</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cls</span><br></pre></td></tr></table></figure>

<p>这个命令将清除当前命令提示符窗口中的所有文本内容，从而创建一个干净的命令行界面。</p>
</li>
</ol>
<p><code>cls</code> 命令通常在需要清除命令行窗口中的文本信息时使用。这可以帮助用户保持命令行窗口的整洁，以便执行新的命令或查看命令输出时不受之前的文本干扰。请注意，<code>cls</code> 命令只会清除屏幕上的文本，而不会影响之前执行的命令或命令历史记录。</p>
<h2 id="windows-cmd-help命令-详解"><a href="#windows-cmd-help命令-详解" class="headerlink" title="windows cmd help命令 详解"></a>windows cmd help命令 详解</h2><p><code>help</code> 命令是 Windows 命令行中的一个实用工具，用于查看帮助信息和命令的用法。它允许用户获取关于其他命令和命令行工具的信息，包括命令的语法、选项、用法示例等。以下是 <code>help</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help [命令]</span><br></pre></td></tr></table></figure>

<p>常见用法：</p>
<ol>
<li><p><strong>查看帮助信息</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help</span><br></pre></td></tr></table></figure>

<p>这个命令将显示 Windows 命令行的基本帮助信息，包括可用的内置命令和一些常见用法示例。</p>
</li>
<li><p><strong>查看特定命令的帮助信息</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help 命令名</span><br></pre></td></tr></table></figure>

<p>这个命令将显示特定命令的帮助信息，包括命令的语法、选项和用法示例。例如，要查看 <code>dir</code> 命令的帮助信息，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help dir</span><br></pre></td></tr></table></figure>

<p>这将显示 <code>dir</code> 命令的详细用法和选项说明。</p>
</li>
<li><p><strong>查看特定命令的子命令帮助信息</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help 命令名 子命令</span><br></pre></td></tr></table></figure>

<p>一些命令具有子命令，您可以使用 <code>help</code> 命令查看特定子命令的帮助信息。例如，要查看 <code>net</code> 命令的 <code>user</code> 子命令的帮助信息，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help net user</span><br></pre></td></tr></table></figure>

<p>这将显示有关 <code>net user</code> 命令的详细信息。</p>
</li>
<li><p><strong>查看命令的选项和用法示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help 命令 /?</span><br></pre></td></tr></table></figure>

<p>这个命令将显示特定命令的选项和用法示例。例如，要查看 <code>copy</code> 命令的选项和用法示例，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help copy /?</span><br></pre></td></tr></table></figure>

<p>这将显示有关 <code>copy</code> 命令的详细选项和用法说明。</p>
</li>
</ol>
<p><code>help</code> 命令是一个有用的工具，可以帮助您了解和学习如何正确使用 Windows 命令行中的各种命令和工具。通过查看帮助信息，您可以快速了解命令的语法和选项，以便在命令行中执行各种操作。这对于新手和经验丰富的用户都是非常有用的。</p>
<h2 id="windows-cmd-notepad命令-详解"><a href="#windows-cmd-notepad命令-详解" class="headerlink" title="windows cmd notepad命令 详解"></a>windows cmd notepad命令 详解</h2><p>在 Windows 命令行中，<code>notepad</code> 命令用于启动记事本应用程序（Notepad），并可选择性地打开指定的文本文件。记事本是 Windows 中的文本编辑器，通常用于创建、编辑和查看文本文件。以下是 <code>notepad</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad [选项] [文件名]</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><strong>文件名</strong>：要在记事本中打开的文本文件的路径。如果省略文件名，则只会启动记事本应用程序而不打开任何文件。</li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>打开记事本</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad</span><br></pre></td></tr></table></figure>

<p>这个命令将启动记事本应用程序，但不会打开任何特定的文本文件。您可以使用记事本创建新文件或打开现有文件。</p>
</li>
<li><p><strong>打开特定文本文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将启动记事本应用程序并打开名为 <code>filename.txt</code> 的文本文件。您可以在记事本中编辑和查看文件内容。</p>
</li>
<li><p><strong>打开多个文本文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将启动记事本应用程序，并同时打开名为 <code>file1.txt</code> 和 <code>file2.txt</code> 的多个文本文件，每个文件将在单独的记事本窗口中打开。</p>
</li>
<li><p><strong>打开文件夹</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad C:\Path\To\Folder</span><br></pre></td></tr></table></figure>

<p>如果您指定的是文件夹路径而不是文件路径，记事本将尝试在文件夹中打开一个新的文本文件。</p>
</li>
</ol>
<p><code>notepad</code> 命令是一个简单的方式来启动记事本应用程序并在其中打开文本文件。这对于快速查看、编辑或创建文本文件非常有用。请注意，<code>notepad</code> 命令是在命令提示符中使用的，因此您需要在命令行界面中输入它。</p>
<h2 id="windows-cmd-find命令-详解"><a href="#windows-cmd-find命令-详解" class="headerlink" title="windows cmd find命令 详解"></a>windows cmd find命令 详解</h2><p><code>find</code> 命令是 Windows 命令行中的一个实用工具，用于在文本文件中搜索指定的字符串，并显示包含匹配文本的行。<code>find</code> 命令是一个基本的文本搜索工具，它可以用于在文本文件中查找特定的文本模式或关键字。以下是 <code>find</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &quot;要搜索的字符串&quot; 文件名</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>&#x2F;i</strong>：不区分大小写地搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /i &quot;search term&quot; filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将不区分大小写地搜索 <code>filename.txt</code> 文件中的 “search term”。</p>
</li>
<li><p><strong>&#x2F;v</strong>：显示不包含搜索字符串的行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /v &quot;exclude this&quot; filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将显示不包含 “exclude this” 的行。</p>
</li>
<li><p><strong>&#x2F;c</strong>：计算匹配的行数，而不显示匹配的文本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /c &quot;search term&quot; filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将计算包含 “search term” 的行数。</p>
</li>
<li><p><strong>&#x2F;n</strong>：显示每行的行号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /n &quot;search term&quot; filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将显示每行的行号，以便您知道匹配的文本出现在文件的哪一行。</p>
</li>
<li><p><strong>&#x2F;b</strong>：只显示包含搜索字符串的行，不显示行号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /b &quot;search term&quot; filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将只显示包含 “search term” 的行，不显示行号。</p>
</li>
<li><p>**&#x2F;?**：显示帮助信息，包括 <code>find</code> 命令的选项和用法示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /?</span><br></pre></td></tr></table></figure></li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>在文本文件中搜索特定字符串</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &quot;search term&quot; filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将搜索 <code>filename.txt</code> 文件中的 “search term” 并显示包含匹配文本的行。</p>
</li>
<li><p><strong>不区分大小写搜索</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /i &quot;search term&quot; filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将不区分大小写地搜索 “search term”。</p>
</li>
<li><p><strong>显示不包含特定字符串的行</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /v &quot;exclude this&quot; filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将显示不包含 “exclude this” 的行。</p>
</li>
<li><p><strong>计算匹配的行数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /c &quot;search term&quot; filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将计算包含 “search term” 的行数。</p>
</li>
<li><p><strong>显示每行的行号</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /n &quot;search term&quot; filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将显示每行的行号，以便您知道匹配的文本出现在文件的哪一行。</p>
</li>
<li><p><strong>只显示包含特定字符串的行</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /b &quot;search term&quot; filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将只显示包含 “search term” 的行，不显示行号。</p>
</li>
</ol>
<p><code>find</code> 命令是一个简单但有用的文本搜索工具，用于在文本文件中查找特定的文本模式或关键字。它可以帮助您快速定位文件中的特定信息，进行文本处理和筛选。请注意，<code>find</code> 命令是基于命令行的工具，因此需要在命令提示符下使用。</p>
<h2 id="windows-cmd-more命令-详解"><a href="#windows-cmd-more命令-详解" class="headerlink" title="windows cmd more命令 详解"></a>windows cmd more命令 详解</h2><p><code>more</code> 命令是 Windows 命令行中的一个实用工具，用于逐页显示文本文件的内容。它允许用户按页浏览大型文本文件，以便更容易查看和阅读文件的内容。以下是 <code>more</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [选项] [文件名]</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>&#x2F;C</strong>：清除屏幕上的内容并从文件的开头开始显示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /c filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;P</strong>：逐页显示文件的内容，允许用户使用空格键进行逐页翻页。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /p filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;S</strong>：将空行视为分页结束，当出现空行时停止显示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /s filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;Tn</strong>：指定每页显示的行数，其中 <code>n</code> 是整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /t10 filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将每页显示 10 行文本。</p>
</li>
<li><p><strong>&#x2F;+n</strong>：从文件的第 <code>n</code> 行开始显示内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /+5 filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将从文件的第 5 行开始显示内容。</p>
</li>
<li><p><strong>&#x2F;E</strong>：在文件的结尾显示 “End of file”（文件结束）消息，并等待用户按键继续。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /e filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>**&#x2F;?**：显示帮助信息，包括 <code>more</code> 命令的选项和用法示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /?</span><br></pre></td></tr></table></figure></li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>逐页显示文件内容</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将按页显示名为 <code>filename.txt</code> 的文本文件的内容。您可以使用空格键来逐页翻阅文件。</p>
</li>
<li><p><strong>从文件的特定行开始显示</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /+10 filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将从 <code>filename.txt</code> 文件的第 10 行开始显示内容。</p>
</li>
<li><p><strong>指定每页显示的行数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /t20 filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将每页显示 20 行文本。</p>
</li>
<li><p><strong>显示文件末尾的消息</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /e filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将在显示文件末尾时显示 “End of file” 消息，并等待用户按键继续。</p>
</li>
</ol>
<p><code>more</code> 命令通常用于查看大型文本文件的内容，以避免在屏幕上同时显示整个文件，这可能会导致信息过于拥挤。它允许用户按页浏览文件，同时提供一些选项以满足不同的浏览需求。如果您需要查看文本文件的内容并逐页查看，<code>more</code> 命令是一个非常有用的工具。</p>
<h2 id="windows-cmd-type命令-详解"><a href="#windows-cmd-type命令-详解" class="headerlink" title="windows cmd type命令 详解"></a>windows cmd type命令 详解</h2><p><code>type</code> 命令是 Windows 命令行中的一个实用工具，用于显示文本文件的内容。它将文本文件的内容逐行显示在命令提示符窗口上。以下是 <code>type</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type [选项] 文件名</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p>**&#x2F;?**：显示帮助信息，包括 <code>type</code> 命令的选项和用法示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type /?</span><br></pre></td></tr></table></figure></li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>显示文本文件的内容</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将打开名为 <code>filename.txt</code> 的文本文件，并将其内容逐行显示在命令提示符窗口上。</p>
</li>
<li><p><strong>显示多个文本文件的内容</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将依次显示 <code>file1.txt</code> 和 <code>file2.txt</code> 文件的内容。您可以指定多个文件名，<code>type</code> 命令将按顺序显示它们的内容。</p>
</li>
<li><p><strong>将文本文件的内容重定向到另一个文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type input.txt &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>input.txt</code> 文件的内容显示在命令提示符窗口上，并将其内容重定向到名为 <code>output.txt</code> 的新文件中。如果 <code>output.txt</code> 文件不存在，将会创建它。如果已存在，则会覆盖其内容。</p>
</li>
<li><p><strong>将文本文件的内容附加到另一个文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type append.txt &gt;&gt; existing.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>append.txt</code> 文件的内容显示在命令提示符窗口上，并将其内容附加到名为 <code>existing.txt</code> 的现有文件末尾。如果 <code>existing.txt</code> 文件不存在，将会创建它。</p>
</li>
</ol>
<p><code>type</code> 命令通常用于查看文本文件的内容，特别是在命令行环境下。它不仅可以用于查看文件内容，还可以通过重定向和附加操作将文件内容复制到其他文件中。这对于查看配置文件、日志文件、文本文档等非常有用。请注意，<code>type</code> 命令不适用于二进制文件，因为它会尝试解释二进制数据并显示在屏幕上，可能会导致不可读的输出。如果需要查看二进制文件，请考虑使用其他适用的工具。</p>
<h2 id="windows-cmd-nslookup命令-详解"><a href="#windows-cmd-nslookup命令-详解" class="headerlink" title="windows cmd nslookup命令 详解"></a>windows cmd nslookup命令 详解</h2><p><code>nslookup</code> 是 Windows 命令行中的一个实用工具，用于查询 DNS（Domain Name System，域名系统）服务器以获取有关域名和 IP 地址之间映射关系的信息。它允许用户查找特定主机的 IP 地址，反向查询 IP 地址以查找关联的域名，以及执行其他与 DNS 相关的查询。以下是 <code>nslookup</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup [选项] [主机名或IP地址] [DNS服务器]</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>主机名或IP地址</strong>：要查询的域名或IP地址。如果未指定主机名或IP地址，<code>nslookup</code> 将启动一个交互式查询会话，允许您在命令提示符下输入查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DNS服务器</strong>：要查询的特定 DNS 服务器的名称或IP地址。如果未指定 DNS 服务器，则将使用默认的系统 DNS 服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup example.com 8.8.8.8</span><br></pre></td></tr></table></figure>

<p>这个命令将使用 Google Public DNS（8.8.8.8）来查询 <code>example.com</code> 的信息。</p>
</li>
<li><p><strong>-querytype&#x3D;查询类型</strong>：指定查询类型，例如 A 记录、MX 记录等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -querytype=mx example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将查询 <code>example.com</code> 的 MX 记录。</p>
</li>
<li><p><strong>-debug</strong>：启用调试模式，以显示更详细的查询信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -debug example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将启用调试模式来显示详细的查询信息。</p>
</li>
<li><p>**-sil[ent]**：静默模式，禁用不必要的输出信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -sil example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将以静默模式运行，只显示查询结果。</p>
</li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>查询域名的 IP 地址</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将查询 <code>example.com</code> 的IP地址。</p>
</li>
<li><p><strong>反向查询 IP 地址</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup 8.8.8.8</span><br></pre></td></tr></table></figure>

<p>这个命令将查询IP地址 8.8.8.8 对应的域名。</p>
</li>
<li><p><strong>指定查询类型</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -querytype=mx example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将查询 <code>example.com</code> 的 MX 记录，以查找邮件服务器信息。</p>
</li>
<li><p><strong>指定 DNS 服务器</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup example.com 8.8.8.8</span><br></pre></td></tr></table></figure>

<p>这个命令将使用 Google Public DNS（8.8.8.8）来查询 <code>example.com</code> 的信息。</p>
</li>
<li><p><strong>启用调试模式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -debug example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将启用调试模式，以显示更详细的查询信息，有助于故障排除。</p>
</li>
</ol>
<p><code>nslookup</code> 命令对于网络管理员和技术支持人员来说是一个重要的工具，用于诊断域名解析问题、查找 DNS 记录、验证 DNS 配置等。通过 <code>nslookup</code>，您可以获取与域名和 IP 地址相关的重要信息，以帮助您解决各种网络问题。</p>
<h2 id="windows-cmd-tracert命令-详解"><a href="#windows-cmd-tracert命令-详解" class="headerlink" title="windows cmd tracert命令 详解"></a>windows cmd tracert命令 详解</h2><p><code>tracert</code>（或<code>traceroute</code> 在某些其他操作系统上）是 Windows 命令行中的一个实用工具，用于跟踪数据包从源主机到目标主机的路径。它通过发送数据包到目标主机，并显示这些数据包在网络上经过的路由器或跃点的详细信息。以下是 <code>tracert</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert [选项] 目标主机</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>-d</strong>：禁用对主机名的解析。通常，<code>tracert</code> 将尝试解析每个跃点的主机名，但使用 <code>-d</code> 选项会禁用这种解析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert -d example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>-h 最大跃点数</strong>：指定要跟踪的最大跃点数，即数据包可以经过的最大路由器数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert -h 30 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将跟踪数据包经过的最多 30 个跃点。</p>
</li>
<li><p><strong>-w 超时时间</strong>：设置等待每个跃点响应的超时时间（以毫秒为单位）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert -w 1000 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将设置每个跃点的超时时间为 1000 毫秒（1秒）。</p>
</li>
<li><p><strong>-4</strong>：使用 IPv4 地址进行跟踪。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert -4 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将使用 IPv4 地址进行跟踪。</p>
</li>
<li><p><strong>-6</strong>：使用 IPv6 地址进行跟踪。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert -6 ipv6.example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将使用 IPv6 地址进行跟踪。</p>
</li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>跟踪到目标主机</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将显示数据包从源主机到 <code>example.com</code> 经过的每个跃点的详细信息，包括IP地址、主机名（如果解析成功）、响应时间等。</p>
</li>
<li><p><strong>禁用主机名解析</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert -d example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将禁用对每个跃点主机名的解析，只显示IP地址。</p>
</li>
<li><p><strong>指定最大跃点数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert -h 30 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将设置最大跃点数为 30，以限制跟踪的路由器数量。</p>
</li>
<li><p><strong>设置超时时间</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert -w 1000 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将设置每个跃点的超时时间为 1000 毫秒（1秒）。</p>
</li>
<li><p><strong>跟踪 IPv6 目标</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert -6 ipv6.example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将使用 IPv6 地址进行跟踪。</p>
</li>
</ol>
<p><code>tracert</code> 命令用于诊断网络连接问题，了解数据包在网络中的路径，以及检测可能存在的网络延迟。它对于排除网络问题、查找故障点以及了解网络拓扑结构非常有用。在使用时，请注意某些网络上可能会阻止 <code>tracert</code> 请求，因此不一定能够成功跟踪到所有目标主机。</p>
<h2 id="windows-cmd-ping命令-详解"><a href="#windows-cmd-ping命令-详解" class="headerlink" title="windows cmd ping命令 详解"></a>windows cmd ping命令 详解</h2><p><code>ping</code> 命令是 Windows 命令行中的一个实用工具，用于测试计算机网络之间的连接性。它通过向目标主机发送网络探测请求（通常是 ICMP Echo 请求），并等待目标主机的响应来确定目标主机是否可达以及网络连接是否正常。以下是 <code>ping</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [选项] 目标主机</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>-t</strong>：持续 Ping。连续发送 Ping 请求，直到手动停止（Ctrl+C）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -t example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>-n 数字</strong>：发送指定数量的 Ping 请求后停止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -n 5 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将发送 5 个 Ping 请求后停止。</p>
</li>
<li><p><strong>-l 大小</strong>：设置 Ping 数据包的大小（以字节为单位）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -l 64 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将使用 64 字节的 Ping 数据包。</p>
</li>
<li><p><strong>-w 超时</strong>：设置 Ping 请求的超时时间（以毫秒为单位）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -w 2000 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将设置 Ping 请求的超时时间为 2000 毫秒（2秒）。</p>
</li>
<li><p><strong>-4</strong>：使用 IPv4 地址进行 Ping。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -4 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将使用 IPv4 地址进行 Ping。</p>
</li>
<li><p><strong>-6</strong>：使用 IPv6 地址进行 Ping。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -6 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将使用 IPv6 地址进行 Ping。</p>
</li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>Ping 目标主机</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将发送 Ping 请求到 <code>example.com</code>，并显示每个请求的响应时间（往返时间）以及是否收到响应。</p>
</li>
<li><p><strong>持续 Ping 目标主机</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -t example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将持续发送 Ping 请求到 <code>example.com</code>，直到手动停止（按下 Ctrl+C）。</p>
</li>
<li><p><strong>指定 Ping 请求数量</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -n 5 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将发送 5 个 Ping 请求到 <code>example.com</code> 并显示结果。</p>
</li>
<li><p><strong>设置 Ping 数据包大小</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -l 64 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将使用 64 字节的 Ping 数据包进行 Ping 测试。</p>
</li>
<li><p><strong>设置 Ping 超时时间</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -w 2000 example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将设置 Ping 请求的超时时间为 2000 毫秒（2秒）。</p>
</li>
<li><p><strong>Ping IPv6 目标</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -6 ipv6.example.com</span><br></pre></td></tr></table></figure>

<p>这个命令将使用 IPv6 地址进行 Ping 测试。</p>
</li>
</ol>
<p><code>ping</code> 命令用于检测计算机与目标主机之间的网络连接性和延迟。它通常用于故障排除网络问题，检查网络是否正常工作以及测量网络响应时间。请注意，某些目标主机或网络防火墙可能会阻止 Ping 请求或禁用 ICMP Echo 响应，因此不一定能够成功 Ping 到所有主机。</p>
<h2 id="windows-cmd-taskkill命令-详解"><a href="#windows-cmd-taskkill命令-详解" class="headerlink" title="windows cmd taskkill命令 详解"></a>windows cmd taskkill命令 详解</h2><p><code>taskkill</code> 命令是 Windows 命令行中的一个实用工具，用于终止或结束正在运行的进程。它允许用户通过进程名称或进程ID（PID）来停止特定的进程。以下是 <code>taskkill</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill [/s 服务器] [/u 用户名 [/p [密码]]] [/fi 过滤条件] [/pid PID | /im 图像名称] [/f] [/t]</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>&#x2F;s 服务器</strong>：指定要在远程服务器上终止进程的名称或IP地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /s RemoteServer</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;u 用户名</strong>：指定用于远程服务器的用户身份验证的用户名。可以与 <code>/p</code> 选项一起使用来提供密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /s RemoteServer /u User1</span><br></pre></td></tr></table></figure>
</li>
<li><p>**&#x2F;p [密码]**：提供与指定用户名相关联的密码。如果未提供密码，系统将提示您输入密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /s RemoteServer /u User1 /p Password123</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;fi 过滤条件</strong>：允许使用过滤条件来限制要终止的进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /fi &quot;IMAGENAME eq notepad.exe&quot;</span><br></pre></td></tr></table></figure>

<p>这个命令将终止所有名称为 “notepad.exe” 的进程。</p>
</li>
<li><p><strong>&#x2F;pid PID</strong>：指定要终止的进程的PID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /pid 1234</span><br></pre></td></tr></table></figure>

<p>这个命令将终止PID为 1234 的进程。</p>
</li>
<li><p><strong>&#x2F;im 图像名称</strong>：指定要终止的进程的图像名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /im notepad.exe</span><br></pre></td></tr></table></figure>

<p>这个命令将终止名称为 “notepad.exe” 的进程。</p>
</li>
<li><p><strong>&#x2F;f</strong>：强制终止进程，而不显示确认提示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /f /im notepad.exe</span><br></pre></td></tr></table></figure>

<p>这个命令将强制终止名称为 “notepad.exe” 的进程。</p>
</li>
<li><p><strong>&#x2F;t</strong>：终止进程及其子进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /t /f /pid 1234</span><br></pre></td></tr></table></figure>

<p>这个命令将终止PID为 1234 的进程及其所有子进程。</p>
</li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>终止指定进程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /im notepad.exe</span><br></pre></td></tr></table></figure>

<p>这个命令将终止所有名称为 “notepad.exe” 的进程。</p>
</li>
<li><p><strong>终止指定PID的进程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /pid 1234</span><br></pre></td></tr></table></figure>

<p>这个命令将终止PID为 1234 的进程。</p>
</li>
<li><p><strong>强制终止指定进程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /f /im notepad.exe</span><br></pre></td></tr></table></figure>

<p>这个命令将强制终止所有名称为 “notepad.exe” 的进程，而不显示确认提示。</p>
</li>
<li><p><strong>终止远程服务器上的进程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /s RemoteServer /u User1 /p Password123 /im notepad.exe</span><br></pre></td></tr></table></figure>

<p>这个命令将连接到远程服务器 <code>RemoteServer</code> 并终止该服务器上名称为 “notepad.exe” 的进程。</p>
</li>
</ol>
<p><code>taskkill</code> 命令对于终止不响应的或问题进程非常有用。请小心使用 <code>/f</code> 选项，因为它会强制终止进程，可能会导致数据丢失或不稳定的系统行为。确保在终止进程之前备份重要数据。根据需要使用不同的选项和过滤条件来自定义操作。</p>
<h2 id="windows-cmd-tasklist命令-详解"><a href="#windows-cmd-tasklist命令-详解" class="headerlink" title="windows cmd tasklist命令 详解"></a>windows cmd tasklist命令 详解</h2><p><code>tasklist</code> 命令是 Windows 命令行中的一个实用工具，用于显示当前正在运行的进程列表以及与这些进程相关的详细信息。它允许用户查看正在运行的进程的名称、进程ID（PID）、内存使用情况、会话ID、进程状态等。以下是 <code>tasklist</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist [/s 服务器] [/u 用户名 [/p [密码]]] [/fo &#123;table|list|csv&#125;] [/nh] [/v] [/fi 过滤条件]</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>&#x2F;s 服务器</strong>：指定要查询进程信息的远程服务器的名称或IP地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /s RemoteServer</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;u 用户名</strong>：指定用于远程服务器的用户身份验证的用户名。可以与 <code>/p</code> 选项一起使用来提供密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /s RemoteServer /u User1</span><br></pre></td></tr></table></figure>
</li>
<li><p>**&#x2F;p [密码]**：提供与指定用户名相关联的密码。如果未提供密码，系统将提示您输入密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /s RemoteServer /u User1 /p Password123</span><br></pre></td></tr></table></figure>
</li>
<li><p>**&#x2F;fo {table|list|csv}**：指定输出格式。可以选择输出格式为表格（table，默认）、列表（list）或CSV文件（csv）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /fo csv</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;nh</strong>：在输出中隐藏标题行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /nh</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;v</strong>：显示详细信息，包括进程的窗口标题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /v</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;fi 过滤条件</strong>：允许使用过滤条件来限制要显示的进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /fi &quot;STATUS eq running&quot;</span><br></pre></td></tr></table></figure>

<p>这个命令将显示状态为 “running” 的所有进程。</p>
</li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>列出所有正在运行的进程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br></pre></td></tr></table></figure>

<p>这个命令将显示当前计算机上所有正在运行的进程的列表。</p>
</li>
<li><p><strong>以列表格式显示进程信息</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /fo list</span><br></pre></td></tr></table></figure>

<p>这个命令将以列表格式显示进程信息，包括进程名称、PID、会话ID等。</p>
</li>
<li><p><strong>显示详细信息，包括窗口标题</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /v</span><br></pre></td></tr></table></figure>

<p>这个命令将显示进程的详细信息，包括窗口标题、内存使用情况等。</p>
</li>
<li><p><strong>查询远程服务器上的进程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /s RemoteServer /u User1 /p Password123</span><br></pre></td></tr></table></figure>

<p>这个命令将连接到远程服务器 <code>RemoteServer</code>，并使用提供的用户名和密码查询远程服务器上的进程信息。</p>
</li>
<li><p><strong>根据过滤条件筛选进程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /fi &quot;STATUS eq running&quot;</span><br></pre></td></tr></table></figure>

<p>这个命令将显示状态为 “running” 的所有进程。</p>
</li>
</ol>
<p><code>tasklist</code> 命令对于查看当前系统中正在运行的进程以及其详细信息非常有用。它经常用于故障排除、监视系统性能和管理进程。您可以根据需要使用不同的选项和过滤条件来自定义查询。</p>
<h2 id="windows-cmd-ipconfig命令-详解"><a href="#windows-cmd-ipconfig命令-详解" class="headerlink" title="windows cmd ipconfig命令 详解"></a>windows cmd ipconfig命令 详解</h2><p><code>ipconfig</code>（Internet Protocol Configuration）是Windows操作系统中的命令行工具，用于显示计算机的网络配置信息。它提供了有关计算机网络接口、IP地址、子网掩码、默认网关、DNS服务器和其他网络相关信息的详细报告。以下是<code>ipconfig</code>命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig [/all] [/renew] [/release] [/flushdns] [/displaydns] [/registerdns] [/showclassid] [连接名称]</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>&#x2F;all</strong>：显示详细的网络配置信息，包括连接名称、物理地址（MAC地址）、IP地址、子网掩码、默认网关、DHCP服务器、DNS服务器等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;renew</strong>：刷新 DHCP 租约，用于从 DHCP 服务器获取新的 IP 地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /renew</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;release</strong>：释放当前的 DHCP 租约，使计算机不再使用当前的 IP 地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /release</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;flushdns</strong>：清除本地 DNS 缓存，用于刷新DNS解析记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;displaydns</strong>：显示本地 DNS 缓存中的所有 DNS 记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /displaydns</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;registerdns</strong>：向 DNS 服务器注册计算机的新 DNS 记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /registerdns</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;showclassid</strong>：显示 DHCP 客户端 ID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /showclassid</span><br></pre></td></tr></table></figure></li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>查看网络配置信息</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<p>这个命令将显示当前网络连接的基本配置信息，包括本地连接的IP地址、子网掩码、默认网关等。</p>
</li>
<li><p><strong>显示详细网络配置信息</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure>

<p>这个命令将显示所有可用网络连接的详细信息，包括物理地址、DHCP信息、DNS信息等。</p>
</li>
<li><p><strong>刷新 DHCP 租约</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /renew</span><br></pre></td></tr></table></figure>

<p>这个命令将尝试刷新 DHCP 租约，以获取新的 IP 地址。</p>
</li>
<li><p><strong>释放 DHCP 租约</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /release</span><br></pre></td></tr></table></figure>

<p>这个命令将释放当前的 DHCP 租约，使计算机不再使用当前的 IP 地址。</p>
</li>
<li><p><strong>清除 DNS 缓存</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>

<p>这个命令将清除本地 DNS 缓存，以帮助刷新 DNS 解析记录。</p>
</li>
</ol>
<p><code>ipconfig</code> 命令对于网络故障排除、检查网络配置和获取有关计算机网络状态的信息非常有用。通过查看<code>ipconfig</code>输出，您可以了解计算机连接到网络的方式以及它的网络参数设置。</p>
<h2 id="windows-cmd-systeminfo命令-详解"><a href="#windows-cmd-systeminfo命令-详解" class="headerlink" title="windows cmd systeminfo命令 详解"></a>windows cmd systeminfo命令 详解</h2><p><code>systeminfo</code> 命令是 Windows 命令行中的一个实用工具，用于显示有关计算机系统的详细信息。它提供了大量关于操作系统、硬件、网络配置等的信息。以下是 <code>systeminfo</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure>

<p>常见用法和输出示例：</p>
<p><code>systeminfo</code> 命令不需要任何参数或选项，只需在命令提示符下键入<code>systeminfo</code>并按 Enter 键即可获得系统信息的详细列表。</p>
<p>输出示例包括以下信息：</p>
<ol>
<li><p><strong>主机名</strong>：计算机的名称。</p>
</li>
<li><p><strong>OS 名称</strong>：操作系统的名称（例如，Windows 10 Pro）。</p>
</li>
<li><p><strong>OS 版本</strong>：操作系统的版本号。</p>
</li>
<li><p><strong>OS 制造商</strong>：操作系统的制造商。</p>
</li>
<li><p><strong>OS 配置</strong>：操作系统的配置（例如，独立工作站）。</p>
</li>
<li><p><strong>OS 构建类型</strong>：操作系统的构建类型（例如，Multiprocessor Free）。</p>
</li>
<li><p><strong>注册的所有人</strong>：操作系统的注册所有者。</p>
</li>
<li><p><strong>注册的组织</strong>：操作系统的注册组织。</p>
</li>
<li><p><strong>产品 ID</strong>：操作系统的产品 ID。</p>
</li>
<li><p><strong>初始安装日期</strong>：操作系统的初始安装日期。</p>
</li>
<li><p><strong>系统启动时间</strong>：计算机的最后一次启动时间。</p>
</li>
<li><p><strong>系统制造商</strong>：计算机制造商的名称。</p>
</li>
<li><p><strong>系统型号</strong>：计算机型号。</p>
</li>
<li><p><strong>系统类型</strong>：计算机的类型（例如，x64-based PC）。</p>
</li>
<li><p><strong>处理器</strong>：安装在计算机上的处理器的详细信息。</p>
</li>
<li><p><strong>BIOS 版本</strong>：计算机的 BIOS 版本。</p>
</li>
<li><p><strong>Windows 目录</strong>：Windows 操作系统文件的目录路径。</p>
</li>
<li><p><strong>系统目录</strong>：Windows 系统文件的目录路径。</p>
</li>
<li><p><strong>启动设备</strong>：计算机的启动设备，例如硬盘驱动器。</p>
</li>
<li><p><strong>系统语言</strong>：操作系统的当前语言。</p>
</li>
<li><p><strong>系统上的用户</strong>：当前登录到计算机的用户列表。</p>
</li>
<li><p><strong>网络适配器</strong>：计算机上安装的网络适配器的信息。</p>
</li>
<li><p><strong>热固件替代成功数</strong>：成功加载的热固件替代数目。</p>
</li>
</ol>
<p><code>systeminfo</code> 命令可用于获取有关计算机系统的详细信息，这对于系统管理员和技术支持人员来说非常有用。您可以将输出导出到文本文件以进行进一步的分析，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo &gt; systeminfo.txt</span><br></pre></td></tr></table></figure>

<p>这会将系统信息保存到名为 <code>systeminfo.txt</code> 的文本文件中，以便稍后查看或共享。无论您是在排除故障、维护计算机，还是只是想了解计算机的配置，<code>systeminfo</code> 都是一个有用的工具。</p>
<h2 id="windows-cmd-move命令-详解"><a href="#windows-cmd-move命令-详解" class="headerlink" title="windows cmd move命令 详解"></a>windows cmd move命令 详解</h2><p><code>move</code> 命令用于在 Windows 命令行中移动文件或目录。它允许您将文件或目录从一个位置移动到另一个位置，也可以用于重命名文件或目录。以下是 <code>move</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move [选项] [源文件或目录] [目标文件或目录]</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>&#x2F;Y</strong>：在移动文件时，不提示确认，直接覆盖目标文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move /Y source.txt destination.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>source.txt</code> 移动到 <code>destination.txt</code>，如果 <code>destination.txt</code> 已经存在，则会直接覆盖。</p>
</li>
<li><p><strong>&#x2F;-Y</strong>：在移动文件时，不提示确认，如果目标文件存在则不执行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move /-Y source.txt destination.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>source.txt</code> 移动到 <code>destination.txt</code>，但如果 <code>destination.txt</code> 已经存在，则不执行操作。</p>
</li>
<li><p>**&#x2F;?**：显示帮助信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move /?</span><br></pre></td></tr></table></figure>

<p>这个命令将显示 <code>move</code> 命令的帮助信息，包括选项和用法示例。</p>
</li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>移动文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move source.txt destination.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>source.txt</code> 移动到 <code>destination.txt</code>，同时也可以用于重命名文件。</p>
</li>
<li><p><strong>移动文件到另一个目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move source.txt C:\Backup\</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>source.txt</code> 移动到 <code>C:\Backup\</code> 目录下。</p>
</li>
<li><p><strong>重命名文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move oldfile.txt newfile.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>oldfile.txt</code> 重命名为 <code>newfile.txt</code>。</p>
</li>
<li><p><strong>移动目录及其内容</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move C:\Source\ C:\Destination\</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>C:\Source\</code> 目录及其所有内容移动到 <code>C:\Destination\</code> 目录下。也可以用于重命名目录。</p>
</li>
</ol>
<p>请注意，在移动文件或目录时，请确保源文件或目录存在，目标文件或目录的路径是有效的，以及您具有适当的权限来执行移动操作。 <code>move</code> 命令允许您在文件系统中管理文件和目录的位置，但请小心使用，以避免意外覆盖或删除重要数据。</p>
<h2 id="windows-cmd-copy命令-详解"><a href="#windows-cmd-copy命令-详解" class="headerlink" title="windows cmd copy命令 详解"></a>windows cmd copy命令 详解</h2><p><code>copy</code> 命令用于在 Windows 命令行中复制文件或目录。它允许您创建文件和目录的副本，以便在不改变原始文件的情况下进行备份或操作。以下是 <code>copy</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy [选项] [源文件或目录] [目标文件或目录]</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>&#x2F;Y</strong>：在复制文件时，不提示确认，直接覆盖目标文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy /Y source.txt destination.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>source.txt</code> 复制到 <code>destination.txt</code>，如果 <code>destination.txt</code> 已经存在，则会直接覆盖。</p>
</li>
<li><p><strong>&#x2F;V</strong>：验证复制的文件，以确保文件复制成功。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy /V source.txt destination.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将复制 <code>source.txt</code> 到 <code>destination.txt</code>，并验证文件是否成功复制。</p>
</li>
<li><p><strong>&#x2F;B</strong>：以二进制模式复制文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy /B source.bin destination.bin</span><br></pre></td></tr></table></figure>

<p>这个命令将以二进制模式复制 <code>source.bin</code> 到 <code>destination.bin</code>。</p>
</li>
<li><p><strong>&#x2F;Z</strong>：在网络拷贝中使用 Restartable Mode（可重新启动模式）。用于大文件的复制，以在复制过程中出现网络中断时恢复复制操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy /Z source.txt destination.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将以可重新启动模式复制 <code>source.txt</code> 到 <code>destination.txt</code>。</p>
</li>
<li><p>**&#x2F;?**：显示帮助信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy /?</span><br></pre></td></tr></table></figure>

<p>这个命令将显示 <code>copy</code> 命令的帮助信息，包括选项和用法示例。</p>
</li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>复制单个文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy source.txt destination.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>source.txt</code> 复制到 <code>destination.txt</code>。</p>
</li>
<li><p><strong>复制文件到另一个目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy source.txt C:\Backup\</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>source.txt</code> 复制到 <code>C:\Backup\</code> 目录下。</p>
</li>
<li><p><strong>复制多个文件到目标目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy file1.txt file2.txt C:\Destination\</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>file1.txt</code> 和 <code>file2.txt</code> 复制到 <code>C:\Destination\</code> 目录下。</p>
</li>
<li><p><strong>复制目录及其内容</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy /Y /S C:\Source\ C:\Destination\</span><br></pre></td></tr></table></figure>

<p>这个命令将 <code>C:\Source\</code> 目录及其所有内容复制到 <code>C:\Destination\</code> 目录下。</p>
</li>
</ol>
<p>请注意，在复制文件或目录时，请确保源文件或目录存在，目标文件或目录的路径是有效的，以及您具有适当的权限来执行复制操作。 <code>copy</code> 命令是用于文件和目录操作的强大工具，但在使用时请小心，以避免意外覆盖或删除重要数据。</p>
<h2 id="windows-cmd-del命令-详解"><a href="#windows-cmd-del命令-详解" class="headerlink" title="windows cmd del命令 详解"></a>windows cmd del命令 详解</h2><p><code>del</code> 命令用于在 Windows 命令行中删除文件。它允许您删除不再需要的文件，但要小心，因为删除文件是不可逆的操作。以下是 <code>del</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del [选项] [文件名或路径]</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>&#x2F;F</strong>：强制删除文件，即使文件是只读的或受保护的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del /F filename.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将强制删除 <code>filename.txt</code> 文件，即使它是只读的。</p>
</li>
<li><p><strong>&#x2F;Q</strong>：以安静模式删除文件，不显示删除的消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del /Q file.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将删除 <code>file.txt</code> 文件，并且不会显示任何输出。</p>
</li>
<li><p><strong>&#x2F;P</strong>：要求用户确认删除操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del /P file.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将提示用户确认是否要删除 <code>file.txt</code> 文件。</p>
</li>
<li><p><strong>&#x2F;S</strong>：递归删除文件，用于删除目录及其所有子目录和文件中的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del /S /Q C:\Example\*</span><br></pre></td></tr></table></figure>

<p>这个命令将递归删除 <code>C:\Example</code> 目录及其所有子目录和文件中的所有文件。</p>
</li>
<li><p>**&#x2F;?**：显示帮助信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del /?</span><br></pre></td></tr></table></figure>

<p>这个命令将显示 <code>del</code> 命令的帮助信息，包括选项和用法示例。</p>
</li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>删除单个文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del file.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将删除名为 <code>file.txt</code> 的文件。</p>
</li>
<li><p><strong>删除多个文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del file1.txt file2.txt file3.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将删除多个指定的文件。</p>
</li>
<li><p><strong>删除目录中的文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del C:\Example\*.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将删除 <code>C:\Example</code> 目录中所有扩展名为 <code>.txt</code> 的文件。</p>
</li>
<li><p><strong>递归删除目录中的文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del /S /Q C:\Example\*</span><br></pre></td></tr></table></figure>

<p>这个命令将递归删除 <code>C:\Example</code> 目录及其所有子目录和文件中的所有文件。</p>
</li>
<li><p><strong>删除只读文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del /F Read-only.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将强制删除只读文件 <code>Read-only.txt</code>。</p>
</li>
</ol>
<p>请小心使用 <code>del</code> 命令，特别是在使用 <code>/F</code> 选项时，因为删除操作是不可逆的，且会永久删除文件。确保在删除文件之前备份重要数据，以防止意外丢失。如果尝试删除需要管理员权限的文件，可能需要以管理员身份运行命令提示符。</p>
<h2 id="windows-cmd-rmdir命令-详解"><a href="#windows-cmd-rmdir命令-详解" class="headerlink" title="windows cmd rmdir命令 详解"></a>windows cmd rmdir命令 详解</h2><p><code>rmdir</code> 命令用于在 Windows 命令行中删除目录（文件夹）。它允许您删除不再需要的目录，但要小心，因为删除目录可能会导致数据丢失。以下是 <code>rmdir</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [选项] [目录路径]</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>&#x2F;S</strong>：删除目录及其子目录和文件。这是递归删除的选项，用于删除整个目录树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /S C:\Example</span><br></pre></td></tr></table></figure>

<p>这个命令将删除 <code>C:\Example</code> 目录及其所有子目录和文件。</p>
</li>
<li><p><strong>&#x2F;Q</strong>：以安静模式删除目录，不显示删除的消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /Q NewFolder</span><br></pre></td></tr></table></figure>

<p>这个命令将删除名为 <code>NewFolder</code> 的目录，并且不会显示任何输出。</p>
</li>
<li><p>**&#x2F;?**：显示帮助信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /?</span><br></pre></td></tr></table></figure>

<p>这个命令将显示 <code>rmdir</code> 命令的帮助信息，包括选项和用法示例。</p>
</li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>删除空目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir EmptyFolder</span><br></pre></td></tr></table></figure>

<p>这个命令将删除名为 <code>EmptyFolder</code> 的空目录。</p>
</li>
<li><p><strong>删除目录及其内容</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /S NonEmptyFolder</span><br></pre></td></tr></table></figure>

<p>这个命令将删除名为 <code>NonEmptyFolder</code> 的目录及其所有子目录和文件。</p>
</li>
<li><p><strong>删除多个目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir Folder1 Folder2 Folder3</span><br></pre></td></tr></table></figure>

<p>这个命令将删除当前目录下的 <code>Folder1</code>、<code>Folder2</code> 和 <code>Folder3</code> 三个目录。</p>
</li>
<li><p><strong>删除只读目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /S /Q ReadOnlyFolder</span><br></pre></td></tr></table></figure>

<p>这个命令将删除只读目录 <code>ReadOnlyFolder</code> 及其所有内容，而不会提示用户进行确认。</p>
</li>
</ol>
<p>请小心使用 <code>rmdir</code> 命令，特别是在使用 <code>/S</code> 选项时，因为删除的操作是不可逆的，且会永久删除数据。确保在删除目录之前备份重要文件和数据。同样，如果尝试删除需要管理员权限的目录，可能需要以管理员身份运行命令提示符。</p>
<h2 id="windows-cmd-mkdir命令-详解"><a href="#windows-cmd-mkdir命令-详解" class="headerlink" title="windows cmd mkdir命令 详解"></a>windows cmd mkdir命令 详解</h2><p><code>mkdir</code> 命令用于在 Windows 命令行中创建新的目录（文件夹）。它允许您在文件系统中创建新的目录结构以组织文件和数据。以下是 <code>mkdir</code> 命令的基本语法和一些常见用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项] [目录路径]</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>&#x2F;P</strong>：创建目录的父目录（如果不存在）。这允许您创建具有多级子目录的目录，而无需逐级手动创建父目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /P C:\Example\Subfolder</span><br></pre></td></tr></table></figure>

<p>这个命令将创建 <code>C:\Example</code> 目录（如果不存在），然后在其中创建 <code>Subfolder</code> 子目录。</p>
</li>
<li><p><strong>&#x2F;Q</strong>：以安静模式创建目录，不显示成功创建的消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /Q NewFolder</span><br></pre></td></tr></table></figure>

<p>这个命令将创建名为 <code>NewFolder</code> 的目录，并且不会显示任何输出。</p>
</li>
<li><p>**&#x2F;?**：显示帮助信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /?</span><br></pre></td></tr></table></figure>

<p>这个命令将显示 <code>mkdir</code> 命令的帮助信息，包括选项和用法示例。</p>
</li>
</ol>
<p>常见用法：</p>
<ol>
<li><p><strong>创建单个目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir NewFolder</span><br></pre></td></tr></table></figure>

<p>这个命令将在当前目录下创建名为 <code>NewFolder</code> 的目录。</p>
</li>
<li><p><strong>创建多级目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir C:\Example\Subfolder</span><br></pre></td></tr></table></figure>

<p>这个命令将创建 <code>C:\Example</code> 目录（如果不存在），然后在其中创建 <code>Subfolder</code> 子目录。</p>
</li>
<li><p><strong>创建带有空格的目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &quot;My Documents&quot;</span><br></pre></td></tr></table></figure>

<p>这个命令将创建名为 <code>My Documents</code> 的目录，由于目录名中包含空格，因此需要用双引号括起来。</p>
</li>
<li><p><strong>创建目录并其父目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /P C:\Projects\NewProject\Subfolder</span><br></pre></td></tr></table></figure>

<p>这个命令将创建 <code>C:\Projects\NewProject</code> 目录（如果不存在），然后在其中创建 <code>Subfolder</code> 子目录。</p>
</li>
<li><p><strong>创建多个目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir Folder1 Folder2 Folder3</span><br></pre></td></tr></table></figure>

<p>这个命令将在当前目录下创建 <code>Folder1</code>、<code>Folder2</code> 和 <code>Folder3</code> 三个目录。</p>
</li>
</ol>
<p>请注意，要创建目录，您需要有适当的权限。如果尝试在需要管理员权限的位置创建目录，可能需要以管理员身份运行命令提示符。在使用 <code>mkdir</code> 命令时，要小心不要意外覆盖或删除重要数据。</p>
<h2 id="windows-cmd-cd命令-详解"><a href="#windows-cmd-cd命令-详解" class="headerlink" title="windows cmd cd命令 详解"></a>windows cmd cd命令 详解</h2><p><code>cd</code> 命令用于在 Windows 命令行中更改当前工作目录（Current Directory）。通过切换当前工作目录，您可以导航到不同的文件夹，执行操作或运行命令。以下是 <code>cd</code> 命令的基本语法和一些常见的用法：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [目录路径]</span><br></pre></td></tr></table></figure>

<p>常见用法：</p>
<ol>
<li><p><strong>进入指定目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Example</span><br></pre></td></tr></table></figure>

<p>这个命令将当前工作目录更改为 <code>C:\Example</code> 目录。您可以指定绝对路径或相对路径。</p>
</li>
<li><p><strong>返回上一级目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<p>这个命令将当前工作目录更改为上一级目录。使用 <code>..</code> 表示上一级目录。</p>
</li>
<li><p><strong>返回根目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd \</span><br></pre></td></tr></table></figure>

<p>这个命令将当前工作目录更改为根目录，通常是 <code>C:\</code>。</p>
</li>
<li><p><strong>返回用户主目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd %userprofile%</span><br></pre></td></tr></table></figure>

<p>这个命令将当前工作目录更改为当前用户的主目录，通常是 <code>C:\Users\&lt;用户名&gt;</code>。</p>
</li>
<li><p><strong>切换驱动器</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /d D:\</span><br></pre></td></tr></table></figure>

<p>这个命令将当前工作目录更改到 <code>D:\</code> 驱动器。</p>
</li>
<li><p><strong>显示当前工作目录</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br></pre></td></tr></table></figure>

<p>这个命令将显示当前工作目录的完整路径。</p>
</li>
<li><p><strong>使用相对路径</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd Documents\Project</span><br></pre></td></tr></table></figure>

<p>这个命令将当前工作目录更改为当前目录下的 <code>Documents\Project</code> 子目录。</p>
</li>
<li><p><strong>使用通配符</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd D:\Files\*.*</span><br></pre></td></tr></table></figure>

<p>这个命令将当前工作目录更改为 <code>D:\Files</code> 目录，并在其中显示所有文件和子目录。</p>
</li>
</ol>
<p>请注意以下几点：</p>
<ul>
<li><p>当使用带有空格的目录路径时，应将路径用双引号括起来，以确保命令正确解释。例如：<code>cd &quot;C:\Program Files&quot;</code></p>
</li>
<li><p><code>cd</code> 命令不仅用于导航，还可以在脚本中用于更改工作目录以执行某些操作。</p>
</li>
<li><p>在命令行窗口中，可以使用 Tab 键来自动补全文件夹和文件名，以减少输入错误。</p>
</li>
<li><p>使用 <code>cd</code> 命令时，请小心不要误删除或误移动文件，特别是在管理员权限下运行命令时。备份重要文件和目录是一个明智的做法。</p>
</li>
</ul>
<h2 id="windows-cmd-dir命令-详解"><a href="#windows-cmd-dir命令-详解" class="headerlink" title="windows cmd dir命令 详解"></a>windows cmd dir命令 详解</h2><p><code>dir</code> 是 Windows 命令行中用于列出目录中文件和子目录的命令。它还提供了一些选项，以定制显示文件和目录的方式。以下是 <code>dir</code> 命令的基本语法以及一些常见选项的详细说明：</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir [选项] [目录路径]</span><br></pre></td></tr></table></figure>

<p>常见选项：</p>
<ol>
<li><p><strong>&#x2F;P</strong>：按页显示文件和目录，每页显示一屏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /P</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;W</strong>：以宽格式显示文件和目录，每行显示多个条目。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /W</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;A:属性</strong>：根据文件或目录的属性筛选显示结果。属性可以是：</p>
<ul>
<li><strong>D</strong>：目录</li>
<li><strong>A</strong>：存档</li>
<li><strong>H</strong>：隐藏</li>
<li><strong>R</strong>：只读</li>
<li><strong>S</strong>：系统</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /A:H</span><br></pre></td></tr></table></figure>

<p>这个命令将只显示隐藏属性的文件和目录。</p>
</li>
<li><p><strong>&#x2F;S</strong>：递归列出目录中的所有子目录的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /S</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;B</strong>：以简单格式显示文件和目录的列表，不包括详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /B</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;O:排序顺序</strong>：按指定的排序顺序显示文件和目录。排序顺序可以是：</p>
<ul>
<li><strong>N</strong>：按名称（默认）</li>
<li><strong>E</strong>：按扩展名</li>
<li><strong>S</strong>：按文件大小</li>
<li><strong>D</strong>：按日期&#x2F;时间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /O:S</span><br></pre></td></tr></table></figure>

<p>这个命令将文件按大小顺序显示。</p>
</li>
<li><p><strong>&#x2F;T:日期或时间</strong>：按指定的日期或时间筛选文件和目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /T:W</span><br></pre></td></tr></table></figure>

<p>这个命令将按最后修改时间筛选文件和目录。</p>
</li>
<li><p><strong>&#x2F;R</strong>：以逆序排序顺序显示文件和目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /R</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;L</strong>：以小写形式显示文件和目录的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /L</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;X</strong>：显示短文件名（8.3 格式）以及长文件名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /X</span><br></pre></td></tr></table></figure>
</li>
<li><p>**&#x2F;?**：显示帮助信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /?</span><br></pre></td></tr></table></figure></li>
</ol>
<p>示例：</p>
<ul>
<li><p>显示当前目录中的所有文件和子目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示指定目录中的文件和子目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir C:\Users</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示当前目录中的隐藏文件和子目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /A:H</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归显示当前目录及其所有子目录中的文件和子目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /S</span><br></pre></td></tr></table></figure>
</li>
<li><p>按文件大小递归显示当前目录及其所有子目录中的文件，并按逆序排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /S /O:-S</span><br></pre></td></tr></table></figure></li>
</ul>
<p>请注意，<code>dir</code> 命令提供了许多选项，可根据需要进行组合，以满足不同的文件和目录查看需求。</p>
<h2 id="windows-cmd-ren命令-详解"><a href="#windows-cmd-ren命令-详解" class="headerlink" title="windows cmd ren命令 详解"></a>windows cmd ren命令 详解</h2><p><code>ren</code>（也可以写作<code>rename</code>）是Windows命令行中用于重命名文件或文件夹的命令。它的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren [旧文件名或路径] [新文件名或路径]</span><br></pre></td></tr></table></figure>

<p>以下是<code>ren</code>命令的一些常见用法和详细说明：</p>
<ol>
<li><p><strong>重命名文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren oldfile.txt newfile.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将文件<code>oldfile.txt</code>重命名为<code>newfile.txt</code>。</p>
</li>
<li><p><strong>重命名文件夹</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren &quot;old folder&quot; &quot;new folder&quot;</span><br></pre></td></tr></table></figure>

<p>这个命令将文件夹<code>old folder</code>重命名为<code>new folder</code>。如果文件夹名称包含空格，需要用引号括起来。</p>
</li>
<li><p><strong>批量重命名文件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren *.txt *.bak</span><br></pre></td></tr></table></figure>

<p>这个命令将当前目录下所有扩展名为<code>.txt</code>的文件都重命名为相同的名称，扩展名变为<code>.bak</code>。</p>
</li>
<li><p><strong>移动文件并重命名</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren &quot;C:\folder\file.txt&quot; &quot;D:\newfolder\newfile.txt&quot;</span><br></pre></td></tr></table></figure>

<p>这个命令将文件<code>C:\folder\file.txt</code>移动到<code>D:\newfolder</code>目录并将其重命名为<code>newfile.txt</code>。</p>
</li>
<li><p><strong>重命名文件并保留扩展名</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren file.txt newname.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将文件<code>file.txt</code>重命名为<code>newname.txt</code>，但保留原始文件的扩展名。</p>
</li>
<li><p><strong>重命名文件夹并移动</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren &quot;C:\oldfolder&quot; &quot;D:\newfolder&quot;</span><br></pre></td></tr></table></figure>

<p>这个命令将文件夹<code>C:\oldfolder</code>重命名为<code>newfolder</code>并移动到<code>D:</code>驱动器下。</p>
</li>
<li><p><strong>重命名文件夹并保留子文件夹结构</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for /r &quot;C:\source&quot; %I in (*) do @ren &quot;%I&quot; &quot;%~nI_new%~xI&quot;</span><br></pre></td></tr></table></figure>

<p>这个命令通过使用<code>for</code>循环来重命名指定目录（<code>C:\source</code>）中的所有文件和文件夹，保留原始的子文件夹结构。</p>
</li>
<li><p><strong>查看帮助信息</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren /?</span><br></pre></td></tr></table></figure>

<p>这个命令将显示<code>ren</code>命令的帮助信息，包括各种选项和用法示例。</p>
</li>
</ol>
<p>请注意，使用<code>ren</code>命令时要小心，特别是在批处理脚本中，因为错误的重命名操作可能导致数据丢失或不可逆的更改。建议在使用前备份重要文件。</p>
<h2 id="windows-net-命令-详解"><a href="#windows-net-命令-详解" class="headerlink" title="windows net 命令 详解"></a>windows net 命令 详解</h2><p>Windows的<code>net</code>命令是一个用于管理网络连接和资源的命令行工具。它提供了一系列的子命令，用于执行各种网络相关的任务。以下是一些常见的<code>net</code>命令及其功能的详解：</p>
<ol>
<li><p><code>net use</code>：用于连接或断开网络共享资源。它的一些常见用法包括：</p>
<ul>
<li><code>net use drive_letter: \\computer\share</code>：将网络共享连接到本地驱动器。</li>
<li><code>net use \\computer\share /delete</code>：断开与网络共享的连接。</li>
<li><code>net use</code>：显示当前的网络连接。</li>
</ul>
</li>
<li><p><code>net view</code>：用于查看本地或远程计算机上的共享资源。例如，<code>net view \\computer</code>将列出远程计算机上的共享文件夹。</p>
</li>
<li><p><code>net user</code>：用于管理Windows用户账户。一些常见用法包括：</p>
<ul>
<li><code>net user username</code>：显示有关指定用户的信息。</li>
<li><code>net user username password /add</code>：添加新用户。</li>
<li><code>net user username /delete</code>：删除用户。</li>
</ul>
</li>
<li><p><code>net group</code>：用于管理用户组。例如，<code>net group Administrators</code>将显示有关Administrators组的信息。</p>
</li>
<li><p><code>net share</code>：用于管理本地计算机上的共享资源。例如，<code>net share sharename=folder_path</code>将共享指定文件夹。</p>
</li>
<li><p><code>net send</code>：用于向其他计算机发送消息。这个命令已经在较新版本的Windows中不再支持，因为它的安全性方面存在问题。</p>
</li>
<li><p><code>net start</code>和<code>net stop</code>：用于启动和停止Windows服务。例如，<code>net start servicename</code>将启动指定的服务。</p>
</li>
<li><p><code>net time</code>：用于显示或设置计算机的时间。例如，<code>net time \\computer</code>将显示远程计算机的时间。</p>
</li>
<li><p><code>net statistics</code>：用于查看网络统计信息，如连接数和数据包传输情况。</p>
</li>
<li><p><code>net localgroup</code>：用于管理本地组，如添加或删除组成员。</p>
</li>
<li><p><code>net use</code>：用于查看、添加和删除持久网络映射。</p>
</li>
</ol>
<p>这些只是<code>net</code>命令的一些常见用法，Windows的<code>net</code>命令提供了更多功能和选项，可以通过在命令提示符中输入<code>net /?</code>来查看帮助信息，以获取更多详细的命令说明和选项列表。</p>
<h2 id="查看账户"><a href="#查看账户" class="headerlink" title="查看账户"></a>查看账户</h2><ul>
<li><p>查看所有账户</p>
<ul>
<li>net user</li>
</ul>
</li>
<li><p>查看指定账户的所有信息</p>
<ul>
<li>net user zhangjunyi</li>
</ul>
</li>
</ul>
<h2 id="启动ssh服务"><a href="#启动ssh服务" class="headerlink" title="启动ssh服务"></a>启动ssh服务</h2><ul>
<li>net start sshd</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Xenomai/2024-05-22-xenomai_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Xenomai/2024-05-22-xenomai_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">xenomai_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Xenomai/" itemprop="url" rel="index"><span itemprop="name">Xenomai</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>xenomai的相关理论基础</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/Xenomai/2024-05-22-xenomai_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Windows/2024-05-22-windows_03_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Windows/2024-05-22-windows_03_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">windows_03_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>windows系统下常用技巧</li>
</ul>
<h2 id="C-kbhit-函数-详解"><a href="#C-kbhit-函数-详解" class="headerlink" title="C _kbhit() 函数 详解"></a>C _kbhit() 函数 详解</h2><p><code>_kbhit()</code> 是 C 语言中一个常用的非标准库函数，通常在 Windows 平台上使用，包含在 <code>&lt;conio.h&gt;</code> 头文件中。它的作用是检查键盘缓冲区是否有按键被按下，而不需要等待用户输入。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> _kbhit(<span class="type">void</span>);</span><br></pre></td></tr></table></figure>

<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><strong>检查键盘输入</strong>：<code>_kbhit()</code> 函数会返回一个非零值（通常为 1），表示键盘缓冲区中有按键事件发生。</li>
<li><strong>非阻塞</strong>：与 <code>getch()</code> 不同，<code>_kbhit()</code> 是非阻塞的，调用时不会暂停程序运行。如果没有按键按下，它立即返回 <code>0</code>。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><strong>非零值</strong>：键盘缓冲区有按键输入。</li>
<li><strong>0</strong>：键盘缓冲区无按键输入。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>_kbhit()</code> 常用于需要实时检测键盘输入的程序，例如游戏编程、实时控制程序或某些交互式控制台应用。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个简单的使用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Press any key to exit...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_kbhit()) &#123; <span class="comment">// 检测到键盘输入</span></span><br><span class="line">            <span class="type">char</span> ch = _getch(); <span class="comment">// 获取输入的字符</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;You pressed: %c\n&quot;</span>, ch);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>跨平台限制</strong>：<code>_kbhit()</code> 是非标准函数，主要在 Windows 平台上使用。如果需要跨平台支持，可以考虑使用第三方库（如 <code>ncurses</code>）或自己实现类似功能。</li>
<li><strong>与 <code>_getch()</code> 配合使用</strong>：<code>_kbhit()</code> 通常与 <code>_getch()</code> 搭配，用于检查并读取按键输入。</li>
<li><strong>资源占用</strong>：<code>_kbhit()</code> 通常用于实时检测输入，但需要注意不要在主循环中高频调用，避免占用过多 CPU 资源。</li>
</ol>
<h3 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h3><p>如果需要跨平台支持，可以用以下方法替代：</p>
<ul>
<li>在 Linux 或 Unix 系统上，可以结合 <code>termios.h</code> 和 <code>fcntl.h</code> 实现类似功能。</li>
<li>使用跨平台库（如 <code>ncurses</code> 或 <code>SDL</code>）。</li>
</ul>
<p>希望这对你有帮助！如果有其他问题，请随时问我。</p>
<h2 id="详细介绍上文中提到的SDL库"><a href="#详细介绍上文中提到的SDL库" class="headerlink" title="详细介绍上文中提到的SDL库"></a>详细介绍上文中提到的SDL库</h2><h3 id="SDL-库详细介绍"><a href="#SDL-库详细介绍" class="headerlink" title="SDL 库详细介绍"></a>SDL 库详细介绍</h3><p><strong>SDL (Simple DirectMedia Layer)</strong> 是一个跨平台的多媒体开发库，用于创建 2D 游戏、图形应用程序和多媒体软件。SDL 提供了一个简单的接口，允许开发者以一致的方式访问硬件资源，如图形、音频、输入设备（键盘、鼠标、手柄等）和文件 I&#x2F;O 等功能。</p>
<hr>
<h3 id="1-SDL-的特点"><a href="#1-SDL-的特点" class="headerlink" title="1. SDL 的特点"></a><strong>1. SDL 的特点</strong></h3><ul>
<li><strong>跨平台</strong>：支持多种操作系统，包括 Windows、macOS、Linux、iOS、Android 等。</li>
<li><strong>硬件加速</strong>：通过底层支持 OpenGL、Vulkan、Metal 等图形 API，利用 GPU 加速图形渲染。</li>
<li><strong>模块化设计</strong>：提供多种模块处理不同任务，如图形渲染、音频输出、输入设备管理等。</li>
<li><strong>自由开源</strong>：SDL 是一个开源库，遵循 zlib 许可证，允许免费使用和分发。</li>
<li><strong>社区支持</strong>：广泛应用于游戏和多媒体开发领域，有丰富的文档和活跃的社区支持。</li>
</ul>
<hr>
<h3 id="2-SDL-的主要功能"><a href="#2-SDL-的主要功能" class="headerlink" title="2. SDL 的主要功能"></a><strong>2. SDL 的主要功能</strong></h3><p>SDL 提供了以下功能模块，每个模块都专注于特定的功能领域：</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SDL Video</strong></td>
<td>管理窗口和屏幕渲染，支持 2D 图形加速。</td>
</tr>
<tr>
<td><strong>SDL Audio</strong></td>
<td>提供音频播放和录制支持，支持多种音频格式。</td>
</tr>
<tr>
<td><strong>SDL Events</strong></td>
<td>处理用户输入事件，如键盘、鼠标、手柄事件。</td>
</tr>
<tr>
<td><strong>SDL Timer</strong></td>
<td>提供计时和延时功能。</td>
</tr>
<tr>
<td><strong>SDL Threads</strong></td>
<td>跨平台线程管理和同步功能。</td>
</tr>
<tr>
<td><strong>SDL Filesystem</strong></td>
<td>跨平台文件系统操作（读取和写入文件、查找目录等）。</td>
</tr>
<tr>
<td><strong>SDL Joystick&#x2F;GameController</strong></td>
<td>支持手柄和游戏控制器的检测和输入处理。</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-SDL-的安装"><a href="#3-SDL-的安装" class="headerlink" title="3. SDL 的安装"></a><strong>3. SDL 的安装</strong></h3><h4 id="3-1-在-Windows-上安装"><a href="#3-1-在-Windows-上安装" class="headerlink" title="3.1 在 Windows 上安装"></a><strong>3.1 在 Windows 上安装</strong></h4><ol>
<li>下载 SDL2 开发包：<ul>
<li><a target="_blank" rel="noopener" href="https://www.libsdl.org/">SDL 官方网站</a> 下载适合你平台的二进制文件。</li>
</ul>
</li>
<li>配置开发环境：<ul>
<li>将 <code>include</code> 文件夹添加到编译器的包含目录。</li>
<li>将 <code>lib</code> 文件夹中的库添加到链接器路径。</li>
</ul>
</li>
<li>链接库：<ul>
<li>链接 <code>SDL2.lib</code> 和 <code>SDL2main.lib</code>。</li>
</ul>
</li>
</ol>
<h4 id="3-2-在-Linux-上安装"><a href="#3-2-在-Linux-上安装" class="headerlink" title="3.2 在 Linux 上安装"></a><strong>3.2 在 Linux 上安装</strong></h4><p>通过包管理器安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libsdl2-dev</span><br></pre></td></tr></table></figure>

<h4 id="3-3-在-macOS-上安装"><a href="#3-3-在-macOS-上安装" class="headerlink" title="3.3 在 macOS 上安装"></a><strong>3.3 在 macOS 上安装</strong></h4><p>通过 Homebrew 安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install sdl2</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-SDL-的基本用法"><a href="#4-SDL-的基本用法" class="headerlink" title="4. SDL 的基本用法"></a><strong>4. SDL 的基本用法</strong></h3><p>下面是一个简单的 SDL 示例，展示如何创建窗口并处理关闭事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL2/SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (SDL_Init(SDL_INIT_VIDEO) &lt; <span class="number">0</span>) &#123; <span class="comment">// 初始化 SDL 视频子系统</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SDL could not initialize! SDL_Error: %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    SDL_Window *window = SDL_CreateWindow(</span><br><span class="line">        <span class="string">&quot;SDL Example&quot;</span>, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,</span><br><span class="line">        <span class="number">640</span>, <span class="number">480</span>, SDL_WINDOW_SHOWN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Window could not be created! SDL_Error: %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">        SDL_Quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    SDL_Event e;</span><br><span class="line">    <span class="type">int</span> running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="keyword">while</span> (SDL_PollEvent(&amp;e)) &#123; <span class="comment">// 处理事件队列</span></span><br><span class="line">            <span class="keyword">if</span> (e.type == SDL_QUIT) &#123; <span class="comment">// 用户关闭窗口</span></span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    SDL_DestroyWindow(window);</span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-SDL-的高级功能"><a href="#5-SDL-的高级功能" class="headerlink" title="5. SDL 的高级功能"></a><strong>5. SDL 的高级功能</strong></h3><h4 id="5-1-渲染-2D-图形"><a href="#5-1-渲染-2D-图形" class="headerlink" title="5.1 渲染 2D 图形"></a><strong>5.1 渲染 2D 图形</strong></h4><p>SDL 提供了简单的 2D 渲染功能，可以绘制矩形、图像、纹理等。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDL_Renderer *renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, SDL_RENDERER_ACCELERATED);</span><br><span class="line">SDL_SetRenderDrawColor(renderer, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>); <span class="comment">// 设置绘图颜色为红色</span></span><br><span class="line">SDL_RenderClear(renderer); <span class="comment">// 清空屏幕</span></span><br><span class="line">SDL_RenderPresent(renderer); <span class="comment">// 更新屏幕显示</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-处理音频"><a href="#5-2-处理音频" class="headerlink" title="5.2 处理音频"></a><strong>5.2 处理音频</strong></h4><p>通过 <code>SDL_Mixer</code> 扩展库可以播放复杂的音频：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL2/SDL_mixer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化音频</span></span><br><span class="line">Mix_OpenAudio(<span class="number">44100</span>, MIX_DEFAULT_FORMAT, <span class="number">2</span>, <span class="number">2048</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载音频文件</span></span><br><span class="line">Mix_Music *music = Mix_LoadMUS(<span class="string">&quot;example.mp3&quot;</span>);</span><br><span class="line">Mix_PlayMusic(music, <span class="number">-1</span>); <span class="comment">// 播放音乐，-1 表示循环播放</span></span><br></pre></td></tr></table></figure>

<h4 id="5-3-支持多种输入设备"><a href="#5-3-支持多种输入设备" class="headerlink" title="5.3 支持多种输入设备"></a><strong>5.3 支持多种输入设备</strong></h4><p>SDL 能检测鼠标、键盘、手柄等输入设备。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.type == SDL_KEYDOWN) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Key pressed: %s\n&quot;</span>, SDL_GetKeyName(e.key.keysym.sym));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-SDL-的优缺点"><a href="#6-SDL-的优缺点" class="headerlink" title="6. SDL 的优缺点"></a><strong>6. SDL 的优缺点</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ol>
<li><strong>简单易用</strong>：提供了抽象接口，隐藏了底层复杂性。</li>
<li><strong>广泛支持</strong>：支持多种平台和设备。</li>
<li><strong>高性能</strong>：支持硬件加速，适合实时应用。</li>
<li><strong>可扩展性强</strong>：有丰富的扩展库，如 <code>SDL_image</code>、<code>SDL_mixer</code> 和 <code>SDL_ttf</code>。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ol>
<li><strong>3D 功能有限</strong>：SDL 专注于 2D 图形，3D 应用需要结合 OpenGL、Vulkan 等库。</li>
<li><strong>学习曲线</strong>：虽然基础功能简单，但高级功能可能需要更多学习。</li>
<li><strong>依赖配置</strong>：需要正确配置开发环境，特别是在跨平台项目中。</li>
</ol>
<hr>
<h3 id="7-常用的-SDL-扩展库"><a href="#7-常用的-SDL-扩展库" class="headerlink" title="7. 常用的 SDL 扩展库"></a><strong>7. 常用的 SDL 扩展库</strong></h3><table>
<thead>
<tr>
<th>扩展库</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SDL_image</strong></td>
<td>支持加载多种图像格式（如 PNG、JPG 等）。</td>
</tr>
<tr>
<td><strong>SDL_mixer</strong></td>
<td>提供高级音频处理功能，如播放多声道音频。</td>
</tr>
<tr>
<td><strong>SDL_ttf</strong></td>
<td>支持 TrueType 字体的渲染和显示。</td>
</tr>
<tr>
<td><strong>SDL_net</strong></td>
<td>提供简单的跨平台网络功能。</td>
</tr>
</tbody></table>
<hr>
<h3 id="8-典型应用"><a href="#8-典型应用" class="headerlink" title="8. 典型应用"></a><strong>8. 典型应用</strong></h3><p>SDL 被广泛用于以下领域：</p>
<ol>
<li><strong>游戏开发</strong>：适合 2D 游戏和简单的 3D 游戏。</li>
<li><strong>多媒体软件</strong>：音频和视频播放、编辑工具。</li>
<li><strong>教育工具</strong>：教学演示、实时可视化应用。</li>
</ol>
<p>SDL 是一个功能强大且灵活的库，非常适合初学者和专业开发者使用。如果有具体问题或想实现某个功能，请随时告诉我！</p>
<h2 id="windows-ren命令-拒绝访问是为什么"><a href="#windows-ren命令-拒绝访问是为什么" class="headerlink" title="windows ren命令 拒绝访问是为什么"></a>windows ren命令 拒绝访问是为什么</h2><p>在 Windows 中使用 <code>ren</code> 命令时，出现“拒绝访问”错误通常与以下原因有关：</p>
<h3 id="1-权限不足"><a href="#1-权限不足" class="headerlink" title="1. 权限不足"></a>1. <strong>权限不足</strong></h3><ul>
<li>当前用户账户可能没有足够的权限来重命名目标文件或文件夹。</li>
<li><strong>解决方法</strong>：<ol>
<li>确认您是否拥有文件或文件夹的所有权。</li>
<li>以管理员身份运行命令提示符：<ul>
<li>右键单击“命令提示符”或“Windows PowerShell”，选择“以管理员身份运行”。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="2-目标文件或文件夹正在被使用"><a href="#2-目标文件或文件夹正在被使用" class="headerlink" title="2. 目标文件或文件夹正在被使用"></a>2. <strong>目标文件或文件夹正在被使用</strong></h3><ul>
<li>如果目标文件或文件夹正在被另一个程序或进程使用，无法重命名。</li>
<li><strong>解决方法</strong>：<ol>
<li>确保文件没有被打开或占用。</li>
<li>使用任务管理器关闭占用文件的相关程序。</li>
<li>如果问题仍然存在，可以通过资源监视器查看并终止相关的锁定进程。</li>
</ol>
</li>
</ul>
<h3 id="3-路径或文件名不正确"><a href="#3-路径或文件名不正确" class="headerlink" title="3. 路径或文件名不正确"></a>3. <strong>路径或文件名不正确</strong></h3><ul>
<li>文件名中包含受限制的字符（如 <code>\</code>, <code>:</code>）或路径错误。</li>
<li><strong>解决方法</strong>：<ol>
<li>确保提供的路径和文件名正确。</li>
<li>使用引号将文件名或路径括起来（例如：<code>ren &quot;old name.txt&quot; &quot;new name.txt&quot;</code>），以避免空格或特殊字符引起的问题。</li>
</ol>
</li>
</ul>
<h3 id="4-文件夹的只读属性"><a href="#4-文件夹的只读属性" class="headerlink" title="4. 文件夹的只读属性"></a>4. <strong>文件夹的只读属性</strong></h3><ul>
<li>如果目标文件夹设置了只读属性，可能会导致无法重命名。</li>
<li><strong>解决方法</strong>：<ol>
<li>右键单击目标文件夹，选择“属性”。</li>
<li>在“常规”选项卡中，取消选中“只读”。</li>
<li>点击“确定”并重新尝试。</li>
</ol>
</li>
</ul>
<h3 id="5-文件或文件夹的权限设置"><a href="#5-文件或文件夹的权限设置" class="headerlink" title="5. 文件或文件夹的权限设置"></a>5. <strong>文件或文件夹的权限设置</strong></h3><ul>
<li>可能文件或文件夹的权限被限制，导致当前用户无法操作。</li>
<li><strong>解决方法</strong>：<ol>
<li>右键单击目标文件或文件夹，选择“属性”。</li>
<li>在“安全”选项卡中，检查当前用户是否有修改权限。</li>
<li>如果没有权限，点击“编辑”并为用户添加“完全控制”权限。</li>
</ol>
</li>
</ul>
<h3 id="6-文件或文件夹被系统保护"><a href="#6-文件或文件夹被系统保护" class="headerlink" title="6. 文件或文件夹被系统保护"></a>6. <strong>文件或文件夹被系统保护</strong></h3><ul>
<li>某些系统文件或文件夹可能受到保护，无法直接修改。</li>
<li><strong>解决方法</strong>：<ol>
<li>不建议直接修改系统文件或文件夹。</li>
<li>如果确实需要修改，先解除系统保护（如关闭防护软件），但需谨慎操作。</li>
</ol>
</li>
</ul>
<p>如果尝试以上方法后仍然无法解决问题，可以提供详细的错误信息（如完整的命令和路径），我可以帮助进一步分析和解决！</p>
<h2 id="windows-cmd中调用bat脚本和ps1脚本的方法"><a href="#windows-cmd中调用bat脚本和ps1脚本的方法" class="headerlink" title="windows cmd中调用bat脚本和ps1脚本的方法"></a>windows cmd中调用bat脚本和ps1脚本的方法</h2><p>在 Windows CMD 中，可以使用以下方法调用 <code>.bat</code> 和 <code>.ps1</code> 脚本：</p>
<hr>
<h3 id="调用-bat-脚本"><a href="#调用-bat-脚本" class="headerlink" title="调用 .bat 脚本"></a>调用 <code>.bat</code> 脚本</h3><h4 id="方法-1-直接调用"><a href="#方法-1-直接调用" class="headerlink" title="方法 1: 直接调用"></a>方法 1: 直接调用</h4><p>只需输入脚本路径（可以是相对路径或绝对路径）：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">path</span>\<span class="title">to</span>\<span class="title">your_script.bat</span></span></span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\your_script.bat</span><br></pre></td></tr></table></figure>

<h4 id="方法-2-使用-call-命令"><a href="#方法-2-使用-call-命令" class="headerlink" title="方法 2: 使用 call 命令"></a>方法 2: 使用 <code>call</code> 命令</h4><p>如果需要在调用脚本后返回到当前 CMD 会话：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> C:\<span class="built_in">path</span>\to\your_script.bat</span><br></pre></td></tr></table></figure>

<h4 id="方法-3-使用-start-命令"><a href="#方法-3-使用-start-命令" class="headerlink" title="方法 3: 使用 start 命令"></a>方法 3: 使用 <code>start</code> 命令</h4><p>启动一个新窗口运行 <code>.bat</code> 脚本：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">start</span> C:\<span class="built_in">path</span>\to\your_script.bat</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="调用-ps1-脚本"><a href="#调用-ps1-脚本" class="headerlink" title="调用 .ps1 脚本"></a>调用 <code>.ps1</code> 脚本</h3><h4 id="1-启用脚本执行策略"><a href="#1-启用脚本执行策略" class="headerlink" title="1. 启用脚本执行策略"></a>1. 启用脚本执行策略</h4><p>PowerShell 的默认策略可能禁止脚本运行。可以设置为允许：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -Command &quot;<span class="built_in">Set</span>-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>: <code>Bypass</code> 是临时策略，仅在当前会话中生效。</p>
</blockquote>
<h4 id="2-调用-ps1-脚本"><a href="#2-调用-ps1-脚本" class="headerlink" title="2. 调用 .ps1 脚本"></a>2. 调用 <code>.ps1</code> 脚本</h4><h5 id="方法-1-使用-powershell-命令运行"><a href="#方法-1-使用-powershell-命令运行" class="headerlink" title="方法 1: 使用 powershell 命令运行"></a>方法 1: 使用 <code>powershell</code> 命令运行</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -File C:\<span class="built_in">path</span>\to\your_script.ps1</span><br></pre></td></tr></table></figure>

<h5 id="方法-2-使用-Command-参数"><a href="#方法-2-使用-Command-参数" class="headerlink" title="方法 2: 使用 -Command 参数"></a>方法 2: 使用 <code>-Command</code> 参数</h5><p>运行单行或多行脚本：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -Command &quot;&amp; &#123;C:\<span class="built_in">path</span>\to\your_script.ps1&#125;&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="混合使用-bat-和-ps1-脚本"><a href="#混合使用-bat-和-ps1-脚本" class="headerlink" title="混合使用 .bat 和 .ps1 脚本"></a>混合使用 <code>.bat</code> 和 <code>.ps1</code> 脚本</h3><h4 id="从-bat-脚本调用-ps1-脚本"><a href="#从-bat-脚本调用-ps1-脚本" class="headerlink" title="从 .bat 脚本调用 .ps1 脚本"></a>从 <code>.bat</code> 脚本调用 <code>.ps1</code> 脚本</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">powershell -ExecutionPolicy Bypass -File &quot;C:\<span class="built_in">path</span>\to\your_script.ps1&quot;</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<h4 id="从-ps1-脚本调用-bat-脚本"><a href="#从-ps1-脚本调用-bat-脚本" class="headerlink" title="从 .ps1 脚本调用 .bat 脚本"></a>从 <code>.ps1</code> 脚本调用 <code>.bat</code> 脚本</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Start-Process</span> <span class="literal">-FilePath</span> <span class="string">&quot;cmd.exe&quot;</span> <span class="literal">-ArgumentList</span> <span class="string">&quot;/c C:\path\to\your_script.bat&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><strong>路径中有空格</strong><br>使用双引号括起来，例如：<code>&quot;C:\Program Files\My Script.bat&quot;</code>。</p>
</li>
<li><p><strong>权限问题</strong>  </p>
<ul>
<li>确保运行 CMD 或 PowerShell 的用户有足够的权限。</li>
<li>如果需要管理员权限，可以以管理员模式运行 CMD 或 PowerShell。</li>
</ul>
</li>
<li><p><strong>脚本失败返回码</strong><br>在 <code>.bat</code> 脚本中检查 PowerShell 脚本的执行结果：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">powershell -ExecutionPolicy Bypass -File &quot;C:\<span class="built_in">path</span>\to\your_script.ps1&quot;</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%ERRORLEVEL%</span> <span class="keyword">neq</span> <span class="number">0</span> (</span><br><span class="line">    <span class="built_in">echo</span> &quot;PowerShell script failed with code <span class="variable">%ERRORLEVEL%</span>&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果你有其他问题或特定需求，可以继续提问！</p>
<h2 id="windows-查看监听的端口"><a href="#windows-查看监听的端口" class="headerlink" title="windows 查看监听的端口"></a>windows 查看监听的端口</h2><p>在 Windows 系统中，可以通过多种方式查看正在监听的端口。以下是几种常见的方法：</p>
<hr>
<h3 id="方法-1-使用-netstat-命令"><a href="#方法-1-使用-netstat-命令" class="headerlink" title="方法 1: 使用 netstat 命令"></a><strong>方法 1: 使用 <code>netstat</code> 命令</strong></h3><ol>
<li>打开 <strong>命令提示符</strong> 或 <strong>PowerShell</strong>。</li>
<li>输入以下命令查看监听的端口：<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | <span class="built_in">findstr</span> LISTEN</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-a</code>：显示所有连接和监听端口。</li>
<li><code>-n</code>：以数字形式显示地址和端口号。</li>
<li><code>| findstr LISTEN</code>：只筛选出正在监听的端口。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="方法-2-使用-Get-NetTCPConnection（适用于-PowerShell）"><a href="#方法-2-使用-Get-NetTCPConnection（适用于-PowerShell）" class="headerlink" title="方法 2: 使用 Get-NetTCPConnection（适用于 PowerShell）"></a><strong>方法 2: 使用 <code>Get-NetTCPConnection</code>（适用于 PowerShell）</strong></h3><ol>
<li><p>打开 <strong>PowerShell</strong>。</p>
</li>
<li><p>输入以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-NetTCPConnection</span> <span class="literal">-State</span> Listen</span><br></pre></td></tr></table></figure>
<ul>
<li>这将列出所有处于监听状态的连接及其端口号。</li>
</ul>
</li>
<li><p>如果需要查看特定端口是否在监听，可以使用：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-NetTCPConnection</span> <span class="literal">-LocalPort</span> &lt;端口号&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="方法-3-使用-tasklist-和-netstat-结合查看"><a href="#方法-3-使用-tasklist-和-netstat-结合查看" class="headerlink" title="方法 3: 使用 tasklist 和 netstat 结合查看"></a><strong>方法 3: 使用 <code>tasklist</code> 和 <code>netstat</code> 结合查看</strong></h3><ol>
<li><p>输入以下命令查看监听端口对应的进程：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | <span class="built_in">findstr</span> LISTEN</span><br></pre></td></tr></table></figure>
<ul>
<li>该命令会显示监听的地址、端口和对应的进程 ID (PID)。</li>
</ul>
</li>
<li><p>查找对应的程序：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | <span class="built_in">findstr</span> &lt;PID&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>将 <code>&lt;PID&gt;</code> 替换为上一步中找到的进程 ID，查看是什么程序占用了端口。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="方法-4-使用图形界面查看"><a href="#方法-4-使用图形界面查看" class="headerlink" title="方法 4: 使用图形界面查看"></a><strong>方法 4: 使用图形界面查看</strong></h3><ol>
<li>打开 <strong>任务管理器</strong>（按 <code>Ctrl + Shift + Esc</code>）。</li>
<li>点击 <strong>性能</strong> -&gt; <strong>打开资源监视器</strong>。</li>
<li>在资源监视器中选择 <strong>网络</strong> 选项卡。</li>
<li>在 <strong>侦听端口</strong> 部分，可以看到当前监听的端口和对应的程序。</li>
</ol>
<hr>
<h3 id="方法-5-使用第三方工具"><a href="#方法-5-使用第三方工具" class="headerlink" title="方法 5: 使用第三方工具"></a><strong>方法 5: 使用第三方工具</strong></h3><p>一些工具可以直观地显示端口使用情况，例如：</p>
<ul>
<li><strong>TCPView</strong>（来自 Sysinternals 套件）：显示所有打开的网络连接和监听端口。</li>
<li><strong>Wireshark</strong>：强大的网络分析工具。</li>
</ul>
<p>通过以上方法，你可以方便地查看 Windows 系统中正在监听的端口。</p>
<h2 id="windows-cmd-查看命令的路径"><a href="#windows-cmd-查看命令的路径" class="headerlink" title="windows cmd 查看命令的路径"></a>windows cmd 查看命令的路径</h2><p>在 Windows CMD（命令提示符）中，可以使用以下方法查看某个命令或程序的路径：</p>
<hr>
<h3 id="1-使用-where-命令"><a href="#1-使用-where-命令" class="headerlink" title="1. 使用 where 命令"></a><strong>1. 使用 <code>where</code> 命令</strong></h3><p><code>where</code> 命令会显示命令或可执行文件的路径。</p>
<h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where &lt;命令名&gt;</span><br></pre></td></tr></table></figure>

<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where python</span><br></pre></td></tr></table></figure>

<p><strong>输出示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Python39\python.exe</span><br><span class="line">C:\Windows\py.exe</span><br></pre></td></tr></table></figure>

<ul>
<li>如果系统路径（<code>PATH</code>）中存在多个同名可执行文件，<code>where</code> 会列出所有路径。</li>
<li>如果找不到命令，<code>where</code> 会提示类似以下内容：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO: Could not find files for the given pattern(s).</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-使用-which-命令（在-PowerShell-中）"><a href="#2-使用-which-命令（在-PowerShell-中）" class="headerlink" title="2. 使用 which 命令（在 PowerShell 中）"></a><strong>2. 使用 <code>which</code> 命令（在 PowerShell 中）</strong></h3><p>在 PowerShell 中，可以使用 <code>which</code> 查看命令的路径。</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which python</span><br></pre></td></tr></table></figure>

<p><strong>输出示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Python39\python.exe</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-查看环境变量-PATH"><a href="#3-查看环境变量-PATH" class="headerlink" title="3. 查看环境变量 PATH"></a><strong>3. 查看环境变量 <code>PATH</code></strong></h3><p>如果要确认某个命令是否在 <code>PATH</code> 环境变量中，可以直接查看 <code>PATH</code>。</p>
<h4 id="查看-PATH-的值："><a href="#查看-PATH-的值：" class="headerlink" title="查看 PATH 的值："></a>查看 <code>PATH</code> 的值：</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">%PATH%</span></span><br></pre></td></tr></table></figure>

<p><strong>操作：</strong></p>
<ul>
<li>查找命令所在的目录是否在输出中。</li>
</ul>
<h4 id="手动搜索："><a href="#手动搜索：" class="headerlink" title="手动搜索："></a>手动搜索：</h4><p>使用 <code>dir</code> 命令搜索指定文件名：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> /s /b C:\ | <span class="built_in">findstr</span> python.exe</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-使用-type-或-for-命令"><a href="#4-使用-type-或-for-命令" class="headerlink" title="4. 使用 type 或 for 命令"></a><strong>4. 使用 <code>type</code> 或 <code>for</code> 命令</strong></h3><p>对于 CMD 内部命令，可以用 <code>type</code> 或 <code>for</code> 查看。</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> %i <span class="keyword">in</span> (python) <span class="keyword">do</span> @<span class="built_in">echo</span> %~$<span class="built_in">PATH</span>:i</span><br></pre></td></tr></table></figure>

<p><strong>输出示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Python39\python.exe</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-检查别名和脚本"><a href="#5-检查别名和脚本" class="headerlink" title="5. 检查别名和脚本"></a><strong>5. 检查别名和脚本</strong></h3><p>在某些情况下，命令可能是通过别名或脚本定义的。可以通过以下方式检查：</p>
<ul>
<li>使用 <code>doskey /macros</code> 查看别名。</li>
<li>如果你怀疑命令是脚本，可以查找是否存在同名的 <code>.bat</code> 或 <code>.cmd</code> 文件。</li>
</ul>
<hr>
<p>通过这些方法，你可以轻松找到任何命令或可执行文件在系统中的路径。</p>
<h2 id="windows-cmd-删除非空目录的命令"><a href="#windows-cmd-删除非空目录的命令" class="headerlink" title="windows cmd 删除非空目录的命令"></a>windows cmd 删除非空目录的命令</h2><p>在 Windows 命令提示符（CMD）中，可以使用以下命令删除非空目录：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rd</span> /s /q 路径</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong>  </p>
<ul>
<li><code>/s</code>：删除指定目录及其所有子目录和文件（即递归删除）。  </li>
<li><code>/q</code>：安静模式，删除时不提示确认。</li>
</ul>
<p><strong>示例：</strong><br>要删除 <code>C:\example</code> 目录及其所有内容，可以运行：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rd</span> /s /q C:\example</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>  </p>
<ul>
<li>确保你有权限删除目标目录。</li>
<li>删除操作不可逆，请谨慎使用。</li>
</ul>
<h2 id="笔记本CPU利用率卡在16-不动，电脑很卡"><a href="#笔记本CPU利用率卡在16-不动，电脑很卡" class="headerlink" title="笔记本CPU利用率卡在16%不动，电脑很卡"></a>笔记本CPU利用率卡在16%不动，电脑很卡</h2><ul>
<li><p>有时候笔记本电脑开机后巨卡顿，开啥都慢，打开任务管理器看CPU利用率卡在15%不懂</p>
</li>
<li><p>这种情况是因为电源问题导致CPU频率被锁住了。要么是电源设置有问题，要么是硬件有问题</p>
<ul>
<li>先检查任务栏的电源设置是不是最佳性能</li>
<li>还不正常的话，就把充电器拔下来，放个几秒再插回去。两头都要拔，因为不能保证是插座那头还是插电脑那头没有接好。(这这个方法解决了我的问题，奈斯)</li>
<li>如果仍然不正常，就看看其他的吧</li>
</ul>
</li>
</ul>
<h2 id="windows-查看端口占用"><a href="#windows-查看端口占用" class="headerlink" title="windows 查看端口占用"></a>windows 查看端口占用</h2><p>要查看 Windows 系统中端口的占用情况，可以使用以下几种方法：</p>
<h3 id="方法-1-使用-netstat-命令-1"><a href="#方法-1-使用-netstat-命令-1" class="headerlink" title="方法 1: 使用 netstat 命令"></a>方法 1: 使用 <code>netstat</code> 命令</h3><ol>
<li><p>打开命令提示符（可以按 <code>Win + R</code>，然后输入 <code>cmd</code>，再按回车键）。</p>
</li>
<li><p>输入以下命令查看所有监听的端口和对应的进程 ID（PID）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>-a</code> 参数表示显示所有连接和监听端口。</li>
<li><code>-n</code> 参数表示以数字形式显示地址和端口号。</li>
<li><code>-o</code> 参数显示与每个连接关联的进程 ID。</li>
</ul>
</li>
<li><p>找到你要检查的端口号，可以通过查看最后一列的 PID 来确定哪个进程占用了该端口。</p>
</li>
</ol>
<h3 id="方法-2-使用-tasklist-命令"><a href="#方法-2-使用-tasklist-命令" class="headerlink" title="方法 2: 使用 tasklist 命令"></a>方法 2: 使用 <code>tasklist</code> 命令</h3><p>你可以结合 <code>tasklist</code> 命令来查看具体是哪个程序占用了某个端口。</p>
<ol>
<li>获取端口占用的 PID，比如你想查看 <code>8080</code> 端口的占用情况：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr :8080</span><br></pre></td></tr></table></figure></li>
<li>根据 PID 查找进程名称：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /fi <span class="string">&quot;pid eq PID_NUMBER&quot;</span></span><br></pre></td></tr></table></figure>
把 <code>PID_NUMBER</code> 替换成你从 <code>netstat</code> 命令中得到的 PID。</li>
</ol>
<h3 id="方法-3-使用-PowerShell"><a href="#方法-3-使用-PowerShell" class="headerlink" title="方法 3: 使用 PowerShell"></a>方法 3: 使用 <code>PowerShell</code></h3><p>你也可以通过 PowerShell 查看端口占用情况。</p>
<ol>
<li>打开 PowerShell。</li>
<li>输入以下命令查看所有监听的端口和对应的进程：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-NetTCPConnection</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.State <span class="operator">-eq</span> <span class="string">&#x27;Listen&#x27;</span> &#125; | <span class="built_in">Select-Object</span> LocalAddress, LocalPort, OwningProcess</span><br></pre></td></tr></table></figure></li>
<li>可以使用 <code>Get-Process</code> 命令进一步查看进程的详细信息：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Process</span> <span class="literal">-Id</span> PID_NUMBER</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些方法都可以帮助你查看和排查端口占用的问题。</p>
<h2 id="windows11-查看系统日志的方法"><a href="#windows11-查看系统日志的方法" class="headerlink" title="windows11 查看系统日志的方法"></a>windows11 查看系统日志的方法</h2><p>在 Windows 11 中查看系统日志的方法如下：</p>
<h3 id="1-使用“事件查看器”查看系统日志"><a href="#1-使用“事件查看器”查看系统日志" class="headerlink" title="1. 使用“事件查看器”查看系统日志"></a>1. 使用“事件查看器”查看系统日志</h3><ol>
<li><p><strong>打开事件查看器</strong>:</p>
<ul>
<li>按 <code>Win + S</code> 键打开搜索框。</li>
<li>输入“事件查看器”或“Event Viewer”，然后按回车。</li>
</ul>
</li>
<li><p><strong>导航到系统日志</strong>:</p>
<ul>
<li>在左侧窗格中，展开“Windows 日志”。</li>
<li>选择“系统”，这里会显示与系统相关的日志。</li>
</ul>
</li>
<li><p><strong>查看日志</strong>:</p>
<ul>
<li>在中央窗格中，你会看到系统日志的详细列表。可以点击任意条目查看具体的事件信息。</li>
<li>你也可以使用右侧的“操作”面板中的“筛选当前日志”功能来缩小搜索范围，查找特定事件。</li>
</ul>
</li>
</ol>
<h3 id="2-使用-PowerShell-查看系统日志"><a href="#2-使用-PowerShell-查看系统日志" class="headerlink" title="2. 使用 PowerShell 查看系统日志"></a>2. 使用 PowerShell 查看系统日志</h3><ol>
<li><p><strong>打开 PowerShell</strong>:</p>
<ul>
<li>按 <code>Win + X</code>，选择“Windows Terminal（管理员）”或“PowerShell（管理员）”。</li>
</ul>
</li>
<li><p><strong>运行命令查看系统日志</strong>:</p>
<ul>
<li>输入以下命令查看系统日志：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-EventLog</span> <span class="literal">-LogName</span> System</span><br></pre></td></tr></table></figure></li>
<li>你可以通过添加参数来过滤或格式化输出，例如：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-EventLog</span> <span class="literal">-LogName</span> System <span class="literal">-Newest</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
这将显示最新的 10 条系统日志。</li>
</ul>
</li>
</ol>
<h3 id="3-使用“设置”应用查看系统日志"><a href="#3-使用“设置”应用查看系统日志" class="headerlink" title="3. 使用“设置”应用查看系统日志"></a>3. 使用“设置”应用查看系统日志</h3><p>虽然“设置”应用本身不直接显示系统日志，但你可以查看一些系统状态信息：</p>
<ol>
<li><p><strong>打开设置</strong>:</p>
<ul>
<li>按 <code>Win + I</code> 打开设置。</li>
</ul>
</li>
<li><p><strong>查看系统状态</strong>:</p>
<ul>
<li>选择“系统”&gt;“故障排除”&gt;“其他故障排除器”，查看一些常见问题和解决方案。</li>
</ul>
</li>
</ol>
<p>这些方法可以帮助你访问和分析 Windows 11 系统日志，排查系统问题或监控系统健康状态。</p>
<h2 id="笔记本电脑屏幕当作扩展屏幕"><a href="#笔记本电脑屏幕当作扩展屏幕" class="headerlink" title="笔记本电脑屏幕当作扩展屏幕"></a>笔记本电脑屏幕当作扩展屏幕</h2><ul>
<li><p>目标: 根据win10自带功能，将一台PC给另一台PC当扩展屏</p>
</li>
<li><p>在设置里打开 可被发现功能</p>
<ul>
<li>如果没有打开，在 添加应用 处添加 无线显示器就可以</li>
</ul>
</li>
<li><p>主机打开投影&#x2F;连接，点击 连接到无线显示器，选择新发现的设备</p>
</li>
<li><p>在投影选项中选择扩展。</p>
</li>
</ul>
<h2 id="windows-查看文件被占用的线程"><a href="#windows-查看文件被占用的线程" class="headerlink" title="windows 查看文件被占用的线程"></a>windows 查看文件被占用的线程</h2><p>在 Windows 中，你可以使用以下方法来查看被占用文件的线程：</p>
<h3 id="方法一：使用-Resource-Monitor"><a href="#方法一：使用-Resource-Monitor" class="headerlink" title="方法一：使用 Resource Monitor"></a>方法一：使用 <strong>Resource Monitor</strong></h3><ol>
<li>按下 <code>Ctrl + Shift + Esc</code> 打开任务管理器。</li>
<li>在任务管理器中，切换到 <strong>“性能”</strong> 标签页，然后点击 <strong>“打开资源监视器”</strong>。</li>
<li>在资源监视器中，切换到 <strong>“CPU”</strong> 标签页。</li>
<li>在 <strong>“关联的句柄”</strong> 搜索框中输入被占用的文件名，资源监视器会显示与该文件相关的进程。</li>
</ol>
<h3 id="方法二：使用-Process-Explorer"><a href="#方法二：使用-Process-Explorer" class="headerlink" title="方法二：使用 Process Explorer"></a>方法二：使用 <strong>Process Explorer</strong></h3><p>Process Explorer 是微软提供的高级工具，可以用于查看文件被哪个进程或线程占用。</p>
<ol>
<li>下载并运行 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer">Process Explorer</a>。</li>
<li>在工具栏中点击 <strong>“Find”</strong>，选择 <strong>“Find Handle or DLL”</strong>，或者直接按 <code>Ctrl + F</code>。</li>
<li>输入文件名，然后点击 <strong>“Search”</strong>。搜索结果会显示与该文件相关的进程。</li>
<li>你可以双击进程名称查看详细信息，包括线程信息。</li>
</ol>
<p>这些方法可以帮助你定位具体的线程或进程占用了文件。</p>
<h2 id="windows-10-系统激活"><a href="#windows-10-系统激活" class="headerlink" title="windows 10 系统激活"></a>windows 10 系统激活</h2><ul>
<li>命令如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slmgr.vbs /upk</span><br><span class="line">slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">slmgr /skms kms.ghxi.com</span><br><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="windows-wsl系统编译linux可执行程序"><a href="#windows-wsl系统编译linux可执行程序" class="headerlink" title="windows wsl系统编译linux可执行程序"></a>windows wsl系统编译linux可执行程序</h2><p>在 Windows 上使用 Windows Subsystem for Linux (WSL) 可以方便地编译 Linux 可执行程序。WSL 允许在 Windows 上运行 Linux 环境，从而可以使用 Linux 原生的编译工具链。以下是具体步骤：</p>
<h3 id="安装-WSL-和-Linux-发行版"><a href="#安装-WSL-和-Linux-发行版" class="headerlink" title="安装 WSL 和 Linux 发行版"></a>安装 WSL 和 Linux 发行版</h3><ol>
<li><p><strong>启用 WSL 功能</strong>：<br>打开 PowerShell（以管理员身份运行），并运行以下命令来启用 WSL：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装 WSL 2</strong>：<br>设置 WSL 2 作为默认版本：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装 Linux 发行版</strong>：<br>从 Microsoft Store 安装你选择的 Linux 发行版，例如 Ubuntu。</p>
</li>
<li><p><strong>初始化 Linux 发行版</strong>：<br>安装完成后，打开安装的 Linux 发行版并按照提示完成初始化过程（设置用户名和密码）。</p>
</li>
</ol>
<h3 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h3><ol>
<li><p><strong>更新包列表</strong>：<br>打开 WSL 终端并更新包列表：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装编译工具</strong>：<br>安装 <code>build-essential</code> 包，它包含了常用的编译工具，如 <code>gcc</code>、<code>g++</code>、<code>make</code> 等：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install build-essential</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="编译-Linux-可执行程序"><a href="#编译-Linux-可执行程序" class="headerlink" title="编译 Linux 可执行程序"></a>编译 Linux 可执行程序</h3><p>假设你有一个简单的 C++ 项目 <code>hello.cpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>编译程序</strong>：<br>使用 <code>g++</code> 编译器编译这个程序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o hello hello.cpp</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行可执行文件</strong>：<br>编译成功后，可以运行生成的可执行文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure></li>
</ol>
<p>你应该会看到输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<h3 id="复杂项目的编译"><a href="#复杂项目的编译" class="headerlink" title="复杂项目的编译"></a>复杂项目的编译</h3><p>对于更复杂的项目，可能需要使用 CMake 或其他构建系统。以下是使用 CMake 的示例：</p>
<ol>
<li><p><strong>安装 CMake</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install cmake</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 CMakeLists.txt</strong>：</p>
<p>在你的项目目录下创建一个 <code>CMakeLists.txt</code> 文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(HelloWorld)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello hello.cpp)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译项目</strong>：</p>
<p>使用 CMake 配置和编译项目：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行可执行文件</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="访问-Windows-文件系统"><a href="#访问-Windows-文件系统" class="headerlink" title="访问 Windows 文件系统"></a>访问 Windows 文件系统</h3><p>在 WSL 中，可以访问 Windows 文件系统。例如，可以访问 <code>C:</code> 驱动器上的文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/c/Users/YourUsername/path/to/your/project</span><br></pre></td></tr></table></figure>

<p>这样，你可以在 Windows 和 WSL 之间轻松共享文件。</p>
<p>通过这些步骤，你可以在 Windows 上使用 WSL 编译和运行 Linux 可执行程序，享受在 Linux 上开发的便利性。</p>
<h2 id="windows-设置powshell环境变量"><a href="#windows-设置powshell环境变量" class="headerlink" title="windows 设置powshell环境变量"></a>windows 设置powshell环境变量</h2><p>在 Windows PowerShell 中设置环境变量，你可以使用 <code>$env</code> 自动变量，也可以使用 PowerShell cmdlet 来实现。以下是两种常见的方法：</p>
<ol>
<li><p><strong>使用 <code>$env</code> 自动变量</strong>：</p>
<ul>
<li>若要设置一个环境变量，你可以使用 <code>$env:变量名</code> 这种语法来分配一个值。例如，要设置一个名为 <code>MY_VARIABLE</code> 的环境变量，可以执行以下命令：</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:MY_VARIABLE</span> = <span class="string">&quot;MyValue&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将创建名为 <code>MY_VARIABLE</code> 的环境变量，并将其值设置为 “MyValue”。</p>
<ul>
<li>若要在 Windows PowerShell 中永久设置环境变量，可以将 <code>$env</code> 变量的设置添加到你的 PowerShell 配置文件中，通常是 <code>$PROFILE</code> 变量指定的脚本文件中，如 <code>$PROFILE</code> 文件或 <code>$PROFILE.AllUsersCurrentHost</code> 文件。</li>
</ul>
</li>
<li><p><strong>使用 PowerShell cmdlet</strong>：</p>
<ul>
<li>你还可以使用 PowerShell 的 <code>Set-Item</code> cmdlet 来设置环境变量。例如，要设置名为 <code>MY_VARIABLE</code> 的环境变量，可以执行以下命令：</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">System.Environment</span>]::SetEnvironmentVariable(<span class="string">&quot;MY_VARIABLE&quot;</span>, <span class="string">&quot;MyValue&quot;</span>, [<span class="type">System.EnvironmentVariableTarget</span>]::User)</span><br></pre></td></tr></table></figure>

<p>上述示例将 <code>MY_VARIABLE</code> 设置为 “MyValue”，并将其限制在当前用户的环境变量中。你可以使用 <code>[System.EnvironmentVariableTarget]::Machine</code> 来设置系统范围的环境变量。</p>
<ul>
<li>若要永久设置环境变量，你通常需要以管理员权限运行 PowerShell，以便更改系统范围的环境变量。</li>
</ul>
</li>
</ol>
<p>请注意，设置环境变量可能需要管理员权限，特别是在更改系统范围的环境变量时。确保以管理员身份运行 PowerShell，以避免权限问题。在设置环境变量后，你需要重新启动 PowerShell 或任何需要使用这些变量的应用程序，以使更改生效。</p>
<h2 id="windows-powshell输出环境变量"><a href="#windows-powshell输出环境变量" class="headerlink" title="windows powshell输出环境变量"></a>windows powshell输出环境变量</h2><p>要在 Windows PowerShell 中查看环境变量，你可以使用 <code>$env</code> 自动变量，该变量允许你访问系统环境变量。以下是一些示例：</p>
<ol>
<li><p><strong>查看单个环境变量</strong>：<br>若要查看单个环境变量的值，你可以使用 <code>$env:变量名</code>，将 “变量名” 替换为你要查看的环境变量的名称。例如，要查看 <code>PATH</code> 环境变量的值，可以执行以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:PATH</span></span><br></pre></td></tr></table></figure>

<p>这将输出 <code>PATH</code> 环境变量的值。</p>
</li>
<li><p><strong>查看所有环境变量</strong>：<br>若要查看所有系统环境变量，你可以使用以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-ChildItem</span> Env:</span><br></pre></td></tr></table></figure>

<p>这将列出所有系统环境变量及其值。</p>
</li>
<li><p><strong>查看用户环境变量</strong>：<br>若要查看当前用户的环境变量，可以使用以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-ChildItem</span> Env: <span class="literal">-PSProvider</span> Environment</span><br></pre></td></tr></table></figure>

<p>这将列出当前用户的环境变量及其值。</p>
</li>
</ol>
<p>请注意，Windows PowerShell 通常需要以管理员权限运行才能查看和编辑系统环境变量。如果你只是普通用户，你可以查看和编辑用户环境变量。</p>
<p>使用 Windows PowerShell 查看环境变量非常方便，因为它提供了直观的语法和强大的功能来管理环境变量。你可以根据你的需求来使用这些命令来查看和管理环境变量。</p>
<h2 id="windows-cmd输出环境变量"><a href="#windows-cmd输出环境变量" class="headerlink" title="windows cmd输出环境变量"></a>windows cmd输出环境变量</h2><p>要在 Windows 命令提示符（cmd）中查看系统环境变量，你可以使用 <code>echo</code> 命令和特定的环境变量名称。以下是一些示例：</p>
<ol>
<li><p><strong>查看单个环境变量</strong>：<br>若要查看单个环境变量，可以使用以下命令，将环境变量的名称替换为你要查看的环境变量名称（例如，<code>PATH</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PATH%</span><br></pre></td></tr></table></figure>

<p>这将输出环境变量的值。</p>
</li>
<li><p><strong>查看所有环境变量</strong>：<br>若要查看所有系统环境变量，你可以使用 <code>set</code> 命令，不带任何参数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure>

<p>这将列出所有系统环境变量及其值。</p>
</li>
<li><p><strong>查看用户环境变量</strong>：<br>若要查看当前用户的环境变量，你可以使用 <code>set</code> 命令并附加 <code>/U</code> 选项，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set /U</span><br></pre></td></tr></table></figure>

<p>这将列出当前用户的环境变量及其值。</p>
</li>
</ol>
<p>请注意，你需要具有足够的权限才能查看系统环境变量。如果你是管理员，通常可以查看和编辑系统环境变量。如果你只是普通用户，你可以查看和编辑用户环境变量。</p>
<p>在命令提示符中查看环境变量对于调试和配置系统非常有用。你可以根据你的需求来使用这些命令来查看和管理环境变量。</p>
<h2 id="windows-截图快捷键"><a href="#windows-截图快捷键" class="headerlink" title="windows 截图快捷键"></a>windows 截图快捷键</h2><ul>
<li>要在具有鼠标和键盘时使用截图工具，请执行以下操作： 按Windows 徽标键‌+ Shift+ S。 选择屏幕截图的区域时，桌面将变暗。 默认情况下，选择“矩形模式”。</li>
</ul>
<h2 id="windows-cmd-创建文件"><a href="#windows-cmd-创建文件" class="headerlink" title="windows cmd 创建文件"></a>windows cmd 创建文件</h2><p>在Windows的命令提示符（CMD）中，您可以使用<code>echo</code>命令创建文本文件，也可以使用<code>copy con</code>命令手动输入文本内容并保存为文件。以下是一些示例：</p>
<ol>
<li><p>使用<code>echo</code>命令创建文本文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo Hello, World! &gt; filename.txt</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为<code>filename.txt</code>的文本文件，并将内容”Hello, World!”写入其中。如果文件已经存在，它将被覆盖。</p>
</li>
<li><p>使用<code>copy con</code>命令手动输入文本内容并保存为文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy con filename.txt</span><br></pre></td></tr></table></figure>

<p>然后，您可以输入文本内容，按Enter键，然后按<code>Ctrl + Z</code>组合键，然后再按Enter键来保存文件。这将创建一个名为<code>filename.txt</code>的文本文件，您可以在其中输入您想要的文本内容。</p>
</li>
<li><p>使用Notepad命令创建和编辑文本文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad filename.txt</span><br></pre></td></tr></table></figure>

<p>这将打开记事本文本编辑器，您可以在其中创建和编辑文本文件。保存文件后，关闭记事本即可。</p>
</li>
</ol>
<p>请注意，以上示例中的<code>filename.txt</code>可以替换为您想要的文件名和扩展名。您可以使用适当的文件路径来指定文件的位置。</p>
<h2 id="windows-键盘快捷键"><a href="#windows-键盘快捷键" class="headerlink" title="windows 键盘快捷键"></a>windows 键盘快捷键</h2><p>Windows 操作系统提供了许多不同的键盘快捷键，这些快捷键可以帮助您更快地执行各种任务。以下是一些常见的 Windows 键盘快捷键：</p>
<ol>
<li><p><strong>通用快捷键：</strong></p>
<ul>
<li><strong>Ctrl + C：</strong> 复制所选项。</li>
<li><strong>Ctrl + X：</strong> 剪切所选项。</li>
<li><strong>Ctrl + V：</strong> 粘贴剪切或复制的项。</li>
<li><strong>Ctrl + Z：</strong> 撤销上一步操作。</li>
<li><strong>Ctrl + Y：</strong> 重做上一步操作。</li>
<li><strong>Ctrl + A：</strong> 选择所有内容。</li>
<li><strong>Ctrl + S：</strong> 保存当前文件。</li>
</ul>
</li>
<li><p><strong>窗口管理快捷键：</strong></p>
<ul>
<li><strong>Alt + Tab：</strong> 切换打开的应用程序。</li>
<li><strong>Windows键 + Tab：</strong> 打开任务视图（Windows 10 及更新版本）。</li>
<li><strong>Alt + F4：</strong> 关闭当前窗口或应用程序。</li>
<li><strong>Windows键 + D：</strong> 最小化或还原所有窗口，显示桌面。</li>
<li><strong>Windows键 + 左&#x2F;右箭头键：</strong> 将当前窗口调整到屏幕的左侧或右侧一半。</li>
<li><strong>Windows键 + 上&#x2F;下箭头键：</strong> 最大化或恢复窗口，或最大化并将其固定在屏幕的底部。</li>
</ul>
</li>
<li><p><strong>浏览和桌面快捷键：</strong></p>
<ul>
<li><strong>Windows键 + E：</strong> 打开文件资源管理器。</li>
<li><strong>Windows键 + L：</strong> 锁定计算机或切换用户。</li>
<li><strong>Alt + F4：</strong> 关闭当前窗口或应用程序。</li>
<li><strong>Ctrl + Shift + Esc：</strong> 打开任务管理器。</li>
</ul>
</li>
<li><p><strong>其他有用的快捷键：</strong></p>
<ul>
<li><strong>Windows键 + R：</strong> 打开“运行”对话框。</li>
<li><strong>Ctrl + Shift + N：</strong> 在文件资源管理器中创建新文件夹。</li>
<li><strong>Alt + Enter：</strong> 在文件或文件夹上按下，打开其属性。</li>
<li><strong>Alt + Print Screen：</strong> 仅截取当前活动窗口。</li>
</ul>
</li>
</ol>
<p>这些是一些常见的 Windows 键盘快捷键，可以帮助您更高效地操作计算机。不同的 Windows 版本和应用程序可能有一些额外的特定快捷键。</p>
<h2 id="windows-切换虚拟窗口-快捷键"><a href="#windows-切换虚拟窗口-快捷键" class="headerlink" title="windows 切换虚拟窗口 快捷键"></a>windows 切换虚拟窗口 快捷键</h2><p>在 Windows 操作系统中，可以使用以下快捷键来在不同的虚拟桌面或任务视图之间进行切换：</p>
<ul>
<li><strong>Windows键 + Ctrl + 左箭头键</strong>：切换到左边的虚拟桌面或任务视图。</li>
<li><strong>Windows键 + Ctrl + 右箭头键</strong>：切换到右边的虚拟桌面或任务视图。</li>
</ul>
<p>这些快捷键可用于在 Windows 10 及更新版本中快速切换虚拟桌面，让您在不同的桌面上组织和管理不同的应用程序和任务。若您使用其他 Windows 版本，可能没有内置的虚拟桌面功能，因此可能无法使用这些快捷键。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
