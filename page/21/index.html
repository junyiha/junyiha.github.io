<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/21/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/21/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_01_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2024-05-22-C++_01_5_%E5%88%A4%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_01_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2024-05-22-C++_01_5_%E5%88%A4%E6%96%AD/" class="post-title-link" itemprop="url">C++_01_5_判断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ 中的判断</li>
</ul>
<h2 id="C-判断"><a href="#C-判断" class="headerlink" title="C++ 判断"></a>C++ 判断</h2><ul>
<li><p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p>
</li>
<li><p>判断语句</p>
<ul>
<li>if 语句	            一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。</li>
<li>if…else 语句	    一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。</li>
<li>嵌套 if 语句	    您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。</li>
<li>switch 语句	        一个 switch 语句允许测试一个变量等于多个值时的情况。</li>
<li>嵌套 switch 语句	您可以在一个 switch 语句内使用另一个 switch 语句。</li>
</ul>
</li>
<li><p>?: 运算符</p>
<ul>
<li>这是条件运算符，可以用来代替if…else语句。它的一般形式如下:<ul>
<li><code>Exp1 ? Exp2 : Exp3;</code></li>
</ul>
</li>
<li>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</li>
<li>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</li>
</ul>
</li>
</ul>
<h2 id="C-if-语句"><a href="#C-if-语句" class="headerlink" title="C++ if 语句"></a>C++ if 语句</h2><ul>
<li><p>一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。</p>
</li>
<li><p>语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(boolean_expression)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 如果布尔表达式为真将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果布尔表达式为 true，则 if 语句内的代码块将被执行。如果布尔表达式为 false，则 if 语句结束后的第一组代码（闭括号后）将被执行。</p>
</li>
<li><p>C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。</p>
</li>
</ul>
<h2 id="C-if…else-语句"><a href="#C-if…else-语句" class="headerlink" title="C++ if…else 语句"></a>C++ if…else 语句</h2><ul>
<li><p>一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。</p>
</li>
<li><p>语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(boolean_expression)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 如果布尔表达式为真将执行的语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 如果布尔表达式为假将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果布尔表达式为 true，则执行 if 块内的代码。如果布尔表达式为 false，则执行 else 块内的代码。</p>
</li>
<li><p>if…else if…else 语句</p>
<ul>
<li>一个 if 语句后可跟一个可选的 else if…else 语句，这可用于测试多种条件。</li>
<li>当使用 if…else if…else 语句时，以下几点需要注意：<ul>
<li>一个 if 后可跟零个或一个 else，else 必须在所有 else if 之后。</li>
<li>一个 if 后可跟零个或多个 else if，else if 必须在 else 之前。</li>
<li>一旦某个 else if 匹配成功，其他的 else if 或 else 将不会被测试。</li>
</ul>
</li>
</ul>
</li>
<li><p>语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(boolean_expression <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当布尔表达式 1 为真时执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( boolean_expression <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当布尔表达式 2 为真时执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( boolean_expression <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当布尔表达式 3 为真时执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当上面条件都不为真时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C-嵌套-if-语句"><a href="#C-嵌套-if-语句" class="headerlink" title="C++ 嵌套 if 语句"></a>C++ 嵌套 if 语句</h2><ul>
<li><p>在 C++ 中，嵌套 if-else 语句是合法的，这意味着您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。</p>
</li>
<li><p>嵌套 if 语句是一种 if 语句的变体，其中一个 if 语句可以在另一个 if 语句中嵌套。</p>
</li>
<li><p>嵌套 if 语句可以帮助您更精确地测试多个条件。</p>
</li>
<li><p>语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( boolean_expression <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 当布尔表达式 1 为 true 时执行</span></span><br><span class="line">   <span class="keyword">if</span>(boolean_expression <span class="number">2</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 当布尔表达式 2 为 ture 时执行</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>您可以嵌套 else if…else，方式与嵌套 if 语句相似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">   <span class="comment">// 如果 condition1 为 true，则执行此处的代码块</span></span><br><span class="line">   <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">      <span class="comment">// 如果 condition2 也为 true，则执行此处的代码块</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 condition2 为 false，则执行此处的代码块</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 如果 condition1 为 false，则执行此处的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C-switch-语句"><a href="#C-switch-语句" class="headerlink" title="C++ switch 语句"></a>C++ switch 语句</h2><ul>
<li><p>一个 switch 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 switch case 进行检查。</p>
</li>
<li><p>语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       <span class="built_in">statement</span>(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">// 可选的</span></span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       <span class="built_in">statement</span>(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">// 可选的</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 您可以有任意数量的 case 语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">// 可选的</span></span><br><span class="line">       <span class="built_in">statement</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch 语句必须遵循下面的规则：</p>
<ul>
<li>switch 语句中的 expression 必须是一个<strong>整型</strong>或<strong>枚举类型</strong>，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。</li>
<li>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</li>
<li>case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</li>
<li>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。</li>
<li>当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</li>
<li>不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。</li>
<li>一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 break 语句不是必需的。</li>
</ul>
</li>
</ul>
<h2 id="C-嵌套-switch-语句"><a href="#C-嵌套-switch-语句" class="headerlink" title="C++ 嵌套 switch 语句"></a>C++ 嵌套 switch 语句</h2><ul>
<li><p>您可以把一个 switch 作为一个外部 switch 的语句序列的一部分，即可以在一个 switch 语句内使用另一个 switch 语句。即使内部和外部 switch 的 case 常量包含共同的值，也没有矛盾。</p>
</li>
<li><p>C++ 中的 switch 语句允许至少 256 个嵌套层次。</p>
</li>
<li><p>语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch1) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;这个 A 是外部 switch 的一部分&quot;</span>;</span><br><span class="line">      <span class="keyword">switch</span>(ch2) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;这个 A 是内部 switch 的一部分&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">// 内部 B case 代码</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">// 外部 B case 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_99_other/2024-05-22-%E4%BD%8D%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_99_other/2024-05-22-%E4%BD%8D%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">位运算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>位运算相关笔记</li>
</ul>
<h2 id="什么是位运算？"><a href="#什么是位运算？" class="headerlink" title="什么是位运算？"></a>什么是位运算？</h2><ul>
<li>所谓位运算，就是对一个比特(bit)位进行操作。比特(bit)是一个电子元器件，8个比特构成一个字节(byte)，它已经是粒度最小的可操作单元了。一个比特(bit)位只有0和1两个取值。</li>
<li>C语言中不能直接使用二进制，位运算两边的操作符可以是十进制，八进制，十六进制，它们在内存中最终都是以二进制形式存储。</li>
<li>C语言提供了六种位运算符:<ul>
<li>运算符    &amp;      |       ^      ~    &lt;&lt;   &gt;&gt;</li>
<li>说明    按位与  按位或  按位异或  取反  左移  右移</li>
</ul>
</li>
</ul>
<h2 id="按位与运算"><a href="#按位与运算" class="headerlink" title="按位与运算(&amp;)"></a>按位与运算(&amp;)</h2><ul>
<li><p>参与 &amp; 运算的两个位都为 1 时，结果才为 1,否则为 0。例如 1&amp;1 为 1, 0&amp;0 为 0, 1&amp;0 也为 0,这和逻辑运算符 &amp;&amp; 非常类似。</p>
</li>
<li><p>常用场景：按位与运算通常用来对某些位清0</p>
<ul>
<li>取一个数中的某些指定位，保留一个数中的某些指定位<ul>
<li>例如要把n的高16位清0，保留低16位，可以进行 n&amp;0xFFFF 运算。(0xFFFF在内存中的存储行为 0000 0000 - 0000 0000 - 1111 1111 - 1111 1111)</li>
<li>清0。将一个单元与0进行位与运算结果为0</li>
<li>取一个数指定位为0。例如 置X&#x3D;1010 1101的高四位置0,则将X &amp; 0xF得到 0000 1101</li>
</ul>
</li>
<li>判断奇偶性：例如一个数 &amp;1 的结果就是取二进制最末位，这样可以判断一个整数的奇偶性，二进制的最末位为0表示偶数，为1表示奇数<ul>
<li>例如 if ((a &amp; 1) &#x3D;&#x3D; 0) 代替 if (a % 2 &#x3D;&#x3D; 0)来判断a是不是偶数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="按位或运算"><a href="#按位或运算" class="headerlink" title="按位或运算(|)"></a>按位或运算(|)</h2><ul>
<li><p>参与 | 运算的两个二进制位有一个为1时，结果就为1，两个都为0时，结果才为0。例如 1|1 为 1, 0 | 0 为0, 1 | 0为1,这和逻辑运算中的 || 非常类似。</p>
</li>
<li><p>常用场景: 按位或运算可以用来将某些位置1,或者保留某些位</p>
<ul>
<li>例如要把n的高16位置1,保留低16位，可以进行 n | 0xFFFF000运算 (0xFFFF000在内存中的存储形式为 1111 1111 - 1111 1111 - 0000 0000 - 0000 0000)</li>
</ul>
</li>
</ul>
<h2 id="char-int-long-float-double等在64位下占多少字节"><a href="#char-int-long-float-double等在64位下占多少字节" class="headerlink" title="char, int, long, float, double等在64位下占多少字节"></a>char, int, long, float, double等在<strong>64位</strong>下占多少字节</h2><ul>
<li>char : 1 byte</li>
<li>char* : 8 bytes</li>
<li>short int : 2 bytes</li>
<li>int : 4 bytes</li>
<li>unsigned int : 4 bytes</li>
<li>float : 4 bytes</li>
<li>double : 8 bytes</li>
<li><strong>long : 8 bytes</strong></li>
<li>long long : 8 bytes</li>
<li><strong>lonunsigned long : 8 bytes</strong></li>
</ul>
<h2 id="char-int-long-float-double等在32位下占多少字节"><a href="#char-int-long-float-double等在32位下占多少字节" class="headerlink" title="char, int, long, float, double等在32位下占多少字节"></a>char, int, long, float, double等在<strong>32位</strong>下占多少字节</h2><ul>
<li>char : 1 byte</li>
<li>char* : 4 bytes</li>
<li>short int : 2 bytes</li>
<li>int : 4 bytes</li>
<li>unsigned int : 4 bytes</li>
<li>float : 4 bytes</li>
<li>double : 8 bytes</li>
<li><strong>long : 4 bytes</strong></li>
<li>long long : 8 bytes</li>
<li><strong>unsigned long : 4 bytes</strong></li>
</ul>
<h2 id="addr-8-0xff"><a href="#addr-8-0xff" class="headerlink" title="(addr &gt;&gt; 8) &amp; 0xff"></a>(addr &gt;&gt; 8) &amp; 0xff</h2><ul>
<li><code>&gt;&gt;</code> : 右移</li>
<li>0xff: <code>0000 0000 0000 0000 0000 0000 1111 1111</code></li>
<li>&amp; 0xff的目的：只取出当前低(最右面)8位，其他位补0</li>
<li><code>&gt;&gt;</code>右移8位，之后 <code>&amp; 0xff</code>，则是取出未移位前数的高8位(当前数最右面的8位)的数值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> SndStr[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> addr;</span><br><span class="line"></span><br><span class="line">SndStr[<span class="number">8</span>] = (addr &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;  <span class="comment">// 取高8位(取高位字节)</span></span><br><span class="line">SndStr[<span class="number">9</span>] = addr &amp; <span class="number">0xff</span>;  <span class="comment">// 取低8位(取低位字节)</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_01_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2024-05-22-C++_01_6_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_01_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2024-05-22-C++_01_6_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">C++_01_6_基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>基础知识</li>
</ul>
<h2 id="C-大括号与生命周期的关系"><a href="#C-大括号与生命周期的关系" class="headerlink" title="C++ 大括号与生命周期的关系"></a>C++ 大括号与生命周期的关系</h2><p>在C++中，大括号 <code>&#123;&#125;</code> 通常用于定义作用域（scope）。作用域内的对象在进入大括号定义的作用域时被创建，当离开该作用域时被销毁。这与对象的生命周期密切相关。</p>
<p>考虑以下示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before scope\n&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        MyClass obj; <span class="comment">// 在作用域内定义对象</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside scope\n&quot;</span>;</span><br><span class="line">    &#125; <span class="comment">// 离开作用域，对象被销毁</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After scope\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出将是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Before scope</span><br><span class="line">Constructor</span><br><span class="line">Inside scope</span><br><span class="line">Destructor</span><br><span class="line">After scope</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyClass</code>的对象在进入大括号定义的作用域时创建（构造函数被调用），并在离开该作用域时销毁（析构函数被调用）。这说明了大括号与对象生命周期的密切关系。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_01_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2024-05-22-C++_01_4_template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_01_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2024-05-22-C++_01_4_template/" class="post-title-link" itemprop="url">C++_01_4_template</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ 模板相关笔记</li>
</ul>
<h2 id="C-模板是什么"><a href="#C-模板是什么" class="headerlink" title="C++ 模板是什么"></a>C++ 模板是什么</h2><p>C++ 模板是一种编程工具，允许程序员编写通用代码，不受特定数据类型的限制。它们允许在编译时进行参数化类型，允许创建函数模板和类模板。</p>
<p>模板在 C++ 中用于生成通用代码，这些代码可以根据不同的数据类型或参数进行实例化。主要有两种类型的模板：</p>
<ol>
<li>函数模板（Function Templates）：允许定义一个通用函数，可以在不同数据类型下工作。例如，可以编写一个模板函数来交换两个值，无论这两个值的类型是什么。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapValues</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>类模板（Class Templates）：允许定义一个通用类，可以在不同数据类型下使用。例如，可以创建一个模板类来实现动态数组，其中数组的元素类型可以根据需要指定。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DynamicArray</span>(<span class="type">int</span> s) : <span class="built_in">size</span>(s) &#123;</span><br><span class="line">        array = <span class="keyword">new</span> T[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他成员函数和操作...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>模板使用关键字 <code>template</code> 来声明，并且通常使用 <code>typename</code> 或 <code>class</code> 关键字定义模板参数。在使用模板时，编译器会根据具体的使用情况生成特定类型的代码。例如，可以使用 <code>swapValues</code> 函数模板交换整数、浮点数或自定义类型等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">5</span>, num2 = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">swapValues</span>(num1, num2); <span class="comment">// 调用模板函数交换整数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> val1 = <span class="number">3.14</span>, val2 = <span class="number">6.28</span>;</span><br><span class="line">    <span class="built_in">swapValues</span>(val1, val2); <span class="comment">// 调用模板函数交换浮点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用类模板</span></span><br><span class="line">    <span class="function">DynamicArray&lt;<span class="type">int</span>&gt; <span class="title">intArray</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建一个存储整数的动态数组</span></span><br><span class="line">    <span class="function">DynamicArray&lt;<span class="type">double</span>&gt; <span class="title">doubleArray</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// 创建一个存储双精度浮点数的动态数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板是 C++ 中非常强大和灵活的功能，能够提高代码的复用性，并允许以一种通用的方式处理不同类型的数据。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul>
<li><p>模板，是一种用（其他）类型和算法对类型和算法进行<strong>参数化</strong>的机制。用户自定义类型和内置类型的计算表现为函数，有时泛化为模板函数和函数对象。</p>
</li>
<li><p><code>template &lt;typename T&gt;</code> : 指明T是该声明的形参，它是数学上“对所有T”或“对所有类型T”的C++表达。</p>
</li>
<li><p>从一个模板和一个模板实参列表生成一个类或者一个函数的过程通常被称为<strong>模板实例化(template instantiation)<strong>。一个模板针对某个特定模板实参列表的版本被称为</strong>特例化(specialization)</strong></p>
</li>
<li><p>一般来说，保证从所有的模板实参列表生成模板的特例化是C++实现的责任，而不是程序员的任务。</p>
</li>
<li><p>模板是什么？或者换句话说，当使用模板时，什么程序设计技术更有效？模板提供了：</p>
<ul>
<li>传递类型参数（像传递值和模板一样）而不丢失信息的能力。则意味着有大好的机会进行内联，当前的C++实现的确充分利用了这一点</li>
<li>推迟的类型检查（在实例化时进行）。这意味着有机会将来自不同上下文的信息编织在一起</li>
<li>传递常量参数的能力。这意味着能进行编译时计算</li>
</ul>
</li>
<li><p>换句话说，模板为编译时计算和类型处理提供了一种强有力的机制，可以生成非常紧凑和高效的代码。记住：类型（类）既可以包含代码也可以包含值。</p>
</li>
<li><p>模板的首要用途，也是它最常见的用途，是支持泛型程序设计(<code>generic programming</code>)，即关注通用算法设计，实现和使用的程序设计。</p>
</li>
<li><p>在这里，”通用“的含义是算法可以接受各种各样的实参类型，只要这些类型满足算法对实参的要求即可。模板是C++支持泛型程序设计的主要特性。它提供了（编译时）参数化多态。</p>
</li>
<li><p>更多地关注代码生成技术（将模板看作类型和函数的生成器），并依赖类型函数表示编译时计算的编程方式被称为<strong>模板元程序设计(<code>template metaprogramming</code>)</strong></p>
</li>
</ul>
<h3 id="C-模板详解"><a href="#C-模板详解" class="headerlink" title="C++模板详解"></a>C++模板详解</h3><ul>
<li><p>模板是C++支持<strong>参数化多态</strong>的工具，使用模板可以使用户为类或者函数声明一种一般模式，<strong>使得类中的某些数据成员或者成员函数的参数，返回值取得任意类型</strong>。</p>
</li>
<li><p>模板是一种对类型进行参数化的工具；</p>
</li>
<li><p>通常有两种形式：函数模板和类模板</p>
<ul>
<li>函数模板针对仅参数类型不同的函数</li>
<li>类模板针对仅数据成员和成员函数类型不同的类</li>
</ul>
</li>
<li><p>使用模板的目的就是能够让程序员编写与类型无关的代码</p>
</li>
<li><p>模板的声明或定义只能在全局，命名空间或类范围内进行。即，<strong>不能在局部范围，函数内进行声明</strong>。例如：不能在<code>main()</code>函数中声明或定义一个模板。</p>
</li>
<li><p>函数模板通式</p>
<ul>
<li>函数模板的格式：<ul>
<li><code>template &lt;class 形参名，class 形参名，......&gt;返回类型 函数名(参数列表）&#123;函数体&#125;</code></li>
</ul>
</li>
</ul>
<ul>
<li>其中，<code>template</code>和<code>class</code>是关键字，**<code>class</code>可以用<code>typename</code>关键字代替，在这里<code>typename</code>和<code>class</code>没有什么区别**</li>
<li><code>&lt;&gt;</code>括号中的参数叫模板形参，模板形参和函数形参很像，模板形参不能为空。</li>
<li>一旦声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内只类型的地方都可以使用模板形参名</li>
<li>模板形参需要调用该模板函数时提供的模板实参来初始化模板形参，一旦编译器确定了实际的模板实参类型，就称它实例化了函数模板的一个实例。</li>
<li>当调用这样的模板函数时，类型T就会被调用时的类型所代替。例如：<code>swap(a,b)</code>其中a和b是int型，这时模板函数<code>swap</code>中的形参T就会被int所代替，模板函数就变为<code>swap(int &amp;a, int &amp;b)</code>。而当<code>swap(c,d)</code>其中c和d是double类型时，模板函数会被替换为<code>swap(double&amp;a, double &amp;b)</code>。如此以来，就实现了函数的实现与类型无关的代码。</li>
</ul>
<ul>
<li><strong>注意</strong><ul>
<li>对于函数模板而言不存在<code>h(int, int)</code>这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行<code>h(2,3)</code>这样的调用，或者<code>int a,b; h(a,b)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>类模板通式</p>
<ul>
<li>类模板的格式为：<code>template&lt;class 形参名，class 形参名，...&gt; class 类名 &#123;...&#125;;</code></li>
<li>类模板和函数模板都是以<code>template</code>开始后接模板形参列表组成，模板形参不能为空，一旦声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来表示。例如<code>template&lt;class T&gt; class A&#123;public: T a; T b; T hy(T c, T &amp;d)；&#125;;</code></li>
<li>在类A中声明了两个类型为<code>T</code>的成员变量<code>a</code>和<code>b</code>，还声明了一个返回类型为<code>T</code>带两个参数类型为<code>T</code>的函数hy</li>
</ul>
<ul>
<li>类模板对象的创建：<ul>
<li>例如一个模板类A，则使用类模板创建对象的方法为<code>A&lt;int&gt; m</code>;在类A后面跟上一个<code>&lt;&gt;</code>尖括号并在里面天上相应的类型，这样的话类A中凡是用到模板形参的地方都会被<code>int</code>所代替。当类模板有两个模板形参时创建对象的方法为<code>A&lt;int, double&gt; m</code>;类型之间使用逗号隔开。</li>
<li><strong>对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。</strong>例如：<code>A&lt;2&gt; m</code>；使用这种方法把模板形参设置为int是错误的（编译错误:<code>error C2079:&#39;a&#39; uses undefined class &#39;A&lt;int&gt;&#39;</code>）,类模板形参不存在实参推演的问题。也就是说：<strong>不能把整型值2推演为int型传递给模板形参，要把类模板形参调置为int型必须这样指定&#96;A<int> m</strong>。</li>
</ul>
</li>
<li>再次注意：模板的声明或定义只能在全局，命名空间或类范围内进行，即不能在局部范围，函数内进行。</li>
</ul>
</li>
</ul>
<h2 id="模板的形参"><a href="#模板的形参" class="headerlink" title="模板的形参"></a>模板的形参</h2><ul>
<li>有三种类型的模板形参：类型形参，非类型形参和模板形参</li>
</ul>
<h3 id="类型形参"><a href="#类型形参" class="headerlink" title="类型形参"></a>类型形参</h3><ul>
<li>类型模板形参：类型形参由关键字<code>class</code>或<code>typename</code>后接说明符构成，例如<code>template&lt;class T&gt; void h(T, a)&#123;&#125;;</code>其中，<code>T</code>就是一个类型形参，类型形参的名字由用户自己确定</li>
<li>模板形参表示的是一个未知的类型。模板类型形参可作为类型说明符用在模板中的任何地方，与内置类型说明符或类类型说明符的使用方式完全相同，即<strong>可以用于指定返回类型，变量声明等</strong>。</li>
<li><strong>函数模板：</strong>不能为同一个模板类型形参指定两种不同的类型，例如<code>template&lt;class T&gt;void h(T a, Tb)&#123;&#125;</code>, 语句调用<code>h(2, 3.2)</code>将出错<ul>
<li>因为该语句给同一个模板形参T指定了两种类型，第一个实参2把模板形参T指定为int，而第二个实参3.2把模板形参指定为double，两种类型的形参不一致，会出错</li>
</ul>
</li>
<li><strong>类模板：</strong>当我们声明类对象为：<code>A&lt;int&gt; a</code>，例如：<code>template&lt;class T&gt;T g(T a, T b)&#123;&#125;</code>,语句调用<code>a.g(2, 3.2)</code>在编译时不会出错，但是会有警告。<ul>
<li>因为在声明类对象的时候已经将T转换为T类型，而第二个实参3.2把模板形参指定为double，在运行时，会对3.2进行强制类型转换为3。</li>
<li>当我们声明类的对象为:<code>A&lt;double&gt; a</code>，此时，就不会有上面的警告，因为从int到double时自动类型转换。</li>
</ul>
</li>
</ul>
<h3 id="非类型形参"><a href="#非类型形参" class="headerlink" title="非类型形参"></a>非类型形参</h3><ul>
<li>非类型模板形参：模板的非类型形参也就是内置类型形参，例如:<code>template &lt;class T, int a&gt; class B&#123;&#125;;</code>其中<code>int a</code>就是非类型的模板形参</li>
<li>非类型形参在模板定义的内部时常量值，也就是说非类型形参在模板的内部是常量</li>
<li>非类型模板的形参只能是整形，指针和引用</li>
<li>调用非类型模板形参的实参必须是一个常量表达式，即它必须能在编译时计算出结果</li>
<li>注意：<ul>
<li>任何局部对象，局部变量，局部对象的地址，局部变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参。</li>
<li>全局指针类型，全局变量，全局对象也不是一个常量表达式，不能用作非类型模板形参的实参</li>
</ul>
</li>
<li>全局变量的地址或引用，全局对象的地址或引用const类型常量是常量表达式，可以用作非类型模板形参的实参</li>
<li>非类型形参一般不应用于函数模板中</li>
</ul>
<h3 id="类模板的默认模板类型形参"><a href="#类模板的默认模板类型形参" class="headerlink" title="类模板的默认模板类型形参"></a>类模板的默认模板类型形参</h3><ul>
<li>可以为类模板的类型形参提供默认值，但是不能为函数模板的类型形参提供默认值。</li>
<li>函数模板和类模板都可以为模板的非类型形参提供默认值</li>
<li><strong>类模板的类型形参默认值形式为:<code>template &lt;class T1, class T2=int&gt; class A&#123;&#125;;</code>为第二个模板类型形参T2提供int型的默认值</strong></li>
<li>类模板类型形参默认值和函数的默认参数一样，如果有多个类型形参则从第一个形参设定了默认值之后的所有模板形参都要设定默认值，例如:<code>template&lt;class T1=int, class T2&gt; classA&#123;&#125;;</code>就是错误的，因为T1给出了默认值，而T2没有设定</li>
<li>在类模板的外部定义类中的成员时,<code>template</code>后的形参表应该省略默认的形参类型。例如：<code>template&lt;class T1, class T2=int&gt; class A&#123;public:void h();&#125;;</code>定义方法为：<code>template&lt;class T1, clas T2&gt; void A&lt;T1, T2&gt;::h()&#123;&#125;</code></li>
</ul>
<h3 id="算法和提升"><a href="#算法和提升" class="headerlink" title="算法和提升"></a>算法和提升</h3><ul>
<li><p>函数模板就是普通函数的泛化：它能对多种数据类型执行动作，并且能够用以参数方式传递来的各种操作实现要执行的动作。</p>
</li>
<li><p>算法(<code>algorithm</code>)就是一个求解问题的过程或公式：通过一个有穷的计算序列生成结果。因此，函数模板通常也称为算法。</p>
</li>
<li><p>如何将一个在特定数据类型上执行特定操作的函数泛化为一个在多种数据类型上执行更通用操作的算法呢？最有效的方法是从一个（多个可能更好）具体实例来泛化出一个好的算法。这种泛化过程就称为提升(<code>lifting</code>)：即，从特殊函数提升为一个通用算法。</p>
</li>
<li><p>在这样一个由具体到抽象的过程中，最重要的一点是保持性能并注意如何做才合理。</p>
</li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>有效处理模板参数传递问题的第一步是建立一个用于讨论模板实参的要求的框架和词汇表。</p>
</li>
<li><p>我们可以<strong>将一组对模板实参的要求看作一个谓词</strong>。例如，可以将“C必须是一个容器”看作一个谓词，它接受一个类型参数C，若C是一个容器则返回true（我们应该已经定义了什么是“容器”），否则返回false。</p>
</li>
<li><p>例如，<code>Container&lt;vector&lt;int&gt;&gt;()</code>和<code>Container&lt;list&lt;string&gt;&gt;()</code>应该为真，而<code>Container&lt;int&gt;()</code>和<code>Container&lt;shared_ptr&lt;string&gt;&gt;()</code>应该为假。</p>
</li>
<li><p>我们称这种<strong>谓词</strong>为**概念(concept)**。概念并非C++中的语言结构，它是一种理念，可以用来推理对模板实参的要求，可以用于注释中，有时可以用我们自己的代码来实现。</p>
</li>
<li><p>初学者可以将一个概念看作一个设计工具：通过一组注释来说明<code>Container&lt;T&gt;()</code>，指出T必须满足什么性质才能使<code>Container&lt;T&gt;()</code>为真。例如</p>
<ul>
<li><code>T</code>必须有下标运算符(<code>[]</code>)</li>
<li><code>T</code>必须有成员函数<code>size()</code></li>
<li><code>T</code>必须有成员类型<code>value_type</code>，它是元素的类型。</li>
</ul>
</li>
<li><p>就像“普通类”一样，类模板可以有任意类型的数据成员。非<code>static</code>数据成员可以在其定义时初始化，也可以在构造函数中初始化</p>
</li>
<li><p>与”普通类“一样，非<code>static</code>成员函数的定义可以在类模板内部，也可以在外部</p>
</li>
</ul>
<h3 id="概念和约束"><a href="#概念和约束" class="headerlink" title="概念和约束"></a>概念和约束</h3><ul>
<li><p>概念不是任意的属性集合。大多数类型（或一组类型）的属性列表并不能给出一个一致，有用的概念定义。要成为一个有用的概念，要求列表必须反映模板类的一组算法或一组操作的需求。</p>
</li>
<li><p>我为概念设定的标准非常高：我要求一个概念具有通用性，一定程度的稳定性，广泛的算法适用性，语义一致性以及其他很多性质。实际上，按照我的标准，很多常见的模板实参的简单约束都不够格称为概念。</p>
</li>
<li><p>我认为这是不可避免的。特别是，我们编写过很多模板，它们并不能很好地反映通用算法或广泛应用的类型。相反，它们的重点是实现细节，它们的实参只反映了单一模板的必要细节，而这些模板只是为特定实现中的特定用途而设计的。我将这种模板实参的要求称为约束(<code>constraint</code>)或特殊概念(<code>ad hoc concept</code>)</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_01_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2024-05-22-C++_01_3_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_01_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2024-05-22-C++_01_3_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C++_01_3_语言基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ 语言基础知识</li>
</ul>
<h2 id="C-简介"><a href="#C-简介" class="headerlink" title="C++ 简介"></a>C++ 简介</h2><ul>
<li>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</li>
<li>C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。</li>
<li>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。</li>
<li>C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。</li>
<li>注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</li>
</ul>
<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><ul>
<li>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：<ul>
<li>封装（Encapsulation）：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。</li>
<li>继承（Inheritance）：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。</li>
<li>多态（Polymorphism）：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。</li>
<li>抽象（Abstraction）：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。</li>
</ul>
</li>
</ul>
<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><ul>
<li>标准的 C++ 由三个重要部分组成：<ul>
<li>核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。</li>
<li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li>
<li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li>
</ul>
</li>
</ul>
<h2 id="ANSI标准"><a href="#ANSI标准" class="headerlink" title="ANSI标准"></a>ANSI标准</h2><ul>
<li>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。</li>
<li>由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。</li>
</ul>
<h2 id="常见C-编译器制造商"><a href="#常见C-编译器制造商" class="headerlink" title="常见C++编译器制造商"></a>常见C++编译器制造商</h2><p>C++ 编译器是将 C++ 程序源代码转换为可执行程序的工具。它们负责将源代码翻译成机器代码，以便计算机可以理解和执行。C++ 编译器制造商是开发和维护这些编译器的公司或组织。以下是一些常见的 C++ 编译器制造商以及他们的一些特点：</p>
<ol>
<li><p><strong>GNU Compiler Collection (GCC)</strong>:</p>
<ul>
<li>制造商：自由软件基金会（Free Software Foundation）</li>
<li>特点：GCC 是一个开源编译器集合，支持多种编程语言，包括 C++。它是许多 Unix 和 Linux 发行版的默认编译器，并且在跨平台开发中广泛使用。GCC 遵循开放标准并且具有强大的优化能力。</li>
</ul>
</li>
<li><p><strong>Clang</strong>:</p>
<ul>
<li>制造商：LLVM 项目</li>
<li>特点：Clang 是 LLVM 编译器基础设施的一部分，它支持 C++ 和其他编程语言。Clang 以其快速的编译速度和准确的诊断能力而闻名。它被广泛用于 C++ 开发和跨平台移动应用程序开发。</li>
</ul>
</li>
<li><p><strong>Microsoft Visual C++</strong>:</p>
<ul>
<li>制造商：微软公司</li>
<li>特点：Visual C++ 是 Windows 平台上的主要 C++ 编译器。它集成在 Visual Studio 开发环境中，为 Windows 开发提供了丰富的工具和库。Visual C++ 遵循微软的特定标准，并且与 Windows API 紧密集成。</li>
</ul>
</li>
<li><p><strong>Intel C++ Compiler</strong>:</p>
<ul>
<li>制造商：英特尔公司</li>
<li>特点：Intel C++ 编译器专注于优化，特别是针对英特尔处理器的优化。它通常用于高性能计算和科学计算领域，以提高代码在英特尔架构上的性能。</li>
</ul>
</li>
<li><p><strong>IBM XL C&#x2F;C++</strong>:</p>
<ul>
<li>制造商：IBM</li>
<li>特点：IBM 的 XL C&#x2F;C++ 编译器主要用于 IBM 的大型服务器和超级计算机上。它支持多种操作系统和架构，并提供了许多高级编译器优化。</li>
</ul>
</li>
<li><p><strong>ARM Compiler</strong>:</p>
<ul>
<li>制造商：ARM Holdings</li>
<li>特点：ARM Compiler 是专门为 ARM 架构处理器设计的编译器。它用于嵌入式系统和移动设备的开发，以及一些嵌入式 Linux 系统。</li>
</ul>
</li>
<li><p><strong>其他厂商</strong>：除了上述制造商之外，还有许多其他公司和组织开发了各种 C++ 编译器，包括商业和开源编译器，以满足不同需求和平台的开发者。</p>
</li>
</ol>
<p>选择合适的 C++ 编译器通常取决于项目的要求、目标平台和性能需求。不同的编译器可能会对标准的支持程度、代码优化和诊断能力等方面有所不同，因此开发者需要根据项目的具体需求来选择合适的编译器。此外，一些项目可能会选择多个编译器进行测试和优化，以确保代码在不同环境下都能正常运行和性能出色。</p>
<h2 id="学习C"><a href="#学习C" class="headerlink" title="学习C++"></a>学习C++</h2><ul>
<li>学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。</li>
<li>学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。</li>
<li>C++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。</li>
</ul>
<h2 id="C-的使用"><a href="#C-的使用" class="headerlink" title="C++的使用"></a>C++的使用</h2><ul>
<li>C++ 语言在许多行业和领域都有广泛应用，包括：<ul>
<li>游戏开发：C++ 是游戏开发领域中最常用的编程语言之一，因为它具有高效的性能和直接控制硬件的能力。许多主要的游戏引擎，如 Unreal Engine 和 Unity，都使用 C++ 编写。</li>
<li>嵌入式系统开发：C++ 可以在嵌入式系统中发挥重要作用，如智能手机、汽车、机器人和家电等领域。由于嵌入式系统通常具有严格的资源限制和实时要求，因此 C++ 的高效性能和内存控制功能非常有用。</li>
<li>金融领域：C++ 在金融领域中被广泛应用，如高频交易、算法交易和风险管理等领域。由于这些应用程序需要高效的性能和对硬件的直接控制，C++ 语言是一个合适的选择。</li>
<li>图形图像处理：C++ 可以用于开发图形和图像处理应用程序，如计算机视觉、计算机图形学和人工智能领域。由于这些应用程序需要高效的计算能力和对硬件的控制，因此 C++ 是一个很好的选择。</li>
<li>科学计算和数值分析：C++ 可以用于开发科学计算和数值分析应用程序，如数值模拟和高性能计算等领域。由于这些应用程序需要高效的计算能力和对硬件的直接控制，C++ 语言是一个很好的选择。</li>
</ul>
</li>
</ul>
<h2 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C++基本语法"></a>C++基本语法</h2><ul>
<li>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。<ul>
<li>对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。</li>
<li>类 - 类可以定义为描述对象行为&#x2F;状态的模板&#x2F;蓝图。</li>
<li>方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。</li>
<li>即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。</li>
</ul>
</li>
</ul>
<h2 id="C-中的分号，语句块"><a href="#C-中的分号，语句块" class="headerlink" title="C++中的分号，语句块"></a>C++中的分号，语句块</h2><ul>
<li><p>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。</p>
</li>
<li><p>例如，下面是三个不同的语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br><span class="line">y = y<span class="number">+1</span>;</span><br><span class="line"><span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure>
</li>
<li><p>语句块是一组使用大括号括起来的按逻辑连接的语句。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。</p>
</li>
</ul>
<h2 id="C-标识符"><a href="#C-标识符" class="headerlink" title="C++标识符"></a>C++标识符</h2><ul>
<li>C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</li>
<li>C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，Manpower 和 manpower 是两个不同的标识符。</li>
</ul>
<h2 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h2><ul>
<li>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。</li>
<li>三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。</li>
<li>三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。</li>
</ul>
<h2 id="C-中的空格"><a href="#C-中的空格" class="headerlink" title="C++中的空格"></a>C++中的空格</h2><ul>
<li>只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。</li>
<li>在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br></pre></td></tr></table></figure></li>
<li>在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fruit = apples + oranges;   <span class="comment">// 获取水果的总数</span></span><br></pre></td></tr></table></figure></li>
<li>fruit 和 &#x3D;，或者 &#x3D; 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。</li>
</ul>
<h2 id="C-注释"><a href="#C-注释" class="headerlink" title="C++注释"></a>C++注释</h2><ul>
<li>程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。</li>
<li>C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。</li>
<li>C++ 注释一般有两种：<ul>
<li>&#x2F;&#x2F; - 一般用于单行注释。</li>
<li>&#x2F;* … *&#x2F; - 一般用于多行注释。</li>
</ul>
</li>
</ul>
<h2 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++数据类型"></a>C++数据类型</h2><ul>
<li>使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。</li>
<li>您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。</li>
</ul>
<h2 id="基本的内置类型"><a href="#基本的内置类型" class="headerlink" title="基本的内置类型"></a>基本的内置类型</h2><ul>
<li><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p>
<ul>
<li>布尔型 : bool</li>
<li>字符型 : char</li>
<li>整型 : int</li>
<li>浮点型 : float</li>
<li>双浮点型 : double </li>
<li>无类型 : void</li>
<li>宽字符型 : wchar_t</li>
</ul>
</li>
<li><p>typedef 声明</p>
<ul>
<li>可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</li>
<li><code>typedef type newname</code></li>
</ul>
</li>
<li><p>枚举类型：</p>
<ul>
<li>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</li>
<li>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</li>
<li>创建枚举，需要使用关键字 enum。枚举类型的一般形式为：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名&#123; </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>类型转换</p>
<ul>
<li>类型转换是将一个数据类型的值转换为另一种数据类型的值。</li>
<li>C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。</li>
</ul>
</li>
<li><p>静态转换（Static Cast）</p>
<ul>
<li>静态转换是将一种数据类型的值强制转换为另一种数据类型的值。</li>
<li>静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。</li>
<li>静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。</li>
</ul>
</li>
<li><p>动态转换（Dynamic Cast）</p>
<ul>
<li>动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 将基类指针转换为派生类指针</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>常量转换（Const Cast）</p>
<ul>
<li>常量转换用于将 const 类型的对象转换为非 const 类型的对象。</li>
<li>常量转换只能用于转换掉 const 属性，不能改变对象的类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(i); <span class="comment">// 常量转换，将const int转换为int</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重新解释转换（Reinterpret Cast）</p>
<ul>
<li>重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换</li>
<li>重新解释转换不进行任何类型检查，因此可能会导致未定义的行为<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>&amp;&gt;(i); <span class="comment">// 重新解释将int类型转换为float类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="C-变量类型"><a href="#C-变量类型" class="headerlink" title="C++ 变量类型"></a>C++ 变量类型</h2><ul>
<li><p>变量其实只不过是程序可操作的存储区的名称</p>
</li>
<li><p>在 C++ 中，有多种变量类型可用于存储不同种类的数据。</p>
</li>
<li><p>C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头</p>
</li>
<li><p>大写字母和小写字母是不同的，因为 C++ 是大小写敏感的</p>
</li>
<li><p>基本的变量类型</p>
<ul>
<li>bool  : 布尔类型，存储值 true 或 false，占用 1 个字节。</li>
<li>char  : 字符类型，用于存储 ASCII 字符，通常占用 1 个字节。</li>
<li>int   : 整数类型，通常用于存储普通整数，通常占用 4 个字节。</li>
<li>float : 单精度浮点值，用于存储单精度浮点数。单精度是这样的格式，1 位符号，8 位指数，23 位小数，通常占用4个字节。</li>
<li>double  : 双精度浮点值，用于存储双精度浮点数。双精度是 1 位符号，11 位指数，52 位小数，通常占用 8 个字节。</li>
<li>void    : 表示类型的缺失。</li>
<li>wchar_t : 宽字符类型，用于存储更大范围的字符，通常占用 2 个或 4 个字节</li>
</ul>
</li>
<li><p>整数类型（Integer Types）：</p>
<ul>
<li>int：用于表示整数，通常占用4个字节。</li>
<li>short：用于表示短整数，通常占用2个字节。</li>
<li>long：用于表示长整数，通常占用4个字节。</li>
<li>long long：用于表示更长的整数，通常占用8个字节。</li>
</ul>
</li>
<li><p>浮点类型（Floating-Point Types）：</p>
<ul>
<li>float：用于表示单精度浮点数，通常占用4个字节。</li>
<li>double：用于表示双精度浮点数，通常占用8个字节。</li>
<li>long double：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。</li>
</ul>
</li>
<li><p>字符类型（Character Types）：</p>
<ul>
<li>char：用于表示字符，通常占用1个字节。</li>
<li>wchar_t：用于表示宽字符，通常占用2或4个字节。</li>
<li>char16_t：用于表示16位Unicode字符，占用2个字节。</li>
<li>char32_t：用于表示32位Unicode字符，占用4个字节。</li>
</ul>
</li>
<li><p>布尔类型（Boolean Type）：</p>
<ul>
<li>bool：用于表示布尔值，只能取true或false。</li>
</ul>
</li>
<li><p>枚举类型（Enumeration Types）：</p>
<ul>
<li>enum：用于定义一组命名的整数常量。</li>
</ul>
</li>
<li><p>指针类型（Pointer Types）：</p>
<ul>
<li>type*：用于表示指向类型为type的对象的指针。</li>
</ul>
</li>
<li><p>数组类型（Array Types）：</p>
<ul>
<li>type[]或type[size]：用于表示具有相同类型的元素组成的数组。</li>
</ul>
</li>
<li><p>结构体类型（Structure Types）：</p>
<ul>
<li>struct：用于定义包含多个不同类型成员的结构。</li>
</ul>
</li>
<li><p>类类型（Class Types）：</p>
<ul>
<li>class：用于定义具有属性和方法的自定义类型。</li>
</ul>
</li>
<li><p>共用体类型（Union Types）：</p>
<ul>
<li>union：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型。</li>
</ul>
</li>
<li><p>C++ 中的变量定义</p>
<ul>
<li>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。</li>
</ul>
</li>
<li><p>变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p>
<ul>
<li>type variable_list;</li>
</ul>
</li>
<li><p>在这里，type 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。</p>
</li>
<li><p>变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：</p>
</li>
<li><p>type variable_name &#x3D; value;</p>
</li>
<li><p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>
</li>
<li><p>C++ 中的变量声明</p>
<ul>
<li>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明</li>
<li>当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次</li>
</ul>
</li>
<li><p>C++ 中的左值(Lvalues)和右值(Rvalues)</p>
</li>
<li><p>C++ 中有两种类型的表达式：</p>
<ul>
<li>左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边</li>
<li>右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ul>
</li>
<li><p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p>
<ul>
<li>int g &#x3D; 20;</li>
</ul>
</li>
<li><p>但是下面这个就不是一个有效的语句，会生成编译时错误：</p>
<ul>
<li>10 &#x3D; 20;</li>
</ul>
</li>
</ul>
<h2 id="C-变量作用域"><a href="#C-变量作用域" class="headerlink" title="C++ 变量作用域"></a>C++ 变量作用域</h2><ul>
<li><p>一般来说有三个地方可以定义变量：</p>
<ul>
<li>在函数或一个代码块内部声明的变量，称为局部变量。</li>
<li>在函数参数的定义中声明的变量，称为形式参数。</li>
<li>在所有函数外部声明的变量，称为全局变量</li>
</ul>
</li>
<li><p>作用域是程序的一个区域，变量的作用域可以分为以下几种：</p>
<ul>
<li>局部作用域：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。</li>
<li>全局作用域：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。</li>
<li>块作用域：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。</li>
<li>类作用域：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。</li>
</ul>
</li>
<li><p>注意：如果在内部作用域中声明的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部作用域中的变量。</p>
</li>
<li><p>局部变量</p>
<ul>
<li>在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。</li>
</ul>
</li>
<li><p>全局变量</p>
<ul>
<li>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。</li>
<li>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。</li>
<li>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值</li>
</ul>
</li>
<li><p>初始化局部变量和全局变量</p>
<ul>
<li>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：<ul>
<li>int : 0</li>
<li>char : ‘\0’</li>
<li>float : 0</li>
<li>double : 0</li>
<li>pointer : NULL</li>
</ul>
</li>
<li>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果</li>
</ul>
</li>
<li><p>类作用域</p>
<ul>
<li>类作用域指的是在类内部声明的变量</li>
</ul>
</li>
</ul>
<h2 id="C-常量"><a href="#C-常量" class="headerlink" title="C++ 常量"></a>C++ 常量</h2><ul>
<li><p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量</p>
</li>
<li><p>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值</p>
</li>
<li><p>常量就像是常规的变量，只不过常量的值在定义后不能进行修改</p>
</li>
<li><p>整数常量</p>
<ul>
<li>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制</li>
<li>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</li>
<li>以下是各种类型的整数常量的实例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">85</span>         <span class="comment">// 十进制</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">// 八进制 </span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">// 十六进制 </span></span><br><span class="line"><span class="number">30</span>         <span class="comment">// 整数 </span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">// 无符号整数 </span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">// 长整数 </span></span><br><span class="line"><span class="number">30ul</span>       <span class="comment">// 无符号长整数</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>浮点常量</p>
<ul>
<li>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</li>
<li>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</li>
<li>下面列举几个浮点常量的实例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14159</span>       <span class="comment">// 合法的 </span></span><br><span class="line"><span class="number">314159E-5L</span>    <span class="comment">// 合法的 </span></span><br><span class="line"><span class="number">510</span>E          <span class="comment">// 非法的：不完整的指数</span></span><br><span class="line"><span class="number">210</span>f          <span class="comment">// 非法的：没有小数或指数</span></span><br><span class="line">.e55          <span class="comment">// 非法的：缺少整数或分数</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>布尔常量</p>
<ul>
<li>布尔常量共有两个，它们都是标准的 C++ 关键字：<ul>
<li>true 值代表真。</li>
<li>false 值代表假。</li>
</ul>
</li>
<li>我们不应把 true 的值看成 1，把 false 的值看成 0。</li>
</ul>
</li>
<li><p>字符常量</p>
<ul>
<li>字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 char 类型的简单变量中。</li>
<li>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）</li>
<li>在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：</li>
</ul>
</li>
<li><p>字符串常量</p>
<ul>
<li>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</li>
<li>您可以使用 \ 做分隔符，把一个很长的字符串常量进行分行。</li>
</ul>
</li>
<li><p>定义常量：</p>
<ul>
<li>在 C++ 中，有两种简单的定义常量的方式：<ul>
<li>使用 #define 预处理器。</li>
<li>使用 const 关键字。</li>
</ul>
</li>
</ul>
</li>
<li><p>#define 预处理器</p>
<ul>
<li>下面是使用 #define 预处理器定义常量的形式：</li>
<li>#define identifier value</li>
</ul>
</li>
<li><p>const 关键字</p>
<ul>
<li>您可以使用 const 前缀声明指定类型的常量，如下所示：</li>
<li>const type variable &#x3D; value;</li>
<li>请注意，把常量定义为大写字母形式，是一个很好的编程实践。</li>
</ul>
</li>
</ul>
<h2 id="C-修饰符类型"><a href="#C-修饰符类型" class="headerlink" title="C++ 修饰符类型"></a>C++ 修饰符类型</h2><ul>
<li><p>C++ 允许在 char、int 和 double 数据类型前放置修饰符。</p>
</li>
<li><p>修饰符是用于改变变量类型的行为的关键字，它更能满足各种情境的需求。</p>
</li>
<li><p>下面列出了数据类型修饰符：</p>
<ul>
<li>signed：表示变量可以存储负数。对于整型变量来说，signed 可以省略，因为整型变量默认为有符号类型。</li>
<li>unsigned：表示变量不能存储负数。对于整型变量来说，unsigned 可以将变量范围扩大一倍。</li>
<li>short：表示变量的范围比 int 更小。short int 可以缩写为 short。</li>
<li>long：表示变量的范围比 int 更大。long int 可以缩写为 long。</li>
<li>long long：表示变量的范围比 long 更大。C++11 中新增的数据类型修饰符。</li>
<li>float：表示单精度浮点数。</li>
<li>double：表示双精度浮点数。</li>
<li>bool：表示布尔类型，只有 true 和 false 两个值。</li>
<li>char：表示字符类型。</li>
<li>wchar_t：表示宽字符类型，可以存储 Unicode 字符。</li>
</ul>
</li>
<li><p>修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。</p>
</li>
<li><p>这些修饰符也可以组合使用，修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。</p>
</li>
<li><p>C++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> num1 = <span class="number">-10</span>; <span class="comment">// 定义有符号整型变量 num1，初始值为 -10</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num2 = <span class="number">20</span>; <span class="comment">// 定义无符号整型变量 num2，初始值为 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="type">int</span> num1 = <span class="number">10</span>; <span class="comment">// 定义短整型变量 num1，初始值为 10</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> num2 = <span class="number">100000</span>; <span class="comment">// 定义长整型变量 num2，初始值为 100000</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> num1 = <span class="number">10000000000</span>; <span class="comment">// 定义长长整型变量 num1，初始值为 10000000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> num1 = <span class="number">3.14f</span>; <span class="comment">// 定义单精度浮点数变量 num1，初始值为 3.14</span></span><br><span class="line"><span class="type">double</span> num2 = <span class="number">2.71828</span>; <span class="comment">// 定义双精度浮点数变量 num2，初始值为 2.71828</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// 定义布尔类型变量 flag，初始值为 true</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch1 = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 定义字符类型变量 ch1，初始值为 &#x27;a&#x27;</span></span><br><span class="line"><span class="type">wchar_t</span> ch2 = <span class="string">L&#x27;你&#x27;</span>; <span class="comment">// 定义宽字符类型变量 ch2，初始值为 &#x27;你&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++ 中的类型限定符</p>
<ul>
<li>类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。</li>
<li>const : const 定义常量，表示该变量的值不能被修改。</li>
<li>volatile : 修饰符 volatile 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程。</li>
<li>restrict : 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</li>
<li>mutable  : 表示类中的成员变量可以在 const 成员函数中被修改。</li>
<li>static   : 用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。</li>
<li>register : 用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率。</li>
</ul>
</li>
<li><p>const 实例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> NUM = <span class="number">10</span>; <span class="comment">// 定义常量 NUM，其值不可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;NUM; <span class="comment">// 定义指向常量的指针，指针所指的值不可修改</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* ptr2 = &amp;NUM; <span class="comment">// 和上面一行等价</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>volatile 实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num = <span class="number">20</span>; <span class="comment">// 定义变量 num，其值可能会在未知的时间被改变</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mutable 实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_; <span class="comment">// const 关键字表示该成员函数不会修改对象中的数据成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(<span class="type">int</span> value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        value_ = value; <span class="comment">// mutable 关键字允许在 const 成员函数中修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>static 实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// static 关键字使变量 count 存储在程序生命周期内都存在</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>register 实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_function</span><span class="params">(<span class="keyword">register</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// register 关键字建议编译器将变量 num 存储在寄存器中</span></span><br><span class="line">    <span class="comment">// 以提高程序执行速度</span></span><br><span class="line">    <span class="comment">// 但是实际上是否会存储在寄存器中由编译器决定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C++ 存储类"></a>C++ 存储类</h2><ul>
<li><p>存储类定义 C++ 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>
<ul>
<li>auto </li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
<li>thread_local(C++11)</li>
</ul>
</li>
<li><p>从C++17开始，auto关键字不再是C++存储类说明符，且register关键字被弃用</p>
</li>
<li><p>auto 存储类</p>
<ul>
<li>自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</li>
<li>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。</li>
<li>根据初始化表达式自动推断被声明的变量的类型，如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=<span class="number">3.14</span>;      <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">9</span>); <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3=<span class="string">&#x27;r&#x27;</span>;<span class="comment">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>register 存储类</p>
<ul>
<li>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">register</span> <span class="type">int</span>  miles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</li>
</ul>
</li>
<li><p>static 存储类</p>
<ul>
<li>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</li>
<li>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</li>
<li>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</li>
</ul>
</li>
<li><p>extern 存储类</p>
<ul>
<li>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</li>
<li>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。</li>
<li>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候</li>
</ul>
</li>
<li><p>mutable 存储类</p>
<ul>
<li>mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</li>
</ul>
</li>
<li><p>thread_local存储类</p>
<ul>
<li>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</li>
<li>thread_local 说明符可以与 static 或 extern 合并。</li>
<li>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</li>
<li>以下演示了可以被声明为 thread_local 的变量：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> x;  <span class="comment">// 命名空间下的全局变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> std::string s; <span class="comment">// 类的static成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="keyword">thread_local</span> std::string X::s;  <span class="comment">// X::s 是需要定义的</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> std::vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">// 本地变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C++ 运算符"></a>C++ 运算符</h2><ul>
<li><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
</li>
<li><p>算术运算符</p>
<ul>
<li><code>+</code> : 把两个操作数相加</li>
<li><code>-</code> : 从第一个操作数中减去第二个操作数</li>
<li><code>*</code> : 把两个操作数相乘</li>
<li><code>/</code> : 分子除以分母</li>
<li><code>%</code> : 取模运算符，整除后的余数</li>
<li><code>++</code> : 自增运算符，整数值增加 1</li>
<li><code>--</code> : 自减运算符，整数值减少 1</li>
</ul>
</li>
<li><p>关系运算符</p>
<ul>
<li><code>==</code> : 检查两个操作数的值是否相等，如果相等则条件为真。</li>
<li><code>!=</code> : 检查两个操作数的值是否相等，如果不相等则条件为真。</li>
<li><code>&gt;</code>  : 检查左操作数的值是否大于右操作数的值，如果是则条件为真。</li>
<li><code>&lt;</code>  : 检查左操作数的值是否小于右操作数的值，如果是则条件为真。</li>
<li><code>&gt;=</code> : 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</li>
<li><code>&lt;=</code> : 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</li>
</ul>
</li>
<li><p>逻辑运算符</p>
<ul>
<li><code>&amp;&amp;</code> : 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。</li>
<li><code>||</code> : 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。</li>
<li><code>!</code>  : 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。</li>
</ul>
</li>
<li><p>位运算符</p>
<ul>
<li><code>&amp;</code> : 按位与操作，按二进制位进行”与”运算</li>
<li><code>|</code> : 按位或运算符，按二进制位进行”或”运算。</li>
<li><code>^</code> : 异或运算符，按二进制位进行”异或”运算。</li>
<li><code>~</code> : 取反运算符，按二进制位进行”取反”运算。</li>
<li><code>&lt;&lt;</code> : 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</li>
<li><code>&gt;&gt;</code> : 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</li>
</ul>
</li>
<li><p>赋值运算符</p>
<ul>
<li><code>=</code>  : 简单的赋值运算符，把右边操作数的值赋给左边操作数</li>
<li><code>+=</code> : 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</li>
<li><code>-=</code> : 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</li>
<li><code>*=</code> : 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</li>
<li><code>/=</code> : 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</li>
<li><code>%=</code> : 求模且赋值运算符，求两个操作数的模赋值给左边操作数</li>
<li><code>&lt;&lt;=</code> : 左移且赋值运算符</li>
<li><code>&gt;&gt;=</code> : 右移且赋值运算符</li>
<li><code>&amp;=</code>  : 按位与且赋值运算符</li>
<li><code>^=</code>  : 按位异或且赋值运算符</li>
<li><code>|=</code>  : 按位或且赋值运算符</li>
</ul>
</li>
<li><p>杂项运算符</p>
<ul>
<li>sizeof : sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。</li>
<li>Condition ? X : Y : 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</li>
<li>, : 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</li>
<li>.（点）和 -&gt;（箭头） : 成员运算符用于引用类、结构和共用体的成员。</li>
<li>Cast : 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</li>
<li>&amp; : 指针运算符 &amp; 返回变量的地址。例如 &a; 将给出变量的实际地址。</li>
<li><code>*</code> : 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。</li>
</ul>
</li>
</ul>
<h2 id="C-循环"><a href="#C-循环" class="headerlink" title="C++ 循环"></a>C++ 循环</h2><ul>
<li><p>有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</p>
</li>
<li><p>编程语言提供了允许更为复杂的执行路径的多种控制结构。</p>
</li>
<li><p>循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：</p>
</li>
<li><p>循环类型</p>
<ul>
<li>while 循环 : 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</li>
<li>for 循环 : 多次执行一个语句序列，简化管理循环变量的代码。</li>
<li>do…while 循环 : 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</li>
<li>嵌套循环 : 您可以在 while、for 或 do..while 循环内使用一个或多个循环。</li>
</ul>
</li>
<li><p>循环控制语句</p>
<ul>
<li>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。</li>
<li>C++ 提供了下列的控制语句。点击链接查看每个语句的细节。<ul>
<li>break 语句 : 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</li>
<li>continue 语句 : 引起循环跳过主体的剩余部分，立即重新开始测试条件。</li>
<li>goto 语句 : 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</li>
</ul>
</li>
</ul>
</li>
<li><p>无限循环</p>
<ul>
<li>如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。</li>
<li>当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。</li>
</ul>
</li>
</ul>
<h2 id="C-判断"><a href="#C-判断" class="headerlink" title="C++ 判断"></a>C++ 判断</h2><ul>
<li><p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p>
</li>
<li><p>判断语句</p>
<ul>
<li>C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。</li>
<li>if 语句 : 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。</li>
<li>if…else 语句 : 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。</li>
<li>嵌套 if 语句 : 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。</li>
<li>switch 语句 : 一个 switch 语句允许测试一个变量等于多个值时的情况。</li>
<li>嵌套 switch 语句 : 您可以在一个 switch 语句内使用另一个 switch 语句。</li>
</ul>
</li>
<li><p>? : 运算符</p>
<ul>
<li>我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下：</li>
<li>Exp1 ? Exp2 : Exp3;</li>
<li>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</li>
<li>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</li>
</ul>
</li>
</ul>
<h2 id="C-函数"><a href="#C-函数" class="headerlink" title="C++ 函数"></a>C++ 函数</h2><ul>
<li><p>函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。</p>
</li>
<li><p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>
</li>
<li><p>函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体</p>
</li>
<li><p>C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。</p>
</li>
<li><p>函数还有很多叫法，比如方法、子例程或程序，等等。</p>
</li>
<li><p>定义函数</p>
<ul>
<li>C++ 中的函数定义的一般形式如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter list )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：<ul>
<li>返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。</li>
<li>函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li>参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li>函数主体：函数主体包含一组定义函数执行任务的语句。</li>
</ul>
</li>
</ul>
</li>
<li><p>函数声明</p>
<ul>
<li>函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</li>
<li>函数声明包括以下几个部分：<ul>
<li>return_type function_name( parameter list );</li>
</ul>
</li>
<li>针对上面定义的函数 max()，以下是函数声明：<ul>
<li>int max(int num1, int num2);</li>
</ul>
</li>
<li>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：<ul>
<li>int max(int, int);</li>
</ul>
</li>
<li>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</li>
</ul>
</li>
<li><p>调用函数</p>
<ul>
<li>创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</li>
<li>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</li>
<li>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。</li>
<li>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁</li>
<li>当调用函数时，有三种向函数传递参数的方式：<ul>
<li>传值调用 : 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</li>
<li>指针调用 : 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</li>
<li>引用调用 : 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</li>
</ul>
</li>
<li>默认情况下，C++ 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。</li>
</ul>
</li>
<li><p>参数的默认值</p>
<ul>
<li>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。</li>
<li>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。</li>
</ul>
</li>
<li><p>Lambda 函数与表达式</p>
<ul>
<li>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</li>
<li>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</li>
<li>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:<ul>
<li><a href="parameters">capture</a>-&gt;return-type{body}</li>
</ul>
</li>
<li>例如：<ul>
<li>[](int x, int y){ return x &lt; y ; }</li>
</ul>
</li>
<li>如果没有返回值可以表示为：<ul>
<li><a href="parameters">capture</a>{body}</li>
</ul>
</li>
<li>例如：<ul>
<li>[]{ ++global_x; }</li>
</ul>
</li>
<li>在一个更为复杂的例子中，返回类型可以被明确的指定如下：<ul>
<li>[](int x, int y) -&gt; int { int z &#x3D; x + y; return z + x; }</li>
</ul>
</li>
<li>如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。</li>
<li>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure></li>
<li>另外有一点需要注意。对于[&#x3D;]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：<ul>
<li><a href="">this</a> { this-&gt;someFunc(); }();</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C-数字"><a href="#C-数字" class="headerlink" title="C++ 数字"></a>C++ 数字</h2><ul>
<li><p>通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。</p>
</li>
<li><p>C++ 数学运算</p>
<ul>
<li>在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做内置函数。您可以在程序中引用这些函数。</li>
<li>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。</li>
<li>为了利用这些函数，您需要引用数学头文件 <cmath>。<ul>
<li>double cos(double);<ul>
<li>该函数返回弧度角（double 型）的余弦。</li>
</ul>
</li>
<li>double sin(double);<ul>
<li>该函数返回弧度角（double 型）的正弦。</li>
</ul>
</li>
<li>double tan(double);<ul>
<li>该函数返回弧度角（double 型）的正切。</li>
</ul>
</li>
<li>double log(double);<ul>
<li>该函数返回参数的自然对数。</li>
</ul>
</li>
<li>double pow(double, double);<ul>
<li>假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</li>
</ul>
</li>
<li>double hypot(double, double);<ul>
<li>该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</li>
</ul>
</li>
<li>double sqrt(double);<ul>
<li>该函数返回参数的平方根。</li>
</ul>
</li>
<li>int abs(int);<ul>
<li>该函数返回整数的绝对值。</li>
</ul>
</li>
<li>double fabs(double);<ul>
<li>该函数返回任意一个浮点数的绝对值。</li>
</ul>
</li>
<li>double floor(double);<ul>
<li>该函数返回一个小于或等于传入参数的最大整数。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>C++ 随机数</p>
<ul>
<li>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数。</li>
<li>下面是一个关于生成随机数的简单实例。实例中使用了 time() 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i,j;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置种子</span></span><br><span class="line">   <span class="built_in">srand</span>( (<span class="type">unsigned</span>)<span class="built_in">time</span>( <span class="literal">NULL</span> ) );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 生成 10 个随机数 */</span></span><br><span class="line">   <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 生成实际的随机数</span></span><br><span class="line">      j= <span class="built_in">rand</span>();</span><br><span class="line">      cout &lt;&lt;<span class="string">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="C-数组"><a href="#C-数组" class="headerlink" title="C++ 数组"></a>C++ 数组</h2><ul>
<li><p>C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>
</li>
<li><p>数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。</p>
</li>
<li><p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>
</li>
<li><p>声明数组</p>
<ul>
<li>在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：<ul>
<li>type arrayName [ arraySize ];</li>
</ul>
</li>
<li>这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下：<ul>
<li>double balance[10];</li>
</ul>
</li>
<li>现在 balance 是一个可用的数组，可以容纳 10 个类型为 double 的数字。</li>
</ul>
</li>
<li><p>初始化数组</p>
<ul>
<li>在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：<ul>
<li>double balance[5] &#x3D; {1000.0, 2.0, 3.4, 7.0, 50.0};</li>
</ul>
</li>
<li>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。</li>
<li>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：<ul>
<li>double balance[] &#x3D; {1000.0, 2.0, 3.4, 7.0, 50.0};</li>
</ul>
</li>
<li>您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：<ul>
<li>balance[4] &#x3D; 50.0;</li>
</ul>
</li>
<li>上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：</li>
</ul>
</li>
<li><p>访问数组元素</p>
<ul>
<li>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。</li>
<li>double salary &#x3D; balance[9];</li>
<li>上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::setw;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> n[ <span class="number">10</span> ]; <span class="comment">// n 是一个包含 10 个整数的数组</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 初始化数组元素          </span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      n[ i ] = i + <span class="number">100</span>; <span class="comment">// 设置元素 i 为 i + 100</span></span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Element&quot;</span> &lt;&lt; <span class="built_in">setw</span>( <span class="number">13</span> ) &lt;&lt; <span class="string">&quot;Value&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出数组中每个元素的值                     </span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">setw</span>( <span class="number">7</span> )&lt;&lt; j &lt;&lt; <span class="built_in">setw</span>( <span class="number">13</span> ) &lt;&lt; n[ j ] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>上面的程序使用了 setw() 函数 来格式化输出。当上面的代码被编译和执行时，它会产生下列结果：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Element        Value</span><br><span class="line">      <span class="number">0</span>          <span class="number">100</span></span><br><span class="line">      <span class="number">1</span>          <span class="number">101</span></span><br><span class="line">      <span class="number">2</span>          <span class="number">102</span></span><br><span class="line">      <span class="number">3</span>          <span class="number">103</span></span><br><span class="line">      <span class="number">4</span>          <span class="number">104</span></span><br><span class="line">      <span class="number">5</span>          <span class="number">105</span></span><br><span class="line">      <span class="number">6</span>          <span class="number">106</span></span><br><span class="line">      <span class="number">7</span>          <span class="number">107</span></span><br><span class="line">      <span class="number">8</span>          <span class="number">108</span></span><br><span class="line">      <span class="number">9</span>          <span class="number">109</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>C++ 中数组详解</p>
<ul>
<li>在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：<ul>
<li>多维数组 : C++ 支持多维数组。多维数组最简单的形式是二维数组。</li>
<li>指向数组的指针 : 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</li>
<li>传递数组给函数 : 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</li>
<li>从函数返回数组 : C++ 允许从函数返回数组。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++ 字符串"></a>C++ 字符串</h2><ul>
<li><p>C++ 提供了以下两种类型的字符串表示形式：</p>
<ul>
<li>C 风格字符串</li>
<li>C++ 引入的 string 类类型</li>
</ul>
</li>
<li><p>C 风格字符串</p>
<ul>
<li>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 \0 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符</li>
<li>下面的声明和初始化创建了一个 RUNOOB 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 RUNOOB 的字符数多一个。</li>
<li>C++ 中有大量的函数用来操作以 null 结尾的字符串:<ul>
<li>strcpy(s1, s2);<ul>
<li>复制字符串 s2 到字符串 s1。</li>
</ul>
</li>
<li>strcat(s1, s2);<ul>
<li>连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如:</li>
</ul>
</li>
<li>strlen(s1);<ul>
<li>返回字符串 s1 的长度。</li>
</ul>
</li>
<li>strcmp(s1, s2);<ul>
<li>如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</li>
</ul>
</li>
<li>strchr(s1, ch);<ul>
<li>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</li>
</ul>
</li>
<li>strstr(s1, s2);<ul>
<li>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>C++ 中的 String 类</p>
<ul>
<li>C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能</li>
</ul>
</li>
</ul>
<h2 id="C-指针"><a href="#C-指针" class="headerlink" title="C++ 指针"></a>C++ 指针</h2><ul>
<li><p>学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的</p>
</li>
<li><p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。</p>
</li>
<li><p>什么是指针？</p>
<ul>
<li>指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：<ul>
<li>type *var-name;</li>
</ul>
</li>
<li>在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="type">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="type">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="type">char</span>   *ch;    <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure></li>
<li>所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</li>
</ul>
</li>
<li><p>C++ 中使用指针</p>
<ul>
<li>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span>  var = <span class="number">20</span>;   <span class="comment">// 实际变量的声明</span></span><br><span class="line">   <span class="type">int</span>  *ip;        <span class="comment">// 指针变量的声明</span></span><br><span class="line"> </span><br><span class="line">   ip = &amp;var;       <span class="comment">// 在指针变量中存储 var 的地址</span></span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of var variable: &quot;</span>;</span><br><span class="line">   cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出在指针变量中存储的地址</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Address stored in ip variable: &quot;</span>;</span><br><span class="line">   cout &lt;&lt; ip &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 访问指针中地址的值</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of *ip variable: &quot;</span>;</span><br><span class="line">   cout &lt;&lt; *ip &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>C++ 指针详解</p>
<ul>
<li>在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C++ 程序员必须清楚的一些与指针相关的重要概念：</li>
<li>C++ Null 指针 : C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。</li>
<li>C++ 指针的算术运算 : 可以对指针进行四种算术运算：++、–、+、-</li>
<li>C++ 指针 vs 数组 : 指针和数组之间有着密切的关系。</li>
<li>C++ 指针数组 : 可以定义用来存储指针的数组。</li>
<li>C++ 指向指针的指针 : C++ 允许指向指针的指针。</li>
<li>C++ 传递指针给函数 : 通过引用或地址传递参数，使传递的参数在调用函数中被改变。</li>
<li>C++ 从函数返回指针 : C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。</li>
</ul>
</li>
</ul>
<h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++ 引用"></a>C++ 引用</h2><ul>
<li><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>
</li>
<li><p>C++ 引用 vs 指针</p>
<ul>
<li>引用很容易与指针混淆，它们之间有三个主要的不同：<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
</li>
</ul>
</li>
<li><p>C++ 中创建引用</p>
<ul>
<li>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：<ul>
<li>int i &#x3D; 17;</li>
</ul>
</li>
<li>我们可以为 i 声明引用变量，如下所示：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;  r = i;</span><br><span class="line"><span class="type">double</span>&amp; s = d;</span><br></pre></td></tr></table></figure></li>
<li>在这些声明中，&amp; 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</li>
<li>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：<ul>
<li>把引用作为参数 : C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。</li>
<li>把引用作为返回值 : 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C-日期-时间"><a href="#C-日期-时间" class="headerlink" title="C++ 日期 &amp; 时间"></a>C++ 日期 &amp; 时间</h2><ul>
<li><p>C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。</p>
</li>
<li><p>有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。</p>
</li>
<li><p>结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">  <span class="type">int</span> tm_sec;   <span class="comment">// 秒，正常范围从 0 到 59，但允许至 61</span></span><br><span class="line">  <span class="type">int</span> tm_min;   <span class="comment">// 分，范围从 0 到 59</span></span><br><span class="line">  <span class="type">int</span> tm_hour;  <span class="comment">// 小时，范围从 0 到 23</span></span><br><span class="line">  <span class="type">int</span> tm_mday;  <span class="comment">// 一月中的第几天，范围从 1 到 31</span></span><br><span class="line">  <span class="type">int</span> tm_mon;   <span class="comment">// 月，范围从 0 到 11</span></span><br><span class="line">  <span class="type">int</span> tm_year;  <span class="comment">// 自 1900 年起的年数</span></span><br><span class="line">  <span class="type">int</span> tm_wday;  <span class="comment">// 一周中的第几天，范围从 0 到 6，从星期日算起</span></span><br><span class="line">  <span class="type">int</span> tm_yday;  <span class="comment">// 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起</span></span><br><span class="line">  <span class="type">int</span> tm_isdst; <span class="comment">// 夏令时</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面是 C&#x2F;C++ 中关于日期和时间的重要函数。所有这些函数都是 C&#x2F;C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。</p>
<ul>
<li>time_t time(time_t *time);<ul>
<li>该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 -1。</li>
</ul>
</li>
<li>char *ctime(const time_t *time);<ul>
<li>该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\n\0。</li>
</ul>
</li>
<li>struct tm *localtime(const time_t *time);<ul>
<li>该函数返回一个指向表示本地时间的 tm 结构的指针。</li>
</ul>
</li>
<li>clock_t clock(void);<ul>
<li>该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 -1。</li>
</ul>
</li>
<li>char * asctime ( const struct tm * time );<ul>
<li>该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。</li>
</ul>
</li>
<li>struct tm *gmtime(const time_t *time);<ul>
<li>该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。</li>
</ul>
</li>
<li>time_t mktime(struct tm *time);<ul>
<li>该函数返回日历时间，相当于 time 所指向结构中存储的时间。</li>
</ul>
</li>
<li>double difftime ( time_t time2, time_t time1 );<ul>
<li>该函数返回 time1 和 time2 之间相差的秒数。</li>
</ul>
</li>
<li>size_t strftime();<ul>
<li>该函数可用于格式化日期和时间为指定的格式。</li>
</ul>
</li>
</ul>
</li>
<li><p>当前日期和时间</p>
<ul>
<li>下面的实例获取当前系统的日期和时间，包括本地时间和协调世界时（UTC）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 基于当前系统的当前日期/时间</span></span><br><span class="line">   <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 把 now 转换为字符串形式</span></span><br><span class="line">   <span class="type">char</span>* dt = <span class="built_in">ctime</span>(&amp;now);</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;本地日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 把 now 转换为 tm 结构</span></span><br><span class="line">   tm *gmtm = <span class="built_in">gmtime</span>(&amp;now);</span><br><span class="line">   dt = <span class="built_in">asctime</span>(gmtm);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;UTC 日期和时间：&quot;</span>&lt;&lt; dt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用结构 tm 格式化时间</p>
<ul>
<li>tm 结构在 C&#x2F;C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。</li>
<li>在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -&gt; 运算符来访问结构成员。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 基于当前系统的当前日期/时间</span></span><br><span class="line">   <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;1970 到目前经过秒数:&quot;</span> &lt;&lt; now &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   tm *ltm = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 tm 结构的各个组成部分</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;年: &quot;</span>&lt;&lt; <span class="number">1900</span> + ltm-&gt;tm_year &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;月: &quot;</span>&lt;&lt; <span class="number">1</span> + ltm-&gt;tm_mon&lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;日: &quot;</span>&lt;&lt;  ltm-&gt;tm_mday &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;时间: &quot;</span>&lt;&lt; ltm-&gt;tm_hour &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">   cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">   cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="C-基本的输入输出"><a href="#C-基本的输入输出" class="headerlink" title="C++ 基本的输入输出"></a>C++ 基本的输入输出</h2><ul>
<li><p>C++ 标准库提供了一组丰富的输入&#x2F;输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I&#x2F;O 操作。</p>
</li>
<li><p>C++ 的 I&#x2F;O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。</p>
</li>
<li><p>I&#x2F;O 库头文件</p>
<ul>
<li>下列的头文件在 C++ 编程中很重要。<ul>
<li><iostream> : 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</li>
<li><iomanip> : 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I&#x2F;O 有用的服务。</li>
<li><fstream> : 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</li>
</ul>
</li>
</ul>
</li>
<li><p>标准输出流（cout）</p>
<ul>
<li>预定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的，</li>
<li>C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</li>
<li>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符。</li>
</ul>
</li>
<li><p>标准输入流（cin）</p>
<ul>
<li>预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的，如下所示：</li>
<li>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</li>
<li>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：<ul>
<li>cin &gt;&gt; name &gt;&gt; age;</li>
</ul>
</li>
<li>这相当于下面两个语句：<ul>
<li>cin &gt;&gt; name;</li>
<li>cin &gt;&gt; age;</li>
</ul>
</li>
</ul>
</li>
<li><p>标准错误流（cerr）</p>
<ul>
<li>预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</li>
</ul>
</li>
<li><p>标准日志流（clog）</p>
<ul>
<li>预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。</li>
<li>clog 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">char</span> str[] = <span class="string">&quot;Unable to read....&quot;</span>;</span><br><span class="line"> </span><br><span class="line">   clog &lt;&lt; <span class="string">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>
</li>
</ul>
<h2 id="C-数据结构"><a href="#C-数据结构" class="headerlink" title="C++ 数据结构"></a>C++ 数据结构</h2><ul>
<li><p>C&#x2F;C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
</li>
<li><p>结构用于表示一条记录，</p>
</li>
<li><p>定义结构</p>
<ul>
<li>为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">type_name</span> &#123;</span><br><span class="line">member_type1 member_name1;</span><br><span class="line">member_type2 member_name2;</span><br><span class="line">member_type3 member_name3;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125; object_names;</span><br></pre></td></tr></table></figure></li>
<li>type_name 是结构体类型的名称，member_type1 member_name1 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的</li>
</ul>
</li>
<li><p>访问结构成员</p>
<ul>
<li>为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。</li>
</ul>
</li>
<li><p>结构作为函数参数</p>
<ul>
<li>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books book )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 声明一个结构体类型 Books </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Books Book1;        <span class="comment">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class="line">   Books Book2;        <span class="comment">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Book1 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book<span class="number">1.</span>title, <span class="string">&quot;C++ 教程&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book<span class="number">1.</span>author, <span class="string">&quot;Runoob&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book<span class="number">1.</span>subject, <span class="string">&quot;编程语言&quot;</span>);</span><br><span class="line">   Book<span class="number">1.</span>book_id = <span class="number">12345</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Book2 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book<span class="number">2.</span>title, <span class="string">&quot;CSS 教程&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book<span class="number">2.</span>author, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book<span class="number">2.</span>subject, <span class="string">&quot;前端技术&quot;</span>);</span><br><span class="line">   Book<span class="number">2.</span>book_id = <span class="number">12346</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 Book1 信息</span></span><br><span class="line">   <span class="built_in">printBook</span>( Book1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 Book2 信息</span></span><br><span class="line">   <span class="built_in">printBook</span>( Book2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books book )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书标题 : &quot;</span> &lt;&lt; book.title &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书作者 : &quot;</span> &lt;&lt; book.author &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书类目 : &quot;</span> &lt;&lt; book.subject &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书 ID : &quot;</span> &lt;&lt; book.book_id &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>指向结构的指针</p>
<ul>
<li>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</li>
<li>struct Books *struct_pointer;</li>
<li>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</li>
<li>struct_pointer &#x3D; &Book1;</li>
<li>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</li>
<li>struct_pointer-&gt;title;</li>
<li>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books *book )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Books Book1;        <span class="comment">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class="line">   Books Book2;        <span class="comment">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Book1 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book<span class="number">1.</span>title, <span class="string">&quot;C++ 教程&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book<span class="number">1.</span>author, <span class="string">&quot;Runoob&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book<span class="number">1.</span>subject, <span class="string">&quot;编程语言&quot;</span>);</span><br><span class="line">   Book<span class="number">1.</span>book_id = <span class="number">12345</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Book2 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book<span class="number">2.</span>title, <span class="string">&quot;CSS 教程&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book<span class="number">2.</span>author, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book<span class="number">2.</span>subject, <span class="string">&quot;前端技术&quot;</span>);</span><br><span class="line">   Book<span class="number">2.</span>book_id = <span class="number">12346</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 通过传 Book1 的地址来输出 Book1 信息</span></span><br><span class="line">   <span class="built_in">printBook</span>( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 通过传 Book2 的地址来输出 Book2 信息</span></span><br><span class="line">   <span class="built_in">printBook</span>( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数以结构指针作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books *book )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书标题  : &quot;</span> &lt;&lt; book-&gt;title &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书作者 : &quot;</span> &lt;&lt; book-&gt;author &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书类目 : &quot;</span> &lt;&lt; book-&gt;subject &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书 ID : &quot;</span> &lt;&lt; book-&gt;book_id &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>typedef 关键字</p>
<ul>
<li>下面是一种更简单的定义结构的方式，您可以为创建的类型取一个”别名”。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125;Books;</span><br></pre></td></tr></table></figure></li>
<li>现在，您可以直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字。下面是实例：</li>
<li>Books Book1, Book2;</li>
<li>您可以使用 typedef 关键字来定义非结构类型，如下所示：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> *pint32;</span><br><span class="line"> </span><br><span class="line">pint32 x, y, z;</span><br></pre></td></tr></table></figure></li>
<li>x, y 和 z 都是指向长整型 long int 的指针。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_02_%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/2024-05-22-C++_02_1_%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_02_%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/2024-05-22-C++_02_1_%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++_02_1_重要函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ 核心函数</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_01_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2024-05-22-C++_01_1_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_01_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2024-05-22-C++_01_1_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C++_01_1_语言基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-28 11:04:43" itemprop="dateModified" datetime="2025-05-28T11:04:43+08:00">2025-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C&#x2F;C++相关的理论基础知识</li>
</ul>
<h2 id="C-中的科学计数法"><a href="#C-中的科学计数法" class="headerlink" title="C++中的科学计数法"></a>C++中的科学计数法</h2><ul>
<li>C++中，也可以使用科学计数法，例如：<ul>
<li><code>double a = 1e3;  // a = 1000.0;</code></li>
</ul>
</li>
</ul>
<h2 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h2><ul>
<li><code>char</code> 类型用于存储字符，例如字符或标点符号。但是从技术层面看，<code>char</code> 是整数类型。</li>
<li>因为<code>char</code>类型实际上存储的是整数而不是字符。计算机使用数字编码来处理字符，即用特定的整数表示特定的字符。</li>
</ul>
<h2 id="04x"><a href="#04x" class="headerlink" title="%04x"></a><code>%04x</code></h2><ul>
<li><code>x</code>表示以小写的十六进制输出</li>
<li><code>4</code>表示输出的十六进制数的宽度是4个字符</li>
<li><code>0</code>表示输出的十六进制数中，不足4个字符的部分，用<code>0</code>来补充，以达到4个字符的宽度</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="C语言中的字符串"><a href="#C语言中的字符串" class="headerlink" title="C语言中的字符串"></a>C语言中的字符串</h3><ul>
<li><p>字符串(character string)是一个或多个字符的序列，例如”this is a string!”</p>
</li>
<li><p>双引号不是字符串的一部分。双引号<strong>仅告知编译器它括起来的是字符串</strong>，正如单引号用于标识单个字符一样。</p>
</li>
<li><p>C语言没有专门用于存储字符串的变量类型，<strong>字符串都被存储在<code>char</code>类型的数组中</strong>。</p>
</li>
<li><p>数组由连续的存储单元组成，字符串中的字符被存储在相邻的存储单元中，每个单元存储一个字符。</p>
</li>
<li><p>数组名是数组首元素的地址</p>
</li>
<li><p>字符串和字符</p>
<ul>
<li>字符串常量”y”和字符常量”x”不同。</li>
<li>区别之一在于”x”是**基本类型(char)<strong>，而”y”是</strong>派生类型(char数组)**；</li>
<li>区别之二是”y”实际上由两个字符组成：’x’和空字符’\0’</li>
</ul>
</li>
<li><p>C-风格字符串具有一种特殊的性质：**以空字符(null character)结尾，空字符被写作<code>\0</code>**，其ASCII码为0，用来标记字符串的结尾。例如</p>
<ul>
<li><code>char dog[8] = &#123;&#39;b&#39;, &#39;e&#39;, &#39;a&#39;, &#39;u&#39;, &#39;x&#39;, &#39; &#39;, &#39;I&#39;, &#39;I&#39;&#125;;  // not a string</code></li>
<li><code>char cat[8] = &#123;&#39;f&#39;, &#39;a&#39;, &#39;t&#39;, &#39;e&#39;, &#39;s&#39;, &#39;s&#39;, &#39;a&#39;, &#39;\0&#39;&#125;; // a string</code></li>
</ul>
</li>
<li><p>使用引号括起来的字符串初始化字符数组，这种字符串被称为<strong>字符串常量</strong>(string constant)或<strong>字符串字面值</strong>(string literal)，例如</p>
<ul>
<li><code>char bird[11] = &quot;Mr. cheps&quot;; // the \0 is understood</code></li>
<li><code>char fish[] = &quot;Bubbles&quot;;  // let the compiler count</code></li>
<li>使用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它。</li>
<li>另外，各种C++输入工具通过键盘输入，将字符串读入到char数组中时，将自动加上结尾的空字符。</li>
</ul>
</li>
<li><p><strong>在数组中使用字符串</strong></p>
<ul>
<li>要将字符串存储到数组中，最常用的方法有两种：<ul>
<li>将数组初始化为字符串常量</li>
<li>将键盘或文件输入读入到数组中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="C-中的字符串"><a href="#C-中的字符串" class="headerlink" title="C++中的字符串"></a>C++中的字符串</h3><ul>
<li><p>字符串是存储在内存的连续字节中的一系列字符</p>
</li>
<li><p>C++处理字符串的方式有两种：</p>
<ul>
<li>第一种来自C语言，常被称为C-风格字符串(<code>C-style string</code>)</li>
<li>另一种基于<code>string</code>类库的方法</li>
</ul>
</li>
</ul>
<h3 id="C-的string类"><a href="#C-的string类" class="headerlink" title="C++的string类"></a>C++的string类</h3><ul>
<li><p>C++程序常使用指针（而不是数组）来处理字符串</p>
</li>
<li><p><code>ISO/ANSI C++98</code>标准通过添加<code>string</code>类扩展了C++库，因此现在可以<code>string</code>类型的变量（使用C++的话说，是<strong>对象</strong>）而不是字符数组来存储字符串。</p>
</li>
<li><p>在很多方面，使用<code>string</code>对象的方式与使用字符数组相同：</p>
<ul>
<li>可以使用C-风格字符串来初始化<code>string</code>对象</li>
<li>可以使用<code>cin</code>来将键盘输入存储到<code>string</code>对象中</li>
<li>可以使用<code>cout</code>来显式<code>string</code>对象</li>
<li>可以使用数组表示法来访问存储在<code>string</code>对象中的字符</li>
</ul>
</li>
<li><p><code>string</code>对象和字符数组之间的主要区别是：可以将<code>string</code>对象声明为简单变量，而不是数组。</p>
<ul>
<li><code>string str1;  // create an empty string object</code></li>
<li><code>string str2 = &quot;panther&quot;; // create an initialized string</code></li>
</ul>
</li>
<li><p>类设计让程序能够自动处理<code>string</code>的大小。这使得与使用数组相比，使用<code>string</code>对象更方便，也更安全。</p>
</li>
<li><p>从理论上来说</p>
<ul>
<li>可以将<code>char</code>数组视为<strong>一组用于存储一个字符串的<code>char</code>存储单元</strong>，</li>
<li>而<code>string</code>类变量是<strong>一个表示字符串的实体</strong>。</li>
</ul>
</li>
</ul>
<h4 id="string类的构造函数"><a href="#string类的构造函数" class="headerlink" title="string类的构造函数"></a>string类的构造函数</h4><ul>
<li><p><code>std::string(const char *s)</code> ：将 <code>std::string</code> 对象初始化为 s 指向的字符串</p>
<ul>
<li><code>std::string str(&quot;Hello!&quot;);</code></li>
</ul>
</li>
<li><p><code>std::string(size_type n,char c)</code> ：创建一个包含 n 个元素的 <code>std::string</code> 对象，其中每个元素都被初始化为字符 c</p>
<ul>
<li><code>std::string str(10,&#39;a&#39;);</code></li>
</ul>
</li>
<li><p><code>std::string(const std::string &amp;str)</code> ：将一个 <code>std::string</code> 对象初始化为 <code>std::string</code> 对象 str（复制构造函数）</p>
<ul>
<li><code>std::string str1(&quot;hello!&quot;);</code></li>
<li><code>std::string str2(str1);</code></li>
</ul>
</li>
<li><p><code>std::string()</code> ：创建一个默认的 <code>std::string</code> 对象，长度为 0（默认构造函数）</p>
<ul>
<li><code>std::string str;</code> 　　　　&#x2F;&#x2F; 创建一个空的 std::string 对象</li>
</ul>
</li>
<li><p>使用C语言风格初始化<code>std::string</code>对象</p>
<ul>
<li><code>std::string str = &quot;string&quot;;</code></li>
</ul>
</li>
</ul>
<h4 id="获取string对象的长度"><a href="#获取string对象的长度" class="headerlink" title="获取string对象的长度"></a>获取string对象的长度</h4><ul>
<li><p>在 C 语言中，使用 strlen 函数获取字符串的长度。在 C++ 中，可以使用 string.size() 函数或 string.length() 函数来获得 string 对象的长度。在 C++ 标准库中，两者的源代码如下 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size_type   __CLR_OR_THIS_CALL   <span class="title function_">length</span><span class="params">()</span>   <span class="type">const</span>   </span><br><span class="line">  &#123; <span class="comment">//   return   length   of   sequence   </span></span><br><span class="line">  <span class="keyword">return</span>   (_Mysize);   </span><br><span class="line">  &#125;   </span><br><span class="line">    </span><br><span class="line">size_type   __CLR_OR_THIS_CALL   <span class="title function_">size</span><span class="params">()</span>   <span class="type">const</span>   </span><br><span class="line">&#123; <span class="comment">//   return   length   of   sequence   </span></span><br><span class="line"><span class="keyword">return</span>   (_Mysize);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可见，这两个方法是完全一样的，并没有区别。</p>
<ul>
<li>length() 方法是 C 语言习惯保留的，</li>
<li>size() 方法则是为了兼容 STL 容器而引入的。</li>
</ul>
</li>
</ul>
<h4 id="复制-string-对象"><a href="#复制-string-对象" class="headerlink" title="复制 string 对象"></a>复制 string 对象</h4><ul>
<li>在 C 语言中，使用 strcpy、strncpy 函数来实现字符串的复制。</li>
<li>在 C++ 中则方便很多，可以直接将一个 string 对象赋值给另一个 string 对象</li>
</ul>
<h4 id="string-对象的拼接和附加"><a href="#string-对象的拼接和附加" class="headerlink" title="string 对象的拼接和附加"></a>string 对象的拼接和附加</h4><ul>
<li>在 C 语言中，使用 strcat、strncat 函数来进行字符串拼接操作。在 C++ 中也有多种方法来实现字符串拼接和附加操作：<ul>
<li>使用 + 操作符拼接两个字符串</li>
<li>使用 +&#x3D; 操作符在字符串后面附加内容</li>
<li>使用 string.append() 函数.可以使用 string.append() 函数来在一个 string 对象后面附加一个 string 对象或 C 风格的字符串：</li>
<li>使用 string.push_back() 函数.可以使用 string.push_back() 函数来在一个 string 对象后面附加一个字符：</li>
</ul>
</li>
</ul>
<h4 id="string-对象的比较"><a href="#string-对象的比较" class="headerlink" title="string 对象的比较"></a>string 对象的比较</h4><ul>
<li>在 C 语言中，使用 strcmp、strncmp 函数来进行字符串的比较。在 C++ 中，由于将 string 对象声明为了简单变量，故而对字符串的比较操作十分简单了，直接使用关系运算符（&#x3D;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;）即可：</li>
<li>当然，也可以使用类似 strcmp 的函数来进行 string 对象的比较，string 类提供的是 string.compare() 方法，函数原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp;str)</span> <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> compare（<span class="type">size_t</span> pos，<span class="type">size_t</span> len，<span class="type">const</span> <span class="built_in">string</span>&amp;str）<span class="type">const</span>;　　　　<span class="comment">// 参数 pos 为比较字符串中第一个字符的位置，len 为比较字符串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> compare（<span class="type">size_t</span> pos，<span class="type">size_t</span> len，<span class="type">const</span> <span class="built_in">string</span>&amp;str, <span class="type">size_t</span> subpos，<span class="type">size_t</span> sublen）<span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> compare（<span class="type">const</span> <span class="type">char</span> * s）<span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> compare（<span class="type">size_t</span> pos，<span class="type">size_t</span> len，<span class="type">const</span> <span class="type">char</span> * s）<span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> compare（<span class="type">size_t</span> pos，<span class="type">size_t</span> len，<span class="type">const</span> <span class="type">char</span> * s，<span class="type">size_t</span> n）<span class="type">const</span>;</span><br></pre></td></tr></table></figure></li>
<li>compare 方法的返回值如下：<ul>
<li>返回 0，表示相等；</li>
<li>返回结果小于 0，表示比较字符串中第一个不匹配的字符比源字符串小，或者所有字符都匹配但是比较字符串比源字符串短；</li>
<li>返回结果大于 0，表示比较字符串中第一个不匹配的字符比源字符串大，或者所有字符都匹配但是比较字符串比源字符串长。</li>
</ul>
</li>
</ul>
<h4 id="使用-string-substr-函数来获取子串"><a href="#使用-string-substr-函数来获取子串" class="headerlink" title="使用 string.substr() 函数来获取子串"></a>使用 string.substr() 函数来获取子串</h4><ul>
<li>可以使用 string.substr() 函数来获取子串，string.substr() 函数的定义如下：<ul>
<li><code>string substr（size_t pos = 0，size_t len = npos）const;</code></li>
</ul>
</li>
<li>其中，pos 是子字符串的起始位置（索引，第一个字符的索引为 0），len 是子串的长度。这个函数的功能是：复制一个 string 对象中从 pos 处开始的 len 个字符到 string 对象 substr 中去，并返回 substr。</li>
</ul>
<h4 id="访问-string-字符串的元素"><a href="#访问-string-字符串的元素" class="headerlink" title="访问 string 字符串的元素"></a>访问 string 字符串的元素</h4><ul>
<li>可以像 C 语言中一样，将 string 对象当做一个数组，然后使用数组下标的方式来访问字符串中的元素；也可以使用 string.at(index) 的方式来访问元素（索引号从 0 开始）：</li>
</ul>
<h2 id="类型说明符-占位符"><a href="#类型说明符-占位符" class="headerlink" title="类型说明符(占位符)"></a>类型说明符(占位符)</h2><ul>
<li><p><code>%a, %A</code> : 读入一个浮点值(仅 C99 有效)  –  <code>	float *</code></p>
</li>
<li><p><code>%c</code>     : 单个字符：</p>
<ul>
<li>读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。</li>
<li>char *</li>
</ul>
</li>
<li><p><code>%d</code>     : 十进制整数：数字前面的 + 或 - 号是可选的。 – <code>int *</code></p>
</li>
<li><p><code>%e</code>     : 使用<code>e</code>字符的科学计数法（尾数和指数）</p>
</li>
<li><p><code>%E</code>     : 使用<code>E</code>字符的科学计数法（尾数和指数）</p>
</li>
<li><p><code>%f</code>     : 十进制浮点数  –  <code>float *</code></p>
</li>
<li><p><code>%g</code>     : 自动选择<code>%e</code>或<code>%f</code>中合适的表示法</p>
</li>
<li><p><code>%G</code>     : 自动选择<code>%E</code>或<code>%f</code>中合适的表示法</p>
</li>
<li><p><code>%o</code>     : 有符号八进制  –  <code>int *</code></p>
</li>
<li><p><code>%s</code>     : 字符的字符串,这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。  –  <code>char *</code></p>
</li>
<li><p><code>%u</code>     : 无符号十进制整数  –  <code>unsigned int *</code></p>
</li>
<li><p><code>%x</code>     : 无符号十六进制整数</p>
</li>
<li><p><code>%X</code>     : 无符号十六进制整数（大写字母）</p>
</li>
<li><p><code>%p</code>     : 指针地址，	读入一个指针 。</p>
</li>
<li><p><code>%[]</code>    : 无输出</p>
</li>
<li><p><code>%%</code>     : 读 % 符号。</p>
</li>
</ul>
<h2 id="数组-C语言"><a href="#数组-C语言" class="headerlink" title="数组  - C语言"></a>数组  - C语言</h2><ul>
<li><p>假设有类型T，<code>T[size]</code>的含义是：包含<code>size</code>个<code>T</code>类型的元素的数组，元素的索引值范围是<code>0</code>到<code>size-1</code></p>
</li>
<li><p>数组用于存储相同类型的数据。</p>
</li>
<li><p>C把数组看作是<strong>派生类型</strong>，因为数组是建立在其他类型的基础上。</p>
</li>
<li><p>也就是说，无法简单地声明一个数组。在声明数组时必须说明其<strong>元素的类型</strong>，例如:<code>int</code>类型的数组，<code>float</code>类型的数组或者其他类型的数组。</p>
<ul>
<li>所谓的其他类型也可以是数据类型，这种情况下，创建的是数组的数组，或者称为二维数组</li>
</ul>
</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><ul>
<li>C把数组名解释为该数组首元素的地址。换言之，<strong>数组名与指向该数组首元素的指针等价</strong></li>
<li>对于C语言来说，不能把整个数组作为参数传递给函数，但是可以传递数组的地址。</li>
</ul>
<h3 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h3><ul>
<li><strong>赋值</strong>：可以把地址赋给指针。例如，用数组名，带地址运算符（<code>&amp;</code>）的变量名，另一个指针进行赋值。</li>
<li><strong>解引用</strong>：**<code>*</code>运算符给出指针指向的地址上所存储的值**</li>
<li><strong>取址</strong>：<strong>和所有变量一样，指针变量也有自己的地址和值</strong>。对指针而言，<code>&amp;</code>运算符给出指针本身的地址。</li>
<li><strong>指针与整数相加</strong>：可以使用<code>+</code>运算符把指针与整数相加，或整数与指针相加。无论哪一种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。</li>
<li><strong>递增指针</strong>：递增指向数组元素的指针可以让指针移动至数组的下一个元素。</li>
<li><strong>指针减去一个整数</strong>：可以使用<code>-</code>运算符从一个指针中减去一个整数</li>
<li><strong>递减指针</strong>：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同</li>
<li><strong>比较</strong>：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。</li>
</ul>
<h2 id="动态内存-new-malloc-delete-free"><a href="#动态内存-new-malloc-delete-free" class="headerlink" title="动态内存 new&#x2F;malloc delete&#x2F;free"></a>动态内存 new&#x2F;malloc delete&#x2F;free</h2><ul>
<li><p>C++ 程序中的内存分为两个部分</p>
<ul>
<li>栈：在函数内部声明的所有变量都将占用栈内存。</li>
<li>堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>
</ul>
</li>
<li><p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定</p>
</li>
<li><p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 <code>new</code> 运算符。</p>
</li>
<li><p>如果您不再需要动态分配的内存空间，可以使用 <code>delete</code> 运算符，删除之前由 <code>new</code> 运算符分配的内存</p>
</li>
</ul>
<h3 id="new-和-delete-运算符"><a href="#new-和-delete-运算符" class="headerlink" title="new 和 delete 运算符"></a>new 和 delete 运算符</h3><ul>
<li><p>使用 new 运算符来为任意的数据类型动态分配内存的通用语法：</p>
<ul>
<li><code>new data-type;</code></li>
</ul>
</li>
<li><p>在这里，<code>data-type</code> 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。</p>
</li>
<li><p>内置的数据类型:</p>
<ul>
<li><code>double* pvalue = NULL; // 初始化null的指针</code></li>
<li><code>pvalue = new double;   // 为变量请求内存</code></li>
</ul>
</li>
<li><p>如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：</p>
<ul>
<li><code>double* pvalue = NULL;</code></li>
<li><code>if(!(pvalue = new double)) &#123;std::cout &lt;&lt; &quot;Error: out of memory &quot;&gt;&gt; std::endl; exit(1);&#125;</code></li>
</ul>
</li>
<li><p>malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。</p>
</li>
<li><p>new 与 malloc() 函数相比，其<strong>主要的优点是</strong>，new 不只是分配了内存，它还创建了对象</p>
</li>
<li><p>在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示：</p>
<ul>
<li><code>delete pvalue;  // 释放pvalue所指向的内存</code></li>
</ul>
</li>
</ul>
<h3 id="数组的动态内存分配"><a href="#数组的动态内存分配" class="headerlink" title="数组的动态内存分配"></a>数组的动态内存分配</h3><ul>
<li><p><code>char *pvalue = NULL;  // 初始化NULL指针</code></p>
</li>
<li><p><code>pvalue = new char[20];// 位变量请求内存</code></p>
</li>
<li><p><code>delete [] pvalue;  // 删除pvalue所指向的数组</code></p>
</li>
</ul>
<h3 id="对象的动态内存分配"><a href="#对象的动态内存分配" class="headerlink" title="对象的动态内存分配"></a>对象的动态内存分配</h3><ul>
<li>对象与简单的数据类型没有什么不同</li>
</ul>
<h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><ul>
<li><p><code>static</code>是C&#x2F;C++中常见的修饰符，它被用来控制<strong>变量的存储方式和可见性</strong>。</p>
</li>
<li><p><code>static</code>的引入</p>
<ul>
<li>在函数内部定义的变量，当程序执行到它的定义时，编译器为它在栈上分配空间，函数在栈上分配的空间在<strong>此函数执行结束时会释放掉</strong></li>
<li>这样就产生了一个问题：如果想将函数中此变量的值保存到下一次调用时，如何实现？</li>
<li>最容易想到的方法是定义为全局的变量，但是定义一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅只受此函数控制）</li>
<li><code>static</code>关键字则可以很好的解决这个问题</li>
<li>另外，在C++中，<strong>需要一个数据对象为整个类而非某个对象服务</strong>，同时又力求不破坏类的封装性，即<strong>要求此成员隐藏在类的内部，对外不可见时，可以将其定义为静态数据</strong>。</li>
</ul>
</li>
<li><p>静态数据的存储</p>
</li>
<li><p>全局（静态）存储区：分为<code>DATA</code>段和<code>BSS</code>段</p>
<ul>
<li><code>DATA</code>段（全局初始化区）存放初始化的全局变量和静态变量</li>
<li><code>BSS</code>段（全局未初始化区）存放未初始化的全局变量和静态变量。</li>
</ul>
</li>
<li><p>程序运行结束时自动释放。其中，**<code>BSS</code>段在程序执行之前会被系统自动清0**，所以未初始化的全局变量和静态变量在程序执行之前已经为<code>0</code>。</p>
</li>
<li><p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化</p>
</li>
<li><p>在C++中, <strong>static的内部实现机制</strong>：</p>
<ul>
<li>静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所有静态数据成员不能在任何函数内分配空间和初始化。</li>
</ul>
</li>
<li><p>这样，它的空间分配有三个可能的地方，</p>
<ul>
<li>一是作为类的外部接口的头文件，那里有类声明</li>
<li>二是类定义的内部实现，那里有类的成员函数定义</li>
<li>三是应用程序的<code>main()</code>函数前的全局数据声明和定义处</li>
</ul>
</li>
<li><p>静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的“尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。</p>
</li>
<li><p>它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。</p>
</li>
<li><p><code>static</code>被引入以告知编译器，将变量存储在程序的<strong>静态存储区</strong>,而非栈上空间，</p>
</li>
<li><p>静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。</p>
</li>
<li><p>优点：</p>
<ul>
<li><strong>可以节省内存，因为它是所有对象所公有的</strong>，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用</li>
<li><strong>静态数据成员的值对每个对象都是一样，但是它的值可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间的效率</strong></li>
</ul>
</li>
<li><p>总的来说</p>
<ul>
<li>在修时变量的时候，<code>static</code>修时的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放</li>
<li><code>static</code>修时全局变量的时候，这个全局变量只能在本文件中访问，不能在其他文件中访问，<strong>即便是<code>extern</code>外部声明也不可以</strong></li>
<li><code>static</code>修饰一个函数，则<strong>这个函数只能在本文件中调用，不能被其他文件调用</strong>。</li>
<li><code>static</code>修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为0。</li>
<li>不想被释放的时候，可以使用<code>static</code>修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束时释放，可以使用<code>static</code>修饰</li>
<li>考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用<code>static</code>）</li>
</ul>
</li>
<li><p><strong>静态变量与普通变量：</strong></p>
<ul>
<li>静态变量都在全局数据区分配内存，包括后面将要提到的静态全局变量</li>
<li>未经初始化的静态全局变量会被程序自动初始化为<code>0</code>（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为<code>0</code>）</li>
<li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的</li>
<li>静态全局变量不能被其他文件所用；其他文件中可以定义相同名字的变量，不会发生冲突</li>
</ul>
</li>
<li><p><strong>全局变量和全局静态变量的区别：</strong></p>
<ul>
<li>全局变量是不显式用<code>static</code>修饰的全局变量，<strong>全局变量默认是有外部链接性的，作用域是整个工程</strong>，在一个文件内定义的全局变量，在另一个文件中，通过<code>extern</code>全局变量名的声明，就可以使用全局变量</li>
<li>全局静态变量是显式用<code>static</code>修饰的全局变量，作用域是声明此变量的所在的文件，其他的文件即使使用<code>extern</code>声明也不能使用。</li>
</ul>
</li>
<li><p><strong>静态局部变量有以下特点：</strong></p>
<ul>
<li>该变量在全局数据区分配内存</li>
<li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化</li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0</li>
<li>它始终驻留在全局数据区，直到程序运行结束。但是其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束</li>
</ul>
</li>
<li><p>一般程序把新产生的动态数据存放在<strong>堆区</strong>，函数内部的自动变量存放在<strong>栈区</strong></p>
</li>
<li><p>自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放这全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。</p>
</li>
</ul>
<h3 id="static用法"><a href="#static用法" class="headerlink" title="static用法"></a><code>static</code>用法</h3><ul>
<li><p>在C++中，<code>static</code>关键字最基本的用法是：</p>
<ul>
<li><strong>被<code>static</code>修饰的变量属于类变量</strong>，可以通过<code>类名.变量名</code>直接引用，而不需要<code>new</code>出一个类来</li>
<li><strong>被<code>static</code>修饰的方法属于类方法</strong>，可以通过<code>类名.方法名</code>直接引用，而不需要<code>new</code>出一个类来</li>
</ul>
</li>
<li><p>被<code>static</code>修饰的变量，被<code>static</code>修饰的方法统一属于类的<strong>静态资源</strong>，是类实例之间共享的，换言之，一处变，处处变。</p>
</li>
<li><p>在C++中，<strong>静态成员是属于整个类的而不是某个对象</strong>，静态成员变量只存储一份供所有对象共用。</p>
</li>
<li><p>所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。</p>
</li>
<li><p>静态类相关：</p>
<ul>
<li>通过类名可以调用静态成员函数，但是不能调用非静态成员函数</li>
<li>通过类的对象可以使用静态成员函数和非静态成员函数</li>
<li>静态成员函数中不能引用非静态成员</li>
<li>类的静态成员变量必须先初始化再使用</li>
</ul>
</li>
<li><p>静态资源属于类，但是是独立于类存在的。从类的加载机制的角度来看，<strong>静态资源是类初始化的时候加载的</strong>，而<strong>非静态资源是类实例化对象的时候加载的</strong>。</p>
</li>
<li><p>类的初始化早于类实例化对象。所以对于静态资源来说，它是不可能知道一个类中有那些非静态资源的；但是对于非静态资源来说就不一样了，由于它是实例化对象出来之后产生的，因此属于类的这些东西它都能认识</p>
</li>
</ul>
<h3 id="static-总结"><a href="#static-总结" class="headerlink" title="static 总结"></a>static 总结</h3><ul>
<li><p>静态成员函数中不能调用非静态成员</p>
</li>
<li><p>非静态成员函数中可以调用静态成员。因为静态成员属于类本身，在类的对象产生之前就已经存在了，所以在非静态成员函数中是可以调用静态成员的</p>
</li>
<li><p>静态成员变量使用之前必须先初始化，否则会在<code>linker</code>时出错。</p>
</li>
<li><p>在类中，<code>static</code>可以用来修饰静态数据成员和静态成员方法</p>
</li>
<li><p>静态数据成员</p>
<ul>
<li>静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变</li>
<li>静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间</li>
<li>静态数据成员可以被初始化，但是只能在类体外进行初始化，如果未对静态数据成员赋初值，则编译器会自动为其初始化为<code>0</code></li>
<li>静态数据成员既可以通过对象名引用，也可以通过类名引用</li>
</ul>
</li>
<li><p>静态成员函数:</p>
<ul>
<li>静态成员函数和静态数据成员一样，它们都是属于类的静态成员，而不是对象成员</li>
<li>非静态成员函数有<code>this</code>指针，而静态成员函数没有<code>this</code>指针</li>
<li>静态成员函数主要用来访问静态数据成员，而不能访问非静态成员。</li>
</ul>
</li>
</ul>
<h2 id="C-this指针"><a href="#C-this指针" class="headerlink" title="C++ this指针"></a>C++ this指针</h2><ul>
<li><p>在非<code>static</code>成员函数中，关键字this是指向调用它的对象的指针</p>
</li>
<li><p>this被当作一个右值，因此我们无法获得this的地址或给它赋值</p>
</li>
<li><p>在C++中，每一个对象都能通过 <code>this</code> 指针来访问自己的地址。</p>
</li>
<li><p><code>this</code> 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p>
</li>
<li><p>友元函数没有 <code>this</code> 指针，因为友元不是类的成员。只有成员函数才有 <code>this</code> 指针</p>
</li>
<li><p><code>this</code> 指针的<strong>用处</strong>：</p>
<ul>
<li>一个对象的 <code>this</code> 指针并不是对象本身的一部分，不会影响<code>sizeof（对象）</code>的结果</li>
<li><code>this</code> 作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数</li>
<li>也就是说，即使没有写上 <code>this</code> 指针，编译器在编译的时候也是加上 <code>this</code> 的，它作为非静态成员函数的隐含形参，对各成员的访问均通过 <code>this</code> 进行</li>
</ul>
</li>
<li><p><code>this</code> 指针的<strong>使用</strong>：</p>
<ul>
<li>一种情况是，在<strong>类的非静态成员函数中返回类对象本身的时候</strong>，直接使用<code>return *this</code></li>
<li>另外一种情况是当<strong>参数与成员变量名相同时</strong>，例如：<code>this-&gt;n = n</code></li>
</ul>
</li>
<li><p>关于 <code>this</code> 指针的一个经典回答：</p>
<ul>
<li>当你进入一个房子后，你可以看见桌子，椅子，地板等，但是房子你是看不到全貌了；对于一个类的实例来说，你可以看到它的成员函数，成员变量，但是实例本身呢？</li>
<li><code>this</code> 是一个指针，它时时刻刻指向你这个实例本身。</li>
</ul>
</li>
</ul>
<h3 id="类的this指针有以下特点"><a href="#类的this指针有以下特点" class="headerlink" title="类的this指针有以下特点"></a>类的this指针有以下特点</h3><ul>
<li><p><code>this</code>只能在成员函数中使用，全局函数，静态函数都不能使用<code>this</code>。</p>
<ul>
<li>实际上，成员函数默认第一个参数为<code>T* const this</code></li>
</ul>
</li>
<li><p><code>this</code>在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数都是一样的，没有任何区别</p>
</li>
<li><p><code>this</code>指针存放在何处？</p>
<ul>
<li><code>this</code>指针会因为编译器不同而有不同的为值。可能是栈，也可能是寄存器，甚至全局变量。</li>
<li>在汇编级别里面，一个值只会以三种形式出现：立即数，寄存器值和内存变量值。</li>
<li><strong>不是存放在寄存器就是存放在内存中</strong>，它们并不是和高级语言变量对应的</li>
</ul>
</li>
<li><p><code>this</code>指针是如何传递类中的函数的？</p>
<ul>
<li>大多数编译器通过<code>ecx</code>寄存器传递<code>this</code>指针。</li>
</ul>
</li>
<li><p>每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</p>
<ul>
<li>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。</li>
<li>只有<strong>虚函数才会被放到函数表中</strong>。但是，即使是虚函数，如果编译器能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。</li>
</ul>
</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li>C&#x2F;C++中的<code>volatile</code>关键字和<code>const</code>对应，用来修饰变量，通常用于建立语言级别的<code>memory barrier</code>, 内存屏障</li>
<li>在<code>The C++ Programming Language</code>中对<code>volatile</code>修饰词的说明：<ul>
<li><code>A volatile specifier is a hint to compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.</code></li>
</ul>
</li>
<li><code>volatile</code>关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统，硬件或者其他线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</li>
<li>当要求使用<code>volatile</code>声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据，而且读取的数据立刻被保存。</li>
</ul>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li>C++语言支持<strong>分离式编译机制</strong>：<ul>
<li>该机制允许将程序分隔为若干个文件，每个文件可被独立编译。为了将程序分为许多文件，则需要在文件中共享代码，例如一个文件的代码可能需要另一个文件中定义的变量</li>
</ul>
</li>
<li>为了支持分离式编译，C++允许<strong>将声明和定义分离开来</strong>：<ul>
<li>变量的声明规定了变量的类型和名字，即使一个名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。</li>
<li>定义则负责创建与名字关联的实体，申请存储空间。</li>
</ul>
</li>
<li>如果想声明一个变量而非定义它，就在变量名前添加<code>extern</code>关键字，而且不要显式地初始化变量。<code>extern int i; // 声明i</code>。变量可以被声明很多次，但那是只能被定义一次</li>
<li>在多个文件中共享<code>const</code>对象。默认情况下，一个<code>const</code>对象仅在本文件内有效，如果多个文件中出现了同名的<code>const</code>变量时，其实等同于在不同的文件中分别定义了独立的变量。</li>
<li>某些时候，我们需要只在一个文件中定义<code>const</code>变量，而在其他多个文件中声明并使用它。解决方法时：对于<code>const</code>变量不管是声明还是定义都添加<code>extern</code>关键字。</li>
<li>模板的控制实例化。当两个或者多个独立编译的源文件中使用了相同的模板并且提供了相同的模板参数时，每个文件中都会有该模板的一个实例。</li>
<li>在C++11新标准中，可以通过显式实例化来避免额外开销。<code>extern template declaration; // 实例化声明</code></li>
<li>当编译器遇到<code>extern</code>模板声明时，它不会在本文件中生成实例化代码，将一个实例化声明为<code>extern</code>就表示承诺在程序的其他位置有该实例化的一个非<code>extern</code>定义。</li>
<li>对于一个给定的的实例化版本，可能有多个<code>extern</code>声明，但是必须只有一个定义。</li>
<li>总结：<ul>
<li><code>extern</code>一般是使用在多个文件之间需要共享某些代码的情况下</li>
</ul>
</li>
</ul>
<h3 id="1-2-extern-用法总结"><a href="#1-2-extern-用法总结" class="headerlink" title="1.2 extern 用法总结"></a>1.2 <code>extern</code> 用法总结</h3><ul>
<li><p>在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量&#x2F;函数是在别处定义的，要在此处引用”。</p>
</li>
<li><p>extern修饰变量的声明</p>
<ul>
<li>如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。</li>
<li>这里需要注意的是，被引用的变量v的链接属性必须是外链接（external）的，也就是说a.c要引用到v，不只是取决于在a.c中声明extern int v，还取决于变量v本身是能够被引用到的。</li>
<li>这涉及到c语言的另外一个话题－－变量的作用域。能够被其他模块以extern修饰符引用到的变量通常是<strong>全局变量</strong>。</li>
<li>还有很重要的一点是，extern int v可以放在a.c中的任何地方，比如你可以在a.c中的函数fun定义的开头处声明extern int v，然后就可以引用到变量v了，只不过这样只能在函数fun作用域中引用v罢了，这还是变量作用域的问题。对于这一点来说，很多人使用的时候都心存顾虑。好像extern声明只能用于文件作用域似的。</li>
</ul>
</li>
<li><p>extern修饰函数声明</p>
<ul>
<li>从本质上来讲，变量和函数没有区别。<strong>函数名是指向函数二进制块开头处的指针</strong></li>
<li>如果文件a.c需要引用b.c中的函数，比如在b.c中原型是int fun(int mu)，那么就可以在a.c中声明extern int fun（int mu），然后就能使用fun来做任何事情。</li>
<li>就像变量的声明一样，extern int fun（int mu）可以放在a.c中任何地方，而不一定非要放在a.c的文件作用域的范围中。</li>
<li>对其他模块中函数的引用，最常用的方法是<strong>包含这些函数声明的头文件</strong>。使用extern和包含头文件来引用函数有什么区别呢？extern的引用方式比包含头文件要简洁得多！extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。</li>
<li>这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间。在大型C程序编译过程中，这种差异是非常明显的。</li>
</ul>
</li>
<li><p>extern修饰符可用于指示C或者C＋＋函数的调用规范</p>
<ul>
<li>比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。</li>
<li>这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。</li>
</ul>
</li>
</ul>
<h2 id="NULL-和-nullptr"><a href="#NULL-和-nullptr" class="headerlink" title="NULL 和 nullptr"></a>NULL 和 nullptr</h2><ul>
<li>字面值常量<code>nullptr</code>表示空指针，即不指向任何对象的指针。我们可以把<code>nullptr</code>赋给其他任意指针类型，但是不能赋值给其他内置类型。</li>
<li><code>nullptr</code>只有一个，它可以用于任意指针类型，C++并没有为每种指针类型各设计一个空指针</li>
<li>在<code>nullptr</code>被引入之前，人们使用数字0表示空指针。任何对象都不会分配到地址0上，0是nullptr最常见的表现形式。</li>
<li>在原来的代码中，很多人习惯于定义一个宏<code>NULL</code>来表示空指针。然而，在不同的具体实现中<code>NULL</code>的定义有所差别；例如，NULL可能是0，也可能是0L。</li>
<li>在C语言中，NULL通常是<code>(void*)0</code>，这种用法在C++中是非法的</li>
<li>使用<code>nullptr</code>的好处：可读性更强，当一组重载函数既可以接受指针也可以接受整数时，使用<code>nullptr</code>能够避免语义混淆。</li>
</ul>
<h2 id="指针与所有权"><a href="#指针与所有权" class="headerlink" title="指针与所有权"></a>指针与所有权</h2><ul>
<li>资源必须先分配后释放。我们用<code>new</code>分配内存，用<code>delete</code>释放内存；使用<code>fopen()</code>打开文件，使用<code>fclose()</code>关闭文件。因此内存和文件都是资源。</li>
<li>指针是最常用的资源句柄。这一点不太容易理解，毕竟在程序中指针随处可见，而且作为资源句柄和指针和不作为资源句柄的指针似乎没有什么差别。</li>
<li>把表示某种所有权的指针全部都置于<code>vector</code>, <code>string</code> 和 <code>unique_ptr</code>等资源句柄类中。</li>
<li>此时，我们就能假定所有不在资源句柄中的指针都不负责管理资源，因此也不必对它们执行delete操作。</li>
</ul>
<h3 id="指针和句柄"><a href="#指针和句柄" class="headerlink" title="指针和句柄"></a>指针和句柄</h3><ul>
<li><p>在程序设计中，句柄（<code>handle</code>）是<code>Windows</code>操作系统用来标识被应用程序所建立或使用的对象的整数。</p>
</li>
<li><p>其本质相当于带有引用计数的智能指针。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，可以使用句柄</p>
</li>
<li><p>句柄与普通指针的区别在于:</p>
<ul>
<li>指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。（参见封装）。</li>
<li>通俗的说就是我们调用句柄就是调用句柄所提供的服务，即句柄已经把它能做的操作都设定好了，我们只能在句柄所提供的操作范围内进行操作，但是普通指针的操作却多种多样，不受限制</li>
</ul>
</li>
<li><p>客户获得句柄时，句柄不仅是资源的标识符，也被授予了对资源的特定访问权限。</p>
</li>
<li><p>在上世纪80年代的操作系统（如<code>Mac OS[1]</code>和<code>Windows</code>）的内存管理中，句柄被广泛应用。</p>
</li>
<li><p><code>Unix</code>系统的文件描述符基本上也属于句柄。和其它桌面环境一样，<code>Windows API</code>大量使用句柄来标识系统中的对象，并建立操作系统与用户空间之间的通信渠道。例如，桌面上的一个窗体由一个<code>HWND</code>类型的句柄来标识</p>
</li>
</ul>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul>
<li><p>文件描述符（<code>File descriptor</code>）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念</p>
</li>
<li><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。</p>
</li>
<li><p>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
</li>
<li><p>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统</p>
</li>
<li><p>文件描述符的优点主要有两个：</p>
<ul>
<li>基于文件描述符的<code>I/O</code>操作兼容<code>POSIX</code>标准</li>
<li>在<code>UNIX</code>、<code>Linux</code>的系统调用中，大量的系统调用都是依赖于文件描述符</li>
<li>此外，在<code>Linux</code>系列的操作系统上，由于<code>Linux</code>的设计思想便是把一切设备都视作文件。因此，文件描述符为在该系列平台上进行设备相关的编程实际上提供了一个统一的方法</li>
</ul>
</li>
<li><p>文件描述符的概念存在两大缺点：</p>
<ul>
<li>在非<code>UNIX/Linux</code> 操作系统上（如<code>Windows</code>），无法基于这一概念进行编程——事实上，<code>Windows</code>下的文件描述符和信号量、互斥锁等内核对象一样都记作<code>HANDLE</code></li>
<li>由于文件描述符在形式上不过是个整数，当代码量增大时，会使编程者<strong>难以分清哪些整数意味着数据，哪些意味着文件描述符</strong>。因此，完成的代码可读性也就会变得很差，这一点一般通过使用名称有文字意义的<code>魔术数字</code>进行替换来解决</li>
</ul>
</li>
</ul>
<h3 id="魔术数字"><a href="#魔术数字" class="headerlink" title="魔术数字"></a>魔术数字</h3><ul>
<li><p>在程式设计中，魔术数字（<code>magic number</code>）可能指：</p>
<ul>
<li>缺乏解释或命名的独特数值。常常在程序中出现多次，并且可以（从规范上而言也应当）被有名字的常量取代</li>
<li>用于辨识一个档案格式或协定类型的一段常量或字符串，例如<code>UNIX</code>的特征签章。</li>
<li>不易于其他值混淆的值，例如<code>UUID</code></li>
</ul>
</li>
<li><p>魔术数字可以是指写死在程式码里的具体数值（如“10”“123”等以数字直接写出的值）</p>
</li>
<li><p>虽然程式作者写的时候自己能了解数值的意义，但对其他程式员而言，甚至制作者本人经过一段时间后，会难以了解这个数值的用途，只能苦笑讽刺“这个数值的意义虽然不懂，不过至少程式能够执行，真是个魔术般的数字”而得名</p>
</li>
<li><p>魔术数字带来的常见的负面影响包括：</p>
<ul>
<li>数值的意义难以了解，影响可读性</li>
<li>数值需要变动时，可能要改不只一个地方</li>
<li>当魔术数字是浮点数时，若在不同地方使用精度不同的数值，可能产生难以溯源的误差问题</li>
</ul>
</li>
<li><p>因此，一般认为应该用一个带有<strong>有意义名称的常量</strong>取代魔术数字</p>
</li>
<li><p>在计算机中<strong>以数字表示的其他信息也可能成为魔术数字</strong>，例如以十六进制数字表示的<code>RGB</code>格式的颜色</p>
</li>
<li><p>魔术数字也可以指其他非数字的值，例如字符，字符串等等。</p>
</li>
<li><p>但是，并非所有未命名的具体数值都是魔术数字。</p>
</li>
<li><p>一般而言，只要数字能让人一眼明白其含义，并且基本没有需要改变的可能，就不会被认为是魔术数字</p>
</li>
</ul>
<h2 id="结构，-联合与枚举"><a href="#结构，-联合与枚举" class="headerlink" title="结构， 联合与枚举"></a>结构， 联合与枚举</h2><ul>
<li>这些类型在C++的早期版本就已经存在了，它们主要关注数据如何表示的问题，构成了大多数C程序的基本框架。这里描述的<code>struct</code>其实是一种简单的<code>class</code></li>
</ul>
<h3 id="结构-struct"><a href="#结构-struct" class="headerlink" title="结构(struct)"></a>结构(struct)</h3><h3 id="C结构体"><a href="#C结构体" class="headerlink" title="C结构体"></a>C结构体</h3><ul>
<li><p>C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
</li>
<li><p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等</p>
</li>
<li><p>如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span>    <span class="comment">//对结构体B进行不完整声明</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//结构体A中包含指向结构体B的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="C-结构体"><a href="#C-结构体" class="headerlink" title="C++结构体"></a>C++结构体</h4><ul>
<li><p>结构声明(<code>structure declaration</code>)描述了<strong>一个结构的组织布局</strong>。</p>
<ul>
<li>例如：<code>struct book&#123;char title[MACTITLE]; char author[MAXAUTL]; float value;&#125;</code></li>
</ul>
</li>
<li><p>该声明描述了一个由两个字符数组和一个<code>float</code>类型变量组成的结构。该声明并未创建实际的数据对象，只描述了<strong>该对象由什么组成。</strong></p>
<ul>
<li>有时，我们把结构声明称为模板，因为它勾勒出结构是如何存储数据的。但和C++的模板不同，C++中的模板更加强大。</li>
</ul>
</li>
<li><p>结构有两层含义：</p>
<ul>
<li>一层含义是<strong>结构布局</strong>，它告诉编译器如何表示数据，但是它并未让编译器为数据分配空间</li>
<li>另一层含义是<strong>创建一个结构变量</strong>。程序中创建结构变量的一行是：<code>struct book library;</code> <ul>
<li>编译器执行这行代码便创建了一个结构变量<code>library</code>。编译器使用 <code>book</code> 模板为该变量分配空间：一个内含<code>MAXTITLE</code>个元素的<code>char</code>数组，一个内含<code>MAXAUTL</code>个元素的<code>char</code>数组和一个<code>float</code>类型的变量。这些存储空间都与一个名称<code>library</code>结合在一起。</li>
<li>在结构变量的声明中，<code>struct book</code>所起的作用相当于一般声明中的<code>int</code>或<code>float</code>。例如，可以定义两个<code>struct book</code>类型的变量，或者甚至是指向<code>struct book</code>类型结构的指针。</li>
</ul>
</li>
</ul>
</li>
<li><p>结构(<code>struct</code>), 是由任意类型元素（即成员，<code>member</code>）构成的序列</p>
</li>
<li><p>在<code>struct</code>的对象中，成员按照声明的顺序依次存放。在内存中为成员分配空间时，顺序与声明结构的时候保持一致。</p>
</li>
<li><p>但是，一个<code>struct</code>对象的大小不一定恰好等于它所有元素大小的累积之和。<strong>因为很多机器要求一些特定类型的对象沿着系统结构设定的边界分配空间，以便机器能够高效地处理这些对象。</strong></p>
</li>
<li><p><code>struct</code>是一种<code>class</code>，它的成员默认是<code>public</code>的。<code>struct</code>可以包含成员函数，尤其是构造函数</p>
</li>
<li><p>类型等价：对于两个<code>struct</code>来说，即使它们的成员相同，它们本身仍是不同的类型。<code>struct</code>本身的类型与其成员的类型不能混为一谈。在程序中，每个<code>struct</code>只能有唯一的定义。</p>
</li>
</ul>
<h4 id="结构体的初始化"><a href="#结构体的初始化" class="headerlink" title="结构体的初始化"></a>结构体的初始化</h4><ul>
<li><p>结构体是常用的自定义构造类型，是一种很常见的数据打包方法。结构体对象的初始化有多种方式，分为指定初始化、顺序初始化、构造函数初始化。</p>
</li>
<li><p>假设有如下结构体：<code>struct A&#123;int b; int b;&#125;;</code></p>
</li>
<li><p><strong>指定初始化（Designated Initializer）</strong></p>
<ul>
<li>实现上有两种方式:<ul>
<li>一种是通过点号加赋值符号实现，即“.fieldname&#x3D;value”，<code>struct A a = &#123;.b = 1, .c = 2&#125;;</code></li>
<li>另外一种是通过冒号实现，即“fieldname:value”，其中fieldname为指定的结构体成员名称。<code>struct A a = &#123;b:1, c:2&#125;;</code></li>
</ul>
</li>
<li>前一种是C99标准引入的结构体初始化方式，但在C++中，很多编译器并不支持。</li>
<li>Linux内核喜欢用“.fieldname&#x3D;value”的方式进行初始化，使用指定初始化，一个明显的优点是成员初始化顺序和个数可变，并且扩展性好，比如增加字段时，避免了传统顺序初始化带来的大量修改。</li>
</ul>
</li>
<li><p><strong>顺序初始化</strong></p>
<ul>
<li>是我们最常用的初始化方式，因为书写起来较为简约，但相对于指定初始化，无法变更初始化顺序，灵活性较差。<code>struct A a1 = &#123;1, 2&#125;;</code></li>
</ul>
</li>
<li><p><strong>构造函数初始化</strong></p>
<ul>
<li>常见于C++代码中，因为C++中的struct可以看作class，结构体也可以拥有构造函数，所以我们可以通过结构体的构造函数来初始化结构体对象。</li>
<li>给定带有构造函数的结构体：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  A(<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">    this-&gt;a = a;</span><br><span class="line">    this-&gt;b = b;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>那么结构体对象的初始化可以像类对象的初始化那样，如下形式：<code>struct A a(1, 2);</code></li>
</ul>
</li>
<li><p>注意： </p>
<ul>
<li>struct如果定义了构造函数的话，就不能用大括号进行初始化了，即不能再使用指定初始化与顺序初始化了。</li>
</ul>
</li>
</ul>
<h4 id="结构体的赋值"><a href="#结构体的赋值" class="headerlink" title="结构体的赋值"></a>结构体的赋值</h4><ul>
<li><p>变量的赋值和初始化是不一样的：</p>
<ul>
<li>初始化，是在变量定义的时候完成的，是属于变量定义的一部分；</li>
<li>赋值，是在变量定义完成之后想改变变量值的时候所采取的操作</li>
</ul>
</li>
<li><p>假设有如下结构体：<code>struct A&#123;int b; int b;&#125;;</code></p>
</li>
<li><p>结构体变量的赋值是不能够采用大括号的方式进行赋值的，例如下面的赋值就是不被允许的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;  <span class="comment">// 错误赋值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面列出常见结构体变量赋值的方法：</p>
</li>
<li><p>使用memset对结构体变量进行置空操作：【只能是POD的类型】</p>
<ul>
<li>按照编译器默认的方式进行初始化（如果a是全局静态存储区的变量，默认初始化为0，如果是栈上的局部变量，默认初始化为随机值）</li>
<li><code>struct A a; memset(&amp;a, 0, sizeof(a));</code></li>
</ul>
</li>
<li><p>依次给每一个结构体成员变量进行赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br><span class="line">a.b = <span class="number">1</span>;</span><br><span class="line">a.c = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用已有的结构体变量给另一个结构体变量赋值。也就是说结构体变量之间是可以相互赋值的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span> =</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">aa</span>;</span></span><br><span class="line">aa = a;  <span class="comment">// 将已有的结构体变量赋值给aa</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化与赋值有着本质的区别</strong>: 初始化是变量定义时的第一次赋值，赋值则是定义之后的值的变更操作，概念上不同，所以实现上也不一样。</p>
</li>
</ul>
<hr>
<h3 id="联合-union"><a href="#联合-union" class="headerlink" title="联合(union)"></a>联合(union)</h3><ul>
<li>联合(<code>union</code>)，是一种<code>struct</code>，同一时刻只保存一个元素的值</li>
<li><code>union</code>是一种特殊的<code>struct</code>，它的所有成员都分配在同一个地址空间上。因此，一个<code>union</code>实际占用的空间大小与其最大的成员一样。自然地，在同一时刻<code>union</code>只能保存一个成员的值</li>
</ul>
<h3 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h3><ul>
<li><p>枚举(<code>enum</code>), 是包含一组命名常量（称为枚举值）的类型</p>
</li>
<li><p>枚举类型(enumeration)是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>
</li>
<li><p>格式说明</p>
<ul>
<li>关键字enum——指明其后的标识符是一个枚举类型的名字。</li>
<li>枚举常量表——由枚举常量构成。”枚举常量”或称”枚举成员”，是以标识符形式表示的整型量，表示枚举类型的取值。</li>
<li>枚举常量表列出枚举类型的所有取值，各枚举常量之间以”，”间隔，且必须各不相同。取值类型与条件表达式相同</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>枚举常量代表该枚举类型的变量可能取的值，编译系统为每个枚举常量指定一个整数值，</li>
<li>默认状态下，这个整数就是所列举元素的序号，序号从0开始</li>
<li>可以在定义枚举类型时为部分或全部枚举常量指定整数值，在指定值之前的枚举常量仍按默认方式取值，而指定值之后的枚举常量按依次加1的原则取值。 </li>
<li><strong>各枚举常量的值可以重复</strong></li>
</ul>
</li>
<li><p>枚举常量只能以标识符形式表示，而不能是整型、字符型等文字常量。</p>
</li>
<li><p>例如，以下定义非法：</p>
<ul>
<li><code>enum letter_set &#123;&#39;a&#39;,&#39;d&#39;,&#39;F&#39;,&#39;s&#39;,&#39;T&#39;&#125;; //枚举常量不能是字符常量</code></li>
<li><code>enum year_set&#123;2000,2001,2002,2003,2004,2005&#125;; //枚举常量不能是整型常量</code></li>
</ul>
</li>
<li><p>可改为以下形式则定义合法：</p>
<ul>
<li><code>enum letter_set &#123;a, d, F, s, T&#125;;</code></li>
<li><code>enum year_set&#123;y2000, y2001, y2002, y2003, y2004, y2005&#125;;</code></li>
</ul>
</li>
<li><p>使用：</p>
<ul>
<li>定义枚举类型的主要目的是：增加程序的可读性</li>
<li>枚举类型最常见也最有意义的用处之一就是<strong>用来描述状态量</strong>，</li>
</ul>
</li>
</ul>
<h2 id="限定作用域的枚举类型-enum-class"><a href="#限定作用域的枚举类型-enum-class" class="headerlink" title="限定作用域的枚举类型 (enum class)"></a>限定作用域的枚举类型 (enum class)</h2><ul>
<li>限定作用域的枚举类型(<code>enum class</code>), 是一种<code>enum</code>， 枚举值位于枚举类型的作用域内，不存在向其他类型的隐式类型转换</li>
<li><code>enum class</code>是一种限定了作用域的强类型枚举，例如<ul>
<li><code>enum class Traffic_light &#123;red, yellow, green&#125;;</code></li>
<li><code>enum class Warning &#123;green, yellow, orange, red&#125;;</code></li>
<li>两个<code>enum</code>的枚举值不会互相冲突，它们位于各自<code>enum class</code>的作用域中</li>
</ul>
</li>
</ul>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><ul>
<li>分号本身也是一条语句，即空语句(<code>empty statement</code>)</li>
<li>花括号<code>&#123;&#125;</code>括起来的一个可能为空的语句序列称为块(<code>block</code>)或者复合语句(<code>compound statement</code>)。块中声明的名字的作用域到块的末尾就结束了</li>
<li>声明(<code>declaration</code>)是一条语句，没有赋值语句或过程调用语句；<strong>赋值和函数调用不是语句，它们是表达式。</strong></li>
<li><code>for</code>初始化语句(<code>for-init-statement</code>)要么是声明，要么是一条表达式语句(<code>expression-statement</code>)，它们都以分号结束</li>
<li><code>for</code>初始化声明(<code>for-init-declaration</code>)必须是一个未初始化变量的声明</li>
<li><code>try</code>语句块(<code>try-block</code>)的作用是处理异常</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>好注释负责指明一段代码应该实现什么功能（代码的意图），而代码本身负责完成该功能（完成的方式）。</li>
<li>最好的方式是：注释的语言应该保持在一个较高层次的抽象水平上，这样便于人们理解而无须纠结于过多的技术细节</li>
<li>关于注释，我的习惯是：<ul>
<li>在针对每个源文件的注释中指明：该文件中的声明有何共同点，对应的参考手册条目，程序员的名字以及维护该文件所需要的其他信息</li>
<li>为每个类，模板和命名空间分别编写注释</li>
<li>为每个非平凡的函数分别编写注释并指明：函数的目的，用到的算法（如果很明显的话可以不用提），以及该函数对其应用环境所做的某些设定</li>
<li>为全局和命名空间内的每个变量以及常量分别编写注释</li>
<li>为某些不太明显或者不可移植的代码编写注释</li>
<li>其他情况，则几乎不需要注释</li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p>函数的一个重要作用：把一个复杂的运算分解为若干有意义的片段，然后分别为它们命名。</p>
</li>
<li><p>把有用的操作“打包”在一起构成函数，然后认真起个名字</p>
</li>
<li><p>一个函数应该对应逻辑上的一个操作</p>
</li>
<li><p>创建自己的函数时，必须自行处理三个方面：<strong>定义，提供原型，调用</strong></p>
</li>
<li><p>定义函数，可以将函数分成两类：没有返回值的函数和有返回值的函数</p>
<ul>
<li>没有返回值的函数，被称为<code>void</code>函数</li>
<li>对于有返回值的函数，必须使用返回语句，以便将值返回给调用函数，<ul>
<li>值本身可以是常量，变量，也可以是表达式，只是其结果的类型必须为<code>typename</code>类型或可以被转换为<code>typename</code>。</li>
<li>函数将最终的值返回给调用函数。</li>
<li>C++对于返回值的类型有一定的限制：不能是数组，但可以是其他任何类型</li>
</ul>
<ul>
<li>函数是如何返回值的？<ul>
<li>通常，函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元，返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。</li>
<li>函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么需要原型？</p>
<ul>
<li>原型，描述了函数到编译器的接口，也就是说，它将函数返回值的类型以及参数的类型和数量告诉编译器</li>
</ul>
</li>
<li><p>原型的语法</p>
<ul>
<li>函数原型是一条语句，因此必须以分号结束。</li>
<li>获得原型最简单的方法，复制函数定义中的函数头，并添加分号。</li>
<li>函数原型不要求提供变量名，有<strong>类型列表</strong>就足够了</li>
<li>通常，在原型的参数列表中，可以包括变量名，也可以不包括。原型中的变量名相当于占位符，因此不必于函数定义中的变量名相同。</li>
</ul>
</li>
<li><p>原型的功能：</p>
<ul>
<li>编译器正确处理函数返回值</li>
<li>编译器检查使用的参数数目是否正确</li>
<li>编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可能的话）</li>
</ul>
</li>
</ul>
<h3 id="函数和数组"><a href="#函数和数组" class="headerlink" title="函数和数组"></a>函数和数组</h3><ul>
<li>在大多数情况下，C++和C语言一样，也将数组名视为指针。<strong>C++将数组名解释为其第一个元素的地址</strong><ul>
<li><code>cookies == &amp;cookies[0]  // array name is address of first element</code></li>
</ul>
</li>
<li>该规则有一些例外。<ul>
<li>首先，数组声明使用数组名来标记存储位置</li>
<li>其次，对数组名使用<code>sizeof</code>将得到整个数组的长度（以字节为单位）</li>
<li>第三，将地址运算符<code>&amp;</code>用于数组名时，将返回整个数组的地址</li>
</ul>
</li>
</ul>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><ul>
<li><p>函数多态是C++在C语言的基础上新增的功能。</p>
</li>
<li><p>默认参数能够使用不同数目的参数调用同一个函数，而函数多态（函数重载）能够使用多个同名的函数。</p>
</li>
<li><p>术语–<strong>多态</strong>，指的是有多种形式，因此函数多态允许函数可以有多种形式。</p>
</li>
<li><p>类似的，术语–<strong>函数重载</strong>，指的是可以有多个同名的函数，因此对名称进行了重载。</p>
</li>
<li><p><strong>这两个术语指的是同一个意思，但通常使用函数重载</strong>。可以通过函数重载来设计一系列函数–它们完成相同的工作，但是使用不同的参数列表。</p>
</li>
<li><p>函数重载的关键是函数的参数列表–也称为<strong>函数特征标</strong>(<code>function signature</code>)。</p>
</li>
<li><p>如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。</p>
</li>
<li><p><strong>C++允许定义名称相同的函数，条件是它们的特征标不同</strong>。如果参数数目和&#x2F;或参数类型不同，则特征标也不同。</p>
</li>
<li><p>何时使用函数重载？</p>
<ul>
<li>仅当函数基本上执行相同的任务，但是使用不同形式的数据时，才应该采用函数重载</li>
</ul>
</li>
<li><p>什么是名称修饰？</p>
<ul>
<li>C++如何跟踪每一个重载函数呢？– 它给这些函数指定了秘密身份。</li>
<li>名称修饰(<code>name decoration</code>)或名称矫正(<code>name mangling</code>)，它根据函数原型中指定的形参类型对每个函数名进行加密</li>
<li>对原始名称进行的表面看来无意义的修饰(或矫正)将对参数数目和类型进行编码。添加的一组符号随函数特征标而异，而修饰时使用的约定随编译器而异</li>
</ul>
</li>
</ul>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul>
<li><p>C++编译器实现了C++新增的一项特性–函数模板</p>
</li>
<li><p>函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的类型(例如<code>int</code>，<code>double</code>)替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型（而不是具体类型）的方式编写程序，因此有时也被称为<strong>通用编程</strong>。由于类型是用参数表示的，因此模板特性有时也被称为<strong>参数化类型</strong>(parameterized types)</p>
</li>
<li><p>要建立一个模板，关键字<code>template</code>和<code>typename</code>是必需的，除非可以使用关键字<code>class</code>代替<code>typename</code>。另外，必需使用尖括号。</p>
</li>
<li><p>类型名可以任意选择，只要遵守C++命名规则即可：许多程序员都使用简单的名称，例如，T</p>
</li>
<li><p>模板并不创建任何函数，而只是告诉编译器如何定义函数</p>
</li>
<li><p>在标准C++98添加关键字<code>typename</code>之前，C++使用关键字<code>class</code>来创建模板。<code>typename</code>关键字使得参数<code>AnyType</code>表示类型这一点更为明显；然而，有大量代码库是使用关键字<code>class</code>。在这种上下文中，这两个关键字是等价的。</p>
</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">描述</th>
<th align="left">运算规则</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">与</td>
<td align="left">两个位都为1时，结果才为1</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">或</td>
<td align="left">两个都为0时，结果才为0</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">异或</td>
<td align="left">两个位相同为0，相异为1</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">取反</td>
<td align="left">0 -&gt; 1, 1 -&gt; 0</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">左移</td>
<td align="left">各二进制位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">右移</td>
<td align="left">各二进制位全部右移若干位，对无符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">描述</th>
<th align="left">对应符号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">OR</td>
<td align="left">或</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">AND</td>
<td align="left">与</td>
<td align="left">&amp;</td>
</tr>
<tr>
<td align="left">XOR</td>
<td align="left">异或</td>
<td align="left">^</td>
</tr>
<tr>
<td align="left">NOR</td>
<td align="left">或非</td>
<td align="left">~(a</td>
</tr>
<tr>
<td align="left">NAND</td>
<td align="left">与非</td>
<td align="left">~(a&amp;b)</td>
</tr>
<tr>
<td align="left">XNOR</td>
<td align="left">异或非</td>
<td align="left">~(a^b)</td>
</tr>
</tbody></table>
<h3 id="1-1-按位与操作"><a href="#1-1-按位与操作" class="headerlink" title="1.1 按位与操作"></a>1.1 按位与操作</h3><ul>
<li>例如：<code>7&amp;5</code>的结果为5，计算过程为：<code>0000 0111 &amp; 0000 0101 = 0000 0101</code></li>
<li>常见用途：<ul>
<li>清零: 如果想将一个单元清零，让其与一个各位都为<code>0</code>的数值相与</li>
<li>取数（常见保留低八位,或者低16位，图像中常见）:</li>
<li>例如，X&#x3D;1001110101， 进行操作 X&amp;0xFF 之后得到 01110101 ; Y&#x3D;10000000000100111，进行操作 Y&amp;0xFFFF 之后得到 0000000000100111</li>
</ul>
</li>
</ul>
<h3 id="1-2-按位或操作"><a href="#1-2-按位或操作" class="headerlink" title="1.2 按位或操作"></a>1.2 按位或操作</h3><ul>
<li>例如：<code>7 | 5</code>的结果为7，计算过程为：<code>0000 0111 | 0000 0101 = 0000 0111</code></li>
<li>常见用途：<ul>
<li>负数补码</li>
<li>将一个数的某些<code>位</code>置为1 例如：把<code>Z=10100110</code>的低4位的数置为1，<code>Z|00001111</code>即可满足目的。</li>
</ul>
</li>
</ul>
<h3 id="1-3-取反运算"><a href="#1-3-取反运算" class="headerlink" title="1.3 取反运算"></a>1.3 取反运算</h3><ul>
<li>例如：<code>~7</code>的结果为472，计算过程为<code>~ 0000 0111 = 1111 1000</code></li>
<li>常见用途：<ul>
<li>使一个数的最低位为0，例如：Q&amp;<del>1, ~1的值为1111111111111110，在与操作之后，最低位一定为0，</del>的优先级高于算数运算符、关系运算符、逻辑运算符等</li>
</ul>
</li>
</ul>
<h3 id="1-4-异或运算"><a href="#1-4-异或运算" class="headerlink" title="1.4 异或运算"></a>1.4 异或运算</h3><ul>
<li>例如：<code>10 ^ -9</code>结果为-3，计算过程为：<code>0000 1010 ^ 1111 0111 = 0000 1101</code></li>
<li>常见用途：<ul>
<li>使特定位翻转：例如Q&#x3D;10110110，使Q低4位翻转，用X ^ 0000 1111 &#x3D; 1011 1001即可得到</li>
<li>与0相异，保留原值： Q^0000 0000 &#x3D; 10110110</li>
</ul>
</li>
</ul>
<h3 id="1-5-左移运算"><a href="#1-5-左移运算" class="headerlink" title="1.5 左移运算"></a>1.5 左移运算</h3><ul>
<li>例如：<code>X = 18; X = X &lt;&lt; 2</code>结果为72。计算过程：<code>&lt;&lt; 2 0001 0010 = 0100 1000</code></li>
<li>上述左移一位后<code>X = X * 2</code>; 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</li>
</ul>
<h3 id="1-6-右移运算符"><a href="#1-6-右移运算符" class="headerlink" title="1.6 右移运算符"></a>1.6 右移运算符</h3><ul>
<li>例如：<code>X = 18; X = X &gt;&gt; 2</code>结果为4，计算过程：<code>&gt;&gt; 2 0001 0010 = 0000 0100</code></li>
<li>操作数每右移一位，相当于该数除以2（向下取整）</li>
</ul>
<h3 id="1-7-C-中的移位运算"><a href="#1-7-C-中的移位运算" class="headerlink" title="1.7 C++中的移位运算"></a>1.7 C++中的移位运算</h3><ul>
<li>移位运算符在C++中会生成一个新值，但不回修改原来的值，例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">27</span>；</span><br><span class="line"><span class="type">int</span> y = x &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">y &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li>
<li>上述代码两次输出的值均为108，即不会修改x的值，表达式x&lt;&lt;2使用x的值来生成一个新的值，就像x+3会申城一个新值，但不会修改x一样，如果要用移位运算符来修改变量的值，则必须使用赋值运算符，可以使用常规的赋值运算符或者&lt;&#x3D;运算符，如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = x&lt;&lt;<span class="number">4</span>;</span><br><span class="line">y &lt;&lt;=<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-8-位运算的一些其他应用"><a href="#1-8-位运算的一些其他应用" class="headerlink" title="1.8 位运算的一些其他应用"></a>1.8 位运算的一些其他应用</h3><ul>
<li><p>判断奇偶数，对于除0之外的任何数，使用X&amp;1&#x3D;&#x3D;1作为逻辑判断即可，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">if</span>(x&amp;<span class="number">1</span>==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x为奇数&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断某个二进制是否为1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如判断x的第五位是否为1，十六进制的0x10转换为二进制是0001 0000</span></span><br><span class="line"><span class="keyword">if</span>(x&amp;<span class="number">0x10</span>==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x为奇数&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求平均数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (a &amp; b) + ((a ^ b) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//也可以用:return a - ((a - b) &gt;&gt; 1);</span></span><br><span class="line">    <span class="comment">//上面第一个会向下取整，第二个向上取整，例如输入10，11时，第一个返回10，第二个返回11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断两个数是否异号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">jtn</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ((a^b) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据加密</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> KEY 0x75</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="type">char</span> p_data[<span class="number">16</span>] = &#123; <span class="string">&quot;我和我的祖国&quot;</span> &#125;;</span><br><span class="line">  	<span class="type">char</span> Encrypt[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;, Decrypt[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(p_data); i++)<span class="comment">//加密</span></span><br><span class="line">  	&#123;</span><br><span class="line">  		Encrypt[i] = p_data[i] ^ KEY;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(Encrypt); i++)<span class="comment">//解密</span></span><br><span class="line">  	&#123;</span><br><span class="line">  		Decrypt[i] = Encrypt[i] ^ KEY;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;Initial date:  %s\n&quot;</span>, p_data);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;Encrypt date:  %s\n&quot;</span>, Encrypt);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;Decode date:  %s\n&quot;</span>, Decrypt);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  上述输出结果为：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Initial date: 我和我的祖国</span></span><br><span class="line"><span class="comment">  Encrypt date: 户细户辣虖</span></span><br><span class="line"><span class="comment">  Decode date: 我和我的祖国</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>取绝对值(效率高)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (n ^ (n &gt;&gt; <span class="number">31</span>)) - (n &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = n &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> i == <span class="number">0</span> ? n : (~n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><ul>
<li><p><strong>构造函数初始化对象</strong></p>
<ul>
<li>换句话说，它创建供成员函数进行操作的环境。创建环境时需要获取资源，如文件，锁或者一些内存，这些资源在使用后必须释放。</li>
<li>因此，某些类需要一个函数，在对象销毁时保证它会被调用，就像在对象创建时保证构造函数会被调用一样。这样的函数就必然被称为<strong>析构函数(destructor)</strong></li>
</ul>
</li>
<li><p><strong>析构函数不接受参数</strong></p>
<ul>
<li>每个类只能由一个析构函数。</li>
<li>当一个自动变量离开作用域时，自由空间中的一个对象被释放时，等等时刻，析构函数会被隐式调用。</li>
<li>只有在极少数情况下用户才需要显式调用析构函数。</li>
</ul>
</li>
<li><p>构造函数负责分配元素空间并正确地初始化<code>Vector</code>成员，析构函数则负责释放空间。这就是所谓的<strong>数据句柄模型（handle-to-data model）</strong>，常用来管理在对象声明周期中大小会发生变化的数据。</p>
</li>
<li><p>在构造函数中请求资源，然后在析构函数中释放他们的技术称为<strong>资源获取即初始化(Resource Acquisition Is Initialization),简称RAII</strong>，它使得我们得以规避”裸<code>new</code>操作“的风险</p>
</li>
<li><p>构造函数：</p>
<ul>
<li>每次在创建类的新对象的时候执行，</li>
<li>构造函数名称与类的名称完全相同，也不会返回任何类型。 </li>
<li>带参的构造函数，默认的构造函数没有任何参数，但是如果需要，可以带参数。这样在创建对象时给初始对象赋值。</li>
</ul>
</li>
<li><p>析构函数：</p>
<ul>
<li>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</li>
<li>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号作为前缀，</li>
<li>它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件，释放内存等）前释放资源。</li>
</ul>
</li>
<li><p>一个类对象不仅是一块内存区域那么简单。一个类对象是在“裸内存”上用其构造函数创建出来的，而当其析构函数执行完后，它又回到“裸内存”状态</p>
</li>
<li><p>构造操作是<strong>自顶向下</strong>的，而析构操作是<strong>自底向上</strong>的。</p>
</li>
</ul>
<h3 id="virtual析构函数"><a href="#virtual析构函数" class="headerlink" title="virtual析构函数"></a>virtual析构函数</h3><ul>
<li><p>析构函数可以声明为<code>virtual</code>，而且对于含有虚函数的类通常就应该这么做    </p>
</li>
<li><p>需要一个<code>virtual</code>析构函数的原因是：</p>
<ul>
<li><strong>如果通常是通过基类提供的接口来操纵一个对象，那么通常也应该通过此接口来delete它。</strong></li>
<li>假设有一个基类指针指向派生类对象的情况。这时候，如果基类的析构函数不是虚的，当通过基类指针删除对象时，只会调用基类的析构函数，而派生类的析构函数不会被调用。这会导致派生类可能分配的资源没有被正确释放，造成内存泄漏或者其他资源泄露。</li>
</ul>
</li>
<li><p>虚析构函数的作用：</p>
<ul>
<li>通过基类指针删除对象时，会先调用派生类的析构函数，再调用基类的析构函数</li>
<li>确保对象的完整销毁链，避免资源泄漏</li>
</ul>
</li>
<li><p>基类需要多态：</p>
<ul>
<li>如果类会被继承，且可能通过基类指针操作派生类对象，则基类必须使用虚析构函数</li>
</ul>
</li>
<li><p>无继承需求：</p>
<ul>
<li>若类不会被继承(例如工具类)， 或使用final关键字禁止继承，则无需虚析构函数。</li>
</ul>
</li>
<li><p>注</p>
<ul>
<li>虚函数表的开销：虚析构函数会引入虚函数表指针(vptr)，略微增加对象大小(通常4-8字节)。若类已有其他虚函数，此开销已存在。</li>
<li>默认析构函数：若未显式定义析构函数，编译器会生成一个非虚的默认析构函数</li>
<li>纯虚析构函数：若需要抽象基类但无其他虚函数，可生命纯虚析构函数(需提供实现)</li>
</ul>
</li>
</ul>
<h3 id="对象的声明周期"><a href="#对象的声明周期" class="headerlink" title="对象的声明周期"></a>对象的声明周期</h3><ul>
<li><p>对象的生命周期(<code>lifetime</code>)从对象的构造函数完成的那一刻开始，直到析构函数执行为止。</p>
</li>
<li><p>对于那些没有声明构造函数的类型，可以认为它们拥有默认的构造函数和析构函数，并且这两个函数不执行任何实际操作</p>
</li>
<li><p>从声明周期的角度把对象划分成一下类别：</p>
<ul>
<li>自动对象(<code>automatic</code>):<ul>
<li>除非程序员特别说明，否则在函数中声明的对象在其定义处被创建，当超出作用域范围时被销毁。这样的对象被称为自动对象</li>
<li>在大多数实现中，自动对象被分配在栈空间上</li>
<li>每调用一次函数，获取新的栈帧(<code>stack frame</code>)以存放它的自动对象</li>
</ul>
</li>
<li>静态对象(<code>static</code>)<ul>
<li>在全局作用域或命名空间作用域中声明的对象以及在函数或类中声明的<code>static</code>成员只被创建并初始化一次。</li>
<li>静态对象在程序的整个执行周期内地址唯一</li>
</ul>
</li>
<li>自由存储对象(<code>free store</code>)<ul>
<li>用<code>new</code>和<code>delete</code>直接控制其声明周期的对象</li>
</ul>
</li>
<li>临时对象(<code>temporary</code>)<ul>
<li>临时对象的声明周期由其用法决定，如果临时对象被绑定到一个引用上，则它的生命周期就是引用的生命周期；否则，临时对象的生命周期与它所处的完整表达式一致</li>
<li>完整表达式(<code>full expression</code>)，不属于其他任何表达式，通常情况下，临时对象也是自动对象</li>
</ul>
</li>
<li>线程局部对象(<code>thread-local</code>)<ul>
<li>这样的对象随着线程的创建而创建，随着线程的销毁而销毁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="拷贝构造函数和赋值函数"><a href="#拷贝构造函数和赋值函数" class="headerlink" title="拷贝构造函数和赋值函数"></a>拷贝构造函数和赋值函数</h2><ul>
<li><p>如果构造函数第一个参数为自身类类型的引用，且任何额外参数都具有默认值，则此构造函数为拷贝构造函数。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  public:</span><br><span class="line">    Foo();  <span class="comment">// 默认构造函数</span></span><br><span class="line">    Foo(<span class="type">const</span> Foo&amp;);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝构造函数的调用场景：</p>
<ul>
<li>将一个对象作为函数参数</li>
<li>函数返回值为一个非引用型对象</li>
<li>使用一个对象初始化另一个对象</li>
</ul>
</li>
<li><p>拷贝构造函数和赋值函数相似之处：都是将一个对象给另一个对象赋值，区别在于拷贝构造函数是将对象赋值给一个新的实例，而赋值函数是赋值一个已经存在的实例。</p>
</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li><p>虚函数的虚字的意义，就是在所谓的“动态联编”或者是“推迟联编”上，一个类的函数并不是在编译时被确定的，而是在运行时被确定的，<strong>由于编写代码的时候并不确定被调用的是基类的函数还是哪一个派生类的函数，所以被成为“虚”函数</strong></p>
</li>
<li><p>虚函数是指<strong>一个类中希望重载的成员函数</strong>，当用一个基类指针或引用指向一个继承类对象的时候，调用一个虚函数，实际调用的是继承类的版本。</p>
</li>
<li><p>虚函数最关键的特点是<strong>动态联编</strong>，它可以在运行时判断指针指向的对象，并自动调用相应的函数</p>
</li>
<li><p><strong>C++虚函数是多态性实现的重要方式</strong>，当某个虚函数通过指针或者引用调用时，编译器产生的代码直到运行时才能确定到底调用哪个版本的函数。被调用的函数是与绑定到指针或者引用上的对象的动态类型相匹配的那个。</p>
</li>
<li><p>因此，<strong>借助虚函数，可以实现多态性。这是<code>OOP</code>的核心思想之一</strong>。</p>
</li>
<li><p>虚函数只能借助于指针或者引用来达到多态的效果，如果是下面这样的代码，则虽然是虚函数，但它并不是多态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  a.<span class="built_in">foo</span>();  <span class="comment">// A::foo() 被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p>在了解虚函数的意思之后，再考虑多态就比较容易了，仍然是针对上面的类层次，但是使用的方法变得复杂了一些</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">(A *a)</span></span><br><span class="line">&#123;</span><br><span class="line">  a-&gt;foo();  <span class="comment">// 被调用的是A::foo() 还是 B::foo()?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>因为foo()是个虚函数，所以在bar这个函数中，只根据这一段代码，无法确定这里被调用的是A::foo()还是B::foo()，但是可以肯定的说，如果a只想的是A类的实例，则A::foo()被调用；如果a指向的是B类的实例，则B::foo()被调用。</p>
</li>
<li><p>这种<strong>同一代码可以产生不同效果的特点，称为“多态”</strong></p>
</li>
<li><p>多态有什么用？</p>
<ul>
<li>在面向对象的编程中，首先会针对数据进行抽象（确定基类）和继承（确定派生类），构成类层次。</li>
<li>这个类层次的使用者在使用它们的时候，如果仍然需要基类的时候写针对基类的代码，在需要派生类的时候写针对派生类的代码，就等于类层次完全暴露在使用者面前。如果这个类层次有任何的改变（增加了新类），都需要使用者“知道”（针对新类写代码）。这样就增加了类层次与其使用者之间的耦合，有人把这种情况列为程序中的“bad smell”之一</li>
<li>多态可以使程序员脱离这种窘境。<code>bar()</code>作为<code>A-B</code>这个类层次的使用者，它并不知道这个类层次中有多少个类，每个类都叫什么，但是一样可以很好的工作，当有一个C类从A类派生出来之后，bar()也不需要“知道”（修改）。这完全归功于编译器针对虚函数产生了可以在运行时刻确定被调用函数的代码。</li>
</ul>
</li>
<li><p>多继承中的虚函数，什么时候使用虚函数</p>
<ul>
<li>当在设计一个基类的时候，如果发现一个函数需要在派生类里有不同的表现，那么它就应该是虚的，</li>
<li>从设计的角度讲，出现在<strong>基类中的虚函数是接口</strong>，出现在<strong>派生类中的虚函数是接口的具体实现</strong>。通过这样的方法，就可以将对象的行为抽象化</li>
</ul>
</li>
</ul>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><ul>
<li><p>虚函数是C++中用于实现多态(<code>polymorphism</code>)的机制，核心理念就是通过基类访问派生类定义的函数。</p>
</li>
<li><p>在C++中的一种函数声明被称之为：纯虚函数(<code>pure virtual function</code>)，它的声明格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// =0 标志一个虚函数为虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：在普通的虚函数后面加上<code>=0</code>，这样就声明了一个纯虚函数(<code>pure virtual function</code>)</p>
</li>
<li><p>一个函数声明为纯虚后，纯虚函数的意思是：是一个抽象类，不要把我实例化</p>
</li>
<li><p>纯虚函数用来规范派生类的行为，实际上就是所谓的接口，他告诉使用者，我们<strong>派生类都会有这个函数</strong></p>
</li>
<li><p>在什么情况下使用纯虚函数？</p>
<ul>
<li>当想在基类中<strong>抽象出一个方法，且该基类只能被继承，而不能被实例化时</strong></li>
<li>这个方法<strong>必须在派生类中被实现</strong></li>
</ul>
</li>
<li><p>如果满足以上两点，可以考虑将该方法被声明为纯虚函数</p>
</li>
<li><p>当一个类打算被用作其他类的基类时，它的析构函数必须是虚的</p>
</li>
</ul>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul>
<li><p>C++标准提供了名称空间工具，以便更好地控制名称的作用域</p>
</li>
<li><p>在介绍C++中新增的名称空间特性之前，先复习C++中已有的名称空间属性</p>
<ul>
<li>**声明区域(<code>declaration region</code>)**，声明区域是可以在其中进行声明的区域。<ul>
<li>例如，可以在函数外面声明全局变量，对于这种变量，其声明区域为其声明所在的文件。对于在函数中声明的变量，其声明区域为其声明在所的代码块</li>
</ul>
</li>
<li><strong>潜在作用域(<code>potential scope</code>)</strong>, 变量的潜在作用域从声明点开始，到其声明区域的结尾。因此，潜在作用域比声明区域小，这是由于变量必须定义后才能使用</li>
</ul>
</li>
<li><p>C++关于全局变量和局部变量的规则定义了一种名称空间层次。每个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的名称。在一个函数中声明的局部变量不会在另一个函数中声明的局部变量发生冲突。</p>
</li>
<li><p>命名空间(<code>namespace</code>)的概念用来直接表示本属一体的一组特性。</p>
</li>
<li><p>命名空间，可作为附加信息来区分不同库中相同名称的函数，类，变量等。</p>
</li>
<li><p>使用了命名空间即<strong>定义了上下文</strong>。本质上，命名空间就是定义了一个范围</p>
</li>
<li><p>多个文件可以定义同一个命名空间，如果该命名空间内没有命名冲突，那么多个文件定义的就是同一个命名空间</p>
</li>
<li><p><strong>任何实际问题都是由若干独立部分组成的</strong>。函数和类提供了相对细粒度的关注点分离，而“库”，源文件和编译单元则提供了粗粒度的分离。</p>
</li>
<li><p>逻辑上最理想的方式是模块化(<code>modularity</code>)，即独立的事物保持分离，只允许通过良好定义的接口访问“模块”。</p>
</li>
<li><p>C++并不是通过单一语言特性来支持模块的概念，也并不存在模块这种语法构造。取而代之，C++<strong>通过其他语言特性（如函数，类和命名空间）的组合和源码的组织来表达模块化</strong></p>
</li>
<li><p>一个命名空间应该表达某种逻辑结构：一个命名空间中的声明应该一起提供一些特性，使得在用户看来它们是一个整体，而且能够反映一组共同的设计策略。它们应该被看成一个逻辑单元。</p>
</li>
<li><p>命名空间是开放的。即，你可以从多个分离的命名空间声明中向一个命名空间添加名字。这样，命名空间的成员就不需要连续放置在单一的文件中。</p>
</li>
</ul>
<h3 id="命名空间作为模块"><a href="#命名空间作为模块" class="headerlink" title="命名空间作为模块"></a>命名空间作为模块</h3><ul>
<li><p>命名空间是表达逻辑分组的一种机制。</p>
</li>
<li><p>即，如果按照某些标准判定一些声明逻辑上属于一个整体，则可将它们放置在一个共同的命名空间中，以表达这一点。</p>
</li>
<li><p>因此，我们可以<strong>使用命名空间来表达计算机程序的逻辑结构。</strong></p>
</li>
<li><p>函数重载机制是跨越命名空间的。这一点很重要，它允许我们以最小的代价修改代码将现有的库改进为使用命名空间的版本。</p>
</li>
<li><p>将除<code>main()</code>之外的所有非局部名字都置于命名空间中</p>
</li>
<li><p>不要为命名空间起非常短的名字。</p>
</li>
<li><p>如有必要，使用命名空间别名为长命名空间名提供简写</p>
</li>
<li><p>当定义命名空间成员时使用<code>Namespace::member</code>表示方式</p>
</li>
<li><p>将<code>using</code>指示用于代码转换，用于基础库(std)以及用于局部作用域内</p>
</li>
<li><p>不要将<code>using</code>指示放在头文件中</p>
</li>
</ul>
<h3 id="命名空间前途及其统一理念"><a href="#命名空间前途及其统一理念" class="headerlink" title="命名空间前途及其统一理念"></a>命名空间前途及其统一理念</h3><ul>
<li>使用在已命名的命名空间中声明的变量，而不是使用外部全局变量</li>
<li>使用在已命名的命名空间中声明的变量，而不是使用静态全局变量</li>
<li>如果开发了一个函数库或类库，将其放在一个名称空间中。事实上，C++当前提倡将标准函数库放在名称空间<code>std</code>中，这种做法扩展到了来自C语言中的函数。</li>
<li>仅将编译指令<code>using</code>作为一种将旧代码转换为使用名称空间的权宜之计</li>
<li>不要在头文件中使用<code>using</code>编译指令。首先，这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。</li>
<li>导入名称时，首选使用作用域解析运算符或<code>using</code>声明的方法</li>
<li>对于<code>using</code>声明，首选将其作用域设置为局部而不是全局</li>
</ul>
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><ul>
<li><code>-Wno-unused-result</code> : 加上这个编译选项，有返回值的返回，不使用其返回值也不会发出警告</li>
<li><code>-Wno-deprecated-declarations</code> : 不要警告 ，已弃用的函数，变量，类型</li>
</ul>
<h2 id="hpp-和-h"><a href="#hpp-和-h" class="headerlink" title=".hpp 和 .h"></a><code>.hpp</code> 和 <code>.h</code></h2><ul>
<li><code>.hpp</code>, 本质上就是将<code>.cpp</code>的实现代码混入<code>.h</code>头文件中，<strong>定义与实现都包含在同一文件</strong>。</li>
<li>该类的调用者只需要包含该<code>.hpp</code>文件即可，无需再将<code>.cpp</code>加入到项目中进行编译。实现代码将直接编译到调用者的对象文件中，不再生成单独的对象文件。</li>
<li>采用<code>.hpp</code>将大幅度减少调用项目中的<code>.cpp</code>文件数量和编译次数，非常适合用来编写开源库</li>
<li>注意事项<ul>
<li><code>.hpp</code>是<code>Header Plus Plus</code>的简写</li>
<li>与<code>.h</code>类似，<code>.hpp</code>是C++程序头文件格式</li>
<li><code>.hpp</code>是VCL专用的头文件，已预编译</li>
<li>是一般模板类的头文件</li>
<li>一般来说，<code>.h</code>里面只有声明，没有实现，而<code>.hpp</code>里声明实现都有，后者可以减少<code>.cpp</code>的数量</li>
<li><code>.h</code>里面可以有<code>using namespace std</code>，而<code>.hpp</code>里则没有</li>
</ul>
<ul>
<li>不可以包含全局对象和全局函数<ul>
<li>由于<code>.hpp</code>本质上是作为<code>.h</code>被调用者包含的文件，所以当<code>.hpp</code>文件中存在全局对象或者全局函数，而该<code>.hpp</code>被多个调用者包含时，将在链接时导致符号重定义错误。要避免这种情况，需要去除全局对象，将全局函数封装为类的静态方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分离编译"><a href="#分离编译" class="headerlink" title="分离编译"></a>分离编译</h2><ul>
<li><p>任何实际程序都由很多逻辑上分离的部分（如命名空间）组成，为了更好地管理这些组成部分，我们可以将程序表示为一组（源码）文件，其中每个文件包含一个或者多个逻辑组件。</p>
</li>
<li><p>我们以接口（如函数声明）与实现（如函数定义）的完全分离为目标。</p>
</li>
<li><p>当用户将一个源文件(<code>source file</code>)提交给编译器后</p>
<ul>
<li>首先对文件进行预处理，即，处理宏以及将<code>#include</code>指令指定的头文件包含进来。<ul>
<li>预处理的结果称为<strong>编译单元(translation unit)</strong></li>
<li>编译单元是编译器真正处理的内容，也是C++语言规则所描述的内容</li>
</ul>
</li>
<li>链接器(<code>linker</code>)是将分离编译的多个部分绑定在一起的程序。编译器有时也被称为加载器(<code>loader</code>)<ul>
<li>链接可以在程序开始运行前全部完成，也可以在程序运行中将新代码添加进来(“动态链接”)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><ul>
<li><p>预处理器是一些<strong>指令</strong>，指示编译器在实际编译之前所需完成的预处理。</p>
</li>
<li><p>所有的预处理器指令都是以井号（<code>#</code>）开头，只有空格字符可以出现在预处理指令之前。</p>
</li>
<li><p>预处理指令不是 <code>C++</code> 语句，所以它们不会以分号（<code>;</code>）结尾。</p>
</li>
<li><p><code>#include </code>指令。这个宏用于把头文件包含到源文件中</p>
</li>
<li><p>C++ 还支持很多预处理指令，比如 <code>#include</code>、<code>#define</code>、<code>#if</code>、<code>#else</code>、<code>#line</code> 等</p>
</li>
<li><p><code>#define</code> 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是：</p>
<ul>
<li><code>#define macro-name replacement-text </code></li>
<li>当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 <code>replacement-text</code></li>
</ul>
</li>
<li><p>条件编译</p>
<ul>
<li>有几个指令可以用来<strong>有选择地对部分程序源代码进行编译</strong>。这个过程被称为<strong>条件编译</strong></li>
<li>条件预处理器的结构与 <code>if</code> 选择结构很像<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NULL</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>可以只在调试时进行编译，调试开关可以使用一个宏来实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"> <span class="built_in">cerr</span> &lt;&lt;<span class="string">&quot;Variable x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>可以使用 <code>#if 0</code> 语句注释掉程序的一部分<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">   不进行编译的代码</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>#</code> 和 <code>##</code> 预处理运算符在 <code>C++</code> 和 <code>ANSI/ISO C</code> 中都是可用的</p>
<ul>
<li><code>#</code> 运算符会把 <code>replacement-text</code> 令牌转换为用引号引起来的字符串,<ul>
<li><code>#</code> 字符串化的意思，出现在宏定义中的<code>#</code>是<strong>把跟在后面的参数转换成一个字符串</strong></li>
<li>当用作字符串化操作时，<code>#</code> 的主要作用是将宏参数不经扩展地转换成字符串常量</li>
<li>宏定义参数的左右两边的空格会被忽略，参数的各个 <code>Token</code> 之间的多个空格会被转换成一个空格</li>
<li>宏定义参数中含有需要特殊含义字符如<code>&quot;</code>或<code>\</code>时，它们前面会自动被加上转义字符 <code>\</code></li>
</ul>
</li>
<li><code>##</code> 运算符用于连接两个令牌<ul>
<li><code>##</code> 连接符号，把参数连在一起。将多个 <code>Token</code> 连接成一个 <code>Token</code></li>
<li>它不能是宏定义中的第一个或最后一个 Token</li>
<li>前后的空格可有可无</li>
</ul>
</li>
</ul>
</li>
<li><p>C++中的<strong>预定义宏</strong></p>
<ul>
<li><code>__LINE__</code>  –  这会在程序编译时包含当前行号。</li>
<li><code>__FILE__</code>  –  这会在程序编译时包含当前文件名。</li>
<li><code>__DATE__</code>  –  这会包含一个形式为 <code>month/day/year</code> 的字符串，它表示把源文件转换为目标代码的日期</li>
<li><code>__TIME__</code>  –  这会包含一个形式为 <code>hour:minute:second</code> 的字符串，它表示程序被编译的时间</li>
</ul>
</li>
</ul>
<h2 id="C-STL中的map"><a href="#C-STL中的map" class="headerlink" title="C++ STL中的map"></a>C++ STL中的map</h2><ul>
<li><code>Map</code>， 是<code>STL</code>的一个关联容器，它提供一对一（其中一个可以称为关键字，每个关键字只能在<code>map</code>中出现一次，第二个可称为该关键字的值）的数据处理能力，</li>
<li>由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。</li>
<li><code>Map</code> 内部数据的组织，其内部自建一颗红黑树（一种非严格意义上的平衡二叉树），这棵树具有对数据自动排序的功能，所以在<code>Map</code>内部所有的数据都是有序的。</li>
</ul>
<h2 id="模板类array"><a href="#模板类array" class="headerlink" title="模板类array"></a>模板类<code>array</code></h2><ul>
<li><p><code>vector</code>类的功能比数组强大，但<strong>付出的代价是效率稍低</strong>。</p>
</li>
<li><p>如果需要的是长度固定的数组，使用数组是更佳的选择，但代价是不那么方便和安全。</p>
</li>
<li><p>这个类的目的是让array能够分配在栈上，而不是像vector那样总是需要访问自由存储区</p>
</li>
<li><p>有鉴于此，C++11新增了模板类<code>array</code>，它也位于名称空间<code>std</code>中。</p>
</li>
<li><p>与数组一样，<code>array</code>对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但更方便和安全。</p>
</li>
<li><p>要创建<code>array</code>对象，需要包含头文件<code>array</code></p>
</li>
<li><p>创建一个名为<code>arr</code>的<code>array</code>对象，它包含<code>n_elem</code>个类型为<code>typename</code>的元素：</p>
<ul>
<li><code>array&lt;typeName, n_elem&gt; arr;</code></li>
</ul>
</li>
<li><p>与创建<code>vector</code>对象不同的是，<code>n_elem</code>不能是变量</p>
</li>
<li><p><strong>方法</strong></p>
<ul>
<li><code>std::array::fill</code><ul>
<li>功能：把数组的所有元素都设置为val</li>
<li>函数原型:<code>void fill(const value_type&amp; val);</code></li>
</ul>
</li>
<li><code>std::array::at</code><ul>
<li>功能：返回数组中第n个位置的元素的引用。返回数组中指定位置的元素</li>
<li>函数原型：<code>reference at(size_type n);const_reference at(size_type n) const;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul>
<li><p>容器（<code>container</code>）</p>
<ul>
<li>容器是指一个包含若干元素的对象，因为<code>Vector</code>的对象都是容器，所以我们称<code>Vector</code>是一种容器类型。</li>
<li>如果<strong>一个类的主要目的是保存一些对象</strong>，那么我们通常称之为容器。</li>
</ul>
</li>
<li><p>容器（<code>container</code>），是指一个包含若干元素的对象，因为<code>Vector</code>的对象都是容器，所以我们称<code>Vector</code>是一种容器类型。</p>
</li>
<li><p>如果一个类的主要目的是保存一些对象，那么我们通常称之为容器。</p>
</li>
<li><p><code>Vector</code>的构造函数使用<code>new</code>运算符从自由存储（也称堆或动态存储）分配一些内存空间，析构函数则使用<code>delete</code>运算符释放该空间以达到清理资源的目的。这一切都无需<code>Vector</code>的使用者干预</p>
</li>
<li><p>构造函数负责分配元素空间并正确地初始化<code>Vector</code>成员，析构函数则负责释放空间。这就是所谓的<strong>数据句柄模型（handle-to-data model）</strong>，常用来管理在对象声明周期中大小会发生变化的数据</p>
</li>
<li><p>和所有标准库容器一样，<code>vector</code>也是元素类型为T的容器，即<code>vector&lt;T&gt;</code>。几乎任意一种数据类型都可以作为容器的元素类型</p>
</li>
<li><p>在构造函数中请求资源，然后在析构函数中释放它们的技术称为**资源获取即初始化(Resource Acquisition Is Initialzation)**，简称RAII，它使得我们得以规避“裸<code>new</code>操作”的风险。同时，也应该避免“裸<code>delete</code>操作”</p>
</li>
</ul>
<h3 id="二维容器"><a href="#二维容器" class="headerlink" title="二维容器"></a>二维容器</h3><ul>
<li><code>vector</code><strong>不能容纳对象引用作为其元素</strong>，因为引用不是一个对象。</li>
<li>在<code>C++11</code>中，二维容器的定义可以写成<code>vector&lt;vector&lt;int &gt; &gt;</code></li>
</ul>
<h3 id="向量-vector"><a href="#向量-vector" class="headerlink" title="向量 vector"></a>向量 vector</h3><ul>
<li><p>模板类<code>vector</code>和<code>array</code>是数组的替代品</p>
</li>
<li><p>模板类<code>vector</code>类似于<code>string</code>类，也是一种动态数组。可以在运行阶段设置<code>vector</code>对象的长度，可在末尾附加新数据，还可在中间插入新数据。</p>
</li>
<li><p>基本上，它是<strong>使用<code>new</code>创建动态数组的替代品</strong>。实际上，<code>vector</code>类确实使用<code>new</code>和<code>delete</code>来管理内存，但这种工作是自动完成的。</p>
</li>
<li><p>基本的使用知识</p>
<ul>
<li>首先，要使用<code>vector</code>对象，必须包含头文件<code>vector</code></li>
<li>其次，<code>vector</code>包含在名称空间<code>std</code>中，可使用<code>using</code>编译指令，<code>using</code>声明或<code>std::vector</code></li>
<li>第三，模板使用不同的语法来指出它存储的数据类型</li>
<li>第四，<code>vector</code>类使用不同的语法来指定元素数</li>
</ul>
</li>
<li><p>定义一个<code>Vector</code>类型的变量： <code>Vector v(6);  // 该Vector对象含有6个元素</code></p>
<ol>
<li>总的来说，<code>Vector</code>对象是一个“句柄”，它包含指向元素的指针（<code>elem</code>）以及元素的数量（<code>sz</code>）。在不同的<code>Vector</code>对象中元素的数量可能不通，即使同一个<code>Vector</code>对象在不同时刻也可能含有不通数量的元素。</li>
<li>不过，<code>Vector</code>对象本身的大小永远保持不变。这是C++语言处理可变数量的一项基本技术：一个固定大小的句柄指向位于“别处”（即通过new分配的自由空间）的一组可变数量的数据。</li>
</ol>
</li>
<li><p>向量（<code>Vector</code>），是一个封装了动态大小数组的顺序容器(<code>Sequence Container</code>)。跟任意其他类型容器一样，它能够存放各种类型的对象。</p>
<ul>
<li>可以简单的认为，<strong>向量是一个能够存放任意类型的动态数组</strong></li>
</ul>
</li>
<li><p>容器特性</p>
<ol>
<li>顺序序列：顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</li>
<li>动态数组：支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算术进行该操作。提供了在序列末尾相对快速地添加&#x2F;删除元素的操作</li>
<li>能够感知内存分配器（<code>Allocator-aware</code>）：容器<strong>使用一个内存分配器对象来动态地处理它的存储需求</strong>。</li>
</ol>
</li>
<li><p>常用方法：</p>
<ol>
<li><code>push_back</code>：在数组的最后添加一个数据</li>
<li><code>pop_back</code> ：去掉数组的最后一个数据</li>
<li><code>at</code>       ：得到编号位置的数据</li>
<li><code>begin</code>    ：得到数组头的指针</li>
<li><code>end</code>      ：得到数组的最后一个单元+1的指针</li>
<li><code>front</code>    ：得到数组头的引用</li>
<li><code>back</code>     ：得到数组的最后一个单元的引用</li>
<li><code>max_size</code> ：得到<code>vector</code>的最大存储元素的数量</li>
<li><code>capacity</code> ：当前<code>vector</code>分配的大小</li>
<li><code>size</code>    ：当前使用数据的大小</li>
<li><code>resize</code>  ：改变当前使用数据的大小，如果它比当前使用的大，填充默认值</li>
<li><code>reserve</code> ：改变当前<code>vector</code>所分配空间的大小</li>
<li><code>erase</code>   ：删除指针指向的数据向</li>
<li><code>clear</code>   ：清空当前的<code>vector</code></li>
<li><code>rbegin</code>  ：将<code>vector</code>反转后的开始指针返回</li>
<li><code>rend</code>    ：将<code>vector</code>反转后的结束指针返回</li>
<li><code>empty</code>   ：判断<code>vector</code>是否为空</li>
<li><code>swap</code>    ：与另一个<code>vector</code>交换数据</li>
</ol>
</li>
<li><p><code>vector::data</code></p>
<ul>
<li>返回指向向量内部用于存储其拥有的元素的内存数组的直接指针。</li>
<li>因为向量中的元素保证以与向量表示的相同顺序存储在连续的存储位置中，所以检索到的指针可以偏移以访问数组中的任何元素。</li>
<li>返回值：指向向量内部使用的数组中第一个元素的指针。<ul>
<li>如果向量对象是<code>const</code>限定的，则该函数返回一个指向<code>const value_type</code>的指针。</li>
<li>否则，它返回指向<code>value_type</code>的指针。</li>
</ul>
</li>
</ul>
</li>
<li><p>固定长度的vector</p>
<ul>
<li>vector提供了一个可以指定元素数量的构造函数，还提供了一个重载的<code>operator[]</code>以便于访问和修改这些元素。</li>
<li>通过<code>operator[]</code>访问<code>vector</code>边界之外的元素时，得到的结果是未定义的。其与真正的数组索引一样，vector上的<code>operator[]</code>没有提供边界检查功能</li>
<li>除了使用<code>operator[]</code>运算符外，还可以通过<code>at(), front(), back()</code>访问<code>vector</code>中的元素。</li>
<li><code>at()</code>方法等同于<code>operator()</code>运算符，区别在于<code>at()</code>会执行边界检查，如果索引超出边界，<code>at()</code>会抛出<code>out_of_range</code>异常</li>
<li><code>front()</code>和<code>back()</code>分别返回<code>vector</code>的第一个元素和最后一个元素的引用。在空的容器上调用<code>front()</code>和<code>back()</code>会引发未定义的行为</li>
</ul>
</li>
<li><p>assign()</p>
<ul>
<li>这个方法删除了所有现有的元素，并添加任意数目的新元素。这个方法特别适合于<code>vector</code>的重用。</li>
</ul>
</li>
</ul>
<h3 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a>元组 tuple</h3><ul>
<li><p>简介：</p>
<ul>
<li><code>tuple</code>是一个固定大小的不同类型值的集合，是泛化的<code>std::pair</code>。</li>
<li>可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更加简洁，直观。</li>
<li><code>std::tuple</code>理论上可以有无数个任意类型的成员变量，而<code>std::pair</code>只能是2个成员，因此在需要保存3个及以上的数据时就需要使用<code>tuple</code>元组</li>
</ul>
</li>
<li><p><code>template &lt;class... Types&gt; class tuple;</code></p>
</li>
<li><p>元组是能够保存元素集合的对象。每个元素可以是不同的类型</p>
</li>
<li><p>模板参数：</p>
<ul>
<li><code>Types...</code> – 用于元素的类型列表，其顺序与它们在元组中的排序顺序相同</li>
</ul>
</li>
</ul>
<h3 id="数据对-pair"><a href="#数据对-pair" class="headerlink" title="数据对 pair"></a>数据对 pair</h3><ul>
<li><p>功能： <code>pair</code> 将一对值组合成一个值,这一对值可以具有不同的数据类型（T1和T2）,两个值可以分别用pair的两个公有函数first和second访问。</p>
</li>
<li><p>类模块：<code>template&lt;class T1,class T2&gt; struct pair</code></p>
</li>
<li><p>参数：</p>
<ul>
<li>T1  –  第一个值的数据类型</li>
<li>T2  –  第二个值的数据类型</li>
</ul>
</li>
<li><p>需求：</p>
<ul>
<li>头文件:<code>#include &lt;utility&gt;   // std::pair, std::make_pair</code></li>
</ul>
</li>
<li><p><code>for(auto &amp;tmp : m_data)</code>  –  iterating for loop</p>
</li>
<li><p>基于循环的范围是在C++11标准中添加的，是其传统等效物的一种更紧凑的形式。基于循环的范围用于从头到尾迭代容器的元素</p>
<ul>
<li>The range based for loop is added in C++11 standard and is a more compact form of its traditional equivalent. The range based for loop is used to iterate over elements of a container from beginning to end.</li>
</ul>
</li>
<li><p>Syntax: <code>for(range-declaration : range-expression) loop statement</code></p>
<ul>
<li><code>range-declaration</code>  –  it is declaration of a variable of type same as the type of elements of range-expression. Often the auto keyword is used to automatically identify the type of elements in range-expression.</li>
<li><code>range-expression</code>   –  any expression used to represent a sequence of elements. Also Sequence of elements in braces can be used.</li>
<li><code>loop-statement</code>     –  body of for loop that contains one or more statements that are to be executed repeatedly till the end of range-expression</li>
</ul>
</li>
</ul>
<h3 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map"></a>映射 map</h3><ul>
<li><p>容器map，是键-值对的集合。</p>
</li>
<li><p>容器map类型通常可以理解为关联数组(associative array)，可以使用键作为下标来获取对应的值，正如内置数组类型一样</p>
</li>
<li><p>而关联的本质在于<strong>元素的值与某个特定的键相关联</strong>，而不是通过在数组中的位置来获取</p>
</li>
<li><p>map是由多对的键值组成的排序结构体，键值独一无二</p>
</li>
<li><p>容器类型<code>multimap</code>和容器类型map基本是一致的，只是multimap允许重复元素，而map不允许</p>
</li>
<li><p>简介：</p>
<ul>
<li>map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的</li>
<li>map的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响</li>
<li>对于迭代器来说，可以修改实值，而不能修改key</li>
</ul>
</li>
<li><p>功能：</p>
<ul>
<li>根据key值快速查找记录，查找的复杂度基本是Log(N)，如果有1000个记录，最多查找10次（2^10)，1,000,000个记录，最多查找20次</li>
<li>快速插入Key -Value 记录</li>
<li>快速删除记录</li>
<li>根据Key 修改value记录</li>
<li>遍历所有记录</li>
</ul>
</li>
<li><p>使用：</p>
<ul>
<li><code>#include &lt;map&gt;  //注意，STL头文件没有扩展名.h</code></li>
<li>map对象是模板类，需要关键字和存储对象两个模板参数：<ul>
<li><code>std:map&lt;int,string&gt; personnel;</code></li>
<li>这样就定义了一个用int作为索引,并拥有相关联的指向string的指针</li>
</ul>
</li>
</ul>
</li>
<li><p>对应的迭代器</p>
<ul>
<li>first  –  键</li>
<li>second –  键值</li>
</ul>
</li>
</ul>
<h4 id="map的容量"><a href="#map的容量" class="headerlink" title="map的容量"></a>map的容量</h4><ul>
<li>在map和multimap中，定义了两个成员函数<code>size()</code>和<code>max_size()</code>，用来确定map和multimap的数据成员的数量</li>
<li>函数的语法<ul>
<li><code>size_type size() const;</code></li>
<li><code>size_type max_size() const;</code></li>
</ul>
</li>
</ul>
<h4 id="map-和-multimap-成员函数"><a href="#map-和-multimap-成员函数" class="headerlink" title="map 和 multimap 成员函数"></a>map 和 multimap 成员函数</h4><ul>
<li><p>判断空函数 : <code>bool empty() const;</code></p>
<ul>
<li>如果为空，返回true</li>
</ul>
</li>
<li><p>遍历容器 : <code>begin(), end(), rbegin(), rend()</code></p>
<ul>
<li>容器map和multimap不支持元素直接存取，元素的存取需要经过迭代器实现，并且map和multimap的迭代器均是双向迭代器</li>
<li>&#96;</li>
</ul>
</li>
</ul>
<h3 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h3><ul>
<li><p>只能访问 queue<T> 容器适配器的第一个和最后一个元素。只能在容器的末尾添加新元素，只能从头部移除元素。</p>
</li>
<li><p>对于任何需要用 FIFO 准则处理的序列来说，使用 queue 容器适配器都是好的选择。</p>
</li>
</ul>
<h4 id="queue-操作"><a href="#queue-操作" class="headerlink" title="queue 操作"></a>queue 操作</h4><ul>
<li><code>front()</code>：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</li>
<li><code>back()</code>：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</li>
<li><code>push(const T&amp; obj)</code>：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</li>
<li><code>push(T&amp;&amp; obj)</code>：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。</li>
<li><code>pop()</code>：删除 queue 中的第一个元素。</li>
<li><code>size()</code>：返回 queue 中元素的个数。</li>
<li><code>empty()</code>：如果 queue 中没有元素的话，返回 true。</li>
<li><code>emplace()</code>：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象</li>
<li><code>swap(queue&lt;T&gt; &amp;other_q)</code>：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>任何一种特定的迭代器都是某种类型的对象</li>
<li>迭代器的类型非常多，因为每个迭代器都是与某个特定容器类型相关联的。</li>
<li>它需要保存一些必要的信息，以便我们对容器执行某些特定的人物。因此，有多少种容器就有多少中迭代器，有多少中特殊要求就有多少种迭代器</li>
<li>所有迭代器类型的语义及其操作的命名都是相似的。例如，对任何迭代器使用<code>++</code>运算符都会得到一个指向下一个元素的迭代器，而<code>*</code>运算符则得到迭代器所指的元素。</li>
<li>实际上，任何符合这些简单规则的对象都能被看成是迭代器。</li>
<li>用户不需要知道某个特定迭代器的类型，迭代器“知道”它自己的迭代器类型是什么，而且都能通过规范的名字<code>iterator</code>和<code>const_iterator</code>来正确声明自己的类型。</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>C++最核心的语言特性就是类。类是一种用户自定义的数据类型，用于<strong>在程序代码中表示某种概念</strong></li>
<li>三种重要的类的基本支持：具体类，抽象类，类层次中的类</li>
</ul>
<h3 id="具体类"><a href="#具体类" class="headerlink" title="具体类"></a>具体类</h3><ul>
<li>具体类型的典型特征是：它的表现形式是其定义的一部分</li>
<li>无须实参就可以调用的构造函数称为默认构造函数。通过定义默认构造函数，<strong>可以有效防止该类型的对象未初始化</strong></li>
<li>析构函数：确保构造函数分配的内存一定会被销毁的一种机制。其命名规则是一个求补运算符<code>~</code>后接类的名字，从含义上来说，它是构造函数的补充。</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>抽象类型（<code>abstract type</code>），将使用者与类的实现细节完全隔离开来。为了做到这一点，我们分离接口与表现形式并且放弃了纯局部变量</li>
<li>关键字<code>virtual</code>的意思是：<strong>可能随后在其派生类中重新定义</strong>。我们把这种用关键字virtual声明的函数称为虚函数(<code>virtual function</code>)</li>
<li>含有纯虚函数的类称为抽象类(<code>abstract class</code>)</li>
<li>如果一个类负责为其他一些类提供接口，那么我们把前者称为<strong>多态类型(polymorphic type)</strong></li>
</ul>
<h3 id="类层次"><a href="#类层次" class="headerlink" title="类层次"></a>类层次</h3><ul>
<li><p>所谓类层次（<code>class hierarchy</code>），是指通过派生（如:<code>public</code>）创建的一组类，在框架中有序排列。</p>
</li>
<li><p>我们使用类层次表示具有层次关系的概念，比如：消防车是卡车的一种，卡车是车辆的一种“以及”笑脸是一个圆，圆是一个形状“</p>
</li>
<li><p>对于抽象类来说，因为其派生类的对象通常是通过抽象基类的接口操纵的，所以基类中必须有一个虚析构函数。</p>
</li>
<li><p>当我们使用一个基类指针释放派生类对象时，虚函数调用机制能够确保我们调用正确的析构函数，然后该析构函数再隐式地调用其基类的析构函数和成员的析构函数。</p>
</li>
<li><p>总的来说，类层次提供了两种便利：</p>
<ul>
<li>**接口继承(<code>Interface inheritance</code>)**：派生类对象可以用在任何需要基类对象的地方。也就是说，基类看起来像是派生类的接口一样。这样的类通常是抽象类</li>
<li>**实现继承(<code>Implementation inheritance</code>)**：基类负责提供可以简化派生类实现的函数或数据。这样的基类通常含有数据成员和构造函数。</li>
</ul>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>面向对象程序设计中最重要的一个概念是<strong>继承</strong>。</p>
</li>
<li><p>继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了<strong>重用代码功能和提高执行效率的效果</strong></p>
</li>
<li><p>当创建一个类时，不需要重新编写新的数据成员和成员函数，只需要指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>
</li>
<li><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。</p>
</li>
<li><p>定义一个派生类，我们使用一个<strong>类派生列表</strong>来指定基类。类派生列表以一个或多个基类命名，例如：</p>
<ul>
<li><code>class derive-class: access-specifier base-class</code><ul>
<li>其中，访问修饰符<code>access-specifier</code>是：<code>public, protected, private</code>其中的一个，<code>base-class</code>是之前定义过的某个类的名称。</li>
<li>如果未使用访问修饰符<code>access-spcifier</code>，则默认为<code>private</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><table>
<thead>
<tr>
<th>访问</th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>派生类</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>外部的类</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<ul>
<li><p>一个派生类继承了所有的基类方法，但是下列情况除外：</p>
<ul>
<li>基类的构造函数，析构函数和拷贝构造函数</li>
<li>基类的重载运算符</li>
<li>基类的友元函数</li>
</ul>
</li>
<li><p>继承类型：</p>
<ul>
<li>**公有继承(public)**：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</li>
<li><strong>保护继承(protected)<strong>：当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的</strong>保护成员</strong>。</li>
<li><strong>私有继承(private)<strong>：当一个类派生自私有基类时，基类的公有和保护成员将称为派生类的</strong>私有成员</strong>。</li>
</ul>
</li>
</ul>
<h3 id="C-类成员的三种访问权限"><a href="#C-类成员的三种访问权限" class="headerlink" title="C++类成员的三种访问权限"></a>C++类成员的三种访问权限</h3><ul>
<li><p>C++通过<code>public, protected, private</code>三个关键字来<strong>控制成员变量和成员函数的访问权限（也称为可见性）</strong>，分别表示：公有的，受保护的，私有的</p>
</li>
<li><p>访问权限，就是<strong>能不能使用该类中的成员</strong></p>
</li>
<li><p>一般地，在类的内部，无论成员被声明为哪一种，都是可以互相访问的；</p>
</li>
<li><p>但是在类的外部，例如通过类的对象，则只能访问<code>public</code>属性的成员，不能访问<code>protected, private</code>属性的成员。</p>
<ul>
<li>**公有的(public)**：可以被该类中的函数，子类的函数，友元函数访问，也可以由该类的对象访问</li>
<li>**受保护的(protected)**：可以被该类中的函数，子类的函数，友元函数访问，但是不可以由该类的对象访问</li>
<li>**私有的(private)**：可以被该类中的函数，友元函数访问，但是不可以由子类的函数，该类的对象访问。（private关键字的作用在于更好地隐藏类的内部实现）</li>
</ul>
</li>
<li><p>根据**C++的软件设计规范，在实际项目开发中，类的成员变量以及只在类内部使用的成员函数，都建议声明为<code>private</code>，而将允许通过对象调用的成员函数声明为<code>public</code>**。</p>
</li>
<li><p>成员变量声明为<code>private</code>，如何赋值？以及怎么获取值？</p>
<ul>
<li>通常需要添加两个<code>public</code>属性的成员函数：一个用来设置成员变量的值，一个用来读取成员变量的值。</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>如果声明不写<code>public, protected, private</code>，则默认为<code>private</code></li>
<li>声明<code>public, protected, private</code>的顺序可以是任意的</li>
<li>在一个类中，<code>public, protected, private</code>可以出现多次，每个限定符的有效范围到出现另一个限定符或类结束为止。但是为了使程序逻辑清晰，应该使每一种限定符只出现一次。</li>
</ul>
</li>
</ul>
<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><ul>
<li>从来没有任何一个重要的程序是用“裸语言”写成的。人们通常县开发出一系列库，随后把它们作为进一步编程工作的基础。</li>
<li>常用的标准库类型，如<code>string, ostream, vector, map, unique_ptr, thread, regex, complex</code></li>
<li>在学习C++的过程中，应该<strong>努力探寻标准库的相关知识，尽量使用已有的标准库而不是自己再做一份</strong>。</li>
<li>因为标准库的设计已经凝结了太多精妙的思想，还没有更多的思想体现在其实现中，并且未来还会有大量的精力投入到标准库的维护和扩展中</li>
</ul>
<h2 id="并发与实用功能"><a href="#并发与实用功能" class="headerlink" title="并发与实用功能"></a>并发与实用功能</h2><ul>
<li><p>所有程序都包含一项关键任务：资源管理。所谓资源是指<strong>程序中符合先获取后释放（显式或者隐式）规律的东西</strong>，比如内存，锁，套接字，线程句柄和文件句柄等。</p>
</li>
<li><p>并发，也就是<strong>多个任务同时执行</strong>，被广泛用于提高吞吐率（用多个处理器共同完成单个运算）和提高相应速度（允许程序的一部分在等待响应时，另一部分继续执行）。</p>
</li>
<li><p>我们<strong>称那些可以与其他计算并行执行的计算为任务(<code>task</code>)<strong>。线程(<code>thread</code>)是</strong>任务在程序中的系统级表示</strong>。</p>
</li>
<li><p><code>join()</code>保证我们在线程完成后才退出，<code>join</code>的意思是：等待线程结束</p>
</li>
</ul>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><ul>
<li>模块化<ol>
<li>构建C++程序的关键就是清晰的定义这些组成部分之间的交互关系。</li>
<li>第一步也是最重要的一步，是将某个部分的接口和实现分离开来。</li>
<li>在语言层面，C++使用声明来描述接口。声明（<code>declaration</code>）指定了使用某个函数或某种类型所需的所有内容。</li>
<li>这里的关键点是函数体，即函数的定义（<code>definition</code>）位于”其他某处“。</li>
</ol>
</li>
<li>关注编程技术，而非语言特性。</li>
</ul>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><ul>
<li>对象首先应该有足够的空间存放对应的变量，但是这些还不够。</li>
<li>在一些机器的体系结构中，存放变量的字节必须保持一种良好的对齐(<code>alignment</code>)方式，以便硬件在访问数据资源时足够高效（在极端情况下一次性访问所有数据）</li>
<li>对齐，只有在<strong>涉及对象布局的问题中比较明显</strong></li>
</ul>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul>
<li>在C++程序中要想使用某个名字（标识符），必须先对其进行声明。换句话说，我们必须指定它的类型以便编译器知道这个名字对应的是何种实体</li>
<li>声明语句的作用不止把类型和名字关联起来这么简单。大多数声明(<code>declaration</code>)同时也是定义(<code>definition</code>)。</li>
<li>我们可以把定义看成是一种特殊的声明，它提供了在程序中使用该实体所需要的一切信息。</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li><p>声明语句为作用域引入了一个新名字，换句话说，某个名字只能在程序文本的某个特定区域使用</p>
</li>
<li><p>局部作用域(<code>local scope</code>)</p>
<ul>
<li>局部名字的作用域从声明处开始，到声明语句所在的块结束为止</li>
<li>块(<code>block</code>)，是指用一对<code>&#123;&#125;</code>包围的代码片段</li>
</ul>
</li>
<li><p>类作用域(<code>class scope</code>)</p>
<ul>
<li>如果某个类位于任意函数，类和枚举类或其他命名空间的外部，则定义在该类中的名字称为成员名字(<code>member name</code>)或类成员名字(<code>class member name</code>)。</li>
<li>类成员名字的作用域从类声明的<code>&#123;</code>开始，到类声明的<code>&#125;</code>结束为止</li>
</ul>
</li>
<li><p>命名空间作用域(<code>namespace scope</code>)</p>
<ul>
<li>如果某个命名空间位于任意函数，类和枚举类或其他命名空间的外部，则<strong>定义在该命名空间中的名字为命名空间成员名字</strong>(<code>namespace member name</code>)</li>
<li>命名空间成员名字的作用域从声明语句开始，到命名空间结束为止</li>
</ul>
</li>
<li><p>全局作用域(<code>global scope</code>)</p>
<ul>
<li>定义在任意函数，类，枚举类和命名空间之外的名字称为全局名字(<code>global name</code>)</li>
<li>全局名字的作用域从声明处开始，到声明语句所在的文件末尾为止</li>
<li>从技术上来说，全局命名空间也是一种命名空间，因为，我们可以把全局名字看成是一种特殊的命名空间成员名字</li>
</ul>
</li>
<li><p>语句作用域(<code>statement scope</code>)</p>
<ul>
<li>如果某个名字定义在<code>for</code>, <code>while</code>, <code>if</code> 和 <code>switch</code>语句的<code>()</code>部分，则该名字位于语句作用域中</li>
<li>它的作用范围从声明出开始，到语句结束为止。</li>
<li>语句作用域中的所有名字都是局部名字</li>
</ul>
</li>
<li><p>函数作用域(<code>function scope</code>) </p>
<ul>
<li>标签的作用域是从声明它开始到函数体结束</li>
</ul>
</li>
</ul>
<h3 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h3><ul>
<li>初始化器，就是对象在初始状态下被赋予的值</li>
</ul>
<h3 id="推断类型：auto-和-decltype"><a href="#推断类型：auto-和-decltype" class="headerlink" title="推断类型：auto 和 decltype()"></a>推断类型：auto 和 decltype()</h3><ul>
<li>C++语言提供了两种<strong>从表达式中推断数据类型的机制</strong><ul>
<li><code>auto</code>, 根据对象的初始化器推断对象的数据类型</li>
<li><code>decltype(expr)</code>推断的对象不是一个简单的初始化器，有可能是函数的返回类型或者类成员的类型。</li>
</ul>
</li>
</ul>
<h3 id="公理-axiom"><a href="#公理-axiom" class="headerlink" title="公理(axiom)"></a>公理(axiom)</h3><ul>
<li>与数学中一样，公理(<code>axiom</code>)就是我们认为正确但是又无法证明的东西</li>
</ul>
<h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><ul>
<li>操纵类和函数这种程序实体的编程通常称为元编程(<code>metaprogramming</code>)</li>
<li>我们用模板来创建类和函数。这导致一个理念：模板程序设计用来编写特殊的程序，这种程序在编译时计算，并能生成代码。</li>
<li>这一理念的变体也称为两级编程(two-level programming)，多级编程(multilevel programming)， 生成式编程(generative programming)以及更常见的模块元编程(template metaprogramming)</li>
<li>使用元编程技术的主要有两个目的：<ul>
<li>提高类型安全。我们可以计算一个数据结构或算法所需要的确切类型，从而不必直接操作低层数据结构</li>
<li>提高运行时性能。我们可以在编译时进行计算并选择在运行时要调用的函数。这样，我们就不必在运行时进行这些计算。（例如，我们可以将很多多态行为解析为直接函数调用）。特别时，通过利用类型系统，可以显著提高内联的机会。而且，通过使用紧凑的数据结构（可能是生成的数据结构），我们能够更好地利用内存，即减少内存占用又提高运行速度。</li>
</ul>
</li>
</ul>
<h2 id="C-C-判断变量的类型"><a href="#C-C-判断变量的类型" class="headerlink" title="C&#x2F;C++判断变量的类型"></a>C&#x2F;C++判断变量的类型</h2><ul>
<li><p>C++判断变量类型：利用<code>typeid()</code>来判断变量类型</p>
<ul>
<li><code>#include &lt;typeinfo&gt;  typeid(var).name()</code></li>
<li><code>type_info</code>的成员函数<code>name</code>返回类型的<code>C-style</code>字符串，但这个返回的类型名与程序中使用的相应类型名不一定一致，其返回值的实现由编译器决定，标准只要求每个类型返回的字符串是唯一的</li>
<li>和<code>sizeof</code>操作符类似，<code>typeid</code>的操作对象既可以是数据类型，也可以是表达式</li>
<li>不像<code>Java</code>、<code>C#</code>等动态语言，<code>C++</code>运行时能获取到的类型信息非常有限，标准也定义的很模糊，如同“鸡肋”一般。在实际工作中，我们一般只使用<code>type_info</code>的<code>“==”</code>运算符来判断两个类型是否相同</li>
<li>不能用<code>typeid</code>来判断基类指针实际指向的是否是某个派生类</li>
</ul>
</li>
<li><p>C语言中，<strong>没有判断变量类型的函数</strong></p>
</li>
<li><p>可以简单利用<code>sizeof()</code>或者<code>ASCII</code>码辅助判断</p>
<ul>
<li>表达式<code>sizeof()</code>可以得到对象或类型的存储字节大小，但是不同操作系统可能存在差异</li>
</ul>
</li>
</ul>
<h2 id="C-字符串和数字的拼接"><a href="#C-字符串和数字的拼接" class="headerlink" title="C++字符串和数字的拼接"></a>C++字符串和数字的拼接</h2><ul>
<li><p><code>std::to_string()</code></p>
<ul>
<li>通过<code>std::to_string()</code>可以将数字类型转换成<code>std::string</code>类型，从而可以直接使用<code>+</code>完成字符串的拼接</li>
<li>需要注意的是，<code>std::string</code>是C++11才有的方法，在g++编译的时候需要指定<code>-std=c++11</code></li>
</ul>
</li>
<li><p><code>c_str()</code></p>
<ul>
<li>如果想要转换为<code>const char*</code>的类型，可以使用<code>c_str()</code>的方法<ul>
<li><code>std::string str = &quot;hello 1&quot;; str.c_str();</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>const_cast</code></p>
<ul>
<li>如果想要去除const属性，需要使用到<code>const_cast</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">&quot;hello 1&quot;</span>; str.c_str();</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* const_char_str = str.c_str();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; const_char_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* char_str = const_cast&lt;<span class="type">char</span>*&gt;(const_char_str);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; char_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="C-类的对象调用成员函数"><a href="#C-类的对象调用成员函数" class="headerlink" title="C++类的对象调用成员函数"></a>C++类的对象调用成员函数</h2><ul>
<li><p>点</p>
<ul>
<li><strong>变量名</strong>所指向其成员时使用</li>
</ul>
</li>
<li><p>箭头</p>
<ul>
<li><strong>地址</strong>所指向其成员时使用</li>
</ul>
</li>
<li><p><code>A *p; p-&gt;play()</code> : 左边是<strong>结构指针</strong></p>
</li>
<li><p><code>A p; p.play()</code> : 左边是<strong>结构变量</strong></p>
</li>
<li><p>总结：</p>
<ul>
<li>箭头<code>-&gt;</code> : 左边必须为指针</li>
<li>点号<code>.</code> : 左边必须为实体</li>
</ul>
</li>
</ul>
<h2 id="C-中用-new-和不用-new-创建类对象"><a href="#C-中用-new-和不用-new-创建类对象" class="headerlink" title="C++中用 new 和不用 new 创建类对象"></a>C++中用 <code>new</code> 和不用 <code>new</code> 创建类对象</h2><ul>
<li><p><code>new</code>创建类对象，使用完需要使用<code>delete</code>删除，和申请内存类似。</p>
</li>
<li><p><code>new</code>创建类对象和不使用<code>new</code>的区别</p>
<ul>
<li><code>new</code>创建类对象需要指针接收，一处初始化，多处使用</li>
<li><code>new</code>创建类对象使用完需要使用<code>delete</code>销毁</li>
<li><code>new</code>创建对象直接使用堆空间，而局部不用<code>new</code>定义类对象则使用栈空间</li>
<li><code>new</code>对象指针用途广泛，比如作为函数返回值，函数参数等</li>
<li>频繁调度场合并不适合new，就像new申请和释放内存一样</li>
</ul>
</li>
<li><p>普通创建方式，使用完后不需要手动释放，该类析构函数会自动执行；而<code>new</code>申请的对象，则只有调用到<code>delete</code>时才会执行析构函数，如果程序退出而没有执行<code>delete</code>，则会造成内存泄漏。</p>
</li>
<li><p>只定义类指针：</p>
<ul>
<li>这跟不用new声明对象有很大区别：类指针可以先行定义，但是类指针只是一个通用指针，在<code>new</code>之前并未对该类对象分配任何内存空间。</li>
<li>使用普通方式创建的类对象，在创建之初就已经分配了内存空间，而类指针，如果没有经过对象初始化，则不需要<code>delete</code>释放</li>
</ul>
</li>
</ul>
<h2 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h2><ul>
<li><p>C++如何增加内存负载？</p>
<ul>
<li>假设要创建一个类，其一个成员表示某人的姓。最简单的方法是使用字符数组来保存，但这种方法有一种缺陷。开始也许会使用一个14个字符的数组，然后发现数组太小，更保险的方法是，使用一个40个字符的数组。然而，如果创建包含2000个这种对象的数组，就会由于字符数组只有部分被使用而浪费大量的内存（<strong>在这种情况下，增加了计算机的内存负载</strong>）。</li>
</ul>
</li>
<li><p><strong>通常，最好是在程序运行时（而不是编译时）确定诸如使用多少内存等问题</strong>。对于在对象中保存姓名来说，通常的C++方法是：在类构造函数中使用new运算符在程序运行时分配所需的内存。</p>
</li>
<li><p>在构造函数中使用new来为字符串分配空间，这避免了在类声明中预先定义字符串的长度</p>
</li>
<li><p>静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象共享同一个静态成员。这对于所有类对象都具有相同值的类私有数据是非常方便的。</p>
</li>
<li><p>在构造函数中使用<code>new</code>来分配内存时，必须在相应的析构函数中使用<code>delete</code>来释放内存。如果使用<code>new[]</code>（包括中括号）来分配内存，则应使用<code>delete[]</code>（包括中括号）来释放内存。</p>
</li>
</ul>
<h2 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h2><ul>
<li>C++为在内存中存储数据方面提供了多种选择。可以选择数据保留在内存中的时间长度（存储持续性）以及程序的哪一部分可以访问数据（作用域和链接）等。可以使用new来动态地分配内存，而定位new运算符提供了这种技术的一种变种。C++名称空间是另一种控制访问权的方式。</li>
<li>通常，大型程序都由多个源代码文件组成，这些文件可能共享一些数据。这样的程序涉及到程序文件的单独编译。</li>
</ul>
<h3 id="单独编译"><a href="#单独编译" class="headerlink" title="单独编译"></a>单独编译</h3><ul>
<li><p>和C语言一样，C++也允许甚至鼓励程序员将<strong>组件函数</strong>放在独立的文件中。</p>
</li>
<li><p>与其将结构声明加入到每一个文件中，不如将其放在头文件中，然后在每一个源代码文件中包含该头文件。这样，要修改结构声明时，只需要在头文件中做一次改动即可。另外，也可以将函数声明放在头文件中。</p>
</li>
<li><p>原来的程序分成三部分：</p>
<ul>
<li>头文件，包含结构声明和使用这些结构的函数的声明</li>
<li>源代码文件，包含与结构有关的函数的代码</li>
<li>源代码文件，包含调用与结构相关的函数的代码</li>
</ul>
</li>
<li><p>头文件中常包含的内容：</p>
<ul>
<li>函数声明</li>
<li>使用<code>#define</code>或<code>const</code>定义的符号常量</li>
<li>结构声明</li>
<li>类声明</li>
<li>模板声明</li>
<li>内联函数</li>
</ul>
</li>
</ul>
<h3 id="存储持续性，作用域和链接性"><a href="#存储持续性，作用域和链接性" class="headerlink" title="存储持续性，作用域和链接性"></a>存储持续性，作用域和链接性</h3><ul>
<li><p>C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别就在于数据保留在内存中的时间</p>
<ul>
<li><strong>自动存储持续性</strong> – 在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量。</li>
<li><strong>静态存储持续性</strong> – 在<strong>函数定义外</strong>定义的变量和使用关键字<code>static</code>定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有三种存储持续性为静态的变量。</li>
<li><strong>线程存储持续性（C++11）</strong> – 当前，多核处理器很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字<code>thread_local</code>声明的，则其声明周期与所属的线程一样长。（并行编程）</li>
<li><strong>动态存储持续性</strong> – 用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束位置。这种内存的存储持续性为动态，有时被称为自由存储(free store)或堆(heap)</li>
</ul>
</li>
<li><p>作用域(scope)描述了名称在文件（翻译单元）的多大范围内可见。</p>
</li>
<li><p>链接性(linkage)描述了名称如何在不同单元间共享。</p>
<ul>
<li>链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享</li>
<li>自动变量的名称没有链接性，因为它们不能共享</li>
</ul>
</li>
</ul>
<h2 id="类-–-成员名和参数名"><a href="#类-–-成员名和参数名" class="headerlink" title="类 – 成员名和参数名"></a>类 – 成员名和参数名</h2><ul>
<li>构造函数的参数，表示的不是类成员，而是赋给类成员的值。因此，参数名不能与类成员的名称相同</li>
<li>为了避免这种混乱<ul>
<li>一种常见的做法是 – <strong>在数据成员名中使用<code>m_</code>前缀</strong></li>
<li>另一种常见的做法是 – <strong>在数据成员名中使用<code>_</code>后缀</strong></li>
</ul>
</li>
</ul>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><ul>
<li><p><code>typedef</code>声明,为现有类型创建一个新的名字。比如常常使用<code>typedef</code>来编写更美观和可读的代码。</p>
</li>
<li><p>所谓美观，是指<code>typedef</code>能够隐藏笨拙的语法构造以及平台相关的数据类型，从而增强可移植性以及未来的可维护性。</p>
</li>
<li><p>在编程中使用<code>typedef</code>目的一般有两个，一个是给变量一个容易记且意义明确的新名字，另一个是简化一些比较复杂的类型声明。</p>
</li>
<li><p><code>typedef</code>并不是创建新的类型，它仅仅为现有类型添加一个同义字</p>
</li>
<li><p><code>typedef</code>的最简单使用</p>
<ul>
<li><code>typedef int size;</code></li>
<li><code>typedef unsigned int u_int;</code></li>
</ul>
</li>
<li><p><strong>typedef和数组，指针</strong></p>
<ul>
<li>可以不用像下面这样重复定义有81个字符元素的数组：<ul>
<li><code>char line[81];</code></li>
<li><code>char text[81];</code></li>
</ul>
</li>
<li>定义一个<code>typedef</code>，每当要用到相同类型和大小的数组时，可以：<ul>
<li><code>typedef char Line[81];</code></li>
<li><code>Line text, secondline;</code></li>
</ul>
</li>
<li>同样，可以像下面这样隐藏指针语法：<ul>
<li><code>typedef char* pstr;</code></li>
<li><code>pstr str = &quot;abc&quot;;</code></li>
<li><code>int mystrcmp(pstr, pstr);</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>typedef和函数</strong></p>
<ul>
<li>函数指针一般用于回调，例如信号处理。回调是比较常用的技术，而回调就要涉及函数指针。</li>
<li>当程序有以下函数：<ul>
<li><code>void printHello(int i);</code></li>
</ul>
</li>
<li>然后需要定义一个函数指针，指向<code>printHello</code>,并且调用这个方法，代码如下：<ul>
<li><code>void (*pFunc)(int);</code></li>
<li><code>pFunc = &amp;printHello;</code></li>
<li><code>(*pFunc)(110);</code></li>
</ul>
</li>
<li>其中，<code>void (*pFunc)(int)</code>是声明一个函数指针，指向返回值是<code>void</code>，调用参数是<code>(int)</code>的函数，变量名是<code>pFunc</code>就是函数指针。</li>
<li>这种声明一个函数指针是比较复杂的，尤其是要在多处地方声明同一个类型的函数指针变量，代码更加复杂</li>
<li>简化的做法<ul>
<li><code>typedef void (*PrintHelloHandle)(int);</code></li>
</ul>
</li>
<li>使用代码如下：<ul>
<li><code>PrintHelloHandle pFunc;</code></li>
<li><code>pFunc = &amp;printHello;</code></li>
<li><code>(*pFunc)(110);</code></li>
</ul>
</li>
<li>以后其他地方的程序需要声明类似的函数指针，只需要使用：<code>PrintHelloHandle pFuncOther;</code></li>
</ul>
</li>
</ul>
<h2 id="中国大学mooc-北京邮电大学-C-语言程序设计"><a href="#中国大学mooc-北京邮电大学-C-语言程序设计" class="headerlink" title="中国大学mooc 北京邮电大学 C++语言程序设计"></a>中国大学mooc 北京邮电大学 C++语言程序设计</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>C++ 语言的特点</p>
<ul>
<li>使用面向对象方法，易于代码重用</li>
<li>适用于大型软件工程项目，易于管理</li>
<li>代码可维护性好</li>
</ul>
</li>
<li><p>面向过程的程序基本结构：</p>
<ul>
<li>顺序</li>
<li>分支</li>
<li>循环</li>
</ul>
</li>
<li><p>面向过程的程序设计主要思想：</p>
<ul>
<li><strong>自顶向下，逐步求精</strong></li>
<li>模块化<ul>
<li>将一个大的系统按照子结构之间的疏密程序分解为较小的部分，每部分称为模块</li>
<li>分解的原则是：模块之间相对独立，联系较少</li>
<li><strong>提供给模块外部可见的只是抽象数据及其上的抽象操作，隐藏了实现细节</strong></li>
<li>整个程序由多模块组成，模块一般以函数为单位</li>
</ul>
</li>
</ul>
</li>
<li><p>面向对象的程序设计将数据和处理数据的函数当成一个整体：类（类的实例称为对象）</p>
<ul>
<li>封装：由对象的概念支持。只需知道外部接口，不需知道内部实现，就可以使用的特性</li>
<li>继承：由类的概念支持。利用已有的成果进行扩展，充分体现了代码重用</li>
<li>多态：运行时特性</li>
<li>确定每个对象和类的简述，例如具体的属性和方法等。</li>
</ul>
</li>
<li><p>面向对象的程序设计的步骤：</p>
<ul>
<li>找出问题中的对象和类</li>
<li>找出这些对象和类之间的关系，确定对象之间的消息通信方式，类之间的继承和组合等关系</li>
<li>编写程序实现这些对象和类</li>
</ul>
</li>
<li><p>关键字 – 是**C++**预先定义好的标识符，在程序中具有特殊作用</p>
</li>
<li><p>标识符 – 是<strong>程序员声明</strong>的单词，它命名程序正文中的一些实体，例如函数名，变量名，类名，对象名等。</p>
</li>
<li><p>分隔符 – 不表示实际的操作，仅仅用于构造程序</p>
<ul>
<li>C++分隔符：<code>()</code> <code>&#123;&#125;</code> <code>,</code> <code>;</code> <code>:</code></li>
</ul>
</li>
<li><p>空白  – 是指制表符，空格，空行，用于分隔单词，在C++语句中经常出现空白，通常都忽略不计</p>
</li>
<li><p>C++的数据类型决定了</p>
<ul>
<li>数据表示形式</li>
<li>数据的存储空间</li>
<li>对数据可以进行哪些运算以及运算规则</li>
</ul>
</li>
<li><p>C++的数据类型分为：基本数据类型和自定义数据类型</p>
</li>
<li><p>表达式 – 操作数与运算符（操作符）序列，表达式的值：运算结果</p>
</li>
<li><p>语句   – 由表达式和结尾的<code>;</code>组成一个C++语句</p>
</li>
<li><p>语句块 – 由<code>&#123;&#125;</code>括起来的语句序列，又称为复合语句</p>
</li>
<li><p>运算符 </p>
<ul>
<li>C++提供了丰富的运算符</li>
<li>运算符的含义：取决于操作数的类型，当操作数为基本数据类型时，C++定义了运算符的运算规则；对于自定义数据类型，C++支持运算符重载</li>
</ul>
</li>
<li><p>语言的输入输出</p>
<ul>
<li>标准输入设备：一般指的是键盘，用于向程序输入数据</li>
<li>标准输出设备：一般指显示器，用于显示程序的执行结果</li>
<li>C语言没有输入输出语句，而是<strong>使用库函数实现输入输出</strong>，基本输出库函数：putchar, printf 基本输入库函数：getchar, scanf</li>
<li>C++没有输入输出语句，而是使用<code>iostream</code>类库实现输入输出<ul>
<li>使用<code>iostream</code>库中标准输入流对象<code>cin</code>， 实现从键盘读取数据</li>
<li>使用<code>iostream</code>库中标准输出流对象<code>cout</code>, 将数据输出到屏幕上</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_03_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-C++_03_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_03_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-C++_03_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++_03_2_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++函数常用函数</li>
</ul>
<h2 id="C-std-isnan-函数-详解"><a href="#C-std-isnan-函数-详解" class="headerlink" title="C++ std::isnan() 函数 详解"></a>C++ std::isnan() 函数 详解</h2><p><code>std::isnan()</code> 是 C++ 标准库中的一个函数，用于检查一个浮点数是否为 NaN（Not a Number）。</p>
<p>NaN 是 IEEE 浮点数表示中的一个特殊值，它通常表示一个未定义或不可表示的结果，比如 0&#x2F;0 的结果或者负数的平方根。NaN 的特点是无法与任何其他浮点数进行比较，包括它自己，因此检查一个值是否为 NaN 是很有用的。</p>
<p><code>std::isnan()</code> 函数的声明位于 <code>&lt;cmath&gt;</code> 头文件中，并且提供了重载版本以支持不同的浮点类型。常见的版本有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isnan</span><span class="params">(<span class="type">float</span> arg)</span> <span class="keyword">noexcept</span></span>;       <span class="comment">// 检查 float 是否为 NaN</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isnan</span><span class="params">(<span class="type">double</span> arg)</span> <span class="keyword">noexcept</span></span>;      <span class="comment">// 检查 double 是否为 NaN</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isnan</span><span class="params">(<span class="type">long</span> <span class="type">double</span> arg)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 检查 long double 是否为 NaN</span></span><br></pre></td></tr></table></figure>

<p>函数接受一个浮点数作为参数，并返回一个布尔值，表示参数是否为 NaN。如果参数是 NaN，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> nanValue = std::<span class="built_in">nan</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">double</span> normalValue = <span class="number">42.0</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::boolalpha; <span class="comment">// 以布尔形式输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is nanValue NaN? &quot;</span> &lt;&lt; std::<span class="built_in">isnan</span>(nanValue) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is normalValue NaN? &quot;</span> &lt;&lt; std::<span class="built_in">isnan</span>(normalValue) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::nan(&quot;&quot;)</code> 创建了一个 NaN 值的双精度浮点数。然后通过 <code>std::isnan()</code> 函数检查这个值，以及一个普通的值是否为 NaN，并输出结果。</p>
<h2 id="std-ostringstream-详解"><a href="#std-ostringstream-详解" class="headerlink" title="std::ostringstream 详解"></a>std::ostringstream 详解</h2><p><code>std::ostringstream</code> 是 C++ 标准库中的一个类，位于 <code>&lt;sstream&gt;</code> 头文件中，用于在内存中创建和操作字符串。它是 <code>std::ostream</code> 的子类，因此可以使用类似于输出流的方式将数据写入其中，但数据将被存储为字符串。</p>
<p><code>std::ostringstream</code> 主要用于构建动态生成的字符串，例如将不同类型的数据（如整数、浮点数、字符串等）格式化为一个字符串。</p>
<p>以下是关于 <code>std::ostringstream</code> 的详细说明：</p>
<ol>
<li><p><strong>创建对象：</strong> 可以通过以下方式创建 <code>std::ostringstream</code> 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::ostringstream oss;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>写入数据：</strong> <code>std::ostringstream</code> 提供了与输出流类似的操作符，可以用于将不同类型的数据写入流中。常用的操作符有 <code>&lt;&lt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">std::string name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;Number: &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;, Pi: &quot;</span> &lt;&lt; pi &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取字符串：</strong> 使用 <code>std::ostringstream</code> 后，可以通过调用 <code>.str()</code> 成员函数来获取内部存储的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string result = oss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>清除内容：</strong> 调用 <code>std::ostringstream</code> 对象的 <code>.str(&quot;&quot;)</code> 成员函数可以清除流中的内容，重新使用该流。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 清除内容</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;New content.&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>格式化输出：</strong> 可以使用格式化操作来控制输出的样式。比如使用 <code>std::setw()</code> 来设置输出字段的宽度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = <span class="number">123</span>;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; value;</span><br><span class="line"><span class="comment">// 输出：&quot;Value: 000123&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常处理：</strong> 与流操作类似，<code>std::ostringstream</code> 也可以引发异常，如格式错误或其他问题。可以使用 <code>.good()</code>、<code>.eof()</code>、<code>.fail()</code> 等成员函数来检查流的状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!oss.<span class="built_in">good</span>()) &#123;</span><br><span class="line">    <span class="comment">// 处理流异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>std::ostringstream</code> 是一个强大的工具，用于将不同类型的数据格式化为字符串，以便于输出、日志记录等任务。它适用于需要在内存中操作字符串数据而不直接写入文件或输出流的情况。</p>
<h2 id="std-clamp"><a href="#std-clamp" class="headerlink" title="std::clamp()"></a>std::clamp()</h2><p><code>std::clamp()</code> 是 C++17 标准引入的一个函数，用于限制一个值的范围。它的目的是将一个值夹在指定的最小值和最大值之间，如果它小于最小值，就返回最小值，如果它大于最大值，就返回最大值。这个函数非常有用，因为它可以帮助你确保一个值不会越界。</p>
<p><code>std::clamp()</code> 的函数签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> T&amp; <span class="title">clamp</span><span class="params">(<span class="type">const</span> T&amp; value, <span class="type">const</span> T&amp; lo, <span class="type">const</span> T&amp; hi)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数有三个参数：</p>
<ol>
<li><code>value</code>：要限制范围的值。</li>
<li><code>lo</code>：最小值。</li>
<li><code>hi</code>：最大值。</li>
</ol>
<p>函数会返回一个与 <code>value</code> 具有相同类型的值，它会被夹在 <code>lo</code> 和 <code>hi</code> 之间。如果 <code>value</code> 小于 <code>lo</code>，则返回 <code>lo</code>；如果 <code>value</code> 大于 <code>hi</code>，则返回 <code>hi</code>；否则，返回 <code>value</code> 本身。</p>
<p>下面是一个示例，演示了如何使用 <code>std::clamp()</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> min_val = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> max_val = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> result = std::<span class="built_in">clamp</span>(value, min_val, max_val);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Clamped value: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>value</code> 的值为 5，<code>min_val</code> 和 <code>max_val</code> 分别是 1 和 10。<code>std::clamp()</code> 函数将 <code>value</code> 夹在 <code>min_val</code> 和 <code>max_val</code> 之间，因此 <code>result</code> 的值将是 5，因为它在指定的范围内。</p>
<p><code>std::clamp()</code> 函数的参数类型可以是任何支持比较运算符的类型，例如整数、浮点数、字符等。这个函数是一种很方便的方法，用于确保值在指定的范围内，而不需要编写额外的条件语句来进行检查和修正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_03_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-C++_03_1_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_03_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-C++_03_1_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++_03_1_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++函数常用函数</li>
</ul>
<h2 id="std-remove"><a href="#std-remove" class="headerlink" title="std::remove"></a>std::remove</h2><ul>
<li><p>简介：</p>
<ul>
<li>C++11中的std::remove函数属于标准库的文件操作函数，用于删除指定的文件</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>filename：要删除的文件的路径（C风格的字符串）</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果文件成功删除，则返回0。</li>
<li>如果删除文件失败，则返回非零值</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>std::remove函数用于删除指定的文件。它将指定的文件路径作为参数，并尝试将文件从文件系统中永久删除。如果文件删除成功，返回值为0，否则返回非零值</li>
<li>std::remove函数不会将文件移动到回收站，而是直接从文件系统中删除文件</li>
<li>如果要删除的文件不存在或无法删除，则会返回非零值，可以通过检查返回值来判断删除操作是否成功</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;/path/to/file.txt&quot;</span>; <span class="comment">// 指定文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">remove</span>(filename) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to delete file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File deleted: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上述示例中，我们使用std::remove函数来删除指定路径的文件。我们传递要删除的文件路径作为参数，并检查返回值是否为0来确定是否删除成功</li>
<li>请注意，std::remove函数只能删除文件，不能删除目录。如果要删除目录及其内容，您可以使用其他方法，例如递归删除目录中的所有文件，然后再删除空的目录</li>
</ul>
</li>
</ul>
<hr>
<h2 id="statvfs"><a href="#statvfs" class="headerlink" title="statvfs"></a>statvfs</h2><ul>
<li><p>简介：</p>
<ul>
<li>statvfs() 是一个Linux系统调用函数，用于获取文件系统的相关信息</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">statvfs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> statvfs *buf)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>statvfs() 函数接受两个参数：path 是文件系统路径名，buf 是指向 struct statvfs 结构的指针，用于存储文件系统信息</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>struct statvfs 结构包含了多个字段，提供了关于文件系统的各种属性。下面是 struct statvfs 的定义：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">statvfs</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_bsize;    <span class="comment">/* 文件系统块大小 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_frsize;   <span class="comment">/* 文件系统的基本块大小 */</span></span><br><span class="line">    <span class="type">fsblkcnt_t</span>    f_blocks;   <span class="comment">/* 文件系统总块数 */</span></span><br><span class="line">    <span class="type">fsblkcnt_t</span>    f_bfree;    <span class="comment">/* 文件系统空闲块数 */</span></span><br><span class="line">    <span class="type">fsblkcnt_t</span>    f_bavail;   <span class="comment">/* 非超级用户可用块数 */</span></span><br><span class="line">    <span class="type">fsfilcnt_t</span>    f_files;    <span class="comment">/* 文件系统节点数 */</span></span><br><span class="line">    <span class="type">fsfilcnt_t</span>    f_ffree;    <span class="comment">/* 文件系统空闲节点数 */</span></span><br><span class="line">    <span class="type">fsfilcnt_t</span>    f_favail;   <span class="comment">/* 非超级用户可用节点数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_fsid;     <span class="comment">/* 文件系统标识符 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_flag;     <span class="comment">/* 挂载标志 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_namemax;  <span class="comment">/* 最大文件名长度 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>常用字段解释：</p>
<ul>
<li>f_bsize：文件系统块的大小（字节）</li>
<li>f_frsize：文件系统的基本块大小（字节）</li>
<li>f_blocks：文件系统的总块数</li>
<li>f_bfree：文件系统的空闲块数</li>
<li>f_bavail：非超级用户可用的块数</li>
<li>f_files：文件系统的节点（文件）数</li>
<li>f_ffree：文件系统的空闲节点数</li>
<li>f_favail：非超级用户可用的节点数</li>
<li>f_fsid：文件系统标识符</li>
<li>f_flag：文件系统的挂载标志</li>
<li>f_namemax：文件系统支持的最大文件名长度</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>通过调用 statvfs() 函数并传递文件系统路径名和一个 struct statvfs 结构指针，可以获取与指定文件系统相关的各种信息。如果函数调用成功，返回值为 0，否则返回值为 -1，表示失败。在失败的情况下，可以使用 errno 来获取具体的错误码</li>
<li>使用 statvfs() 函数，您可以获取文件系统的块大小、总空间、可用空间、文件节点数等信息，以便进行磁盘空间管理和监控等操作</li>
</ul>
</li>
</ul>
<h2 id="sysinfo"><a href="#sysinfo" class="headerlink" title="sysinfo"></a>sysinfo</h2><ul>
<li><p>简介：</p>
<ul>
<li>sysinfo() 函数是一个系统调用，用于获取关于系统整体状态的信息，包括内存使用情况、负载信息、运行时间等。它位于 &lt;sys&#x2F;sysinfo.h&gt; 头文件中</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *info)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>详解：</p>
<ul>
<li>该函数接受一个指向 sysinfo 结构的指针作为参数，并将系统信息填充到该结构中。sysinfo 结构定义如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sysinfo</span> &#123;</span><br><span class="line">    <span class="type">long</span> uptime;             <span class="comment">// 系统运行时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> loads[<span class="number">3</span>];  <span class="comment">// 1分钟、5分钟、15分钟的负载平均值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> totalram;  <span class="comment">// 总内存大小（字节）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> freeram;   <span class="comment">// 可用内存大小（字节）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sharedram; <span class="comment">// 共享内存大小（字节）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bufferram; <span class="comment">// 缓冲区大小（字节）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> totalswap; <span class="comment">// 总交换空间大小（字节）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> freeswap;  <span class="comment">// 可用交换空间大小（字节）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> procs;    <span class="comment">// 进程数量</span></span><br><span class="line">    <span class="type">char</span> _f[<span class="number">22</span>];             <span class="comment">// 保留字段，不使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>sysinfo() 函数将系统的状态信息填充到传入的 sysinfo 结构中，然后返回 0 表示成功，-1 表示失败</li>
</ul>
</li>
<li><p>详解-2：</p>
<ul>
<li>通过调用 sysinfo() 函数并传入一个 sysinfo 结构的指针，可以获取系统的各种信息，如系统运行时间、负载平均值、内存使用情况等。在获取内存信息时，可以使用 totalram 字段获取总内存大小，freeram 字段获取可用内存大小</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sysinfo</span> sys_info;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sysinfo</span>(&amp;sys_info) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> total_memory = sys_info.totalram;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> free_memory = sys_info.freeram;</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Total Memory: &quot;</span> &lt;&lt; total_memory &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Free Memory: &quot;</span> &lt;&lt; free_memory &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to retrieve system memory information.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>请注意，sysinfo() 函数返回的内存大小是以字节为单位的整数值。如果需要以更友好的方式显示内存大小（如以MB或GB为单位），可以进行相应的单位转换操作。</li>
</ul>
</li>
</ul>
<h2 id="prctl"><a href="#prctl" class="headerlink" title="prctl"></a>prctl</h2><ul>
<li><p>简介：</p>
<ul>
<li>prctl() 是一个 Linux 系统调用函数，用于控制进程的各种属性和行为。它可以用于获取和修改进程的运行时属性，包括名称、资源限制、父子关系、信号处理等</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prctl</span><span class="params">(<span class="type">int</span> option, <span class="type">unsigned</span> <span class="type">long</span> arg2, <span class="type">unsigned</span> <span class="type">long</span> arg3, <span class="type">unsigned</span> <span class="type">long</span> arg4, <span class="type">unsigned</span> <span class="type">long</span> arg5)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>prctl() 函数的第一个参数 option 用于指定要执行的操作</li>
<li>后面的参数 arg2、arg3、arg4、arg5 则是与特定操作相关的参数。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>PR_SET_NAME：设置进程名称。</li>
<li>PR_GET_NAME：获取进程名称。</li>
<li>PR_SET_PDEATHSIG：设置子进程在父进程终止时接收的信号。</li>
<li>PR_SET_CHILD_SUBREAPER：设置进程为子进程的子进程收割器。</li>
<li>PR_GET_CHILD_SUBREAPER：检查进程是否是子进程的子进程收割器</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* processName = <span class="string">&quot;MyProcess&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prctl</span>(PR_SET_NAME, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;(processName), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to set process name&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prctl</span>(PR_GET_NAME, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;(buffer), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to get process name&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Process name: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上面的示例中，我们首先使用 prctl() 函数将进程的名称设置为 “MyProcess”。然后，我们使用 prctl() 函数的 PR_GET_NAME 参数获取进程的名称，并将其输出到控制台</li>
<li>需要注意的是，prctl() 函数的具体操作和参数在不同的操作系统版本和架构上可能会有所不同。因此，在使用 prctl() 函数时，建议参考相关的文档和系统头文件以了解特定操作和参数的正确使用方式</li>
</ul>
</li>
</ul>
<h2 id="pthread-setname-np"><a href="#pthread-setname-np" class="headerlink" title="pthread_setname_np"></a>pthread_setname_np</h2><ul>
<li><p>简介：</p>
<ul>
<li>pthread_setname_np() 是一个非标准的 POSIX 函数，用于设置 POSIX 线程的名称。它允许你为线程分配一个描述性的名称，以便在调试和跟踪应用程序时更容易地识别不同的线程</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setname_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>pthread_setname_np() 函数的第一个参数是要设置名称的线程标识符 thread</li>
<li>第二个参数是要分配给线程的名称字符串 name</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunction</span><span class="params">(<span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 线程执行的任务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* threadName = <span class="string">&quot;MyThread&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">nullptr</span>, threadFunction, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程名称</span></span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(thread, threadName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程执行的任务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上面的示例中，我们首先创建了一个线程 thread，然后使用 pthread_setname_np() 函数将其名称设置为 “MyThread”。</li>
<li>需要注意的是，pthread_setname_np() 函数是非标准的，它可能在不同的操作系统和实现中有所差异。在某些平台上，可能需要添加一些特定的宏定义或包含其他头文件来使用该函数。</li>
<li>此外，pthread_setname_np() 函数仅用于 POSIX 线程，不能用于其他类型的线程，如 Windows 线程</li>
</ul>
</li>
</ul>
<h2 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h2><ul>
<li><p>简介：</p>
<ul>
<li>signal() 是一个 C 标准库函数，用于捕捉和处理信号。信号是在操作系统中用于通知进程发生某个事件的机制</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*<span class="built_in">signal</span>(<span class="type">int</span> signum, <span class="built_in">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>signum：一个整数，表示要捕捉的信号的编号。常见的信号包括 SIGINT（中断信号）和 SIGTERM（终止信号），还有其他许多可用的信号。</li>
<li>handler：一个函数指针，指向一个处理信号的函数。函数的类型为 void (*)(int)，它接受一个整数作为参数，并返回 void</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回一个函数指针，指向以前与 signum 相关联的信号处理函数。如果以前没有设置过信号处理函数，则返回 SIG_DFL（默认信号处理）或 SIG_IGN（忽略信号）</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>signal() 函数用于为指定的信号 signum 设置信号处理函数 handler。</li>
<li>要使用 signal() 函数，需要包含头文件 &lt;signal.h&gt;。</li>
<li>通过设置信号处理函数，可以在程序中对特定的信号做出相应的操作，例如捕捉 SIGINT 信号以处理用户中断操作。</li>
<li>当进程接收到指定的信号时，系统将调用与之相关联的信号处理函数来处理该信号。</li>
<li>信号处理函数可以是用户自定义的函数，用于执行特定的操作，或者可以是 SIG_DFL（默认信号处理）或 SIG_IGN（忽略信号）。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigintHandler</span><span class="params">(<span class="type">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received SIGINT signal. Exiting...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 在此处执行清理操作或其他必要的处理</span></span><br><span class="line">    <span class="comment">// 例如关闭文件、释放资源等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出程序</span></span><br><span class="line">    <span class="built_in">exit</span>(signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 SIGINT 信号的处理函数为 sigintHandler</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sigintHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 在此处执行主要的程序逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在此示例中，我们定义了一个名为 sigintHandler() 的信号处理函数，用于处理 SIGINT 信号（通常是通过键盘输入 Ctrl+C 产生的）。在 main() 函数中，我们使用 signal() 函数将 SIGINT 信号与 sigintHandler() 函数关联起来。当程序接收到 SIGINT 信号时，将调用 sigintHandler() 函数来处理该信号，并在处理函数中执行相应的操作。在此示例中，我们简单地打印一条消息并退出程序</li>
</ul>
</li>
</ul>
<hr>
<h2 id="setpriority"><a href="#setpriority" class="headerlink" title="setpriority"></a>setpriority</h2><ul>
<li><p>简介：</p>
<ul>
<li>setpriority() 是一个 C 标准库函数，用于设置进程的调度优先级。通过调整进程的调度优先级，可以影响操作系统对进程的调度顺序</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who, <span class="type">int</span> prio)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>which：一个整数，指定要设置优先级的对象。可取以下值<ul>
<li>PRIO_PROCESS：设置进程的优先级。</li>
<li>PRIO_PGRP：设置进程组的优先级。</li>
<li>PRIO_USER：设置用户的所有进程的优先级</li>
</ul>
</li>
<li>who：一个整数，表示要设置优先级的对象的标识符。根据 which 参数的取值，可有不同的解释：<ul>
<li>当 which 为 PRIO_PROCESS 时，who 是进程ID（PID）。</li>
<li>当 which 为 PRIO_PGRP 时，who 是进程组ID（PGID）。</li>
<li>当 which 为 PRIO_USER 时，who 是用户ID（UID）</li>
</ul>
</li>
<li>prio：一个整数，表示要设置的优先级。优先级的范围通常是 -20 到 19，其中 -20 表示最高优先级，19 表示最低优先级。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回 -1，并设置 errno 变量表示错误的原因</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>setpriority() 函数用于设置进程的调度优先级。</li>
<li>要使用 setpriority() 函数，需要包含头文件 &lt;sys&#x2F;time.h&gt; 和 &lt;sys&#x2F;resource.h&gt;。</li>
<li>进程的调度优先级影响了操作系统对进程的调度顺序。更高的优先级意味着进程更有可能被操作系统选择进行执行。</li>
<li>setpriority() 函数需要适当的权限来设置进程的优先级。通常，只有超级用户（root）或具有特权的用户才能更改其他进程的优先级。</li>
<li>可以使用 getpriority() 函数来获取进程的当前优先级。</li>
<li>设置进程的优先级可能会受到操作系统和调度器的限制，具体的行为可能因操作系统的实现而异</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前进程ID</span></span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="built_in">getpid</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置进程的优先级为最高优先级</span></span><br><span class="line">    <span class="type">int</span> priority = <span class="number">-20</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">setpriority</span>(PRIO_PROCESS, pid, priority);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setpriority&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process priority set to %d\n&quot;</span>, priority);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在此示例中，我们使用 setpriority() 函数将当前进程的优先级设置为最高优先级（-20）。请注意，设置进程的优先级可能需要适当的权限，并且对于不同的操作系统和调度器，行为可能会有所不同。因此，具体的效果和行为可能因系统而异</li>
</ul>
</li>
</ul>
<h2 id="std-uniform-int-distribution"><a href="#std-uniform-int-distribution" class="headerlink" title="std::uniform_int_distribution"></a>std::uniform_int_distribution</h2><p><code>std::uniform_int_distribution</code>是C++标准库中的一个分布类，用于生成指定范围内的均匀分布的整数随机数。</p>
<p>以下是一些关键点来详细解释<code>std::uniform_int_distribution</code>的用法和特性：</p>
<ol>
<li><p><code>std::uniform_int_distribution</code>的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">uniform_int_distribution</span><span class="params">(IntType a = <span class="number">0</span>, IntType b = std::numeric_limits&lt;IntType&gt;::max())</span></span>;</span><br></pre></td></tr></table></figure>
<p>构造一个<code>std::uniform_int_distribution</code>对象。参数<code>a</code>和<code>b</code>用于指定生成随机数的范围，生成的随机数将包含<code>a</code>和<code>b</code>。</p>
</li>
<li><p><code>std::uniform_int_distribution</code>的成员函数<code>operator()()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">(Engine&amp; eng)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过调用<code>operator()</code>函数，可以生成一个随机数。需要提供一个随机数引擎对象<code>eng</code>作为参数，该引擎将用于生成随机数。</p>
</li>
<li><p><code>std::uniform_int_distribution</code>的成员函数<code>param()</code>和<code>param(const param_type&amp; parm)</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">param_type <span class="title">param</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">param</span><span class="params">(<span class="type">const</span> param_type&amp; parm)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>param()</code>函数用于获取当前分布对象的参数，即范围的上下界。<code>param(const param_type&amp; parm)</code>函数用于设置分布对象的参数。</p>
</li>
<li><p><code>std::uniform_int_distribution</code>对象的用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::random_device rd;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rng</span><span class="params">(rd())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> randomNumber = <span class="built_in">dist</span>(rng);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Random number: &quot;</span> &lt;&lt; randomNumber &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，首先创建一个<code>std::random_device</code>对象<code>rd</code>用于获取随机种子。然后，创建一个<code>std::mt19937</code>对象<code>rng</code>作为随机数引擎。接下来，创建一个<code>std::uniform_int_distribution&lt;int&gt;</code>对象<code>dist</code>，表示生成1到10之间（包括1和10）的整数随机数。最后，通过在循环中调用<code>dist(rng)</code>生成随机数，并将其打印输出。</p>
</li>
</ol>
<p><code>std::uniform_int_distribution</code>用于生成均匀分布的整数随机数，确保生成的随机数在指定范围内的分布是均匀的。它通常与随机数引擎（如<code>std::mt19937</code>）配合使用，可以满足许多随机数生成的需求。</p>
<h2 id="std-mt19937"><a href="#std-mt19937" class="headerlink" title="std::mt19937"></a>std::mt19937</h2><p><code>std::mt19937</code>是C++标准库中的一个随机数引擎类，用于生成高质量的伪随机数序列。它基于梅森旋转算法（Mersenne Twister）实现，并且具有良好的随机性和周期性。</p>
<p>以下是一些关键点来详细解释<code>std::mt19937</code>的用法和特性：</p>
<ol>
<li><p><code>std::mt19937</code>的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">mt19937</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">mt19937</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Sseq</span>&gt; <span class="function"><span class="keyword">explicit</span> <span class="title">mt19937</span><span class="params">(Sseq&amp; q)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>std::mt19937</code>提供了几种不同的构造函数。默认构造函数会使用默认的种子值初始化随机数引擎。第二个构造函数接受一个无符号整数作为种子值。第三个构造函数接受一个序列生成器对象作为参数，并使用该序列生成器生成种子序列。</p>
</li>
<li><p><code>std::mt19937</code>的成员函数<code>operator()()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过调用<code>operator()</code>函数，可以生成一个随机数。返回的随机数的类型由<code>result_type</code>定义。</p>
</li>
<li><p><code>std::mt19937</code>的成员函数<code>seed()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">seed</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过调用<code>seed()</code>函数，可以重新设置随机数引擎的种子值。</p>
</li>
<li><p><code>std::mt19937</code>的成员函数<code>discard()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">discard</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> z)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>discard()</code>函数用于丢弃指定数量的随机数。这在某些情况下可以用于跳过初始的随机数，以获得更随机的序列。</p>
</li>
<li><p><code>std::mt19937</code>对象的用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::mt19937 rng;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置种子值</span></span><br><span class="line">    rng.<span class="built_in">seed</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机数</span></span><br><span class="line">    <span class="type">int</span> randomNumber = <span class="built_in">rng</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Random number: &quot;</span> &lt;&lt; randomNumber &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，首先创建一个<code>std::mt19937</code>对象<code>rng</code>。然后，通过调用<code>rng.seed()</code>来设置种子值，这里使用了常数值42作为种子。最后，通过调用<code>rng()</code>生成一个随机数，并将其打印输出。</p>
</li>
</ol>
<p><code>std::mt19937</code>是一个高质量的随机数引擎，通常比<code>std::rand()</code>等传统的随机数生成函数产生更好的随机数。它在C++11标准中被引入，用于替代了旧的随机数引擎。</p>
<h2 id="std-random-device"><a href="#std-random-device" class="headerlink" title="std::random_device"></a>std::random_device</h2><p><code>std::random_device</code>是C++标准库中的一个类，用于生成真正的随机数。它是一个非确定性随机数生成器，通常通过操作系统提供的熵源来获取随机数。</p>
<p><code>std::random_device</code>类定义在头文件 <code>&lt;random&gt;</code> 中，用于产生高质量的随机数，适用于密码学、模拟和其他需要真正随机性的应用场景。</p>
<p>以下是一些关键点来详细解释<code>std::random_device</code>的用法和特性：</p>
<ol>
<li><p><code>std::random_device</code>的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">random_device</span><span class="params">(<span class="type">const</span> string&amp; token = implementation-defined)</span></span>;</span><br></pre></td></tr></table></figure>
<p>构造一个<code>std::random_device</code>对象。可选的<code>token</code>参数用于指定特定的随机数生成器实现。</p>
</li>
<li><p><code>std::random_device</code>的成员函数<code>operator()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过调用<code>operator()</code>函数，可以生成一个随机数。返回的随机数的类型由<code>result_type</code>定义。</p>
</li>
<li><p><code>std::random_device</code>的成员函数<code>entropy()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">result_type <span class="title">entropy</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回随机数生成器的熵值，表示生成的随机数的质量。如果熵值为0，表示随机数生成器没有可用的熵源。</p>
</li>
<li><p><code>std::random_device</code>对象的用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::random_device rd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个随机数</span></span><br><span class="line">    <span class="type">int</span> randomNumber = <span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Random number: &quot;</span> &lt;&lt; randomNumber &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Entropy: &quot;</span> &lt;&lt; rd.<span class="built_in">entropy</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，首先创建一个<code>std::random_device</code>对象<code>rd</code>。然后，通过调用<code>rd()</code>来生成一个随机数，并将其打印输出。最后，使用<code>rd.entropy()</code>获取熵值，并将其打印输出。</p>
</li>
</ol>
<p>需要注意的是，由于<code>std::random_device</code>是非确定性的，它可能会依赖于操作系统的随机数生成器实现。因此，不同的操作系统和编译器可能会有不同的行为。在某些情况下，<code>std::random_device</code>可能返回伪随机数，而不是真正的随机数。如果您需要高质量的随机数，请考虑使用其他的随机数生成器，如<code>std::mt19937</code>。</p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>在C++中，<code>std::move()</code>是一个函数模板，位于<code>&lt;utility&gt;</code>头文件中。它用于将对象的状态从一个对象转移到另一个对象，通常用于实现高效的移动语义。</p>
<p><code>std::move()</code>函数将给定的对象转换为右值引用，使得可以使用移动语义来操作该对象。移动语义是C++11引入的一个重要特性，允许在对象转移所有权时避免不必要的复制操作，提高性能。</p>
<p>以下是<code>std::move()</code>函数的一般语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">move</span>(argument);</span><br></pre></td></tr></table></figure>

<p>其中，<code>argument</code>是要移动的对象。</p>
<p>使用<code>std::move()</code>函数的主要目的是将对象的状态从一个对象转移到另一个对象，而不进行深拷贝操作。这对于移动构造函数和移动赋值运算符非常有用，可以显著提高对象的性能。</p>
<p>以下是<code>std::move()</code>函数的一些常见用法：</p>
<ol>
<li><p>移动语义的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">MyClass</span>(MyClass&amp;&amp; other) : <span class="built_in">data</span>(std::<span class="built_in">move</span>(other.data)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动赋值运算符</span></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) &#123;</span><br><span class="line">    data = std::<span class="built_in">move</span>(other.data);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在移动构造函数和移动赋值运算符中，通过使用<code>std::move()</code>函数，将数据从一个对象移动到另一个对象，避免了不必要的复制。</p>
</li>
<li><p>传递参数的移动语义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp;&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对移动后的data进行操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">processData</span>(std::<span class="built_in">move</span>(vec));</span><br></pre></td></tr></table></figure>

<p>在此示例中，通过使用<code>std::move()</code>函数，将<code>vec</code>对象转换为右值引用，并将其作为参数传递给<code>processData()</code>函数。这样可以避免不必要的拷贝操作。</p>
</li>
</ol>
<p>需要注意的是，<code>std::move()</code>函数只是将对象转换为右值引用，本身并不进行实际的数据移动。实际的移动操作需要由移动构造函数或移动赋值运算符来实现。</p>
<p>使用<code>std::move()</code>函数需要谨慎操作，确保正确处理移动后的对象状态，避免悬空引用和使用已经移动的对象。</p>
<h2 id="std-localtime"><a href="#std-localtime" class="headerlink" title="std::localtime"></a>std::localtime</h2><ul>
<li><p>简介：</p>
<ul>
<li>std::localtime() 是 C++ 标准库中的一个函数，用于将时间值（通常是由 std::time() 函数获得的时间戳）转换为本地时间的结构</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tm* <span class="title">std::localtime</span><span class="params">(<span class="type">const</span> std::<span class="type">time_t</span>* timePtr)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>timePtr：一个指向 std::time_t 类型变量的指针，表示要转换为本地时间的时间值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果成功转换为本地时间，则返回一个指向 std::tm 结构的指针，其中包含了年、月、日、时、分、秒等时间信息</li>
<li>如果转换失败或 timePtr 为 nullptr，则返回 nullptr</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>std::tm 结构包含了以下成员：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">// 秒 (0 ~ 59)</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">// 分 (0 ~ 59)</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">// 小时 (0 ~ 23)</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">// 一个月的日期 (1 ~ 31)</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">// 月份 (0 ~ 11，0 表示 1 月)</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">// 年份 (自 1900 年起)</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">// 一周的日期 (0 ~ 6，0 表示星期日)</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">// 一年的日期 (0 ~ 365，0 表示 1 月 1 日)</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// 夏令时标识符 (-1 表示不确定，0 表示不使用夏令时，&gt;0 表示使用夏令时)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="type">time_t</span> currentTime = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    std::tm* localTime = std::<span class="built_in">localtime</span>(&amp;currentTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localTime != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;本地时间：&quot;</span> &lt;&lt; localTime-&gt;tm_year + <span class="number">1900</span> &lt;&lt; <span class="string">&quot;-&quot;</span></span><br><span class="line">                  &lt;&lt; localTime-&gt;tm_mon + <span class="number">1</span> &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; localTime-&gt;tm_mday</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; localTime-&gt;tm_hour &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">                  &lt;&lt; localTime-&gt;tm_min &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; localTime-&gt;tm_sec &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换为本地时间失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上述示例中，我们使用 std::time() 函数获取当前的系统时间，并将其存储在 currentTime 变量中。然后，我们使用 std::localtime() 函数将 currentTime 转换为本地时间的 std::tm 结构，并将其存储在 localTime 指针中</li>
<li>我们可以通过访问 std::tm 结构的成员，如 tm_year、tm_mon、tm_mday 等，获取转换后的本地时间的年、月、日、小时、分钟和秒等信息</li>
<li>需要注意的是，std::localtime() 函数返回的指针指向一个静态分配的 std::tm 结构，因此在下一次调用 std::localtime() 之前应尽快使用转换后的时间信息</li>
</ul>
</li>
</ul>
<h2 id="std-time"><a href="#std-time" class="headerlink" title="std::time"></a>std::time</h2><ul>
<li><p>简介：</p>
<ul>
<li>std::time() 是 C++ 标准库中的一个函数，用于获取当前的系统时间</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::<span class="type">time_t</span> <span class="title">std::time</span><span class="params">(std::<span class="type">time_t</span>* timePtr)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>timePtr：一个指向 std::time_t 类型的变量的指针，用于存储获取的系统时间。可以为 nullptr，表示不存储时间值。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果成功获取系统时间，则返回一个 std::time_t 类型的值，表示自 1970 年 1 月 1 日以来的秒数（UTC 时间）</li>
<li>如果获取系统时间失败，则返回 -1</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="type">time_t</span> currentTime = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTime != <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前时间：&quot;</span> &lt;&lt; std::<span class="built_in">asctime</span>(std::<span class="built_in">localtime</span>(&amp;currentTime));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取系统时间失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上述示例中，我们使用 std::time() 函数获取当前的系统时间，并将其存储在 currentTime 变量中。然后，我们使用 std::localtime() 函数将 currentTime 转换为本地时间，并使用 std::asctime() 函数将本地时间转换为字符串格式进行输出</li>
<li>需要注意的是，std::time() 返回的时间是从 1970 年 1 月 1 日以来经过的秒数，也称为 UNIX 时间戳。为了方便使用和显示，可以使用其他时间处理函数将时间戳转换为可读的日期和时间格式</li>
<li>此外，std::time() 函数返回的时间精度可能取决于操作系统和实现。通常情况下，时间精度为秒级，但有些系统可能提供更高的精度</li>
</ul>
</li>
</ul>
<hr>
<h2 id="sched-yield"><a href="#sched-yield" class="headerlink" title="sched_yield"></a>sched_yield</h2><ul>
<li><p>简介：</p>
<ul>
<li>sched_yield() 函数是一个库函数，它允许一个正在运行的线程主动放弃 CPU 的使用权，从而使得其他可运行的线程有机会运行</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<ul>
<li>sched_yield() 函数没有参数，它的返回值为调用是否成功</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>sched_yield() 函数的作用是将当前线程移出调度器的运行队列，让其他具有相同或更高优先级的可运行线程有机会被调度和执行。简而言之，调用 sched_yield() 函数会主动让出 CPU，给其他线程执行的机会</li>
<li>sched_yield() 函数是一种协作式的调度机制。在使用 sched_yield() 之前，内核会保证当前线程在运行队列中是处于就绪状态的。调用 sched_yield() 后，内核会选择一个合适的线程来运行，具体的选择是由调度算法和线程的优先级决定的</li>
<li>sched_yield() 函数不能保证当前线程立即放弃 CPU 控制权，也不能保证其他线程立即运行。它仅仅是给其他线程运行的机会，具体的调度还是由内核来决定</li>
<li>sched_yield() 函数通常在以下情况下使用：<ul>
<li>当线程在忙碌运行一段时间后，如果没有更多的工作可以做，可以调用 sched_yield() 来让其他线程有机会运行，避免资源的浪费</li>
<li>在实现自旋锁或自旋等待时，可以使用 sched_yield() 来减小自旋的开销，避免过度消耗 CPU 资源</li>
</ul>
</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，sched_yield() 函数只对线程调度起到协作的作用，具体的调度策略和行为由内核来决定，并且在不同的操作系统和调度器中可能会有一些差异。因此，在实际使用中，需要谨慎考虑 sched_yield() 函数的使用时机和效果，并进行充分的测试和验证</li>
</ul>
</li>
</ul>
<h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><ul>
<li><p>简介：</p>
<ul>
<li>文件的定位操作可以使用 lseek() 函数，该函数可以将文件的当前位置指针移动到指定的位置</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fd：文件描述符，表示要进行定位操作的文件。</li>
<li>offset：偏移量，表示相对于 whence 参数指定位置的偏移量。</li>
<li>whence：定位基准位置，可以是以下值之一<ul>
<li>SEEK_SET：从文件开头开始计算偏移量</li>
<li>SEEK_CUR：从当前位置开始计算偏移量</li>
<li>SEEK_END：从文件末尾开始计算偏移量</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果成功，返回新的文件位置指针的偏移量</li>
<li>如果发生错误，返回值为 -1，并设置 errno 变量来指示具体的错误原因。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">off_t</span> offset = lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to move file pointer to the beginning&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在文件位置指针已经在文件开头，可以进行后续操作</span></span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上述示例中，我们使用 open() 函数打开文件，并使用 lseek() 函数将文件位置指针移动到文件开头。如果 lseek() 返回值为 -1，表示定位失败，我们可以使用 perror() 函数打印错误消息</li>
<li>需要注意的是，lseek() 函数在处理二进制文件或随机访问文件时非常有用。对于顺序读取文件的情况，可以使用更高级的文件读取函数，如 fseek() 和 rewind()</li>
</ul>
</li>
</ul>
<h2 id="tcflush"><a href="#tcflush" class="headerlink" title="tcflush"></a>tcflush</h2><ul>
<li><p>简介：</p>
<ul>
<li>tcflush()函数用于刷新串口输入输出缓冲区。它是与串口相关的函数，可用于清空或刷新串口的数据缓冲区</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcflush</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> queue_selector)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fd：文件描述符，表示要刷新的串口</li>
<li>queue_selector：刷新队列的选择器，可以是以下值之一<ul>
<li>TCIFLUSH：刷新输入队列，丢弃输入缓冲区中的数据</li>
<li>TCOFLUSH：刷新输出队列，丢弃输出缓冲区中的数据</li>
<li>TCIOFLUSH：刷新输入和输出队列，丢弃输入和输出缓冲区中的数据</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果刷新成功，返回值为0</li>
<li>如果刷新失败，返回值为-1，并设置errno变量以指示错误类型</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>使用tcflush()函数可以清空串口的输入和输出缓冲区，以便开始或终止数据传输之前进行必要的清理</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> serial_fd; <span class="comment">// 串口文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开串口并设置相关参数...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (tcflush(serial_fd, TCIFLUSH) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to flush input queue&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空输出缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (tcflush(serial_fd, TCOFLUSH) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to flush output queue&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Serial port input and output queues flushed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭串口...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上述示例中，我们首先打开串口并设置相关参数（未在示例中展示）。然后，我们使用tcflush()函数两次调用来分别清空输入和输出缓冲区。最后，我们关闭串口（未在示例中展示）</li>
<li>请注意，上述示例仅演示了刷新串口缓冲区的情况。在实际应用中，你可能还需要进行其他串口操作，如读取或写入数据等。同时，还要注意进行错误处理，以检查函数调用是否成功</li>
</ul>
</li>
</ul>
<h2 id="cfsetospeed"><a href="#cfsetospeed" class="headerlink" title="cfsetospeed"></a>cfsetospeed</h2><ul>
<li><p>简介：</p>
<ul>
<li>cfsetospeed() 函数用于设置串口设备的输出波特率。它是与串口相关的函数，用于配置串口的通信参数</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cfsetospeed</span><span class="params">(<span class="keyword">struct</span> termios *termios_p, <span class="type">speed_t</span> speed)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>termios_p：指向 termios 结构的指针，该结构包含了串口的配置参数</li>
<li>speed：要设置的输出波特率</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果设置成功，返回值为 0</li>
<li>如果设置失败，返回值为 -1，并设置 errno 变量以指示错误类型</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>使用 cfsetospeed() 函数时，通常需要先获取当前的串口配置参数，然后修改其中的输出波特率，最后将修改后的参数重新设置给串口</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">term</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前的串口配置参数</span></span><br><span class="line">    tcgetattr(STDOUT_FILENO, &amp;term);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置输出波特率为 9600</span></span><br><span class="line">    <span class="keyword">if</span> (cfsetospeed(&amp;term, B9600) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to set output baud rate&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将修改后的配置参数重新设置给串口</span></span><br><span class="line">    <span class="keyword">if</span> (tcsetattr(STDOUT_FILENO, TCSANOW, &amp;term) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to apply serial port settings&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Output baud rate set to 9600\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上述示例中，我们首先通过调用 tcgetattr() 函数获取当前的串口配置参数，并将其存储在 term 结构中。然后，我们使用 cfsetospeed() 函数将输出波特率设置为 9600。最后，我们调用 tcsetattr() 函数将修改后的配置参数重新应用到串口</li>
<li>请注意，上述示例仅演示了设置输出波特率的情况。如果你还需要设置输入波特率，可以使用类似的方法调用 cfsetispeed() 函数进行设置。同时，还要注意进行错误处理，以检查函数调用是否成功</li>
</ul>
</li>
</ul>
<h2 id="cfsetispeed"><a href="#cfsetispeed" class="headerlink" title="cfsetispeed"></a>cfsetispeed</h2><ul>
<li><p>简介：</p>
<ul>
<li>cfsetispeed() 函数用于设置串口设备的输入波特率。它是与串口相关的函数，用于配置串口的通信参数</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cfsetispeed</span><span class="params">(<span class="keyword">struct</span> termios *termios_p, <span class="type">speed_t</span> speed)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>termios_p：指向 termios 结构的指针，该结构包含了串口的配置参数</li>
<li>speed：要设置的输入波特率</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果设置成功，返回值为 0</li>
<li>如果设置失败，返回值为 -1，并设置 errno 变量以指示错误类型</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>使用 cfsetispeed() 函数时，通常需要先获取当前的串口配置参数，然后修改其中的输入波特率，最后将修改后的参数重新设置给串口</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">term</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前的串口配置参数</span></span><br><span class="line">    tcgetattr(STDIN_FILENO, &amp;term);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置输入波特率为 9600</span></span><br><span class="line">    <span class="keyword">if</span> (cfsetispeed(&amp;term, B9600) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to set input baud rate&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将修改后的配置参数重新设置给串口</span></span><br><span class="line">    <span class="keyword">if</span> (tcsetattr(STDIN_FILENO, TCSANOW, &amp;term) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to apply serial port settings&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input baud rate set to 9600\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上述示例中，我们首先通过调用 tcgetattr() 函数获取当前的串口配置参数，并将其存储在 term 结构中。然后，我们使用 cfsetispeed() 函数将输入波特率设置为 9600。最后，我们调用 tcsetattr() 函数将修改后的配置参数重新应用到串口</li>
<li>请注意，上述示例仅演示了设置输入波特率的情况。如果你还需要设置输出波特率，可以使用类似的方法调用 cfsetospeed() 函数进行设置。同时，还要注意进行错误处理，以检查函数调用是否成功</li>
</ul>
</li>
</ul>
<h2 id="tcgetattr"><a href="#tcgetattr" class="headerlink" title="tcgetattr"></a>tcgetattr</h2><ul>
<li><p>简介：</p>
<ul>
<li>tcgetattr() 是一个 C 函数，用于获取终端设备的属性。它用于读取终端设备的当前设置，并将这些设置存储在一个 termios 结构体中</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcgetattr</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> termios *termios_p)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fd：要获取属性的终端设备文件描述符。</li>
<li>termios_p：指向 termios 结构体的指针，用于存储终端设备的属性</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>tcgetattr() 函数会返回一个整数值，表示函数执行的结果。如果函数执行成功，则返回 0；否则，返回 -1，并设置相应的错误码</li>
</ul>
</li>
<li><p>详解</p>
<ul>
<li>使用 tcgetattr() 函数可以获取终端设备的属性，如输入输出模式、字符大小、超时设置等。可以通过修改 termios 结构体的成员来更改终端设备的属性，然后使用 tcsetattr() 函数将修改后的属性应用到终端设备上</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = STDIN_FILENO; <span class="comment">// 标准输入设备文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">term</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (tcgetattr(fd, &amp;term) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;tcgetattr&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印终端设备的属性</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input flags: %x\n&quot;</span>, term.c_iflag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Output flags: %x\n&quot;</span>, term.c_oflag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Control flags: %x\n&quot;</span>, term.c_cflag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Local flags: %x\n&quot;</span>, term.c_lflag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>这个示例程序获取标准输入设备的属性，并打印各个属性的值。</li>
</ul>
</li>
</ul>
<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><ul>
<li><p>简介：</p>
<ul>
<li>ioctl() 是一个系统调用函数，用于控制设备的操作，它在不同的设备和操作系统上有不同的功能和用法。在 C 语言中，可以使用 ioctl() 函数来发送命令给设备驱动程序，并执行特定的操作</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fd：文件描述符，用于指定要进行控制的设备</li>
<li>request：控制命令，是一个无符号长整型数值，用于指定具体的操作</li>
<li>…：可选参数，根据不同的控制命令可能需要提供额外的参数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>ioctl() 函数的返回值通常为 0 表示操作成功，-1 表示操作失败，并通过 errno 变量来获取具体的错误信息</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>要使用 ioctl() 函数，需要事先了解设备的控制命令和参数的定义。不同的设备和操作系统可能有不同的命令和参数定义，因此需要参考相关的文档或设备驱动程序的头文件来获取正确的命令和参数定义</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/ttyS0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open serial port&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">options</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (tcgetattr(fd, &amp;options) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to get serial port options&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cfsetispeed(&amp;options, B9600);</span><br><span class="line">    cfsetospeed(&amp;options, B9600);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcsetattr(fd, TCSANOW, &amp;options) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to set serial port options&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上述示例中，首先使用 open() 函数打开串口设备文件 &#x2F;dev&#x2F;ttyS0，然后使用 tcgetattr() 函数获取当前的串口设置</li>
<li>接下来使用 cfsetispeed() 和 cfsetospeed() 函数将输入和输出波特率设置为 9600。这里使用了波特率常量 B9600，具体的常量定义可以在 &lt;termios.h&gt; 头文件中找到</li>
<li>最后使用 tcsetattr() 函数将修改后的串口设置应用到设备上，并关闭文件描述符</li>
<li>这只是一个简单的示例，实际的 ioctl() 使用可能涉及更复杂的控制命令和参数，具体的用法和命令定义需要参考相关文档或设备驱动程序的说明</li>
</ul>
</li>
</ul>
<h2 id="ftruncate"><a href="#ftruncate" class="headerlink" title="ftruncate"></a>ftruncate</h2><ul>
<li><p>简介：</p>
<ul>
<li>ftruncate() 函数是 C&#x2F;C++ 中的一个文件操作函数，用于调整文件的大小</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fd：文件描述符，指定要操作的文件。</li>
<li>length：要设置的新文件大小</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>函数功能：<ul>
<li>如果文件当前的大小大于指定的 length，则文件将被截断到指定的大小。</li>
<li>如果文件当前的大小小于指定的 length，则文件将被扩展到指定的大小，并使用空字节填充扩展的部分。</li>
<li>如果文件当前的大小等于指定的 length，则文件大小保持不变</li>
</ul>
</li>
<li>返回值<ul>
<li>如果调用成功，返回值为 0。</li>
<li>如果调用失败，返回值为 -1，并设置相应的错误码，可以通过 errno 全局变量获取具体的错误信息。</li>
</ul>
</li>
<li>使用 ftruncate() 函数需要先打开文件，获取文件描述符 fd，然后调用该函数即可。请确保在使用该函数时具有足够的权限来修改文件大小</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(filename, O_RDWR | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> new_size = <span class="number">1024</span>;  <span class="comment">// New file size in bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ftruncate</span>(fd, new_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to truncate file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File size adjusted successfully&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述代码打开名为 “example.txt” 的文件，将其大小调整为 1024 字节。如果调用成功，将输出 “File size adjusted successfully”。否则，将输出相应的错误信息</li>
<li>请注意，使用 ftruncate() 函数时应格外谨慎，确保操作的文件和大小设置是正确的，以免意外丢失数据</li>
</ul>
</li>
</ul>
<h2 id="shm-unlink"><a href="#shm-unlink" class="headerlink" title="shm_unlink"></a>shm_unlink</h2><ul>
<li><p>简介：</p>
<ul>
<li>shm_unlink() 函数用于解除与共享内存对象的链接，并将其标记为待删除状态。具体来说，shm_unlink() 函数的作用是删除共享内存对象的名字，但并不立即释放共享内存资源，只有当所有打开该共享内存对象的文件描述符都关闭时，才会释放共享内存资源</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shm_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>参数 name 是共享内存对象的名字，通过该名字可以标识和访问共享内存对象。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>调用 shm_unlink() 函数后，如果成功解除链接并标记为删除，函数返回 0；如果发生错误，返回 -1，并设置对应的错误码</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* shm_name = <span class="string">&quot;/my_shared_memory&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开共享内存对象</span></span><br><span class="line">    <span class="type">int</span> shm_fd = <span class="built_in">shm_open</span>(shm_name, O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除链接并标记为删除</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">shm_unlink</span>(shm_name);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭共享内存对象</span></span><br><span class="line">    <span class="built_in">close</span>(shm_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上述示例中，我们通过 shm_open() 打开了一个共享内存对象，然后调用 shm_unlink() 解除与该对象的链接并标记为删除。最后，通过 close() 关闭了共享内存对象的文件描述符</li>
<li>需要注意的是，只有当所有打开共享内存对象的进程都解除链接后，该共享内存对象才会被真正删除。因此，在使用 shm_unlink() 函数时需要确保所有进程都已解除链接，以避免资源泄漏</li>
</ul>
</li>
</ul>
<h2 id="shm-open"><a href="#shm-open" class="headerlink" title="shm_open"></a>shm_open</h2><ul>
<li><p>简介：</p>
<ul>
<li>在 C++ 中，shm_open() 函数用于创建或打开共享内存对象。它是 POSIX 共享内存机制的一部分，用于在不同进程之间共享内存数据。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shm_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>name：共享内存对象的名称，以字符串形式表示。在创建共享内存对象时，可以给它一个唯一的名称，以便其他进程可以使用相同的名称来访问该对象</li>
<li>oflag：打开标志，用于指定打开共享内存的方式。常用的选项包括 O_CREAT（如果共享内存对象不存在，则创建它）和 O_RDWR（可读写方式打开共享内存）等</li>
<li>mode：权限模式，用于设置共享内存对象的权限。只有在创建新的共享内存对象时才会使用该参数，它类似于 open() 函数中的文件权限参数</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>shm_open() 函数返回一个整数值，代表共享内存对象的文件描述符。如果打开或创建共享内存对象成功，则返回非负整数值；否则返回 -1，并设置相应的错误码。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 共享内存对象的名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;/my_shared_memory&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建或打开共享内存对象</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">shm_open</span>(name, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create/open shared memory&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭共享内存对象的文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared memory created/opened successfully&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上述示例中，我们使用 shm_open() 函数创建或打开了一个名为 “&#x2F;my_shared_memory” 的共享内存对象。通过指定 O_CREAT 和 O_RDWR 标志，我们创建了一个新的共享内存对象，并以可读写方式打开它。然后，我们关闭了共享内存对象的文件描述符，并输出一条成功的消息</li>
<li>请注意，shm_open() 函数只是打开或创建共享内存对象，它并没有定义共享内存的大小或分配实际的内存空间。要分配内存空间并映射到共享内存对象，可以使用 mmap() 函数。同时，创建或打开共享内存对象后，应该适当处理错误情况并进行错误检查，以确保操作的成功</li>
<li>在编译链接时，需要包含头文件<code>&lt;sys/mman.h&gt;</code>和链接库<code>librt.so</code></li>
</ul>
</li>
</ul>
<h2 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h2><ul>
<li><p>简介：</p>
<ul>
<li>shmat()函数用于将共享内存段连接到当前进程的地址空间。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>shmid：共享内存标识符，即共享内存段的标识符。</li>
<li>shmaddr：指定共享内存段连接到当前进程地址空间的地址。通常设置为NULL，让系统自动选择一个可用的地址</li>
<li>shmflg：标志位，用于指定共享内存段的连接方式和权限。可以使用SHM_RDONLY表示只读方式连接共享内存段，也可以使用0表示可读写方式连接</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>shmat()函数的返回值是一个void*指针，指向共享内存段在当前进程地址空间的起始地址。连接成功时，返回指向共享内存段的指针；连接失败时，返回-1。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="number">1234</span>; <span class="comment">// 共享内存标识符</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接共享内存段</span></span><br><span class="line">    <span class="type">void</span> *shm_ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_ptr == (<span class="type">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared memory segment attached at address: %p\n&quot;</span>, shm_ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在连接的共享内存段中读写数据</span></span><br><span class="line">    <span class="type">int</span> *data = (<span class="type">int</span>*)shm_ptr;</span><br><span class="line">    *data = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data in shared memory: %d\n&quot;</span>, *data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 断开共享内存段的连接</span></span><br><span class="line">    <span class="type">int</span> result = shmdt(shm_ptr);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmdt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared memory segment detached\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在这个示例中，我们首先使用shmat()函数将共享内存段连接到当前进程的地址空间。通过将shmaddr参数设置为NULL，让系统自动选择可用的地址进行连接。如果连接成功，返回的shm_ptr指向共享内存段在当前进程地址空间的起始地址</li>
<li>接下来，我们可以在连接的共享内存段中进行读写操作。在示例中，我们将共享内存段当作一个整数变量来使用，将值42写入共享内存段，并从共享内存段中读取该值</li>
<li>最后，我们使用shmdt()函数断开共享内存段的连接，将共享内存段从当前进程的地址空间中分离。注意，断开连接并不会删除共享内存段，只是将共享内存段从当前进程中移除。如果其他进程仍然连接到该共享内存段，它们仍然可以访问和修改共享内存数据</li>
<li>需要注意的是，使用shmat()和shmdt()函数时需要确保当前用户对共享内存段具有足够的权限。另外，要小心处理共享内存的并发访问，使用同步机制来避免竞争条件和数据不一致的问题</li>
</ul>
</li>
</ul>
<h2 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h2><ul>
<li><p>简介：</p>
<ul>
<li>shmctl()函数用于控制和操作共享内存段的属性。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>shmid：共享内存标识符，即共享内存段的标识符。</li>
<li>cmd：控制命令，用于指定对共享内存段的操作，可以是下列值之一：<ul>
<li>IPC_STAT：获取共享内存段的状态信息，将共享内存段的信息存储在buf指向的shmid_ds结构体中。</li>
<li>IPC_SET：设置共享内存段的状态信息，将buf指向的shmid_ds结构体中的信息应用于共享内存段。</li>
<li>IPC_RMID：删除共享内存段，释放共享内存资源。</li>
</ul>
</li>
<li>buf：用于存储共享内存段状态信息的结构体指针。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>使用IPC_STAT命令可以获取共享内存段的状态信息，包括共享内存段的大小、创建者的用户ID、最后一次操作的时间等。这些信息被存储在shmid_ds结构体中，通过传递一个指向该结构体的指针作为buf参数来获取这些信息</li>
<li>使用IPC_SET命令可以修改共享内存段的属性，比如更改共享内存段的权限、所有者等。需要将一个填充了新属性值的shmid_ds结构体指针传递给buf参数</li>
<li>使用IPC_RMID命令可以删除共享内存段，释放相关的资源。注意，删除共享内存段并不会立即清除共享内存中的数据，只是使得该共享内存段不再可用。实际的共享内存段会在所有连接到它的进程都断开连接后被系统清理</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="number">1234</span>; <span class="comment">// 共享内存标识符</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> <span class="title">shm_info</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取共享内存段的状态信息</span></span><br><span class="line">    <span class="type">int</span> result = shmctl(shmid, IPC_STAT, &amp;shm_info);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmctl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of shared memory segment: %lu\n&quot;</span>, shm_info.shm_segsz);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Owner&#x27;s user ID: %d\n&quot;</span>, shm_info.shm_perm.uid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Last attach time: %ld\n&quot;</span>, shm_info.shm_atime);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改共享内存段的权限</span></span><br><span class="line">    shm_info.shm_perm.mode = <span class="number">0666</span>; <span class="comment">// 设置权限为rw-rw-rw-</span></span><br><span class="line">    result = shmctl(shmid, IPC_SET, &amp;shm_info);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmctl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared memory segment permissions updated successfully\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在这个示例中，我们首先使用shmctl()函数和IPC_STAT命令获取共享内存段的状态信息，并将信息存储在shmid_ds结构体（shm_info）中。然后，我们打印出共享内存段的大小、所有者的用户ID以及最后一次附加到共享内存段的时间</li>
<li>接下来，我们修改共享内存段的权限，将权限设置为0666，即读写权限对所有用户都可用。我们将新的权限信息存储在shm_info结构体中，并使用shmctl()函数和IPC_SET命令应用这些新的属性</li>
<li>请注意，使用shmctl()函数进行修改操作时，需要确保当前用户对共享内存段具有足够的权限。另外，要小心使用IPC_RMID命令删除共享内存段，因为这将导致所有连接到该共享内存段的进程失去对它的访问权限</li>
</ul>
</li>
</ul>
<h2 id="shmdt"><a href="#shmdt" class="headerlink" title="shmdt"></a>shmdt</h2><ul>
<li><p>简介：</p>
<ul>
<li>shmdt()函数用于将共享内存段从当前进程的地址空间中分离，即将共享内存段与进程的连接断开</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<ul>
<li>shmaddr：共享内存段的起始地址，即附加到进程地址空间的地址。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>shmdt()函数将共享内存段从当前进程的地址空间中分离，并释放与共享内存段相关的资源。一旦共享内存段被分离，进程将无法再访问共享内存段中的数据。</li>
<li>使用shmdt()函数时需要注意以下几点：<ul>
<li>shmaddr参数应该是之前使用shmat()函数将共享内存段附加到进程地址空间时返回的地址</li>
<li>成功执行shmdt()函数后，共享内存段与进程的连接被断开，但共享内存段本身并没有被销毁。其他进程仍然可以访问该共享内存段。</li>
<li>如果多个进程共享同一个共享内存段，在一个进程中调用shmdt()函数分离共享内存段后，其他进程仍然可以继续访问该共享内存段。</li>
<li>分离共享内存段后，可以使用shmctl()函数删除共享内存段。</li>
</ul>
</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="number">1234</span>; <span class="comment">// 共享内存标识符</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> *shmaddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmaddr == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared memory segment attached at address: %p\n&quot;</span>, shmaddr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> result = shmdt(shmaddr);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmdt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared memory segment detached successfully\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在这个示例中，我们首先使用shmat()函数将共享内存段附加到进程地址空间，并获取共享内存段的起始地址（shmaddr）。然后，我们使用shmdt()函数分离共享内存段，断开进程与共享内存段的连接。如果分离共享内存段时出现错误，我们使用perror()函数打印相应的错误消息</li>
<li>请注意，分离共享内存段后，进程将无法再访问共享内存段中的数据</li>
</ul>
</li>
</ul>
<h2 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h2><ul>
<li><p>简介：</p>
<ul>
<li>shmget()函数是一个系统调用，用于创建或打开一个共享内存段。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<ul>
<li>key：共享内存段的键值，通常由ftok()函数生成。</li>
<li>size：共享内存段的大小，以字节为单位</li>
<li>shmflg：共享内存段的访问权限和标志，可以是一个或多个标志的位或运算结果，如IPC_CREAT、IPC_EXCL等。</li>
</ul>
</li>
<li><p>详解</p>
<ul>
<li>shmget()函数根据给定的键值和大小创建或打开一个共享内存段，并返回一个与共享内存段相关的标识符（shmid）。这个标识符可以用于后续的共享内存操作，如附加、分离、读写等。</li>
<li>使用shmget()函数时需要注意以下几点：<ul>
<li>key参数应该是一个与其他进程共享的键值，通常由ftok()函数生成。不同的key值将对应不同的共享内存段。</li>
<li>size参数指定了共享内存段的大小，即申请的内存空间大小。</li>
<li>shmflg参数用于设置共享内存段的权限和标志。常见的标志有IPC_CREAT表示创建新的共享内存段，IPC_EXCL表示只在共享内存段不存在时创建，0666表示权限设置为可读可写。</li>
<li>如果成功创建或打开共享内存段，shmget()函数返回一个非负整数的共享内存标识符（shmid），用于后续的共享内存操作。</li>
<li>如果共享内存段已经存在且没有指定IPC_EXCL标志，则返回已存在的共享内存标识符</li>
</ul>
</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;/path/to/file&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> size = <span class="number">1024</span>; <span class="comment">// 共享内存段的大小，以字节为单位</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> shmid = shmget(key, size, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared memory segment created with shmid: %d\n&quot;</span>, shmid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>这个示例中，我们首先使用ftok()函数生成一个键值，然后使用shmget()函数创建一个共享内存段，并获取与该共享内存段相关的标识符（shmid）。如果创建共享内存段时出现错误，我们使用perror()函数打印相应的错误消息。</li>
<li>请注意，创建共享内存段后，还需要使用其他函数（如shmat()）将共享内存段附加到进程的地址空间中，才能进行读写操作。此处仅演示了创建共享内存段的基本过程</li>
</ul>
</li>
</ul>
<h2 id="ftok"><a href="#ftok" class="headerlink" title="ftok"></a>ftok</h2><ul>
<li><p>简介：</p>
<ul>
<li><code>ftok()</code>函数是C语言中的一个函数，用于生成一个唯一的键值（key）来创建一个共享内存、消息队列或信号量等系统对象。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<ul>
<li>pathname：一个存在的文件的路径名，用于生成键值。</li>
<li>proj_id：项目标识符，通常为一个非负整数，用于区分不同的键值。</li>
</ul>
</li>
<li><p>详解</p>
<ul>
<li>ftok()函数根据pathname和proj_id生成一个唯一的键值，并返回一个key_t类型的值作为结果。这个键值可以用于创建和访问共享内存、消息队列或信号量等系统对象</li>
<li>使用ftok()函数时需要注意以下几点：<ul>
<li>pathname参数必须是一个有效的文件路径，且文件必须存在。如果文件不存在或路径无效，ftok()函数将返回一个错误的键值。</li>
<li>proj_id参数通常是一个非负整数，用于区分不同的键值。不同的proj_id值将生成不同的键值。</li>
</ul>
</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;/path/to/file&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Generated key: %d\n&quot;</span>, key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>请注意，生成的键值应该在进程之间共享，以便其他进程可以使用相同的键值访问同一个系统对象。通常，可以将生成的键值传递给共享内存、消息队列或信号量等相关函数来创建或访问这些对象</li>
<li>相同的文件，相同的标识符，生成相同的键值</li>
</ul>
</li>
</ul>
<h2 id="newlocale"><a href="#newlocale" class="headerlink" title="newlocale"></a>newlocale</h2><ul>
<li><p><code>newlocale</code>是一个C语言函数，用于创建一个新的区域设置对象。区域设置对象是一个数据结构，包含了与特定地区相关的本地化信息，如日期格式、货币符号、语言偏好等。</p>
</li>
<li><p><code>newlocale</code>函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">locale_t</span> <span class="title function_">newlocale</span><span class="params">(<span class="type">int</span> category_mask, <span class="type">const</span> <span class="type">char</span> *locale, <span class="type">locale_t</span> base)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解释如下：</p>
<ul>
<li><code>category_mask</code>：一个位掩码，用于指定要设置的区域设置的不同方面。可以使用<code>LC_ALL</code>表示所有方面，或使用以下值之一：<code>LC_COLLATE</code>、<code>LC_CTYPE</code>、<code>LC_MONETARY</code>、<code>LC_NUMERIC</code>、<code>LC_TIME</code>。</li>
<li><code>locale</code>：一个字符串，表示要创建的区域设置的名称。可以是特定地区的名称（例如：”en_US”表示美国英语），也可以是一些特殊值（例如：”C”表示默认的”POSIX”区域设置）。</li>
<li><code>base</code>：一个基本区域设置对象，用作新区域设置的基础。可以将其设置为<code>NULL</code>，表示没有基础区域设置。</li>
</ul>
</li>
<li><p>函数返回一个<code>locale_t</code>类型的值，表示新创建的区域设置对象。如果创建失败，函数返回<code>NULL</code>。</p>
</li>
<li><p>使用<code>newlocale</code>函数可以创建新的区域设置对象，以便在程序中进行本地化设置，从而使程序能够适应不同的地区和语言环境。创建后的区域设置对象可以传递给其他一些与本地化相关的函数，如<code>strftime</code>、<code>strcoll</code>等，以便根据特定区域的规则进行相应的操作。</p>
</li>
</ul>
<h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><ul>
<li><p>简介：</p>
<ul>
<li>C 库函数 void *memcpy(void *str1, const void *str2, size_t n) 从存储区 str2 复制 n 个字节到存储区 str1。</li>
</ul>
</li>
<li><p>声明</p>
<ul>
<li><code>void *memcpy(void *str1, const void *str2, size_t n);</code></li>
</ul>
</li>
<li><p>参数：</p>
<ul>
<li>str1 – 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li>
<li>str2 – 指向要复制的数据源，类型强制转换为 void* 指针。</li>
<li>n – 要被复制的字节数。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>该函数返回一个指向目标存储区 str1 的指针。</li>
</ul>
</li>
</ul>
<h2 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h2><ul>
<li><p>简介：getopt() 方法是用来分析命令行参数的，该方法由 Unix 标准库提供，包含在 <code>&lt;unistd.h&gt;</code> 头文件中。</p>
</li>
<li><p>定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">const</span> <span class="type">char</span> *optstring)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *optarg;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> optind, opterr, optopt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getopt参数：</p>
<ul>
<li>argc：通常由 main 函数直接传入，表示参数的数量</li>
<li>argv：通常也由 main 函数直接传入，表示参数的字符串变量数组</li>
<li>optstring：一个包含正确的参数选项字符串，用于参数的解析。例如 “abc:”，其中 -a，-b 就表示两个普通选项，-c 表示一个必须有参数的选项，因为它后面有一个冒号<ul>
<li>可选参数：一个冒号表示选项后必须有参数，没有参数就会报错。如果有两个冒号的话，那么这个参数就是可选参数了，即可有可没有。</li>
<li>注意这里 可选参数 选项 -c 后面跟参数的时候，一定不能有空格。</li>
<li>但是如果是 必选参数，即选项后面只有一个冒号，则是有没有空格都可以。</li>
</ul>
</li>
</ul>
</li>
<li><p>外部变量说明</p>
<ul>
<li>optarg：如果某个选项有参数，这包含当前选项的参数字符串</li>
<li>optind：argv 的当前索引值</li>
<li>opterr：正常运行状态下为 0。非零时表示存在无效选项或者缺少选项参数，并输出其错误信息</li>
<li>optopt：当发现无效选项字符时，即 getopt() 方法返回 ? 字符，optopt 中包含的就是发现的无效选项字符</li>
</ul>
</li>
<li><p>输入字符串转 int</p>
<ul>
<li>由于 optarg 都是字符串类型的，所以当我们想要整型的输入参数时，会经常用到 atio() 这个方法，这里也简单介绍一下。</li>
<li>atoi (表示 ascii to integer) 是把字符串转换成整型数的一个函数，包含在 <code>&lt;stdlib.h&gt;</code> 头文件中，使用方式如下：<ul>
<li><code>int num = atoi(optarg);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="getopt-long"><a href="#getopt-long" class="headerlink" title="getopt_long"></a>getopt_long</h2><ul>
<li><p>简介：getopt_long支持处理长短选项的命令行解析，函数在<code>&lt;getopt.h&gt;</code>头文件中</p>
</li>
<li><p>定义：<code>int getopt_long(int argc, char *const *argv, const char *shortopts, const option *longopts, int *longind);</code></p>
</li>
<li><p>参数</p>
<ul>
<li>argc、argv 和 main 函数的两个参数一致；</li>
<li>optstring：短选项字符串；<ul>
<li>形式如 a:b::cd，分别表示程序支持的命令行短选项有 -a、-b、-c、-d，冒号含义如下：<ul>
<li>只有一个字符，不带冒号—–只表示选项，如: -c</li>
<li>一个字符，后面接一个冒号—–表示选项后面带一个参数，如: -a 100</li>
<li>一个字符，后面接两个冒号—–表示选项后面带一个可选参数，即参数可有可无，如果带参数，则选项与参数之间不能有空格，如: -b200</li>
</ul>
</li>
</ul>
</li>
<li>longopts：表示长选项结构体：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="comment">/* has_arg can&#x27;t be an enum because some compilers complain about</span></span><br><span class="line"><span class="comment">     type mismatches in all the code that assumes it is an int.  */</span></span><br><span class="line">  <span class="type">int</span> has_arg;</span><br><span class="line">  <span class="type">int</span> *flag;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;help&quot;</span>, no_argument,       <span class="number">0</span>,   <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;cfg&quot;</span>,  required_argument, <span class="number">0</span>,   <span class="string">&#x27;f&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;http-proxy&quot;</span>, required_argument, &amp;lopt, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;http-user&quot;</span>, required_argument, &amp;lopt, <span class="number">2</span> &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;http-passwd&quot;</span>, required_argument, &amp;lopt, <span class="number">3</span> &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;http-proxy-user&quot;</span>, required_argument, &amp;lopt, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;http-proxy-passwd&quot;</span>, required_argument, &amp;lopt, <span class="number">5</span> &#125;,</span><br><span class="line">    &#123;<span class="string">&quot;http-auth-scheme&quot;</span>, required_argument, &amp;lopt, <span class="number">6</span> &#125;,</span><br><span class="line">    &#123;nullptr, <span class="number">0</span>, nullptr, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>name：表示选项的名称，如 help、cfg 等；</li>
<li>has_arg：表示选项后面是否携带参数，该参数有三个不同值，如：<ul>
<li>no_argument(0): 参数后面不跟参数值，如：–help；</li>
<li>required_argument(1): 参数输入格式为：–参数 值 or –参数&#x3D;值，如：.&#x2F;dist_measurment_node –cfg .&#x2F;cal_result；</li>
<li>optional_argument(2): 参数输入格式只能为：–参数&#x3D;值。</li>
</ul>
</li>
<li>flag：该参数有两种，空或者非空：<ul>
<li>如果参数为空(NULL)：当选中某个长选项的时候，getopt_long 将返回 val 值，如： .&#x2F;可执行程序 –help，getopt_long 的返回值为 h。</li>
<li>如果参数不为空：当选中某个长选项的时候，getopt_long 将返回 0，并且将 flag 指针指向 val 值，如：.&#x2F;可执行程序 –http-proxy&#x3D;127.0.0.1:80，getopt_long 的返回值为 0，并且 lopt 值为 1。</li>
</ul>
</li>
<li>val：表示指定函数找到该选项时的返回值，或者当 flag 非空时指定 flag 指向的数据的值。</li>
<li>longindex：longindex 非空，它指向的变量将记录当前找到参数符合 longopts 里的第几个元素的描述，即 longopts 的下标值。</li>
</ul>
</li>
</ul>
</li>
<li><p>全局变量</p>
<ul>
<li>optarg：会被系统自动赋为当前选项的参数；</li>
<li>optind：表示下一个将被处理到的参数在 argv 中的下标值；</li>
<li>opterr：如果 opterr &#x3D; 0，在getopt、getopt_long、getopt_long_only 遇到错误将不会输出错误信息到标准输出流。opterr 在非 0 时，向屏幕输出错误。</li>
<li>optopt：会被自动赋值当前未标识的选项；</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果短选项找到，那么将返回短选项对应的字符。</li>
<li>如果长选项找到，如果flag为NULL，返回val。如果flag不为空，返回0</li>
<li>如果遇到一个选项没有在短字符、长字符里面，或者在长字符里面存在二义性的，返回“？”</li>
<li>如果解析完所有字符没有找到（一般是输入命令参数格式错误，eg： 连斜杠都没有加的选项），返回“-1”</li>
<li>如果选项需要参数，忘了添加参数。返回值取决于optstring，如果其第一个字符是“：”，则返回“：”，否则返回“？”</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>longopts的最后一个元素必须是全0填充，否则会报段错误</li>
<li>短选项中每个选项都是唯一的。而长选项如果简写，也需要保持唯一性。</li>
</ul>
</li>
</ul>
<h2 id="perror"><a href="#perror" class="headerlink" title="perror()"></a>perror()</h2><ul>
<li>功能：把一个描述性错误消息输出到标准错误 stderr</li>
<li>原型：<code>void perror(const char *str);</code></li>
<li>参数：<ul>
<li><code>str</code>  –  这是 C 字符串，包含了一个自定义消息，将显示在原本的错误消息之前。</li>
</ul>
</li>
</ul>
<h2 id="daemon"><a href="#daemon" class="headerlink" title="daemon()"></a>daemon()</h2><ul>
<li>功能：将程序置于后台，并与控制终端分离</li>
<li>原型：<code>int daemon(int nochdir, int noclose);</code></li>
<li>参数：<ul>
<li><code>nochdir</code>  –  如果为0，执行<code>chdir (&quot;/&quot;)</code></li>
<li><code>noclose</code>  –  如果为0，将<code>stdin, stdout, stderr</code>重定向到<code>/dev/null</code></li>
</ul>
</li>
</ul>
<h2 id="strchr"><a href="#strchr" class="headerlink" title="strchr()"></a>strchr()</h2><ul>
<li>功能：在参数 <code>str</code> 所指向的字符串中搜索最后一次出现字符 <code>c</code>（一个无符号字符）的位置</li>
<li>原型：<code>char* strrchr(const char *str, int c);</code></li>
<li>参数：<ul>
<li><code>str</code>  –  C字符串</li>
<li><code>c</code>    –  要搜索的字符。以 <code>int</code> 形式传递，但是最终会转换回 <code>char</code> 形式</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回<code>str</code>中最后一次出现字符<code>c</code>的位置</li>
<li>失败  –  没有找到该值，返回一个空指针</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;string.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe()"></a>pipe()</h2><ul>
<li>功能：创建单项通信通道(管道)</li>
<li>原型：<code>int pipe(int *__pipedes);</code><ul>
<li>如果成功，两个文件描述符存储在<code>pipedes</code>中</li>
<li><code>pipedes[1]</code>上写入的字节可以从<code>pipedes[0]</code>中读取</li>
</ul>
</li>
<li>参数：<ul>
<li><code>__pipedes</code>  –  数组</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  0</li>
<li>失败  –  -1</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;unistd.h&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li>管道没有外部或永久的名字，因此程序只能通过它的两个描述符来访问它</li>
<li>因此，管道只能由创建它的进程或在<code>fork</code>时继承了它的描述符的后代进程使用。</li>
</ul>
</li>
</ul>
<h2 id="mkfifo"><a href="#mkfifo" class="headerlink" title="mkfifo()"></a>mkfifo()</h2><ul>
<li>功能：创建新的FIFO特殊文件</li>
<li>原型：<code>int mkfifo(const char *path, mode_t mode);</code></li>
<li>参数：<ul>
<li><code>path</code>  –  创建的文件路径</li>
<li><code>mode</code>  –  文件权限</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  0</li>
<li>失败  –  -1，并设置errno</li>
</ul>
</li>
</ul>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><ul>
<li>功能：克隆调用进程，创建一个精确的副本。</li>
<li>原型：<code>pid_t fork();</code></li>
<li>参数：无</li>
<li>返回值：<ul>
<li>成功  –  新进程返回 0，或者新进程对旧进程的进程ID</li>
<li>失败  –  -1</li>
</ul>
</li>
</ul>
<h2 id="getpid"><a href="#getpid" class="headerlink" title="getpid()"></a>getpid()</h2><!-- + 功能：返回进程ID
+ 原型：`pid_t getpid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  进程ID
  + 失败  --  
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `pid_t`是用来表示进程ID的一个无符号整数类型
  + `getpid`函数不能返回错误 -->

<ul>
<li><p>简介：</p>
<ul>
<li>getpid() 是一个 C 标准库函数，用于获取当前进程的进程ID（Process ID）</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：</p>
<ul>
<li>返回一个整数值，表示当前进程的进程ID</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>getpid() 函数用于获取当前进程的进程ID，进程ID是一个唯一标识符，用于在系统中唯一地标识一个进程。</li>
<li>该函数属于 POSIX 标准，并可在大多数操作系统上使用，如 Linux、Unix 和 macOS。</li>
<li>要使用 getpid() 函数，需要包含头文件 &lt;sys&#x2F;types.h&gt; 和 &lt;unistd.h&gt;。</li>
<li>通过调用 getpid() 函数，可以在程序中获取当前进程的进程ID，并在需要时进行处理或记录</li>
<li>需要注意的是，进程ID是由操作系统分配和管理的，它在进程的生命周期中保持不变。每个进程都有一个唯一的进程ID，可以用于识别和跟踪进程。在多进程环境中，使用 getpid() 函数可以帮助确定不同进程之间的执行路径和行为</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process ID: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="getppid"><a href="#getppid" class="headerlink" title="getppid()"></a>getppid()</h2><ul>
<li>功能：返回父进程ID</li>
<li>原型：<code>pid_t getppid(void);</code></li>
<li>参数：无</li>
<li>返回值：<ul>
<li>成功  –  父进程ID</li>
<li>失败  –</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;unistd.h&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li><code>pid_t</code>是用来表示进程ID的一个无符号整数类型</li>
<li><code>getppid</code>函数不能返回错误</li>
</ul>
</li>
</ul>
<h2 id="geteuid"><a href="#geteuid" class="headerlink" title="geteuid()"></a>geteuid()</h2><ul>
<li>功能：返回用户ID</li>
<li>原型：<code>uid_t geteuid(void);</code></li>
<li>参数：无</li>
<li>返回值：<ul>
<li>成功  –  用户ID</li>
<li>失败  –</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;unistd.h&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li><code>uid_t</code>是代表用户ID的整数类型</li>
<li><code>geteuid()</code>不返回错误</li>
</ul>
</li>
</ul>
<h2 id="getegid"><a href="#getegid" class="headerlink" title="getegid()"></a>getegid()</h2><ul>
<li>功能：返回组ID</li>
<li>原型：<code>gid_t getegid(void);</code></li>
<li>参数：无</li>
<li>返回值：<ul>
<li>成功  –  组ID</li>
<li>失败  –</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;unistd.h&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li><code>gid_t</code>是代表组ID的整数类型</li>
<li><code>getegid()</code>不返回错误</li>
</ul>
</li>
</ul>
<h2 id="fork-1"><a href="#fork-1" class="headerlink" title="fork()"></a>fork()</h2><ul>
<li>功能：创建新的进程</li>
<li>原型：<code>pid_t fork(void);</code></li>
<li>参数：无</li>
<li>返回值：<ul>
<li>成功  –  向子进程返回0，并将子进程ID返回父进程</li>
<li>失败  –  -1，并设置errno，没有创建子进程</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;unistd.h&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li>fork函数的返回值是允许父进程和子进程区别自己并执行不同代码的关键特征</li>
</ul>
</li>
</ul>
<h2 id="execl"><a href="#execl" class="headerlink" title="execl()"></a>execl()</h2><ul>
<li>功能：使用参数<code>arg</code>以及之后的参数 执行<code>path</code></li>
<li>原型：<code>int execl(const char* path, const char* arg,...);</code></li>
<li>参数：<ul>
<li><code>path</code>  –  要执行的文件</li>
<li><code>arg</code>   –  执行的参数</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –</li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h2 id="pthread-sigmask"><a href="#pthread-sigmask" class="headerlink" title="pthread_sigmask()"></a>pthread_sigmask()</h2><ul>
<li>功能：修改，控制调用线程的信号掩码</li>
<li>原型：<code>int pthread_sigmask(int how, const sigset_t *newmask, sigset_t *oldmask);</code></li>
<li>参数：<ul>
<li><code>how</code>  –  <ul>
<li><code>SIG_BLOCK</code>  ：结果集是当前集合参数集的并集， </li>
<li><code>SIG_UNBLOCK</code>：结果集是当前集合参数集的差集， </li>
<li><code>SIG_SETMASK</code>：结果集是由参数集指向的集</li>
</ul>
</li>
<li><code>newmask</code></li>
<li><code>oldmask</code></li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – 0</li>
<li>失败  – -1，并设置errno</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;signal.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create()"></a>pthread_create()</h2><ul>
<li>功能：创建一个新的线程，并让它可执行</li>
<li>原型：<code>int pthread_create(pthread_t *newthread, const pthread_attr_t attr, void *(*start_routine)(void *), void *arg);</code></li>
<li>参数：<ul>
<li><code>newthread</code>  –  存储新线程的句柄，指向线程标识符指针</li>
<li><code>attr</code> –  设置线程属性</li>
<li><code>start_routine</code> – 线程运行函数的起始地址</li>
<li><code>arg</code>  –  运行函数的参数</li>
</ul>
</li>
<li>返回值：<ul>
<li>线程创建成功  –  0</li>
<li>线程创建失败  –  返回出错编号，并且*thread中的内容是未定义的</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;pthread&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li>返回成功时，由<code>newthread</code>指向的内存单元被设置为新创建线程的线程ID</li>
<li>attr参数用于指定各种不同的线程属性</li>
<li>新创建的线程从<code>start_routine</code>函数的地址开始运行，该函数只有一个万能指针参数<code>arg</code></li>
<li>如果需要向<code>start_routine</code>函数传递的参数不止一个，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为arg的参数传入</li>
<li>linux下用C语言开发多线程程序，Linux系统下的多线程遵循POSIX线程接口，称为pthread</li>
</ul>
</li>
</ul>
<h2 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join()"></a>pthread_join()</h2><ul>
<li>功能：子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。</li>
<li>原型：<code>int pthread_join(pthread_t thread, void **retval);</code></li>
<li>参数：<ul>
<li><code>thread</code>  –  线程标识符，即线程ID，标识唯一的线程</li>
<li><code>retval</code>  –  用户定义的指针，用来存储被等待线程的返回值</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  0</li>
<li>失败  –  其他值</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;pthread&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li>pthread_join()函数，以阻塞的方式等待thread指定的线程结束。</li>
<li>当函数返回时，被等待线程的资源被收回。</li>
<li>如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。</li>
</ul>
</li>
</ul>
<h2 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach()"></a>pthread_detach()</h2><ul>
<li>功能：指示线程<code>th</code>永远不会与<code>PTHREAD_JOIN</code>连接。因此，<code>th</code>的资源将在它终止时立即被释放，而不是等待另一个线程对它执行<code>PTHREAD_JOIN</code>。<ul>
<li>主线程与子线程分离，子线程结束后，资源自动回收。</li>
</ul>
</li>
<li>原型：<code>int pthread_detach(pthread_t th);</code></li>
<li>参数：<ul>
<li><code>th</code>  –  线程标识符，指向需要自动释放的线程</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  0</li>
<li>失败  –  其他情况</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;pthread&gt;</code></li>
</ul>
</li>
<li>注意：</li>
</ul>
<h2 id="pthread-两种状态"><a href="#pthread-两种状态" class="headerlink" title="pthread 两种状态"></a>pthread 两种状态</h2><ul>
<li><p><code>pthread</code>有两种状态<code>joinable</code>状态和<code>unjoinable</code>状态</p>
</li>
<li><p>如果线程是<code>joinable</code>状态，当线程函数自己返回退出时或<code>pthread_exit</code>时都不会释放线程所占用堆栈和线程描述符（总计8K多）</p>
</li>
<li><p>只有当你调用了<code>pthread_join</code>之后这些资源才会被释放</p>
</li>
<li><p>若是<code>unjoinable</code>状态的线程，这些资源在线程函数退出时或<code>pthread_exit</code>时自动会被释放</p>
</li>
<li><p><code>unjoinable</code>属性可以在<code>pthread_create</code>时指定，或在线程创建后在线程中<code>pthread_detach</code>自己</p>
</li>
<li><p><code>pthread_detach(pthread_self());</code></p>
<ul>
<li>将状态改为<code>unjoinable</code>状态，确保资源的释放。或者将线程置为 <code>joinable</code>,然后适时调用<code>pthread_join</code>.</li>
<li>简单的说就是在线程函数头加上 <code>pthread_detach(pthread_self())</code>的话，线程状态改变，<strong>在函数尾部直接 <code>pthread_exit</code> 线程就会自动退出</strong>。省去了给线程擦屁股的麻烦</li>
</ul>
</li>
</ul>
<h2 id="exit"><a href="#exit" class="headerlink" title="_exit()"></a>_exit()</h2><ul>
<li>功能：使用<code>__status</code>的<code>low-order 8 bits</code>终止程序执行</li>
<li>原型：<code>void _exit(int __status);</code></li>
<li>参数：<ul>
<li><code>__status</code>  –</li>
</ul>
</li>
<li>返回值：</li>
</ul>
<h2 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid()"></a>waitpid()</h2><ul>
<li>功能：等待进程为<code>pid</code>的子进程死亡， </li>
<li>原型：<code>pid_t waitpid(pid_t  pid, int* stat_loc, int options);</code></li>
<li>参数：<ul>
<li><code>pid</code>  –  等待的进程,指向返回状态所在单元的指针和一个用来指定可选项的标志符<ul>
<li>pid有四种情况：<ul>
<li>pid &lt;  -1 等待组ID等于pid绝对值的任意子进程</li>
<li>pid &#x3D;&#x3D; -1 等待任意子进程</li>
<li>pid &#x3D;&#x3D; 0  等待组ID等于调用进程组ID的任意子进程</li>
<li>pid &gt;  0  等待进程ID与pid相等的子进程</li>
</ul>
</li>
</ul>
</li>
<li><code>stat_loc</code>  –  指向终止进程的终止状态，如果不关心终止状态可指定为空指针</li>
<li><code>options</code>   –  控制waitpid的操作<ul>
<li>WCONTINUED</li>
<li>WUNTRACED</li>
<li>WNOHANG  waitpid不阻塞</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回pid，并将子进程的状态存储到<code>stat_loc</code>中</li>
<li>失败  –  -1</li>
</ul>
</li>
</ul>
<h2 id="mkstemp"><a href="#mkstemp" class="headerlink" title="mkstemp()"></a>mkstemp()</h2><ul>
<li>功能：根据<code>__tmplate</code>生成唯一的临时文件名</li>
<li>原型：<code>int mkstemp(char *__template);</code></li>
<li>参数：<ul>
<li><code>__tmplate</code>  –  需要操作的文件</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回在文件上打开的用于读取和写入的文件描述符</li>
<li>失败  –  -1 （如果它不能创建一个唯一的文件名）</li>
</ul>
</li>
</ul>
<h2 id="openlog"><a href="#openlog" class="headerlink" title="openlog()"></a>openlog()</h2><ul>
<li>功能：此函数用来打开一个到系统日志记录程序的连接，打开之后就可以用<code>syslog</code>或<code>vsyslog</code>函数向系统日志里添加信息了。而<code>closelog</code>函数就是用来关闭此连接的</li>
<li>原型：<code>void openlog(const char *ident, int option, int facility);</code></li>
<li>参数：<ul>
<li><code>ident</code>  –  一个标记，<code>ident</code>所表示的字符串将固定地加在每行日志的前面以标识这个日志，通常就写成当前程序的名称以作标记</li>
<li><code>option</code> –  参数option是下列值取与运算的结果：<ul>
<li><code>LOG_CONS，LOG_NDELAY， LOG_NOWAIT， LOG_ODELAY， LOG_PERROR，LOG_PID</code></li>
<li>各值意义请参考<code>man openlog</code>手册</li>
</ul>
</li>
<li><code>facility</code>  –  指明记录日志的程序的类型</li>
</ul>
</li>
<li>返回值：空</li>
</ul>
<h2 id="setlogmask"><a href="#setlogmask" class="headerlink" title="setlogmask()"></a>setlogmask()</h2><ul>
<li>功能：设置日志掩码级别</li>
<li>原型：<code>int setlogmask(int mask);</code></li>
<li>参数：<ul>
<li><code>mask</code>  –</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  </li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C 标准库 &lt;stdarg.h&gt;"></a>C 标准库 <code>&lt;stdarg.h&gt;</code></h2><ul>
<li><code>stdarg.h</code> 头文件定义了一个变量类型 <code>va_list</code> 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。</li>
<li>可变参数的函数通在参数列表的末尾是使用省略号<code>(,...)</code>定义的</li>
</ul>
<h3 id="库变量-–-va-list"><a href="#库变量-–-va-list" class="headerlink" title="库变量 – va_list"></a>库变量 – va_list</h3><ul>
<li>功能：这是一个适用于 <code>va_start()</code>、<code>va_arg()</code> 和 <code>va_end()</code> 这三个宏存储信息的类型</li>
<li>声明：<code>typedef _G_va_list va_list;</code></li>
</ul>
<h3 id="va-start"><a href="#va-start" class="headerlink" title="va_start()"></a>va_start()</h3><ul>
<li>功能：<ul>
<li>C 库宏 <code>void va_start(va_list ap, last_arg)</code> 初始化 <code>ap</code> 变量，它与 <code>va_arg</code> 和 <code>va_end</code> 宏是一起使用的</li>
<li><code>last_arg</code> 是最后一个传递给函数的已知的固定参数，即<strong>省略号之前的参数</strong></li>
<li>这个宏必须在使用 <code>va_arg</code> 和 <code>va_end</code> 之前被调用</li>
</ul>
</li>
<li>原型：<code>void va_start(va_list ap, last_arg);</code></li>
<li>参数：<ul>
<li><code>ap</code> – 这是一个 <code>va_list</code> 类型的对象，它用来存储通过 <code>va_arg</code> 获取额外参数时所必需的信息</li>
<li><code>last_arg</code> – 最后一个传递给函数的已知的固定参数</li>
</ul>
</li>
<li>返回值：空</li>
</ul>
<h3 id="va-arg"><a href="#va-arg" class="headerlink" title="va_arg()"></a>va_arg()</h3><ul>
<li>功能：<ul>
<li>C 库宏 <code>type va_arg(va_list ap, type)</code> 检索函数参数列表中类型为 <code>type</code> 的下一个参数。</li>
<li>它无法判断检索到的参数是否是传给函数的最后一个参数</li>
</ul>
</li>
<li>原型：<code>type va_arg(va_list ap, type);</code></li>
<li>参数：<ul>
<li><code>ap</code>   – 这是一个 <code>va_list</code> 类型的对象，存储了有关额外参数和检索状态的信息。该对象应在第一次调用 <code>va_arg</code> 之前通过调用 <code>va_start</code> 进行初始化</li>
<li><code>type</code> – 这是一个类型名称。该类型名称是作为扩展自该宏的表达式的类型来使用的。</li>
</ul>
</li>
<li>返回值：<ul>
<li>该宏返回下一个额外的参数，是一个类型为 <code>type</code> 的表达式</li>
</ul>
</li>
</ul>
<h3 id="va-end"><a href="#va-end" class="headerlink" title="va_end()"></a>va_end()</h3><ul>
<li>功能：<ul>
<li>C 库宏 <code>void va_end(va_list ap)</code> 允许使用了 <code>va_start</code> 宏的带有可变参数的函数返回。</li>
<li>如果在从函数返回之前没有调用 <code>va_end</code>，则结果为未定义</li>
</ul>
</li>
<li>原型：<code>void va_end(va_list ap);</code></li>
<li>参数：<ul>
<li><code>ap</code> – 这是之前由同一函数中的 <code>va_start</code> 初始化的 <code>va_list</code> 对象</li>
</ul>
</li>
<li>返回值：空</li>
</ul>
<h2 id="vsnprintf"><a href="#vsnprintf" class="headerlink" title="vsnprintf()"></a>vsnprintf()</h2><ul>
<li>功能：将可变参数列表的格式化数据写入到大小为<code>n</code>的缓冲区</li>
<li>原型：<code>int vsnprintf(char *s, size_t n, const char *format, va_list arg);</code></li>
<li>参数：<ul>
<li><code>s</code>  –  指向存储C字符串的缓冲区指针</li>
<li><code>n</code>  –  缓冲区最大可用的字节数</li>
<li><code>format</code>  –  包含格式化字符串的C字符串，和printf()相同</li>
<li><code>arg</code>–  识别使用<code>va_start</code>初始化的可变参数列表的值</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  被写入的字符数<code>n</code></li>
<li>失败  –  -1</li>
</ul>
</li>
</ul>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><ul>
<li>功能：对在范围<code>[first, last]</code>内的元素进行排序，不能保证保留同等元素的顺序  </li>
<li>原型：<ul>
<li><code>template &lt;class RandomIt&gt;, class &lt;Compare&gt;</code></li>
<li><code>void sort(RandomIt first, RandomIt last, Compare comp);</code></li>
</ul>
</li>
<li>参数：<ul>
<li><code>first</code>  –  排序元素范围的开始</li>
<li><code>last</code>   –  排序元素范围的结束</li>
<li><code>comp</code>   –  比较函数对象（即满足比较要求的对象）</li>
</ul>
</li>
<li>返回值：空</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;algorithm&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt()"></a>sqrt()</h2><ul>
<li>功能：返回x的平方根</li>
<li>原型：<code>double sqrt(double x);</code></li>
<li>参数：<ul>
<li><code>x</code>  –  需要处理的浮点数</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  x的平方根</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;math.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="opendir"><a href="#opendir" class="headerlink" title="opendir()"></a>opendir()</h2><ul>
<li>功能：打开一个目录文件</li>
<li>原型：<code>DIR *opendir(const char *dirname);</code></li>
<li>参数：<ul>
<li><code>dirname</code>  –  目录</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回一个指向目录对象的指针</li>
<li>失败  –  返回一个空指针，并设置errno</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;dirent.h&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li>定义在dirent.h中的DIR类型，表示的是一个<strong>目录流</strong>(directory stream)</li>
<li>目录流是一个特定目录中所有目录项组成的一个有序序列。目录流中的条目不一定是按文件名的字母顺序排列的</li>
</ul>
</li>
</ul>
<h2 id="readdir"><a href="#readdir" class="headerlink" title="readdir()"></a>readdir()</h2><ul>
<li>功能：读取一个目录文件中的数据</li>
<li>原型：<code>struct dirent *readdir(DIR *dirp);</code></li>
<li>参数：<ul>
<li><code>dirp</code>  –  目录对象的指针</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回一个指向<code>struct dirent</code>结构的指针，结构中包含了与下一个目录项有关的信息</li>
<li>失败  –  返回一个NULL指针，并设置errno<ul>
<li><code>readdir()</code>的实现必须检测的错误只有一种，就是要返回的结构中的值无法正确表达，其错误码是<code>EOVERFLOW</code></li>
<li><code>readdir()</code>函数也返回NULL来指示目录的末尾，但在这种情况下它并不改变errno</li>
</ul>
</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;dirent.h&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li><code>readdir</code>在每次调用之后都将流转移到下一个位置上去</li>
</ul>
</li>
</ul>
<h2 id="stat"><a href="#stat" class="headerlink" title="stat()"></a>stat()</h2><ul>
<li>功能：通过名字来访问文件</li>
<li>原型：<code>int stat(const char *restrict path, struct stat *restrict buf);</code></li>
<li>参数：<ul>
<li><code>path</code>  –  指定了需要返回状态的文件或符号链接的名字</li>
<li><code>buf</code>   –  指向一个用户提供的缓冲区，这些函数都将信息存储在这个缓冲区中</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  0</li>
<li>失败  –  -1，并设置errno</li>
</ul>
</li>
</ul>
<h2 id="link"><a href="#link" class="headerlink" title="link()"></a>link()</h2><ul>
<li>功能：为<code>path1</code>指定的已存在文件创建一个新的目录项，这个文件位于<code>path2</code>指定的目录中</li>
<li>原型：<code>int link(const char *path1, const char *path2)</code></li>
<li>参数：<ul>
<li><code>path1</code>  –  已存在文件</li>
<li><code>path2</code>  –  指定的目录</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – 0</li>
<li>失败  – -1</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;unistd.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink()"></a>unlink()</h2><ul>
<li>功能：删除了path指定的目录项</li>
<li>原型：<code>int unlink(const char *path);</code></li>
<li>参数：<ul>
<li><code>path</code>  –  需要删除的目录项</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – 0</li>
<li>失败  – -1</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;unistd.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="symlink"><a href="#symlink" class="headerlink" title="symlink()"></a>symlink()</h2><ul>
<li>功能：创建一个符号链接</li>
<li>原型：<code>int symlink(const char *path1, const char *path2);</code></li>
<li>参数：<ul>
<li><code>path1</code>  –  包含了将成为链接的内容的字符串</li>
<li><code>path2</code>  –  链接的路径名</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – 0</li>
<li>失败  – -1</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;unistd.h&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li>换句话来说，path2就是新创建的链接，而新链接指向path1</li>
</ul>
</li>
</ul>
<h2 id="sigset-t-信号集"><a href="#sigset-t-信号集" class="headerlink" title="sigset_t 信号集"></a>sigset_t 信号集</h2><ul>
<li>信号集被定义为一种数据类型：<ul>
<li><code>typedef struct &#123;unsigned long sig[_NSIG_WORDS];&#125; sigset_t;</code></li>
</ul>
</li>
<li>信号集用来描述信号的集合，每个信号占用一位（64位）。</li>
<li>Linux所支持的所有信号可以全部或部分的出现在信号集中，主要与信号阻塞相关函数配合使用</li>
</ul>
<h3 id="信号集操作定义的相关函数："><a href="#信号集操作定义的相关函数：" class="headerlink" title="信号集操作定义的相关函数："></a>信号集操作定义的相关函数：</h3><ul>
<li><p><code>int sigemptyset(sigset_t *set);</code>  初始化由<code>set</code>指定的信号集，信号集里面的所有信号被清空，相当于<code>64</code>为置<code>0</code>；</p>
</li>
<li><p><code>int sigfillset(sigset_t *set);</code>   调用该函数后，<code>set</code>指向的信号集中将包含<code>linux</code>支持的<code>64</code>种信号，相当于<code>64</code>为都置<code>1</code>；</p>
</li>
<li><p><code>int sigaddset(sigset_t *set, int signum);</code>在<code>set</code>指向的信号集中加入<code>signum</code>信号，相当于将给定信号所对应的位置<code>1</code>；</p>
</li>
<li><p><code>int sigdelset(sigset_t *set, int signum);</code>在<code>set</code>指向的信号集中删除<code>signum</code>信号，相当于将给定信号所对应的位置<code>0</code>；</p>
</li>
<li><p><code>int sigismember(const sigset_t *set, int signum);</code>判定信号<code>signum</code>是否在<code>set</code>指向的信号集中，相当于检查给定信号所对应的位是<code>0</code>还是<code>1</code>。</p>
</li>
</ul>
<h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><ul>
<li>信号是内核提供的向用户态进程发送信息的机制, </li>
<li>常见的有使用<code>SIGUSR1</code>唤醒用户进程执行子程序或发生段错误时使用<code>SIGSEGV</code>保存用户错误现场.</li>
</ul>
<h2 id="sigwait"><a href="#sigwait" class="headerlink" title="sigwait()"></a>sigwait()</h2><ul>
<li>功能：从<code>set</code>中选择任何挂起的信号或等待任何一个信号到达</li>
<li>原型：<code>int sigwait(const sigset_t *set, int sig);</code></li>
<li>参数：<ul>
<li><code>set</code>  –  信号集</li>
<li><code>sig</code>  –</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  </li>
<li>失败  –</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;signal.h&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li>sigwait是同步的等待信号的到来，而不是像进程中那样是异步的等待信号的到来</li>
<li>sigwait函数使用一个信号集作为他的参数，并且在集合中的任一个信号发生时返回该信号值，解除阻塞，然后可以针对该信号进行一些相应的处理。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_01_%E5%B8%B8%E7%94%A8%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_01_%E5%B8%B8%E7%94%A8%E5%BA%93/" class="post-title-link" itemprop="url">C++_04_01_常用库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="C-处理CSV文件的库"><a href="#C-处理CSV文件的库" class="headerlink" title="C++ 处理CSV文件的库"></a>C++ 处理CSV文件的库</h2><p>在C++中处理CSV文件的常用库包括一些开源库和标准文件流库。这里介绍几种常用的C++库来读取、写入和处理CSV文件。</p>
<h3 id="1-CSV-parser"><a href="#1-CSV-parser" class="headerlink" title="1. CSV-parser"></a>1. <strong>CSV-parser</strong></h3><ul>
<li><strong>简介</strong>：<code>CSV-parser</code> 是一个轻量级的开源C++库，用于读取和解析CSV文件。它基于现代C++（C++11及以上），提供了简单的接口，可以方便地处理带有标题行的CSV文件。</li>
<li><strong>优点</strong>：速度快，支持流式读取，支持单行读取，也支持按列名读取数据。</li>
<li><strong>安装</strong>：通过 <code>CMake</code> 或将源文件直接加入到项目中。</li>
</ul>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csv.hpp&quot;</span>  <span class="comment">// 需要包含csv-parser头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">io::CSVReader&lt;2&gt; <span class="title">in</span><span class="params">(<span class="string">&quot;sample.csv&quot;</span>)</span></span>;  <span class="comment">// 指定列数</span></span><br><span class="line">    in.<span class="built_in">read_header</span>(io::ignore_extra_column, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>); <span class="comment">// 指定列标题</span></span><br><span class="line">    std::string name; <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">while</span>(in.<span class="built_in">read_row</span>(name, age))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>GitHub地址</strong>: <a target="_blank" rel="noopener" href="https://github.com/vincentlaucsb/csv-parser">CSV-parser</a></li>
</ul>
<h3 id="2-libcsv"><a href="#2-libcsv" class="headerlink" title="2. libcsv"></a>2. <strong>libcsv</strong></h3><ul>
<li><strong>简介</strong>：<code>libcsv</code> 是一个小巧且高效的CSV解析库，用于快速解析CSV文件。它用C语言编写，因此可以方便地在C++项目中使用。</li>
<li><strong>优点</strong>：占用内存少，解析速度快，适用于大型CSV文件。</li>
<li><strong>缺点</strong>：接口相对底层，需要用户手动处理字段解析，比较适合对CSV文件结构有控制的情况。</li>
</ul>
<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libcsv.h&quot;</span> <span class="comment">// 包含libcsv头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb1</span> <span class="params">(<span class="type">void</span> *s, <span class="type">size_t</span> i, <span class="type">void</span> *userdata)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">field</span><span class="params">((<span class="type">char</span> *)s, i)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Field: &quot;</span> &lt;&lt; field &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb2</span> <span class="params">(<span class="type">int</span> c, <span class="type">void</span> *userdata)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of row&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    csv_parser p;</span><br><span class="line">    <span class="built_in">csv_init</span>(&amp;p, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;name,age\nAlice,30\nBob,25&quot;</span>;</span><br><span class="line">    <span class="built_in">csv_parse</span>(&amp;p, buf, <span class="built_in">sizeof</span>(buf), cb1, cb2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">csv_fini</span>(&amp;p, cb1, cb2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">csv_free</span>(&amp;p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>GitHub地址</strong>: <a target="_blank" rel="noopener" href="https://github.com/rgamble/libcsv">libcsv</a></li>
</ul>
<h3 id="3-Fast-C-CSV-Parser"><a href="#3-Fast-C-CSV-Parser" class="headerlink" title="3. Fast C++ CSV Parser"></a>3. <strong>Fast C++ CSV Parser</strong></h3><ul>
<li><strong>简介</strong>：<code>Fast C++ CSV Parser</code> 是一个专门为处理大数据量CSV文件设计的C++库，适合读取大文件时使用。该库基于多线程并行读取CSV文件，非常高效。</li>
<li><strong>优点</strong>：高效，支持多线程，适合大文件。</li>
<li><strong>缺点</strong>：不支持CSV写入，只能用于读取。</li>
</ul>
<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csv.h&quot;</span> <span class="comment">// Fast C++ CSV Parser 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">io::CSVReader&lt;2&gt; <span class="title">in</span><span class="params">(<span class="string">&quot;sample.csv&quot;</span>)</span></span>; <span class="comment">// 定义列数</span></span><br><span class="line">    in.<span class="built_in">read_header</span>(io::ignore_extra_column, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>); <span class="comment">// 设定标题</span></span><br><span class="line">    std::string name; <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">while</span>(in.<span class="built_in">read_row</span>(name, age)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>GitHub地址</strong>: <a target="_blank" rel="noopener" href="https://github.com/ben-strasser/fast-cpp-csv-parser">Fast C++ CSV Parser</a></li>
</ul>
<h3 id="4-使用-C-标准库（fstream）"><a href="#4-使用-C-标准库（fstream）" class="headerlink" title="4. 使用 C++ 标准库（fstream）"></a>4. <strong>使用 C++ 标准库（fstream）</strong></h3><p>如果CSV文件格式非常简单，您也可以使用 C++ 标准库 <code>fstream</code> 直接进行文件的读取和解析。<code>fstream</code> 足够灵活，可以手动控制CSV解析。</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;sample.csv&quot;</span>)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">        <span class="function">std::stringstream <span class="title">lineStream</span><span class="params">(line)</span></span>;</span><br><span class="line">        std::string cell;</span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">getline</span>(lineStream, cell, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Cell: &quot;</span> &lt;&lt; cell &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>CSV-parser</strong> 和 <strong>Fast C++ CSV Parser</strong> 适合处理带有标题的较大CSV文件。</li>
<li><strong>libcsv</strong> 适合性能要求高的场景，可以手动解析字段。</li>
<li><strong>fstream</strong> 是标准方法，适合格式简单或文件较小的情况。</li>
</ul>
<h2 id="C-保存成excel文件的第三方库"><a href="#C-保存成excel文件的第三方库" class="headerlink" title="C++ 保存成excel文件的第三方库"></a>C++ 保存成excel文件的第三方库</h2><p>在C++中保存数据为Excel文件通常需要借助第三方库，因为标准库不直接支持Excel格式。以下是一些常用的C++ Excel操作库：</p>
<h3 id="1-xlnt"><a href="#1-xlnt" class="headerlink" title="1. xlnt"></a>1. <strong>xlnt</strong></h3><ul>
<li><p><strong>简介</strong>：<code>xlnt</code> 是一个开源库，支持读写Excel的.xlsx文件格式。支持创建、修改单元格、设置样式等。</p>
</li>
<li><p><strong>优点</strong>：操作简单，兼容性好，支持跨平台（Windows、Linux、macOS）。</p>
</li>
<li><p><strong>缺点</strong>：仅支持.xlsx格式，不支持.xls格式。</p>
</li>
<li><p><strong>安装</strong>：可以通过<code>CMake</code>进行安装，并且它没有依赖于Microsoft Excel或其他外部软件。</p>
</li>
<li><p><strong>GitHub地址</strong>: <a target="_blank" rel="noopener" href="https://github.com/tfussell/xlnt">xlnt</a></p>
</li>
</ul>
<h3 id="2-libxlsxwriter"><a href="#2-libxlsxwriter" class="headerlink" title="2. libxlsxwriter"></a>2. <strong>libxlsxwriter</strong></h3><ul>
<li><p><strong>简介</strong>：<code>libxlsxwriter</code> 是一个用C语言编写的轻量级库，专门用于生成Excel的.xlsx文件，适用于生成大批量Excel文件的情境。</p>
</li>
<li><p><strong>优点</strong>：速度快、支持图表、数据验证、格式化等功能，适用于生成复杂的Excel表格。</p>
</li>
<li><p><strong>缺点</strong>：仅支持.xlsx格式，不能读取现有的Excel文件。</p>
</li>
<li><p><strong>安装</strong>：提供了CMake支持，依赖少。</p>
</li>
<li><p><strong>GitHub地址</strong>: <a target="_blank" rel="noopener" href="https://github.com/jmcnamara/libxlsxwriter">libxlsxwriter</a></p>
</li>
</ul>
<h3 id="3-SpreadsheetLight-基于Open-XML-SDK"><a href="#3-SpreadsheetLight-基于Open-XML-SDK" class="headerlink" title="3. SpreadsheetLight (基于Open XML SDK)"></a>3. <strong>SpreadsheetLight (基于Open XML SDK)</strong></h3><ul>
<li><p><strong>简介</strong>：<code>SpreadsheetLight</code> 是一个基于Open XML SDK的C++库，可以轻松生成、读取、编辑.xlsx文件。</p>
</li>
<li><p><strong>优点</strong>：支持自定义样式、图表等功能，适合Windows环境。</p>
</li>
<li><p><strong>缺点</strong>：支持较为局限，不跨平台，主要依赖于Windows和.NET环境。</p>
</li>
<li><p><strong>官网地址</strong>: <a target="_blank" rel="noopener" href="https://spreadsheetlight.com/">SpreadsheetLight</a></p>
</li>
</ul>
<h3 id="4-QtXlsxWriter-适用于Qt"><a href="#4-QtXlsxWriter-适用于Qt" class="headerlink" title="4. QtXlsxWriter (适用于Qt)"></a>4. <strong>QtXlsxWriter (适用于Qt)</strong></h3><ul>
<li><strong>简介</strong>：这是一个适用于Qt应用程序的库，可以用于读写Excel的.xlsx文件。Qt应用程序可以直接集成，支持自定义格式。</li>
<li><strong>优点</strong>：与Qt生态系统完美集成，适合需要UI的C++项目。</li>
<li><strong>缺点</strong>：依赖于Qt框架，仅支持.xlsx格式。</li>
<li><strong>GitHub地址</strong>: <a target="_blank" rel="noopener" href="https://github.com/dbzhang800/QtXlsxWriter">QtXlsxWriter</a></li>
</ul>
<h3 id="5-Apache-POI-通过JNI调用"><a href="#5-Apache-POI-通过JNI调用" class="headerlink" title="5. Apache POI (通过JNI调用)"></a>5. <strong>Apache POI (通过JNI调用)</strong></h3><ul>
<li><p><strong>简介</strong>：Apache POI 是一个Java库，支持.xls和.xlsx格式，可以通过JNI在C++中调用它实现Excel文件操作。</p>
</li>
<li><p><strong>优点</strong>：支持丰富的Excel功能，如图表、格式化、函数等。</p>
</li>
<li><p><strong>缺点</strong>：需要Java运行环境，集成较为复杂。</p>
</li>
<li><p><strong>官网地址</strong>: <a target="_blank" rel="noopener" href="https://poi.apache.org/">Apache POI</a></p>
</li>
</ul>
<h3 id="选择建议："><a href="#选择建议：" class="headerlink" title="选择建议："></a>选择建议：</h3><ul>
<li>如果主要是生成.xlsx文件并希望跨平台，推荐 <code>libxlsxwriter</code> 和 <code>xlnt</code>。</li>
<li>如果使用Qt开发应用程序，<code>QtXlsxWriter</code> 是较为合适的选择。</li>
<li>若需要同时支持读取和写入并支持.xls格式，可考虑通过JNI调用Apache POI。</li>
</ul>
<h2 id="C-参数解析库"><a href="#C-参数解析库" class="headerlink" title="C++ 参数解析库"></a>C++ 参数解析库</h2><p>在 C++ 中，参数解析库可以帮助开发者处理命令行参数，并将其转换为更易处理的格式。以下是一些常用的 C++ 参数解析库及其特点：</p>
<h3 id="1-Boost-Program-options"><a href="#1-Boost-Program-options" class="headerlink" title="1. Boost.Program_options"></a>1. <strong>Boost.Program_options</strong></h3><ul>
<li><strong>特性</strong>：<ul>
<li>功能强大，支持命令行参数、配置文件和环境变量的解析。</li>
<li>提供详细的帮助信息生成。</li>
<li>支持短选项（如 <code>-h</code>）和长选项（如 <code>--help</code>）。</li>
</ul>
</li>
<li><strong>适用场景</strong>：需要处理复杂的参数格式和高级配置场景时非常有用。</li>
<li><strong>用法示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/program_options.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> po = boost::program_options;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">po::options_description <span class="title">desc</span><span class="params">(<span class="string">&quot;Allowed options&quot;</span>)</span></span>;</span><br><span class="line">    desc.<span class="built_in">add_options</span>()</span><br><span class="line">        (<span class="string">&quot;help&quot;</span>, <span class="string">&quot;produce help message&quot;</span>)</span><br><span class="line">        (<span class="string">&quot;compression&quot;</span>, po::<span class="built_in">value</span>&lt;<span class="type">int</span>&gt;(), <span class="string">&quot;set compression level&quot;</span>);</span><br><span class="line"></span><br><span class="line">    po::variables_map vm;</span><br><span class="line">    po::<span class="built_in">store</span>(po::<span class="built_in">parse_command_line</span>(argc, argv, desc), vm);</span><br><span class="line">    po::<span class="built_in">notify</span>(vm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="built_in">count</span>(<span class="string">&quot;help&quot;</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; desc &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="built_in">count</span>(<span class="string">&quot;compression&quot;</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Compression level was set to &quot;</span></span><br><span class="line">                  &lt;&lt; vm[<span class="string">&quot;compression&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">int</span>&gt;() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-cxxopts"><a href="#2-cxxopts" class="headerlink" title="2. cxxopts"></a>2. <strong>cxxopts</strong></h3><ul>
<li><strong>特性</strong>：<ul>
<li>轻量级，设计简单，支持大多数常见的参数解析需求。</li>
<li>支持短选项、长选项和带参数的选项。</li>
<li>生成帮助信息。</li>
</ul>
</li>
<li><strong>适用场景</strong>：项目对库的依赖要求较低时，适合使用此库。</li>
<li><strong>用法示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cxxopts.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">cxxopts::Options <span class="title">options</span><span class="params">(<span class="string">&quot;MyProgram&quot;</span>, <span class="string">&quot;A brief description&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    options.<span class="built_in">add_options</span>()</span><br><span class="line">        (<span class="string">&quot;h,help&quot;</span>, <span class="string">&quot;Print help&quot;</span>)</span><br><span class="line">        (<span class="string">&quot;i,input&quot;</span>, <span class="string">&quot;Input file&quot;</span>, cxxopts::<span class="built_in">value</span>&lt;std::string&gt;())</span><br><span class="line">        (<span class="string">&quot;v,verbose&quot;</span>, <span class="string">&quot;Verbose output&quot;</span>, cxxopts::<span class="built_in">value</span>&lt;<span class="type">bool</span>&gt;()-&gt;<span class="built_in">default_value</span>(<span class="string">&quot;false&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> result = options.<span class="built_in">parse</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">count</span>(<span class="string">&quot;help&quot;</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; options.<span class="built_in">help</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">count</span>(<span class="string">&quot;input&quot;</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Input file: &quot;</span> &lt;&lt; result[<span class="string">&quot;input&quot;</span>].<span class="built_in">as</span>&lt;std::string&gt;() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> verbose = result[<span class="string">&quot;verbose&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">bool</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Verbose mode enabled&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-CLI11"><a href="#3-CLI11" class="headerlink" title="3. CLI11"></a>3. <strong>CLI11</strong></h3><ul>
<li><strong>特性</strong>：<ul>
<li>支持复杂命令行解析，包括子命令、多值选项等。</li>
<li>提供多种错误处理和帮助信息生成。</li>
<li>能处理层次化的命令行参数。</li>
</ul>
</li>
<li><strong>适用场景</strong>：适合复杂的命令行程序，例如包含子命令的工具。</li>
<li><strong>用法示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CLI/CLI.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    CLI::App app&#123;<span class="string">&quot;My Program&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::string filename;</span><br><span class="line">    <span class="type">bool</span> verbose = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    app.<span class="built_in">add_option</span>(<span class="string">&quot;-f,--file&quot;</span>, filename, <span class="string">&quot;Input file&quot;</span>);</span><br><span class="line">    app.<span class="built_in">add_flag</span>(<span class="string">&quot;-v,--verbose&quot;</span>, verbose, <span class="string">&quot;Verbose output&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CLI11_PARSE</span>(app, argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Verbose mode enabled&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filename.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Input file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-TCLAP-Templatized-C-Command-Line-Argument-Parser"><a href="#4-TCLAP-Templatized-C-Command-Line-Argument-Parser" class="headerlink" title="4. TCLAP (Templatized C++ Command Line Argument Parser)"></a>4. <strong>TCLAP (Templatized C++ Command Line Argument Parser)</strong></h3><ul>
<li><strong>特性</strong>：<ul>
<li>简单易用，基于模板的参数解析库。</li>
<li>支持自动生成帮助信息。</li>
</ul>
</li>
<li><strong>适用场景</strong>：适合简单的命令行工具开发，使用模板使得代码更加灵活。</li>
<li><strong>用法示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tclap/CmdLine.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">TCLAP::CmdLine <span class="title">cmd</span><span class="params">(<span class="string">&quot;Command description&quot;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&quot;0.1&quot;</span>)</span></span>;</span><br><span class="line">        <span class="function">TCLAP::ValueArg&lt;std::string&gt; <span class="title">inputArg</span><span class="params">(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;input&quot;</span>, <span class="string">&quot;Input file&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;string&quot;</span>)</span></span>;</span><br><span class="line">        cmd.<span class="built_in">add</span>(inputArg);</span><br><span class="line"></span><br><span class="line">        <span class="function">TCLAP::SwitchArg <span class="title">verboseSwitch</span><span class="params">(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;verbose&quot;</span>, <span class="string">&quot;Verbose output&quot;</span>, cmd, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        cmd.<span class="built_in">parse</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">        std::string inputFile = inputArg.<span class="built_in">getValue</span>();</span><br><span class="line">        <span class="type">bool</span> verbose = verboseSwitch.<span class="built_in">getValue</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Verbose mode enabled&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Input file: &quot;</span> &lt;&lt; inputFile &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (TCLAP::ArgException &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">error</span>() &lt;&lt; <span class="string">&quot; for arg &quot;</span> &lt;&lt; e.<span class="built_in">argId</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-argparse"><a href="#5-argparse" class="headerlink" title="5. argparse"></a>5. <strong>argparse</strong></h3><ul>
<li><strong>特性</strong>：<ul>
<li>类似 Python 的 argparse 库，使用方便，语法直观。</li>
<li>支持默认值、位置参数、选项参数等功能。</li>
</ul>
</li>
<li><strong>适用场景</strong>：需要类似 Python argparse 风格的参数解析时非常合适。</li>
<li><strong>用法示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;argparse/argparse.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function">argparse::ArgumentParser <span class="title">program</span><span class="params">(<span class="string">&quot;example&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    program.<span class="built_in">add_argument</span>(<span class="string">&quot;filename&quot;</span>)</span><br><span class="line">        .<span class="built_in">help</span>(<span class="string">&quot;Input file name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    program.<span class="built_in">add_argument</span>(<span class="string">&quot;-v&quot;</span>, <span class="string">&quot;--verbose&quot;</span>)</span><br><span class="line">        .<span class="built_in">default_value</span>(<span class="literal">false</span>)</span><br><span class="line">        .<span class="built_in">implicit_value</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="built_in">help</span>(<span class="string">&quot;Enable verbose mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        program.<span class="built_in">parse_args</span>(argc, argv);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; err) &#123;</span><br><span class="line">        std::cerr &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; program;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string filename = program.<span class="built_in">get</span>&lt;std::string&gt;(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line">    <span class="type">bool</span> verbose = program.<span class="built_in">get</span>&lt;<span class="type">bool</span>&gt;(<span class="string">&quot;--verbose&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Verbose mode enabled&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Input file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>根据项目的需求选择合适的参数解析库：</p>
<ul>
<li><strong>Boost.Program_options</strong>：适合复杂需求的项目，但需要依赖 Boost。</li>
<li><strong>cxxopts</strong> 和 <strong>CLI11</strong>：轻量级且功能强大，适合大部分项目。</li>
<li><strong>TCLAP</strong>：简单、基于模板，适合喜欢模板编程的开发者。</li>
<li><strong>argparse</strong>：语法简洁，适合喜欢 Python argparse 风格的开发者。</li>
</ul>
<p>你可以根据项目的复杂度、依赖管理要求以及个人偏好选择合适的库。</p>
<h2 id="libxmu-dev"><a href="#libxmu-dev" class="headerlink" title="libxmu-dev"></a>libxmu-dev</h2><p><code>libxmu-dev</code> 是针对 Linux 操作系统的一个开发包，用于开发基于 X Window 系统的图形用户界面应用程序。下面我将为你详细解释一下这个开发包的相关内容。</p>
<ol>
<li><p><strong>X Window 系统</strong>：X Window 系统，也称为 X11，是一种用于图形界面的基础架构，允许在计算机屏幕上绘制图形和显示图像。它提供了基本的图形绘制、窗口管理、用户输入等功能，是许多图形用户界面环境的基础。</p>
</li>
<li><p><strong>libxmu-dev 包含的内容</strong>：<code>libxmu-dev</code> 是一个开发包，提供了与 X Window 系统和 Xlib 相关的头文件和库文件，以便开发者能够创建使用 X Window 系统的图形界面应用程序。这个开发包的内容包括：</p>
<ul>
<li><p><strong>头文件（Header Files）</strong>：这些头文件包含了与 Xlib 库函数和数据结构相关的声明，使开发者能够在代码中使用这些函数和结构体。头文件的扩展名通常是 <code>.h</code>。</p>
</li>
<li><p><strong>库文件（Library Files）</strong>：库文件包含了编译好的 Xlib 库函数的二进制代码，这些库可以在链接时与应用程序一起使用。库文件的扩展名通常是 <code>.a</code>（静态库）或 <code>.so</code>（共享库）。</p>
</li>
</ul>
</li>
<li><p><strong>Xlib 库</strong>：Xlib 是 X Window 系统的客户端库，它提供了一组函数和数据结构，用于与 X 服务器进行通信、创建窗口、处理事件、绘制图形等。通过使用 Xlib，开发者可以在应用程序中管理窗口、绘制图形元素、响应用户输入等。</p>
</li>
<li><p><strong>Xmu 库</strong>：Xmu 是 X Window 系统的辅助库，它建立在 Xlib 之上，提供了一些常见的功能，如字符串处理、几何结构操作、资源管理等。<code>libxmu-dev</code> 中的文件可能包括 Xmu 库的头文件和库文件，使开发者能够更方便地使用这些功能。</p>
</li>
</ol>
<p>总之，<code>libxmu-dev</code> 提供了开发基于 X Window 系统的图形界面应用程序所需的工具和资源，包括 Xlib 和 Xmu 库的头文件和库文件。通过使用这些工具，开发者可以创建具有丰富图形界面的应用程序，处理窗口、事件、图形绘制等任务。</p>
<h2 id="linux-vdso-so"><a href="#linux-vdso-so" class="headerlink" title="linux-vdso.so"></a>linux-vdso.so</h2><ul>
<li>linux-vdso.so.1 是一个特殊的动态链接库，它在 Linux 系统中起着重要的作用。VDSO 是 Virtual Dynamic Shared Object（虚拟动态共享对象）的缩写，它是 Linux 内核提供的一种特殊的机制，用于在用户空间和内核空间之间进行高效的系统调用。</li>
<li>linux-vdso.so.1 库实际上不是一个真正的共享库文件，而是内核在每个进程的地址空间中映射的一个虚拟文件。它通过特殊的技术将一些常见的系统调用实现以内联汇编的方式嵌入到用户空间程序中，避免了频繁的用户态到内核态的切换。</li>
<li>通过使用 VDSO，一些常见的系统调用，例如获取当前时间、获取进程 ID、获取系统调用号等，可以在用户空间直接执行，而无需陷入内核执行。这大大减少了系统调用的开销，提高了程序的性能。</li>
<li>linux-vdso.so.1 是一个系统生成的文件，其路径通常为 “&#x2F;lib&#x2F;ld-linux.so.2” 或 “&#x2F;lib&#x2F;ld-linux-armhf.so.3” 等，具体路径取决于系统架构和配置。</li>
<li>需要注意的是，由于 linux-vdso.so.1 是在内核启动时动态生成的，因此你不会在文件系统中找到实际的库文件。它在运行时通过内核的机制自动映射到每个进程的地址空间中。</li>
</ul>
<h2 id="ld-linux-armhf-so"><a href="#ld-linux-armhf-so" class="headerlink" title="ld-linux-armhf.so"></a>ld-linux-armhf.so</h2><ul>
<li>ld-linux-armhf.so 是 ARM 架构上的动态链接器，用于在 ARM 处理器上运行基于动态链接的可执行文件。它是 Linux 系统中的一部分，用于加载和解析可执行文件以及它们所依赖的动态链接库。</li>
<li>动态链接器（linker）是一个系统组件，负责在运行时将可执行文件和动态链接库组合在一起，解决符号引用，建立程序的运行环境，并开始执行程序。</li>
<li>ld-linux-armhf.so 针对 ARM 架构上的硬浮点 ABI（Application Binary Interface）进行了优化。它确保可执行文件和动态链接库在 ARM 架构上以正确的方式加载和运行，并与其他系统组件协同工作。</li>
<li>需要注意的是，ld-linux-armhf.so 的名称可能会因操作系统版本、发行版或具体的 ARM 架构变体而有所不同。不同的 ARM 架构和操作系统可能使用不同的链接器名称和路径。</li>
</ul>
<h2 id="libpostproc-so"><a href="#libpostproc-so" class="headerlink" title="libpostproc.so"></a>libpostproc.so</h2><ul>
<li>libpostproc.so 是 FFmpeg 多媒体处理库中的一个动态链接库（shared library）文件。FFmpeg 是一个开源的跨平台多媒体框架，用于处理音频、视频和其他多媒体数据。</li>
<li>libpostproc.so 库提供了视频后处理的功能，包括图像滤镜、色彩空间转换、图像调整等。它可以用于在视频处理过程中对图像进行修正、增强和优化，提供更好的视觉效果。</li>
<li>通过链接 libpostproc.so，开发人员可以在他们的应用程序中使用 FFmpeg 提供的视频后处理功能。这对于需要进行视频处理和编辑的应用程序、媒体播放器、转码工具等非常有用。</li>
<li>需要注意的是，libpostproc.so 是 FFmpeg 中的一部分，它是一个开源的项目，因此可以在多个平台上使用。在不同的操作系统和平台上，libpostproc.so 的具体名称和路径可能会有所不同，但提供的视频后处理功能基本相似。</li>
</ul>
<h2 id="libdrm-so"><a href="#libdrm-so" class="headerlink" title="libdrm.so"></a>libdrm.so</h2><ul>
<li>libdrm.so 是一个常见的动态链接库（shared library）文件，它是 Direct Rendering Manager（DRM）的一部分。DRM 是一个用于在 Linux 系统上管理图形设备的子系统，它提供了与显示服务器、图形驱动程序和用户空间应用程序之间的接口。</li>
<li>libdrm.so 库提供了一组函数，用于与 DRM 子系统进行交互和通信。它允许用户空间应用程序通过 DRM 接口与图形设备进行交互，进行诸如显示输出、图形渲染、硬件加速等操作。</li>
<li>通过链接 libdrm.so，开发人员可以编写应用程序来管理图形设备，并利用 DRM 提供的功能，如显示模式设置、缓冲区管理、2D&#x2F;3D 图形渲染等。</li>
<li>需要注意的是，libdrm.so 是特定于 Linux 系统上的 DRM 子系统的库文件。它是在 DRM 子系统和图形驱动程序之间进行通信的桥梁，提供了对图形设备的访问和控制。在不同的 Linux 发行版和不同的图形硬件上，libdrm.so 的具体实现和用法可能会有所不同。</li>
</ul>
<h2 id="libgcc-s-so"><a href="#libgcc-s-so" class="headerlink" title="libgcc_s.so"></a>libgcc_s.so</h2><ul>
<li>libgcc_s.so 是一个常见的动态链接库（shared library）文件，它是 GCC（GNU Compiler Collection）的运行时支持库之一。”libgcc_s” 代表 “libgcc support”，该库提供了在使用 GCC 编译的程序中所需的一些运行时支持。</li>
<li>libgcc_s.so 库提供了一些与编译器相关的支持函数和运行时环境，用于处理一些特定的语言特性、异常处理、类型转换、整数运算等。它通常用于支持编译器生成的一些代码，以提供必要的运行时支持。</li>
<li>在某些情况下，使用 GCC 编译的程序可能依赖于 libgcc_s.so 库。当运行这些程序时，系统会自动加载和链接 libgcc_s.so，以提供所需的运行时支持。这通常是由于程序使用了一些与编译器相关的功能，或者使用了特定的编译选项。</li>
<li>需要注意的是，libgcc_s.so 是特定于 GCC 的库，因此在使用其他编译器或不同版本的 GCC 上编译的程序可能会使用不同的运行时支持库。在不同的操作系统和平台上，libgcc_s.so 的具体名称和路径可能会有所不同，但其目的和功能基本相似。</li>
</ul>
<h2 id="libstdc-so-6"><a href="#libstdc-so-6" class="headerlink" title="libstdc++.so.6"></a>libstdc++.so.6</h2><ul>
<li>libstdc++.so 是一个常见的动态链接库（shared library）文件，它是 GNU C++ 标准库（GNU C++ Standard Library）的一部分。”libstdc++” 代表 “Standard C++”，该库提供了 C++ 标准库的实现</li>
<li>libstdc++.so 库包含了各种与 C++ 相关的函数和类，如容器（vector、list、map）、算法（sort、find、transform）、输入输出（iostream、fstream）、字符串处理（string、stringstream）等</li>
<li>这个库是 C++ 编程中非常重要的一部分，它提供了 C++ 标准库的实现，包括常用的数据结构、算法、输入输出等功能，为 C++ 开发人员提供了丰富的工具和函数，简化了开发过程</li>
<li>通过链接 libstdc++.so，应用程序可以使用这些标准库函数和类，从而实现各种 C++ 编程任务，如数据结构操作、算法实现、文件读写、字符串处理等</li>
<li>需要注意的是，libstdc++.so 是在许多操作系统中的标准 C++ 库，包括 Linux、Unix 和类 Unix 系统。在不同的操作系统和平台上，libstdc++.so 的名称和具体实现可能会有所不同，但提供的标准库函数和用法基本上是相似的</li>
</ul>
<h2 id="libc-so-6"><a href="#libc-so-6" class="headerlink" title="libc.so.6"></a>libc.so.6</h2><ul>
<li>libc.so 是一个常见的动态链接库（shared library）文件，它是 C 语言标准库（C Standard Library）的一部分。”libc” 代表 “C”，该库提供了一系列 C 语言的标准函数和常用工具函数的实现</li>
<li>libc.so 库包含了各种常用的函数，例如内存操作函数（如malloc、free、memcpy、memset）、字符串操作函数（如strcpy、strcat、strlen）、文件操作函数（如fopen、fclose、fread、fwrite）、数学函数（如abs、sqrt、sin、cos）等</li>
<li>这个库是 C 语言编程中非常重要的一部分，它提供了许多基础的函数和工具，可以帮助开发人员进行内存管理、字符串处理、文件操作、数学计算等各种常见的任务。通过链接 libc.so，应用程序可以使用这些函数，从而简化了代码的编写和开发过程</li>
<li>需要注意的是，libc.so 是在许多操作系统中的标准 C 库，包括 Linux、Unix 和类 Unix 系统。在不同的操作系统和平台上，libc.so 的名称和具体实现可能会有所不同，但提供的标准函数和用法基本上是相似的</li>
</ul>
<h2 id="libm-so-6"><a href="#libm-so-6" class="headerlink" title="libm.so.6"></a>libm.so.6</h2><ul>
<li>libm.so 是一个常见的动态链接库（shared library）文件，它是数学库（Math Library）的一部分。”libm” 代表 “Math”，该库提供了许多数学函数的实现，供应用程序在运行时使用。</li>
<li>libm.so 库通常用于执行各种数学操作，例如三角函数、指数函数、对数函数、幂函数等。它包含了标准的数学函数库，使开发人员能够在程序中进行高级数学计算和操作，无需自己实现这些函数</li>
<li>该库提供的函数包括但不限于：sin、cos、tan、exp、log、pow、sqrt 等。通过链接 libm.so，应用程序可以调用这些函数来执行各种数学运算，从而简化了数学计算的实现过程。</li>
<li>需要注意的是，libm.so 是在许多操作系统中标准的数学库，包括 Linux、Unix 和类 Unix 系统。在不同的操作系统和平台上，libm.so 的名称和具体实现可能会有所不同，但提供的数学函数和用法基本上是相似的</li>
</ul>
<h2 id="libdl-so-动态加载共享库"><a href="#libdl-so-动态加载共享库" class="headerlink" title="libdl.so 动态加载共享库"></a>libdl.so 动态加载共享库</h2><ul>
<li>libdl.so 是一个动态链接库（shared library）文件，它是 Linux 操作系统中的一部分。”libdl” 代表 “Dynamic Loading”，该库提供了在运行时动态加载其他共享库的功能。在 Linux 系统中，动态链接库可以在程序执行过程中被加载和卸载，这样可以提供更灵活的代码组织和模块化开发的方式</li>
<li>libdl.so 库通常由应用程序使用，用于在运行时动态加载其他共享库。它提供了一组函数，例如 <code>dlopen()</code>、<code>dlsym()</code>、<code>dlclose()</code> 等，用于加载、查找和卸载其他库中的符号（函数、变量等）。这些函数可以让程序在运行时根据需要加载所需的库，并调用其中的函数或访问其中的变量。</li>
<li>通过 libdl.so，程序可以实现插件化架构、动态加载模块、实现扩展性等。这对于一些需要在运行时动态加载功能的程序，如插件系统、动态链接器、动态加载器等，非常有用</li>
<li>需要注意的是，libdl.so 是 Linux 系统中的库文件，而在其他操作系统中，类似的功能可能由其他库提供，而命名可能也有所不同</li>
</ul>
<p><code>libdl.so</code>是Linux系统上的动态链接库，它提供了动态加载和管理共享库的功能。与之对应的头文件是<code>dlfcn.h</code>，它包含了在使用<code>libdl.so</code>库时需要的函数和宏的声明。</p>
<p>以下是<code>dlfcn.h</code>头文件的常见函数和宏：</p>
<ol>
<li><p><code>dlopen</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数用于打开一个共享库文件，并返回一个指向库句柄的指针。<code>filename</code>参数是共享库文件的路径，<code>flags</code>参数指定了打开库的方式，如<code>RTLD_LAZY</code>表示在需要时才解析符号，<code>RTLD_NOW</code>表示立即解析符号等。</p>
</li>
<li><p><code>dlsym</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">dlsym</span><span class="params">(<span class="type">void</span>* handle, <span class="type">const</span> <span class="type">char</span>* symbol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数用于在打开的库中查找指定的符号，并返回符号对应的地址。<code>handle</code>参数是由<code>dlopen</code>返回的库句柄，<code>symbol</code>参数是要查找的符号的名称。</p>
</li>
<li><p><code>dlclose</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dlclose</span><span class="params">(<span class="type">void</span>* handle)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数用于关闭打开的库。<code>handle</code>参数是要关闭的库的句柄。</p>
</li>
<li><p><code>dlerror</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">dlerror</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数返回上一个动态库函数调用的错误信息。如果没有错误发生，则返回<code>NULL</code>。</p>
</li>
</ol>
<p>上述函数和宏的声明都可以在<code>dlfcn.h</code>头文件中找到。为了使用这些函数和宏，需要在C&#x2F;C++源文件中包含<code>dlfcn.h</code>头文件：<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样，你就可以使用<code>libdl.so</code>库提供的动态加载和管理共享库的功能了。请注意，这些函数和宏在不同的操作系统和平台上可能会有所差异，因此在编写跨平台代码时需要注意相关的兼容性问题。</p>
<h2 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h2><ul>
<li><code>EPERM</code>	  	<code> 1</code>	 Operation not permitted </li>
<li><code>ENOENT</code> 		<code> 2</code>	 No such file or directory </li>
<li><code>ESRCH</code>		  <code> 3</code>	 No such process </li>
<li><code>EINTR</code>		  <code> 4</code>	 Interrupted system call </li>
<li><code>EIO</code>		    <code> 5</code>	 I&#x2F;O error </li>
<li><code>ENXIO</code>		  <code> 6</code>	 No such device or address </li>
<li><code>E2BIG</code>		  <code> 7</code>	 Argument list too long </li>
<li><code>ENOEXEC</code>		<code> 8</code>	 Exec format error </li>
<li><code>EBADF</code>		  <code> 9</code>	 Bad file number </li>
<li><code>ECHILD</code>		<code>10</code>	 No child processes </li>
<li><code>EAGAIN</code>		<code>11</code>	 Try again </li>
<li><code>ENOMEM</code>		<code>12</code>	 Out of memory </li>
<li><code>EACCES</code>		<code>13</code>	 Permission denied </li>
<li><code>EFAULT</code>		<code>14</code>	 Bad address </li>
<li><code>ENOTBLK</code>		<code>15</code>	 Block device required </li>
<li><code>EBUSY</code>		  <code>16</code>	 Device or resource busy </li>
<li><code>EEXIST</code>		<code>17</code>	 File exists </li>
<li><code>EXDEV</code>		  <code>18</code>	 Cross-device link </li>
<li><code>ENODEV</code>		<code>19</code>	 No such device </li>
<li><code>ENOTDIR</code>		<code>20</code>	 Not a directory </li>
<li><code>EISDIR</code>		<code>21</code>	 Is a directory </li>
<li><code>EINVAL</code>		<code>22</code>	 Invalid argument </li>
<li><code>ENFILE</code>		<code>23</code>	 File table overflow </li>
<li><code>EMFILE</code>		<code>24</code>	 Too many open files </li>
<li><code>ENOTTY</code>		<code>25</code>	 Not a typewriter </li>
<li><code>ETXTBSY</code>		<code>26</code>	 Text file busy </li>
<li><code>EFBIG</code>		  <code>27</code>	 File too large </li>
<li><code>ENOSPC</code>		<code>28</code>	 No space left on device </li>
<li><code>ESPIPE</code>		<code>29</code>	 Illegal seek </li>
<li><code>EROFS</code>		  <code>30</code>	 Read-only file system </li>
<li><code>EMLINK</code>		<code>31</code>	 Too many links </li>
<li><code>EPIPE</code>		  <code>32</code>	 Broken pipe </li>
<li><code>EDOM</code>		  <code>33</code>	 Math argument out of domain of func </li>
<li><code>ERANGE</code>		<code>34</code>	 Math result not representable</li>
</ul>
<h2 id="sscanf-正则表达式"><a href="#sscanf-正则表达式" class="headerlink" title="sscanf() 正则表达式"></a>sscanf() 正则表达式</h2><ul>
<li><p>C++处理字符串的工具函数</p>
<ul>
<li><code>strcpy, strcat, strlen, strstr</code></li>
<li><code>sscanf + 正则表达式</code></li>
</ul>
</li>
<li><p>函数声明：<code>int sscanf(const char *buffer, const char *format, [ argument ]...);</code></p>
</li>
<li><p>其中最重要的参数就是<code>format</code>，它可以是一个或多个<code>&#123; %[*][width][&#123;h|I|I64|L&#125;]type|&#39; &#39;|&#39;\t&#39;| &#39;\n&#39;|非%符号&#125;</code></p>
</li>
<li><p>常用元字符释义</p>
<ul>
<li><code>*</code>也可以用于格式中, (即 <code>%*d</code> 和 <code>%*s</code>) 加了星号 (<code>*</code>) 表示跳过此数据不读入，也就是不把此数据读入参数中。</li>
<li><code>&#123;a|b|c&#125;</code>表示a,b,c中选一，<code>[d]</code>表示可以有d也可以没有d</li>
<li>width表示读取宽度。</li>
<li><code>&#123;h | l | I64 | L&#125;</code>:参数的<code>size</code>,通常<code>h</code>表示单字节size，<code>I</code>表示2字节 size，<code>L</code>表示4字节size(double例外)，<code>l64</code>表示8字节size。</li>
<li><code>type</code>:这一项比较多，就是<code>%s</code>、<code>%d</code>之类。</li>
<li>特别的：<code>%*[width] [&#123;h | l | I64 | L&#125;]type</code> 表示满足该条件的被过滤掉，不会向目标参数中写入值。</li>
<li>未成功匹配返回0 ，否则返回格式化的参数个数。</li>
</ul>
</li>
</ul>
<h2 id="宏定义，宏函数，内置宏，常用宏"><a href="#宏定义，宏函数，内置宏，常用宏" class="headerlink" title="宏定义，宏函数，内置宏，常用宏"></a>宏定义，宏函数，内置宏，常用宏</h2><ul>
<li>在C语言中，变量类型，循环控制，基础语法等与其他高级语言基本无异；</li>
<li>而C语言(C++)特有的两把双刃剑–指针和宏定义&#x2F;宏函数，使得C&#x2F;C++在底层开发中披荆斩棘，无所不能</li>
</ul>
<h3 id="常用宏定义"><a href="#常用宏定义" class="headerlink" title="常用宏定义"></a>常用宏定义</h3><ul>
<li><p>防止一个头文件被重复包含</p>
<ul>
<li><code>#ifndef ICE_BASE_HPP</code></li>
<li><code>#define ICE_BASE_HPP</code></li>
<li><code>#endif  //ICE_BASE_HPP</code></li>
</ul>
</li>
<li><p>重新定义一些类型，防止由于各种平台和编译器的不同，而产生的类型字节数差异，方便移植。</p>
<ul>
<li><code>typedef  unsigned long int  uint32;      	/* Unsigned 32 bit value */</code></li>
</ul>
</li>
</ul>
<h3 id="内置宏"><a href="#内置宏" class="headerlink" title="内置宏"></a>内置宏</h3><ul>
<li>ANSI标准<ul>
<li><code>__LINE__</code></li>
<li><code>__FILE__</code></li>
<li><code>__DATE__</code></li>
<li><code>__TIME__</code></li>
<li><code>__TIME__</code></li>
<li><code>__STDC__</code></li>
</ul>
</li>
</ul>
<h3 id="BEGIN-DECLS"><a href="#BEGIN-DECLS" class="headerlink" title="__BEGIN_DECLS"></a><code>__BEGIN_DECLS</code></h3><ul>
<li><p>许多头文件中都有：</p>
<ul>
<li>文件开头有<code>__BEGIN_DECLS</code></li>
<li>文件结尾有<code>__END_DECLS</code></li>
</ul>
</li>
<li><p>它们是两个宏定义，声明为：</p>
<ul>
<li><code>#define __BEGIN_DECLS extern &quot;C&quot;&#123;</code></li>
<li><code>#define __END_DECLS   &#125;</code></li>
</ul>
</li>
</ul>
<h2 id="bits-socket-h"><a href="#bits-socket-h" class="headerlink" title="bits&#x2F;socket.h"></a>bits&#x2F;socket.h</h2><ul>
<li>特定于系统的套接字常量和类型</li>
<li>这个特定于操作系统的头文件定义了<code>SOCK_*</code>、<code>PF_*</code>、<code>AF_*</code>、<code>MSG_*</code>、<code>SOL_*</code>和<code>SO_*</code>常量，以及<code>struct sockaddr </code>、<code>struct msghdr </code>和<code>struct linger </code>类型。</li>
</ul>
<h3 id="struct-sockaddr"><a href="#struct-sockaddr" class="headerlink" title="struct sockaddr"></a>struct sockaddr</h3><ul>
<li>简述：描述通用套接字地址的结构</li>
<li>声明：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sa_);	<span class="comment">/* Common data: address family and length.  地址族 */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];		<span class="comment">/* Address data.  14字节，包含套接字中的目标地址和端口信息    */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
<li>注意：<ul>
<li>结构体用来处理网络通信的地址。</li>
<li>sockaddr的缺陷是：sa_data把目标地址和端口信息混在一起了，</li>
</ul>
</li>
</ul>
<h2 id="netinet-in-h"><a href="#netinet-in-h" class="headerlink" title="netinet&#x2F;in.h"></a>netinet&#x2F;in.h</h2><ul>
<li><p>网络协议相关数据结构的声明和定义</p>
</li>
<li><p>简述：描述因特网套接字地址的结构</p>
</li>
<li><p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin_);   <span class="comment">/* Address Family.   地址族 */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;			    <span class="comment">/* Port number.      16位TCP/UDP端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>		<span class="comment">/* Internet address. 32位IP地址  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr&#x27;.  不使用*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) -</span><br><span class="line">			   __SOCKADDR_COMMON_SIZE -</span><br><span class="line">			   <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) -</span><br><span class="line">			   <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：</p>
<ul>
<li>结构体用来处理网络通信的地址。</li>
<li>该结构体解决了sockaddr的缺陷，把port和addr 分开储存在两个变量中</li>
<li>该结构体中提到的另一个结构体in_addr定义如下 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Internet address.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>sin_port</code>和<code>sin_addr</code>都必须是网络字节序（<code>NBO</code>），一般可视化的数字都是主机字节序（<code>HBO</code>）</li>
</ul>
</li>
</ul>
<h2 id="sockaddr-in和sockaddr"><a href="#sockaddr-in和sockaddr" class="headerlink" title="sockaddr_in和sockaddr"></a>sockaddr_in和sockaddr</h2><ul>
<li><p>二者长度一样，都是16个字节，即占用的内存大小是一致的，因此可以互相转化。</p>
</li>
<li><p>二者是并列结构，指向<code>sockaddr_in</code>结构的指针也可以指向<code>sockaddr</code></p>
</li>
<li><p><code>sockaddr</code>常用于<code>bind</code>、<code>connect</code>、<code>recvfrom</code>、<code>sendto</code>等函数的参数，指明地址信息，是一种通用的套接字地址。</p>
</li>
<li><p><code>sockaddr_in</code> 是internet环境下套接字的地址形式。所以在网络编程中我们会对<code>sockaddr_in</code>结构体进行操作，使用<code>sockaddr_in</code>来建立所需的信息，最后使用类型转化就可以了。</p>
</li>
<li><p>一般先把<code>sockaddr_in</code>变量赋值后，强制类型转换后传入用<code>sockaddr</code>做参数的函数：</p>
<ul>
<li><code>sockaddr_in</code>用于socket定义和赋值；</li>
<li><code>sockaddr</code>用于函数参数</li>
</ul>
</li>
<li><p>另外 – 两个函数 htons() 和 inet_addr()</p>
<ul>
<li><code>htons()</code>作用是将端口号由主机字节序转换为网络字节序的整数值。(<code>host to net</code>)</li>
<li><code>inet_addr()</code>作用是将一个<code>IP</code>字符串转化为一个网络字节序的整数值，用于<code>sockaddr_in.sin_addr.s_addr</code></li>
<li><code>inet_ntoa()</code>作用是将一个<code>sin_addr</code>结构体输出成<code>IP</code>字符串(<code>network to ascii</code>)，例如<ul>
<li><code>printf(&quot;%s&quot;,inet_ntoa(mysock.sin_addr));</code></li>
</ul>
</li>
<li><code>htonl()</code>作用和<code>htons()</code>一样，不过它针对的是32位的（<code>long</code>），而<code>htons()</code>针对的是两个字节，16位的（<code>short</code>）</li>
<li>与<code>htonl()</code>和<code>htons()</code>作用相反的两个函数是：<code>ntohl()</code>和<code>ntohs()</code></li>
<li>它们的声明都在文件<code>netinet/in.h</code>中</li>
</ul>
</li>
</ul>
<h2 id="bits-sockaddr-h"><a href="#bits-sockaddr-h" class="headerlink" title="bits&#x2F;sockaddr.h"></a>bits&#x2F;sockaddr.h</h2><ul>
<li><p><code>struct sockaddr_*</code>通用成员和大小的定义，通用版本。</p>
</li>
<li><p><code>#define	__SOCKADDR_COMMON(sa_prefix) sa_family_t sa_prefix##family</code></p>
</li>
<li><p>这个宏用于声明用于套接字地址的数据类型的初始公共成员，<code>struct sockaddr </code>、<code>struct sockaddr_in </code>、<code>struct sockaddr_un </code>等。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_03_openssl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_03_openssl/" class="post-title-link" itemprop="url">C++_04_03_openssl</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>openssl库</li>
</ul>
<h2 id="C-OpenSSL库-详解"><a href="#C-OpenSSL库-详解" class="headerlink" title="C++ OpenSSL库 详解"></a>C++ OpenSSL库 详解</h2><p>OpenSSL 是一个功能强大且广泛使用的开源密码库，提供了许多加密算法和安全通信协议的实现，包括 SSL&#x2F;TLS。在 C++ 中使用 OpenSSL 库可以实现安全通信、加密解密等功能。下面是一个简要的 C++ OpenSSL 库的详解：</p>
<ol>
<li><p><strong>加密和解密</strong>：OpenSSL 提供了许多常见的加密算法，如对称加密算法（如 AES、DES）、非对称加密算法（如 RSA、DSA）以及哈希函数（如 MD5、SHA）。你可以使用这些算法来加密和解密数据，保护数据的安全性。</p>
</li>
<li><p><strong>SSL&#x2F;TLS 客户端和服务器</strong>：OpenSSL 支持 SSL&#x2F;TLS 协议，你可以使用 OpenSSL 库创建安全的客户端和服务器应用程序。通过 SSL&#x2F;TLS，你可以确保通信的机密性和完整性，防止中间人攻击等安全威胁。</p>
</li>
<li><p><strong>数字证书操作</strong>：OpenSSL 提供了对数字证书的生成、签名、验证等操作。数字证书在 SSL&#x2F;TLS 通信中起着重要的作用，用于身份验证和密钥交换。</p>
</li>
<li><p><strong>SSL&#x2F;TLS 握手过程</strong>：SSL&#x2F;TLS 握手是建立安全连接的过程，涉及到密钥协商、身份验证等步骤。OpenSSL 库提供了对 SSL&#x2F;TLS 握手过程的支持，你可以使用 OpenSSL 创建安全的网络通信应用程序。</p>
</li>
<li><p><strong>密码学工具</strong>：OpenSSL 还提供了许多密码学工具和实用程序，用于生成随机数、计算哈希值、生成公钥私钥对等操作。</p>
</li>
<li><p><strong>支持多种操作系统和平台</strong>：OpenSSL 是一个跨平台的库，可以在多种操作系统上运行，包括 Linux、Windows、macOS 等。</p>
</li>
<li><p><strong>开源和社区支持</strong>：OpenSSL 是一个开源项目，拥有活跃的社区支持和贡献者，可以从社区获取帮助、文档和示例代码。</p>
</li>
</ol>
<p>在 C++ 中使用 OpenSSL 库通常涉及到一些复杂的概念和操作，如密钥管理、证书操作、SSL 握手过程等。因此，熟悉 OpenSSL 库的使用方法和安全最佳实践对于开发安全的网络应用程序至关重要。在使用 OpenSSL 库时，务必注意安全问题，避免常见的安全漏洞和攻击。</p>
<h2 id="cmake-引用”openssl”库"><a href="#cmake-引用”openssl”库" class="headerlink" title="cmake 引用”openssl”库"></a>cmake 引用”openssl”库</h2><p>要在 CMake 中引用 OpenSSL 库，你可以遵循以下步骤：</p>
<ol>
<li><p><strong>查找 OpenSSL 库</strong>: 首先，确保已经在系统中安装了 OpenSSL 库。你需要知道 OpenSSL 库的安装路径。通常情况下，它可能安装在标准位置，但也可能在非标准位置。可以使用以下命令来查找 OpenSSL 库的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_package(OpenSSL REQUIRED)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>添加头文件路径</strong>: 在 CMakeLists.txt 文件中，使用 <code>include_directories</code> 命令将 OpenSSL 头文件路径添加到项目中。示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include_directories($&#123;OPENSSL_INCLUDE_DIR&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>链接 OpenSSL 库</strong>: 使用 <code>target_link_libraries</code> 命令将 OpenSSL 库链接到你的目标可执行文件或库中。示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(your_target_name $&#123;OPENSSL_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>完整示例</strong>: 下面是一个完整的示例 CMakeLists.txt 文件，演示如何引用 OpenSSL 库：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(your_project_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 OpenSSL 库</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenSSL REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 OpenSSL 头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OPENSSL_INCLUDE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加你的可执行文件或库</span></span><br><span class="line"><span class="keyword">add_executable</span>(your_executable_or_library_name your_source_files.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 OpenSSL 库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(your_executable_or_library_name <span class="variable">$&#123;OPENSSL_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>确保将 <code>your_project_name</code>、<code>your_executable_or_library_name</code> 和 <code>your_source_files.cpp</code> 替换为实际的项目名称、目标名称和源文件路径。</p>
<p>这样配置后，CMake 将会正确地链接 OpenSSL 库到你的项目中，使你能够在项目中使用 OpenSSL 提供的功能和 API。</p>
<h2 id="libcrypto-so"><a href="#libcrypto-so" class="headerlink" title="libcrypto.so"></a>libcrypto.so</h2><ul>
<li>libcrypto.so 是 OpenSSL 库中的一个动态链接库文件。OpenSSL 是一个开源的加密和安全套接字库，提供了密码学功能和安全通信协议的实现。</li>
<li>libcrypto.so 库包含了 OpenSSL 提供的各种加密算法、密码学函数和安全协议的实现。它提供了对对称加密算法（如 AES、DES）、哈希函数（如 SHA、MD5）、公钥加密算法（如 RSA、DSA）、数字签名和证书操作等功能的支持。</li>
<li>通过链接 libcrypto.so，开发人员可以在他们的应用程序中使用 OpenSSL 提供的加密和安全功能。这对于需要进行加密通信、数字签名、证书验证和其他密码学操作的应用程序、网络服务器、安全工具等非常有用。</li>
<li>需要注意的是，libcrypto.so 是 OpenSSL 库的一部分，它是一个开源项目，在多个操作系统和平台上可用。在不同的系统中，libcrypto.so 的具体名称和路径可能会有所不同，但提供的加密和安全功能基本相似。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_02_%E5%B8%B8%E7%94%A8%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_02_%E5%B8%B8%E7%94%A8%E5%BA%93/" class="post-title-link" itemprop="url">C++_04_02_常用库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++编程中遇到的第三方库</li>
</ul>
<h2 id="linux-libopus-dev是什么"><a href="#linux-libopus-dev是什么" class="headerlink" title="linux libopus-dev是什么"></a>linux libopus-dev是什么</h2><p><code>libopus-dev</code> 是用于开发的一个软件包，针对在 Linux 系统上开发基于 Opus 音频编解码器的应用程序。</p>
<p>以下是关于 <code>libopus-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>Opus 编解码器</strong>：Opus 是一个开源的音频编解码器，可用于实时互联网音频传输、语音通话、音频流媒体等应用。Opus 具有低延迟、高效率和高音质等特点，被广泛认可为网络音频编码的标准之一。</p>
</li>
<li><p><strong>libopus-dev</strong>：<code>libopus-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 Opus 音频编解码器的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libopus-dev</code>，开发者可以在他们的项目中使用 Opus 编解码器提供的音频编解码功能。他们可以包含 Opus 的头文件以访问其功能，并链接 Opus 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：<code>libopus-dev</code> 通常可以通过操作系统的包管理工具进行安装。在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以使用以下命令安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libopus-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libopus-dev</code> 通常是针对需要开发或编译 Opus 编解码器相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libopus-dev</code> 是一个用于开发基于 Opus 音频编解码器的应用程序的软件包，提供了开发所需的头文件和静态库文件。Opus 编解码器可以帮助开发者实现高效、高质量的音频编解码功能。</p>
<h2 id="linux-libmp3lame-dev是什么"><a href="#linux-libmp3lame-dev是什么" class="headerlink" title="linux libmp3lame-dev是什么"></a>linux libmp3lame-dev是什么</h2><p><code>libmp3lame-dev</code> 是用于开发的一个软件包，针对在 Linux 系统上开发基于 LAME MP3 编码器的应用程序。</p>
<p>以下是关于 <code>libmp3lame-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>LAME MP3 编码器</strong>：LAME 是一个开源的 MP3 音频编码器，它允许用户将音频文件编码为 MP3 格式。LAME 提供了高质量的音频压缩功能，并被广泛用于音乐、音效等领域的编码工作。</p>
</li>
<li><p><strong>libmp3lame-dev</strong>：<code>libmp3lame-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 LAME MP3 编码器的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libmp3lame-dev</code>，开发者可以在他们的项目中使用 LAME MP3 编码器提供的音频编码功能。他们可以包含 LAME 的头文件以访问其功能，并链接 LAME 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：<code>libmp3lame-dev</code> 通常可以通过操作系统的包管理工具进行安装。在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以使用以下命令安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libmp3lame-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libmp3lame-dev</code> 通常是针对需要开发或编译 LAME MP3 编码器相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libmp3lame-dev</code> 是一个用于开发基于 LAME MP3 编码器的应用程序的软件包，提供了开发所需的头文件和静态库文件。LAME MP3 编码器可以帮助开发者实现高质量的 MP3 音频编码功能。</p>
<h2 id="linux-libfdk-aac-dev是什么"><a href="#linux-libfdk-aac-dev是什么" class="headerlink" title="linux libfdk-aac-dev是什么"></a>linux libfdk-aac-dev是什么</h2><p><code>libfdk-aac-dev</code> 是用于开发的一个软件包，针对在 Linux 系统上开发基于 Fraunhofer FDK AAC 编解码器的应用程序。</p>
<p>以下是关于 <code>libfdk-aac-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>Fraunhofer FDK AAC 编解码器</strong>：FDK AAC（Fraunhofer FDK AAC）是由 Fraunhofer Institute for Integrated Circuits 开发的一种高性能音频编解码器，用于编码和解码 AAC（Advanced Audio Coding）格式的音频。AAC 是一种广泛应用于音频压缩的格式，通常用于在线音频流媒体、数字音乐存储等领域。</p>
</li>
<li><p><strong>libfdk-aac-dev</strong>：<code>libfdk-aac-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 FDK AAC 编解码器的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libfdk-aac-dev</code>，开发者可以在他们的项目中使用 FDK AAC 编解码器提供的高质量音频编解码功能。他们可以包含 FDK AAC 的头文件以访问其功能，并链接 FDK AAC 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：<code>libfdk-aac-dev</code> 通常可以通过操作系统的包管理工具进行安装。在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以使用以下命令安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libfdk-aac-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libfdk-aac-dev</code> 通常是针对需要开发或编译 FDK AAC 编解码器相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libfdk-aac-dev</code> 是一个用于开发基于 Fraunhofer FDK AAC 编解码器的应用程序的软件包，提供了开发所需的头文件和静态库文件。FDK AAC 编解码器可以帮助开发者实现高质量的 AAC 音频编解码功能。</p>
<h2 id="linux-libx265-dev是什么"><a href="#linux-libx265-dev是什么" class="headerlink" title="linux libx265-dev是什么"></a>linux libx265-dev是什么</h2><p><code>libx265-dev</code> 是用于开发的一个软件包，针对在 Linux 系统上开发基于 x265 视频编码库的应用程序。</p>
<p>以下是关于 <code>libx265-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>x265 编码库</strong>：x265 是一个开源的视频编码库，用于编码 HEVC (High Efficiency Video Coding) 格式的视频。它提供了高效的视频压缩和编码功能，被广泛应用于视频编码、视频转码、视频流媒体等领域。</p>
</li>
<li><p><strong>libx265-dev</strong>：<code>libx265-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 x265 编码库的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libx265-dev</code>，开发者可以在他们的项目中使用 x265 提供的视频编码功能。他们可以包含 x265 的头文件以访问其功能，并链接 x265 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以通过包管理工具（如 apt）安装 <code>libx265-dev</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libx265-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libx265-dev</code> 通常是针对需要开发或编译 x265 编码库相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libx265-dev</code> 是一个用于开发基于 x265 视频编码库的应用程序的软件包，提供了开发所需的头文件和静态库文件。x265 编码库可以帮助开发者实现高效的 HEVC 视频编码功能。</p>
<h2 id="linux-libx264-dev是什么"><a href="#linux-libx264-dev是什么" class="headerlink" title="linux libx264-dev是什么"></a>linux libx264-dev是什么</h2><p><code>libx264-dev</code> 是用于开发的一个软件包，针对在 Linux 系统上开发基于 x264 视频编码库的应用程序。</p>
<p>以下是关于 <code>libx264-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>x264 编码库</strong>：x264 是一个开源的视频编码库，用于编码 H.264&#x2F;AVC 格式的视频。它提供了高效的视频压缩和编码功能，被广泛应用于视频编码、视频转码、视频流媒体等领域。</p>
</li>
<li><p><strong>libx264-dev</strong>：<code>libx264-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 x264 编码库的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libx264-dev</code>，开发者可以在他们的项目中使用 x264 提供的视频编码功能。他们可以包含 x264 的头文件以访问其功能，并链接 x264 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以通过包管理工具（如 apt）安装 <code>libx264-dev</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libx264-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libx264-dev</code> 通常是针对需要开发或编译 x264 编码库相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libx264-dev</code> 是一个用于开发基于 x264 视频编码库的应用程序的软件包，提供了开发所需的头文件和静态库文件。 x264 编码库可以帮助开发者实现高效的视频编码功能。</p>
<h2 id="linux-nasm是什么"><a href="#linux-nasm是什么" class="headerlink" title="linux nasm是什么"></a>linux nasm是什么</h2><p>NASM (Netwide Assembler) 是一个流行的开源汇编器，用于 x86 和 x86-64 架构的汇编语言编程。它是一个跨平台的工具，可以在多个操作系统上使用，包括 Linux、Windows 和 macOS。</p>
<p>以下是关于 NASM 的一些说明：</p>
<ol>
<li><p><strong>汇编器</strong>：NASM 是一个汇编器，用于将汇编语言源代码转换为可执行的二进制目标文件。汇编语言是一种低级语言，与特定硬件架构紧密相关，常用于编写系统级别的程序、设备驱动程序等。</p>
</li>
<li><p><strong>支持的架构</strong>：NASM 主要支持 x86 和 x86-64 架构，这两种是在 PC 和服务器上最常见的架构之一。通过 NASM，用户可以编写针对这些架构的汇编代码。</p>
</li>
<li><p><strong>跨平台</strong>：NASM 是一个跨平台工具，可以在多种操作系统上使用，包括 Linux、Windows 和 macOS。这使得开发者可以在不同的平台上编写和调试汇编代码。</p>
</li>
<li><p><strong>功能丰富</strong>：NASM 提供了丰富的指令集支持和功能，使得用户可以编写复杂的汇编代码，并充分利用硬件特性，实现高效的程序。</p>
</li>
<li><p><strong>广泛应用</strong>：NASM 被广泛应用于各种领域，包括操作系统内核、引导加载程序、驱动程序、嵌入式系统、游戏开发等。它还常用于编写性能要求较高的程序，如编解码器、密码学算法等。</p>
</li>
<li><p><strong>安装</strong>：NASM 通常可以通过操作系统的包管理工具进行安装。在大多数 Linux 发行版中，可以使用以下命令安装 NASM：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nasm</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总的来说，NASM 是一个流行的开源汇编器，用于 x86 和 x86-64 架构的汇编语言编程。它具有跨平台、功能丰富、广泛应用等特点，适用于各种类型的编程任务。</p>
<h2 id="linux-yasm是什么"><a href="#linux-yasm是什么" class="headerlink" title="linux yasm是什么"></a>linux yasm是什么</h2><p>Yasm 是一个开源的汇编器，用于汇编编程语言。它支持 x86 和 AMD64 架构，并提供了高度可扩展性和灵活性，使得用户可以编写高效的汇编代码。</p>
<p>以下是关于 Yasm 的一些说明：</p>
<ol>
<li><p><strong>汇编器</strong>：Yasm 是一个汇编器，用于将汇编语言源代码转换为机器代码。汇编语言是一种底层编程语言，与特定硬件架构密切相关，通常用于编写性能要求较高的程序或操作系统内核等。</p>
</li>
<li><p><strong>支持的架构</strong>：Yasm 主要支持 x86 和 AMD64 架构，这两种架构是在 PC 和服务器上最常见的架构之一。通过 Yasm，用户可以编写针对这些架构的汇编代码。</p>
</li>
<li><p><strong>高度可扩展性</strong>：Yasm 提供了丰富的指令集支持和高度可扩展的功能，使得用户可以编写复杂的汇编代码，并利用硬件特性实现更高效的代码。</p>
</li>
<li><p><strong>灵活性</strong>：Yasm 具有很高的灵活性，允许用户定义自定义的宏和指令，以适应不同的编程需求。这种灵活性使得 Yasm 成为一个强大的工具，被广泛应用于各种领域，包括操作系统、编译器、多媒体处理等。</p>
</li>
<li><p><strong>用途</strong>：Yasm 可以用于编写各种类型的程序，包括操作系统内核、驱动程序、嵌入式系统固件等。它还常用于编写优化的算法和程序库，以提高性能。</p>
</li>
<li><p><strong>安装</strong>：Yasm 可以在大多数 Linux 发行版的软件仓库中找到，并可以通过包管理工具进行安装。例如，在 Ubuntu 中可以使用以下命令安装 Yasm：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install yasm</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总的来说，Yasm 是一个用于编写汇编语言程序的开源工具，它具有高度可扩展性和灵活性，适用于各种类型的编程任务。</p>
<h2 id="linux-zlib1g-dev是什么"><a href="#linux-zlib1g-dev是什么" class="headerlink" title="linux zlib1g-dev是什么"></a>linux zlib1g-dev是什么</h2><p><code>zlib1g-dev</code> 是用于在 Linux 系统上开发基于 zlib 库的应用程序的软件包。zlib 是一个流行的压缩库，用于提供数据压缩和解压缩的功能。它广泛用于许多应用程序中，包括 Web 服务器、数据库、文件压缩工具等。</p>
<p>以下是关于 <code>zlib1g-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>zlib 库</strong>：zlib 是一个开源的数据压缩库，它提供了用于压缩和解压缩数据的函数。zlib 使用 DEFLATE 算法，可以实现高效的数据压缩和解压缩。</p>
</li>
<li><p><strong>zlib1g-dev</strong>：<code>zlib1g-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 zlib 库的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>zlib1g-dev</code>，开发者可以在他们的项目中使用 zlib 提供的数据压缩和解压缩功能。他们可以包含 zlib 的头文件以访问其功能，并链接 zlib 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以通过包管理工具（如 apt）安装 <code>zlib1g-dev</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>zlib1g-dev</code> 通常是针对需要开发或编译 zlib 库相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>zlib1g-dev</code> 是一个用于开发基于 zlib 库的应用程序的软件包，提供了开发所需的头文件和静态库文件。 zlib 库可以帮助开发者实现数据的高效压缩和解压缩。</p>
<h2 id="linux-texinfo是什么"><a href="#linux-texinfo是什么" class="headerlink" title="linux texinfo是什么"></a>linux texinfo是什么</h2><p><code>texinfo</code> 是一个文档格式和处理工具，用于创建和格式化技术文档。它最初是由 GNU 项目开发的，现在被广泛用于撰写和发布 GNU 软件的手册和文档。</p>
<p>以下是关于 <code>texinfo</code> 的一些说明：</p>
<ol>
<li><p><strong>文档格式</strong>：<code>texinfo</code> 使用一种类似于 LaTeX 的标记语言来编写文档，但它具有更加简单和易于理解的语法。这使得用户能够方便地撰写各种类型的技术文档，如手册、教程、指南等。</p>
</li>
<li><p><strong>多输出格式</strong>：通过使用 <code>texinfo</code>，用户可以将其文档编写为 Texinfo 格式的源文件，然后使用 <code>makeinfo</code> 工具将其转换为各种输出格式，包括 Info 格式、HTML 格式、PDF 格式等。这种灵活性使得用户可以在不同的平台和设备上阅读和使用文档。</p>
</li>
<li><p><strong>GNU 软件手册</strong>：大多数 GNU 软件都提供了 Texinfo 格式的手册，这些手册可以在 GNU&#x2F;Linux 系统中使用 Info 阅读器查看。这些手册提供了对 GNU 软件的详细说明、使用说明、命令选项等信息。</p>
</li>
<li><p><strong><code>makeinfo</code> 命令</strong>：<code>makeinfo</code> 是 <code>texinfo</code> 套件中的一个命令行工具，用于将 Texinfo 格式的源文件转换为可阅读的输出格式。用户可以通过在终端中运行 <code>makeinfo</code> 命令来生成 Info 格式、HTML 格式或其他格式的文档。</p>
</li>
<li><p><strong>安装</strong>：<code>texinfo</code> 软件包通常可以通过系统的包管理工具进行安装，例如在 Debian 或 Ubuntu 系统上可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install texinfo</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总的来说，<code>texinfo</code> 是一个用于创建和格式化技术文档的工具，它使用一种简单的标记语言编写文档，并提供了多种输出格式的转换工具，以方便用户在不同的平台上阅读和使用文档。</p>
<h2 id="linux-libxcb-xfixes0-dev是什么"><a href="#linux-libxcb-xfixes0-dev是什么" class="headerlink" title="linux libxcb-xfixes0-dev是什么"></a>linux libxcb-xfixes0-dev是什么</h2><p><code>libxcb-xfixes0-dev</code> 是针对开发者的一个软件包，用于在 Linux 系统上开发基于 XCB（X C Bindings）库的应用程序，特别是涉及到 X Window 系统的修复扩展（X Fixes Extension）的应用程序。</p>
<p>以下是关于 <code>libxcb-xfixes0-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>XCB</strong>：XCB 是 X Window 系统的一个替代性的客户端库，用于与 X 服务器通信和管理图形用户界面（GUI）。XCB 提供了比传统的 Xlib 库更现代化、更高效的 API。</p>
</li>
<li><p><strong>X Fixes Extension</strong>：X Fixes Extension（修复扩展）是 X Window 系统的一个扩展，提供了对窗口和图形对象的修复功能，如光标形状、窗口位置、选项功能等。</p>
</li>
<li><p><strong>libxcb-xfixes0-dev</strong>：<code>libxcb-xfixes0-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 XCB 修复扩展的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libxcb-xfixes0-dev</code>，开发者可以在他们的项目中使用 XCB 修复扩展提供的功能，如窗口位置修复、光标形状设置等。他们可以包含 XCB 修复扩展的头文件以访问其功能，并链接 XCB 修复扩展的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以通过包管理工具（如 apt）安装 <code>libxcb-xfixes0-dev</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libxcb-xfixes0-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libxcb-xfixes0-dev</code> 通常是针对需要开发或编译 XCB 修复扩展相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libxcb-xfixes0-dev</code> 是一个用于开发基于 XCB 修复扩展的应用程序的软件包，提供了开发所需的头文件和静态库文件。 XCB 修复扩展可以帮助开发者实现对窗口和图形对象的修复功能。</p>
<h2 id="linux-libxcb-shm0-dev是什么"><a href="#linux-libxcb-shm0-dev是什么" class="headerlink" title="linux libxcb-shm0-dev是什么"></a>linux libxcb-shm0-dev是什么</h2><p><code>libxcb-shm0-dev</code> 是针对开发者的一个软件包，用于在 Linux 系统上开发基于 XCB（X C Bindings）库中共享内存扩展（X Shared Memory Extension）的应用程序。</p>
<p>以下是关于 <code>libxcb-shm0-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>XCB</strong>：XCB 是 X Window 系统的一个替代性的客户端库，用于与 X 服务器通信和管理图形用户界面（GUI）。它提供了比传统的 Xlib 库更现代化、更高效的 API。</p>
</li>
<li><p><strong>X Shared Memory Extension</strong>：X Shared Memory Extension（共享内存扩展）是 X Window 系统的一个扩展，允许 X 服务器和客户端之间共享内存区域，从而提高图形数据的传输效率。</p>
</li>
<li><p><strong>libxcb-shm0-dev</strong>：<code>libxcb-shm0-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 XCB 共享内存扩展的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libxcb-shm0-dev</code>，开发者可以在他们的项目中使用 XCB 共享内存扩展提供的功能，如共享图像数据以加速图形渲染。他们可以包含 XCB 共享内存扩展的头文件以访问其功能，并链接 XCB 共享内存扩展的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以通过包管理工具（如 apt）安装 <code>libxcb-shm0-dev</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libxcb-shm0-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libxcb-shm0-dev</code> 通常是针对需要开发或编译 XCB 共享内存扩展相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libxcb-shm0-dev</code> 是一个用于开发基于 XCB 共享内存扩展的应用程序的软件包，提供了开发所需的头文件和静态库文件。 XCB 共享内存扩展可以帮助开发者实现共享图像数据以加速图形渲染。</p>
<h2 id="linux-libxcb1-dev是什么"><a href="#linux-libxcb1-dev是什么" class="headerlink" title="linux libxcb1-dev是什么"></a>linux libxcb1-dev是什么</h2><p><code>libxcb1-dev</code> 是针对开发者的一个软件包，用于在 Linux 系统上开发基于 XCB（X C Bindings）库的应用程序。XCB 是 X Window 系统的一个替代性的客户端库，用于与 X 服务器通信和管理图形用户界面（GUI）。</p>
<p>以下是关于 <code>libxcb1-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>XCB</strong>：XCB 是 X Window 系统的一个客户端库，提供了用于与 X 服务器通信的低级别 API。相比于传统的 Xlib 库，XCB 提供了更为现代化、高效的 API，并且在网络环境下更加稳定和可靠。</p>
</li>
<li><p><strong>libxcb1-dev</strong>：<code>libxcb1-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 XCB 库的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libxcb1-dev</code>，开发者可以在他们的项目中使用 XCB 提供的功能，如创建窗口、处理用户输入、绘制图形等。他们可以包含 XCB 的头文件以访问其功能，并链接 XCB 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以通过包管理工具（如 apt）安装 <code>libxcb1-dev</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libxcb1-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libxcb1-dev</code> 通常是针对需要开发或编译 XCB 库相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libxcb1-dev</code> 是一个用于开发基于 XCB 库的应用程序的软件包，提供了开发所需的头文件和静态库文件。 XCB 库可以帮助开发者实现与 X 服务器的通信和管理 GUI。</p>
<h2 id="linux-libvorbis-dev是什么"><a href="#linux-libvorbis-dev是什么" class="headerlink" title="linux libvorbis-dev是什么"></a>linux libvorbis-dev是什么</h2><p><code>libvorbis-dev</code> 是针对开发者的一个软件包，用于在 Linux 系统上开发基于 Vorbis 音频编解码器的应用程序。Vorbis 是一种开放的音频压缩格式，通常用于存储音乐和音效，具有高质量的音频编解码能力。</p>
<p>以下是关于 <code>libvorbis-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>Vorbis 编解码器</strong>：Vorbis 是一种开源的音频编解码器，提供了高质量的音频压缩和解压缩功能。它通常用于存储音乐和音效，是一个免费、自由的音频编解码器。</p>
</li>
<li><p><strong>libvorbis-dev</strong>：<code>libvorbis-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 Vorbis 编解码器的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libvorbis-dev</code>，开发者可以在他们的项目中使用 Vorbis 编解码器提供的功能，如音频解码和编码。他们可以包含 Vorbis 的头文件以访问其功能，并链接 Vorbis 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以通过包管理工具（如 apt）安装 <code>libvorbis-dev</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libvorbis-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libvorbis-dev</code> 通常是针对需要开发或编译 Vorbis 编解码器相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libvorbis-dev</code> 是一个用于开发基于 Vorbis 音频编解码器的应用程序的软件包，提供了开发所需的头文件和静态库文件。</p>
<h2 id="linux-libvdpau-dev是什么"><a href="#linux-libvdpau-dev是什么" class="headerlink" title="linux libvdpau-dev是什么"></a>linux libvdpau-dev是什么</h2><p><code>libvdpau-dev</code> 是用于开发的一个软件包，针对在 Linux 系统上开发基于 VDPAU（Video Decode and Presentation API for Unix）的应用程序。VDPAU 是用于视频解码和渲染的 API，可以利用图形处理器（GPU）的硬件加速功能来提高视频播放性能。</p>
<p>以下是关于 <code>libvdpau-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>VDPAU</strong>：VDPAU 是一个用于视频解码和渲染的 API，旨在提供统一的接口，使得开发者能够利用图形处理器（GPU）的硬件加速功能来提高视频播放性能。VDPAU 可以与 NVIDIA 的显卡硬件配合使用。</p>
</li>
<li><p><strong>libvdpau-dev</strong>：<code>libvdpau-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 VDPAU 的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libvdpau-dev</code>，开发者可以在他们的项目中使用 VDPAU 提供的功能，如硬件加速的视频解码和渲染。他们可以包含 VDPAU 的头文件以访问其功能，并链接 VDPAU 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以通过包管理工具（如 apt）安装 <code>libvdpau-dev</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libvdpau-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libvdpau-dev</code> 通常是针对需要开发或编译 VDPAU 相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libvdpau-dev</code> 是一个用于开发基于 VDPAU 的应用程序的软件包，提供了开发所需的头文件和静态库文件。</p>
<h2 id="linux-libva-dev是什么"><a href="#linux-libva-dev是什么" class="headerlink" title="linux libva-dev是什么"></a>linux libva-dev是什么</h2><p><code>libva-dev</code> 是针对开发者的一个软件包，用于在 Linux 系统上开发基于 VA API（Video Acceleration API）的应用程序。VA API 是一个用于视频解码和编码加速的开放标准，它允许开发者利用硬件加速功能，提高视频处理性能。</p>
<p>以下是关于 <code>libva-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>VA API</strong>：VA API 是一个开放标准，旨在提供统一的接口，使得开发者能够利用硬件加速功能，实现视频解码、编码、处理等操作。VA API 可以与不同的图形硬件（如 Intel、AMD、NVIDIA）配合使用。</p>
</li>
<li><p><strong>libva-dev</strong>：<code>libva-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 VA API 的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libva-dev</code>，开发者可以在他们的项目中使用 VA API 提供的功能，如硬件加速的视频解码和编码。他们可以包含 VA API 的头文件以访问其功能，并链接 VA API 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以通过包管理工具（如 apt）安装 <code>libva-dev</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libva-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libva-dev</code> 通常是针对需要开发或编译 VA API 相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libva-dev</code> 是一个用于开发基于 VA API 的应用程序的软件包，提供了开发所需的头文件和静态库文件。</p>
<h2 id="linux-libtool库是什么"><a href="#linux-libtool库是什么" class="headerlink" title="linux libtool库是什么"></a>linux libtool库是什么</h2><p><code>libtool</code> 是一个跨平台的库支持脚本工具，用于管理可移植性和共享库（或动态链接库）的构建过程。它主要用于简化在不同 UNIX 系统上构建共享库的过程，并解决了在不同平台上构建共享库时的兼容性和依赖性问题。</p>
<p>以下是关于 <code>libtool</code> 的一些说明：</p>
<ol>
<li><p><strong>库的构建和管理</strong>：<code>libtool</code> 主要用于构建和管理共享库（或动态链接库）。共享库允许多个程序共享同一段代码，这可以减少内存占用，并且使得更新库更为方便。</p>
</li>
<li><p><strong>可移植性</strong>：<code>libtool</code> 被设计用于提高可移植性，使得开发者可以在不同的 UNIX 系统上构建共享库而无需关心不同系统的细节和差异。</p>
</li>
<li><p><strong>解决兼容性问题</strong>：在不同的 UNIX 系统上，共享库的命名、版本控制、符号导出等方面可能有所不同。<code>libtool</code> 通过提供统一的接口和规范，解决了这些问题，使得开发者能够轻松地在不同系统上构建共享库。</p>
</li>
<li><p><strong>用法</strong>：<code>libtool</code> 提供了一组命令行工具，用于配置、编译、链接和安装共享库。通常在项目的 <code>configure</code> 脚本中会自动调用 <code>libtool</code> 来生成共享库。</p>
</li>
<li><p><strong>示例</strong>：以下是 <code>libtool</code> 常用的一些命令：</p>
<ul>
<li><code>libtoolize</code>：初始化项目以使用 libtool。</li>
<li><code>libtool --mode=compile</code>：编译源文件为对象文件。</li>
<li><code>libtool --mode=link</code>：链接对象文件生成共享库或可执行文件。</li>
<li><code>libtool --mode=install</code>：安装共享库或可执行文件。</li>
</ul>
</li>
<li><p><strong>安装</strong>：<code>libtool</code> 通常作为开发工具链的一部分，在大多数 Linux 发行版中都已经预装。如果没有安装，可以通过包管理工具进行安装，例如在 Ubuntu 中可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libtool</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总的来说，<code>libtool</code> 是一个用于管理和构建共享库的跨平台工具，通过提供统一的接口和规范，解决了在不同 UNIX 系统上构建共享库时的可移植性和兼容性问题。</p>
<h2 id="linux-libsdl2-dev是什么"><a href="#linux-libsdl2-dev是什么" class="headerlink" title="linux libsdl2-dev是什么"></a>linux libsdl2-dev是什么</h2><p><code>libsdl2-dev</code> 是针对开发者的一个软件包，用于在 Linux 系统上开发基于 SDL 2 库的应用程序。SDL（Simple DirectMedia Layer）是一个跨平台的多媒体库，提供了对图形、音频、输入设备等的统一接口，使得开发者可以更容易地编写跨平台的游戏和多媒体应用程序。</p>
<p>下面是关于 <code>libsdl2-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>SDL 2</strong>：SDL 2 是 Simple DirectMedia Layer 的第二个主要版本，它是一个开源的跨平台多媒体库。SDL 2 提供了对图形、音频、输入设备等的抽象接口，使得开发者可以编写跨平台的游戏、仿真软件、多媒体应用等。</p>
</li>
<li><p><strong>libsdl2-dev</strong>：<code>libsdl2-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 SDL 2 库的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libsdl2-dev</code>，开发者可以在他们的项目中使用 SDL 2 库提供的功能，如窗口管理、图形渲染、音频播放、输入处理等。他们可以包含 SDL 2 的头文件以访问其功能，并链接 SDL 2 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以通过包管理工具（如 apt）安装 <code>libsdl2-dev</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsdl2-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libsdl2-dev</code> 通常是针对需要开发或编译 SDL 2 库相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libsdl2-dev</code> 是一个用于开发基于 SDL 2 库的应用程序的软件包，提供了开发所需的头文件和静态库文件。</p>
<h2 id="linux-libfreetype6-dev是什么"><a href="#linux-libfreetype6-dev是什么" class="headerlink" title="linux libfreetype6-dev是什么"></a>linux libfreetype6-dev是什么</h2><p><code>libfreetype6-dev</code> 是在 Linux 系统上提供的一个软件包，它包含了用于开发和构建基于 FreeType 2 库的应用程序所需的头文件和静态库文件。这个软件包通常用于开发需要使用 FreeType 2 库的应用程序，例如字体渲染器、文本处理程序等。</p>
<p>下面是对 <code>libfreetype6-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>FreeType 2</strong>：FreeType 2 是一个用于渲染字体的开源库，它支持多种字体格式，如 TrueType、OpenType、Type 1 等。FreeType 2 提供了对字体文件的解析、轮廓处理、渲染等功能。</p>
</li>
<li><p><strong>libfreetype6-dev</strong>：<code>libfreetype6-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 FreeType 2 库的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libfreetype6-dev</code>，开发者可以在他们的项目中使用 FreeType 2 库提供的功能，如字体解析和渲染。他们可以包含 FreeType 2 的头文件以访问其功能，并链接 FreeType 2 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以通过包管理工具（如 apt）安装 <code>libfreetype6-dev</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libfreetype6-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libfreetype6-dev</code> 通常是针对需要开发或编译 FreeType 2 库相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libfreetype6-dev</code> 是一个用于开发基于 FreeType 2 库的应用程序的软件包，提供了开发所需的头文件和静态库文件。</p>
<h2 id="libass-dev是什么"><a href="#libass-dev是什么" class="headerlink" title="libass-dev是什么"></a>libass-dev是什么</h2><p><code>libass-dev</code> 是一个在 Linux 系统上提供的软件包，它包含了用于开发和构建基于 libass 库的应用程序所需的头文件和静态库文件。这个软件包通常用于开发需要使用 libass 库的应用程序，例如字幕渲染器、媒体播放器等。</p>
<p>下面是对 <code>libass-dev</code> 的一些说明：</p>
<ol>
<li><p><strong>libass</strong>：<code>libass</code> 是一个用于字幕渲染的库，支持多种字幕格式，包括 ASS&#x2F;SSA、SRT、SUB 等。它能够将字幕嵌入到视频中并进行渲染，支持字体、样式、效果等特性。</p>
</li>
<li><p><strong>libass-dev</strong>：<code>libass-dev</code> 是针对开发者的软件包，它包含了用于编译、链接和构建基于 libass 库的应用程序所需的开发文件。这些文件通常包括头文件（<code>.h</code> 文件）和静态库文件（<code>.a</code> 文件）。</p>
</li>
<li><p><strong>用途</strong>：通过安装 <code>libass-dev</code>，开发者可以在他们的项目中使用 libass 库提供的功能，如字幕渲染。他们可以包含 libass 的头文件以访问其功能，并链接 libass 的静态库到他们的应用程序中。</p>
</li>
<li><p><strong>安装</strong>：在大多数基于 Debian 或 Ubuntu 的 Linux 发行版中，可以通过包管理工具（如 apt）安装 <code>libass-dev</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libass-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：安装 <code>libass-dev</code> 通常是针对需要开发或编译 libass 库相关应用程序的用户。如果只是想要使用已经编译好的应用程序，通常不需要安装这个软件包。</p>
</li>
</ol>
<p>总的来说，<code>libass-dev</code> 是一个用于开发基于 libass 库的应用程序的软件包，提供了开发所需的头文件和静态库文件。</p>
<h2 id="osqp库是什么"><a href="#osqp库是什么" class="headerlink" title="osqp库是什么"></a>osqp库是什么</h2><p>OSQP（Operator Splitting Quadratic Program）是一个用于求解二次规划（Quadratic Programming，QP）问题的开源求解器。QP是一类数学优化问题，其目标是在一些约束条件下寻找一个二次目标函数的最小值。OSQP的设计旨在高效地解决大规模QP问题。</p>
<p>OSQP使用了运算符分裂方法，这是一种内点方法的变体。内点方法是一类数值优化算法，用于求解约束优化问题，其中优化过程发生在约束集合的内部。OSQP针对大规模问题的高效性和可扩展性做了优化。</p>
<p>OSQP的主要特点包括：</p>
<ol>
<li><p><strong>高性能</strong>：OSQP旨在处理大规模的二次规划问题，并在实践中表现出较好的性能。</p>
</li>
<li><p><strong>开源</strong>：OSQP是一个开源项目，用户可以自由访问其源代码，并根据需要进行修改和定制。</p>
</li>
<li><p><strong>支持稀疏矩阵</strong>：OSQP针对稀疏问题进行了优化，这使得它在处理大规模问题时更为高效。</p>
</li>
<li><p><strong>易于使用</strong>：OSQP提供了用户友好的接口，使得在实际应用中能够相对轻松地集成和使用。</p>
</li>
</ol>
<p>OSQP的使用通常涉及将问题表达为标准的二次规划形式，然后使用OSQP库来求解这个问题。如果您有特定的关于OSQP的问题，或者想要在特定领域应用它，建议查阅OSQP的文档和社区资源以获取更详细的信息。</p>
<h2 id="libabsl库是什么"><a href="#libabsl库是什么" class="headerlink" title="libabsl库是什么"></a>libabsl库是什么</h2><p><code>libabsl</code> 是 Google 的 Abseil C++ 库的核心部分。Abseil 是一个包含许多功能性、通用性 C++ 库的项目，旨在提高 C++ 代码的可读性、可维护性和性能。”Abseil” 这个名字来源于攀岩时绳索的一种技术，强调库的坚固性和稳定性。</p>
<p>Abseil 的核心库 <code>libabsl</code> 提供了许多模块，包括字符串、日期与时间、散列、随机数生成、调试、并发等。这些模块被设计为非常通用，可以用于大量的 C++ 应用程序。Abseil 的目标是填补 C++ 标准库的一些不足，提供更为现代和丰富的工具。</p>
<p>下面是一些 Abseil C++ 库的特点：</p>
<ol>
<li><p><strong>字符串库</strong>：提供了更为丰富和灵活的字符串操作工具，包括 <code>absl::string_view</code>，用于高效处理字符串而无需复制。</p>
</li>
<li><p><strong>日期与时间库</strong>：包括了丰富的日期与时间的工具，使得处理时间变得更加方便。</p>
</li>
<li><p><strong>散列库</strong>：提供了哈希函数和散列容器，用于高效地处理哈希相关的操作。</p>
</li>
<li><p><strong>随机数库</strong>：包含了高质量的伪随机数生成器和分布，用于生成随机数。</p>
</li>
<li><p><strong>调试库</strong>：提供了一些调试和日志工具，方便程序员进行调试。</p>
</li>
<li><p><strong>并发库</strong>：提供了并发编程相关的工具，包括原子操作、锁、条件变量等。</p>
</li>
</ol>
<p>要使用 Abseil C++ 库，通常你需要将其包含在你的项目中，并链接到 <code>libabsl</code> 库。在某些情况下，<code>libabsl</code> 可能已经作为系统库提供，可以通过包管理器进行安装。在其他情况下，你可能需要从源代码构建或使用预编译的二进制版本。确保查看 Abseil 的文档以获取详细的安装和使用说明。</p>
<h2 id="libabsl库的编译和安装"><a href="#libabsl库的编译和安装" class="headerlink" title="libabsl库的编译和安装"></a>libabsl库的编译和安装</h2><p>编译和安装 <code>libabsl</code>（Abseil C++ 库）通常涉及以下步骤：</p>
<ol>
<li><p><strong>获取源代码</strong>：你可以从 Abseil 的 GitHub 仓库克隆源代码。使用以下命令：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/abseil/abseil-cpp.git</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进入源代码目录</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> abseil-cpp</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建构建目录</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行 CMake 配置</strong>：使用 CMake 配置构建过程。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure>

<p>这将生成用于构建 <code>libabsl</code> 的 Makefile。</p>
</li>
<li><p><strong>运行构建</strong>：使用 <code>make</code> 命令进行构建。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行测试（可选）</strong>：运行 <code>make test</code> 来执行测试，确保库的功能正常。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装（可选）</strong>：如果希望将 <code>libabsl</code> 安装到系统目录中，可以使用 <code>make install</code>。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<p>这将安装 <code>libabsl</code> 到系统的默认库目录中。如果你不希望安装到系统目录，可以跳过此步骤。</p>
</li>
</ol>
<p>请注意，上述步骤假定你已经安装了 CMake 和 Make 工具。如果尚未安装，请使用包管理器安装它们。例如，在 Ubuntu 上，你可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install cmake make</span><br></pre></td></tr></table></figure>

<p>以上步骤可能因操作系统、系统配置和库版本而有所不同。为确保成功编译和安装，建议查阅 <code>libabsl</code> 仓库中的文档，了解任何特定于你的平台或版本的说明。</p>
<h2 id="liborocos-kdl是什么"><a href="#liborocos-kdl是什么" class="headerlink" title="liborocos-kdl是什么"></a>liborocos-kdl是什么</h2><p><code>liborocos-kdl</code> 是 <a target="_blank" rel="noopener" href="https://orocos.org/kdl">Orocos Kinematics and Dynamics Library (KDL)</a> 的一部分。Orocos 是一个用于机器人控制的开源框架，而 KDL 是 Orocos 中的一个子库，专注于运动学（Kinematics）和动力学（Dynamics）计算。</p>
<p>具体而言，<code>liborocos-kdl</code> 提供了一个用于求解机器人运动学和动力学问题的 C++ 库。运动学涉及到描述和分析机器人的运动，例如，通过给定关节角度计算末端执行器的位置和姿态。动力学则涉及到描述机器人的力学行为，包括关节力和扭矩之间的关系。</p>
<p>使用 <code>liborocos-kdl</code>，开发者可以利用提供的函数和工具，以编程方式执行运动学和动力学计算。这对于机器人领域的控制算法和系统建模非常有用。</p>
<p>以下是一些 Orocos KDL 的主要特点：</p>
<ol>
<li><p><strong>运动学计算</strong>：支持通过给定关节角度计算机器人链的末端执行器位置和姿态。</p>
</li>
<li><p><strong>动力学计算</strong>：提供了用于计算机器人链的动力学特性的工具。</p>
</li>
<li><p><strong>支持多种机器人模型</strong>：能够处理多种不同类型的机器人模型，包括串联和并联机器人。</p>
</li>
<li><p><strong>ROS 集成</strong>：可以与 ROS（Robot Operating System）一起使用，与 ROS 中的其他组件进行集成。</p>
</li>
</ol>
<p>如果你正在进行机器人控制或相关领域的开发，使用 <code>liborocos-kdl</code> 可能是一个有用的选择。要开始使用它，你需要查阅相关的文档和示例代码，以了解如何集成和使用这个库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_06_nlohmann_json/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_06_nlohmann_json/" class="post-title-link" itemprop="url">C++_04_06_nlohmann_json</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>nlohmann&#x2F;json 库的相关笔记</li>
<li>nlohmann 是个人名,全称为 Niels Lohmann 尼尔斯-洛曼</li>
</ul>
<h2 id="nlohmann-json-创建包含布尔值的数组"><a href="#nlohmann-json-创建包含布尔值的数组" class="headerlink" title="nlohmann&#x2F;json 创建包含布尔值的数组"></a>nlohmann&#x2F;json 创建包含布尔值的数组</h2><p>使用nlohmann&#x2F;json库创建包含布尔值的数组非常简单。首先，确保你已经将该库包含到你的项目中。如果你使用CMake，可以将以下代码添加到你的CMakeLists.txt文件中：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(nlohmann_json REQUIRED)</span><br></pre></td></tr></table></figure>

<p>然后，使用以下C++代码创建包含布尔值的数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建包含布尔值的数组</span></span><br><span class="line">    nlohmann::json boolArray = &#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将JSON数组打印到控制台</span></span><br><span class="line">    std::cout &lt;&lt; boolArray &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先包含了nlohmann&#x2F;json库，然后创建了一个包含布尔值的数组 <code>boolArray</code>。最后，通过 <code>std::cout</code> 将JSON数组打印到控制台。</p>
<p>确保在项目中正确设置和使用nlohmann&#x2F;json库，以便成功编译和运行这段代码。</p>
<h2 id="nlohmann-json-将std-vector作为值传给键"><a href="#nlohmann-json-将std-vector作为值传给键" class="headerlink" title="nlohmann&#x2F;json 将std::vector作为值传给键"></a>nlohmann&#x2F;json 将std::vector作为值传给键</h2><p>使用 nlohmann&#x2F;json 库时，可以将 <code>std::vector</code> 作为 JSON 对象的值传递给键。下面是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 JSON 对象，将 std::vector 作为值传递给键</span></span><br><span class="line">    json jsonObject;</span><br><span class="line">    jsonObject[<span class="string">&quot;myNumbers&quot;</span>] = numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 JSON 对象转换为字符串输出</span></span><br><span class="line">    std::string jsonString = jsonObject.<span class="built_in">dump</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;JSON String: &quot;</span> &lt;&lt; jsonString &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::vector&lt;int&gt;</code> 中的数字被添加到了名为 <code>&quot;myNumbers&quot;</code> 的键中，并将整个向量作为 JSON 对象的值。<code>jsonObject.dump()</code> 将 JSON 对象转换为字符串，并使用 <code>std::cout</code> 输出到控制台。</p>
<p>你可以根据需要将不同类型的值存储在 JSON 对象中，并根据库的文档进行操作以满足你的特定需求。</p>
<h2 id="nlohmann-json-解析JSON字符串-将数组传递给std-vector"><a href="#nlohmann-json-解析JSON字符串-将数组传递给std-vector" class="headerlink" title="nlohmann&#x2F;json 解析JSON字符串 将数组传递给std::vector"></a>nlohmann&#x2F;json 解析JSON字符串 将数组传递给std::vector</h2><p>要使用 nlohmann&#x2F;json 库解析包含数组的 JSON 字符串并将其传递给 <code>std::vector</code>，你可以使用 <code>from_json</code> 函数。以下是一个示例：</p>
<p>假设有如下的 JSON 字符串：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;myArray&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在 C++ 中使用 nlohmann&#x2F;json 库解析该 JSON 字符串并将数组传递给 <code>std::vector</code> 的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JSON 字符串</span></span><br><span class="line">    std::string jsonString = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;myArray&quot;: [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    )&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 JSON 字符串</span></span><br><span class="line">    json jsonObject = json::<span class="built_in">parse</span>(jsonString);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 JSON 对象中获取数组并传递给 std::vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector = jsonObject[<span class="string">&quot;myArray&quot;</span>].get&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 std::vector 中的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Values in vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : myVector) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>jsonObject[&quot;myArray&quot;].get&lt;std::vector&lt;int&gt;&gt;()</code> 从 JSON 对象中获取名为 <code>&quot;myArray&quot;</code> 的数组，并使用 <code>.get&lt;std::vector&lt;int&gt;&gt;()</code> 将其转换为 <code>std::vector&lt;int&gt;</code> 类型。然后，将 <code>std::vector</code> 中的值输出到控制台。</p>
<p>这是一种使用 nlohmann&#x2F;json 库解析 JSON 字符串并将数组值传递给 <code>std::vector</code> 的方法。</p>
<h2 id="解析JSON文件"><a href="#解析JSON文件" class="headerlink" title="解析JSON文件"></a>解析JSON文件</h2><p>使用 nlohmann&#x2F;json 库解析 JSON 文件非常简单。下面是一个简单的示例，演示了如何使用该库解析 JSON 文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开 JSON 文件</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;data.json&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取 JSON 数据</span></span><br><span class="line">    nlohmann::json jsonData;</span><br><span class="line">    file &gt;&gt; jsonData;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 JSON 数据中提取所需的值</span></span><br><span class="line">    std::string name = jsonData[<span class="string">&quot;name&quot;</span>];</span><br><span class="line">    <span class="type">int</span> age = jsonData[<span class="string">&quot;age&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印提取的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先使用 <code>ifstream</code> 打开一个名为 “data.json” 的 JSON 文件。然后，我们使用 <code>&gt;&gt;</code> 运算符将文件中的 JSON 数据读取到 <code>nlohmann::json</code> 对象 <code>jsonData</code> 中。最后，我们从 <code>jsonData</code> 中提取出 “name” 和 “age” 字段的值，并将其打印出来。</p>
<p>请确保在编译时链接 nlohmann&#x2F;json 库。你可以通过在编译命令中添加 <code>-I</code> 选项指定头文件的搜索路径，以及 <code>-l</code> 选项指定库文件的链接。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_08_httplib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_08_httplib/" class="post-title-link" itemprop="url">C++_04_08_httplib</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ net-httplib库</li>
</ul>
<h2 id="C-net-httplib库-详解"><a href="#C-net-httplib库-详解" class="headerlink" title="C++ net-httplib库 详解"></a>C++ net-httplib库 详解</h2><p><code>net-httplib</code> 是一个基于 C++ 的 HTTP 库，用于简化在 C++ 中进行 HTTP 通信的开发。以下是一个简要的 <code>net-httplib</code> 库的详解：</p>
<h3 id="特点和优势"><a href="#特点和优势" class="headerlink" title="特点和优势"></a>特点和优势</h3><ol>
<li><p><strong>轻量级：</strong> <code>net-httplib</code> 是一个轻量级的库，易于集成到现有的 C++ 项目中。</p>
</li>
<li><p><strong>简单易用：</strong> 提供了简单易用的 API，使得在 C++ 中进行 HTTP 通信变得容易。</p>
</li>
<li><p><strong>跨平台：</strong> 兼容多种操作系统，包括 Windows、Linux、macOS 等。</p>
</li>
<li><p><strong>灵活性：</strong> 支持多种 HTTP 请求方法（GET、POST 等）和响应状态码，同时提供了自定义请求头、查询参数等功能。</p>
</li>
<li><p><strong>无依赖：</strong> 无需依赖其他第三方库，易于集成和部署。</p>
</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httplib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">httplib::Client <span class="title">cli</span><span class="params">(<span class="string">&quot;http://httpbin.org&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> res = cli.<span class="built_in">Get</span>(<span class="string">&quot;/get&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (res &amp;&amp; res-&gt;status == <span class="number">200</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; res-&gt;body &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Request failed: &quot;</span> &lt;&lt; res.<span class="built_in">error</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例演示了如何使用 <code>net-httplib</code> 发送一个简单的 GET 请求。首先，我们创建了一个 <code>httplib::Client</code> 对象，指定了目标服务器的 URL。然后，我们使用 <code>Get()</code> 方法发送了一个 GET 请求，并检查了返回的响应。如果请求成功，我们输出响应的主体内容，否则输出错误信息。</p>
<h3 id="安装和集成"><a href="#安装和集成" class="headerlink" title="安装和集成"></a>安装和集成</h3><p><code>net-httplib</code> 可以通过源代码或者包管理器进行安装。一般情况下，你可以从 GitHub 上获取源代码，并将其添加到你的项目中，然后通过包含头文件来使用它。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>net-httplib</code> 是一个简单、轻量级的 C++ HTTP 库，适用于在 C++ 项目中进行 HTTP 通信。它提供了简单易用的 API，支持多种 HTTP 请求方法和响应状态码，同时具备跨平台性和灵活性，是一个方便快捷的 HTTP 通信解决方案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_05_libjsoncpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_05_libjsoncpp/" class="post-title-link" itemprop="url">C++_04_05_libjsoncpp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>libjsoncpp库</li>
</ul>
<h2 id="C-libjsoncpp库-详解"><a href="#C-libjsoncpp库-详解" class="headerlink" title="C++ libjsoncpp库 详解"></a>C++ libjsoncpp库 详解</h2><p>libjsoncpp 是一个用于处理 JSON 数据的 C++ 库。它提供了一组功能强大的 API，使得在 C++ 应用程序中解析、生成和操作 JSON 数据变得简单而高效。</p>
<p>以下是关于 libjsoncpp 的详解：</p>
<ol>
<li><p><strong>JSON 数据处理</strong>：libjsoncpp 提供了一套 API，使得在 C++ 应用程序中处理 JSON 数据变得简单。它可以解析 JSON 字符串，将 JSON 对象转换为 C++ 对象，以及将 C++ 对象转换为 JSON 字符串。</p>
</li>
<li><p><strong>易于使用</strong>：libjsoncpp 的 API 设计简单直观，易于理解和使用。它提供了类似于标准容器的接口，使得对 JSON 对象进行操作就像操作标准容器一样方便。</p>
</li>
<li><p><strong>跨平台性</strong>：libjsoncpp 可以在各种平台上运行，包括 Windows、Linux、macOS 等。这使得它适用于各种不同的开发环境和应用场景。</p>
</li>
<li><p><strong>开源</strong>：libjsoncpp 是开源的，采用 MIT 许可证。这意味着您可以自由地使用、修改和分发该库，而无需担心版权问题。</p>
</li>
<li><p><strong>高性能</strong>：libjsoncpp 在设计上注重了性能，并且采用了一些优化策略来提高解析和生成 JSON 数据的速度。这使得它在处理大量 JSON 数据时表现出色。</p>
</li>
<li><p><strong>灵活性</strong>：libjsoncpp 提供了丰富的功能，可以满足不同应用场景的需求。您可以使用它来处理各种类型的 JSON 数据，包括简单的键值对、嵌套对象、数组等等。</p>
</li>
<li><p><strong>与标准库兼容</strong>：libjsoncpp 的设计与 C++ 标准库兼容，并且尽量遵循 C++ 的最佳实践和惯例。这使得它可以与其他 C++ 库和框架无缝集成。</p>
</li>
<li><p><strong>持续维护</strong>：libjsoncpp 是一个活跃维护的项目，开发团队不断更新和改进库的功能，并及时修复可能存在的 bug 和问题。</p>
</li>
</ol>
<p>总的来说，libjsoncpp 是一个功能强大、易于使用、高性能的 C++ JSON 库，适用于各种类型的 C++ 应用程序，包括网络服务、移动应用、游戏开发等。</p>
<h2 id="jsoncpp"><a href="#jsoncpp" class="headerlink" title="jsoncpp"></a>jsoncpp</h2><h3 id="json-概述"><a href="#json-概述" class="headerlink" title="json 概述"></a>json 概述</h3><ul>
<li><p>JSON(<code>JavaScript Object Notation</code>, JavaScript 对象表示法) 是一种轻量级的数据交换格式。 </p>
</li>
<li><p>JSON是存储和交换文本信息的语法，类似于XML。但它比XML更小，更快，更易解析，易于人阅读和编写。同时也易于机器解析和生成。 </p>
</li>
<li><p>它基于<code>JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999</code>的一个子集。 </p>
</li>
<li><p>JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括<code>C, C++, C#, Java, JavaScript, Perl, Python</code>等）。 </p>
</li>
<li><p>这些特性使JSON成为理想的数据交换语言</p>
</li>
<li><p>要明白，JSON 是一种轻量级的文本数据交换格式而非编程语言，其语法只支持字符串，数值，布尔值及null以及在此基础上的对象和数组，</p>
</li>
<li><p>JSON建构于两种结构：</p>
<ul>
<li>“名称&#x2F;值”对的集合（<code>A collection of name/value pairs</code>）,不同的语言中，它被理解为对象（<code>object</code>），纪录（<code>record</code>），结构（<code>struct</code>），字典（<code>dictionary</code>），哈希表（<code>hash table</code>），有键列表（<code>keyed list</code>），或者关联数组 （<code>associative array</code>）。</li>
<li>值的有序列表（An ordered list of values）,在大部分语言中，它被理解为数组（<code>array</code>）</li>
</ul>
</li>
<li><p>JSON具有以下这些形式：</p>
<ul>
<li>对象是一个无序的“‘名称&#x2F;值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称&#x2F;值’ 对”之间使用“,”（逗号）分隔</li>
</ul>
</li>
</ul>
<h4 id="JSON语法规则"><a href="#JSON语法规则" class="headerlink" title="JSON语法规则"></a>JSON语法规则</h4><ul>
<li><p>数据在 名称&#x2F;值对 里面</p>
</li>
<li><p>数据由逗号分隔</p>
</li>
<li><p>大括号保存对象</p>
</li>
<li><p>中括号保存数组</p>
</li>
<li><p>JSON名称&#x2F;值对</p>
<ul>
<li>JSON 数据的书写格式是：名称&#x2F;值对</li>
<li>名称&#x2F;值对 包括字段名称（在双引号中），后面写一个冒号，然后是值： <code>&quot;name&quot;:&quot;hello world&quot;</code></li>
</ul>
</li>
<li><p>JSON名称（键）必须是字符串</p>
</li>
<li><p>JSON值可以是：</p>
<ul>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在中括号中）</li>
<li>对象（在大括号中）</li>
<li>null</li>
</ul>
</li>
<li><p>JSON对象</p>
<ul>
<li>JSON 对象在大括号（{}）中书写</li>
<li>对象可以包含多个名称&#x2F;值对：   <code>&#123;&quot;name&quot;:&quot;hello world&quot;, &quot;url&quot;:&quot;www&quot;&#125;</code></li>
</ul>
</li>
<li><p>JSON数组</p>
<ul>
<li>JSON 数组在中括号中书写</li>
<li>数组可包含多个对象：<code>&quot;sites&quot;:[&#123;&quot;name&quot;:&quot;hello&quot;, &quot;url&quot;:&quot;www&quot;&#125;, &#123;&quot;name&quot;:&quot;world&quot;, &quot;url&quot;:&quot;www&quot;&#125;]</code><ul>
<li>对象sites是包含两个对象的数组，每个对象代表一条关于网站(name, url)的记录</li>
</ul>
</li>
</ul>
</li>
<li><p>访问对象值</p>
<ul>
<li>可以使用点号来访问对象的值<code>var myobj,x; myobj = &#123;&quot;name&quot;:&quot;json&quot;, &quot;alex&quot;:1111, &quot;site&quot;:&quot;www&quot;&#125;; x = myobj.name;</code></li>
<li>可以使用中括号来访问对象的值<code>var myobj,x; myobj = &#123;&quot;name&quot;:&quot;json&quot;, &quot;alex&quot;:1111, &quot;site&quot;:&quot;www&quot;&#125;; x = myobj[&quot;name&quot;];</code></li>
</ul>
</li>
</ul>
<h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h4><ul>
<li><p>JSON通常用于与服务端交换数据</p>
</li>
<li><p>在接收服务器数据时，一般是字符串，可以使用JSON.parse()方法将数据交换为JavaScript对象</p>
</li>
<li><p>语法：<code>JSON.parse(text, reviver);</code></p>
</li>
<li><p>参数说明：</p>
<ul>
<li><code>text</code>  – 一个有效的JSON字符串</li>
<li><code>reviver</code> – 一个转换结果的函数，将为对象的每个成员调用此函数</li>
</ul>
</li>
</ul>
<h4 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h4><ul>
<li><p>JSON 通常用于与服务端交换数据。</p>
</li>
<li><p>在向服务器发送数据时一般是字符串。</p>
</li>
<li><p>我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。</p>
</li>
<li><p>语法：<code>JSON.stringify(value[, replacer[, space]])</code></p>
</li>
<li><p>参数说明：</p>
<ul>
<li><code>value</code>  –  要转换的 JavaScript 值（通常为对象或数组）。</li>
<li><code>replacer</code> – 用于转换结果的函数或数组</li>
<li><code>space</code>  –  文本添加缩进、空格和换行符</li>
</ul>
</li>
</ul>
<h3 id="jsoncpp-详解"><a href="#jsoncpp-详解" class="headerlink" title="jsoncpp 详解"></a>jsoncpp 详解</h3><ul>
<li><p>开源程序：<code>libjsoncpp</code></p>
</li>
<li><p>地址：<code>https://github.com/open-source-parsers/jsoncpp</code></p>
</li>
<li><p>将仓库克隆到本地，cmake编译完成之后，当做第三方库的方式为：</p>
<ul>
<li>头文件：jsoncpp&#x2F;include&#x2F;json</li>
<li>静态库和动态库文件：build&#x2F;lib&#x2F;</li>
</ul>
</li>
</ul>
<h3 id="jsoncpp-基本用法"><a href="#jsoncpp-基本用法" class="headerlink" title="jsoncpp 基本用法"></a>jsoncpp 基本用法</h3><ul>
<li><p>jsonCpp主要包含三种类型的<code>class</code>：<code>value</code>、<code>reader</code>、<code>write</code>。</p>
</li>
<li><p>jsonCpp总所有对象、类名都在namespace json中</p>
</li>
<li><p><code>Json::Value</code></p>
<ul>
<li>Json::Value时jsonCpp中最基本、最重要的类，用于表示各种类型的对象，jsoncpp 支持的对象类型可见 <code>Json::ValueType</code> 枚举值。</li>
<li>在把value插入值后再输出来，输出的值是按字母表的顺序排列。<ul>
<li><code>Json::Value root;</code></li>
<li><code>root[&quot;status&quot;] = 1;			//新建一个key为status，赋予数值1</code></li>
<li><code>root[&quot;message&quot;] = &quot;OK&quot;;		//新建一个key为message，赋予字符串OK</code></li>
<li><code>root[&quot;array&quot;].append(&quot;arr&quot;); //新建一个key为array，类型为数组，对第一个元素赋值为字符串“arr”</code></li>
<li><code>root[&quot;array&quot;].append(1234);  // 为数组 key_array 赋值，对第二个元素赋值为：1234。</code></li>
<li><code>Json::ValueType type = root.type();	//获得root的类型</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>Json::Writer</code></p>
<ul>
<li><code>Json::Writer</code>负责将内存中的<code>Value</code>对象转换成<code>JSON</code>文档，输出到文件或者是字符串中</li>
<li>Json::Writer是一个纯虚类，不能直接使用，一般使用<code>Json::Writer</code>的子类：<code>Json::FasterWriter</code>, <code>Json::StyledWriter</code>、<code>Json::StyledStreamWriter</code></li>
<li>注：在新版中<code>Json::FasterWriter</code>, <code>Json::StyledWriter</code>、<code>Json::Reader</code>都被弃用，替代的是<code>Json::StreamWriterBuilder</code>、<code>Json::CharReaderBuilder</code><ul>
<li><code>Json::FasterWriter</code>：速度最快</li>
<li><code>Json::StyledWriter</code>：格式化后的json</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Json::Reader</code></p>
<ul>
<li>用于读取，准确说是用于将字符串或者文件输入流转换为Json::Value对象的</li>
<li><code>parse()</code></li>
<li>使用<code>Json::Reader</code>对<code>json</code>文件进行解析<ul>
<li>声明：<code>bool parse(const std::string&amp; document, Value&amp; root, bool collectComments = true);</code></li>
<li>参数：<ul>
<li><code>root</code>:（输出）Json::Value的对象</li>
</ul>
</li>
</ul>
</li>
<li>使用Json::Reader对json输入流（文件）进行解析<ul>
<li>声明：<code>bool parse(std:stream&amp; is, Value&amp; root, bool collectComment = true);</code></li>
</ul>
</li>
<li>使用Json::Reader对字符串进行解析<ul>
<li>声明：<code>bool parse(const char* beginDoc, const char* ednDoc, Value&amp; root, bool collectComment = true);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="JsonCpp其他操作"><a href="#JsonCpp其他操作" class="headerlink" title="JsonCpp其他操作"></a>JsonCpp其他操作</h3><ul>
<li><p>判断key是否存在</p>
<ul>
<li>声明：<code>bool Json::Value::isMember ( const char * key) const；</code></li>
<li>存在返回1，否则返回0</li>
</ul>
</li>
<li><p>判断是否为null成员函数</p>
</li>
<li><p>注：Json::Value和C++中的map有一个共同的特点，就是当你尝试访问一个不存在的 key 时，会自动生成这样一个key-value默认为null的值对。</p>
</li>
<li><p>得到所有成员</p>
<ul>
<li><code>typedef std::vectorstd::string Json::Value::Members;</code></li>
<li><code>Value::Members Json::Value::getMemberNames ( ) const;</code></li>
<li>该函数的类型为一个string的vector。</li>
</ul>
</li>
<li><p>删除成员</p>
<ul>
<li><code>Value Json::Value::removeMember( const char* key)</code></li>
<li>返回删除的值，或者null</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_07_cryptopp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_07_cryptopp/" class="post-title-link" itemprop="url">C++_04_07_cryptopp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cryptopp库</li>
</ul>
<h2 id="cryptopp是什么"><a href="#cryptopp是什么" class="headerlink" title="cryptopp是什么"></a>cryptopp是什么</h2><p>Crypto++（CryptoPP）是一个免费的开源密码学库，用于实现各种密码学算法和协议。它提供了许多常见的对称加密算法（如AES、DES、Blowfish等）、非对称加密算法（如RSA、DSA、ECDSA等）、哈希函数（如SHA-1、SHA-256、MD5等）、消息认证码（如HMAC）以及其他密码学算法的实现。</p>
<p>Crypto++库是用C++语言编写的，设计用于提供高性能和可移植性。它采用了面向对象的设计，提供了一组易于使用的C++类和模板，使开发者能够轻松地在其应用程序中集成密码学功能。</p>
<p>Crypto++库在许多操作系统和平台上都可用，并已经被广泛应用于许多领域，包括网络安全、加密通信、数字签名、数据完整性验证等。</p>
<p>总之，Crypto++是一个强大而灵活的密码学库，为开发者提供了实现安全通信和数据保护所需的工具和算法。</p>
<h2 id="C-cryptopp-详解"><a href="#C-cryptopp-详解" class="headerlink" title="C++ cryptopp 详解"></a>C++ cryptopp 详解</h2><p>Crypto++（也称为CryptoPP）是一个强大的密码学库，提供了丰富的密码学算法和工具，包括对称加密、非对称加密、哈希函数、消息认证码（MAC）、数字签名等。它是用C++编写的，旨在提供高性能、可移植和易于使用的接口。下面我将详细解释Crypto++的一些重要方面：</p>
<h3 id="1-密码学算法支持"><a href="#1-密码学算法支持" class="headerlink" title="1. 密码学算法支持"></a>1. 密码学算法支持</h3><p>Crypto++支持各种密码学算法，包括对称加密、非对称加密、哈希函数和消息认证码。一些常见的算法包括：</p>
<ul>
<li><strong>对称加密算法</strong>：AES、DES、Triple-DES、Blowfish等。</li>
<li><strong>非对称加密算法</strong>：RSA、DSA、ECDSA、DH等。</li>
<li><strong>哈希函数</strong>：SHA-1、SHA-256、SHA-512、MD5等。</li>
<li><strong>消息认证码</strong>：HMAC、CMAC等。</li>
</ul>
<h3 id="2-对象模型和易用性"><a href="#2-对象模型和易用性" class="headerlink" title="2. 对象模型和易用性"></a>2. 对象模型和易用性</h3><p>Crypto++采用了面向对象的设计，提供了一组易于使用的C++类和模板。这使得开发人员可以轻松地在其应用程序中集成密码学功能，并使用简单的接口进行加密、解密、签名和验证等操作。</p>
<h3 id="3-高性能和优化"><a href="#3-高性能和优化" class="headerlink" title="3. 高性能和优化"></a>3. 高性能和优化</h3><p>Crypto++对性能进行了优化，旨在提供快速的加密和解密速度。它使用了各种优化技术，包括内联汇编、CPU指令级优化、并行化等，以最大程度地提高执行效率。</p>
<h3 id="4-跨平台支持"><a href="#4-跨平台支持" class="headerlink" title="4. 跨平台支持"></a>4. 跨平台支持</h3><p>Crypto++可在多种操作系统和平台上运行，包括Windows、Linux、macOS等。这使得开发人员可以在不同的环境中使用相同的代码来实现安全通信和数据保护。</p>
<h3 id="5-开源和免费"><a href="#5-开源和免费" class="headerlink" title="5. 开源和免费"></a>5. 开源和免费</h3><p>Crypto++是开源的，根据公共领域许可证（Public Domain License）发布，允许开发人员免费使用、修改和分发库的源代码。这使得它成为了一个广泛使用的密码学工具，被许多项目和组织采用。</p>
<h3 id="6-社区支持和文档"><a href="#6-社区支持和文档" class="headerlink" title="6. 社区支持和文档"></a>6. 社区支持和文档</h3><p>Crypto++拥有一个活跃的开发和用户社区，提供了丰富的文档、示例代码和教程，帮助开发人员快速入门并解决问题。</p>
<p>综上所述，Crypto++是一个功能强大、性能优越、易于使用的密码学库，适用于各种安全应用和需求。无论是加密通信、数据保护还是数字签名等方面，Crypto++都提供了全面的解决方案。</p>
<h2 id="cryptopp-编译和安装"><a href="#cryptopp-编译和安装" class="headerlink" title="cryptopp 编译和安装"></a>cryptopp 编译和安装</h2><ul>
<li>编译: make libcryptopp.a libcryptopp.so cryptest.exe</li>
<li>安装: sudo make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;<ul>
<li>默认安装目录为: &#x2F;usr&#x2F;local&#x2F;include&#x2F;</li>
</ul>
</li>
</ul>
<h2 id="openssl库包括crpto库吗"><a href="#openssl库包括crpto库吗" class="headerlink" title="openssl库包括crpto库吗"></a>openssl库包括crpto库吗</h2><p>是的，OpenSSL 库包括了 Crypto 库。OpenSSL 是一个开放源代码的软件库，提供了一套加密和通信安全功能。其中，Crypto 库提供了各种密码学功能，如对称加密、非对称加密、哈希函数等。这些功能可以被其他应用程序调用，用于数据的加密、数字签名、SSL&#x2F;TLS 连接等安全通信操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_09_libssl-dev/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_09_libssl-dev/" class="post-title-link" itemprop="url">C++_04_09_libssl-dev</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>libssl-dev库 是什么</li>
</ul>
<h2 id="libssl-dev库-是什么"><a href="#libssl-dev库-是什么" class="headerlink" title="libssl-dev库 是什么"></a>libssl-dev库 是什么</h2><p>libssl-dev是一个软件包，它提供了在Linux系统上开发使用OpenSSL库的软件所需的头文件和静态库。OpenSSL是一个用于安全套接字层 (SSL) 和传输层安全 (TLS) 协议的开源实现，它提供了加密、解密、数字证书生成和管理等功能。libssl-dev包通常用于编译和构建依赖于OpenSSL的应用程序。</p>
<h2 id="libssl-dev库-详解"><a href="#libssl-dev库-详解" class="headerlink" title="libssl-dev库 详解"></a>libssl-dev库 详解</h2><p>libssl-dev库实际上是一个软件包，通常用于在Linux系统上开发使用OpenSSL库的软件。让我们更详细地解释一下：</p>
<ol>
<li><p><strong>OpenSSL</strong>：OpenSSL是一个开源的加密和安全套接字层（SSL&#x2F;TLS）协议的实现。它提供了许多加密算法和安全功能，包括对SSL和TLS协议的支持、数字证书的生成和管理、对称加密和非对称加密、哈希函数等。OpenSSL广泛应用于互联网上的安全通信、加密数据存储以及身份验证等方面。</p>
</li>
<li><p><strong>libssl-dev库</strong>：libssl-dev是一个软件包，一般在Debian或基于Debian的Linux发行版（如Ubuntu）中使用。它提供了用于开发和编译依赖于OpenSSL库的软件所需的头文件和静态库。头文件包含了函数声明和常量定义等信息，静态库则包含了OpenSSL的实现代码，开发者可以链接到他们的程序中。</p>
</li>
<li><p><strong>作用</strong>：libssl-dev库的作用在于为开发者提供了必要的工具和资源，使他们能够开发基于OpenSSL的应用程序。这些应用程序可以涉及到加密通信、安全连接、数字证书管理等领域。通过使用libssl-dev，开发者可以利用OpenSSL的功能来增强他们的软件的安全性和可靠性。</p>
</li>
</ol>
<p>总之，libssl-dev库是用于在Linux系统上开发使用OpenSSL库的软件所需的软件包，它提供了开发者编写、编译和构建基于OpenSSL的应用程序所需的头文件和静态库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_2_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_2_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">C++_06_2_编程技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C&#x2F;C++常用的编程技巧</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_2_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_04_libmagic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_04_libmagic/" class="post-title-link" itemprop="url">C++_04_04_libmagic</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>libmagic</li>
</ul>
<h2 id="libmagic"><a href="#libmagic" class="headerlink" title="libmagic"></a>libmagic</h2><p><code>libmagic</code> 是一个开源的库，用于识别文件类型。它能够通过分析文件的内容来判断文件的类型，而不仅仅依赖于文件的扩展名。这个库最初由 Ian F. Darwin 创建，并且后来被维护和扩展，成为一个广泛使用的文件类型检测工具。</p>
<p>以下是关于 <code>libmagic</code> 的一些详细解释：</p>
<ol>
<li><p>文件类型识别：<br><code>libmagic</code> 主要用于识别文件的类型。它可以根据文件的内容（magic bytes）来判断文件的类型，例如文本文件、二进制文件、图像、音频、视频、压缩文件等。</p>
</li>
<li><p>magic 文件：<br><code>libmagic</code> 使用一个名为 <code>magic</code> 的文件来描述文件类型的规则。这个文件包含了一系列的规则和魔术字节（magic bytes）来帮助识别文件类型。这些规则可以被定制和扩展，以适应不同的需求。</p>
</li>
<li><p>魔术字节：<br>魔术字节是一个文件中特定位置的字节序列，用于标识文件类型。例如，许多图像文件的开头会有特定的字节序列，用于识别该文件为图像类型。</p>
</li>
<li><p>命令行工具：<br><code>libmagic</code> 提供了一个命令行工具 <code>file</code>，用于在命令行中直接识别文件类型。您可以在命令行中输入 <code>file filename</code> 来获取文件的类型信息。</p>
</li>
<li><p>编程接口：<br><code>libmagic</code> 也提供了编程接口，使开发者可以将文件类型检测功能集成到自己的应用程序中。主要有 C、Python、Perl 和 Ruby 等语言的接口。</p>
</li>
<li><p>跨平台支持：<br><code>libmagic</code> 是一个跨平台的库，在 Linux、Unix、macOS 和 Windows 等操作系统上都可以使用。</p>
</li>
</ol>
<p>总的来说，<code>libmagic</code> 是一个非常有用的文件类型检测工具，能够帮助我们在文件处理和分析时更准确地判断文件类型，从而做出相应的处理。它被广泛用于文件管理、数据恢复、多媒体应用、网络传输等领域。</p>
<h2 id="C-libmagic库-详解"><a href="#C-libmagic库-详解" class="headerlink" title="C++ libmagic库 详解"></a>C++ libmagic库 详解</h2><p><code>libmagic</code>是一个用于文件类型识别的C库，它可以通过分析文件的内容或者文件的魔术数字（magic number）来确定文件的类型。在UNIX系统中，<code>libmagic</code>通常被用来确定文件类型，以便应用程序可以根据文件类型采取相应的操作。</p>
<p>下面是一个简要的<code>libmagic</code>的详解：</p>
<h3 id="功能和特点："><a href="#功能和特点：" class="headerlink" title="功能和特点："></a>功能和特点：</h3><ol>
<li><p><strong>文件类型识别</strong>：<code>libmagic</code>可以通过读取文件的内容或者文件的魔术数字来确定文件的类型，如文本文件、图像文件、音频文件等。</p>
</li>
<li><p><strong>多种支持格式</strong>：<code>libmagic</code>支持识别多种常见的文件格式，包括但不限于文本文件、二进制文件、压缩文件、图像文件、音频文件等。</p>
</li>
<li><p><strong>跨平台性</strong>：<code>libmagic</code>在UNIX和类UNIX系统中通常被广泛使用，但也可以在其他操作系统上使用，如Windows。</p>
</li>
<li><p><strong>易于集成</strong>：由于是C库，<code>libmagic</code>易于集成到C和C++程序中，并且提供了一些编程接口来方便地进行文件类型识别。</p>
</li>
</ol>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><ol>
<li><p><strong>初始化</strong>：首先需要初始化<code>libmagic</code>，通常是通过<code>magic_open()</code>函数来实现。该函数返回一个指向<code>magic_t</code>结构的指针，该结构代表了一个<code>libmagic</code>的实例。</p>
</li>
<li><p><strong>设置配置</strong>：可以通过一些函数来配置<code>libmagic</code>，例如<code>magic_load()</code>函数可以用来加载魔术文件（magic file），该文件包含了一系列的规则，用于识别文件类型。</p>
</li>
<li><p><strong>文件类型识别</strong>：通过<code>magic_file()</code>或<code>magic_buffer()</code>等函数来实现文件类型的识别。<code>magic_file()</code>用于指定文件路径，而<code>magic_buffer()</code>用于指定文件的内存缓冲区和大小。</p>
</li>
<li><p><strong>获取结果</strong>：识别完成后，可以通过<code>magic_getpath()</code>、<code>magic_getmime()</code>等函数来获取识别结果，如文件类型、MIME类型等。</p>
</li>
<li><p><strong>清理资源</strong>：最后需要通过<code>magic_close()</code>函数来关闭<code>libmagic</code>的实例，释放资源。</p>
</li>
</ol>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><p>下面是一个简单的C++示例代码，演示了如何使用<code>libmagic</code>库来识别文件类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;magic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">magic_t</span> magic_cookie;</span><br><span class="line">    magic_cookie = <span class="built_in">magic_open</span>(MAGIC_MIME_TYPE);</span><br><span class="line">    <span class="keyword">if</span> (magic_cookie == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to initialize magic library&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">magic_load</span>(magic_cookie, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Cannot load magic database - &quot;</span> &lt;&lt; <span class="built_in">magic_error</span>(magic_cookie) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">magic_close</span>(magic_cookie);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* mime_type = <span class="built_in">magic_file</span>(magic_cookie, filename);</span><br><span class="line">    <span class="keyword">if</span> (mime_type == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Cannot determine MIME type&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">magic_close</span>(magic_cookie);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MIME type of &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; mime_type &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">magic_close</span>(magic_cookie);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><p>在使用<code>libmagic</code>之前，需要确保已经安装了相关的开发包，以及<code>magic.h</code>头文件和<code>libmagic</code>库文件。</p>
</li>
<li><p>在使用<code>magic_load()</code>加载魔术文件之前，确保已经将相应的魔术文件（通常是<code>magic.mgc</code>）放置在正确的位置，或者使用合适的参数来指定魔术文件的路径。</p>
</li>
<li><p>在释放<code>libmagic</code>资源之前，确保调用了<code>magic_close()</code>函数，以避免资源泄漏。</p>
</li>
</ul>
<p>总的来说，<code>libmagic</code>提供了一种简单而强大的方法来确定文件类型，对于需要进行文件类型识别的应用程序来说是一个非常有用的工具库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_1_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_1_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">C++_06_1_编程技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>常用的编程技巧，使用示例与方法</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_1_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
