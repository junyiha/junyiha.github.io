<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/30/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/30/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_92_ifconfig/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_92_ifconfig/" class="post-title-link" itemprop="url">linux_2_92_ifconfig</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux ifconfig命令 详解</li>
</ul>
<h2 id="linux-ifconfig命令-详解"><a href="#linux-ifconfig命令-详解" class="headerlink" title="linux ifconfig命令 详解"></a>linux ifconfig命令 详解</h2><p><code>ifconfig</code> 是一个用于配置和显示网络接口信息的命令，在 Linux 和 Unix 系统中广泛使用。尽管它在一些较新的发行版中已经被弃用，但仍然有很多人使用它。以下是 <code>ifconfig</code> 命令的一些常见用法和选项：</p>
<ol>
<li><p><strong>显示所有网络接口信息</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p>这会显示系统中所有网络接口的详细信息，包括接口名称、MAC 地址、IP 地址、子网掩码、广播地址等。</p>
</li>
<li><p><strong>显示指定网络接口信息</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig &lt;接口名称&gt;</span><br></pre></td></tr></table></figure>
<p>通过指定接口名称，你可以只显示特定接口的信息。</p>
</li>
<li><p><strong>启用网络接口</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ifconfig &lt;接口名称&gt; up</span><br></pre></td></tr></table></figure>
<p>这会启用指定的网络接口。</p>
</li>
<li><p><strong>禁用网络接口</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ifconfig &lt;接口名称&gt; down</span><br></pre></td></tr></table></figure>
<p>这会禁用指定的网络接口。</p>
</li>
<li><p><strong>设置 IP 地址</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ifconfig &lt;接口名称&gt; &lt;IP 地址&gt; netmask &lt;子网掩码&gt;</span><br></pre></td></tr></table></figure>
<p>这会为指定的网络接口设置 IP 地址和子网掩码。</p>
</li>
<li><p><strong>设置 MAC 地址</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ifconfig &lt;接口名称&gt; hw ether &lt;新的 MAC 地址&gt;</span><br></pre></td></tr></table></figure>
<p>这会为指定的网络接口设置新的 MAC 地址。</p>
</li>
</ol>
<p><code>ifconfig</code> 命令提供了一种快速查看和配置网络接口的方式，但在一些新的 Linux 发行版中已经被更现代的工具如 <code>ip</code> 命令所取代。因此，为了获得更多功能和更好的兼容性，建议使用 <code>ip</code> 命令来替代 <code>ifconfig</code>。</p>
<h2 id="linux-ifconfig命令-常用技巧"><a href="#linux-ifconfig命令-常用技巧" class="headerlink" title="linux ifconfig命令 常用技巧"></a>linux ifconfig命令 常用技巧</h2><p>当使用 <code>ifconfig</code> 命令时，有一些常用的技巧可以帮助你更有效地管理和诊断网络接口。以下是一些常用的技巧：</p>
<ol>
<li><p><strong>显示特定网络接口信息</strong>：<br>如果你只想查看特定网络接口的信息，可以直接在 <code>ifconfig</code> 命令后面指定接口名称，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0</span><br></pre></td></tr></table></figure>
<p>这将只显示名为 <code>eth0</code> 的网络接口的信息。</p>
</li>
<li><p><strong>显示所有接口信息</strong>：<br>如果你想查看系统中所有网络接口的信息，可以简单地运行 <code>ifconfig</code> 命令而不带任何参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p>这将显示所有网络接口的详细信息。</p>
</li>
<li><p><strong>启用或禁用网络接口</strong>：<br>使用 <code>ifconfig</code> 命令可以启用或禁用网络接口。例如，要启用接口，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ifconfig eth0 up</span><br></pre></td></tr></table></figure>
<p>要禁用接口，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ifconfig eth0 down</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置 IP 地址和子网掩码</strong>：<br>使用 <code>ifconfig</code> 命令可以为网络接口设置 IP 地址和子网掩码。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ifconfig eth0 192.168.1.10 netmask 255.255.255.0</span><br></pre></td></tr></table></figure>
<p>这会将 <code>eth0</code> 接口的 IP 地址设置为 <code>192.168.1.10</code>，子网掩码为 <code>255.255.255.0</code>。</p>
</li>
<li><p><strong>设置 MAC 地址</strong>：<br>使用 <code>ifconfig</code> 命令可以设置网络接口的 MAC 地址。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ifconfig eth0 hw ether 00:11:22:33:44:55</span><br></pre></td></tr></table></figure>
<p>这会将 <code>eth0</code> 接口的 MAC 地址设置为 <code>00:11:22:33:44:55</code>。</p>
</li>
<li><p><strong>清空 IP 地址</strong>：<br>有时候你可能需要清空网络接口的 IP 地址，可以通过设置 IP 地址为 0.0.0.0 来实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ifconfig eth0 0.0.0.0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示简洁的输出</strong>：<br>如果你只需要网络接口的关键信息，你可以使用 <code>-s</code> 选项来显示简洁的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -s</span><br></pre></td></tr></table></figure>
<p>这将只显示每个接口的基本信息，如接口名称、IP 地址、MTU 等。</p>
</li>
</ol>
<p>使用这些技巧可以让你更加灵活地使用 <code>ifconfig</code> 命令，并更有效地管理和诊断 Linux 系统中的网络接口。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_89_crontab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_89_crontab/" class="post-title-link" itemprop="url">linux_2_89_crontab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux crontab命令 详解</li>
</ul>
<h2 id="linux-crontab命令-详解"><a href="#linux-crontab命令-详解" class="headerlink" title="linux crontab命令 详解"></a>linux crontab命令 详解</h2><p>当你需要在Linux系统上定期执行任务时，<code>crontab</code>命令就会派上用场。<code>crontab</code>（”cron table”的缩写）是一个用于管理和操作系统定时任务的工具。它允许用户创建、编辑、查看和删除定时任务。</p>
<h3 id="1-查看当前用户的定时任务列表"><a href="#1-查看当前用户的定时任务列表" class="headerlink" title="1. 查看当前用户的定时任务列表"></a>1. 查看当前用户的定时任务列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>

<p>这个命令会列出当前用户的所有定时任务。</p>
<h3 id="2-编辑当前用户的定时任务列表"><a href="#2-编辑当前用户的定时任务列表" class="headerlink" title="2. 编辑当前用户的定时任务列表"></a>2. 编辑当前用户的定时任务列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>这个命令会打开一个文本编辑器，允许你编辑当前用户的定时任务列表。编辑完成后保存并退出编辑器。</p>
<h3 id="3-移除当前用户的所有定时任务"><a href="#3-移除当前用户的所有定时任务" class="headerlink" title="3. 移除当前用户的所有定时任务"></a>3. 移除当前用户的所有定时任务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -r</span><br></pre></td></tr></table></figure>

<p>这个命令会移除当前用户的所有定时任务。</p>
<h3 id="4-添加定时任务"><a href="#4-添加定时任务" class="headerlink" title="4. 添加定时任务"></a>4. 添加定时任务</h3><p><code>crontab</code>的定时任务格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command_to_execute</span><br><span class="line">- - - - -</span><br><span class="line">| | | | |</span><br><span class="line">| | | | +----- Day of week (0 - 7) (Sunday=0 or 7)</span><br><span class="line">| | | +------- Month (1 - 12)</span><br><span class="line">| | +--------- Day of month (1 - 31)</span><br><span class="line">| +----------- Hour (0 - 23)</span><br><span class="line">+------------- Minute (0 - 59)</span><br></pre></td></tr></table></figure>

<p>每一列代表了定时任务执行的时间要求，分别是分钟、小时、日期、月份和星期。你可以设置相应的数字、星号（代表任意值）、逗号（分隔多个值）、连字符（表示范围）、以及正斜杠（用于指定间隔）来定义定时任务的执行时间。</p>
<p>例如：</p>
<ul>
<li><code>0 0 * * * command</code> 每天午夜执行任务</li>
<li><code>*/15 * * * * command</code> 每隔15分钟执行任务</li>
<li><code>0 8,12,16 * * * command</code> 每天的8点、12点和16点执行任务</li>
</ul>
<h3 id="5-使用案例"><a href="#5-使用案例" class="headerlink" title="5. 使用案例"></a>5. 使用案例</h3><p>假设你有一个名为<code>backup.sh</code>的备份脚本，想要每天凌晨4点备份一次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>然后在编辑器中添加以下行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 4 * * * /path/to/backup.sh</span><br></pre></td></tr></table></figure>

<p>保存并退出编辑器。现在，<code>backup.sh</code>脚本将会每天凌晨4点执行备份任务。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_93_nslookup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_93_nslookup/" class="post-title-link" itemprop="url">linux_2_93_nslookup</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux nslookup命令 详解</li>
</ul>
<h2 id="linux-nslookup命令-详解"><a href="#linux-nslookup命令-详解" class="headerlink" title="linux nslookup命令 详解"></a>linux nslookup命令 详解</h2><p><code>nslookup</code> 命令用于查询域名系统 (DNS) 的记录，获取域名的 IP 地址或反向查找 IP 地址对应的域名。以下是 <code>nslookup</code> 命令的一些常见用法和选项：</p>
<ol>
<li><p><strong>查询域名的 IP 地址</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup example.com</span><br></pre></td></tr></table></figure>
<p>这会查询域名 <code>example.com</code> 的 IP 地址。</p>
</li>
<li><p><strong>查询指定类型的 DNS 记录</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -<span class="built_in">type</span>=&lt;记录类型&gt; example.com</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>-type</code> 选项来指定查询的 DNS 记录类型，如 <code>A</code> 记录、<code>MX</code> 记录、<code>NS</code> 记录等。</p>
</li>
<li><p><strong>反向查询 IP 地址对应的域名</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup &lt;IP 地址&gt;</span><br></pre></td></tr></table></figure>
<p>这会查询指定 IP 地址对应的域名。</p>
</li>
<li><p><strong>指定特定的 DNS 服务器</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup example.com &lt;DNS 服务器地址&gt;</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>nslookup</code> 会使用系统配置的 DNS 服务器。你可以通过在命令后面指定 DNS 服务器地址来使用其他的 DNS 服务器进行查询。</p>
</li>
<li><p><strong>退出交互模式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>在进入 <code>nslookup</code> 的交互模式后，你可以通过输入 <code>exit</code> 来退出交互模式。</p>
</li>
</ol>
<p><code>nslookup</code> 命令可以帮助你诊断网络问题，例如查找域名对应的 IP 地址或查找 IP 地址对应的域名。它是一个非常有用的网络工具，可以在 Linux、Windows 和其他操作系统上使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_94_nmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_94_nmap/" class="post-title-link" itemprop="url">linux_2_94_nmap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux nmap命令 详解</li>
</ul>
<h2 id="linux-nmap命令-详解"><a href="#linux-nmap命令-详解" class="headerlink" title="linux nmap命令 详解"></a>linux nmap命令 详解</h2><p><code>nmap</code> 是一个功能强大的网络扫描工具，可以用于探测主机、服务以及网络上的各种信息。它在网络安全领域广泛应用，可用于网络发现、漏洞扫描、服务版本探测等任务。下面是 <code>nmap</code> 命令的一些常见用法和选项：</p>
<h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap [扫描类型] [目标主机或网络]</span><br></pre></td></tr></table></figure>

<h3 id="常用扫描类型："><a href="#常用扫描类型：" class="headerlink" title="常用扫描类型："></a>常用扫描类型：</h3><ul>
<li><code>-sS</code>：TCP SYN 扫描，常用于快速扫描。</li>
<li><code>-sT</code>：TCP 连接扫描，完整连接的方式扫描，速度较慢。</li>
<li><code>-sU</code>：UDP 扫描，用于扫描 UDP 端口。</li>
<li><code>-sF</code>：FIN 扫描，发送 FIN 包给目标主机。</li>
<li><code>-sX</code>：XMAS 扫描，发送 URG、PSH、FIN 标志给目标主机。</li>
<li><code>-sN</code>：NULL 扫描，发送没有标志的 TCP 包给目标主机。</li>
</ul>
<h3 id="其他常用选项："><a href="#其他常用选项：" class="headerlink" title="其他常用选项："></a>其他常用选项：</h3><ul>
<li><code>-p</code>：指定要扫描的端口或端口范围。</li>
<li><code>-A</code>：启用操作系统检测、服务版本检测、脚本扫描等一系列功能。</li>
<li><code>-O</code>：对目标主机进行操作系统检测。</li>
<li><code>-T</code>：指定扫描的速度&#x2F;对目标主机进行操作系统检测。</li>
<li><code>-v</code>：详细模式，显示更多信息。</li>
<li><code>-oN</code>：将扫描结果保存到文件中。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><ol>
<li><p>扫描单个主机的常用端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 1-1000 192.168.1.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描整个子网的常见端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 1-1000 192.168.1.0/24</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用操作系统检测和服务版本检测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A 192.168.1.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 TCP SYN 扫描对单个主机进行快速扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS 192.168.1.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 NULL 扫描扫描目标主机：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sN 192.168.1.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>对目标主机进行操作系统检测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O 192.168.1.1</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>nmap</code> 提供了丰富的选项和功能，可以根据需要进行定制化的扫描。记得在使用 <code>nmap</code> 进行扫描时，遵守网络安全和法律法规，避免对未经授权的系统进行扫描。</p>
<h2 id="linux-nmap命令-常用技巧"><a href="#linux-nmap命令-常用技巧" class="headerlink" title="linux nmap命令 常用技巧"></a>linux nmap命令 常用技巧</h2><p>当使用 <code>nmap</code> 进行网络扫描时，有一些常用的技巧可以帮助你更有效地执行扫描并获得更有用的信息。以下是一些常见的 <code>nmap</code> 技巧：</p>
<ol>
<li><p><strong>指定端口范围</strong>：使用 <code>-p</code> 选项可以指定要扫描的端口范围。例如，<code>-p 1-1000</code> 表示扫描端口范围从 1 到 1000。</p>
</li>
<li><p><strong>指定多个主机</strong>：你可以在命令中指定多个目标主机，以便同时扫描它们。例如，<code>nmap 192.168.1.1 192.168.1.2</code>。</p>
</li>
<li><p><strong>扫描整个子网</strong>：使用 CIDR 表示法来指定整个子网。例如，<code>nmap 192.168.1.0/24</code> 将扫描 192.168.1.0 到 192.168.1.255 的所有主机。</p>
</li>
<li><p><strong>快速扫描</strong>：使用 <code>-F</code> 选项进行快速扫描。它只扫描常用端口，速度更快。例如，<code>nmap -F 192.168.1.1</code>。</p>
</li>
<li><p><strong>启用操作系统检测</strong>：使用 <code>-O</code> 选项可以尝试识别目标主机的操作系统。例如，<code>nmap -O 192.168.1.1</code>。</p>
</li>
<li><p><strong>启用服务版本检测</strong>：使用 <code>-sV</code> 选项可以尝试识别目标主机上运行的服务的版本信息。例如，<code>nmap -sV 192.168.1.1</code>。</p>
</li>
<li><p><strong>脚本扫描</strong>：<code>nmap</code> 包含许多脚本，可以执行各种任务，如漏洞探测、服务识别等。使用 <code>--script</code> 选项来指定要运行的脚本。例如，<code>nmap --script vuln 192.168.1.1</code> 将运行漏洞扫描脚本。</p>
</li>
<li><p><strong>保存结果</strong>：使用 <code>-oN</code> 选项可以将扫描结果保存到文件中，方便后续分析。例如，<code>nmap -oN scan_results.txt 192.168.1.1</code>。</p>
</li>
<li><p><strong>扫描速度调整</strong>：使用 <code>-T</code> 选项可以调整扫描速度，范围从 0（最慢）到 5（最快）。例如，<code>nmap -T4 192.168.1.1</code> 将使用较快的扫描速度。</p>
</li>
<li><p><strong>显示详细信息</strong>：使用 <code>-v</code> 选项可以显示更详细的扫描信息。例如，<code>nmap -v 192.168.1.1</code>。</p>
</li>
</ol>
<p>这些技巧可以帮助你更灵活、更高效地使用 <code>nmap</code> 进行网络扫描，并获取更全面的信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_91_route/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_91_route/" class="post-title-link" itemprop="url">linux_2_91_route</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux route命令 详解</li>
</ul>
<h2 id="linux-route命令-详解"><a href="#linux-route命令-详解" class="headerlink" title="linux route命令 详解"></a>linux route命令 详解</h2><p><code>route</code> 命令在 Linux 中用于配置和显示 IP 路由表。它可以用于添加、删除、修改和显示路由信息。以下是一些常见的 <code>route</code> 命令用法：</p>
<ol>
<li><p><strong>显示路由表</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -e</span><br></pre></td></tr></table></figure>
<p>这将显示当前系统的路由表。<code>-n</code> 选项用于显示数值形式的 IP 地址和网络掩码，而不进行主机名和网络地址的反解析。</p>
</li>
<li><p><strong>添加路由</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.0.1</span><br></pre></td></tr></table></figure>
<p>这条命令将添加一个到 <code>192.168.1.0/24</code> 子网的路由，网关地址为 <code>192.168.0.1</code>。</p>
</li>
<li><p><strong>删除路由</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> route del -net 192.168.1.0 netmask 255.255.255.0</span><br></pre></td></tr></table></figure>
<p>这将删除指定子网的路由。</p>
</li>
<li><p><strong>添加默认网关</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> route add default gw 192.168.0.1</span><br></pre></td></tr></table></figure>
<p>这会将 <code>192.168.0.1</code> 设置为默认网关。</p>
</li>
<li><p><strong>删除默认网关</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> route del default gw 192.168.0.1</span><br></pre></td></tr></table></figure>
<p>这将删除默认网关的路由。</p>
</li>
<li><p><strong>显示详细信息</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n -A inet6</span><br></pre></td></tr></table></figure>
<p>这将显示 IPv6 路由表的详细信息。</p>
</li>
</ol>
<p><code>route</code> 命令的功能比较基础，更强大的路由管理一般使用 <code>ip route</code> 命令。在较新的 Linux 系统中，<code>route</code> 命令可能已经被废弃，建议使用 <code>ip route</code> 命令进行路由管理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_90_traceroute/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_90_traceroute/" class="post-title-link" itemprop="url">linux_2_90_traceroute</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux traceroute命令 详解</li>
</ul>
<h2 id="linux-traceroute命令-详解"><a href="#linux-traceroute命令-详解" class="headerlink" title="linux traceroute命令 详解"></a>linux traceroute命令 详解</h2><p><code>traceroute</code> 命令用于追踪数据包从本地主机到目标主机的路径。它通过发送 ICMP 回显请求报文（ping）到目标主机，并记录每个经过的路由器的 IP 地址，以及到达目标主机的时间。以下是 <code>traceroute</code> 命令的一些常见用法和选项：</p>
<ol>
<li><p><strong>基本用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute &lt;目标主机&gt;</span><br></pre></td></tr></table></figure>
<p>这会启动一个追踪路由的过程，显示从本地主机到目标主机的路径信息。</p>
</li>
<li><p><strong>显示 IP 地址</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -n &lt;目标主机&gt;</span><br></pre></td></tr></table></figure>
<p>使用 <code>-n</code> 选项将显示 IP 地址，而不进行反向 DNS 查询。</p>
</li>
<li><p><strong>指定最大跃点数</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -m &lt;最大跃点数&gt; &lt;目标主机&gt;</span><br></pre></td></tr></table></figure>
<p>使用 <code>-m</code> 选项可以指定最大的跃点数（最大 TTL 值），以限制路由跟踪的跳数。</p>
</li>
<li><p><strong>使用 UDP 数据包</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -U &lt;目标主机&gt;</span><br></pre></td></tr></table></figure>
<p>使用 <code>-U</code> 选项可以指定使用 UDP 数据包而不是默认的 ICMP 回显请求。</p>
</li>
<li><p><strong>使用指定的端口号</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -p &lt;端口号&gt; &lt;目标主机&gt;</span><br></pre></td></tr></table></figure>
<p>使用 <code>-p</code> 选项可以指定发送数据包的目标端口号。</p>
</li>
<li><p><strong>设置报文发送间隔</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -z &lt;间隔时间&gt; &lt;目标主机&gt;</span><br></pre></td></tr></table></figure>
<p>使用 <code>-z</code> 选项可以设置发送报文之间的间隔时间。</p>
</li>
</ol>
<p><code>traceroute</code> 命令非常有用，可以用于诊断网络问题、分析网络路径以及调试网络配置。注意，不同系统版本可能会略有不同，因此建议查看相应版本的 <code>traceroute</code> 命令的文档以获取更多信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_95_p7zip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_95_p7zip/" class="post-title-link" itemprop="url">linux_2_95_p7zip</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>p7zip命令 详解</li>
</ul>
<h2 id="linux-p7zip命令-详解"><a href="#linux-p7zip命令-详解" class="headerlink" title="linux p7zip命令 详解"></a>linux p7zip命令 详解</h2><p><code>p7zip</code> 是一个基于7-Zip的开源文件压缩和解压缩工具，用于Linux平台。它提供了一个命令行界面，允许用户使用不同的选项来执行各种压缩和解压缩操作。以下是 <code>p7zip</code> 命令的一些常见用法和选项：</p>
<h3 id="1-压缩文件或目录："><a href="#1-压缩文件或目录：" class="headerlink" title="1. 压缩文件或目录："></a>1. 压缩文件或目录：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a [压缩文件名].7z [要压缩的文件或目录]</span><br></pre></td></tr></table></figure>

<h3 id="2-解压缩文件："><a href="#2-解压缩文件：" class="headerlink" title="2. 解压缩文件："></a>2. 解压缩文件：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z x [压缩文件名].7z</span><br></pre></td></tr></table></figure>

<h3 id="3-列出压缩文件中的内容："><a href="#3-列出压缩文件中的内容：" class="headerlink" title="3. 列出压缩文件中的内容："></a>3. 列出压缩文件中的内容：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z l [压缩文件名].7z</span><br></pre></td></tr></table></figure>

<h3 id="4-使用密码进行压缩和解压缩："><a href="#4-使用密码进行压缩和解压缩：" class="headerlink" title="4. 使用密码进行压缩和解压缩："></a>4. 使用密码进行压缩和解压缩：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7z a -p[密码] [压缩文件名].7z [要压缩的文件或目录]</span><br><span class="line">7z x -p[密码] [压缩文件名].7z</span><br></pre></td></tr></table></figure>

<h3 id="5-设置压缩级别："><a href="#5-设置压缩级别：" class="headerlink" title="5. 设置压缩级别："></a>5. 设置压缩级别：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -mx=[压缩级别] [压缩文件名].7z [要压缩的文件或目录]</span><br></pre></td></tr></table></figure>

<p>其中 <code>[压缩级别]</code> 是一个介于0和9之间的整数，0表示无压缩，9表示最高压缩率。</p>
<h3 id="6-指定压缩文件类型："><a href="#6-指定压缩文件类型：" class="headerlink" title="6. 指定压缩文件类型："></a>6. 指定压缩文件类型：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -t[压缩文件类型] [压缩文件名].[后缀名] [要压缩的文件或目录]</span><br></pre></td></tr></table></figure>

<p>例如，如果要创建一个tar格式的压缩文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -ttar [压缩文件名].tar [要压缩的文件或目录]</span><br></pre></td></tr></table></figure>

<h3 id="7-帮助和其他选项："><a href="#7-帮助和其他选项：" class="headerlink" title="7. 帮助和其他选项："></a>7. 帮助和其他选项：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z --help</span><br></pre></td></tr></table></figure>

<p>这将显示 <code>p7zip</code> 命令的所有可用选项和帮助信息。</p>
<p><code>p7zip</code> 命令非常灵活，并且可以用于各种情况下的文件压缩和解压缩操作。记住，在执行任何操作之前，最好先阅读它的帮助文档，以确保正确使用所需的选项。</p>
<h2 id="linux-p7zip命令-常用技巧"><a href="#linux-p7zip命令-常用技巧" class="headerlink" title="linux p7zip命令 常用技巧"></a>linux p7zip命令 常用技巧</h2><p>当使用 <code>p7zip</code> 命令时，以下是一些常用的技巧和技巧，可以提高效率并使操作更加方便：</p>
<ol>
<li><p><strong>批量压缩文件</strong>：使用通配符来压缩多个文件或目录。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a archive.7z file1.txt file2.txt directory/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>压缩文件并排除指定文件或目录</strong>：通过使用 <code>-x</code> 选项，可以在压缩时排除特定的文件或目录。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a archive.7z directory/ -x!*.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示压缩进度</strong>：通过使用 <code>-bsp1</code> 选项，可以在压缩或解压缩过程中显示进度百分比。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -bsp1 archive.7z directory/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将压缩文件分卷</strong>：通过使用 <code>-v</code> 选项，可以将压缩文件分割成指定大小的卷。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -v1m archive.7z directory/</span><br></pre></td></tr></table></figure>

<p> 这会将压缩文件分割成1MB大小的卷。</p>
</li>
<li><p><strong>加密压缩文件</strong>：通过使用 <code>-p</code> 选项，可以指定密码来加密压缩文件。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -psecret archive.7z directory/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解压特定文件</strong>：通过使用 <code>-o</code> 选项，可以指定解压缩文件的输出目录。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z x archive.7z -ooutput_directory/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>压缩文件时保留文件权限</strong>：通过使用 <code>-m0=Copy</code> 选项，可以在压缩时保留文件的权限。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -m0=Copy archive.7z directory/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用其他压缩算法</strong>：除了默认的7z算法外，还可以使用其他压缩算法，如zip。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z a -tzip archive.zip directory/</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些技巧可以帮助你更有效地使用 <code>p7zip</code> 命令，并根据需要进行自定义。记住查看命令的帮助文档，以了解更多可用选项和功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_4_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/2024-05-22-linux_4_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91_%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_4_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/2024-05-22-linux_4_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91_%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/" class="post-title-link" itemprop="url">linux_4_内核编译_常见错误</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>内核编译遇到的常见错误</li>
</ul>
<h2 id="编译内核报错-No-rule-to-make-target-‘debian-canonical-certs-pem‘-或-‘canonical-revoked-certs-pem‘-的解决方法"><a href="#编译内核报错-No-rule-to-make-target-‘debian-canonical-certs-pem‘-或-‘canonical-revoked-certs-pem‘-的解决方法" class="headerlink" title="编译内核报错 No rule to make target ‘debian&#x2F;canonical-certs.pem‘ 或 ‘canonical-revoked-certs.pem‘ 的解决方法"></a>编译内核报错 No rule to make target ‘debian&#x2F;canonical-certs.pem‘ 或 ‘canonical-revoked-certs.pem‘ 的解决方法</h2><ul>
<li><p>Ubuntu 编译 Linux 内核经常会遇到如下错误：</p>
</li>
<li><p>如果报错 canonical-certs.pem：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** No rule to make target <span class="string">&#x27;debian/canonical-certs.pem&#x27;</span>, needed by <span class="string">&#x27;certs/x509_certificate_list&#x27;</span>.  Stop.</span><br><span class="line">make: *** [Makefile:1868: certs] Error 2</span><br></pre></td></tr></table></figure></li>
<li><p>在命令行中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scripts/config --disable SYSTEM_TRUSTED_KEYS</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果报错 canonical-revoked-certs.pem：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** No rule to make target &#x27;debian/canonical-revoked-certs.pem&#x27;, needed by &#x27;certs/x509_revocation_list&#x27;.  Stop.</span><br><span class="line">make: *** [Makefile:1868: certs] Error 2</span><br></pre></td></tr></table></figure></li>
<li><p>在命令行中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scripts/config --disable SYSTEM_REVOCATION_KEYS</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/shell_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-shell_2_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/shell_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-shell_2_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">shell_2_2_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>shell编程常用技巧</li>
</ul>
<h2 id="linux-目录下按照规则排序文件"><a href="#linux-目录下按照规则排序文件" class="headerlink" title="linux 目录下按照规则排序文件"></a>linux 目录下按照规则排序文件</h2><p>在 Linux 中，可以使用 <code>ls</code> 命令结合不同的选项来按照规则排序目录下的文件。以下是一些常用的示例和方法：</p>
<h3 id="1-按文件名排序"><a href="#1-按文件名排序" class="headerlink" title="1. 按文件名排序"></a>1. 按文件名排序</h3><p>默认情况下，<code>ls</code> 命令按文件名的字母顺序排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<h3 id="2-按文件大小排序"><a href="#2-按文件大小排序" class="headerlink" title="2. 按文件大小排序"></a>2. 按文件大小排序</h3><p>使用 <code>-S</code> 选项按文件大小排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lS</span><br></pre></td></tr></table></figure>

<h3 id="3-按修改时间排序"><a href="#3-按修改时间排序" class="headerlink" title="3. 按修改时间排序"></a>3. 按修改时间排序</h3><p>使用 <code>-t</code> 选项按修改时间排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lt</span><br></pre></td></tr></table></figure>

<h3 id="4-按访问时间排序"><a href="#4-按访问时间排序" class="headerlink" title="4. 按访问时间排序"></a>4. 按访问时间排序</h3><p>使用 <code>-u</code> 选项按访问时间排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lu</span><br></pre></td></tr></table></figure>

<h3 id="5-按文件创建时间排序（有些文件系统不支持）"><a href="#5-按文件创建时间排序（有些文件系统不支持）" class="headerlink" title="5. 按文件创建时间排序（有些文件系统不支持）"></a>5. 按文件创建时间排序（有些文件系统不支持）</h3><p>使用 <code>-c</code> 选项按文件创建时间排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lc</span><br></pre></td></tr></table></figure>

<h3 id="6-逆序排序"><a href="#6-逆序排序" class="headerlink" title="6. 逆序排序"></a>6. 逆序排序</h3><p>使用 <code>-r</code> 选项逆序排列：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lr</span><br></pre></td></tr></table></figure>

<h3 id="7-按扩展名排序"><a href="#7-按扩展名排序" class="headerlink" title="7. 按扩展名排序"></a>7. 按扩展名排序</h3><p>使用 <code>--sort=extension</code> 按扩展名排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l --<span class="built_in">sort</span>=extension</span><br></pre></td></tr></table></figure>

<h3 id="8-按文件大小排序并显示人类可读格式"><a href="#8-按文件大小排序并显示人类可读格式" class="headerlink" title="8. 按文件大小排序并显示人类可读格式"></a>8. 按文件大小排序并显示人类可读格式</h3><p>使用 <code>-h</code> 选项结合 <code>-S</code> 选项：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lSh</span><br></pre></td></tr></table></figure>

<h3 id="9-按指定规则排序文件"><a href="#9-按指定规则排序文件" class="headerlink" title="9. 按指定规则排序文件"></a>9. 按指定规则排序文件</h3><p>结合 <code>find</code> 和 <code>sort</code> 命令，可以按照更加复杂的规则进行排序。例如，按文件大小排序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; + | <span class="built_in">sort</span> -k 5 -n</span><br></pre></td></tr></table></figure>

<h3 id="10-按文件名排序，并忽略大小写"><a href="#10-按文件名排序，并忽略大小写" class="headerlink" title="10. 按文件名排序，并忽略大小写"></a>10. 按文件名排序，并忽略大小写</h3><p>使用 <code>-f</code> 选项结合 <code>sort</code> 命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> | <span class="built_in">sort</span> -f</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设有一个目录，里面包含以下文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file1.txt</span><br><span class="line">file2.txt</span><br><span class="line">fileA.txt</span><br><span class="line">fileB.txt</span><br><span class="line">file10.txt</span><br></pre></td></tr></table></figure>

<p><strong>按文件名排序（忽略大小写）</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> | <span class="built_in">sort</span> -f</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file1.txt</span><br><span class="line">file10.txt</span><br><span class="line">file2.txt</span><br><span class="line">fileA.txt</span><br><span class="line">fileB.txt</span><br></pre></td></tr></table></figure>

<p><strong>按文件大小排序</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lS</span><br></pre></td></tr></table></figure>

<p>输出（假设文件大小分别为 100B, 200B, 150B, 50B, 250B）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 user group  250 Apr 10 10:00 file10.txt</span><br><span class="line">-rw-r--r-- 1 user group  200 Apr 10 10:00 file2.txt</span><br><span class="line">-rw-r--r-- 1 user group  150 Apr 10 10:00 fileA.txt</span><br><span class="line">-rw-r--r-- 1 user group  100 Apr 10 10:00 file1.txt</span><br><span class="line">-rw-r--r-- 1 user group   50 Apr 10 10:00 fileB.txt</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过结合使用 <code>ls</code> 命令的不同选项以及 <code>sort</code> 命令，你可以根据各种规则对目录下的文件进行排序。选择适合你需求的命令和选项，并根据需要进行调整。</p>
<h2 id="shell-字符串分割"><a href="#shell-字符串分割" class="headerlink" title="shell 字符串分割"></a>shell 字符串分割</h2><p>在 Shell 中，可以使用多种方法来分割字符串。下面是几种常见的方法：</p>
<h3 id="1-使用-IFS（内部字段分隔符）"><a href="#1-使用-IFS（内部字段分隔符）" class="headerlink" title="1. 使用 IFS（内部字段分隔符）"></a>1. 使用 <code>IFS</code>（内部字段分隔符）</h3><p>使用 <code>IFS</code> 变量可以轻松地将字符串分割成数组。以下是一个示例，将逗号分隔的字符串分割成数组：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;apple,banana,cherry&quot;</span></span><br><span class="line">IFS=<span class="string">&#x27;,&#x27;</span> <span class="built_in">read</span> -r -a array &lt;&lt;&lt; <span class="string">&quot;<span class="variable">$str</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组元素</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;array[@]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$element</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="2-使用-cut"><a href="#2-使用-cut" class="headerlink" title="2. 使用 cut"></a>2. 使用 <code>cut</code></h3><p><code>cut</code> 命令可以从字符串中提取字段。以下是一个示例，使用逗号作为分隔符：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;apple,banana,cherry&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;,&#x27;</span> -f1  <span class="comment"># apple</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;,&#x27;</span> -f2  <span class="comment"># banana</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;,&#x27;</span> -f3  <span class="comment"># cherry</span></span><br></pre></td></tr></table></figure>

<h3 id="3-使用-awk"><a href="#3-使用-awk" class="headerlink" title="3. 使用 awk"></a>3. 使用 <code>awk</code></h3><p><code>awk</code> 是一个强大的文本处理工具，可以用来分割字符串。以下是一个示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;apple,banana,cherry&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | awk -F<span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>  <span class="comment"># apple</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | awk -F<span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>  <span class="comment"># banana</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | awk -F<span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>  <span class="comment"># cherry</span></span><br></pre></td></tr></table></figure>

<h3 id="4-使用-tr-和-while-循环"><a href="#4-使用-tr-和-while-循环" class="headerlink" title="4. 使用 tr 和 while 循环"></a>4. 使用 <code>tr</code> 和 <code>while</code> 循环</h3><p><code>tr</code> 命令可以用来替换字符。结合 <code>while</code> 循环，可以逐个处理字符串中的每个部分。以下是一个示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;apple,banana,cherry&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span> | <span class="built_in">tr</span> <span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;\n&#x27;</span> | <span class="keyword">while</span> <span class="built_in">read</span> element</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$element</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="5-使用参数扩展"><a href="#5-使用参数扩展" class="headerlink" title="5. 使用参数扩展"></a>5. 使用参数扩展</h3><p>在 Bash 中，还可以使用参数扩展进行简单的字符串分割：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;apple,banana,cherry&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取第一个逗号前的部分</span></span><br><span class="line">part1=<span class="string">&quot;<span class="variable">$&#123;str%%,*&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$part1</span>&quot;</span>  <span class="comment"># apple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取第一个逗号后的部分</span></span><br><span class="line">remaining=<span class="string">&quot;<span class="variable">$&#123;str#*,&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次截取</span></span><br><span class="line">part2=<span class="string">&quot;<span class="variable">$&#123;remaining%%,*&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$part2</span>&quot;</span>  <span class="comment"># banana</span></span><br><span class="line">part3=<span class="string">&quot;<span class="variable">$&#123;remaining#*,&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$part3</span>&quot;</span>  <span class="comment"># cherry</span></span><br></pre></td></tr></table></figure>

<p>这些方法可以帮助你在 Shell 脚本中进行字符串分割。选择最适合你需求的方法，并根据需要调整分隔符和字符串。</p>
<h2 id="在shell-script中以某用户身份执行命令"><a href="#在shell-script中以某用户身份执行命令" class="headerlink" title="在shell script中以某用户身份执行命令"></a>在shell script中以某用户身份执行命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="built_in">sudo</span> -S bash -c <span class="string">&#x27;whoami&#x27;</span></span><br><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure>

<h2 id="linux-写一个定时刷新的24h运行脚本"><a href="#linux-写一个定时刷新的24h运行脚本" class="headerlink" title="linux 写一个定时刷新的24h运行脚本"></a>linux 写一个定时刷新的24h运行脚本</h2><p>你可以使用<code>crontab</code>来创建一个定时刷新的脚本。<code>crontab</code>是一个用于在Linux系统上定期执行任务的工具。下面是一个示例，假设你有一个名为<code>refresh.sh</code>的脚本，你想每天定时运行：</p>
<p>首先，创建一个<code>refresh.sh</code>脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是你的刷新任务脚本内容</span></span><br><span class="line"><span class="comment"># 例如，你可以在这里写下你想要执行的任务</span></span><br><span class="line"><span class="comment"># 比如，刷新某个文件夹下的内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running refresh script at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="comment"># 在这里执行你的刷新任务</span></span><br></pre></td></tr></table></figure>

<p>保存并退出。</p>
<p>接下来，编辑你的<code>crontab</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>在编辑器中添加以下行，表示每天的0点执行<code>refresh.sh</code>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * /path/to/refresh.sh</span><br></pre></td></tr></table></figure>

<p>确保将<code>/path/to/refresh.sh</code>替换为你实际的<code>refresh.sh</code>脚本的路径。</p>
<p>保存并退出编辑器。</p>
<p>这将使你的<code>refresh.sh</code>脚本每天的午夜被执行，从而实现了24小时定时刷新的需求。</p>
<h2 id="linux-stat-获取指定目录的空闲空间"><a href="#linux-stat-获取指定目录的空闲空间" class="headerlink" title="linux stat 获取指定目录的空闲空间"></a>linux stat 获取指定目录的空闲空间</h2><p>你可以使用 <code>stat</code> 命令获取文件系统的信息，但是 <code>stat</code> 命令不能直接获取指定目录的空闲空间。要获取指定目录的空闲空间，你可以使用 <code>df</code> 命令。</p>
<p>以下是一个示例 Bash 脚本，用于获取指定目录的空闲空间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要获取空间信息的目录</span></span><br><span class="line">directory=<span class="string">&quot;/path/to/your/directory&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目录所在的文件系统</span></span><br><span class="line">filesystem=$(<span class="built_in">df</span> -P <span class="string">&quot;<span class="variable">$directory</span>&quot;</span> | awk <span class="string">&#x27;NR==2 &#123;print $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件系统的空闲空间</span></span><br><span class="line">free_space=$(<span class="built_in">df</span> -P <span class="string">&quot;<span class="variable">$filesystem</span>&quot;</span> | awk <span class="string">&#x27;NR==2 &#123;print $4&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Free space in <span class="variable">$directory</span> : <span class="variable">$free_space</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个脚本中，你需要将 <code>/path/to/your/directory</code> 替换为你要查询空间信息的目录路径。脚本将首先使用 <code>df</code> 命令获取该目录所在的文件系统，然后再次使用 <code>df</code> 命令获取该文件系统的空闲空间。最后，脚本会输出空闲空间的信息。</p>
<p>请注意，这个脚本只是一个简单的示例，适用于大多数情况。在实际使用中，你可能需要更复杂的逻辑来确保脚本的稳健性和安全性。</p>
<h2 id="linux-bash-字符串删除"><a href="#linux-bash-字符串删除" class="headerlink" title="linux bash 字符串删除"></a>linux bash 字符串删除</h2><p>如果你要删除字符串中的特定字符或子字符串，你可以使用 Bash 的内置功能 <code>sed</code>、<code>awk</code> 或字符串操作函数来实现。下面是一些方法示例：</p>
<h3 id="使用-sed-删除字符串中的字符："><a href="#使用-sed-删除字符串中的字符：" class="headerlink" title="使用 sed 删除字符串中的字符："></a>使用 <code>sed</code> 删除字符串中的字符：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始字符串</span></span><br><span class="line">original_string=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除字符串中的空格</span></span><br><span class="line">modified_string=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$original_string</span>&quot;</span> | sed <span class="string">&#x27;s/ //g&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Original string: <span class="variable">$original_string</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Modified string: <span class="variable">$modified_string</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-awk-删除字符串中的字符："><a href="#使用-awk-删除字符串中的字符：" class="headerlink" title="使用 awk 删除字符串中的字符："></a>使用 <code>awk</code> 删除字符串中的字符：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始字符串</span></span><br><span class="line">original_string=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除字符串中的空格</span></span><br><span class="line">modified_string=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$original_string</span>&quot;</span> | awk <span class="string">&#x27;&#123;gsub(&quot; &quot;, &quot;&quot;)&#125;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Original string: <span class="variable">$original_string</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Modified string: <span class="variable">$modified_string</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用字符串操作函数删除字符串中的子字符串："><a href="#使用字符串操作函数删除字符串中的子字符串：" class="headerlink" title="使用字符串操作函数删除字符串中的子字符串："></a>使用字符串操作函数删除字符串中的子字符串：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始字符串</span></span><br><span class="line">original_string=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除字符串中的 &quot;llo&quot; 子字符串</span></span><br><span class="line">substring_to_remove=<span class="string">&quot;llo&quot;</span></span><br><span class="line">modified_string=<span class="string">&quot;<span class="variable">$&#123;original_string//$substring_to_remove&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Original string: <span class="variable">$original_string</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Modified string: <span class="variable">$modified_string</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这些示例中，原始字符串是 “Hello World”，然后使用不同的方法删除了其中的空格或子字符串。你可以根据自己的需求选择其中一种方法。</p>
<h2 id="linux-bash-获取docker容器的id"><a href="#linux-bash-获取docker容器的id" class="headerlink" title="linux bash 获取docker容器的id"></a>linux bash 获取docker容器的id</h2><p>要获取正在运行的 Docker 容器的 ID，你可以使用 Docker 命令行工具。以下是使用 <code>docker ps</code> 命令来获取正在运行容器的 ID 的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取正在运行的容器的 ID</span></span><br><span class="line">container_id=$(docker ps -q)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running Docker container ID: <span class="variable">$container_id</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个脚本中，<code>docker ps -q</code> 命令用于列出正在运行的容器，并使用 <code>-q</code> 参数只显示容器的 ID。然后将结果存储在 <code>container_id</code> 变量中，并输出该变量的值。 </p>
<p>这只会获取第一个正在运行的容器的 ID。如果你想获取特定容器的 ID，你可以使用 <code>docker ps -qf</code> 命令并提供过滤条件，如容器的名称、标签等。例如，要获取名称为 <code>my_container</code> 的容器的 ID，你可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_id=$(docker ps -qf <span class="string">&quot;name=my_container&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>你可以根据自己的需要调整这些命令。</p>
<h2 id="linux-find命令找到指定文件并保存到数组中"><a href="#linux-find命令找到指定文件并保存到数组中" class="headerlink" title="linux find命令找到指定文件并保存到数组中"></a>linux find命令找到指定文件并保存到数组中</h2><p>在Linux中，<code>find</code>命令用于查找文件和目录。如果你想使用<code>find</code>命令找到指定文件并将结果保存到一个数组中，你可以使用以下方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用 find 命令查找指定文件，并将结果保存到数组</span></span><br><span class="line">files_array=($(find /path/to/search -name <span class="string">&quot;your_pattern&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 输出数组内容（可选）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Files found:&quot;</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files_array[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">cmd=<span class="string">&quot;libtool -static -o libabsl.a &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files_array[@]&#125;</span>&quot;</span>; <span class="keyword">do</span> </span><br><span class="line">    cmd=<span class="string">&quot;<span class="variable">$&#123;cmd&#125;</span> <span class="variable">$&#123;file&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cmd:&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;cmd&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>/path/to/search</code> 是你要搜索的目录的路径。</li>
<li><code>&quot;your_pattern&quot;</code> 是你要匹配的文件名模式。你可以使用通配符来匹配文件名的一部分，比如 <code>*.txt</code> 表示所有以 <code>.txt</code> 结尾的文件。</li>
<li><code>files_array</code> 是保存文件列表的数组。</li>
</ul>
<p>请注意，上述代码假设文件和目录名不包含空格。如果你的文件名中可能包含空格，建议使用更复杂的方法来处理，比如使用 <code>find</code> 命令的 <code>-print0</code> 选项以及 <code>readarray</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 find 命令查找指定文件，将结果以空字符分隔保存到数组</span></span><br><span class="line"><span class="built_in">readarray</span> -d <span class="string">&#x27;&#x27;</span> files_array &lt; &lt;(find /path/to/search -name <span class="string">&quot;your_pattern&quot;</span> -print0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Files found:&quot;</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files_array[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这种方法通过 <code>-print0</code> 选项和 <code>readarray -d &#39;&#39;</code> 的配合，确保了对文件名中可能包含的空格进行正确处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_83_update-alternatives/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_83_update-alternatives/" class="post-title-link" itemprop="url">linux_2_83_update-alternatives</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>update-alternatives命令</li>
</ul>
<h2 id="linux-g-多版本管理"><a href="#linux-g-多版本管理" class="headerlink" title="linux g++ 多版本管理"></a>linux g++ 多版本管理</h2><p>在 Linux 系统上，你可以使用 <code>update-alternatives</code> 来进行多版本管理，特别是对于编译器如 <code>g++</code> 的管理。这允许你在系统上安装多个版本的 <code>g++</code>，并通过 <code>update-alternatives</code> 选择默认版本。</p>
<p>以下是一个简单的步骤来实现 <code>g++</code> 多版本管理：</p>
<ol>
<li><p><strong>安装多个版本的 g++：</strong></p>
<p>首先，确保你已经安装了要管理的多个版本的 <code>g++</code>。你可以使用包管理工具如 <code>apt</code>、<code>yum</code> 或者 <code>dnf</code> 进行安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install g++-version1 g++-version2</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install g++-7 g++-8</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>update-alternatives</code> 配置 g++：</strong></p>
<p>使用 <code>update-alternatives</code> 添加和配置 <code>g++</code> 的备选项。以下是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 100</span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-8 90</span><br></pre></td></tr></table></figure>

<p>这里，我们给 <code>g++-7</code> 和 <code>g++-8</code> 分别分配了优先级 100 和 90。较高优先级的版本将成为默认版本。</p>
</li>
<li><p><strong>选择默认版本：</strong></p>
<p>使用 <code>update-alternatives --config g++</code> 来选择默认的 <code>g++</code> 版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --config g++</span><br></pre></td></tr></table></figure>

<p>这将显示一个菜单，让你选择要设置为默认的 <code>g++</code> 版本。</p>
</li>
<li><p><strong>验证版本：</strong></p>
<p>使用以下命令验证 <code>g++</code> 的当前版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ --version</span><br></pre></td></tr></table></figure>

<p>确保显示的版本号是你选择的默认版本。</p>
</li>
</ol>
<p>通过这种方式，你可以方便地在系统上安装和管理多个版本的 <code>g++</code>。这对于处理不同项目或依赖不同 <code>C++</code> 标准的情况非常有用。</p>
<h2 id="linux-update-alternatives命令-是什么"><a href="#linux-update-alternatives命令-是什么" class="headerlink" title="linux update-alternatives命令 是什么"></a>linux update-alternatives命令 是什么</h2><p><code>update-alternatives</code> 是一个用于管理 Linux 系统上多个软件版本或者实现的工具的命令。它允许你在系统中选择默认的软件版本或者实现，而不必手动修改符号链接或者其他相关的配置文件。</p>
<p>通过 <code>update-alternatives</code>，你可以为系统中的特定命令或者服务设置不同的备选项，然后选择默认的备选项。这对于系统管理员来说是一个方便的工具，因为它可以在不同版本之间切换而不会导致配置混乱。</p>
<p>例如，假设你有多个版本的 Java 安装在系统上，你可以使用 <code>update-alternatives</code> 来选择默认使用的 Java 版本，而无需手动更改符号链接或者其他相关配置。</p>
<p>命令的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --config &lt;name-of-alternative&gt;</span><br></pre></td></tr></table></figure>

<p>其中 <code>&lt;name-of-alternative&gt;</code> 是你要配置的备选项的名称。这个命令会显示一个菜单，列出可用的备选项，你可以选择其中一个作为默认。</p>
<p>要添加新的备选项，你可以使用 <code>--install</code> 选项。具体的用法可以通过 <code>man update-alternatives</code> 查看命令的手册页面来获取更多信息。</p>
<h2 id="linux-update-alternatives命令-详解"><a href="#linux-update-alternatives命令-详解" class="headerlink" title="linux update-alternatives命令 详解"></a>linux update-alternatives命令 详解</h2><p><code>update-alternatives</code> 命令用于管理系统上的备选项，例如不同版本的软件、命令或服务。通过该命令，用户可以方便地在备选项之间切换，而无需手动编辑配置文件。以下是该命令的详细解释：</p>
<h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives [options] --config &lt;name-of-alternative&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;name-of-alternative&gt;</code>: 要管理的备选项的名称。</li>
</ul>
<h3 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h3><ul>
<li><p><code>--install &lt;link&gt; &lt;name&gt; &lt;path&gt; &lt;priority&gt;</code>: 添加一个备选项。这个选项用于将一个备选项加入到系统中。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/java java /usr/java/jdk1.8.0_171/bin/java 1</span><br></pre></td></tr></table></figure>

<p>这个命令将 JDK 1.8.0_171 的 Java 可执行文件添加为备选项。</p>
</li>
<li><p><code>--config &lt;name-of-alternative&gt;</code>: 配置默认的备选项。这个选项用于在多个备选项中选择一个作为默认值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --config java</span><br></pre></td></tr></table></figure>

<p>用户将会看到一个菜单，可以选择要使用的 Java 版本。</p>
</li>
<li><p><code>--display &lt;name-of-alternative&gt;</code>: 显示指定备选项的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --display java</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>--remove &lt;name-of-alternative&gt; &lt;path&gt;</code>: 从备选项列表中删除一个备选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --remove java /usr/java/jdk1.8.0_171/bin/java</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h3><ol>
<li><p><strong>安装备选项：</strong> 使用 <code>--install</code> 选项将备选项添加到系统。</p>
</li>
<li><p><strong>配置默认备选项：</strong> 使用 <code>--config</code> 选项选择默认的备选项。</p>
</li>
<li><p><strong>显示备选项信息：</strong> 使用 <code>--display</code> 可以查看备选项的信息，包括路径、符号链接等。</p>
</li>
<li><p><strong>删除备选项：</strong> 使用 <code>--remove</code> 选项可以从备选项列表中删除不再需要的备选项。</p>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><h4 id="1-安装备选项："><a href="#1-安装备选项：" class="headerlink" title="1. 安装备选项："></a>1. 安装备选项：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/editor editor /usr/bin/nano 50</span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/editor editor /usr/bin/vim.basic 30</span><br></pre></td></tr></table></figure>

<h4 id="2-配置默认备选项："><a href="#2-配置默认备选项：" class="headerlink" title="2. 配置默认备选项："></a>2. 配置默认备选项：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --config editor</span><br></pre></td></tr></table></figure>

<p>用户可以选择默认的编辑器。</p>
<h4 id="3-显示备选项信息："><a href="#3-显示备选项信息：" class="headerlink" title="3. 显示备选项信息："></a>3. 显示备选项信息：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --display editor</span><br></pre></td></tr></table></figure>

<p>显示与编辑器相关的备选项信息。</p>
<h4 id="4-删除备选项："><a href="#4-删除备选项：" class="headerlink" title="4. 删除备选项："></a>4. 删除备选项：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --remove editor /usr/bin/nano</span><br></pre></td></tr></table></figure>

<p>从备选项列表中删除 Nano 编辑器。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>使用 <code>sudo</code> 或者在具有足够权限的用户下运行命令，因为修改备选项可能需要超级用户权限。</li>
<li>在某些系统上，<code>update-alternatives</code> 可能不适用于所有软件。它通常用于系统软件和一些常见的命令。</li>
<li>具体备选项的名称、路径和优先级等参数可能因软件而异，具体使用时需要参考软件的文档或手册。</li>
</ul>
<p>这是 <code>update-alternatives</code> 命令的基本概述，具体的使用方法和备选项名称会根据不同的软件而有所不同。可以通过 <code>man update-alternatives</code> 命令查看完整的命令手册。</p>
<h2 id="linux-update-alternatives命令-常用技巧"><a href="#linux-update-alternatives命令-常用技巧" class="headerlink" title="linux update-alternatives命令 常用技巧"></a>linux update-alternatives命令 常用技巧</h2><p><code>update-alternatives</code> 命令是一个强大的工具，以下是一些在使用该命令时的常用技巧：</p>
<ol>
<li><p><strong>查看当前备选项配置：</strong></p>
<p>使用 <code>--display</code> 选项可以查看当前备选项的配置信息，包括备选项的名称、路径、优先级等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --display &lt;name-of-alternative&gt;</span><br></pre></td></tr></table></figure>

<p>例如，查看 Java 的备选项配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --display java</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装新备选项：</strong></p>
<p>使用 <code>--install</code> 选项可以添加新的备选项。例如，安装一个新版本的 Java：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/java java /usr/java/jdk1.11.0/bin/java 2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置默认备选项：</strong></p>
<p>使用 <code>--config</code> 选项可以选择默认的备选项。例如，选择默认的 Java 版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --config java</span><br></pre></td></tr></table></figure>

<p>用户将会看到一个菜单，可以选择要使用的 Java 版本。</p>
</li>
<li><p><strong>手动更改备选项路径：</strong></p>
<p>在某些情况下，你可能需要手动更改备选项的路径。可以直接编辑 <code>/etc/alternatives/</code> 目录下对应备选项的符号链接，或者使用 <code>--set</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --<span class="built_in">set</span> &lt;name-of-alternative&gt; &lt;alternative-path&gt;</span><br></pre></td></tr></table></figure>

<p>例如，手动设置 Java 的路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --<span class="built_in">set</span> java /usr/java/jdk1.11.0/bin/java</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除不需要的备选项：</strong></p>
<p>使用 <code>--remove</code> 选项可以从备选项列表中删除不再需要的备选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --remove &lt;name-of-alternative&gt; &lt;alternative-path&gt;</span><br></pre></td></tr></table></figure>

<p>例如，删除不再需要的 Java 版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --remove java /usr/java/jdk1.8.0_171/bin/java</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看已安装备选项的列表：</strong></p>
<p>使用 <code>--list</code> 选项可以列出某个备选项的所有可选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --list &lt;name-of-alternative&gt;</span><br></pre></td></tr></table></figure>

<p>例如，列出所有安装的 Java 版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --list java</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过脚本自动配置备选项：</strong></p>
<p>如果你需要在脚本中自动配置备选项，可以使用 <code>--auto</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --auto &lt;name-of-alternative&gt;</span><br></pre></td></tr></table></figure>

<p>这样可以根据预设规则自动选择默认备选项。</p>
</li>
</ol>
<p>这些技巧可以帮助你更灵活地管理系统上的备选项，特别是当你需要安装、配置或更新多个版本的软件时。在使用 <code>update-alternatives</code> 时，请确保谨慎操作，以免影响系统稳定性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_5_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/2024-05-22-5_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_5_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/2024-05-22-5_1/" class="post-title-link" itemprop="url">5_1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux系统下常见的问题及其解决方法</li>
</ul>
<h2 id="mv-目录非空"><a href="#mv-目录非空" class="headerlink" title="mv 目录非空"></a>mv 目录非空</h2><p>当你尝试使用 <code>mv</code> 命令移动一个非空目录时，你会发现 <code>mv</code> 只能在同一文件系统中移动目录，而不能跨文件系统移动非空目录。如果你确实需要移动一个非空目录，可以尝试以下方法：</p>
<ol>
<li><p><strong>使用 <code>rsync</code> 命令</strong>：<br><code>rsync</code> 是一个功能强大的工具，可以用于将文件和目录从一个位置同步到另一个位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz /path/to/source/directory /path/to/destination</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>cp</code> 命令复制然后删除原目录</strong>：<br>如果 <code>rsync</code> 不可用，你可以先使用 <code>cp</code> 命令递归复制目录，然后删除原目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /path/to/source/directory /path/to/destination</span><br><span class="line"><span class="built_in">rm</span> -rf /path/to/source/directory</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>tar</code> 命令打包和解包</strong>：<br>你可以使用 <code>tar</code> 命令先将目录打包，然后将包解压到目标位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -czf directory.tar.gz -C /path/to/source directory</span><br><span class="line"><span class="built_in">mv</span> directory.tar.gz /path/to/destination</span><br><span class="line"><span class="built_in">cd</span> /path/to/destination</span><br><span class="line">tar -xzf directory.tar.gz</span><br><span class="line"><span class="built_in">rm</span> directory.tar.gz</span><br></pre></td></tr></table></figure></li>
</ol>
<p>你可以选择最适合你情况的方法来移动非空目录。</p>
<h2 id="ubuntu-文件加个锁是什么意思"><a href="#ubuntu-文件加个锁是什么意思" class="headerlink" title="ubuntu 文件加个锁是什么意思"></a>ubuntu 文件加个锁是什么意思</h2><p>在 Ubuntu 中,给文件加锁通常有以下几种含义:</p>
<ol>
<li><p>权限锁定:</p>
<ul>
<li>通过修改文件的权限,限制其他用户对该文件的访问和操作。</li>
<li>可以使用 <code>chmod</code> 命令来设置文件的读、写、执行权限。</li>
</ul>
</li>
<li><p>文件锁定:</p>
<ul>
<li>在多用户环境下,某个用户正在编辑一个文件时,可以对该文件进行锁定,防止其他用户同时编辑该文件。</li>
<li>常见的文件编辑器如 gedit、vim 等都支持文件锁定功能。</li>
</ul>
</li>
<li><p>加密锁定:</p>
<ul>
<li>使用加密技术对文件进行加密,只有拥有正确密钥的用户才能访问和编辑该文件。</li>
<li>Ubuntu 自带的加密文件系统 eCryptfs 就可以实现这种加密锁定。</li>
</ul>
</li>
<li><p>共享锁定:</p>
<ul>
<li>在网络共享环境下,可以对文件设置共享锁定,限制其他用户的访问权限。</li>
<li>这种锁定通常由文件服务器或共享服务来管理和实现。</li>
</ul>
</li>
</ol>
<p>总之,给 Ubuntu 中的文件加锁,主要是为了保护文件的安全性和完整性,防止未经授权的访问和修改。具体使用哪种锁定方式,需要根据实际需求和使用场景来决定。</p>
<ul>
<li>通过命令 chmod 777 destination 修改文件权限即可</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/shell_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-shell_2_1_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/shell_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-shell_2_1_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">shell_2_1_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>shell脚本编程的常用方法</li>
</ul>
<h2 id="linux-shell-创建数组并在for循环中向数组添加元素"><a href="#linux-shell-创建数组并在for循环中向数组添加元素" class="headerlink" title="linux shell 创建数组并在for循环中向数组添加元素"></a>linux shell 创建数组并在for循环中向数组添加元素</h2><p>在 Bash 中，你可以在 <code>for</code> 循环中向数组添加元素。以下是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空数组</span></span><br><span class="line">my_array=()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 for 循环中向数组添加元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    my_array+=(<span class="string">&quot;<span class="variable">$i</span>&quot;</span>)</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数组中的所有元素</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;my_array[@]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$item</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了一个空数组 <code>my_array</code>。然后，在 <code>for</code> 循环中，我们使用 <code>+=</code> 运算符向数组添加了 1 到 5 的数字。最后，我们使用另一个 <code>for</code> 循环遍历数组并打印出所有的元素。</p>
<p>这样做会将每个数字作为一个独立的数组元素添加到数组中。</p>
<h2 id="linux-shell-创建数组"><a href="#linux-shell-创建数组" class="headerlink" title="linux shell 创建数组"></a>linux shell 创建数组</h2><p>在 Bash 中创建数组很简单，只需在变量名前加上 <code>()</code> 并用空格分隔元素即可。以下是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个数组</span></span><br><span class="line">my_array=(<span class="string">&quot;apple&quot;</span> <span class="string">&quot;banana&quot;</span> <span class="string">&quot;orange&quot;</span> <span class="string">&quot;grape&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数组中的所有元素</span></span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;my_array[@]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$fruit</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这个脚本创建了一个名为 <code>my_array</code> 的数组，其中包含了几种水果。然后，通过 <code>for</code> 循环遍历数组中的每个元素，并将其打印出来。</p>
<p>你也可以在创建数组后，通过索引访问和修改数组中的元素。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问数组元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;my_array[0]&#125;</span>&quot;</span>  <span class="comment"># 输出第一个元素 &quot;apple&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改数组元素</span></span><br><span class="line">my_array[1]=<span class="string">&quot;pear&quot;</span>     <span class="comment"># 将第二个元素修改为 &quot;pear&quot;</span></span><br></pre></td></tr></table></figure>

<p>这些都是 Bash 中创建和操作数组的基本方法。</p>
<h2 id="linux-shell脚本-获取指定目录下的所有文件名并依次判断是文件还是目录"><a href="#linux-shell脚本-获取指定目录下的所有文件名并依次判断是文件还是目录" class="headerlink" title="linux shell脚本 获取指定目录下的所有文件名并依次判断是文件还是目录"></a>linux shell脚本 获取指定目录下的所有文件名并依次判断是文件还是目录</h2><p>你可以通过 <code>for</code> 循环遍历指定目录下的所有文件和目录，并使用 <code>test</code> 命令检查每个项目是文件还是目录。以下是一个示例脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定目录路径</span></span><br><span class="line">directory=<span class="string">&quot;/path/to/directory&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目录下所有文件和目录名，并遍历</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$directory</span>&quot;</span>/*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 判断是否为文件</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$item</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$item</span> 是一个文件&quot;</span></span><br><span class="line">    <span class="comment"># 判断是否为目录</span></span><br><span class="line">    <span class="keyword">elif</span> [ -d <span class="string">&quot;<span class="variable">$item</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$item</span> 是一个目录&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$item</span> 不是文件也不是目录&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这个脚本会遍历指定目录下的所有文件和目录，并输出相应的信息。你可以根据需要修改 <code>directory</code> 变量来指定不同的目录路径。</p>
<h2 id="linux-shell脚本-获取指定目录下的所有文件名并保存到数组"><a href="#linux-shell脚本-获取指定目录下的所有文件名并保存到数组" class="headerlink" title="linux shell脚本 获取指定目录下的所有文件名并保存到数组"></a>linux shell脚本 获取指定目录下的所有文件名并保存到数组</h2><p>你可以编写一个 shell 脚本来获取指定目录下的所有文件名，并将它们保存到一个数组中。以下是一个示例脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定目录路径</span></span><br><span class="line">directory=<span class="string">&quot;/path/to/directory&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目录下所有文件名，并保存到数组</span></span><br><span class="line">file_list=($(<span class="built_in">ls</span> <span class="string">&quot;<span class="variable">$directory</span>&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数组中的所有文件名</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;file_list[@]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>将上述脚本保存为一个文件，比如 <code>list_files.sh</code>，然后赋予执行权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x list_files.sh</span><br></pre></td></tr></table></figure>

<p>最后，运行该脚本即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./list_files.sh</span><br></pre></td></tr></table></figure>

<p>这个脚本会将指定目录下的所有文件名保存到 <code>file_list</code> 数组中，并打印出来。你可以根据需要修改 <code>directory</code> 变量来指定不同的目录路径。</p>
<h2 id="linux-shell-字符串拼接"><a href="#linux-shell-字符串拼接" class="headerlink" title="linux shell 字符串拼接"></a>linux shell 字符串拼接</h2><p>在Linux Shell中，你可以使用不同的方法来进行字符串拼接，具体取决于你使用的Shell（例如，Bash、Zsh、Fish等）。以下是一些常见的方法：</p>
<ol>
<li><p>使用<code>+</code>操作符（仅限Bash和Zsh）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=<span class="string">&quot;$str1<span class="variable">$str2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将会输出：<code>Hello, world!</code></p>
</li>
<li><p>使用<code>$&#123;&#125;</code>来拼接字符串（适用于大多数Shell）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=<span class="string">&quot;<span class="variable">$&#123;str1&#125;</span><span class="variable">$&#123;str2&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出与上述相同。</p>
</li>
<li><p>使用<code>printf</code>函数来拼接字符串（适用于大多数Shell）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=$(<span class="built_in">printf</span> <span class="string">&quot;%s%s&quot;</span> <span class="string">&quot;<span class="variable">$str1</span>&quot;</span> <span class="string">&quot;<span class="variable">$str2</span>&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出与上述相同。</p>
</li>
<li><p>使用命令替换来拼接字符串（适用于大多数Shell）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;str1&#125;</span><span class="variable">$&#123;str2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出与上述相同。</p>
</li>
<li><p>在echo中直接拼接字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;str1&#125;</span><span class="variable">$&#123;str2&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将直接输出拼接后的字符串。</p>
</li>
<li><p>使用Here Document（适用于大多数Shell）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=$(<span class="built_in">cat</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">$&#123;str1&#125;$&#123;str2&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这种方法适用于多行字符串拼接。</p>
</li>
</ol>
<p>请注意，上述示例中的字符串拼接方法可以在大多数常见的Shell中使用，但可能会有一些细微的差异。确保根据你所使用的Shell来选择适当的方法。</p>
<h2 id="linux-bash-shell-字符串拼接"><a href="#linux-bash-shell-字符串拼接" class="headerlink" title="linux bash shell 字符串拼接"></a>linux bash shell 字符串拼接</h2><p>在Bash Shell中，你可以使用不同的方法来进行字符串拼接。以下是一些常见的方法：</p>
<ol>
<li>使用<code>$&#123;&#125;</code>来拼接字符串：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=<span class="string">&quot;<span class="variable">$&#123;str1&#125;</span><span class="variable">$&#123;str2&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将会输出：<code>Hello, world!</code></p>
<ol start="2">
<li>使用<code>+</code>操作符（仅限Bash 4.0及更高版本）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=<span class="string">&quot;$str1<span class="variable">$str2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这也会输出：<code>Hello, world!</code></p>
<ol start="3">
<li>使用<code>+=</code>操作符来追加字符串：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str1+=<span class="string">&quot;world!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str1</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将输出：<code>Hello, world!</code></p>
<ol start="4">
<li>使用命令替换来拼接字符串：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line">result=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;str1&#125;</span><span class="variable">$&#123;str2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这也会输出：<code>Hello, world!</code></p>
<ol start="5">
<li>在echo中直接拼接字符串：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&quot;Hello, &quot;</span></span><br><span class="line">str2=<span class="string">&quot;world!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;str1&#125;</span><span class="variable">$&#123;str2&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将直接输出拼接后的字符串。</p>
<p>请根据你的需求和个人偏好选择合适的字符串拼接方法。在Bash中，上述示例中的任何一种方法都可以使用。</p>
<h2 id="将命令输出的信息存储到数组"><a href="#将命令输出的信息存储到数组" class="headerlink" title="将命令输出的信息存储到数组"></a>将命令输出的信息存储到数组</h2><p>在Linux Shell中，可以使用命令替换和数组来将命令的输出存储到一个数组中。有两种常用的方式来实现这个目标，分别是使用<code>$()</code>或反引号&#96;&#96;来进行命令替换。</p>
<p>假设你要将<code>ls</code>命令的输出存储到一个数组中，可以按照以下方式进行操作：</p>
<p>使用<code>$()</code>进行命令替换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将ls命令的输出存储到数组files中</span></span><br><span class="line">files=($(<span class="built_in">ls</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组元素</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>使用反引号&#96;&#96;进行命令替换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将ls命令的输出存储到数组files中</span></span><br><span class="line">files=`<span class="built_in">ls</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组元素</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果文件名中包含空格或特殊字符，使用上述方法存储到数组中可能会导致文件名分割错误。为了避免这种情况，建议使用<code>read</code>命令来逐行读取命令输出，然后将每行存储到数组中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用read命令逐行读取ls命令的输出并存储到数组files中</span></span><br><span class="line">IFS=$<span class="string">&#x27;\n&#x27;</span> <span class="built_in">read</span> -d <span class="string">&#x27;&#x27;</span> -r -a files &lt; &lt;(<span class="built_in">ls</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组元素</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这种方法可以正确处理文件名中包含空格或特殊字符的情况。</p>
<p>请注意，存储命令输出到数组时，输出中的每个元素会根据换行符进行分割。如果输出是以空格或其他分隔符分隔的，可以使用<code>IFS</code>变量来设置分隔符。例如，如果输出是以空格分隔的，可以设置<code>IFS=&#39; &#39;</code>。</p>
<h2 id="判断变量是否为空"><a href="#判断变量是否为空" class="headerlink" title="判断变量是否为空"></a>判断变量是否为空</h2><p>在 Linux Shell 脚本中，可以使用不同的方式来判断一个变量是否为空。以下是几种常用的方法：</p>
<ol>
<li><p><strong>使用 if-else 语句</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$var</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;变量为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;变量不为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，使用 <code>-z</code> 表达式来判断变量 <code>$var</code> 是否为空。如果为空，则执行 if 语句块中的命令；如果不为空，则执行 else 语句块中的命令。</p>
</li>
<li><p><strong>使用双引号和等号比较</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$var</span>&quot;</span> = <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;变量为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;变量不为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>这种方式使用双引号将变量引起来，并与空字符串进行等号比较，判断变量是否为空。</p>
</li>
<li><p><strong>使用双括号和双引号</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$var</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;变量为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;变量不为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在这种方式中，使用双括号 <code>[[ ... ]]</code> 来进行条件判断，并使用双引号将变量引起来。</p>
</li>
</ol>
<p>需要注意的是，变量前面的 <code>$</code> 符号需要加上双引号，这样可以避免在变量为空时引发语法错误。</p>
<p>这些是常用的方式来判断一个变量是否为空。根据具体的需求和脚本环境，您可以选择适合您的方式来进行变量的判空操作。</p>
<p>希望这些解释对您有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><p>在 Shell 脚本中，可以使用 <code>date</code> 命令来获取当前的时间和日期。</p>
<p>要获取当前的完整时间，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_time=$(<span class="built_in">date</span> +%T)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前时间：<span class="variable">$current_time</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>该命令使用 <code>%T</code> 格式化选项来获取当前时间，并将结果保存在 <code>current_time</code> 变量中。</p>
<p>如果你只需要获取当前的日期，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_date=$(<span class="built_in">date</span> +%F)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前日期：<span class="variable">$current_date</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里使用 <code>%F</code> 格式化选项来获取当前日期，并将结果保存在 <code>current_date</code> 变量中。</p>
<p><code>date</code> 命令还有很多其他的格式化选项，你可以根据需求选择适合你的日期和时间格式。使用 <code>man date</code> 命令可以查看 <code>date</code> 命令的完整文档，其中包含了所有的格式化选项和用法示例。</p>
<p>除了 <code>date</code> 命令，还可以使用其他 Shell 内建的变量来获取当前时间和日期。例如：</p>
<ul>
<li><p>获取当前时间戳：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_timestamp=$(<span class="built_in">date</span> +%s)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前时间戳：<span class="variable">$current_timestamp</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前年份：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_year=$(<span class="built_in">date</span> +%Y)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前年份：<span class="variable">$current_year</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前月份：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_month=$(<span class="built_in">date</span> +%m)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前月份：<span class="variable">$current_month</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>等等，根据具体需求选择适合的日期和时间信息。</p>
<hr>
<h2 id="gsettings-常用示例"><a href="#gsettings-常用示例" class="headerlink" title="gsettings 常用示例"></a>gsettings 常用示例</h2><p>以下是一些常见的 <code>gsettings</code> 命令示例，涵盖了不同的设置类别：</p>
<ol>
<li><p>修改桌面背景图片：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background picture-uri <span class="string">&#x27;file:///path/to/image.jpg&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改桌面壁纸平铺方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background picture-options <span class="string">&#x27;scaled&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改桌面图标显示&#x2F;隐藏：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background show-desktop-icons <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改窗口主题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.preferences theme <span class="string">&#x27;Adwaita&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改默认浏览器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.default-applications.web-browser <span class="string">&#x27;firefox.desktop&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改鼠标双击行为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.mouse double-click <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改键盘重复延迟和速度：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.keyboard delay 200</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.keyboard repeat-interval 20</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改屏幕亮度调节方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.power idle-dim <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些示例只是 <code>gsettings</code> 命令的一小部分。你可以通过查阅相关的文档或使用 <code>gsettings list-schemas</code>、<code>gsettings list-keys SCHEMA</code> 等命令来探索更多可用的设置和键。</p>
<p>请注意，命令中的 <code>SCHEMA</code> 和 <code>KEY</code> 根据要修改的设置不同而有所变化。确保替换命令中的占位符为适当的值。</p>
<hr>
<h2 id="gsettings-打开-关闭-代理"><a href="#gsettings-打开-关闭-代理" class="headerlink" title="gsettings 打开 关闭 代理"></a>gsettings 打开 关闭 代理</h2><p>在Ubuntu中，你可以使用<code>gsettings</code>命令来打开和关闭代理设置。以下是相关的命令示例：</p>
<p>打开代理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.system.proxy mode &#x27;manual&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy.http host &#x27;proxy.example.com&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy.http port 8080</span><br></pre></td></tr></table></figure>
<p>将 <code>&#39;proxy.example.com&#39;</code> 替换为你的代理服务器地址，<code>8080</code> 替换为代理服务器端口号。</p>
<p>关闭代理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.system.proxy mode &#x27;none&#x27;</span><br></pre></td></tr></table></figure>

<p>这些命令将设置系统代理模式为手动（manual）并指定代理服务器的地址和端口。关闭代理时，将把系统代理模式设置为无（none）。</p>
<p>请注意，这些命令基于 GNOME 桌面环境的代理设置。如果你使用的是其他桌面环境，可能会有不同的命令或配置文件用于管理代理设置。</p>
<p>另外，使用<code>gsettings</code>命令修改的代理设置将在整个系统范围内生效，包括各个应用程序和网络连接。你可能需要重新启动一些应用程序或系统才能使代理设置生效。</p>
<hr>
<h2 id="linux-Ctrl-快捷命令"><a href="#linux-Ctrl-快捷命令" class="headerlink" title="linux Ctrl 快捷命令"></a>linux Ctrl 快捷命令</h2><p>在Linux中，Ctrl键（Control键）结合其他键组合可以触发各种快捷命令。下面是一些常用的Ctrl快捷键及其功能的详细解释：</p>
<ol>
<li><p>Ctrl+C：发送中断信号（SIGINT）给当前正在前台运行的进程，用于中断（终止）进程的执行。</p>
</li>
<li><p>Ctrl+Z：发送暂停信号（SIGTSTP）给当前正在前台运行的进程，将其挂起并放入后台。可以使用<code>fg</code>命令将其重新放到前台运行，或使用<code>bg</code>命令将其转换为后台运行。</p>
</li>
<li><p>Ctrl+D：表示输入流结束，用于退出交互式shell。当你在终端中输入Ctrl+D时，它会告诉shell当前输入结束，然后触发相应的行为，如关闭当前终端会话或退出交互式程序。</p>
</li>
<li><p>Ctrl+L：清除终端屏幕，等效于使用<code>clear</code>命令。它将当前终端窗口的内容滚动到顶部，使终端屏幕变为空白。</p>
</li>
<li><p>Ctrl+A：将光标移到命令行的开头。</p>
</li>
<li><p>Ctrl+E：将光标移到命令行的末尾。</p>
</li>
<li><p>Ctrl+K：删除光标位置到命令行末尾的文本。</p>
</li>
<li><p>Ctrl+U：删除光标位置到命令行开头的文本。</p>
</li>
<li><p>Ctrl+W：删除光标之前的一个单词。</p>
</li>
<li><p>Ctrl+R：在命令历史中进行反向搜索。</p>
</li>
<li><p>Ctrl+G：取消当前的编辑或操作，放弃正在进行的命令。</p>
</li>
</ol>
<p>这些是一些常见的Ctrl快捷键，在Linux终端中使用频率很高。它们可以帮助你更高效地控制终端会话、编辑命令行以及与进程进行交互。请注意，某些快捷键在特定的应用程序或环境中可能会有不同的功能或效果。</p>
<hr>
<h2 id="linux-alt-快捷命令"><a href="#linux-alt-快捷命令" class="headerlink" title="linux alt 快捷命令"></a>linux alt 快捷命令</h2><p>在Linux中，Alt键（也称为Meta键或Option键）结合其他键组合可以触发各种快捷命令。下面是一些常用的Alt快捷键及其功能的简要说明：</p>
<ol>
<li><p>Alt+Tab：在打开的窗口之间切换。按下Alt键并保持按住，然后连续按下Tab键可以切换到下一个窗口。松开Alt键时，所选的窗口将被激活。</p>
</li>
<li><p>Alt+F4：关闭当前活动的窗口。按下Alt键并保持按住，然后按下F4键可以关闭当前窗口。</p>
</li>
<li><p>Alt+Space：打开窗口菜单。按下Alt键并保持按住，然后按下Space键可以打开当前窗口的菜单选项，例如最大化、最小化、移动等。</p>
</li>
<li><p>Alt+Enter：在终端中切换全屏模式。按下Alt键并保持按住，然后按下Enter键可以在终端窗口之间切换全屏模式。</p>
</li>
<li><p>Alt+Up&#x2F;Down：在终端中上下滚动。按下Alt键并保持按住，然后按下上箭头或下箭头键可以在终端中上下滚动输出。</p>
</li>
<li><p>Alt+Left&#x2F;Right：在终端中左右切换。按下Alt键并保持按住，然后按下左箭头或右箭头键可以在终端中左右切换命令。</p>
</li>
</ol>
<p>这些是一些常见的Alt快捷键，在Linux中使用频率较高。请注意，某些快捷键可能因特定的桌面环境、窗口管理器或应用程序而有所不同。此外，Alt键也常用于与其他键组合以实现特定功能，具体取决于应用程序的键绑定设置。</p>
<h2 id="clear-清除屏幕信息-ctrl-L"><a href="#clear-清除屏幕信息-ctrl-L" class="headerlink" title="clear 清除屏幕信息  ctrl+L"></a>clear 清除屏幕信息  ctrl+L</h2><p>在Linux中，<code>clear</code>命令用于清除当前终端窗口上的内容，使其变为空白屏幕，以提供一个干净的工作环境。</p>
<p>使用<code>clear</code>命令非常简单，只需在终端中键入以下命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure>

<p>执行该命令后，当前终端窗口中的所有文本和输出将被清除，终端将变为空白屏幕，光标回到终端的起始位置。</p>
<p><code>clear</code>命令常用于清除终端中的大量输出或命令的执行结果，以便获得更好的可读性和清晰度。当终端窗口中显示的内容过多或杂乱时，使用<code>clear</code>命令可以快速清除屏幕并重新开始。</p>
<p>需要注意的是，<code>clear</code>命令只会清除当前终端窗口的内容，并不会影响其他终端或窗口的显示。当你切换到其他终端或打开新的终端窗口时，之前的内容仍然可见。</p>
<p>除了<code>clear</code>命令，你也可以使用快捷键<code>Ctrl + L</code>来达到相同的效果，它可以清除当前终端窗口的内容。</p>
<p>总结起来，<code>clear</code>命令用于清除当前终端窗口的内容，使其变为空白屏幕。这是一个简单但实用的命令，可以提供一个干净的工作环境。</p>
<hr>
<h2 id="查看目录下所有文件的行数"><a href="#查看目录下所有文件的行数" class="headerlink" title="查看目录下所有文件的行数"></a>查看目录下所有文件的行数</h2><p>要查看Linux中一个目录下所有文件的行数，可以使用<code>find</code>命令与<code>wc</code>命令的组合。以下是一个示例命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -type f -exec cat &#123;&#125; + | wc -l</span><br></pre></td></tr></table></figure>

<p>请替换<code>/path/to/directory</code>为你想要查看的目录的实际路径。</p>
<p>该命令的解释如下：</p>
<ul>
<li><code>find /path/to/directory</code>：查找指定目录下的所有文件。</li>
<li><code>-type f</code>：限定只查找普通文件，排除目录和其他特殊文件。</li>
<li><code>-exec cat &#123;&#125; +</code>：对找到的每个文件执行<code>cat</code>命令，将文件内容输出到标准输出。</li>
<li><code>|</code>：将<code>cat</code>命令的输出通过管道传递给下一个命令。</li>
<li><code>wc -l</code>：对输入进行行数统计，输出总行数。</li>
</ul>
<p>执行该命令后，会输出指定目录下所有文件的总行数。</p>
<p>请注意，如果目录下的文件较多或文件较大，这个命令可能需要一些时间来完成执行。另外，该命令只统计文件中的行数，不包括空行和文件夹的行数。</p>
<hr>
<h2 id="根据进程名-获取进程id"><a href="#根据进程名-获取进程id" class="headerlink" title="根据进程名 获取进程id"></a>根据进程名 获取进程id</h2><p>在Shell脚本中，可以使用<code>pgrep</code>命令来根据进程名获取进程ID（PID）。<code>pgrep</code>命令可以根据进程名模式匹配正在运行的进程，并返回符合条件的进程ID。</p>
<p>以下是一个示例Shell脚本，演示如何使用<code>pgrep</code>命令获取进程ID：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">process_name=<span class="string">&quot;example_process&quot;</span>  <span class="comment"># 设置进程名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pgrep命令获取进程ID</span></span><br><span class="line">pid=$(pgrep <span class="string">&quot;<span class="variable">$process_name</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$pid</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;进程 <span class="variable">$process_name</span> 的PID为: <span class="variable">$pid</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;未找到进程 <span class="variable">$process_name</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，首先定义了要查找的进程名为<code>example_process</code>。然后，使用<code>pgrep</code>命令和进程名作为参数来获取进程ID。如果找到了符合条件的进程，<code>$pid</code>变量将保存进程ID，并打印出来。如果未找到进程，则打印相应的提示信息。</p>
<p>可以将上述脚本保存为<code>.sh</code>文件，并在Shell环境中运行，即可根据进程名获取进程ID。</p>
<p>需要注意的是，<code>pgrep</code>命令还支持其他选项，如根据用户、进程所属终端等条件进行进程查找。您可以通过<code>man pgrep</code>命令查看<code>pgrep</code>命令的详细用法和选项。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_io_buffers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_io_buffers/" class="post-title-link" itemprop="url">mongoose_io_buffers</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose的出站入站缓冲区接口</li>
<li>IO缓冲区由结构mg_iobuf描述，是一个简单的数据结构，可以在任意偏移量插入或删除数据块，并自动增长&#x2F;收缩。</li>
</ul>
<h2 id="struct-mg-iobuf"><a href="#struct-mg-iobuf" class="headerlink" title="struct mg_iobuf"></a>struct mg_iobuf</h2><ul>
<li><p>简介：</p>
<ul>
<li>通用IO缓冲区。size指定buf指向的数据的分配大小，len指定当前存储的字节数。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *buf;  <span class="comment">// Pointer to stored data</span></span><br><span class="line">  <span class="type">size_t</span> size;         <span class="comment">// Total size available</span></span><br><span class="line">  <span class="type">size_t</span> len;          <span class="comment">// Current number of bytes</span></span><br><span class="line">  <span class="type">size_t</span> align;        <span class="comment">// Alignment during allocation</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-iobuf-init"><a href="#mg-iobuf-init" class="headerlink" title="mg_iobuf_init"></a>mg_iobuf_init</h2><ul>
<li><p>简介：</p>
<ul>
<li>初始化IO缓冲区，分配字节大小</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mg_iobuf_init</span><span class="params">(<span class="keyword">struct</span> mg_iobuf *io, <span class="type">size_t</span> size, <span class="type">size_t</span> align)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>io    – 要初始化的mg_iobuf结构的指针</li>
<li>size  – 分配的字节数</li>
<li>align – 将大小对齐到对齐内存边界。0表示不对齐</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>1 – 成功</li>
<li>0 – 失败</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> io;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">mg_iobuf_init</span>(&amp;io, <span class="number">0</span>, <span class="number">64</span>)) &#123;</span><br><span class="line">  <span class="comment">// io successfully initialized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-iobuf-resize"><a href="#mg-iobuf-resize" class="headerlink" title="mg_iobuf_resize"></a>mg_iobuf_resize</h2><ul>
<li><p>简介：</p>
<ul>
<li>调整IO缓冲区的大小，将新的大小设置为size。在此之后，io-&gt;buf指针可能会发生变化，例如缓冲区变大。如果size为0，则释放io-&gt;buf并将其设置为NULL，同时将size和len都设置为0。 得到的io-&gt;size总是与io-&gt;align字节边界对齐；因此，为了避免内存碎片和频繁的重新分配，将io-&gt;align设置为更高的值。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mg_iobuf_resize</span><span class="params">(<span class="keyword">struct</span> mg_iobuf *io, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>io   – 需要调整大小的iobuf</li>
<li>size – 新的大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>1 – 成功</li>
<li>0 – 失败</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> io;</span><br><span class="line"><span class="built_in">mg_iobuf_init</span>(&amp;io, <span class="number">0</span>, <span class="number">10</span>);  <span class="comment">// An empty buffer with 10-byte alignment</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">mg_iobuf_resize</span>(&amp;io, <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="comment">// New io size is 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-iobuf-free"><a href="#mg-iobuf-free" class="headerlink" title="mg_iobuf_free"></a>mg_iobuf_free</h2><ul>
<li><p>简介：</p>
<ul>
<li>释放io-&gt;buf指向的内存并设置为NULL。size和len都被设置为0。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_iobuf_free</span><span class="params">(<span class="keyword">struct</span> mg_iobuf *io)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>io – 需要释放的iobuf</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> io;</span><br><span class="line"><span class="comment">// IO buffer initialization</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time to cleanup</span></span><br><span class="line"><span class="built_in">mg_iobuf_free</span>(&amp;io);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-iobuf-add"><a href="#mg-iobuf-add" class="headerlink" title="mg_iobuf_add"></a>mg_iobuf_add</h2><ul>
<li><p>简介：</p>
<ul>
<li>在偏移量处插入数据缓冲区buf、len。如果需要，iobuf将被扩展。产生的io-&gt;size总是与io-&gt;align字节边界对齐；因此，为了避免内存碎片和频繁的重新分配，将align设置为一个较大的值。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mg_iobuf_add</span><span class="params">(<span class="keyword">struct</span> mg_iobuf *io, <span class="type">size_t</span> offset, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>io     – 需要追加数据的iobuf</li>
<li>offset – 追加数据的偏移</li>
<li>buf    – 追加的数据</li>
<li>len    – 追加数据的长度</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>更新后iobuf的长度</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> io;         <span class="comment">// Declare buffer</span></span><br><span class="line"><span class="built_in">mg_iobuf_init</span>(&amp;io, <span class="number">0</span>, <span class="number">16</span>);  <span class="comment">// Initialise empty buffer with 16 byte alignment</span></span><br><span class="line"><span class="built_in">mg_iobuf_add</span>(&amp;io, io.len, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);  <span class="comment">// Append &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-iobuf-del"><a href="#mg-iobuf-del" class="headerlink" title="mg_iobuf_del"></a>mg_iobuf_del</h2><ul>
<li><p>简介：</p>
<ul>
<li>删除从偏移量开始的len字节，并移动剩余的字节。如果len大于io-&gt;len，则不会发生任何操作，因此这种调用会被忽略。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mg_iobuf_del</span><span class="params">(<span class="keyword">struct</span> mg_iobuf *io, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>io – 需要删除数据的iobuf</li>
<li>offset – 开始位置的偏移量</li>
<li>len – 删除的字节数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>更新后iobuf的长度</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_iobuf</span> io;</span><br><span class="line"><span class="built_in">mg_iobuf_init</span>(&amp;io, <span class="number">0</span>, <span class="number">16</span>);          <span class="comment">// Empty buffer, 16-bytes aligned</span></span><br><span class="line"><span class="built_in">mg_iobuf_add</span>(&amp;io, <span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">2</span>);   <span class="comment">// io-&gt;len is 5, io-&gt;size is 16</span></span><br><span class="line"><span class="built_in">mg_iobuf_del</span>(&amp;io, <span class="number">1</span>, <span class="number">3</span>);            <span class="comment">// io-&gt;len is 2, io-&gt;size is still 16</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_file_system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_file_system/" class="post-title-link" itemprop="url">mongoose_file_system</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>文件相关api</li>
</ul>
<h2 id="struct-mg-fd"><a href="#struct-mg-fd" class="headerlink" title="struct mg_fd"></a>struct mg_fd</h2><ul>
<li><p>简介：</p>
<ul>
<li>文件系统虚拟化层</li>
<li>Mongoose允许覆盖文件IO操作，以支持不同的存储设备，如可编程的闪存，无文件系统设备等。为了实现这一点，Mongoose提供了一个结构mg_fs API来指定一个自定义的文件系统。除此之外，Mongoose还提供了几个内置的API–一个标准的POSIX，FatFS，和一个 “打包的FS “API：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">mg_fs</span> <span class="title">mg_fs_posix</span>;</span>   <span class="comment">// POSIX open/close/read/write/seek</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">mg_fs</span> <span class="title">mg_fs_packed</span>;</span>  <span class="comment">// Packed FS, see examples/device-dashboard</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">mg_fs</span> <span class="title">mg_fs_fat</span>;</span>     <span class="comment">// FAT FS</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_fs</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> (*st)(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">size_t</span> *size, <span class="type">time_t</span> *mtime);  <span class="comment">// stat file</span></span><br><span class="line">  <span class="type">void</span> (*ls)(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">void</span> (*fn)(<span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *), <span class="type">void</span> *);</span><br><span class="line">  <span class="type">void</span> *(*op)(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> flags);             <span class="comment">// Open file</span></span><br><span class="line">  <span class="type">void</span> (*cl)(<span class="type">void</span> *fd);                                 <span class="comment">// Close file</span></span><br><span class="line">  <span class="type">size_t</span> (*rd)(<span class="type">void</span> *fd, <span class="type">void</span> *buf, <span class="type">size_t</span> len);        <span class="comment">// Read file</span></span><br><span class="line">  <span class="type">size_t</span> (*wr)(<span class="type">void</span> *fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len);  <span class="comment">// Write file</span></span><br><span class="line">  <span class="type">size_t</span> (*sk)(<span class="type">void</span> *fd, <span class="type">size_t</span> offset);                <span class="comment">// Set file position</span></span><br><span class="line">  <span class="type">bool</span> (*mv)(<span class="type">const</span> <span class="type">char</span> *from, <span class="type">const</span> <span class="type">char</span> *to);         <span class="comment">// Rename file</span></span><br><span class="line">  <span class="type">bool</span> (*rm)(<span class="type">const</span> <span class="type">char</span> *path);                         <span class="comment">// Delete file</span></span><br><span class="line">  <span class="type">bool</span> (*mkd)(<span class="type">const</span> <span class="type">char</span> *path);                        <span class="comment">// Create directory</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> MG_FS_READ = <span class="number">1</span>, MG_FS_WRITE = <span class="number">2</span>, MG_FS_DIR = <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="struct-mg-fd-1"><a href="#struct-mg-fd-1" class="headerlink" title="struct mg_fd"></a>struct mg_fd</h2><ul>
<li><p>简介：</p>
<ul>
<li>已打开的文件抽象。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_fd</span> &#123;</span></span><br><span class="line">  <span class="type">void</span> *fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-fs-open"><a href="#mg-fs-open" class="headerlink" title="mg_fs_open"></a>mg_fs_open</h2><ul>
<li><p>简介：</p>
<ul>
<li>在一个给定的文件系统中打开一个文件</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_fd *<span class="title function_">mg_fs_open</span><span class="params">(<span class="keyword">struct</span> mg_fs *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fs : 一个文件系统的实现</li>
<li>path : 一个文件路径</li>
<li>flags : 所需的标志，是MG_FS_READ和MG_FS_WRITE的组合。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 一个非NULL的已打开的描述符、</li>
<li>失败： NULL</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_fd</span> *<span class="title">fd</span> =</span> mg_fs_open(&amp;mg_fs_posix, <span class="string">&quot;/tmp/data.json&quot;</span>, MG_FS_WRITE);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-fs-close"><a href="#mg-fs-close" class="headerlink" title="mg_fs_close"></a>mg_fs_close</h2><ul>
<li><p>简介：</p>
<ul>
<li>关闭一个已打开的文件描述符</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_fs_close</span><span class="params">(<span class="keyword">struct</span> mg_fd *fd)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fd : 一个已打开的文件描述符</li>
</ul>
</li>
<li><p>返回自：</p>
<ul>
<li>无</li>
</ul>
</li>
</ul>
<h2 id="mg-file-read"><a href="#mg-file-read" class="headerlink" title="mg_file_read"></a>mg_file_read</h2><ul>
<li><p>简介：</p>
<ul>
<li>在内存中读取整个文件。</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">mg_file_read</span><span class="params">(<span class="keyword">struct</span> mg_fs *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">size_t</span> *size)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<ul>
<li>fs : 一个文件系统的实现</li>
<li>path : 一个文件路径</li>
<li>size : 如果不是NULL，将包含所读文件的大小。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，一个指向文件数据的指针，该指针保证为0端。</li>
<li>错误时，为NULL</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *data = mg_file_read(&amp;mg_fs_packed, <span class="string">&quot;/data.json&quot;</span>, &amp;size);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-file-write"><a href="#mg-file-write" class="headerlink" title="mg_file_write"></a>mg_file_write</h2><ul>
<li><p>简介：</p>
<ul>
<li>写入一段数据buf，len到一个文件路径。如果该文件不存在，它将被创建。之前的内容，如果有的话，会被删除。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">mg_file_write</span><span class="params">(<span class="keyword">struct</span> mg_fs *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fs : 一个文件系统的实现</li>
<li>path : 一个文件路径</li>
<li>buf : 一个指向待写数据的指针</li>
<li>len : 待写数据的大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功, true</li>
<li>失败, false</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_file_write(&amp;mg_fs_fat, <span class="string">&quot;/test.txt&quot;</span>, <span class="string">&quot;hi\n&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-file-printf"><a href="#mg-file-printf" class="headerlink" title="mg_file_printf"></a>mg_file_printf</h2><ul>
<li><p>简介：</p>
<ul>
<li>写一个打印格式的数据到一个文件路径。如果该文件不存在，它将被创建。之前的内容（如果有的话）被删除</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">mg_file_printf</span><span class="params">(<span class="keyword">struct</span> mg_fs *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fs : 一个文件系统的实现</li>
<li>path : 一个文件路径</li>
<li>fmt : printf语义中的格式字符串。支持的格式指定器的列表见mg_snprintf。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功, true</li>
<li>失败, false</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_file_printf(&amp;mg_fs_fat, <span class="string">&quot;/test.txt&quot;</span>, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_core/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_core/" class="post-title-link" itemprop="url">mongoose_core</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose核心api笔记</li>
</ul>
<h2 id="struct-mg-addr"><a href="#struct-mg-addr" class="headerlink" title="struct mg_addr"></a>struct mg_addr</h2><ul>
<li><p>简介：</p>
<ul>
<li>该结构包含网络地址。它可以被认为<code>sockaddr</code>结构在Mongoose中的等价结构体</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_addr</span> &#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> port;    <span class="comment">// TCP or UDP port in network byte order</span></span><br><span class="line">  <span class="type">uint32_t</span> ip;      <span class="comment">// IP address in network byte order</span></span><br><span class="line">  <span class="type">uint8_t</span> ip6[<span class="number">16</span>];  <span class="comment">// IPv6 address</span></span><br><span class="line">  <span class="type">bool</span> is_ip6;      <span class="comment">// True when address is IPv6 address</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="struct-mg-mgr"><a href="#struct-mg-mgr" class="headerlink" title="struct mg_mgr"></a>struct mg_mgr</h2><ul>
<li><p>简介：</p>
<ul>
<li>它是一个事件管理结构体，能够保存一个正在活动的连接列表，以及一些维持管理的信息</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">conns</span>;</span>  <span class="comment">// List of active connections  结构体数组</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_dns</span> <span class="title">dns4</span>;</span>           <span class="comment">// DNS for IPv4</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_dns</span> <span class="title">dns6</span>;</span>           <span class="comment">// DNS for IPv6</span></span><br><span class="line">  <span class="type">int</span> dnstimeout;               <span class="comment">// DNS resolve timeout in milliseconds</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nextid;         <span class="comment">// Next connection ID</span></span><br><span class="line">  <span class="type">void</span> *userdata;               <span class="comment">// Arbitrary user data pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="struct-mg-connection"><a href="#struct-mg-connection" class="headerlink" title="struct mg_connection"></a>struct mg_connection</h2><ul>
<li><p>简介：</p>
<ul>
<li>它是一个连接：可能是一个监听连接，或者是一个已接收连接，或者是一个出站连接</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">next</span>;</span>  <span class="comment">// Linkage in struct mg_mgr :: connections</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> *<span class="title">mgr</span>;</span>          <span class="comment">// Our container</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_addr</span> <span class="title">loc</span>;</span>          <span class="comment">// Local address</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_addr</span> <span class="title">rem</span>;</span>          <span class="comment">// Remote address</span></span><br><span class="line">  <span class="type">void</span> *fd;                    <span class="comment">// Connected socket, or LWIP data</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> id;            <span class="comment">// Auto-incrementing unique connection ID</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_iobuf</span> <span class="title">recv</span>;</span>        <span class="comment">// Incoming data</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_iobuf</span> <span class="title">send</span>;</span>        <span class="comment">// Outgoing data</span></span><br><span class="line">  <span class="type">mg_event_handler_t</span> fn;       <span class="comment">// User-specified event handler function</span></span><br><span class="line">  <span class="type">void</span> *fn_data;               <span class="comment">// User-specified function parameter</span></span><br><span class="line">  <span class="type">mg_event_handler_t</span> pfn;      <span class="comment">// Protocol-specific handler function</span></span><br><span class="line">  <span class="type">void</span> *pfn_data;              <span class="comment">// Protocol-specific function parameter</span></span><br><span class="line">  <span class="type">char</span> label[<span class="number">50</span>];              <span class="comment">// Arbitrary label</span></span><br><span class="line">  <span class="type">void</span> *tls;                   <span class="comment">// TLS specific data</span></span><br><span class="line">  <span class="type">unsigned</span> is_listening : <span class="number">1</span>;   <span class="comment">// Listening connection</span></span><br><span class="line">  <span class="type">unsigned</span> is_client : <span class="number">1</span>;      <span class="comment">// Outbound (client) connection</span></span><br><span class="line">  <span class="type">unsigned</span> is_accepted : <span class="number">1</span>;    <span class="comment">// Accepted (server) connection</span></span><br><span class="line">  <span class="type">unsigned</span> is_resolving : <span class="number">1</span>;   <span class="comment">// Non-blocking DNS resolve is in progress</span></span><br><span class="line">  <span class="type">unsigned</span> is_connecting : <span class="number">1</span>;  <span class="comment">// Non-blocking connect is in progress</span></span><br><span class="line">  <span class="type">unsigned</span> is_tls : <span class="number">1</span>;         <span class="comment">// TLS-enabled connection</span></span><br><span class="line">  <span class="type">unsigned</span> is_tls_hs : <span class="number">1</span>;      <span class="comment">// TLS handshake is in progress</span></span><br><span class="line">  <span class="type">unsigned</span> is_udp : <span class="number">1</span>;         <span class="comment">// UDP connection</span></span><br><span class="line">  <span class="type">unsigned</span> is_websocket : <span class="number">1</span>;   <span class="comment">// WebSocket connection</span></span><br><span class="line">  <span class="type">unsigned</span> is_hexdumping : <span class="number">1</span>;  <span class="comment">// Hexdump in/out traffic</span></span><br><span class="line">  <span class="type">unsigned</span> is_draining : <span class="number">1</span>;    <span class="comment">// Send remaining data, then close and free</span></span><br><span class="line">  <span class="type">unsigned</span> is_closing : <span class="number">1</span>;     <span class="comment">// Close and free the connection immediately</span></span><br><span class="line">  <span class="type">unsigned</span> is_full : <span class="number">1</span>;        <span class="comment">// Stop reads, until cleared</span></span><br><span class="line">  <span class="type">unsigned</span> is_resp : <span class="number">1</span>;        <span class="comment">// Response is still being generated</span></span><br><span class="line">  <span class="type">unsigned</span> is_readable : <span class="number">1</span>;    <span class="comment">// Connection is ready to read</span></span><br><span class="line">  <span class="type">unsigned</span> is_writable : <span class="number">1</span>;    <span class="comment">// Connection is ready to write</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-mgr-init"><a href="#mg-mgr-init" class="headerlink" title="mg_mgr_init"></a>mg_mgr_init</h2><ul>
<li><p>简介：</p>
<ul>
<li>初始化事件管理器结构体变量，它所做的工作：<ul>
<li>将活动连接的列表设置为null</li>
<li>设置IPv4和IPv6的默认DNS服务器</li>
<li>设置默认DNS查找超时</li>
</ul>
</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_mgr_init</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr : 需要初始化的<code>mg_mgr</code>结构体指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> <span class="title">mgr</span>;</span></span><br><span class="line">mg_mgr_init(&amp;mgr);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-mgr-poll"><a href="#mg-mgr-poll" class="headerlink" title="mg_mgr_poll"></a>mg_mgr_poll</h2><ul>
<li><p>简介：</p>
<ul>
<li>在所有连接中迭代，接受新的连接，发送和接收数据，关闭连接并调用事件处理程序的功能，以适用于各自事件。</li>
<li>执行一次池迭代(poll iteration)。对在<code>mgr-&gt;conns</code>列表中的每一个连接进行如下操作<ul>
<li>查看是否有传入数据。如果有，将数据读入到<code>c-&gt;recv</code>缓冲区，并发出一个<code>MG_EV_READ</code>事件</li>
<li>查看<code>c-&gt;send</code>缓冲区是否有数据。如果有，写入数据，并发送<code>MG_EV_WRITE</code>事件</li>
<li>如果一个连接处于监听状态，或已接收一个进入的连接状态，发送一个<code>MG_EV_ACCEPT</code>事件</li>
<li>发送<code>MG_EV_POLL</code>事件</li>
</ul>
</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_mgr_poll</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">int</span> ms)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr :  使用的事件管理结构体</li>
<li>ms : 超时时间，单位为毫秒</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (running == <span class="literal">true</span>) mg_mgr_poll(&amp;mgr, <span class="number">1000</span> <span class="comment">/*1 second*/</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-mgr-free"><a href="#mg-mgr-free" class="headerlink" title="mg_mgr_free"></a>mg_mgr_free</h2><ul>
<li><p>简介：</p>
<ul>
<li>关闭所有连接，释放所有资源</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_mgr_free</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr : 需要被清除的事件管理结构体</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_mgr</span> <span class="title">mgr</span>;</span></span><br><span class="line">mg_mgr_init(&amp;mgr);</span><br><span class="line"><span class="keyword">while</span> (running == <span class="literal">true</span>) mg_mgr_poll(&amp;mgr, <span class="number">1000</span>);   <span class="comment">// Event loop</span></span><br><span class="line">mg_mgr_free(&amp;mgr);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-listen"><a href="#mg-listen" class="headerlink" title="mg_listen"></a>mg_listen</h2><ul>
<li><p>简介：</p>
<ul>
<li>创建一个监听连接，并将这个连接追加到<code>mgr-&gt;conns</code>连接列表中</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_connection *<span class="title function_">mg_listen</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">const</span> <span class="type">char</span> *url, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr : 使用的事件管理结构体</li>
<li>url : URL。指定监听的本地IP地址和端口，例如：<code>tcp://127.0.0.1:1234</code>或<code>udp://0.0.0.0:9000</code></li>
<li>fn :  事件处理函数</li>
<li>fn_data : 一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回创建的连接 </li>
<li>失败，返回NULL</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">c</span> =</span> mg_listen(&amp;mgr, <span class="string">&quot;tcp://127.0.0.1:8080&quot;</span>, fn, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-connect"><a href="#mg-connect" class="headerlink" title="mg_connect"></a>mg_connect</h2><ul>
<li><p>简介：</p>
<ul>
<li>创建一个出站连接，并将这个连接追加到<code>mgr-&gt;conns</code>队列中</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_connection *<span class="title function_">mg_connect</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">const</span> <span class="type">char</span> *url, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<ul>
<li>mgr : 使用的事件管理结构体</li>
<li>url : URL，指定需要连接的远程IP地址和端口。例如：<code>http://a.com</code></li>
<li>fn : 一个事件处理函数</li>
<li>fn_data :  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回创建的连接 </li>
<li>失败，返回NULL</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">c</span> =</span> mg_connect(&amp;mgr, <span class="string">&quot;http://example.org&quot;</span>, fn, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-send"><a href="#mg-send" class="headerlink" title="mg_send"></a>mg_send</h2><ul>
<li><p>简介：</p>
<ul>
<li>将大小为<code>size</code>的数据追加到<code>c-&gt;send</code>缓冲区。返回追加的字节数</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_send</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 一个连接指针</li>
<li>data : 一个指向需要增加到输出缓冲区的数据指针</li>
<li>size : 数据大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功， true</li>
<li>失败， false</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>这个函数不会将数据推送到网络。它仅仅是将数据追加到输出缓冲区。</li>
<li>只有当<code>mg_mgr_poll()</code>被调用时，才会将数据发送出去。</li>
<li>如果<code>mg_send()</code>被多次调用，则输出缓冲区会增长</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_send(c, <span class="string">&quot;hi&quot;</span>, <span class="number">2</span>);  <span class="comment">// Append string &quot;hi&quot; to the output buffer</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-printf"><a href="#mg-printf" class="headerlink" title="mg_printf"></a>mg_printf</h2><ul>
<li><p>简介：</p>
<ul>
<li>与<code>mg_send()</code>相同，但是使用<code>printf()</code>语义格式化数据。返回追加到输出缓冲区的字节数。有关支持格式规范列表，参见<code>mg_snprintf</code></li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_printf</span><span class="params">(<span class="keyword">struct</span> mg_connection *, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 一个连接指针</li>
<li>fmt : <code>printf()</code>语义中的格式字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回追加到输出缓冲区的字节数</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_printf(c, <span class="string">&quot;Hello, %s!&quot;</span>, <span class="string">&quot;world&quot;</span>); <span class="comment">// Add &quot;Hello, world!&quot; to output buffer</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-wrapfd"><a href="#mg-wrapfd" class="headerlink" title="mg_wrapfd"></a>mg_wrapfd</h2><ul>
<li><p>简介：</p>
<ul>
<li>将给定的文件描述符<code>fd</code>包装到连接中，然后将该连接添加到事件管理器中。这个<code>fd</code>文件描述符必须支持<code>send(), recv(), select()</code>系统调用，而且是非阻塞的。Mongoose将把它当做TCP套接字使用。<code>c-&gt;rem</code>和<code>c-&gt;loc</code>地址将会变为空的</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_connection *<span class="title function_">mg_wrapfd</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">int</span> fd, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fd : 需要包装的文件描述符</li>
<li>mgr : 一个事件管理结构体</li>
<li>fn : 一个指向事件处理函数的指针</li>
<li>ud : 一个用户数据指针。它将被当做<code>fn_data</code>参数传递给<code>fn</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回创建的连接</li>
<li>失败，返回NULL</li>
</ul>
</li>
</ul>
<h2 id="mg-mkpipe"><a href="#mg-mkpipe" class="headerlink" title="mg_mkpipe"></a>mg_mkpipe</h2><ul>
<li><p>简介：</p>
<ul>
<li>创建两个互相连接的套接字，用于线程间通信。其中一个套接字被包装到一个Mongoose连接，并被添加到事件管理结构体中。另一个套接字将会被返回，且它应该被传递给工作线程。当一个工作线程使用<code>send()</code>发送任何数据到这个套接字，都将唤醒<code>mgr</code>和<code>fn</code>事件处理函数接收一个<code>MG_EV_READ</code>事件。另外，<code>fn</code>向工作线程发送的任何数据，都被由工作线程使用<code>recv()</code>接收</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_mkpipe</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data, <span class="type">bool</span> udp)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr : 一个事件管理结构体</li>
<li>fn : 一个指向事件处理函数的指针</li>
<li>fn_data : 一个指向用户数据的指针。它将会被当做<code>fn_data</code>参数传递给<code>fn</code></li>
<li>udp : 告知创建一个UDP，还是创建一个TCP socketpair</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回创建的套接字</li>
<li>失败，返回-1</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li>参考examples&#x2F;multi-threaded</li>
</ul>
</li>
</ul>
<h2 id="mg-hello"><a href="#mg-hello" class="headerlink" title="mg_hello"></a>mg_hello</h2><ul>
<li><p>简介：</p>
<ul>
<li>便利功能，在给定的监听URL上启动一个简单的Web服务器。这个函数只有在接收到一个<code>/quit</code>请求才会返回。服务器处理以下URI<ul>
<li><code>/quit</code>  –  退出服务，且退出函数</li>
<li><code>/debug</code> –  设置调试级别，作为POST负载，<code>&#123;&quot;level&quot; : 3&#125;</code>是有效的</li>
<li>对其他所有的URI，都将返回一个<code>hi</code>作为响应</li>
</ul>
</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_hello</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>url : 一个监听的URL，例如：<code>http://0.0.0.0:8000</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_http/" class="post-title-link" itemprop="url">mongoose_http</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose 中http相关api笔记</li>
</ul>
<h2 id="struct-mg-http-header"><a href="#struct-mg-http-header" class="headerlink" title="struct mg_http_header"></a>struct mg_http_header</h2><ul>
<li><p>简介：</p>
<ul>
<li>结构代表HTTP标头，像<code>Content-Type: text/html</code>。<code>Content-Type</code> 是一个 Header name，<code>text/html/</code>是一个 Header value</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_header</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">name</span>;</span>   <span class="comment">// Header name</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">value</span>;</span>  <span class="comment">// Header value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="struct-mg-http-message"><a href="#struct-mg-http-message" class="headerlink" title="struct mg_http_message"></a>struct mg_http_message</h2><ul>
<li><p>简介：</p>
<ul>
<li>结构代表HTTP消息。</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">method</span>, <span class="title">uri</span>, <span class="title">query</span>, <span class="title">proto</span>;</span>             <span class="comment">// Request/response line</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_header</span> <span class="title">headers</span>[<span class="title">MG_MAX_HTTP_HEADERS</span>];</span>  <span class="comment">// Headers</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">body</span>;</span>                                  <span class="comment">// Body</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">message</span>;</span>                               <span class="comment">// Request line + headers + body</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-listen"><a href="#mg-http-listen" class="headerlink" title="mg_http_listen"></a>mg_http_listen</h2><ul>
<li><p>简介：</p>
<ul>
<li>创建HTTP侦听器。</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_connection *<span class="title function_">mg_http_listen</span><span class="params">(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">const</span> <span class="type">char</span> *url, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr : 一个事件管理结构体</li>
<li>url : 一个URL，指定监听的本地IP地址和端口。例如：<code>http://0.0.0.0:8000</code></li>
<li>fn : 一个事件处理函数</li>
<li>fn_data : 一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回一个指向创建的连接指针</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">c</span> =</span> mg_http_listen(&amp;mgr, <span class="string">&quot;0.0.0.0:8000&quot;</span>, fn, arg);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">NULL</span>) fatal_error(<span class="string">&quot;Cannot create listener&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-connect"><a href="#mg-http-connect" class="headerlink" title="mg_http_connect"></a>mg_http_connect</h2><ul>
<li><p>简介</p>
<ul>
<li>创建HTTP客户端连接。这个函数不能连接到对端，它仅仅分配需要的资源和启动连接进程。当对端真正连接好了，会向连接事件处理函数发送一个<code>MG_EV_CONNECT</code>事件</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_connection *<span class="title function_">mg_http_connect</span><span class="params">(<span class="keyword">struct</span> mg_mgr *, <span class="type">const</span> <span class="type">char</span> *url, <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr : 一个事件管理结构体</li>
<li>url : 一个URL，指定监听的本地IP地址和端口。例如：<code>http://0.0.0.0:8000</code></li>
<li>fn : 一个事件处理函数</li>
<li>fn_data : 一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回一个指向创建的连接指针</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_connection</span> *<span class="title">c</span> =</span> mg_http_connect(&amp;mgr, <span class="string">&quot;http://google.com&quot;</span>, fn, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">NULL</span>) fatal_error(<span class="string">&quot;Cannot create connection&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-status"><a href="#mg-http-status" class="headerlink" title="mg_http_status"></a>mg_http_status</h2><ul>
<li><p>简介：</p>
<ul>
<li>获取HTTP响应的状态代码。</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_http_status</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> mg_http_message *hm)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>hm : 需要解析的HTTP响应</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回状态码，例如：200表示成功</li>
</ul>
</li>
</ul>
<hr>
<h2 id="mg-http-get-request-len"><a href="#mg-http-get-request-len" class="headerlink" title="mg_http_get_request_len"></a>mg_http_get_request_len</h2><ul>
<li><p>简介：</p>
<ul>
<li>获取请求的长度。请求的长度是直到HTTP头结束的字节数。它不包括HTTP请求体的长度</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_http_get_request_len</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">size_t</span> buf_len)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>buf : 指向存放请求数据的缓冲区的指针</li>
<li>buf_len : 缓冲区大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回请求的长度</li>
<li>0, 消息不完整</li>
<li>-1， 错误</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *buf = <span class="string">&quot;GET /test \n\nGET /foo\n\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> req_len = mg_http_get_request_len(buf, <span class="built_in">strlen</span>(buf));  <span class="comment">// req_len == 12</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-parse"><a href="#mg-http-parse" class="headerlink" title="mg_http_parse"></a>mg_http_parse</h2><ul>
<li><p>简介：</p>
<ul>
<li>解析请求报文字符串，并存入到<code>mg_http_message</code>结构体中</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_http_parse</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len, <span class="keyword">struct</span> mg_http_message *hm)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>s : 一个请求字符串</li>
<li>len : 请求字符串的长度</li>
<li>hm : 存储解析请求报文结果的结构体指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回请求报文的长度</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> <span class="title">hm</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *buf = <span class="string">&quot;GET / HTTP/1.0\n\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (mg_http_parse(buf, <span class="built_in">strlen</span>(buf), &amp;hm) &gt; <span class="number">0</span>) &#123; <span class="comment">/* success */</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-printf-chunk"><a href="#mg-http-printf-chunk" class="headerlink" title="mg_http_printf_chunk"></a>mg_http_printf_chunk</h2><ul>
<li><p>简介：</p>
<ul>
<li>使用<code>printf()</code>语义，写一个块编码的块数据。(Write a chunk of data in chunked encoding format, using printf() semantic)</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_printf_chunk</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 一个连接指针</li>
<li>fmt : 以<code>printf()</code>语义的字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_http_printf_chunk(c, <span class="string">&quot;Hello, %s!&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-write-chunk"><a href="#mg-http-write-chunk" class="headerlink" title="mg_http_write_chunk"></a>mg_http_write_chunk</h2><ul>
<li><p>简介：</p>
<ul>
<li>写入一个块编码格式的块数据(Write a chunk of data in chunked encoding format.)</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_write_chunk</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 一个连接指针</li>
<li>buf : 需要写入的数据</li>
<li>len : 写入数据的长度</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mg_http_write_chunk(c, <span class="string">&quot;hi&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-delete-chunk"><a href="#mg-http-delete-chunk" class="headerlink" title="mg_http_delete_chunk"></a>mg_http_delete_chunk</h2><ul>
<li><p>简介：</p>
<ul>
<li>从输入缓冲区中删除指定的块(chunk)</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_delete_chunk</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="keyword">struct</span> mg_http_message *hm)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 连接指针</li>
<li>hm : 需要删除的块(chunk)</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_CHUNK) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    mg_http_delete_chunk(c, hm); <span class="comment">// Remove received chunk</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="struct-mg-http-serve-opts"><a href="#struct-mg-http-serve-opts" class="headerlink" title="struct mg_http_serve_opts"></a>struct mg_http_serve_opts</h2><ul>
<li><p>简介：</p>
<ul>
<li>传递给<code>mg_http_serve_dir()</code>和<code>mg_http_serve_file()</code>的结构，该结构驱动了这两个函数的行为</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_serve_opts</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *root_dir;       <span class="comment">// Web root directory, must be non-NULL</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ssi_pattern;    <span class="comment">// SSI file name pattern, e.g. #.shtml</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *extra_headers;  <span class="comment">// Extra HTTP headers to add in responses</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *mime_types;     <span class="comment">// Extra mime types, ext1=type1,ext2=type2,..</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *page404;        <span class="comment">// Path to the 404 page, or NULL by default</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_fs</span> *<span class="title">fs</span>;</span>           <span class="comment">// Filesystem implementation. Use NULL for POSIX</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-serve-dir"><a href="#mg-http-serve-dir" class="headerlink" title="mg_http_serve_dir"></a>mg_http_serve_dir</h2><ul>
<li><p>简介：</p>
<ul>
<li>根据给定选项服务多个静态文件。文件也可以被压缩,包括目录索引。所有压缩文件都必须以.gz结尾，并且不得在没有扩展名的情况下存在具有相同名称的文件，否则将优先考虑</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_serve_dir</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="keyword">struct</span> mg_http_message *hm, <span class="type">const</span> <span class="keyword">struct</span> mg_http_serve_opts *opts)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 使用的连接</li>
<li>hm : 应该被服务的HTTP消息</li>
<li>opts : 服务选项。请注意，<code>opts.root_dir</code>可以选择接受额外的逗号分隔<code>uri=path</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_serve_opts</span> <span class="title">opts</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;opts, <span class="number">0</span>, <span class="keyword">sizeof</span>(opts));</span><br><span class="line">    opts.root_dir = <span class="string">&quot;/var/www,/conf=/etc&quot;</span>;  <span class="comment">// Serve /var/www. URIs starting with /conf are served from /etc</span></span><br><span class="line">    mg_http_serve_dir(c, hm, &amp;opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-serve-file"><a href="#mg-http-serve-file" class="headerlink" title="mg_http_serve_file"></a>mg_http_serve_file</h2><ul>
<li><p>简介：</p>
<ul>
<li>服务一个静态文件。如果不存在带有路径中指定的文件名的文件，则Mongoose尝试附加<code>.gz</code>；如果存在这样的文件，它将使用<code>Content-Encoding: gzip</code> header 去服务</li>
</ul>
</li>
<li><p>原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_serve_file</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="keyword">struct</span> mg_http_message *hm, <span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> mg_http_serve_opts *opts)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 使用连接</li>
<li>hm : 需要服务的HTTP消息</li>
<li>path : 需要服务的文件路径</li>
<li>opts : 服务选项</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_serve_opts</span> <span class="title">opts</span> =</span> &#123;</span><br><span class="line">      .mime_types = <span class="string">&quot;png=image/png&quot;</span>,</span><br><span class="line">      .extra_headers = <span class="string">&quot;AA: bb\r\nCC: dd\r\n&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    mg_http_serve_file(c, hm, <span class="string">&quot;a.png&quot;</span>, &amp;opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-reply"><a href="#mg-http-reply" class="headerlink" title="mg_http_reply"></a>mg_http_reply</h2><ul>
<li><p>简介：</p>
<ul>
<li>通过使用<code>printf()</code>语义发送简单的HTTP响应。这个函数根据<code>body_fmt</code>格式化响应体(response body)，然后自动追加到一个正确的<code>Content-Length</code>头(header)。额外的<code>headers</code>需要通过<code>headers</code>参数传递</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_reply</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> status_code, <span class="type">const</span> <span class="type">char</span> *headers, <span class="type">const</span> <span class="type">char</span> *body_fmt, ...)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 一个连接</li>
<li>status_code : 一个HTTP响应状态码</li>
<li>headers : 额外的headers，默认为NULL，如果不是空，则必须以<code>\r\n</code>结尾</li>
<li>fmt : 使用<code>printf</code>语义，需要格式化成HTTP body的字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一个简单的JSON响应：</span></span><br><span class="line">mg_http_reply(c, <span class="number">200</span>, <span class="string">&quot;Content-Type: application/json\r\n&quot;</span>, <span class="string">&quot;&#123;\&quot;result\&quot;: %d&#125;&quot;</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// 发送一个302重定向：</span></span><br><span class="line">mg_http_reply(c, <span class="number">302</span>, <span class="string">&quot;Location: /\r\n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 发送一个错误</span></span><br><span class="line">mg_http_reply(c, <span class="number">403</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Not Authorized\n&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-get-header"><a href="#mg-http-get-header" class="headerlink" title="mg_http_get_header"></a>mg_http_get_header</h2><ul>
<li><p>简介：</p>
<ul>
<li>获取HTTP header值</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_str *<span class="title function_">mg_http_get_header</span><span class="params">(<span class="keyword">struct</span> mg_http_message *hm, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>hm : 需要寻找 header 的HTTP消息</li>
<li>name : Header name</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，HTTP header</li>
<li>失败，NULL</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose event handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> *<span class="title">s</span> =</span> mg_http_get_header(hm, <span class="string">&quot;X-Extra-Header&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      mg_http_reply(c, <span class="number">200</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Holly molly! Header value: %.*s&quot;</span>, (<span class="type">int</span>) s-&gt;len, s-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mg_http_reply(c, <span class="number">200</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Oh no, header is not set...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-get-header-var"><a href="#mg-http-get-header-var" class="headerlink" title="mg_http_get_header_var"></a>mg_http_get_header_var</h2><ul>
<li><p>简介：</p>
<ul>
<li>解析具有表格<code>name1=value1; name=value2;...</code>的HTTP header，并获取一个给定的变量</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_str <span class="title function_">mg_http_get_header_var</span><span class="params">(<span class="keyword">struct</span> mg_str s, <span class="keyword">struct</span> mg_str v)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>s : HTTP header</li>
<li>name : 变量名字</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，一个请求的变量</li>
<li>失败，一个空的字符串</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> *<span class="title">cookie</span> =</span> mg_http_get_header(hm, <span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">token</span> =</span> mg_str(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cookie != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  token = mg_http_get_header_var(*cookie, mg_str(<span class="string">&quot;access_token&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-var"><a href="#mg-http-var" class="headerlink" title="mg_http_var"></a>mg_http_var</h2><ul>
<li><p>简介：</p>
<ul>
<li>获取未编码的HTTP变量</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mg_str <span class="title function_">mg_http_var</span><span class="params">(<span class="keyword">struct</span> mg_str buf, <span class="keyword">struct</span> mg_str name)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>buf : 一个url编码的字符串：HTTP请求体或查询字符串(HTTP request body or query string)</li>
<li>name : 获取的变量名字</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回变量的值</li>
<li>失败，返回一个空字符串</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We have received a request to /my/uri?a=b&amp;c=d%20</span></span><br><span class="line"><span class="comment">// The hm-&gt;query points to &quot;a=b&amp;c=d%20&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">v</span> =</span> mg_http_var(hm-&gt;query, mg_str(<span class="string">&quot;c&quot;</span>));  <span class="comment">// v = &quot;d%20&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-get-var"><a href="#mg-http-get-var" class="headerlink" title="mg_http_get_var"></a>mg_http_get_var</h2><ul>
<li><p>简介：</p>
<ul>
<li>获取并解码HTTP 变量</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_http_get_var</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> mg_str *var, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> *buf, <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>var : HTTP请求体(HTTP request body)</li>
<li>name : 变量名</li>
<li>buf : 写入解码变量的缓冲区(Buffer to write decoded variable)</li>
<li>len : 缓冲区大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，解码变量的长度， 0</li>
<li>失败，返回负数</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">mg_http_get_var(&amp;hm-&gt;body, <span class="string">&quot;key1&quot;</span>, buf, <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-creds"><a href="#mg-http-creds" class="headerlink" title="mg_http_creds"></a>mg_http_creds</h2><ul>
<li><p>简介：</p>
<ul>
<li>从请求获取身份验证证书，然后将它存储到<code>user</code>, <code>userlen</code>, <code>pass</code>, <code>passlen</code>缓冲区中。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_creds</span><span class="params">(<span class="keyword">struct</span> mg_http_message *hm, <span class="type">char</span> *user, <span class="type">size_t</span> userlen, <span class="type">char</span> *pass, <span class="type">size_t</span> passlen)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>hm : 需要查找证书的HTTP 消息</li>
<li>user : 接收用户名字的缓冲区</li>
<li>userlen : user缓冲区的大小</li>
<li>pass : 接收密码的缓冲区</li>
<li>passlen : pass缓冲区的大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="type">char</span> user[<span class="number">100</span>], pass[<span class="number">100</span>];</span><br><span class="line">    mg_http_creds(hm, user, <span class="keyword">sizeof</span>(user), pass, <span class="keyword">sizeof</span>(pass)); <span class="comment">// &quot;user&quot; is now user name and &quot;pass&quot; is now password from request</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-match-uri"><a href="#mg-http-match-uri" class="headerlink" title="mg_http_match_uri"></a>mg_http_match_uri</h2><ul>
<li><p>简介：</p>
<ul>
<li>检查在HTTP请求报文中，是否有和给定的<code>glob</code>字符串相匹配的字符串</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">mg_http_match_uri</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> mg_http_message *hm, <span class="type">const</span> <span class="type">char</span> *glob)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>hm : 需要匹配检索的HTTP消息</li>
<li>glob : 匹配的字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，true </li>
<li>失败，false</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose events handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="keyword">if</span> (mg_http_match_uri(hm, <span class="string">&quot;/secret&quot;</span>)) &#123;</span><br><span class="line">      mg_http_reply(c, <span class="number">200</span>, <span class="literal">NULL</span>, <span class="string">&quot;Very big secret!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mg_http_reply(c, <span class="number">200</span>, <span class="literal">NULL</span>, <span class="string">&quot;hello world..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-bauth"><a href="#mg-http-bauth" class="headerlink" title="mg_http_bauth"></a>mg_http_bauth</h2><ul>
<li><p>简介：</p>
<ul>
<li>将一个基本的<code>Authorization</code> header写入到输出缓冲区</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mg_http_bauth</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">const</span> <span class="type">char</span> *user, <span class="type">const</span> <span class="type">char</span> *pass)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 使用的连接</li>
<li>user : 用户名</li>
<li>pass : 密码</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mg_printf(c, <span class="string">&quot;POST /v1/subscriptions HTTP/1.1\r\n&quot;</span></span><br><span class="line">             <span class="string">&quot;Host: api.stripe.com\r\n&quot;</span></span><br><span class="line">             <span class="string">&quot;Transfer-Encoding: chunked\r\n&quot;</span>);</span><br><span class="line">mg_http_bauth(c, stripe_private_key, <span class="literal">NULL</span>);     <span class="comment">// Add Basic auth header</span></span><br><span class="line">mg_printf(c, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span>);                     <span class="comment">// End HTTP headers</span></span><br><span class="line"></span><br><span class="line">mg_http_printf_chunk(c, <span class="string">&quot;&amp;customer=%s&quot;</span>, customer_id);   <span class="comment">// Set customer</span></span><br><span class="line">mg_http_printf_chunk(c, <span class="string">&quot;&amp;items[0][price]=%s&quot;</span>, price);  <span class="comment">// And price</span></span><br><span class="line">mg_http_printf_chunk(c, <span class="string">&quot;&quot;</span>);                            <span class="comment">// End request</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="struct-mg-http-part"><a href="#struct-mg-http-part" class="headerlink" title="struct mg_http_part"></a>struct mg_http_part</h2><ul>
<li><p>简介：</p>
<ul>
<li>描述HTTP 多个消息(multipart message)中单个部分的结构体</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parameter for mg_http_next_multipart</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_part</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">name</span>;</span>      <span class="comment">// Form field name</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">filename</span>;</span>  <span class="comment">// Filename for file uploads</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mg_str</span> <span class="title">body</span>;</span>      <span class="comment">// Part contents</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-next-multipart"><a href="#mg-http-next-multipart" class="headerlink" title="mg_http_next_multipart"></a>mg_http_next_multipart</h2><ul>
<li><p>简介：</p>
<ul>
<li>根据给定的<code>offset</code>，在<code>body</code>中解析multipart chunk。一个初始的<code>offset</code>应该为0.在提供的<code>part</code>中填充参数，可能为空。返回下一块的offsete，或者返回0表示没有其他块(chunks)</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">mg_http_next_multipart</span><span class="params">(<span class="keyword">struct</span> mg_str body, <span class="type">size_t</span> offset, <span class="keyword">struct</span> mg_http_part *part)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>body : 消息体</li>
<li>offset : 开始偏移量</li>
<li>part : 指向需要填充的<code>struct mg_http_part</code>结构体</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回下一块的offset</li>
<li>失败，返回0，或者表示没有其他块</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_http_part</span> <span class="title">part</span>;</span></span><br><span class="line"><span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((pos = mg_http_next_multipart(body, pos, &amp;part)) != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Use part</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-http-upload"><a href="#mg-http-upload" class="headerlink" title="mg_http_upload"></a>mg_http_upload</h2><ul>
<li><p>简介：</p>
<ul>
<li>这是一个助手实用程序功能，用于通过小块上传大型文件。将HTTP POST 数据追加到指定目录的文件中。文件名和文件偏移由查询字符串参数指定:<code>POST /upload?name=firmware.bin&amp;offset=2048 HTTP/1.1</code>。如果偏移量为0，则将文件截断。客户的责任是将文件分为较小的块，并发送一系列由此功能处理的POST请求</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mg_http_upload</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="keyword">struct</span> mg_http_message *hm, <span class="keyword">struct</span> mg_fs *fs, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">size_t</span> max_size)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c : 一个连接</li>
<li>hm : 一个需要被解析的HTTP message</li>
<li>fs : 需要写文件的文件系统，例如：<code>&amp;mg_fs_posix</code></li>
<li>path : 一个文件名</li>
<li>max_size : 允许的文件大小的最大值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回文件的大小</li>
<li>失败，返回一个负数</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mg_http_message</span> *<span class="title">hm</span> =</span> (<span class="keyword">struct</span> mg_http_message *) ev_data;</span><br><span class="line">    <span class="keyword">if</span> (mg_http_match_uri(hm, <span class="string">&quot;/upload&quot;</span>)) &#123;</span><br><span class="line">      mg_http_upload(c, hm, &amp;mg_fs_posix, <span class="string">&quot;/tmp/myfile.bin&quot;</span>, <span class="number">99999</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">struct</span> mg_http_serve_opts opts = &#123;.root_dir = <span class="string">&quot;.&quot;</span>&#125;;   <span class="comment">// Serve</span></span><br><span class="line">      mg_http_serve_dir(c, ev_data, &amp;opts);                 <span class="comment">// static content</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_sntp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_sntp/" class="post-title-link" itemprop="url">mongoose_sntp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>SNTP server(simple network time protocol), 是一种用于提供时间同步服务的网络服务器。它基于网络通信协议，允许计算机和其他网络设备通过网络获取准确的时间信息</li>
</ul>
<h2 id="mg-sntp-connect"><a href="#mg-sntp-connect" class="headerlink" title="mg_sntp_connect"></a>mg_sntp_connect</h2><ul>
<li><p>简介：</p>
<ul>
<li>连接SNTP服务器。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mg_connection</span> *<span class="built_in">mg_sntp_connect</span>(<span class="keyword">struct</span> mg_mgr *mgr, <span class="type">const</span> <span class="type">char</span> *url,</span><br><span class="line">                                      <span class="type">mg_event_handler_t</span> fn, <span class="type">void</span> *fn_data)</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>mgr – 使用的事件管理器</li>
<li>url – 指定远程URL，如果为空，则为time.google.com。</li>
<li>fn  – 事件处理函数</li>
<li>fn_data – 一个任意指针，在调用事件处理程序时作为fn_data传递。该指针也将作为c-&gt;fn_data存储在连接结构中。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回指向创建的连接的指针</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sntp_cb</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *evd, <span class="type">void</span> *fnd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ev == MG_EV_SNTP_TIME) &#123;</span><br><span class="line">    <span class="comment">// Time received</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> *tv = (<span class="keyword">struct</span> timeval *tv)evd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">mg_sntp_connect</span>(mgr&amp;, <span class="literal">NULL</span> <span class="comment">/* connect to time.google.com */</span>, sntp_cb, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mg-sntp-request"><a href="#mg-sntp-request" class="headerlink" title="mg_sntp_request"></a>mg_sntp_request</h2><ul>
<li><p>简介：</p>
<ul>
<li>向SNTP服务器发送时间请求</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_sntp_request</span><span class="params">(<span class="keyword">struct</span> mg_connection *c)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c – 使用的连接</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mg_sntp_request</span>(c);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_logging/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_logging/" class="post-title-link" itemprop="url">mongoose_logging</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose 日志相关函数</li>
<li>Mongoose为日志记录提供了一系列函数和宏。应用程序可以为自己的目的使用这些函数，也可以使用Mongoose API的其他部分。</li>
</ul>
<h2 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h2><ul>
<li><p>简介：</p>
<ul>
<li>日志宏</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(level, args)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_ERROR(args) MG_LOG(MG_LL_ERROR, args)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_INFO(args) MG_LOG(MG_LL_INFO, args)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_DEBUG(args) MG_LOG(MG_LL_DEBUG, args)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MG_VERBOSE(args) MG_LOG(MG_LL_VERBOSE, args)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MG_INFO</span>((<span class="string">&quot;Hello %s!&quot;</span>, <span class="string">&quot;world&quot;</span>));  <span class="comment">// Output &quot;Hello, world&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-log-set"><a href="#mg-log-set" class="headerlink" title="mg_log_set"></a>mg_log_set</h2><ul>
<li><p>简介：</p>
<ul>
<li>设置Mongoose日志级别</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_log_set</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *spec)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>spec – 字符串，包含日志级别，可以是以下值之一<ul>
<li>0 – 关闭日志</li>
<li>1 – 仅输出错误</li>
<li>2 – 输出错误和消息</li>
<li>3 – 输出错误，消息和调试消息</li>
<li>4 – 输出所有日志信息</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>可以根据源文件覆盖日志级别。例如，如果有一个名为foo.c的文件，您希望将全局级别设置为2（info），但将foo.c文件的日志级别提高到debug，那么规格应该是 “2,foo.c&#x3D;3”。可以有多个以逗号分隔的重写。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mg_log_set</span>(<span class="string">&quot;2&quot;</span>);                  <span class="comment">// Set log level to info</span></span><br><span class="line"><span class="built_in">mg_log_set</span>(<span class="string">&quot;2,foo.c=3,bar.c=0&quot;</span>);  <span class="comment">// Set log level to info, with overrides</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-hexdump"><a href="#mg-hexdump" class="headerlink" title="mg_hexdump"></a>mg_hexdump</h2><ul>
<li><p>简介：</p>
<ul>
<li>记录二进制数据buf, len的十六进制转储。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_hexdump</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>buf – 数据指针</li>
<li>len – 数据大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mg_hexdump</span>(c-&gt;recv.buf, c-&gt;recv.len);  <span class="comment">// Hex dump incoming data</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-log-set-fn"><a href="#mg-log-set-fn" class="headerlink" title="mg_log_set_fn"></a>mg_log_set_fn</h2><ul>
<li><p>简介：</p>
<ul>
<li>将日志重定向到自定义函数。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_log_set_fn</span><span class="params">(<span class="type">mg_pfn_t</span> logfunc, <span class="type">void</span> *param)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>logfunc – 记录单个字符的函数指针</li>
<li>param – 日志函数参数</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mylog</span><span class="params">(<span class="type">char</span> ch, <span class="type">void</span> *param)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">  <span class="type">static</span> <span class="type">size_t</span> len;</span><br><span class="line">  buf[len++] = ch;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span> || len &gt;= <span class="built_in">sizeof</span>(buf)) &#123;</span><br><span class="line">    <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;%.*s&quot;</span>, (<span class="type">int</span>) len, buf); <span class="comment">// Send logs</span></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">mg_log_set_fn</span>(mylog, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-Overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-Overview/" class="post-title-link" itemprop="url">Overview</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>使用方式</p>
<ul>
<li>添加<code>mongoose.h</code>和<code>mongoose.c</code>文件</li>
</ul>
</li>
<li><p>两个基本数据结构</p>
<ul>
<li><code>struct mg_mgr</code>  –  持有所有运行连接的事件管理</li>
<li><code>struct mg_connection</code>  –  单个连接描述符。换言之，每个连接都通过结构mg_connection结构来描述</li>
</ul>
</li>
<li><p>事件处理，每一个连接有两个事件处理函数：<code>c-&gt;fn</code>和<code>c-&gt;pfn</code></p>
<ul>
<li><code>c-&gt;fn</code>，是由用户自定义的事件处理函数</li>
<li><code>c-&gt;pfn</code>，是一个特定于协议的处理程序函数，被隐式设置。例如，<code>mg_http_listen()</code>将<code>c-&gt;pfn</code>设置为mongoose的HTTP事件处理程序。</li>
</ul>
</li>
<li><p>在特定于用户的处理程序之前调用特定于协议的处理程序。它解析传入数据，并可能调用特定于协议的事件，例如<code>MG_EV_HTTP_MSG</code></p>
</li>
<li><p>注意：</p>
<ul>
<li>由于Mongoose的核心不受并发访问的保护，因此请确保从同一线程或RTOS任务调用所有<code>mg_*</code> API函数</li>
</ul>
</li>
<li><p>发送和接收缓冲区，每一个连接有一个发送和接收缓冲区：<code>struct mg_connection::send</code>, <code>struct mg_connection::recv</code></p>
<ul>
<li><code>struct mg_connection::send</code> : 将发送到对端的数据</li>
<li><code>struct mg_connection::recv</code> : 从对端接收的数据</li>
</ul>
</li>
<li><p>当数据到达时，mongoose将接收到的数据追加到<code>recv</code>并触发一个<code>MG_EV_READ</code>事件。</p>
</li>
<li><p>用户可以通过调用输出函数之一来发送数据，例如<code>mg_send()</code>，<code>mg_printf()</code>或类似于<code>mg_ws_send()</code>的协议特定函数。</p>
</li>
<li><p>输出函数将数据追加到<code>send</code>缓冲区。当mongoose成功将数据写入套接字中时，它会将数据从结构体<code>mg_connection::send</code>中丢掉并且发送一个<code>MG_EV_WRITE</code>事件</p>
</li>
<li><p>每个连接都有与之关联的事件处理函数，该功能必须由用户实现。事件处理函数是mongoose的关键要素，因为它定义了连接的行为</p>
</li>
<li><p>事件处理函数示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Event handler function defines connection&#x27;s behavior</span><br><span class="line">static void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_READ) &#123;</span><br><span class="line">    mg_send(c, c-&gt;recv.buf, c-&gt;recv.len);   // Implement echo server</span><br><span class="line">    c-&gt;recv.len = 0;                        // Delete received data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>参数：</p>
<ul>
<li><code>struct mg_connection *c</code>  –  接收事件的连接</li>
<li><code>int ev</code>                   –  在<code>mongoose.h</code>中定义的事件编号。例如，当数据到达入站连接时，<code>ev</code>将是<code>MG_EV_READ</code></li>
<li><code>void *ev_data</code>            –  指向特定于事件的数据，并且对不同事件具有不同的含义。<ul>
<li>例如，对于<code>MG_EV_READ</code>事件，<code>ev_data</code>是一个<code>int *</code>指向从远程对等方接收的字节数，并保存到<code>c-&gt;recv</code> IO缓冲区中。</li>
<li><code>ev_data</code>的确切含义是<strong>用来描述每一个事件</strong>。</li>
<li>特定于协议的事件通常将<code>ev_data</code>指向具有特定协议信息的结构</li>
</ul>
</li>
<li><code>void *fn_data</code>            –  连接的用户定义指针，这是用于应用程序特定数据的占位符。<ul>
<li>这个<code>fn_data</code>指针是在<code>*_listen()</code>或者<code>*_connect()</code>调用期间设置的，并将其存储在<code>c-&gt;fn_data</code>。</li>
<li>监听连接将<code>c-&gt;fn_data</code>的值复制到新接受的连接，因此所有接受的连接最初共享相同的<code>fn_data</code>指针。</li>
<li>通过设置<code>c-&gt;fn_data = new_value</code>，可以随时更新或替换任何连接的<code>fn_data</code>指针</li>
</ul>
</li>
</ul>
</li>
<li><p><code>struct mg_connection</code>具有带有连接标志的设置。标志是二进制的：它们是0或者1。一些标志是由mongoose设置的，应用代码不能修改。例如，<code>is_udp</code>标志告诉应用连接是不是UDP。</p>
</li>
<li><p>一些标志是应用代码可以修改的，它们是：<code>is_hexdumping</code>, <code>id_draining</code>, <code>is_closing</code>。</p>
<ul>
<li><code>id_draining</code>标志，如果用户设置了这个标志，就是告诉mongoose向对端发送剩余数据，当都发送完毕时，关掉这个连接</li>
<li><code>is_closing</code>标志，如果用户设置了这个标志，就是立即关闭并释放连接，而不需要发送剩余数据</li>
<li><code>is_hexdumping</code>标志，</li>
</ul>
</li>
<li><p>调试日志。要增加调试的详细性，调用<code>mg_log_set()</code> ： <code>mg_log_set(MG_LL_DEBUG); mg_mgr_init(&amp;mgr);</code></p>
<ul>
<li><code>MG_INFO()</code>, <code>MG_DEBUG()</code>日志宏默认情况下使用<code>putchar()</code>，即它们使用标准的C stdout流。这种方式在传统的操作系统环境正常工作。在嵌入式环境中，为了查看调试日志，可以使用两种方式：IO重定位和日志重定向<ul>
<li>IO重定位可以通过嵌入式SDK实现</li>
</ul>
</li>
</ul>
</li>
<li><p>如果您需要执行连接的任何初始化，请通过捕获<code>MG_EV_OPEN</code>事件进行操作。</p>
</li>
<li><p>该事件是在连接被分配并添加到事件管理之后立即发送的，并在其他任何内容之前。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">if (ev == MG_EV_OPEN) &#123;</span><br><span class="line">  ... // Do your initialisation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果您需要保留一些特定连接的数据，则有两个选择</p>
<ul>
<li>第一，使用<code>c-&gt;fn_data</code>指针。该指针作为最后一个参数传递给事件处理程序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_OPEN) &#123;</span><br><span class="line">    c-&gt;fn_data = malloc(123);       // Change our fn_data</span><br><span class="line">  &#125; else if (ev == MG_EV_CLOSE) &#123;</span><br><span class="line">    free(fn_data);  // Don&#x27;t forget to free!</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Every accepted connection inherit NULL pointer as c-&gt;fn_data, but we change</span><br><span class="line">// it per-connection to something else</span><br><span class="line">mg_http_listen(&amp;mgr, &quot;http://localhost:1234&quot;, fn, NULL);</span><br></pre></td></tr></table></figure></li>
<li>第二，使用<code>c-&gt;label</code>缓冲区。该缓冲区可以容纳一些特定于连接的数据，而无需额外的内存分配<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_WS_OPEN) &#123;</span><br><span class="line">    c-&gt;label[0] = &#x27;W&#x27;; // Established websocket connection, store something</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果需要关闭连接，请在自己的事件处理函数中设置<code>c-&gt;is_draining = 1;</code>。它将告诉mongoose向对端发送剩余数据，当都发送完毕时，关掉这个连接</p>
</li>
<li><p>如果需要立即关闭而不需要发送剩余数据，则设置<code>c-&gt;is_closing = 1;</code></p>
</li>
<li><p>使用<code>mg_http_reply()</code>函数创建HTTP响应报文。重要的是，这个函数能够正确设置<code>Content-Length</code>头。</p>
</li>
<li><p>当然，也可以手动创建HTTP响应报文。例如，使用<code>mg_printf()</code>函数，但是请确定设置了<code>Content-Length</code>头</p>
<ul>
<li><code>mg_printf(c, &quot;HTTP/1.1 200 OK\r\Content-Length: %d\r\n\r\n%s&quot;, 2, &quot;hi&quot;);</code></li>
</ul>
</li>
<li><p>或者，使用块的传输编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mg_printf(c, &quot;HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n&quot;);</span><br><span class="line">mg_http_printf_chunk(c, &quot;%s&quot;, &quot;foo&quot;);</span><br><span class="line">mg_http_printf_chunk(c, &quot;%s&quot;, &quot;bar&quot;);</span><br><span class="line">mg_http_printf_chunk(c, &quot;&quot;);  // Don&#x27;t forget the last empty chunk</span><br></pre></td></tr></table></figure></li>
<li><p>需要注意的是：如果不适用<code>mg_http_reply()</code>或者<code>mg_http_*_chunk()</code>，请确保在自己的活动处理程序完成写入响应报文时，确保设置<code>c-&gt;is_reply = 0;</code></p>
</li>
<li><p>默认情况下，IO缓冲区分配的大小<code>MG_IO_SIZE</code>是2048.将其更改为512可以减少每个连接的内存消耗</p>
</li>
<li><p>Mongoose有三种影响构建的构建常数（预处理器定义）：目标体系结构&#x2F;操作系统，目标网络堆栈，可调参数。</p>
</li>
<li><p>为了在构建时间设置选项，请使用-D选项编译器标志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cc app.c mongoose.c                           # Use defaults!</span><br><span class="line">$ cc app.c mongoose.c -D MG_ENABLE_IPV6=1       # Build with IPv6 enabled</span><br><span class="line">$ cc app.c mongoose.c -D MG_ARCH=MG_ARCH_RTX    # Set architecture</span><br><span class="line">$ cc app.c mongoose.c -D MG_ENABLE_SSI=0 -D MG_IO_SIZE=8192  # Multiple options</span><br></pre></td></tr></table></figure></li>
<li><p>支持架构的列表在<code>Arch.H</code>标题文件中定义。通常，无需明确指定体系结构。在构建过程中猜到了架构，因此通常不需要设置 </p>
</li>
<li><p>网络堆栈常数在下面列出。请注意，如果未指定网络堆栈，则假定目标体系结构支持标准BSD套接字API</p>
</li>
<li><p>另一类的构建常量是在<code>src/config.h</code>中定义的，以及它们的默认值。这些是包含&#x2F;排除某个功能或更改相关参数的调谐物。</p>
</li>
<li><p><code>MG_IO_SIZE</code>常数还设置了最大的UDP消息大小，请参见<code>#/907</code>有关详细信息。如果应用程序使用大型UDP消息，请相应地增加<code>MG_IO_SIZE</code>限制。</p>
</li>
<li><p>此步骤是可选的，仅当您打算使用自定义TCP&#x2F;IP堆栈时才需要。为此，您应该：</p>
<ul>
<li>禁用BSD插座API：在Mongoose_custom.h中，添加<code>#define MG_ENABLE_SOCKET 0</code></li>
</ul>
</li>
<li><p>添加几个内部API函数的实现，例如<code>mg_send()</code>, <code>mg_mgr_poll()</code>等等。要参考，请查看<code>test/mongoose_custom.c</code>和实验性的<code>src/mip.c</code></p>
</li>
</ul>
<h2 id="重要API"><a href="#重要API" class="headerlink" title="重要API"></a>重要API</h2><h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h3><h4 id="struct-mg-addr"><a href="#struct-mg-addr" class="headerlink" title="struct mg_addr"></a><code>struct mg_addr</code></h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct mg_addr &#123;</span><br><span class="line">  uint16_t port;    // TCP or UDP port in network byte order</span><br><span class="line">  uint32_t ip;      // IP address in network byte order</span><br><span class="line">  uint8_t ip6[16];  // IPv6 address</span><br><span class="line">  bool is_ip6;      // True when address is IPv6 address</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>该结构包含网络地址。它可以被认为<code>sockaddr</code>结构在Mongoose中的等价结构体</li>
</ul>
<h4 id="struct-mg-mgr"><a href="#struct-mg-mgr" class="headerlink" title="struct mg_mgr"></a><code>struct mg_mgr</code></h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct mg_mgr &#123;</span><br><span class="line">  struct mg_connection *conns;  // List of active connections  结构体数组</span><br><span class="line">  struct mg_dns dns4;           // DNS for IPv4</span><br><span class="line">  struct mg_dns dns6;           // DNS for IPv6</span><br><span class="line">  int dnstimeout;               // DNS resolve timeout in milliseconds</span><br><span class="line">  unsigned long nextid;         // Next connection ID</span><br><span class="line">  void *userdata;               // Arbitrary user data pointer</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>它是一个事件管理结构体，能够保存一个正在活动的连接列表，以及一些维持管理的信息</li>
</ul>
<h4 id="struct-mg-connection"><a href="#struct-mg-connection" class="headerlink" title="struct mg_connection"></a><code>struct mg_connection</code></h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct mg_connection &#123;</span><br><span class="line">  struct mg_connection *next;  // Linkage in struct mg_mgr :: connections</span><br><span class="line">  struct mg_mgr *mgr;          // Our container</span><br><span class="line">  struct mg_addr loc;          // Local address</span><br><span class="line">  struct mg_addr rem;          // Remote address</span><br><span class="line">  void *fd;                    // Connected socket, or LWIP data</span><br><span class="line">  unsigned long id;            // Auto-incrementing unique connection ID</span><br><span class="line">  struct mg_iobuf recv;        // Incoming data</span><br><span class="line">  struct mg_iobuf send;        // Outgoing data</span><br><span class="line">  mg_event_handler_t fn;       // User-specified event handler function</span><br><span class="line">  void *fn_data;               // User-specified function parameter</span><br><span class="line">  mg_event_handler_t pfn;      // Protocol-specific handler function</span><br><span class="line">  void *pfn_data;              // Protocol-specific function parameter</span><br><span class="line">  char label[50];              // Arbitrary label</span><br><span class="line">  void *tls;                   // TLS specific data</span><br><span class="line">  unsigned is_listening : 1;   // Listening connection</span><br><span class="line">  unsigned is_client : 1;      // Outbound (client) connection</span><br><span class="line">  unsigned is_accepted : 1;    // Accepted (server) connection</span><br><span class="line">  unsigned is_resolving : 1;   // Non-blocking DNS resolve is in progress</span><br><span class="line">  unsigned is_connecting : 1;  // Non-blocking connect is in progress</span><br><span class="line">  unsigned is_tls : 1;         // TLS-enabled connection</span><br><span class="line">  unsigned is_tls_hs : 1;      // TLS handshake is in progress</span><br><span class="line">  unsigned is_udp : 1;         // UDP connection</span><br><span class="line">  unsigned is_websocket : 1;   // WebSocket connection</span><br><span class="line">  unsigned is_hexdumping : 1;  // Hexdump in/out traffic</span><br><span class="line">  unsigned is_draining : 1;    // Send remaining data, then close and free</span><br><span class="line">  unsigned is_closing : 1;     // Close and free the connection immediately</span><br><span class="line">  unsigned is_full : 1;        // Stop reads, until cleared</span><br><span class="line">  unsigned is_resp : 1;        // Response is still being generated</span><br><span class="line">  unsigned is_readable : 1;    // Connection is ready to read</span><br><span class="line">  unsigned is_writable : 1;    // Connection is ready to write</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>它是一个连接：可能是一个监听连接，或者是一个已接收连接，或者是一个出站连接</li>
</ul>
<h3 id="1-2-核心API调用"><a href="#1-2-核心API调用" class="headerlink" title="1.2 核心API调用"></a>1.2 核心API调用</h3><h4 id="mg-mgr-init"><a href="#mg-mgr-init" class="headerlink" title="mg_mgr_init()"></a><code>mg_mgr_init()</code></h4><ul>
<li><code>void mg_mgr_init(struct mg_mgr *mgr);</code></li>
<li>初始化事件管理器结构体变量，它所做的工作：<ul>
<li>将活动连接的列表设置为null</li>
<li>设置IPv4和IPv6的默认DNS服务器</li>
<li>设置默认DNS查找超时</li>
</ul>
</li>
<li>参数<ul>
<li><code>mgr</code>  –  需要初始化的<code>mg_mgr</code>结构体指针</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct mg_mgr mgr;</span><br><span class="line">mg_mgr_init(&amp;mgr);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-mgr-poll"><a href="#mg-mgr-poll" class="headerlink" title="mg_mgr_poll()"></a><code>mg_mgr_poll()</code></h4><ul>
<li><code>void mg_mgr_poll(struct mg_mgr *mgr, int ms);</code></li>
<li>在所有连接中迭代，接受新的连接，发送和接收数据，关闭连接并调用事件处理程序的功能，以适用于各自事件。</li>
<li>执行一次池迭代(poll iteration)。对在<code>mgr-&gt;conns</code>列表中的每一个连接进行如下操作<ul>
<li>查看是否有传入数据。如果有，将数据读入到<code>c-&gt;recv</code>缓冲区，并发出一个<code>MG_EV_READ</code>事件</li>
<li>查看<code>c-&gt;send</code>缓冲区是否有数据。如果有，写入数据，并发送<code>MG_EV_WRITE</code>事件</li>
<li>如果一个连接处于监听状态，或已接收一个进入的连接状态，发送一个<code>MG_EV_ACCEPT</code>事件</li>
<li>发送<code>MG_EV_POLL</code>事件</li>
</ul>
</li>
<li>参数<ul>
<li><code>mgr</code>  –  使用的事件管理结构体</li>
<li><code>ms</code>   –  超时时间，单位为毫秒</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例<ul>
<li><code>while (running == true) mg_mgr_poll(&amp;mgr, 1000 /*1 second*/);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-mgr-free"><a href="#mg-mgr-free" class="headerlink" title="mg_mgr_free()"></a><code>mg_mgr_free()</code></h4><ul>
<li><code>void mg_mgr_free(struct mg_mgr *mgr);</code></li>
<li>关闭所有连接，释放所有资源</li>
<li>参数：<ul>
<li><code>mgr</code>  –  需要被清除的事件管理结构体</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_mgr mgr;</span><br><span class="line">mg_mgr_init(&amp;mgr);</span><br><span class="line">while (running == true) mg_mgr_poll(&amp;mgr, 1000);   // Event loop</span><br><span class="line">mg_mgr_free(&amp;mgr);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-listen"><a href="#mg-listen" class="headerlink" title="mg_listen()"></a><code>mg_listen()</code></h4><ul>
<li><code>struct mg_connection *mg_listen(struct mg_mgr *mgr, const char *url, mg_event_handler_t fn, void *fn_data);</code></li>
<li>创建一个监听连接，并将这个连接追加到<code>mgr-&gt;conns</code>连接列表中</li>
<li>参数：<ul>
<li><code>mgr</code>  –  使用的事件管理结构体</li>
<li><code>url</code>  –  URL。指定监听的本地IP地址和端口，例如：<code>tcp://127.0.0.1:1234</code>或<code>udp://0.0.0.0:9000</code></li>
<li><code>fn</code>   –  事件处理函数</li>
<li><code>fn_data</code>  –  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li>返回值：返回创建的连接 或 NULL作为错误</li>
<li>示例<ul>
<li><code>struct mg_connection *c = mg_listen(&amp;mgr, &quot;tcp://127.0.0.1:8080&quot;, fn, NULL);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-connect"><a href="#mg-connect" class="headerlink" title="mg_connect()"></a><code>mg_connect()</code></h4><ul>
<li><code>struct mg_connection *mg_connect(struct mg_mgr *mgr, const char *url, mg_event_handler_t fn, void *fn_data);</code></li>
<li>创建一个出站连接，并将这个连接追加到<code>mgr-&gt;conns</code>队列中</li>
<li>参数：<ul>
<li><code>mgr</code>  –  使用的事件管理结构体</li>
<li><code>url</code>  –  URL，指定需要连接的远程IP地址和端口。例如：<code>http://a.com</code></li>
<li><code>fn</code>   –  一个事件处理函数</li>
<li><code>fn_data</code>  –  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li>返回值：返回创建的连接 或 NULL作为错误</li>
<li>注意：<ul>
<li>这个函数不会连接对端，它只会分配需要的资源和启动连接进程。</li>
<li>一旦对端真正连接了，会将<code>MG_EV_CONNECT</code>事件发送到连接事件处理</li>
</ul>
</li>
<li>示例<ul>
<li><code>struct mg_connection *c = mg_connect(&amp;mgr, &quot;http://example.org&quot;, fn, NULL);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-send"><a href="#mg-send" class="headerlink" title="mg_send()"></a><code>mg_send()</code></h4><ul>
<li><code>int mg_send(struct mg_connection *c, const void *data, size_t size);</code></li>
<li>将大小为<code>size</code>的数据追加到<code>c-&gt;send</code>缓冲区。返回追加的字节数</li>
<li>注意：<ul>
<li>这个函数不会将数据推送到网络。它仅仅是将数据追加到输出缓冲区。</li>
<li>只有当<code>mg_mgr_poll()</code>被调用时，才会将数据发送出去。</li>
<li>如果<code>mg_send()</code>被多次调用，则输出缓冲区会增长</li>
</ul>
</li>
<li>参数：<ul>
<li><code>c</code>  –  一个连接指针</li>
<li><code>data</code>  –  一个指向需要增加到输出缓冲区的数据指针</li>
<li><code>size</code>  –  数据大小</li>
</ul>
</li>
<li>返回值：如果数据成功追加，则返回true；否则返回false</li>
<li>示例<ul>
<li><code>mg_send(c, &quot;hi&quot;, 2);  // Append string &quot;hi&quot; to the output buffer</code></li>
</ul>
</li>
</ul>
<h4 id="mg-printf-mg-vprintf"><a href="#mg-printf-mg-vprintf" class="headerlink" title="mg_printf(), mg_vprintf()"></a><code>mg_printf(), mg_vprintf()</code></h4><ul>
<li><code>int mg_printf(struct mg_connection *, const char *fmt, ...);</code></li>
<li><code>int mg_vprintf(struct mg_connection *, const char *fmt, va_list *ap);</code></li>
<li>与<code>mg_send()</code>相同，但是使用<code>printf()</code>语义格式化数据。返回追加到输出缓冲区的字节数。有关支持格式规范列表，参见<code>mg_snprintf</code></li>
<li>参数：<ul>
<li><code>c</code>  –  一个连接指针</li>
<li><code>fmt</code>  –  <code>printf()</code>语义中的格式字符串</li>
</ul>
</li>
<li>返回值：返回追加到输出缓冲区的字节数</li>
<li>示例<ul>
<li><code>mg_printf(c, &quot;Hello, %s!&quot;, &quot;world&quot;); // Add &quot;Hello, world!&quot; to output buffer</code></li>
</ul>
</li>
</ul>
<h4 id="mg-wrapfd"><a href="#mg-wrapfd" class="headerlink" title="mg_wrapfd()"></a><code>mg_wrapfd()</code></h4><ul>
<li><code>struct mg_connection *mg_wrapfd(struct mg_mgr *mgr, int fd, mg_event_handler_t fn, void *fn_data);</code></li>
<li>将给定的文件描述符<code>fd</code>包装到连接中，然后将该连接添加到事件管理器中。这个<code>fd</code>文件描述符必须支持<code>send(), recv(), select()</code>系统调用，而且是非阻塞的。Mongoose将把它当做TCP套接字使用。<code>c-&gt;rem</code>和<code>c-&gt;loc</code>地址将会变为空的</li>
<li>参数：<ul>
<li><code>fd</code>  –  需要包装的文件描述符</li>
<li><code>mgr</code> –  一个事件管理结构体</li>
<li><code>fn</code>  –  一个指向事件处理函数的指针</li>
<li><code>ud</code>  –  一个用户数据指针。它将被当做<code>fn_data</code>参数传递给<code>fn</code></li>
</ul>
</li>
<li>返回值：返回创建的连接 或者 NULL作为错误</li>
</ul>
<h4 id="mg-mkpipe"><a href="#mg-mkpipe" class="headerlink" title="mg_mkpipe()"></a><code>mg_mkpipe()</code></h4><ul>
<li><code>int mg_mkpipe(struct mg_mgr *mgr, mg_event_handler_t fn, void *fn_data, bool udp);</code></li>
<li>创建两个互相连接的套接字，用于线程间通信。其中一个套接字被包装到一个Mongoose连接，并被添加到事件管理结构体中。另一个套接字将会被返回，且它应该被传递给工作线程。当一个工作线程使用<code>send()</code>发送任何数据到这个套接字，都将唤醒<code>mgr</code>和<code>fn</code>事件处理函数接收一个<code>MG_EV_READ</code>事件。另外，<code>fn</code>向工作线程发送的任何数据，都被由工作线程使用<code>recv()</code>接收。</li>
<li>参数：<ul>
<li><code>mgr</code>  –  一个事件管理结构体</li>
<li><code>fn</code>   –  一个指向事件处理函数的指针</li>
<li><code>fn_data</code>  –  一个指向用户数据的指针。它将会被当做<code>fn_data</code>参数传递给<code>fn</code></li>
<li><code>udp</code>  –  告知创建一个UDP，还是创建一个TCP socketpair</li>
</ul>
</li>
<li>返回值：成功，返回创建的套接字；失败，返回-1</li>
<li>使用案例参见<code>examples/multi-threaded</code></li>
</ul>
<h4 id="mg-hello"><a href="#mg-hello" class="headerlink" title="mg_hello()"></a><code>mg_hello()</code></h4><ul>
<li><code>void mg_hello(const char *url);</code></li>
<li>便利功能，在给定的监听URL上启动一个简单的Web服务器。这个函数只有在接收到一个<code>/quit</code>请求才会返回。服务器处理以下URI<ul>
<li><code>/quit</code>  –  退出服务，且退出函数</li>
<li><code>/debug</code> –  设置调试级别，作为POST负载，<code>&#123;&quot;level&quot; : 3&#125;</code>是有效的</li>
<li>对其他所有的URI，都将返回一个<code>hi</code>作为响应</li>
</ul>
</li>
<li>参数：<ul>
<li><code>url</code>  –  一个监听的URL，例如：<code>http://0.0.0.0:8000</code></li>
</ul>
</li>
</ul>
<h3 id="1-3-HTTP-API"><a href="#1-3-HTTP-API" class="headerlink" title="1.3 HTTP API"></a>1.3 HTTP API</h3><h4 id="struct-mg-http-header"><a href="#struct-mg-http-header" class="headerlink" title="struct mg_http_header"></a><code>struct mg_http_header</code></h4><ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_http_header &#123;</span><br><span class="line">  struct mg_str name;   // Header name</span><br><span class="line">  struct mg_str value;  // Header value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>结构代表HTTP标头，像<code>Content-Type: text/html</code>。<code>Content-Type</code> 是一个 Header name，<code>text/html/</code>是一个 Header value</li>
</ul>
<h4 id="struct-mg-http-message"><a href="#struct-mg-http-message" class="headerlink" title="struct mg_http_message"></a><code>struct mg_http_message</code></h4><ul>
<li>声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct mg_http_message &#123;</span><br><span class="line">  struct mg_str method, uri, query, proto;             // Request/response line</span><br><span class="line">  struct mg_http_header headers[MG_MAX_HTTP_HEADERS];  // Headers</span><br><span class="line">  struct mg_str body;                                  // Body</span><br><span class="line">  struct mg_str message;                               // Request line + headers + body</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>结构代表HTTP消息。</li>
</ul>
<h4 id="mg-http-listen"><a href="#mg-http-listen" class="headerlink" title="mg_http_listen()"></a><code>mg_http_listen()</code></h4><ul>
<li><code>struct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url, mg_event_handler_t fn, void *fn_data);</code></li>
<li>创建HTTP侦听器。</li>
<li>参数：<ul>
<li><code>mgr</code>  –  一个事件管理结构体</li>
<li><code>url</code>  –  一个URL，指定监听的本地IP地址和端口。例如：<code>http://0.0.0.0:8000</code></li>
<li><code>fn</code>   –  一个事件处理函数</li>
<li><code>fn_data</code>  –  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li>返回值：返回一个指向创建的连接指针 或者 返回NULL表示错误</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct mg_connection *c = mg_http_listen(&amp;mgr, &quot;0.0.0.0:8000&quot;, fn, arg);</span><br><span class="line">if (c == NULL) fatal_error(&quot;Cannot create listener&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-connect"><a href="#mg-http-connect" class="headerlink" title="mg_http_connect()"></a><code>mg_http_connect()</code></h4><ul>
<li><code>struct mg_connection *mg_http_connect(struct mg_mgr *, const char *url, mg_event_handler_t fn, void *fn_data);</code></li>
<li>创建HTTP客户端连接。这个函数不能连接到对端，它仅仅分配需要的资源和启动连接进程。当对端真正连接好了，会向连接事件处理函数发送一个<code>MG_EV_CONNECT</code>事件</li>
<li>参数：<ul>
<li><code>mgr</code>  –  事件管理结构体</li>
<li><code>url</code>  –  URL，指定远程URL。例如:<code>http://google.com</code></li>
<li><code>fn</code>   –  事件处理函数</li>
<li><code>fn_data</code>  –  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li>返回值： 返回一个指向创建的连接的指针 或者 返回NULL表示错误</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct mg_connection *c = mg_http_connect(&amp;mgr, &quot;http://google.com&quot;, fn, NULL);</span><br><span class="line">if (c == NULL) fatal_error(&quot;Cannot create connection&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-status"><a href="#mg-http-status" class="headerlink" title="mg_http_status()"></a><code>mg_http_status()</code></h4><ul>
<li><code>int mg_http_status(const struct mg_http_message *hm);</code></li>
<li>获取HTTP响应的状态代码。</li>
<li>参数：<ul>
<li><code>hm</code>  –  需要解析的HTTP响应</li>
</ul>
</li>
<li>返回值：返回状态码。例如：200表示成功</li>
</ul>
<h4 id="mg-http-get-request-len"><a href="#mg-http-get-request-len" class="headerlink" title="mg_http_get_request_len()"></a><code>mg_http_get_request_len()</code></h4><ul>
<li><code>int mg_http_get_request_len(const unsigned char *buf, size_t buf_len);</code></li>
<li>获取请求的长度。请求的长度是直到HTTP头结束的字节数。它不包括HTTP请求体的长度</li>
<li>参数：<ul>
<li><code>buf</code>  –  指向存放请求数据的缓冲区的指针</li>
<li><code>buf_len</code>  –  缓冲区大小</li>
</ul>
</li>
<li>返回值： <ul>
<li>-1  –  错误</li>
<li>0   –  消息不完整</li>
<li>请求的长度</li>
</ul>
</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *buf = &quot;GET /test \n\nGET /foo\n\n&quot;;</span><br><span class="line">int req_len = mg_http_get_request_len(buf, strlen(buf));  // req_len == 12</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-parse"><a href="#mg-http-parse" class="headerlink" title="mg_http_parse()"></a><code>mg_http_parse()</code></h4><ul>
<li><code>int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm);</code></li>
<li>解析请求报文字符串，并存入到<code>mg_http_message</code>结构体中</li>
<li>参数：<ul>
<li><code>s</code>    –  一个请求字符串</li>
<li><code>len</code>  –  请求字符串的长度</li>
<li><code>hm</code>   –  存储解析请求报文结果的结构体指针</li>
</ul>
</li>
<li>返回值：返回请求报文的长度</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct mg_http_message hm;</span><br><span class="line">const char *buf = &quot;GET / HTTP/1.0\n\n&quot;;</span><br><span class="line">if (mg_http_parse(buf, strlen(buf), &amp;hm) &gt; 0) &#123; /* success */ &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-printf-chunk"><a href="#mg-http-printf-chunk" class="headerlink" title="mg_http_printf_chunk()"></a><code>mg_http_printf_chunk()</code></h4><ul>
<li><code>void mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...);</code></li>
<li>使用<code>printf()</code>语义，写一个块编码的块数据。(Write a chunk of data in chunked encoding format, using printf() semantic)</li>
<li>参数：<ul>
<li><code>c</code>    –  一个连接指针</li>
<li><code>fmt</code>  –  以<code>printf()</code>语义的字符串</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例<ul>
<li><code>mg_http_printf_chunk(c, &quot;Hello, %s!&quot;, &quot;world&quot;);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-http-write-chunk"><a href="#mg-http-write-chunk" class="headerlink" title="mg_http_write_chunk()"></a><code>mg_http_write_chunk()</code></h4><ul>
<li><code>void mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len);</code></li>
<li>写入一个块编码格式的块数据(Write a chunk of data in chunked encoding format.)</li>
<li>参数：<ul>
<li><code>c</code>   –  一个连接指针</li>
<li><code>buf</code> –  需要写入的数据</li>
<li><code>len</code> –  写入数据的长度</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<ul>
<li><code>mg_http_write_chunk(c, &quot;hi&quot;, 2);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-http-delete-chunk"><a href="#mg-http-delete-chunk" class="headerlink" title="mg_http_delete_chunk()"></a><code>mg_http_delete_chunk()</code></h4><ul>
<li><code>void mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm);</code></li>
<li>从输入缓冲区中删除指定的块(chunk)</li>
<li>参数：<ul>
<li><code>c</code>  –  连接指针</li>
<li><code>hm</code> –  需要删除的块(chunk)</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_CHUNK) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    mg_http_delete_chunk(c, hm); // Remove received chunk</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="struct-mg-http-serve-opts"><a href="#struct-mg-http-serve-opts" class="headerlink" title="struct mg_http_serve_opts"></a><code>struct mg_http_serve_opts</code></h4><ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct mg_http_serve_opts &#123;</span><br><span class="line">  const char *root_dir;       // Web root directory, must be non-NULL</span><br><span class="line">  const char *ssi_pattern;    // SSI file name pattern, e.g. #.shtml</span><br><span class="line">  const char *extra_headers;  // Extra HTTP headers to add in responses</span><br><span class="line">  const char *mime_types;     // Extra mime types, ext1=type1,ext2=type2,..</span><br><span class="line">  const char *page404;        // Path to the 404 page, or NULL by default</span><br><span class="line">  struct mg_fs *fs;           // Filesystem implementation. Use NULL for POSIX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>传递给<code>mg_http_serve_dir()</code>和<code>mg_http_serve_file()</code>的结构，该结构驱动了这两个函数的行为</li>
</ul>
<h4 id="mg-http-serve-dir"><a href="#mg-http-serve-dir" class="headerlink" title="mg_http_serve_dir()"></a><code>mg_http_serve_dir()</code></h4><ul>
<li><code>void mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm, const struct mg_http_serve_opts *opts);</code></li>
<li>根据给定选项服务多个静态文件。文件也可以被压缩,包括目录索引。所有压缩文件都必须以.gz结尾，并且不得在没有扩展名的情况下存在具有相同名称的文件，否则将优先考虑</li>
<li>注意：<ul>
<li>为了启动SSI，需要设置<code>-DMSG_ENABLE_SSI=1</code>构件标志</li>
<li>在<code>root_dir</code>中为了避免双点<code>..</code>，如果需要引用高级目录，则需要使用绝对路径</li>
</ul>
</li>
<li>参数：<ul>
<li><code>c</code>     –  使用的连接</li>
<li><code>hm</code>    –  应该被服务的HTTP消息</li>
<li><code>opts</code>  –  服务选项。请注意，<code>opts.root_dir</code>可以选择接受额外的逗号分隔<code>uri=path</code></li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    struct mg_http_serve_opts opts;</span><br><span class="line">    memset(&amp;opts, 0, sizeof(opts));</span><br><span class="line">    opts.root_dir = &quot;/var/www,/conf=/etc&quot;;  // Serve /var/www. URIs starting with /conf are served from /etc</span><br><span class="line">    mg_http_serve_dir(c, hm, &amp;opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-serve-file"><a href="#mg-http-serve-file" class="headerlink" title="mg_http_serve_file()"></a><code>mg_http_serve_file()</code></h4><ul>
<li><code>void mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm, const char *path, struct mg_http_serve_opts *opts);</code></li>
<li>服务一个静态文件。如果不存在带有路径中指定的文件名的文件，则Mongoose尝试附加<code>.gz</code>；如果存在这样的文件，它将使用<code>Content-Encoding: gzip</code> header 去服务</li>
<li>注意：<ul>
<li><code>opts-&gt;root_dir</code>设置被这个函数忽略</li>
<li><code>opts-&gt;extra_headers</code> 必须以<code>\r\n</code>结束</li>
</ul>
</li>
<li>参数：<ul>
<li><code>c</code>     –  使用的连接</li>
<li><code>hm</code>    –  需要服务的HTTP消息</li>
<li><code>path</code>  –  需要服务的文件路径</li>
<li><code>opts</code>  –  服务选项</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    struct mg_http_serve_opts opts = &#123;</span><br><span class="line">      .mime_types = &quot;png=image/png&quot;,</span><br><span class="line">      .extra_headers = &quot;AA: bb\r\nCC: dd\r\n&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    mg_http_serve_file(c, hm, &quot;a.png&quot;, &amp;opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-reply"><a href="#mg-http-reply" class="headerlink" title="mg_http_reply()"></a><code>mg_http_reply()</code></h4><ul>
<li><code>void mg_http_reply(struct mg_connection *c, int status_code, const char *headers, const char *body_fmt, ...);</code></li>
<li>通过使用<code>printf()</code>语义发送简单的HTTP响应。这个函数根据<code>body_fmt</code>格式化响应体(response body)，然后自动追加到一个正确的<code>Content-Length</code>头(header)。额外的<code>headers</code>需要通过<code>headers</code>参数传递</li>
<li>参数：<ul>
<li><code>c</code>     –  使用的连接</li>
<li><code>status_code</code>  –  一个HTTP响应状态码</li>
<li><code>headers</code>      –  额外的headers，默认为NULL，如果不是空，则必须以<code>\r\n</code>结尾</li>
<li><code>fmt</code>    –  使用<code>printf</code>语义，需要格式化成HTTP body的字符串</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<ul>
<li>发送一个简单的JSON响应：<ul>
<li><code>mg_http_reply(c, 200, &quot;Content-Type: application/json\r\n&quot;, &quot;&#123;\&quot;result\&quot;: %d&#125;&quot;, 123);</code></li>
</ul>
</li>
<li>发送一个302重定向：<ul>
<li><code>mg_http_reply(c, 302, &quot;Location: /\r\n&quot;, &quot;&quot;);</code></li>
</ul>
</li>
<li>发送一个错误<ul>
<li><code>mg_http_reply(c, 403, &quot;&quot;, &quot;%s&quot;, &quot;Not Authorized\n&quot;);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="mg-http-get-header"><a href="#mg-http-get-header" class="headerlink" title="mg_http_get_header()"></a><code>mg_http_get_header()</code></h4><ul>
<li><code>struct mg_str *mg_http_get_header(struct mg_http_message *hm, const char *name);</code></li>
<li>获取HTTP header值</li>
<li>参数：<ul>
<li><code>hm</code>    –  需要寻找 header 的HTTP消息</li>
<li><code>name</code>  –  Header name</li>
</ul>
</li>
<li>返回值：HTTP header 值 或 NULL表示没有找到</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose event handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    struct mg_str *s = mg_http_get_header(hm, &quot;X-Extra-Header&quot;);</span><br><span class="line">    if (s != NULL) &#123;</span><br><span class="line">      mg_http_reply(c, 200, &quot;&quot;, &quot;Holly molly! Header value: %.*s&quot;, (int) s-&gt;len, s-&gt;ptr);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      mg_http_reply(c, 200, &quot;&quot;, &quot;Oh no, header is not set...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-get-header-var"><a href="#mg-http-get-header-var" class="headerlink" title="mg_http_get_header_var()"></a><code>mg_http_get_header_var()</code></h4><ul>
<li><code>struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v);</code></li>
<li>解析具有表格<code>name1=value1; name=value2;...</code>的HTTP header，并获取一个给定的变量</li>
<li>参数：<ul>
<li><code>s</code>  –  HTTP header</li>
<li><code>name</code>  –  变量名字的名字</li>
</ul>
</li>
<li>返回值：一个请求的变量 或 一个空的字符串</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str *cookie = mg_http_get_header(hm, &quot;Cookie&quot;);</span><br><span class="line">struct mg_str token = mg_str(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">if (cookie != NULL) &#123;</span><br><span class="line">  token = mg_http_get_header_var(*cookie, mg_str(&quot;access_token&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-var"><a href="#mg-http-var" class="headerlink" title="mg_http_var()"></a><code>mg_http_var()</code></h4><ul>
<li><code>struct mg_str mg_http_var(struct mg_str buf, struct mg_str name);</code></li>
<li>获取未编码的HTTP变量</li>
<li>参数：<ul>
<li><code>buf</code>  –  一个url编码的字符串：HTTP请求体或查询字符串(HTTP request body or query string)</li>
<li><code>name</code> –  获取的变量名字</li>
</ul>
</li>
<li>返回值：返回变量的值 或 返回一个空的字符串，表示没有找到</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// We have received a request to /my/uri?a=b&amp;c=d%20</span><br><span class="line">// The hm-&gt;query points to &quot;a=b&amp;c=d%20&quot;</span><br><span class="line">struct mg_str v = mg_http_var(hm-&gt;query, mg_str(&quot;c&quot;));  // v = &quot;d%20&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-get-var"><a href="#mg-http-get-var" class="headerlink" title="mg_http_get_var()"></a><code>mg_http_get_var()</code></h4><ul>
<li><code>int mg_http_get_var(const struct mg_str *var, const char *name, char *buf, int len);</code></li>
<li>获取并解码HTTP 变量</li>
<li>参数：<ul>
<li><code>var</code>    –  HTTP请求体(HTTP request body)</li>
<li><code>name</code>   –  变量名</li>
<li><code>buf</code>    –  写入解码变量的缓冲区(Buffer to write decoded variable)</li>
<li><code>len</code>    –  缓冲区大小</li>
</ul>
</li>
<li>返回值：解码变量的长度 或 0，负数表示错误</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buf[100] = &quot;&quot;;</span><br><span class="line">mg_http_get_var(&amp;hm-&gt;body, &quot;key1&quot;, buf, sizeof(buf)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-creds"><a href="#mg-http-creds" class="headerlink" title="mg_http_creds()"></a><code>mg_http_creds()</code></h4><ul>
<li><code>void mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen, char *pass, size_t passlen);</code></li>
<li>从请求获取身份验证证书，然后将它存储到<code>user</code>, <code>userlen</code>, <code>pass</code>, <code>passlen</code>缓冲区中。</li>
<li>证书按以下顺序查找<ul>
<li>从HTTP header中的<code>Authorization</code>中：<ul>
<li>基本身份(Basic auth) ，填充到<code>user</code> 和 <code>pass</code></li>
<li>持票人身份(Bearer auth)，仅填充到<code>pass</code></li>
</ul>
</li>
<li>从 cookie 的<code>access_token</code>中，填充<code>pass</code></li>
<li>从搜索字符串参数的<code>?access_token=...</code>，填充<code>pass</code></li>
</ul>
</li>
<li>如果都没有，<code>user</code>和<code>pass</code>都被设置为以NULL结尾的字符串</li>
<li>参数：<ul>
<li><code>hm</code>    –  需要查找证书的HTTP 消息</li>
<li><code>user</code>  –  接收用户名字的缓冲区</li>
<li><code>userlen</code>  –  user缓冲区的大小</li>
<li><code>pass</code>  –  接收密码的缓冲区</li>
<li><code>passlen</code>  –  pass缓冲区的大小</li>
</ul>
</li>
<li>返回值：空</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    char user[100], pass[100];</span><br><span class="line">    mg_http_creds(hm, user, sizeof(user), pass, sizeof(pass)); // &quot;user&quot; is now user name and &quot;pass&quot; is now password from request</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-match-uri"><a href="#mg-http-match-uri" class="headerlink" title="mg_http_match_uri()"></a><code>mg_http_match_uri()</code></h4><ul>
<li><code>bool mg_http_match_uri(const struct mg_http_message *hm, const char *glob);</code></li>
<li>检查在HTTP请求报文中，是否有和给定的<code>glob</code>字符串相匹配的字符串</li>
<li>参数：<ul>
<li><code>hm</code>    –  需要匹配检索的HTTP消息</li>
<li><code>glob</code>  –  匹配的字符串</li>
</ul>
</li>
<li>返回值：如果在HTTP请求报文中找到了匹配的字符串，返回 True 或者 返回 False表示未匹配到</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    if (mg_http_match_uri(hm, &quot;/secret&quot;)) &#123;</span><br><span class="line">      mg_http_reply(c, 200, NULL, &quot;Very big secret!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      mg_http_reply(c, 200, NULL, &quot;hello world..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-bauth"><a href="#mg-http-bauth" class="headerlink" title="mg_http_bauth()"></a><code>mg_http_bauth()</code></h4><ul>
<li><code>void mg_http_bauth(struct mg_connection *c, const char *user, const char *pass);</code></li>
<li>将一个基本的<code>Authorization</code> header写入到输出缓冲区</li>
<li>参数：<ul>
<li><code>c</code>    –  使用的连接</li>
<li><code>user</code> –  用户名</li>
<li><code>pass</code> –  密码</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：使用基本验证来创建Stripe订阅的用法示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mg_printf(c, &quot;POST /v1/subscriptions HTTP/1.1\r\n&quot;</span><br><span class="line">             &quot;Host: api.stripe.com\r\n&quot;</span><br><span class="line">             &quot;Transfer-Encoding: chunked\r\n&quot;);</span><br><span class="line">mg_http_bauth(c, stripe_private_key, NULL);     // Add Basic auth header</span><br><span class="line">mg_printf(c, &quot;%s&quot;, &quot;\r\n&quot;);                     // End HTTP headers</span><br><span class="line"></span><br><span class="line">mg_http_printf_chunk(c, &quot;&amp;customer=%s&quot;, customer_id);   // Set customer</span><br><span class="line">mg_http_printf_chunk(c, &quot;&amp;items[0][price]=%s&quot;, price);  // And price</span><br><span class="line">mg_http_printf_chunk(c, &quot;&quot;);                            // End request</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="struct-mg-http-part"><a href="#struct-mg-http-part" class="headerlink" title="struct mg_http_part"></a><code>struct mg_http_part</code></h4><ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Parameter for mg_http_next_multipart</span><br><span class="line">struct mg_http_part &#123;</span><br><span class="line">  struct mg_str name;      // Form field name</span><br><span class="line">  struct mg_str filename;  // Filename for file uploads</span><br><span class="line">  struct mg_str body;      // Part contents</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>描述HTTP 多个消息(multipart message)中单个部分的结构体</li>
</ul>
<h4 id="mg-http-next-multipart"><a href="#mg-http-next-multipart" class="headerlink" title="mg_http_next_multipart()"></a><code>mg_http_next_multipart()</code></h4><ul>
<li><code>size_t mg_http_next_multipart(struct mg_str body, size_t offset, struct mg_http_part *part);</code></li>
<li>根据给定的<code>offset</code>，在<code>body</code>中解析multipart chunk。一个初始的<code>offset</code>应该为0.在提供的<code>part</code>中填充参数，可能为空。返回下一块的offsete，或者返回0表示没有其他块(chunks)</li>
<li>参数：<ul>
<li><code>body</code>  –  消息体(message body)</li>
<li><code>offset</code>  –  开始偏移量(start offset)</li>
<li><code>part</code>  –  指向需要填充的<code>struct mg_http_part</code>结构体</li>
</ul>
</li>
<li>返回值：返回下一块的offsete，或者返回0表示没有其他块(chunks)</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct mg_http_part part;</span><br><span class="line">size_t pos = 0;</span><br><span class="line"></span><br><span class="line">while ((pos = mg_http_next_multipart(body, pos, &amp;part)) != 0) &#123;</span><br><span class="line">  // Use part</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-http-upload"><a href="#mg-http-upload" class="headerlink" title="mg_http_upload()"></a><code>mg_http_upload()</code></h4><ul>
<li><code>int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm, struct mg_fs *fs, const char *path, size_t max_size);</code></li>
<li>这是一个助手实用程序功能，用于通过小块上传大型文件。将HTTP POST 数据追加到指定目录的文件中。文件名和文件偏移由查询字符串参数指定:<code>POST /upload?name=firmware.bin&amp;offset=2048 HTTP/1.1</code>。如果偏移量为0，则将文件截断。客户的责任是将文件分为较小的块，并发送一系列由此功能处理的POST请求</li>
<li>参数：<ul>
<li><code>c</code>    –  一个连接</li>
<li><code>hm</code>   –  一个需要被解析的HTTP message</li>
<li><code>fs</code>   –  需要写文件的文件系统，例如：<code>&amp;mg_fs_posix</code></li>
<li><code>path</code> –  一个文件名</li>
<li><code>max_size</code>  –  允许的文件大小的最大值</li>
</ul>
</li>
<li>返回值：写完后，返回文件的大小  或者 返回一个负数表示错误</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    if (mg_http_match_uri(hm, &quot;/upload&quot;)) &#123;</span><br><span class="line">      mg_http_upload(c, hm, &amp;mg_fs_posix, &quot;/tmp/myfile.bin&quot;, 99999);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      struct mg_http_serve_opts opts = &#123;.root_dir = &quot;.&quot;&#125;;   // Serve</span><br><span class="line">      mg_http_serve_dir(c, ev_data, &amp;opts);                 // static content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-4-WebSocket-API"><a href="#1-4-WebSocket-API" class="headerlink" title="1.4 WebSocket API"></a>1.4 WebSocket API</h3><h4 id="struct-mg-ws-message"><a href="#struct-mg-ws-message" class="headerlink" title="struct mg_ws_message"></a><code>struct mg_ws_message</code></h4><ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_ws_message &#123;</span><br><span class="line">  struct mg_str data; // WebSocket message data</span><br><span class="line">  uint8_t flags;      // WebSocket message flags</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>该结构代表Websocket消息。这个<code>flag</code>元素对应于<code>RFC 6455</code>第5.2节中所述的第一个字节。(<code>https://www.rfc-editor.org/rfc/rfc6455#section-5.2</code>)</li>
</ul>
<h4 id="WebSockete-message-type"><a href="#WebSockete-message-type" class="headerlink" title="WebSockete message type:"></a>WebSockete message type:</h4><ul>
<li>要从传入消息中提取消息类型，在结构体<code>mg_ws_message</code>的<code>flag</code>元素中检查四个<code>LSBs</code></li>
<li>可能存在的WebSocket消息类型：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define WEBSOCKET_OP_CONTINUE 0</span><br><span class="line">#define WEBSOCKET_OP_TEXT 1</span><br><span class="line">#define WEBSOCKET_OP_BINARY 2</span><br><span class="line">#define WEBSOCKET_OP_CLOSE 8</span><br><span class="line">#define WEBSOCKET_OP_PING 9</span><br><span class="line">#define WEBSOCKET_OP_PONG 10</span><br></pre></td></tr></table></figure></li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_WS_MSG) &#123;</span><br><span class="line">    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;</span><br><span class="line">    msgtype = wm-&gt;flags &amp; 0x0F;</span><br><span class="line">    if (msgtype == WEBSOCKET_OP_BINARY) &#123;</span><br><span class="line">      // This is a binary data message</span><br><span class="line">    &#125; else if (msgtype == WEBSOCKET_OP_TEXT) &#123;</span><br><span class="line">      // This is a text data message</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当调用<code>mg_ws_send()</code>或<code>ms_ws_printf()</code>发送消息时，请使用<code>RFC 6455</code>第5.6节中所述的正确消息类型进行数据帧(<code>https://www.rfc-editor.org/rfc/rfc6455#section-5.6</code>)</li>
</ul>
<h4 id="mg-ws-connect"><a href="#mg-ws-connect" class="headerlink" title="mg_ws_connect()"></a><code>mg_ws_connect()</code></h4><ul>
<li><code>struct mg_connection *mg_ws_connect(struct mg_mgr *mgr, const char *url, mg_event_handler_t fn, void *fn_data, const char *fmt, ...);</code></li>
<li>创建客户端Websocket连接。这个函数不能连接到对端，它仅仅分配需要的资源和启动连接进程。当对端真正连接好了，会向连接事件处理函数发送一个<code>MG_EV_CONNECT</code>事件</li>
<li>参数：<ul>
<li><code>mgr</code>  –  使用的事件管理结构体</li>
<li><code>url</code>  –  指定的远程URL。例如：<code>http://google.com</code></li>
<li><code>fn</code>   –  一个事件处理函数</li>
<li><code>fn_data</code>  –  一个任意指针，当事件处理函数被调用时，它会被作为<code>fn_data</code>传递。这个指针作为<code>c-&gt;fn_data</code>存储在连接结构体中</li>
</ul>
</li>
<li>返回值：返回一个指向创建的连接； 返回NULL表示错误</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct mg_connection *c = mg_ws_connect(&amp;mgr, &quot;ws://test_ws_server.com:1000&quot;,</span><br><span class="line">                                        handler, NULL, &quot;%s&quot;, &quot;Sec-WebSocket-Protocol: echo\r\n&quot;);</span><br><span class="line">if(c == NULL) fatal(&quot;Cannot create connection&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-ws-upgrade"><a href="#mg-ws-upgrade" class="headerlink" title="mg_ws_upgrade()"></a><code>mg_ws_upgrade()</code></h4><ul>
<li><code>void mg_ws_upgrade(struct mg_connection *c, struct mg_http_message *, const char *fmt, ...);</code></li>
<li>升级给定HTTP连接到Websocket。<code>fmt</code>是一个类似于<code>printf()</code>格式的字符串，用于额外的HTTP标头，返回给Websocket握手的客户端。如果不需要额外的标头，将<code>fmt</code>设置为空。</li>
<li>参数：<ul>
<li><code>c</code>    –  使用的连接</li>
<li><code>hm</code>   –  HTTP消息</li>
<li><code>fmt</code>  –  类似于<code>printf</code>的格式字符串，用于附加<code>HTTP</code>标头或为null</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_HTTP_MSG) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    mg_ws_upgrade(c, hm, NULL);  // Upgrade HTTP to WS</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-ws-send"><a href="#mg-ws-send" class="headerlink" title="mg_ws_send()"></a><code>mg_ws_send()</code></h4><ul>
<li><code>size_t mg_ws_send(struct mg_connection *c, const void *buf, size_t len, int op);</code></li>
<li>向WebSocket对端发送数据</li>
<li>参数：<ul>
<li><code>c</code>  –  使用的连接</li>
<li><code>buf</code>  –  需要发送的数据</li>
<li><code>len</code>  –  需要发送的数据大小</li>
<li><code>op</code>   –  WebSocket消息类型，参见WebSocket message type</li>
</ul>
</li>
<li>返回值：返回发送的字节数</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Mongoose events handler</span><br><span class="line">void fn(struct mg_connection *c, int ev, void *ev_data, void *fn_data) &#123;</span><br><span class="line">  if (ev == MG_EV_WS_OPEN) &#123;</span><br><span class="line">    struct mg_http_message *hm = (struct mg_http_message *) ev_data;</span><br><span class="line">    mg_ws_send(c, &quot;opened&quot;, 6, WEBSOCKET_OP_BINARY);  // Send &quot;opened&quot; to web socket connection</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-ws-printf-mg-ws-vprintf"><a href="#mg-ws-printf-mg-ws-vprintf" class="headerlink" title="mg_ws_printf(), mg_ws_vprintf()"></a><code>mg_ws_printf(), mg_ws_vprintf()</code></h4><ul>
<li><code>size_t mg_ws_printf(struct mg_connection *, int op, const char *fmt, ...);</code></li>
<li><code>size_t mg_ws_vprintf(struct mg_connection *, int op, const char *fmt, va_list *);</code></li>
<li>和<code>ms_ws_send()</code>相同，但是使用<code>printf()</code>语义格式化数据</li>
<li>参数：<ul>
<li><code>c</code>   –  使用的连接</li>
<li><code>op</code>  –  WebSocket消息类型，参见WebSocket message type</li>
<li><code>fmt</code> –  使用<code>printf()</code>语义格式化的字符串</li>
</ul>
</li>
<li>返回值：返回发送的字节数</li>
<li>示例<ul>
<li><code>mg_ws_printf(c, WEBSOCKET_OP_TEXT, &quot;Hello, %s!&quot;, &quot;world&quot;);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-ws-wrap"><a href="#mg-ws-wrap" class="headerlink" title="mg_ws_wrap()"></a><code>mg_ws_wrap()</code></h4><ul>
<li><code>size_t mg_ws_wrap(struct mg_connection *c, size_t len, int op)</code></li>
<li>将输出缓冲区中的数据转换为Websocket格式。有用然后通过WebSocket实施协议。具体示例参见<code>examples/mqtt-over-ws-client</code></li>
<li>参数：<ul>
<li><code>c</code>  –  使用的连接</li>
<li><code>len</code>  –  转换的字节数</li>
<li><code>op</code>   –  WebSocket消息类型</li>
</ul>
</li>
<li>返回值：返回连接结构体中输出缓冲区新的大小</li>
<li>示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size_t len = c-&gt;send.len;         // Store output buffer len</span><br><span class="line">mg_mqtt_login(c, s_url, &amp;opts);   // Write MQTT login message</span><br><span class="line">mg_ws_wrap(c, c-&gt;send.len - len, WEBSOCKET_OP_BINARY); // Wrap it into WS</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-5-Timer-API"><a href="#1-5-Timer-API" class="headerlink" title="1.5 Timer API"></a>1.5 Timer API</h3><h4 id="mg-timer-add"><a href="#mg-timer-add" class="headerlink" title="mg_timer_add()"></a><code>mg_timer_add()</code></h4><ul>
<li><code>struct mg_timer *mg_timer_add(struct mg_mgr *mgr, uint64_t period_ms, unsigned flags, void (*fn)(void *), void *fn_data);</code></li>
<li>设置一个计时器。这是一个高级计时器API，允许将软件计时器添加到活动管理器。这个函数使用<code>calloc()</code>一个新的计时器，并将它添加到<code>mgr-&gt;timers</code>列表中。当调用<code>mg_mgr_poll()</code>时，所有添加的计时器均进行轮询，并在计时器到期时调用计时器设定的函数</li>
<li>注意：<ul>
<li>确保计时器的间隔等于或大于<code>mg_mgr_poll()</code>的超时时间</li>
</ul>
</li>
<li>参数：<ul>
<li><code>mgr</code>   –  指向事件管理器的结构体指针</li>
<li><code>ms</code>    –  一个时间间隔，以毫秒为单位</li>
<li><code>flags</code> –  计时器标志掩码：<code>MG_TIMER_REPEAT</code>和<code>MG_TIMER_RUN_NOW</code></li>
<li><code>fn</code>    –  函数调用</li>
<li><code>fn_data</code>  –  调用的函数参数</li>
</ul>
</li>
<li>返回值：返回一个指向创建的计时器的指针</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void timer_fn(void *data) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mg_timer_add(mgr, 1000, MG_TIMER_REPEAT, timer_fn, NULL);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="struct-mg-timer"><a href="#struct-mg-timer" class="headerlink" title="struct mg_timer"></a><code>struct mg_timer</code></h4><ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct mg_timer &#123;</span><br><span class="line">  uint64_t period_ms;       // Timer period in milliseconds</span><br><span class="line">  uint64_t expire;          // Expiration timestamp in milliseconds</span><br><span class="line">  unsigned flags;           // Possible flags values below</span><br><span class="line">#define MG_TIMER_ONCE 0     // Call function once</span><br><span class="line">#define MG_TIMER_REPEAT 1   // Call function periodically</span><br><span class="line">#define MG_TIMER_RUN_NOW 2  // Call immediately when timer is set</span><br><span class="line">  void (*fn)(void *);       // Function to call</span><br><span class="line">  void *arg;                // Function argument</span><br><span class="line">  struct mg_timer *next;    // Linkage</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>计时器结构体。描述一个软件计时器。计时器粒度与主事件循环中的<code>mg_mgr_poll()</code>的超时参数相同</li>
</ul>
<h4 id="mg-timer-init"><a href="#mg-timer-init" class="headerlink" title="mg_timer_init()"></a><code>mg_timer_init()</code></h4><ul>
<li><code>void mg_timer_init(struct mg_timer **head, struct mg_timer *t, uint64_t period_ms, unsigned flags, void (*fn)(void *), void *fn_data);</code></li>
<li>设置一个计时器</li>
<li>参数：<ul>
<li><code>head</code>    –  指向<code>mg_timer</code>队列头部的指针</li>
<li><code>t</code>       –  指向一个需要被初始化的<code>mg_timer</code></li>
<li><code>ms</code>      –  时间间隔，以毫秒为单位</li>
<li><code>flags</code>   –  计时器标志掩码：<code>MG_TIMER_REPEAT</code>和<code>MG_TIMER_RUN_NOW</code></li>
<li><code>fn</code>    –  函数调用</li>
<li><code>fn_data</code>  –  调用的函数参数</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void timer_fn(void *data) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct mg_timer timer, *head = NULL;</span><br><span class="line">mg_timer_init(&amp;head, &amp;timer, 1000, MG_TIMER_REPEAT, timer_fn, NULL);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-timer-free"><a href="#mg-timer-free" class="headerlink" title="mg_timer_free()"></a><code>mg_timer_free()</code></h4><ul>
<li><code>void mg_timer_free(struct mg_timer **head, struct mg_timer *t);</code></li>
<li>释放计时器，将其从内部计时器列表中删除。</li>
<li>参数：<ul>
<li><code>head</code>  –  指向<code>mg_timer</code>队列头部的指针</li>
<li><code>t</code>     –  需要释放的计时器</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct mg_timer timer;</span><br><span class="line">// ...</span><br><span class="line">mg_timer_free(&amp;timer);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-timer-poll"><a href="#mg-timer-poll" class="headerlink" title="mg_timer_poll()"></a><code>mg_timer_poll()</code></h4><ul>
<li><code>void mg_timer_poll(struct mg_timer **head, uint64_t uptime_ms);</code></li>
<li>如果当前的时间戳<code>uptime_ms</code>超过了计时器的到期时间，则计时器遍历列表，并调用它们</li>
<li>参数：<ul>
<li><code>head</code>   –  指向<code>mg_timer</code>列表头部的指针</li>
<li><code>uptime_ms</code>  –  当前时间戳</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例<ul>
<li><code>mg_timer_poll(mg_millis());</code></li>
</ul>
</li>
</ul>
<h3 id="1-6-Time"><a href="#1-6-Time" class="headerlink" title="1.6 Time"></a>1.6 Time</h3><h4 id="mg-millis"><a href="#mg-millis" class="headerlink" title="mg_millis()"></a><code>mg_millis()</code></h4><ul>
<li><code>int64_t mg_millis(void);</code></li>
<li>以毫秒返回当前的正常运行时间。</li>
<li>参数：无</li>
<li>返回值：当前时间戳</li>
<li>示例：<ul>
<li><code>int64_t uptime = mg_millis();</code></li>
</ul>
</li>
</ul>
<h3 id="1-7-String"><a href="#1-7-String" class="headerlink" title="1.7 String"></a>1.7 String</h3><h4 id="struct-mg-str"><a href="#struct-mg-str" class="headerlink" title="struct mg_str"></a><code>struct mg_str</code></h4><ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str &#123;</span><br><span class="line">  const char *ptr;  // Pointer to string data</span><br><span class="line">  size_t len;       // String len</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>该结构代表了任意内存的一部分，并不一定是<code>zero-terminated</code>。这是一个<code>mongoose string</code>，它在代码库中广泛使用，而不是C zero-terminated strings</li>
<li>例如<ul>
<li>当一个HTTP request到达时，Mongoose创建了一个<code>mg_http_message</code>结构体，该结构体包含一个指向请求方法，URI，头部等<code>struct mg_str</code>结构体集合。这样，Mongoose避免了任何堆申请，并且不会修改接收的缓冲区。相反，它使用<code>struct mg_str</code>来描述HTTP请求的各个部分</li>
<li>许多其他情况也是如此。</li>
</ul>
</li>
<li>注意：<ul>
<li>由于<code>ptr</code>不一定是<code>zero-terminated</code>，因此请勿使用libc字符串函数，例如：<code>strlen()</code>或<code>sscanf()</code></li>
</ul>
</li>
</ul>
<h4 id="mg-str"><a href="#mg-str" class="headerlink" title="mg_str()"></a><code>mg_str()</code></h4><ul>
<li><code>struct mg_str mg_str(const char *s)</code></li>
<li>从<code>NULL-terminated C-string</code>创建一个Mongoose字符串。这个函数不重复提供字符串，并且将指针存储在创建的<code>mg_str</code>结构中</li>
<li>注意：<ul>
<li>在C++(构造函数)中存在此问题，这个功能有同义词<code>mg_str_s</code></li>
</ul>
</li>
<li>参数：<ul>
<li><code>s</code>  –  一个指向需要存储到<code>mg_str</code>结构中的<code>NULL-terminated string</code></li>
</ul>
</li>
<li>返回值：创建的Mongoose string</li>
<li>示例：  <ul>
<li><code>struct mg_str str = mg_str(&quot;Hello, world!);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-str-n"><a href="#mg-str-n" class="headerlink" title="mg_str_n()"></a><code>mg_str_n()</code></h4><ul>
<li><code>struct mg_str mg_str_n(const char *s, size_t n);</code></li>
<li>从C-string（可以是<code>non-NULL terminated</code>，长度由<code>n</code>指定）创建Mongoose string。这个函数不重复提供字符串，并且将指针存储在创建的<code>mg_str</code>结构中</li>
<li>参数：<ul>
<li><code>s</code>  –  指向需要存储到创建的<code>mg_str</code>的字符串</li>
<li><code>n</code>  –  字符串长度</li>
</ul>
</li>
<li>返回值：创建的Mongoose string</li>
<li>示例：<ul>
<li><code>struct mg_str str = mg_str_n(&quot;hi&quot;, 2);</code></li>
</ul>
</li>
</ul>
<h4 id="mg-casecmp"><a href="#mg-casecmp" class="headerlink" title="mg_casecmp()"></a><code>mg_casecmp()</code></h4><ul>
<li><code>int mg_casecmp(const char *s1, const char *s2);</code></li>
<li>不区分大小写的，比较两个 NULL-terminated strings</li>
<li>参数：<ul>
<li><code>s1</code>, <code>s2</code>  –  指向两个需要比较的字符串的指针</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果两个字符串相等，则返回0</li>
<li>如果第一个参数比第二个参数长，则返回大于0的数</li>
<li>如果第一个参数比第二个参数短，则返回小于0的数</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (mg_casecmp(&quot;hello&quot;, &quot;HELLO&quot;) == 0) &#123;</span><br><span class="line">  // Strings are equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-ncasecmp"><a href="#mg-ncasecmp" class="headerlink" title="mg_ncasecmp()"></a><code>mg_ncasecmp()</code></h4><ul>
<li><code>int mg_ncasecmp(const char *s1, const char *s2, size_t len);</code></li>
<li>不区分大小写的比较两个C-strings的前<code>len</code>个字符，或者遇到<code>\0</code>字符</li>
<li>参数：<ul>
<li><code>s1</code>, <code>s2</code>  –  指向需要比较的两个字符串</li>
<li><code>len</code>   –  比较的最大长度</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果两个字符串相等，则返回0</li>
<li>如果第一个参数比第二个参数长，则返回大于0的数</li>
<li>如果第一个参数比第二个参数短，则返回小于0的数</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (mg_ncasecmp(&quot;hello1&quot;, &quot;HELLO2&quot;, 5) == 0) &#123;</span><br><span class="line">  // Strings are equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-vcmp"><a href="#mg-vcmp" class="headerlink" title="mg_vcmp()"></a><code>mg_vcmp()</code></h4><ul>
<li><code>int mg_vcmp(const struct mg_str *s1, const char *s2);</code></li>
<li>比较 mongoose string 和 C-string</li>
<li>参数：<ul>
<li><code>s1</code>  –  指向需要比较的 mongoose string</li>
<li><code>s2</code>  –  指向需要比较的 C-string</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果两个字符串相等，则返回0</li>
<li>如果第一个参数比第二个参数长，则返回大于0的数</li>
<li>如果第一个参数比第二个参数短，则返回小于0的数</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str str = mg_str(&quot;hello&quot;);</span><br><span class="line">if (mg_vcmp(str, &quot;hello&quot;) == 0) &#123;</span><br><span class="line">  // Strings are equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-vcasecmp"><a href="#mg-vcasecmp" class="headerlink" title="mg_vcasecmp()"></a><code>mg_vcasecmp()</code></h4><ul>
<li><code>int mg_vcasecmp(const struct mg_str *str1, const char *str2);</code></li>
<li>不区分大小的比较 mongoose string 和 C-string</li>
<li>参数：<ul>
<li><code>s1</code>  –  指向需要比较的 mongoose string</li>
<li><code>s2</code>  –  指向需要比较的 C-string</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果两个字符串相等，则返回0</li>
<li>如果第一个参数比第二个参数长，则返回大于0的数</li>
<li>如果第一个参数比第二个参数短，则返回小于0的数</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str str = mg_str(&quot;hello&quot;);</span><br><span class="line">if (mg_vcasecmp(str, &quot;HELLO&quot;) == 0) &#123;</span><br><span class="line">  // Strings are equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-strcmp"><a href="#mg-strcmp" class="headerlink" title="mg_strcmp()"></a><code>mg_strcmp()</code></h4><ul>
<li><code>int mg_strcmp(const struct mg_str str1, const struct mg_str str2);</code></li>
<li>比较两个 mongoose strings</li>
<li>参数：<ul>
<li><code>str1</code>, <code>str2</code>  –  指向两个需要比较的 mongoose strings</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果两个字符串相等，则返回0</li>
<li>如果第一个参数比第二个参数长，则返回大于0的数</li>
<li>如果第一个参数比第二个参数短，则返回小于0的数</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str str1 = mg_str(&quot;hello&quot;);</span><br><span class="line">struct mg_str str2 = mg_str(&quot;hello&quot;);</span><br><span class="line">if (mg_strcmp(str1, str2) == 0) &#123;</span><br><span class="line">  // Strings are equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-strdup"><a href="#mg-strdup" class="headerlink" title="mg_strdup()"></a><code>mg_strdup()</code></h4><ul>
<li><code>struct mg_str mg_strdup(const struct mg_str s);</code></li>
<li>重复提供的字符串。返回一个新的字符串或者<code>MG_NULL_STR</code>表示错误。</li>
<li>注意：<ul>
<li>这个函数为返回的字符串分配内存。需要使用<code>free()</code>函数释放</li>
</ul>
</li>
<li>参数：<ul>
<li><code>s</code>  –  需要重复的 mongoose string</li>
</ul>
</li>
<li>返回值：重复的字符串</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str str1 = mg_str(&quot;hello&quot;);</span><br><span class="line">struct mg_str str2 = mg_strdup(str1);</span><br><span class="line">//...</span><br><span class="line">free((void *)str2.ptr);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-strstr"><a href="#mg-strstr" class="headerlink" title="mg_strstr()"></a><code>mg_strstr()</code></h4><ul>
<li><code>const char *mg_strstr(const struct mg_str haystack, const struct mg_str needle)</code></li>
<li>在<code>haystack</code>字符串中查找<code>needle</code>子字符串</li>
<li>参数：<ul>
<li><code>haystack</code>  –  需要查找子字符串的 mongoose string</li>
<li><code>needle</code>    –  需要查找的 mongoose string</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回一个指向<code>neddle</code>在<code>haystack</code>中发生的位置的指针</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str str = mg_str(&quot;Hello, world&quot;);</span><br><span class="line">struct mg_str sub_str = mg_str(&quot;world&quot;);</span><br><span class="line"></span><br><span class="line">if (mg_strstr(str, sub_str) != NULL) &#123;</span><br><span class="line">  // Found</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-strstrip"><a href="#mg-strstrip" class="headerlink" title="mg_strstrip()"></a><code>mg_strstrip()</code></h4><ul>
<li><code>struct mg_str mg_strstrip(struct mg_str s)</code></li>
<li>删除 mongoose string <code>s</code>的头部和尾部的空格</li>
<li>参数：<ul>
<li><code>s</code>  –  需要修剪的 mongoose string</li>
</ul>
</li>
<li>返回值：输入的字符串</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str str = mg_strstrip(mg_str(&quot;   Hello, world   &quot;));</span><br><span class="line">if (mg_vcmp(str, &quot;Hello, world&quot;) == 0) &#123;</span><br><span class="line">  // Strings are equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-match"><a href="#mg-match" class="headerlink" title="mg_match()"></a><code>mg_match()</code></h4><ul>
<li><code>bool mg_match(struct mg_str str, struct mg_str pattern, struct mg_str *caps);</code></li>
<li>检查字符串<code>str</code>是否匹配<code>pattern</code>，可选地将通配符捕获到提供的数组<code>caps</code>中</li>
<li>注意：<ul>
<li>如果<code>caps</code>是非空的，那么<code>caps</code>数组的大小最小为<code>pattern</code>的长度加1.</li>
<li>最后的 cap 将会被初始化成一个空的字符串</li>
</ul>
</li>
<li>全局匹配规则：<ul>
<li><code>?</code>  –  匹配任何单个字符</li>
<li><code>*</code>  –  匹配0个或多个字符，除了<code>/</code></li>
<li><code>#</code>  –  匹配0个或多个字符</li>
<li>任何其他字符只匹配它自身</li>
</ul>
</li>
<li>参数：<ul>
<li><code>str</code>    –  需要匹配的字符串</li>
<li><code>patter</code> –  与之匹配的规则（模式）</li>
<li><code>caps</code>   –  通配符符号的可选捕获数组<code>?</code>, <code>*</code>, <code>#</code></li>
</ul>
</li>
<li>返回值：<ul>
<li>匹配成功，返回true</li>
<li>其他情况，返回false</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Assume that hm-&gt;uri holds /foo/bar. Then we can match the requested URI:</span><br><span class="line">struct mg_str caps[3];  // Two wildcard symbols &#x27;*&#x27; plus 1</span><br><span class="line">if (mg_match(hm-&gt;uri, mg_str(&quot;/*/*&quot;), caps)) &#123;</span><br><span class="line">  // caps[0] holds `foo`, caps[1] holds `bar`.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-commalist"><a href="#mg-commalist" class="headerlink" title="mg_commalist()"></a><code>mg_commalist()</code></h4><ul>
<li><code>bool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v);</code></li>
<li>解析字符串S，这是一个分隔的条目列表。条目可以是任意字符串，该字符串存储在<code>v</code>中，或者分别存储在<code>k</code>和<code>v</code>中的<code>KEY=VALUE</code></li>
<li>重要：<ul>
<li>此函数通过指向下一个条目来修改<code>s</code>。</li>
</ul>
</li>
<li>参数：<ul>
<li><code>s</code>  –  需要搜索条目的字符串</li>
<li><code>k</code>  –  一个指向<code>mg_str</code>的指针，接收条目键</li>
<li><code>v</code>  –  一个指向<code>mg_str</code>的指针，接收条目值</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果条目被找到，返回true</li>
<li>其他情况，返回false</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str k, v, s = mg_str(&quot;a=333,b=777&quot;);</span><br><span class="line">while (mg_commalist(&amp;s, &amp;k, &amp;v))                      // This loop output:</span><br><span class="line">  printf(&quot;[%.*s] set to [%.*s]\n&quot;,                    // [a] set to [333]</span><br><span class="line">         (int) k.len, k.ptr, (int) v.len, v.ptr);     // [b] set to [777]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-hex"><a href="#mg-hex" class="headerlink" title="mg_hex()"></a><code>mg_hex()</code></h4><ul>
<li><code>char *mg_hex(const void *buf, size_t len, char *dst);</code></li>
<li>十六进制编码的二进制数据<code>buf</code>，<code>len</code>输入到一个缓冲区<code>dst</code>，并将其终止。这个输出缓冲区至少比<code>2 x len + 1</code>大</li>
<li>参数：<ul>
<li><code>buf</code>  –  十六进制编码的数据</li>
<li><code>len</code>  –  数据长度</li>
<li><code>dst</code>  –  指向输出缓冲区的指针</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回<code>dst</code>指针。这个编码的字符是小写的</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char data[] = &quot;\x1\x2\x3&quot;;</span><br><span class="line">char buf[sizeof(data)*2];</span><br><span class="line">char *hex = mg_hex(data, sizeof(data) - 1, buf);</span><br><span class="line">LOG(LL_INFO, (&quot;%s&quot;, hex)); // Output &quot;010203&quot;;</span><br><span class="line">free(hex);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-unhex"><a href="#mg-unhex" class="headerlink" title="mg_unhex()"></a><code>mg_unhex()</code></h4><ul>
<li><code>void mg_unhex(const char *buf, size_t len, unsigned char *to);</code></li>
<li>十六进制字符串<code>buf</code>，<code>len</code>输入到缓冲区<code>to</code>。这个缓冲区<code>to</code>必须大于<code>lsn / 2</code></li>
<li>参数：<ul>
<li><code>buf</code>  –  需要十六进制解码的数据</li>
<li><code>len</code>  –  数据大小</li>
<li><code>to</code>   –  指向输出缓冲区的指针</li>
</ul>
</li>
<li>返回值：无</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char data[] = &quot;010203&quot;;</span><br><span class="line">char *buf[sizeof(data)/2];</span><br><span class="line">char *hex = mg_unhex(data, sizeof(data) - 1, buf); // buf is now [1,2,3]</span><br><span class="line">free(hex);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-unhexn"><a href="#mg-unhexn" class="headerlink" title="mg_unhexn()"></a><code>mg_unhexn()</code></h4><ul>
<li><code>unsigned long mg_unhexn(const char *s, size_t len);</code></li>
<li>解析十六进制编码的字符串<code>s</code>的<code>len</code>个字节。这个<code>len</code>最大值为<code>long x 2</code>的宽度，例如：32-bit platform it is 8</li>
<li>参数：<ul>
<li><code>s</code>   –  需要解析的字符串</li>
<li><code>len</code> –  字符串长度</li>
</ul>
</li>
<li>返回值：返回解析的值</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char data[] = &quot;010203&quot;;</span><br><span class="line">char *buf[sizeof(data)/2];</span><br><span class="line">unsigned long val = mg_unhex(data, sizeof(data) - 1); // val is now 123</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-remove-double-dots"><a href="#mg-remove-double-dots" class="headerlink" title="mg_remove_double_dots()"></a><code>mg_remove_double_dots()</code></h4><ul>
<li><code>char *mg_remove_double_dots(char *s);</code></li>
<li>通过从中删除双点，修改字符串<code>s</code>。用于修改从网络收到的文件名或URI</li>
<li>参数：<ul>
<li><code>s</code>  –  需要修改的字符串</li>
</ul>
</li>
<li>返回值：返回<code>s</code>指针</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char data[] = &quot;../../a.txt&quot;;</span><br><span class="line">mg_remove_double_dots(data);  // data is /a.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-snprintf-mg-vsnprintf"><a href="#mg-snprintf-mg-vsnprintf" class="headerlink" title="mg_snprintf(), mg_vsnprintf()"></a><code>mg_snprintf(), mg_vsnprintf()</code></h4><ul>
<li><code>size_t mg_snprintf(char *buf, size_t len, const char *fmt, ...);</code></li>
<li><code>size_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list ap);</code></li>
<li>像<code>snprintf()</code>标准函数一样，打印格式的字符串到字符串缓冲区中,但是以一种可预测的方式，不取决于C库或构建环境。返回值可以大于缓冲区长度<code>len</code>，在这种情况下，溢出字节未打印。Mongoose库通常用于以JSON格式交换数据因此，还支持非标准<code>％q</code>，<code>％v</code>，<code>％h</code>指定符用于格式化JSON字符串</li>
<li>参数：<ul>
<li><code>buf</code>  –  指向输出缓冲区的指针</li>
<li><code>len</code>  –  缓冲区大小</li>
<li><code>fmt</code>  –  类似于printf的格式字符串</li>
</ul>
</li>
<li>支持格式指定符<ul>
<li><code>hhd</code>, <code>hd</code>, <code>d</code>, <code>ld</code>, <code>lld</code>  –  用于 <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>int64_t</code></li>
<li><code>hhu</code>, <code>hu</code>, <code>u</code>, <code>lu</code>, <code>llu</code>  –  相同，但是用于无符号</li>
<li><code>hhx</code>, <code>hx</code>, <code>x</code>, <code>lx</code>, <code>llx</code>  –  相同，无符号并且以十六进制输出</li>
<li><code>s</code>  –  对应<code>char *</code></li>
<li><code>q</code>  –  对应<code>char *</code>，输出JSON格式字符串(extension)</li>
<li><code>Q</code>  –  对应<code>char *</code>，输出双引号的JSON格式字符串(extension)</li>
<li><code>H</code>  –  对应<code>int</code>, <code>void *</code>, 输出双引号的十六进制字符串(extension)</li>
<li><code>I</code>  –  对应<code>int</code>（4 或 6）， <code>void *</code>, 输出IP地址(extension)</li>
<li><code>A</code>  –  对应<code>void *</code>， 输出硬件地址(extension)</li>
<li><code>V</code>  –  对应<code>int</code>, <code>void *</code>， 输出双引号的base64 字符串(extension)</li>
<li><code>M</code>  –  对应<code>mg_pfn_t</code>，调用另一个输出函数(extension)</li>
<li><code>g</code>, <code>f</code>  –  对应<code>double</code></li>
<li><code>c</code>  –  对应<code>char</code></li>
<li><code>%</code>  –  对应<code>%</code>字符自己</li>
<li><code>p</code>  –  对应任何指针，输出<code>0x....</code>十六进制值</li>
<li><code>%X.Y</code>  –  可选宽度和精度修饰符</li>
<li><code>%.*</code>   –  可选的精度修饰符指定为<code>int</code>参数</li>
</ul>
</li>
<li>返回值：返回打印的字节数</li>
<li>发送一个JSON HTTP response： <ul>
<li><code>mg_http_reply(c, 200, &quot;Content-Type: application/json\r\n&quot;, &quot;&#123; %Q: %g&#125;&quot;, &quot;value&quot;, 1.2345);</code></li>
</ul>
</li>
<li>使用更复杂格式字符串的示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%lld&quot;, (int64_t) 123);   // 123</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%.2s&quot;, &quot;abcdef&quot;);        // ab</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%.*s&quot;, 2, &quot;abcdef&quot;);     // ab</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%05x&quot;, 123);             // 00123</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%%-%3s&quot;, &quot;a&quot;);           // %-  a</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;hi, %Q&quot;, &quot;a&quot;);           // hi, &quot;a&quot;</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;r: %M, %d&quot;, f,1,2,7);    // r: 3, 7</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%I&quot;, 4, &quot;abcd&quot;);         // 97.98.99.100</span><br><span class="line">mg_snprintf(buf, sizeof(buf), &quot;%A&quot;, &quot;abcdef&quot;);          // 61:62:63:64:65:66</span><br><span class="line"></span><br><span class="line">// Printing sub-function for %M specifier. Grabs two int parameters</span><br><span class="line">size_t f(void (*out)(char, void *), void *ptr, va_list *ap) &#123;</span><br><span class="line">  int a = va_arg(*ap, int);</span><br><span class="line">  int b = va_arg(*ap, int);</span><br><span class="line">  return mg_xprintf(out, ptr, &quot;%d&quot;, a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-mprintf-mg-vmprintf"><a href="#mg-mprintf-mg-vmprintf" class="headerlink" title="mg_mprintf(), mg_vmprintf()"></a><code>mg_mprintf(), mg_vmprintf()</code></h4><ul>
<li><code>char *mg_mprintf(const char *fmt, ...);</code></li>
<li><code>char *mg_vmprintf(const char *fmt, va_list *ap);</code></li>
<li>将消息打印输出到分配的缓冲区中。调用者必须手动释放缓冲区</li>
<li>参数：<ul>
<li><code>fmt</code>  –  类似于printf的格式字符串</li>
</ul>
</li>
<li>返回值：分配的内存缓冲区</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *msg = mg_mprintf(&quot;Double quoted string: %Q!&quot;, &quot;hi&quot;);</span><br><span class="line">free(msg);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-xprintf-mg-vxprintf"><a href="#mg-xprintf-mg-vxprintf" class="headerlink" title="mg_xprintf(), mg_vxprintf()"></a><code>mg_xprintf(), mg_vxprintf()</code></h4><ul>
<li><code>size_t mg_xprintf(void (*out)(char, void *), void *param, const char *fmt, ...);</code></li>
<li><code>size_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt, va_list *ap);</code></li>
<li>使用指定字符输出函数打印消息</li>
<li>参数：<ul>
<li><code>out</code>   –  被用于打印字符的函数</li>
<li><code>param</code> –  被传给<code>out</code>的参数</li>
<li><code>fmt</code>   –  类似于printf的格式字符串</li>
</ul>
</li>
<li>返回值：返回打印的字节数</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void myfn(char c, void *p);</span><br><span class="line"></span><br><span class="line">size_t len = mg_xprintf(myfn, myfn_p, &quot;Double quoted string: %Q!&quot;, &quot;hi&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-pfn-iobuf"><a href="#mg-pfn-iobuf" class="headerlink" title="mg_pfn_iobuf()"></a><code>mg_pfn_iobuf()</code></h4><ul>
<li><code>void mg_pfn_iobuf(char ch, void *param);</code></li>
<li>将一个字符打印到通用IO缓冲区 <code>Generic IO buffer</code></li>
<li>参数：<ul>
<li><code>ch</code>    –  被打印的字节</li>
<li><code>param</code> –  必须是<code>struct mg_iobuf *</code></li>
</ul>
</li>
<li>示例：<ul>
<li><code>mg_xprintf(mg_pfn_iobuf, &amp;c-&gt;send, &quot;hi!&quot;);  // Append to the output buffer</code></li>
</ul>
</li>
</ul>
<h4 id="mg-to64"><a href="#mg-to64" class="headerlink" title="mg_to64()"></a><code>mg_to64()</code></h4><ul>
<li><code>int64_t mg_to64(struct mg_str str);</code></li>
<li><code>uint64_t mg_tou64(struct mg_str str);</code></li>
<li>解析字符串持有的64位整数的值。</li>
<li>参数：<ul>
<li><code>str</code>  –  需要解析的字符串</li>
</ul>
</li>
<li>返回值：解析的值</li>
<li>示例：<ul>
<li><code>int64_t val = mg_to64(mg_str(&quot;123&quot;)); // Val is now 123</code></li>
</ul>
</li>
</ul>
<h4 id="mg-aton"><a href="#mg-aton" class="headerlink" title="mg_aton()"></a><code>mg_aton()</code></h4><ul>
<li><code>bool mg_aton(struct mg_str str, struct mg_addr *addr);</code></li>
<li>解析存储在<code>str</code>的IP地址，并将结果存储在<code>addr</code></li>
<li>参数：<ul>
<li><code>str</code>   –  需要解析的字符串，例如：<code>1.2.3.4</code>, <code>[::1]</code>, <code>01:02::03</code></li>
<li><code>addr</code>  –  指向接收解析结果的<code>mg_addr</code>字符串的指针</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回true</li>
<li>其他情况，返回false</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct mg_addr addr;</span><br><span class="line">if (mg_aton(mg_str(&quot;127.0.0.1&quot;), &amp;addr)) &#123;</span><br><span class="line">  // addr is now binary representation of 127.0.0.1 IP address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-8-JSON-API"><a href="#1-8-JSON-API" class="headerlink" title="1.8 JSON API"></a>1.8 JSON API</h3><ul>
<li>请注意，Mongoose的打印功能支持非标准格式指定Q和％m，它们可以轻松打印JSON字符串：<ul>
<li><code>char *json = mg_mprintf(&quot;&#123; %Q:%d&#125;&quot;, &quot;value&quot;, 123);  // &#123;&quot;value&quot;:123&#125;</code></li>
<li><code>free(json);</code></li>
</ul>
</li>
<li>因此，对于完整的JSON支持，需要一组解析功能 - 如下所述。</li>
</ul>
<h4 id="mg-json-get"><a href="#mg-json-get" class="headerlink" title="mg_json_get()"></a><code>mg_json_get()</code></h4><ul>
<li><code>enum &#123; MG_JSON_TOO_DEEP = -1, MG_JSON_INVALID = -2, MG_JSON_NOT_FOUND = -3 &#125;;</code></li>
<li><code>int mg_json_get(struct mg_str json, const char *path, int *toklen);</code></li>
<li>解析JSON字符串<code>json</code>，并且返回JSON <code>path</code> 指定的元素的偏移。这个元素的长度被存储在<code>toklen</code></li>
<li>参数：<ul>
<li><code>json</code>  –  保存有一个有效JSON的字符串</li>
<li><code>path</code>  –  一个JSON 路径，必须由<code>$</code>开始，例如：<code>$.user</code></li>
<li><code>toklen</code> –  指向接收元素的长度的指针，可以为NULL</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回元素的偏移量</li>
<li>返回负数 <code>MG_JSON_*</code>表示错误</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Create a json string: &#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3] &#125;</span><br><span class="line">char *buf = mg_mprintf(&quot;&#123; %Q: %d, %Q: [%d, %d] &#125;&quot;, &quot;a&quot;, 1, &quot;b&quot;, 2, 3);</span><br><span class="line">struct mg_str json = mg_str(buf);</span><br><span class="line">int offset, length;</span><br><span class="line"></span><br><span class="line">// Lookup &quot;$&quot;, which is the whole JSON. Can be used for validation</span><br><span class="line">offset = mg_json_get(json, &quot;$&quot;, &amp;length);    // offset = 0, length = 23</span><br><span class="line"></span><br><span class="line">// Lookup attribute &quot;a&quot;. Point to value &quot;1&quot;</span><br><span class="line">offset = mg_json_get(json, &quot;$.a&quot;, &amp;length);  // offset = 7, length = 1</span><br><span class="line"></span><br><span class="line">// Lookup attribute &quot;b&quot;. Point to array [2, 3]</span><br><span class="line">offset = mg_json_get(json, &quot;$.b&quot;, &amp;length);  // offset = 15, length = 6</span><br><span class="line"></span><br><span class="line">// Lookup attribute &quot;b[1]&quot;. Point to value &quot;3&quot;</span><br><span class="line">offset = mg_json_get(json, &quot;$.b[1]&quot;, &amp;length); // offset = 19, length = 1</span><br><span class="line"></span><br><span class="line">free(buf);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-json-get-num"><a href="#mg-json-get-num" class="headerlink" title="mg_json_get_num()"></a><code>mg_json_get_num()</code></h4><ul>
<li><code>bool mg_json_get_num(struct mg_str json, const char *path, double *v);</code></li>
<li>在JSON路径<code>path</code>，从<code>json</code>字符串获取数字值(double)。如果成功，返回true</li>
<li>参数：<ul>
<li><code>json</code>  –  保存有效JSON字符串</li>
<li><code>path</code>  –  一个JSON路径。必须以<code>$</code>开始</li>
<li><code>v</code>     –  一个对应于值的占位符</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回true</li>
<li>失败，返回false</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double d = 0.0;</span><br><span class="line">mg_json_get_num(mg_str(&quot;[1,2,3]&quot;, &quot;$[1]&quot;, &amp;d));     // d contains 2</span><br><span class="line">mg_json_get_num(mg_str(&quot;&#123;\&quot;a\&quot;:1.23&#125;&quot;, &quot;$.a&quot;, &amp;d)); // d contains 1.23</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-json-get-bool"><a href="#mg-json-get-bool" class="headerlink" title="mg_json_get_bool()"></a><code>mg_json_get_bool()</code></h4><ul>
<li><code>bool mg_json_get_bool(struct mg_str json, const char *path, bool *v);</code></li>
<li>在JSON路径<code>path</code>，从<code>json</code>字符串获取布尔值(bool)。如果成功，返回true</li>
<li>参数：<ul>
<li><code>json</code>  –  保存有效JSON字符串</li>
<li><code>path</code>  –  一个JSON路径。必须以<code>$</code>开始</li>
<li><code>v</code>     –  一个对应于值的占位符</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回true</li>
<li>失败，返回false</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool b = false;</span><br><span class="line">mg_json_get_bool(mg_str(&quot;[123]&quot;, &quot;$[0]&quot;, &amp;b));   // Error. b remains to be false</span><br><span class="line">mg_json_get_bool(mg_str(&quot;[true]&quot;, &quot;$[0]&quot;, &amp;b));  // b is true</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-json-get-long"><a href="#mg-json-get-long" class="headerlink" title="mg_json_get_long()"></a><code>mg_json_get_long()</code></h4><ul>
<li><code>long mg_json_get_long(struct mg_str json, const char *path, long default_val);</code></li>
<li>在JSON路径<code>path</code>，从<code>json</code>字符串获取数字值(long)。</li>
<li>参数：<ul>
<li><code>json</code>  –  保存有效JSON字符串</li>
<li><code>path</code>  –  一个JSON路径。必须以<code>$</code>开始</li>
<li><code>v</code>     –  一个对应于值的占位符</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回找到的值</li>
<li>返回<code>default_val</code>值</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long a = mg_json_get_long(mg_str(&quot;[123]&quot;, &quot;$a&quot;, -1));   // a = -1</span><br><span class="line">long b = mg_json_get_long(mg_str(&quot;[123]&quot;, &quot;$[0]&quot;, -1)); // b = 123</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-json-get-str"><a href="#mg-json-get-str" class="headerlink" title="mg_json_get_str()"></a><code>mg_json_get_str()</code></h4><ul>
<li><code>char *mg_json_get_str(struct mg_str json, const char *path);</code></li>
<li>在JSON路径<code>path</code>，从<code>json</code>字符串获取字符串值。如果找到，使用<code>calloc()</code>分配内存的字符串，没有转义的返回给调用者。调用者需要手动使用<code>free()</code>释放返回的字符串</li>
<li>参数：<ul>
<li><code>json</code>  –  保存有效JSON字符串</li>
<li><code>path</code>  –  一个JSON路径。必须以<code>$</code>开始</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回non-NULL</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str json = mg_str(&quot;&#123;\&quot;a\&quot;: \&quot;hi\&quot;&#125;&quot;);  // json = &#123;&quot;a&quot;: &quot;hi&quot;&#125;</span><br><span class="line">char *str = mg_json_get_str(json, &quot;$.a&quot;);        // str = &quot;hi&quot;</span><br><span class="line">free(str);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-json-get-hex"><a href="#mg-json-get-hex" class="headerlink" title="mg_json_get_hex()"></a><code>mg_json_get_hex()</code></h4><ul>
<li><code>char *mg_json_get_hex(struct mg_str json, const char *path, int *len);</code></li>
<li>在JSON路径<code>path</code>，从<code>json</code>字符串获取十六进制编码的缓冲区。如果找到，使用<code>calloc()</code>分配内存的缓冲区，解码，并且返回给调用者。调用者需要手动调用<code>free()</code>释放返回的字符串。返回的缓冲区是 0-terminated</li>
<li>参数：<ul>
<li><code>json</code>  –  保存有效JSON字符串</li>
<li><code>path</code>  –  一个JSON路径。必须以<code>$</code>开始</li>
<li><code>len</code>   –  一个指向接收解码长度的指针。可以为NULL</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回non-NULL</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str json = mg_str(&quot;&#123;\&quot;a\&quot;: \&quot;6869\&quot;&#125;&quot;); // json = &#123;&quot;a&quot;: &quot;6869&quot;&#125;</span><br><span class="line">char *str = mg_json_get_hex(json, &quot;$.a&quot;, NULL);   // str = &quot;hi&quot;</span><br><span class="line">free(str);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mg-json-get-b64"><a href="#mg-json-get-b64" class="headerlink" title="mg_json_get_b64()"></a><code>mg_json_get_b64()</code></h4><ul>
<li><code>char *mg_json_get_b4(struct mg_str json, const char *path, int *len);</code></li>
<li>在JSON路径<code>path</code>，从<code>json</code>字符串获取base64 编码的缓冲区。如果找到，使用<code>calloc()</code>申请内存的缓冲区，解码，并返回给调用者。调用者需要手动调用<code>free()</code>释放返回的字符串。返回的缓冲区是 0-terminated</li>
<li>参数：<ul>
<li><code>json</code>  –  保存有效JSON字符串</li>
<li><code>path</code>  –  一个JSON路径。必须以<code>$</code>开始</li>
<li><code>len</code>   –  一个指向接收解码长度的指针。可以为NULL</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回non-NULL</li>
<li>失败，返回NULL</li>
</ul>
</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct mg_str json = mg_str(&quot;&#123;\&quot;a\&quot;: \&quot;YWJj\&quot;&#125;&quot;); // json = &#123;&quot;a&quot;: &quot;YWJj&quot;&#125;</span><br><span class="line">char *str = mg_json_get_b64(json, &quot;$.a&quot;, NULL);   // str = &quot;abc&quot;</span><br><span class="line">free(str);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-9-Utility-API"><a href="#1-9-Utility-API" class="headerlink" title="1.9 Utility API"></a>1.9 Utility API</h3><h3 id="2-0-URL-API"><a href="#2-0-URL-API" class="headerlink" title="2.0 URL API"></a>2.0 URL API</h3><h3 id="2-1-Logging-API"><a href="#2-1-Logging-API" class="headerlink" title="2.1 Logging API"></a>2.1 Logging API</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_utility/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Mongoose/mongoose_1_%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/2024-05-22-mongoose_utility/" class="post-title-link" itemprop="url">mongoose_utility</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mongoose/" itemprop="url" rel="index"><span itemprop="name">Mongoose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mongoose 工具</li>
</ul>
<h2 id="mg-call"><a href="#mg-call" class="headerlink" title="mg_call"></a>mg_call</h2><ul>
<li><p>简介：</p>
<ul>
<li>发送ev事件到c事件处理程序。该函数在实现您自己的协议时非常有用。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_call</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">int</span> ev, <span class="type">void</span> *ev_data)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c – 发送事件的连接</li>
<li>ev – 发送的事件</li>
<li>ev_data – 附加事件参数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In a timer callback, send MG_EV_USER event to all connections</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">timer_fn</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mg_mgr</span> *mgr = (<span class="keyword">struct</span> mg_mgr *) arg;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">struct</span> mg_connection *c = mgr-&gt;conns; c != <span class="literal">NULL</span>; c = c-&gt;next) &#123;</span><br><span class="line">    <span class="built_in">mg_call</span>(c, MG_EV_USER, <span class="string">&quot;hi!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="mg-error"><a href="#mg-error" class="headerlink" title="mg_error"></a>mg_error</h2><ul>
<li><p>简介：</p>
<ul>
<li>向连接事件处理程序发送MG_EV_ERROR，并使用printf语义格式化错误信息。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mg_error</span><span class="params">(<span class="keyword">struct</span> mg_connection *c, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>c – 发送事件的连接</li>
<li>fmt – 使用printf语义格式化的字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>无</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mg_error</span>(c, <span class="string">&quot;Operation failed, error code: %d&quot;</span>, errno);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/29/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><span class="page-number current">30</span><a class="page-number" href="/page/31/">31</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/31/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
