<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/12/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/19/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-06-19-C++%E4%B8%AD%E7%9A%84NaN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/19/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-06-19-C++%E4%B8%AD%E7%9A%84NaN/" class="post-title-link" itemprop="url">C++中的NaN 产生原因，特性及处理方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-19 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-19T09:00:00+08:00">2024-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>在C++编程中， NaN(Not a number)是浮点数类型(例如float, double, long double)中的一种特殊值，用于表示无法定义的数值或者操作结果。NaN在数值计算和科学计算中十分常见，正确理解和处理NaN对于编写健壮和可靠的代码至关重要。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/06/19/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-06-19-C++%E4%B8%AD%E7%9A%84NaN/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/19/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-06-19-linux_2_96_rsync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/19/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-06-19-linux_2_96_rsync/" class="post-title-link" itemprop="url">linux_2_96_rsync</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-19 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-19T09:00:00+08:00">2024-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="linux-rsync命令是什么"><a href="#linux-rsync命令是什么" class="headerlink" title="linux rsync命令是什么"></a>linux rsync命令是什么</h2><p><code>rsync</code> 是一个用于在本地或远程同步文件和目录的开源实用工具。它非常强大和灵活，支持递归传输、保持文件权限、压缩传输等功能，使其成为文件同步和备份的首选工具之一。</p>
<p>以下是 <code>rsync</code> 的一些常用选项和示例：</p>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul>
<li><code>-a, --archive</code>：归档模式，等同于 <code>-rlptgoD</code>，保留文件的权限、时间戳、符号链接等。</li>
<li><code>-v, --verbose</code>：详细模式，显示传输过程中的详细信息。</li>
<li><code>-z, --compress</code>：在传输过程中压缩文件以节省带宽。</li>
<li><code>-P</code>：显示传输进度并部分保留已传输的文件（等同于 <code>--partial --progress</code>）。</li>
<li><code>--exclude</code>：排除指定的文件或目录。</li>
<li><code>--delete</code>：删除目标目录中在源目录中不存在的文件。</li>
</ul>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="本地复制"><a href="#本地复制" class="headerlink" title="本地复制"></a>本地复制</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /source/directory /destination/directory</span><br></pre></td></tr></table></figure>
<p>将 <code>/source/directory</code> 复制到 <code>/destination/directory</code>。</p>
<h4 id="远程复制"><a href="#远程复制" class="headerlink" title="远程复制"></a>远程复制</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /local/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>
<p>将本地目录 <code>/local/directory</code> 复制到远程主机 <code>remote_host</code> 的 <code>/remote/directory</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av user@remote_host:/remote/directory /local/directory</span><br></pre></td></tr></table></figure>
<p>将远程主机 <code>remote_host</code> 的 <code>/remote/directory</code> 复制到本地目录 <code>/local/directory</code>。</p>
<h4 id="使用-exclude-排除特定目录"><a href="#使用-exclude-排除特定目录" class="headerlink" title="使用 --exclude 排除特定目录"></a>使用 <code>--exclude</code> 排除特定目录</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;exclude_directory&#x27;</span> /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>
<p>将本地目录 <code>/source/directory</code> 复制到远程主机 <code>remote_host</code> 的 <code>/remote/directory</code>，但排除 <code>exclude_directory</code> 目录。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol>
<li><p><strong>同步本地目录</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /home/user/data /backup</span><br></pre></td></tr></table></figure>
<p>将 <code>/home/user/data</code> 目录同步到 <code>/backup</code> 目录。</p>
</li>
<li><p><strong>排除特定目录</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;tmp&#x27;</span> /home/user/data /backup</span><br></pre></td></tr></table></figure>
<p>将 <code>/home/user/data</code> 目录同步到 <code>/backup</code> 目录，但排除 <code>tmp</code> 目录。</p>
</li>
<li><p><strong>同步到远程主机</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz /home/user/data user@remote_host:/backup</span><br></pre></td></tr></table></figure>
<p>将本地 <code>/home/user/data</code> 目录同步到远程主机 <code>remote_host</code> 的 <code>/backup</code> 目录，并在传输过程中进行压缩。</p>
</li>
<li><p><strong>从远程主机同步到本地</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz user@remote_host:/backup /home/user/data</span><br></pre></td></tr></table></figure>
<p>将远程主机 <code>remote_host</code> 的 <code>/backup</code> 目录同步到本地的 <code>/home/user/data</code> 目录，并在传输过程中进行压缩。</p>
</li>
<li><p><strong>显示进度</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avP /home/user/data user@remote_host:/backup</span><br></pre></td></tr></table></figure>
<p>将本地 <code>/home/user/data</code> 目录同步到远程主机 <code>remote_host</code> 的 <code>/backup</code> 目录，并显示传输进度。</p>
</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>rsync</code> 是一个非常强大且灵活的工具，适用于各种文件同步和备份需求。通过熟练使用 <code>rsync</code> 的各种选项，你可以高效地完成复杂的文件传输和同步任务。</p>
<h2 id="linux-rsync命令-详解"><a href="#linux-rsync命令-详解" class="headerlink" title="linux rsync命令 详解"></a>linux rsync命令 详解</h2><p><code>rsync</code> 是一个强大的文件同步工具，常用于在本地或远程主机之间复制和同步文件和目录。它支持增量传输、保持文件权限、压缩传输等功能。以下是 <code>rsync</code> 的详细说明和一些示例。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync [OPTION]... SRC [SRC]... DEST</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SRC</code>：源文件或目录</li>
<li><code>DEST</code>：目标文件或目录</li>
</ul>
<h3 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h3><ul>
<li><code>-a, --archive</code>：归档模式，相当于 <code>-rlptgoD</code>，保留文件属性。<ul>
<li><code>-r, --recursive</code>：递归处理目录。</li>
<li><code>-l, --links</code>：保留符号链接。</li>
<li><code>-p, --perms</code>：保留文件权限。</li>
<li><code>-t, --times</code>：保持文件修改时间。</li>
<li><code>-g, --group</code>：保留文件组信息。</li>
<li><code>-o, --owner</code>：保留文件所有者信息。</li>
<li><code>-D</code>：保留设备文件和特殊文件。</li>
</ul>
</li>
<li><code>-v, --verbose</code>：详细输出。</li>
<li><code>-z, --compress</code>：在传输过程中压缩文件。</li>
<li><code>-P</code>：显示传输进度和部分传输的文件（等同于 <code>--partial --progress</code>）。<ul>
<li><code>--partial</code>：保留部分传输的文件，以便恢复。</li>
<li><code>--progress</code>：显示传输进度。</li>
</ul>
</li>
<li><code>--exclude</code>：指定排除的文件或目录模式。</li>
<li><code>--delete</code>：删除目标目录中在源目录中不存在的文件。</li>
<li><code>--bwlimit=RATE</code>：限制 I&#x2F;O 带宽，单位为 KB&#x2F;s。</li>
<li><code>-e, --rsh=COMMAND</code>：指定远程 shell 程序。</li>
<li><code>--checksum</code>：基于文件校验和进行比较，而不是文件大小和修改时间。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="本地复制-1"><a href="#本地复制-1" class="headerlink" title="本地复制"></a>本地复制</h4><p>将本地目录 <code>/source/directory</code> 复制到 <code>/destination/directory</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /source/directory /destination/directory</span><br></pre></td></tr></table></figure>

<h4 id="远程复制-1"><a href="#远程复制-1" class="headerlink" title="远程复制"></a>远程复制</h4><p>将本地目录 <code>/local/directory</code> 复制到远程主机 <code>remote_host</code> 的 <code>/remote/directory</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /local/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<p>将远程主机 <code>remote_host</code> 的 <code>/remote/directory</code> 复制到本地目录 <code>/local/directory</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av user@remote_host:/remote/directory /local/directory</span><br></pre></td></tr></table></figure>

<h4 id="排除特定目录"><a href="#排除特定目录" class="headerlink" title="排除特定目录"></a>排除特定目录</h4><p>将本地目录 <code>/source/directory</code> 复制到远程主机 <code>remote_host</code> 的 <code>/remote/directory</code>，但排除 <code>exclude_directory</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;exclude_directory&#x27;</span> /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<h4 id="显示进度"><a href="#显示进度" class="headerlink" title="显示进度"></a>显示进度</h4><p>在传输过程中显示进度：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avP /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<h4 id="同步文件并删除目标目录中多余的文件"><a href="#同步文件并删除目标目录中多余的文件" class="headerlink" title="同步文件并删除目标目录中多余的文件"></a>同步文件并删除目标目录中多余的文件</h4><p>将本地目录 <code>/source/directory</code> 同步到远程主机 <code>remote_host</code> 的 <code>/remote/directory</code>，并删除目标目录中多余的文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --delete /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<h4 id="限制传输带宽"><a href="#限制传输带宽" class="headerlink" title="限制传输带宽"></a>限制传输带宽</h4><p>将本地目录 <code>/source/directory</code> 复制到远程主机 <code>remote_host</code> 的 <code>/remote/directory</code>，并限制传输带宽为 500 KB&#x2F;s：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --bwlimit=500 /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<h4 id="使用-SSH-进行传输"><a href="#使用-SSH-进行传输" class="headerlink" title="使用 SSH 进行传输"></a>使用 SSH 进行传输</h4><p>通过 SSH 进行文件传输：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz -e ssh /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<h4 id="基于校验和进行比较"><a href="#基于校验和进行比较" class="headerlink" title="基于校验和进行比较"></a>基于校验和进行比较</h4><p>基于文件校验和进行比较，而不是文件大小和修改时间：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --checksum /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p><code>rsync</code> 是一个非常强大且灵活的工具，可以满足各种文件同步和备份需求。通过掌握 <code>rsync</code> 的各种选项和用法，你可以高效地完成复杂的文件传输和同步任务。</p>
<h2 id="linux-rsync命令-拷贝目录并且忽略指定目录"><a href="#linux-rsync命令-拷贝目录并且忽略指定目录" class="headerlink" title="linux rsync命令 拷贝目录并且忽略指定目录"></a>linux rsync命令 拷贝目录并且忽略指定目录</h2><p>在 Linux 上使用 <code>rsync</code> 拷贝目录并且忽略指定目录的具体步骤如下。假设你要拷贝 <code>/source/directory</code> 到目标目录 <code>/destination/directory</code>，但要忽略 <code>ignore_directory</code> 目录。</p>
<h3 id="示例命令"><a href="#示例命令" class="headerlink" title="示例命令"></a>示例命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;ignore_directory&#x27;</span> /source/directory/ /destination/directory/</span><br></pre></td></tr></table></figure>

<h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><ul>
<li><code>-a, --archive</code>：归档模式，表示递归复制目录，并保持文件属性。</li>
<li><code>-v, --verbose</code>：详细模式，显示传输过程中的信息。</li>
<li><code>--exclude &#39;ignore_directory&#39;</code>：指定要排除的目录 <code>ignore_directory</code>。</li>
<li><code>/source/directory/</code>：源目录路径，末尾的 <code>/</code> 表示拷贝目录内的内容。</li>
<li><code>/destination/directory/</code>：目标目录路径，末尾的 <code>/</code> 表示将内容复制到该目录中。</li>
</ul>
<h3 id="更详细的例子"><a href="#更详细的例子" class="headerlink" title="更详细的例子"></a>更详细的例子</h3><p>假设有如下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/source/directory/</span><br><span class="line">├── file1.txt</span><br><span class="line">├── file2.txt</span><br><span class="line">└── ignore_directory/</span><br><span class="line">    ├── file3.txt</span><br><span class="line">    └── file4.txt</span><br></pre></td></tr></table></figure>

<p>使用上述 <code>rsync</code> 命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;ignore_directory&#x27;</span> /source/directory/ /destination/directory/</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/destination/directory/</span><br><span class="line">├── file1.txt</span><br><span class="line">└── file2.txt</span><br></pre></td></tr></table></figure>

<h3 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h3><ul>
<li>如果你有多个目录或文件需要排除，可以使用多个 <code>--exclude</code> 选项：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;ignore_directory1&#x27;</span> --exclude <span class="string">&#x27;ignore_directory2&#x27;</span> /source/directory/ /destination/directory/</span><br></pre></td></tr></table></figure>

<ul>
<li>你也可以使用 <code>--exclude-from</code> 选项从文件中读取排除的目录和文件列表。假设排除列表文件 <code>exclude-list.txt</code> 内容如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ignore_directory1</span><br><span class="line">ignore_directory2</span><br><span class="line">ignore_file.txt</span><br></pre></td></tr></table></figure>

<p>使用命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude-from=<span class="string">&#x27;exclude-list.txt&#x27;</span> /source/directory/ /destination/directory/</span><br></pre></td></tr></table></figure>

<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>通过以上方法，你可以使用 <code>rsync</code> 高效地复制目录，同时忽略指定的目录或文件。这些选项提供了灵活的排除机制，使 <code>rsync</code> 成为处理文件同步和备份任务的强大工具。</p>
<h2 id="linux-rsync命令-远程拷贝目录并且忽略指定目录"><a href="#linux-rsync命令-远程拷贝目录并且忽略指定目录" class="headerlink" title="linux rsync命令 远程拷贝目录并且忽略指定目录"></a>linux rsync命令 远程拷贝目录并且忽略指定目录</h2><p>使用 <code>rsync</code> 命令可以实现远程拷贝目录并且忽略指定目录。以下是详细步骤和示例。</p>
<h3 id="示例命令-1"><a href="#示例命令-1" class="headerlink" title="示例命令"></a>示例命令</h3><p>假设你要将本地的 <code>/source/directory</code> 目录拷贝到远程主机 <code>remote_host</code> 的 <code>/destination/directory</code>，但要忽略 <code>ignore_directory</code> 目录。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;ignore_directory&#x27;</span> /source/directory/ user@remote_host:/destination/directory/</span><br></pre></td></tr></table></figure>

<h3 id="详细说明-1"><a href="#详细说明-1" class="headerlink" title="详细说明"></a>详细说明</h3><ul>
<li><code>-a, --archive</code>：归档模式，表示递归复制目录，并保持文件属性。</li>
<li><code>-v, --verbose</code>：详细模式，显示传输过程中的信息。</li>
<li><code>--exclude &#39;ignore_directory&#39;</code>：指定要排除的目录 <code>ignore_directory</code>。</li>
<li><code>/source/directory/</code>：源目录路径，末尾的 <code>/</code> 表示拷贝目录内的内容。</li>
<li><code>user@remote_host:/destination/directory/</code>：目标目录路径，格式为 <code>user@host:/path</code>。</li>
</ul>
<h3 id="更详细的例子-1"><a href="#更详细的例子-1" class="headerlink" title="更详细的例子"></a>更详细的例子</h3><p>假设有如下本地目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/source/directory/</span><br><span class="line">├── file1.txt</span><br><span class="line">├── file2.txt</span><br><span class="line">└── ignore_directory/</span><br><span class="line">    ├── file3.txt</span><br><span class="line">    └── file4.txt</span><br></pre></td></tr></table></figure>

<p>使用上述 <code>rsync</code> 命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;ignore_directory&#x27;</span> /source/directory/ user@remote_host:/destination/directory/</span><br></pre></td></tr></table></figure>

<p>结果是远程主机 <code>remote_host</code> 上的 <code>/destination/directory/</code> 目录结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/destination/directory/</span><br><span class="line">├── file1.txt</span><br><span class="line">└── file2.txt</span><br></pre></td></tr></table></figure>

<h3 id="使用多个排除选项"><a href="#使用多个排除选项" class="headerlink" title="使用多个排除选项"></a>使用多个排除选项</h3><p>如果你有多个目录或文件需要排除，可以使用多个 <code>--exclude</code> 选项：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;ignore_directory1&#x27;</span> --exclude <span class="string">&#x27;ignore_directory2&#x27;</span> /source/directory/ user@remote_host:/destination/directory/</span><br></pre></td></tr></table></figure>

<h3 id="使用排除列表文件"><a href="#使用排除列表文件" class="headerlink" title="使用排除列表文件"></a>使用排除列表文件</h3><p>你也可以使用 <code>--exclude-from</code> 选项从文件中读取排除的目录和文件列表。假设排除列表文件 <code>exclude-list.txt</code> 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ignore_directory1</span><br><span class="line">ignore_directory2</span><br><span class="line">ignore_file.txt</span><br></pre></td></tr></table></figure>

<p>使用命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude-from=<span class="string">&#x27;exclude-list.txt&#x27;</span> /source/directory/ user@remote_host:/destination/directory/</span><br></pre></td></tr></table></figure>

<h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>通过以上方法，你可以使用 <code>rsync</code> 高效地实现远程目录拷贝，同时忽略指定的目录或文件。这些选项提供了灵活的排除机制，使 <code>rsync</code> 成为处理远程文件同步和备份任务的强大工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/27/notebook/Tools/2024-05-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/27/notebook/Tools/2024-05-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-27 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-27T09:00:00+08:00">2024-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>数据结构相关笔记</p>
</li>
<li><p>数据结构(data structure)是计算机中存储，组织数据的方式</p>
</li>
<li><p>数据结构是一种具有一定逻辑关系，在计算机中应用某种数据结构，并且封装了相应操作的数据元素集合。它包含三方面的内容，逻辑关系，存储关系及操作。</p>
</li>
<li><p>不同种类的数据结构适合于不同种类的应用，而部分甚至专门用于特定的作业任务。例如，计算机网络依赖于路由表运作，B树高度适用于数据库的封装。</p>
</li>
<li><p>数据结构研究的内容：就是如何按一定的逻辑结构，把数据组织起来，并选择适当的存储表示方法把逻辑结构组织好的数据存储到计算机的存储器里。</p>
</li>
</ul>
<h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><ul>
<li>栈(stack)： 栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据节点的插入和删除操作</li>
<li>队列(queue)：队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作</li>
<li>数组(array)：数据是一种聚合数据类型，它是将具有相同相同类型的若干变量有序的组织在一起的集合。</li>
<li>链表(linked list)：链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。</li>
<li>树(tree)：树是典型的非线性结构，它是包括，2 个结点的有穷集合 K</li>
<li>图(graph)：图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。</li>
<li>堆(heap)：堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。</li>
<li>散列表(hash table)：散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/27/notebook/Tools/2024-05-27-%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/27/notebook/Tools/2024-05-27-%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-27 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-27T09:00:00+08:00">2024-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>数据结构研究的内容：就是如何按一定的逻辑结构，把数据组织起来，并选择适当的存储表示方法把逻辑结构组织好的数据存储到计算机的存储器里。</li>
<li>算法研究的目的是为了更有效的处理数据，提高数据运算效率。数据的运算是定义在数据的逻辑结构上，但是运算的具体实现要在存储结构上进行。一般有以下几种常用运算<ul>
<li>检索：检索就是在数据结构里查找满足一定条件的节点。一般是给定一个某字段的值，找具有该字段的节点</li>
<li>插入：往数据结构中增加新的节点</li>
<li>删除：把指定的节点从数据结构中去掉</li>
<li>更新：改变指定节点的一个或者多个字段的值</li>
<li>排序：把节点按某种指定的顺序重新排列。例如递增或者递减</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/24/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-05-24-python_3_os%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/24/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-05-24-python_3_os%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">python_3_os模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-24 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-24T09:00:00+08:00">2024-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-14 08:45:41" itemprop="dateModified" datetime="2025-05-14T08:45:41+08:00">2025-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>os模块相关笔记</li>
</ul>
<h2 id="python3-os模块-详解"><a href="#python3-os模块-详解" class="headerlink" title="python3 os模块 详解"></a>python3 os模块 详解</h2><p><code>os</code>模块是Python中用于与操作系统进行交互的标准库之一。它提供了许多函数来执行文件和目录管理，处理文件路径，以及与操作系统交互的其他功能。下面是对<code>os</code>模块的一些主要功能的详解：</p>
<h3 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h3><ol>
<li><p><strong>创建目录</strong></p>
<ul>
<li><code>os.mkdir(path)</code>: 创建单级目录。</li>
<li><code>os.makedirs(path)</code>: 递归创建多级目录。</li>
</ul>
</li>
<li><p><strong>删除目录</strong></p>
<ul>
<li><code>os.rmdir(path)</code>: 删除指定目录。</li>
<li><code>os.removedirs(path)</code>: 递归删除目录，直到指定目录。</li>
</ul>
</li>
<li><p><strong>文件和目录存在性检查</strong></p>
<ul>
<li><code>os.path.exists(path)</code>: 检查文件或目录是否存在。</li>
<li><code>os.path.isfile(path)</code>: 检查给定路径是否是文件。</li>
<li><code>os.path.isdir(path)</code>: 检查给定路径是否是目录。</li>
</ul>
</li>
<li><p><strong>重命名和移动</strong></p>
<ul>
<li><code>os.rename(src, dst)</code>: 重命名文件或目录。</li>
<li><code>os.replace(src, dst)</code>: 替换文件或目录，如果目标已经存在。</li>
</ul>
</li>
<li><p><strong>列出目录内容</strong></p>
<ul>
<li><code>os.listdir(path)</code>: 返回目录中的所有文件和目录的列表。</li>
</ul>
</li>
<li><p><strong>删除文件</strong></p>
<ul>
<li><code>os.remove(path)</code>: 删除指定文件。</li>
</ul>
</li>
</ol>
<h3 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h3><ol>
<li><p><strong>连接路径</strong></p>
<ul>
<li><code>os.path.join(path1, path2, ...)</code>: 将多个路径组合成一个路径。</li>
</ul>
</li>
<li><p><strong>获取文件名和目录名</strong></p>
<ul>
<li><code>os.path.basename(path)</code>: 返回路径的基本名称（文件名或目录名）。</li>
<li><code>os.path.dirname(path)</code>: 返回路径的目录部分。</li>
</ul>
</li>
<li><p><strong>获取路径信息</strong></p>
<ul>
<li><code>os.path.abspath(path)</code>: 返回路径的绝对路径。</li>
<li><code>os.path.split(path)</code>: 将路径拆分为目录和文件名的元组。</li>
<li><code>os.path.splitext(path)</code>: 将路径拆分为文件名和扩展名的元组。</li>
</ul>
</li>
<li><p><strong>检查路径属性</strong></p>
<ul>
<li><code>os.path.isabs(path)</code>: 检查路径是否是绝对路径。</li>
<li><code>os.path.islink(path)</code>: 检查路径是否是符号链接。</li>
<li><code>os.path.realpath(path)</code>: 返回符号链接的绝对路径。</li>
</ul>
</li>
</ol>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ol>
<li><p><strong>执行系统命令</strong></p>
<ul>
<li><code>os.system(command)</code>: 在系统上执行命令。</li>
</ul>
</li>
<li><p><strong>获取环境变量</strong></p>
<ul>
<li><code>os.getenv(name)</code>: 获取环境变量的值。</li>
<li><code>os.putenv(name, value)</code>: 设置环境变量的值。</li>
</ul>
</li>
<li><p><strong>进程控制</strong></p>
<ul>
<li><code>os.getpid()</code>: 获取当前进程的PID。</li>
<li><code>os.kill(pid, signal)</code>: 向指定PID的进程发送信号。</li>
</ul>
</li>
<li><p><strong>文件描述符操作</strong></p>
<ul>
<li><code>os.open(file, flags[, mode])</code>: 打开文件并返回文件描述符。</li>
<li><code>os.close(fd)</code>: 关闭文件描述符。</li>
</ul>
</li>
</ol>
<p>这些只是<code>os</code>模块中的一部分功能，但覆盖了许多常见的文件和目录操作，以及与操作系统进行交互的基本操作。</p>
<h2 id="python3-os模块-os-walk-函数-详解"><a href="#python3-os模块-os-walk-函数-详解" class="headerlink" title="python3 os模块 os.walk() 函数 详解"></a>python3 os模块 os.walk() 函数 详解</h2><p><code>os.walk()</code> 是 Python <code>os</code> 模块中非常常用的一个函数，主要用于<strong>遍历目录树</strong>。它可以递归地访问一个目录下的所有子目录和文件，非常适合查找文件或批量处理。</p>
<hr>
<h2 id="🔍-一、基本语法"><a href="#🔍-一、基本语法" class="headerlink" title="🔍 一、基本语法"></a>🔍 一、基本语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> os.walk(top, topdown=<span class="literal">True</span>, onerror=<span class="literal">None</span>, followlinks=<span class="literal">False</span>):</span><br><span class="line">    <span class="comment"># 你的代码</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧩-二、参数说明"><a href="#🧩-二、参数说明" class="headerlink" title="🧩 二、参数说明"></a>🧩 二、参数说明</h2><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>top</code></td>
<td>要遍历的目录路径（字符串）</td>
</tr>
<tr>
<td><code>topdown</code></td>
<td>默认为 <code>True</code>，表示从上到下遍历（先访问当前目录，再访问子目录）<br>若为 <code>False</code>，则从下往上遍历（先子目录后当前目录）</td>
</tr>
<tr>
<td><code>onerror</code></td>
<td>可选的错误处理函数（当访问目录出错时调用）</td>
</tr>
<tr>
<td><code>followlinks</code></td>
<td>是否跟踪符号链接（默认为 <code>False</code>）</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔁-三、返回值说明"><a href="#🔁-三、返回值说明" class="headerlink" title="🔁 三、返回值说明"></a>🔁 三、返回值说明</h2><p><code>os.walk()</code> 返回的是一个 <strong>生成器</strong>，每次迭代返回一个 3 元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(dirpath, dirnames, filenames)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>元素</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>dirpath</code></td>
<td>字符串</td>
<td>当前遍历到的目录路径</td>
</tr>
<tr>
<td><code>dirnames</code></td>
<td>列表[str]</td>
<td>当前目录下的子目录名（不含路径）</td>
</tr>
<tr>
<td><code>filenames</code></td>
<td>列表[str]</td>
<td>当前目录下的文件名（不含路径）</td>
</tr>
</tbody></table>
<hr>
<h2 id="📌-四、简单示例"><a href="#📌-四、简单示例" class="headerlink" title="📌 四、简单示例"></a>📌 四、简单示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&#x27;./test_dir&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> os.walk(root_dir):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;当前目录: <span class="subst">&#123;dirpath&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子目录: <span class="subst">&#123;dirnames&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;文件: <span class="subst">&#123;filenames&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当前目录: ./test_dir</span><br><span class="line">子目录: [&#x27;images&#x27;, &#x27;texts&#x27;]</span><br><span class="line">文件: [&#x27;readme.txt&#x27;]</span><br><span class="line"></span><br><span class="line">当前目录: ./test_dir/images</span><br><span class="line">子目录: []</span><br><span class="line">文件: [&#x27;pic1.jpg&#x27;, &#x27;pic2.jpg&#x27;]</span><br><span class="line"></span><br><span class="line">当前目录: ./test_dir/texts</span><br><span class="line">子目录: []</span><br><span class="line">文件: [&#x27;a.txt&#x27;, &#x27;b.txt&#x27;]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🎯-五、常见用法示例"><a href="#🎯-五、常见用法示例" class="headerlink" title="🎯 五、常见用法示例"></a>🎯 五、常见用法示例</h2><h3 id="1-获取所有文件的完整路径"><a href="#1-获取所有文件的完整路径" class="headerlink" title="1. 获取所有文件的完整路径"></a>1. 获取所有文件的完整路径</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dirpath, _, filenames <span class="keyword">in</span> os.walk(root_dir):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        full_path = os.path.join(dirpath, filename)</span><br><span class="line">        <span class="built_in">print</span>(full_path)</span><br></pre></td></tr></table></figure>

<h3 id="2-只查找指定类型的文件（如-txt）"><a href="#2-只查找指定类型的文件（如-txt）" class="headerlink" title="2. 只查找指定类型的文件（如 .txt）"></a>2. 只查找指定类型的文件（如 <code>.txt</code>）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dirpath, _, filenames <span class="keyword">in</span> os.walk(root_dir):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        <span class="keyword">if</span> filename.endswith(<span class="string">&#x27;.txt&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(os.path.join(dirpath, filename))</span><br></pre></td></tr></table></figure>

<hr>
<p>如果你有特定场景，比如只查一层目录、跳过某些文件、或组合 <code>os.walk()</code> 和正则，我也可以进一步讲解。需要吗？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/VSCode/2024-05-22-2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/VSCode/2024-05-22-2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">vscode-常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 18:21:03" itemprop="dateCreated datePublished" datetime="2024-05-22T18:21:03+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vscode/" itemprop="url" rel="index"><span itemprop="name">vscode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>VSCode 编辑器常用的技巧</li>
</ul>
<h2 id="vscode-windows下PATH环境变量更新，vscode未识别"><a href="#vscode-windows下PATH环境变量更新，vscode未识别" class="headerlink" title="vscode windows下PATH环境变量更新，vscode未识别"></a>vscode windows下PATH环境变量更新，vscode未识别</h2><ul>
<li>先退出VSCode</li>
<li>打开cmd窗口，输入并执行 code 命令</li>
<li>在新打开的VSCode的终端里，环境变量已经是最新的</li>
</ul>
<h2 id="vscode-页面切换到左侧工具栏"><a href="#vscode-页面切换到左侧工具栏" class="headerlink" title="vscode 页面切换到左侧工具栏"></a>vscode 页面切换到左侧工具栏</h2><p>在 Visual Studio Code 中，如果你希望将焦点从编辑器切换到左侧的侧边栏（也称为 Activity Bar），可以使用以下方法：</p>
<ol>
<li><p><strong>使用键盘快捷键</strong>：</p>
<ul>
<li>按下 <code>Ctrl + 0</code>（Windows&#x2F;Linux）或者 <code>Cmd + 0</code>（Mac）可以将焦点从编辑器切换到侧边栏的第一个图标。</li>
<li>使用 <code>Ctrl + 1</code>、<code>Ctrl + 2</code>、<code>Ctrl + 3</code> 等数字键（Windows&#x2F;Linux）或者 <code>Cmd + 1</code>、<code>Cmd + 2</code>、<code>Cmd + 3</code> 等数字键（Mac）可以将焦点切换到侧边栏的不同图标。</li>
</ul>
</li>
<li><p><strong>使用鼠标</strong>：</p>
<ul>
<li>直接点击侧边栏的图标来切换到相应的视图，例如资源管理器、搜索、源代码管理等。</li>
</ul>
</li>
</ol>
<p>这些方法可以帮助你快速地将焦点从编辑器切换到左侧的工具栏，以便访问不同的功能和视图。</p>
<h2 id="vscode-分屏显示-切换"><a href="#vscode-分屏显示-切换" class="headerlink" title="vscode 分屏显示 切换"></a>vscode 分屏显示 切换</h2><p>在 Visual Studio Code 中，你可以使用以下快捷键来实现分屏显示和切换：</p>
<ol>
<li><p><strong>分屏显示</strong>：</p>
<ul>
<li>打开第一个文件后，按下 <code>Ctrl + \</code>（Windows&#x2F;Linux）或者 <code>Cmd + \</code>（Mac）来进行分屏显示。这会在当前编辑器的右侧打开一个新的编辑器。</li>
<li>或者，你可以通过右键点击文件选项卡，选择 “Split Editor”。</li>
</ul>
</li>
<li><p><strong>切换焦点</strong>：</p>
<ul>
<li>使用 <code>Ctrl + 1</code>、<code>Ctrl + 2</code> 等数字键（Windows&#x2F;Linux）或者 <code>Cmd + 1</code>、<code>Cmd + 2</code> 等数字键（Mac）来切换到不同的编辑器。</li>
<li>或者，你可以使用 <code>Ctrl + \</code>（Windows&#x2F;Linux）或者 <code>Cmd + \</code>（Mac）来切换焦点到分屏的另一个编辑器。</li>
</ul>
</li>
<li><p><strong>关闭分屏</strong>：</p>
<ul>
<li>在分屏模式下，将鼠标悬停在编辑器的右上角，会看到一个关闭按钮（’X’）。点击该按钮可以关闭分屏。</li>
</ul>
</li>
<li><p><strong>重新分屏</strong>：</p>
<ul>
<li>如果你只剩下一个编辑器，但是想要重新进行分屏，你可以使用 <code>Ctrl + \</code>（Windows&#x2F;Linux）或者 <code>Cmd + \</code>（Mac）来重新分屏。</li>
</ul>
</li>
</ol>
<p>通过这些快捷键，你可以方便地在 Visual Studio Code 中进行分屏显示和切换。</p>
<h2 id="日志断点调试"><a href="#日志断点调试" class="headerlink" title="日志断点调试"></a>日志断点调试</h2><ul>
<li>断点模式设置为日志断点，输入表达式，随即会在output一栏输出</li>
<li>例如输出变量command,则表达式为{command}，随后回车就会输出</li>
</ul>
<h2 id="配置C-智能匹配"><a href="#配置C-智能匹配" class="headerlink" title="配置C++智能匹配"></a>配置C++智能匹配</h2><ul>
<li>open the Command Palette (Ctrl+Shift+P) </li>
<li>enter Select IntelliSense Configuration.</li>
</ul>
<h2 id="配置C"><a href="#配置C" class="headerlink" title="配置C++"></a>配置C++</h2><ul>
<li>You can view the C&#x2F;C++ configuration UI by running the command C&#x2F;C++: Edit Configurations (UI) from the Command Palette (Ctrl+Shift+P).</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/VSCode/2024-05-22-1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/VSCode/2024-05-22-1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">vscode-理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 18:21:03" itemprop="dateCreated datePublished" datetime="2024-05-22T18:21:03+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vscode/" itemprop="url" rel="index"><span itemprop="name">vscode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="VSCode-基础"><a href="#VSCode-基础" class="headerlink" title="VSCode 基础"></a>VSCode 基础</h1><h2 id="vscode-c-cpp-properties-json-excludePath参数-详解"><a href="#vscode-c-cpp-properties-json-excludePath参数-详解" class="headerlink" title="vscode c_cpp_properties.json excludePath参数 详解"></a>vscode c_cpp_properties.json excludePath参数 详解</h2><p>在Visual Studio Code中，<code>c_cpp_properties.json</code>文件是用于配置C&#x2F;C++扩展的解析设置的文件。在该文件中，<code>excludePath</code>参数用于指定应该在解析期间排除的目录。以下是对<code>excludePath</code>参数的详细解释：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Configuration&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;excludePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;$&#123;workspaceFolder&#125;/path/to/excluded_directory&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;$&#123;workspaceFolder&#125;/another/excluded_directory/**/*.cpp&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong><code>$&#123;workspaceFolder&#125;</code></strong>: 这是一个变量，表示当前工作区的根目录。<code>$&#123;workspaceFolder&#125;/**</code>表示将包括工作区中的所有文件和子目录。</p>
</li>
<li><p><strong><code>excludePath</code>数组</strong>: 用于指定要在解析期间排除的目录。可以指定一个或多个目录，并使用相对于<code>$&#123;workspaceFolder&#125;</code>的路径。在上面的示例中，两个目录都被排除了。</p>
<ul>
<li><code>$&#123;workspaceFolder&#125;/path/to/excluded_directory</code>: 表示要排除的第一个目录。</li>
<li><code>$&#123;workspaceFolder&#125;/another/excluded_directory/**/*.cpp</code>: 使用通配符<code>**</code>表示所有子目录和其中的所有<code>.cpp</code>文件都应该被排除。</li>
</ul>
</li>
<li><p><strong>注意事项</strong>:</p>
<ul>
<li>在配置<code>excludePath</code>时，确保使用正确的相对路径，并确保路径是以<code>$&#123;workspaceFolder&#125;</code>为基础的。</li>
<li>你可以使用通配符<code>**</code>来匹配任意目录或文件。在示例中，<code>/**/*.cpp</code>表示匹配任意子目录下的所有<code>.cpp</code>文件。</li>
<li>更改完成后，需要重启Visual Studio Code以使更改生效。</li>
</ul>
</li>
</ol>
<p>通过使用<code>excludePath</code>参数，你可以控制C&#x2F;C++扩展在解析代码时忽略特定的目录，这对于排除不需要进行代码分析的目录非常有用。</p>
<h2 id="解决cpptools-high-cpu问题"><a href="#解决cpptools-high-cpu问题" class="headerlink" title="解决cpptools high cpu问题"></a>解决cpptools high cpu问题</h2><ul>
<li>在VScode菜单栏文件-&gt;首选项-&gt;设置 搜索C_Cpp.intelliSenseCacheSize,修改默认的5120为512</li>
<li></li>
</ul>
<h2 id="调试模式-设置环境变量"><a href="#调试模式-设置环境变量" class="headerlink" title="调试模式 设置环境变量"></a>调试模式 设置环境变量</h2><p>在Visual Studio Code (VSCode) 中，<code>launch.json</code> 文件用于配置调试器的启动选项。当您在VSCode中使用C++进行调试时，可以使用 <code>launch.json</code> 文件设置环境变量以定制调试过程。</p>
<p>以下是如何在 <code>launch.json</code> 文件中设置环境变量的步骤：</p>
<ol>
<li><p>打开 VSCode，并在您的 C++ 项目文件夹中找到或创建 <code>launch.json</code> 文件。通常，该文件位于 <code>.vscode</code> 文件夹中。</p>
</li>
<li><p>在 <code>configurations</code> 字段中添加一个调试配置。如果该字段为空，请复制以下 JSON 代码并粘贴到 <code>launch.json</code> 文件中：</p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C++ Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/&lt;your_executable&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在上面的代码中，<code>environment</code> 字段用于设置环境变量。您可以将需要的环境变量添加到该字段中。每个环境变量都以键值对的形式表示，键和值之间使用冒号分隔。例如，如果要设置名为 <code>MY_ENV_VAR</code> 的环境变量，可以添加如下配置：</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MY_ENV_VAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;your_value&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>保存 <code>launch.json</code> 文件。</p>
</li>
<li><p>在 VSCode 中打开您的 C++ 源代码文件，并在需要调试的行上设置断点。</p>
</li>
<li><p>单击 VSCode 左侧的调试图标（虫子图标），然后点击绿色的“启动调试”按钮。调试器将启动，并在设置的断点处停止。</p>
</li>
<li><p>如果有设置环境变量，它们将在调试过程中生效，您可以在调试过程中使用它们。</p>
</li>
</ol>
<p>请注意：</p>
<ul>
<li>有些调试器可能不支持在 <code>launch.json</code> 文件中设置环境变量。确保您使用的调试器支持此功能。</li>
<li>在 <code>launch.json</code> 文件中设置的环境变量仅对该特定的调试配置生效。如果您有多个调试配置，每个配置可能需要不同的环境变量设置。</li>
</ul>
<p>以上步骤是为了在 VSCode 中通过 <code>launch.json</code> 文件设置 C++ 调试的环境变量。如果您在调试过程中遇到问题，请确保配置正确，并查看调试器的文档以获取更多帮助。</p>
<h2 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h2><ul>
<li><code>word wrap</code></li>
</ul>
<h2 id="VScode-extensions-xhr-failure"><a href="#VScode-extensions-xhr-failure" class="headerlink" title="VScode extensions xhr:failure"></a>VScode extensions xhr:failure</h2><ul>
<li>setting-&gt;details-&gt;Data&amp;Time-&gt;Automatic Time Zone <ul>
<li>open</li>
</ul>
</li>
</ul>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul>
<li><p>首先，在官网找到需要下载的文件，点击下载，并将下载连接复制下来，例如：</p>
<ul>
<li><code>https://az764295.vo.msecnd.net/stable/97dec172d3256f8ca4bfb2143f3f76b503ca0534/code_1.74.3-1673284829_amd64.deb</code></li>
</ul>
</li>
<li><p>然后，将<code>az764295.vo.msecnd.net</code>替换为<code>vscode.cdn.azure.cn</code>，例如：</p>
<ul>
<li><code>https://vscode.cdn.azure.cn/stable/97dec172d3256f8ca4bfb2143f3f76b503ca0534/code_1.74.3-1673284829_amd64.deb</code></li>
</ul>
</li>
<li><p>这就是国内的镜像</p>
</li>
</ul>
<h2 id="使用root用户打开vscode"><a href="#使用root用户打开vscode" class="headerlink" title="使用root用户打开vscode"></a>使用root用户打开vscode</h2><ul>
<li><p>背景：</p>
<ul>
<li>在远程调试机械臂的时候，需要使用到root权限来运行程序，所以在调试的时候需要使用到root权限</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li>示例：<code>code --no-sandbox --disable-gpu-sandbox --user-data-dir=&quot;.vscode-root&quot;</code></li>
</ul>
<!-- + 在`.bashrc`中加入一行代码：
  + `alias code='/usr/share/code/code . --no-sandbox --unity-lanuch'`
+ 然后，直接在终端使用vscode命令打开vscode : `code` --></li>
</ul>
<h2 id="VSCode-是什么"><a href="#VSCode-是什么" class="headerlink" title="VSCode 是什么"></a>VSCode 是什么</h2><ul>
<li><p>VSCode 是什么，VS Code的全称是Visual Studio Code，但这全名实在是太长了，很多用户喜欢叫它VS Code。说起VS Code，官方定义它是一个免费的、开源的跨平台编辑器。之所以强调“编辑器”，我想是因为 VS Code 并无意成为一个全尺寸的集成开发环境，也就是IDE</p>
</li>
<li><p>很多人都把编辑器等同于IDE，其实从专业角度来讲并非这样。IDE 更为关注开箱即用的编程体验、对代码往往有很好的智能理解，同时侧重于工程项目，为代码调试、测试、工作流等都有图形化界面的支持，因此相对笨重，Java程序员常用的Eclipse定位就是IDE；而编辑器则相对更轻量，侧重于文件或者文件夹，语言和工作流的支持更丰富和自由，VS Code 把自己定位在编辑器这个方向上，但又不完全局限于此。</p>
</li>
<li><p>要理解VS Code代码编辑器的设计思路，就需要先看看VS Code的发展轨迹。</p>
</li>
<li><p>从我的角度看，不管你是学习编程语言，还是框架、编辑器，都应该先去看看它的来龙去脉，了解它们是怎么发展而来的，曾经遇到了什么问题，又是怎么解决的，这些信息都便于你从大局上提高对事情本质的认识</p>
</li>
<li><p>VSCode 发展历史：<code>https://geek-docs.com/vscode/vscode-tutorials/what-is-vscode.html</code></p>
</li>
</ul>
<h2 id="VSCode的学习路线"><a href="#VSCode的学习路线" class="headerlink" title="VSCode的学习路线"></a>VSCode的学习路线</h2><ul>
<li><p>简短地了解了 VS Code 的历史后，如果你也认同它的设计哲学和使命，你肯定还想知道该如何把 VS Code 的这一套转化为自己的内力。我在第一讲 “学编辑器，到底应该‘学’什么？” 里讲过编辑器学习的通用办法，在 VS Code 身上也是适用的。你可以按照以下三个步骤来逐步掌握 VS Code。</p>
<ul>
<li>核心编辑器的使用。VS Code 有一套自己的快捷键，你可以通过快捷键的学习了解核心编辑器所支持的功能。同时， VS Code 允许自定义快捷键的映射，如果你有自己熟悉的一套快捷键操作，也可以无缝地在 VS Code 上使用。除了快捷键，VS Code 对鼠标操作、多光标、搜索都有完备的支持；在编程语言的支持上面，VS Code 也向 IDE 看齐，自动补全、代码片段等一应俱全。掌握了核心编辑器，VS Code 就能够胜任你的日常通用编辑器。</li>
<li>工作台、工作区的使用。VS Code 中除了编辑器区域，还有很多其他的功能，像是资源管理器、跨文件搜索、插件管理等，它们一起组成了统一的界面，我们称之为工作台。这个工作台的设计，代表了 VS Code 对工作流的选择。内置的软件版本管理，终端模拟器，调试器等，掌握这些 VS Code “钦定”的工具，进一步提升工作效率。</li>
<li>VS Code 定制和插件开发。作为一个百万级别用户量的工具，很多功能的默认设置不可能满足每个人或者每个工作场景，你可以学习如何定制 VS Code 的各个部件，不能永远按部就班；对于 VS Code 没有实现的功能，还可以学习一下如何使用 JavaScript 书写插件，把自己的想法，变成工具的一部分。</li>
</ul>
</li>
<li><p>通过这三个步骤，你在使用 VS Code 时就能够“随心所欲”了。除此之外，我也建议你关注 VS Code 每月的发布更新日志，官方团队会详细讲解每个版本新增的功能。VS Code 的官方博客也非常值得订阅，团队成员会经常分享开发过程的心得感悟，算得上是最前沿的技术分享。</p>
</li>
</ul>
<h2 id="VSCode入门"><a href="#VSCode入门" class="headerlink" title="VSCode入门"></a>VSCode入门</h2><ul>
<li>主要讲一下“学习”区域的三个功能：命令面板、界面概览和交互式演习场</li>
</ul>
<h3 id="命令面板"><a href="#命令面板" class="headerlink" title="命令面板"></a>命令面板</h3><ul>
<li>首先来看命令面板，它是 VS Code 快捷键的主要交互界面，你可以通过 F1 或者“Cmd+Shift+P ”(Windows 上是 “Ctrl+Shift+P”) 打开。这里提醒一下，如无特殊说明，我在这个专栏里默认基于macOS平台进行讲解，但也会本着为你提供方便的原则，同时给出Windows或Linux平台下的操作说明。通过编辑器来实现高效编程的思路是一致的，这和具体的使用平台无关，所以你大可不必为此担心。</li>
<li>你可以在命令面板中快速搜索命令并且执行。如果你的 VS Code 是简体中文版，那么你可以在命令面板里使用中文或者英文来搜索命令。VS Code 的绝大多数命令都可以在命令面板里搜到，所以熟练使用命令面板，你就可以摆脱鼠标，完全通过键盘操作来完成全部编码工作。</li>
</ul>
<h3 id="界面概览"><a href="#界面概览" class="headerlink" title="界面概览"></a>界面概览</h3><ul>
<li>第二个是界面概览，它展示了 VS Code 默认界面里的不同部件的位置、名称和快捷键。VS Code 强调无鼠标操作，但是对于初学者而言快捷键的记忆是个麻烦，这个界面恰好可以帮助你渡过最初的不适应阶段。</li>
</ul>
<h3 id="交互式演习场"><a href="#交互式演习场" class="headerlink" title="交互式演习场"></a>交互式演习场</h3><ul>
<li>第三个是交互式演习场，打开这个界面，你会看到一个全英文的初学者教程，其中通过各种交互示例给出了 VS Code 的核心功能，展示了一些高级代码编辑功能的使用，每个功能都会有一个代码片段和编辑器供你实时使用。</li>
</ul>
<h3 id="命令行的使用"><a href="#命令行的使用" class="headerlink" title="命令行的使用"></a>命令行的使用</h3><ul>
<li><p>如果你是 Windows用户，安装并重启系统后，你就可以在命令行中使用 code 或者 code-insiders了，如果你希望立刻而不是等待重启后使用，可以将 VS Code 的安装目录添加到系统环境变量 PATH中， Windows 64 位下的 VS Code 安装路径是 C:\Program FIles\Microsoft VS Code下。</p>
</li>
<li><p>如果你希望使用已经打开的窗口来打开文件，可以在 code 命令后添加参数 -r来进行窗口的复用。</p>
</li>
<li><p>你也可以使用参数 <code>-g &lt;file:line[:character]&gt;</code> 打开文件，然后滚动到文件中某个特定的行和列，比如:</p>
<ul>
<li>输入 <code>code -r -g package.json:128</code>命令，你就可以打开 <code>package.json</code> 这个文件，然后自动跳转到 128 行。</li>
<li>这个命令可以方便你从终端里快速地在 VS Code 里打开一个文件进行预览，一个特别常见的例子就是当我们使用脚本执行某个命令，这个命令告诉我们某个文件的某一行出现了错误，我们就能够快速定位了。</li>
</ul>
</li>
<li><p>VS Code 也可以用来比较两个文件的内容，你只需使用 -d参数，并传入两个文件路径，比如:</p>
<ul>
<li>输入 <code>code -r -d a.txt b.txt</code>命令，就可以比较<code>a.txt</code>和<code>b.txt</code>两个文件的内容了。</li>
<li>有了这个命令，你就可以既使用命令行运行脚本，也可以借助 VS Code 的图形化界面进行文件内容的对比了。</li>
</ul>
</li>
<li><p>VS Code 命令行除了支持打开磁盘上的文件以外，也接受来自管道中的数据。这样你就可以将原本在命令行中展示的内容，实时地展示在 VS Code 里，然后在编辑器中搜索和修改。比如,你可以把当前目录下所有的文件名都展示在编辑器里，此时只需使用<code>ls | code -</code>命令。</p>
</li>
</ul>
<h2 id="VSCode-键盘操作"><a href="#VSCode-键盘操作" class="headerlink" title="VSCode 键盘操作"></a>VSCode 键盘操作</h2><ul>
<li>VSCode 键盘操作，做到双手不离键盘，今天先来谈一谈核心的键盘操作：光标的移动、文本的选择、文本的删除，以及如何为编辑器命令绑定快捷键。</li>
</ul>
<h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ul>
<li><p>移动光标最常用的就是方向键，但是方向键每次只能把光标移动一个位置，可以说是一种相对低效的方式。</p>
</li>
<li><p>首先是针对单词的光标移动。这个你应该比较熟悉，绝大多数原生的编辑应用和文本框都支持。这也是我自己最常用的一组快捷键。</p>
<ul>
<li>下面这张图显示，第一行代码中的第一个单词是 function，一共8个字符，光标的位置在第五个字符 t 的后面。当你想把光标直接移动到整个单词，也就是 function 的前面，你只需按下 Option（Windows 上是 Ctrl 键）和左方向键。相反，如果要把光标移动到单词的末尾，只需要按下 Option 和右方向键就好了。</li>
<li>我们都知道，一直按着方向键，光标就可以不停地，一个字符一个字符地在文档中移动。但如果你同时按住 Option 和方向键，那么光标移动的颗粒度就变成了单词，你就可以在文档中以单词为单位不停地移动光标了</li>
</ul>
</li>
<li><p>第二种方式是把光标移动到行首或者行末。比如第一行代码是 function foo() {，你只需按住 Cmd + 左方向键（Windows 上是 Home 键），就可以把光标移动到了这行的第一列；而如果你按住 Cmd 和右方向键（Windows 上是 End 键），光标就会被移动到 { 的后面。</p>
</li>
<li><p>接下来一种是对于<strong>代码块的光标移动</strong>。很多编程语言都使用花括号将代码块包裹起来，比如 if、for 语句等，你很可能会希望通过一个快捷键，就能实现在代码块的始末快速跳转。比如在这5行代码示例中，第一行到第三行代码是函数 foo 的定义，由一对花括号包裹起来，当你把光标放在花括号上时，只需按下 Cmd + Shift + \（Windows 上是 <code>Ctrl + Shift + \</code>），就可以在这对花括号之间跳转。</p>
</li>
<li><p>最后一种基础的光标操作就是移动到文档的第一行或者最后一行，你只需按下 Cmd 和上下方向键即可（Windows 上是 <code>Ctrl + Home/End</code> 键）。</p>
</li>
</ul>
<h3 id="文本选择"><a href="#文本选择" class="headerlink" title="文本选择"></a>文本选择</h3><ul>
<li>掌握了上面的快捷键之后，你还可以非常轻松地掌握文本选择的操作。因为对于基于单词、行和整个文档的光标操作，你只需要多按一个 Shift 键，就可以在移动光标的同时选中其中的文本</li>
</ul>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><ul>
<li><p>比如你想把当前行中光标之前的文本全部删除，就可以先选中这段文本（Windows&#x2F;Linux: Home + Shift，macOS: Cmd + Left + Shift )，然后再按删除键。不过对于频繁使用的删除操作，你肯定希望单次操作就可以完成任务，而不是重复地选择文本然后删除，那么你需要记住下面几个命令。</p>
</li>
<li><p>假设你把光标放在第二行代码的中间位置，然后按下 Cmd 和 Backspace（MacOS上就是“fn + delete”的组合，Windows 上未绑定快捷键，可以打开命令面板运行“删除右侧所有内容”），就能够把第二行代码光标后（右侧）的字符全部删掉。</p>
</li>
<li><p>按下 Cmd 和 Delete 键则是删除当前行中光标前（左侧）的所有内容（Windows 上未绑定快捷键，可以打开命令面板运行“删除左侧所有内容”）</p>
</li>
<li><p>删除单词内的字符与此类似。假设把光标放在第一行第四个字符 c 的后面。Option 加左方向键把光标移动到 function 这个单词的开头，Option加左方向键再加 Shift 即可选中 func 这四个字符，而Option 加 Delete 则会删除 func 这四个字符。这里你可能看出来了，这些快捷键共同的是 Option 键，然后通过按下 Shift 或者 Delete 键，来达到不同的效果。</p>
</li>
<li><p>相反地，Option 加 Backspace（MacOS上就是“fn + delete”的组合） 则会删除 function 的后四个字符 tion。</p>
</li>
</ul>
<h3 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h3><ul>
<li><p>前面我们提到，VS Code 内置了很多的命令，但是并没有为每个命令都提供一个快捷键，毕竟快捷键的组合总是有限的。不过 VS Code 提供了快捷键的修改和自定义功能，这样你就可以根据自己的使用习惯，给自己常用的命令指定顺手的快捷键。</p>
</li>
<li><p>首先你可以打开命令面板（你还记得它的快捷键不？），搜索“打开键盘快捷方式”然后执行，这时你将看到相对应的界面。</p>
</li>
<li><p>然后通过搜索找到你希望修改快捷键的命令，双击，接下来你只要按下你期望的快捷键，最后按下回车键就可以了。</p>
</li>
<li><p>比如，你可以搜索“选择括号内所有内容”，双击，按下”Cmd + Shift + ]”，然后按下回车，这个快捷键就绑定上了。</p>
</li>
<li><p>VS Code 的快捷键修改界面已经考虑到了这一点，你可以在搜索框内搜索你使用的快捷键，然后就可以看到这个快捷键当前对应的命令是哪个。</p>
</li>
</ul>
<h2 id="VSCode-代码行编辑"><a href="#VSCode-代码行编辑" class="headerlink" title="VSCode 代码行编辑"></a>VSCode 代码行编辑</h2><ul>
<li><p>要删掉一行代码，你可以选中它，然后再按 Delete 键。不过还有一个快捷键，那就是直接按下 “ Cmd + Shift + K ” (Windows 上是 “Ctrl + Shift + K”)，当前代码行就可以被删除了。</p>
</li>
<li><p>如果你只是想要剪切这行代码，那么你直接按下 “ Cmd + x ” (Windows 上是 “Ctrl + x”) 即可。</p>
</li>
<li><p>我想你肯定很清楚，“Enter” 键的基础作用是能在编辑器里光标所在的位置添加一个换行符。但是很多时候你可能并不是单纯地要将一行分成两段，而是希望在这行的下面或者上面开始一段新的代码。</p>
</li>
<li><p>这个功能对应的快捷键非常好记，它跟 “Enter”键十分接近。当你想在当前行的下面新开始一行时，你只需按下 “Cmd + Enter” （Windows 上是 “Ctrl + Enter”）；而当你想在当前行的上面新开始一行时，你只要按下 “Cmd + Shift + Enter” （Windows 上是 “Ctrl + Shift + Enter”）就行了</p>
</li>
<li><p>当你想移动一段代码时，一般你可能会分三步走：先选中，再剪切，最后粘贴。不过我更喜欢的是按住 “Option + 上下方向键”（Windows中就是“Alt + 上下方向键”） ，将当前行，或者当前选中的几行代码，在编辑器里上下移动。</p>
</li>
<li><p>如果你同时按住 “Shift” 键的话，也就是 “Option + Shift + 上下方向键”（Windows中就是“Alt + shift + 上下方向键”），那就可以复制这几行，然后粘贴到当前行的上面或者下面。</p>
</li>
<li><p>另外，你在尝试“Option + 上下方向键”这个快捷键“上下移动”时，可能也发现了，当你把一段代码移动到花括号里面或者外面时，代码前的制表符或者空格的数量会自动发生改变，这样你就不需要移动完代码后再调整了。</p>
</li>
</ul>
<h2 id="VSCode-撤销光标移动"><a href="#VSCode-撤销光标移动" class="headerlink" title="VSCode 撤销光标移动"></a>VSCode 撤销光标移动</h2><ul>
<li>VSCode 撤销光标移动，撤销光标的移动和选择。有的时候你移动完光标之后，又希望把光标回退到上一个位置，这时你只需按下 “Cmd + U”（Windows 上是 <code>Ctrl + U</code>），就可以撤销这一次光标的移动。</li>
</ul>
<h2 id="VSCode-行排序"><a href="#VSCode-行排序" class="headerlink" title="VSCode 行排序"></a>VSCode 行排序</h2><ul>
<li>VSCode 行排序。无论是你在写代码，还是写 Markdown，你都可以把代码行按照字母序进行重新排序。不过这个命令比较小众，VS Code 并没有给这个命令指定快捷键，你可以调出命令面板，然后搜索 “按升序排列行” 或者 “按降序排列行” 命令执行。</li>
</ul>
<h2 id="VSCode-合并代码行"><a href="#VSCode-合并代码行" class="headerlink" title="VSCode 合并代码行"></a>VSCode 合并代码行</h2><ul>
<li>VSCode 合并代码行。有的时候你可能会为了避免代码看起来过于冗余，就会把比较短小的几行代码合并到一行里面去。这时，你只需要按下 “ Ctrl + j ” （Windows 上未绑定快捷键，可以打开命令面板，搜索 ”合并行“）就可以了，而不需要不断地调整光标、删除换行符。</li>
</ul>
<h2 id="VSCode-调整字符大小写"><a href="#VSCode-调整字符大小写" class="headerlink" title="VSCode 调整字符大小写"></a>VSCode 调整字符大小写</h2><ul>
<li>VSCode 调整字符大小写，我估计这个你会经常用到。你可以选中一串字符，然后在命令面板里运行“转换为大写”或 “转换为小写”, 来变换字符的大小写。</li>
</ul>
<h2 id="VSCode-调换字符位置"><a href="#VSCode-调换字符位置" class="headerlink" title="VSCode 调换字符位置"></a>VSCode 调换字符位置</h2><ul>
<li>VSCode 调换字符的位置。你可以按下 “Ctrl + t” （Windows 上未绑定快捷键，可以打开命令面板，搜索 ”转置游标处的字符“） 来把当前光标前后的字符调换位置。</li>
</ul>
<h2 id="VSCode-代码缩进"><a href="#VSCode-代码缩进" class="headerlink" title="VSCode 代码缩进"></a>VSCode 代码缩进</h2><ul>
<li>VSCode 代码缩进，有的时候，你会觉得代码格式化太重了，需要的可能只是把代码里的缩进调整一下。这时你可以打开命令面板（快捷键“Cmd + Shift + P”），搜索 “缩进”，然后使用 “重新缩进行” 将整个文档的缩进进行调整，但更多时候，你只需要运行 “重新缩进选中行” 来调整部分选中代码行的缩进。</li>
</ul>
<h2 id="VSCode-代码格式化快捷键"><a href="#VSCode-代码格式化快捷键" class="headerlink" title="VSCode 代码格式化快捷键"></a>VSCode 代码格式化快捷键</h2><ul>
<li><p>VSCode 代码格式化快捷键，我们平常在做自己的小项目或者随便写一些脚本的时候，可能不会太在意代码的格式。不过一旦开始团队合作，整个项目组则会选择同一个代码风格和格式以有效降低协同成本。所以定期对自己写的代码进行格式化是个很好的习惯。</p>
</li>
<li><p>你可以按下 “Option + Shift + F” （Windows 上是 <code>Alt + Shift + F</code>）来对整个文档进行格式化，VS Code 也会根据你当前的语言，选择相关的插件。当然，前提条件是你已经安装了相关插件。</p>
</li>
<li><p>你也可以选中一段代码，然后按下 “Cmd + K Cmd + F” （Windows 上是 Ctrl + K Ctrl + F），这样只有这段被选中的代码才会被格式化。</p>
</li>
</ul>
<h2 id="VSCode-添加代码注释"><a href="#VSCode-添加代码注释" class="headerlink" title="VSCode 添加代码注释"></a>VSCode 添加代码注释</h2><ul>
<li>VSCode 添加代码注释，你在调试代码时，肯定经常需要临时地把一些代码注释掉。如果你要将一行代码注释掉，你只需按下 Cmd + &#x2F; （Windows 上时 <code>Ctrl + /</code>）。如果你需要把一整段代码注释掉，按下 Option + Shift + A即可。</li>
</ul>
<h2 id="VSCode-自动补全"><a href="#VSCode-自动补全" class="headerlink" title="VSCode 自动补全"></a>VSCode 自动补全</h2><ul>
<li><p>VS Code自动补全,VS Code 当中的自动补全内容，其实是由语言服务来提供的。本文介绍VS Code自动补全功能和VS Code自动补全设置。</p>
</li>
<li><p>VS Code 为编程语言工作者提供了统一的 API ，即 Language Server Protocol，每种语言都能够通过实现这个 API 在 VS Code 上得到类似 IDE 的开发体验，而各个语言根据这个 API 实现的服务，就被称为语言服务。</p>
</li>
<li><p>语言服务会根据当前的项目、当前的文件，以及光标所在的位置，为我们提供一个建议列表。这个列表包含了在当前光标位置下我们可能会输入的代码。当我们不断地输入字符，VS Code 就会根据当前输入的字符，在这个列表进行过滤。</p>
</li>
<li><p>如果我们偶尔觉得这个自动补全窗口是多余的，希望暂时不看到它，可以按下 Escape 键将其隐藏。后续如果希望再次看到这个窗口，除了通过打字来将其调出以外，我们还可以按下 <code>“Ctrl + 空格键”</code>来手动地调出建议列表。</p>
</li>
<li><p>刚才我们提到，VS Code 会根据我们输入的字符在这个建议列表里进行过滤。同时，这个过滤是允许我们犯一点小错误的，比如打字特别快的时候少打一个字母，VS Code 也能处理这个情况。比如在下面的动图里，我想使用 console 里的 debug 函数，但是我只打了 db 两个字母，建议列表依然为我提供了 debug 这个选项。</p>
</li>
<li><p>上面的这几个窗口，它们都是通过我们输入的内容自动触发的，也就是说，编程语言决定了我们什么时候看到什么内容。虽然我们可以通过快捷键将其快速地关闭和唤出，但是有的时候自动补全窗口出现得过于频繁，也是会影响我们的编程体验的，毕竟悬浮窗口会遮盖一部分代码，影响我们的阅读。</p>
</li>
<li><p>不过，我们可以通过几个设置，控制自动补全窗口出现的频率和方式，甚至这个窗口的大小。</p>
</li>
<li><p>首先我们可以通过设置 “editor.quickSuggestions” 来决定在什么语境下自动补全窗口会被唤出。默认设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;editor.quickSuggestions&quot;: &#123;</span><br><span class="line">   &quot;other&quot;: true,</span><br><span class="line">   &quot;comments&quot;: false,</span><br><span class="line">   &quot;strings&quot;: false</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个配置有三个选项：other、comments和strings。其中，comments 就是代码注释，strings 就是指字符串。默认情况下，当光标在代码注释或者字符串里，自动补全窗口就不会被自动唤出了。但如果你希望这个窗口永远不被自动唤出，那么你就需要将“other” 也改为 “false”。</li>
</ul>
</li>
<li><p>这时你可能会问了，如果关闭了这个设置，我想看到自动补全该怎么办呢？不用担心，当你按下 “Ctrl + 空格键” 之后，这个窗口依然会被打开，不管设置是关闭还是开启的状态。看到这个设置，你肯定也就明白了，为什么默认情况下你在写注释的时候没有代码自动补全的提示了吧。</p>
</li>
<li><p>参数预览窗口也是一样的，你可以通过参数 “editor.parameterHints.enabled” 将其关闭。当你觉得自己需要看一看参数预览时，按下快捷键或者通过命令面板就能够将其打开了。 </p>
</li>
<li><p>上面的这个设置决定“是与否”的问题，但你也可以控制自动补全窗口出现的时间。自动补全窗口监听文件内容的变化，当你停止输入时，它就会试着给你提供建议。但是有的时候你打字稍微快一些，自动补全窗口才刚刚出现，你就输入了更多的内容，紧接着代码服务就要重新计算并提供建议了。如果你希望减少这种不必要的提示，可以增大设置 “editor.quickSuggestionsDelay” 的值，这样在你输入完代码后，自动补全窗口就会多等一会儿，然后再跳出来。</p>
</li>
<li><p>其他几个自动补全的设置，你可以在设置里搜一搜 “editor.suggest”，自己修改玩一玩。</p>
</li>
<li><p>上面提到的几个功能，它们都依托于语言服务来提供内容。但是有的时候，语言服务并不完美。编辑器于是提供了一种相对 “笨” 一些的提示，那就是基于单词的提示。编辑器通过分析当前的文件里的内容，进行简单的正则表达式匹配，给我们建议已经出现过的单词。</p>
</li>
</ul>
<h2 id="VSCode-文本选择"><a href="#VSCode-文本选择" class="headerlink" title="VSCode 文本选择"></a>VSCode 文本选择</h2><ul>
<li><p>最简单的方式，也是我们每个人最熟悉的方式，就是按住鼠标左键，然后拖动鼠标，直到选中所有我们想要选择的文字为止，再松开鼠标即可。</p>
</li>
<li><p>那是不是说鼠标用户要完成类似的操作，就只能“一点、二拖、三松手”呢？当然不是，VS Code 其实给鼠标也配备了类似的快捷键。</p>
</li>
<li><p>在VS Code中：</p>
<ul>
<li>你单击鼠标左键就可以把光标移动到相应的位置。</li>
<li>而双击鼠标左键，则会将当前光标下的单词选中。</li>
<li>连续三次按下鼠标左键，则会选中当前这一行代码。</li>
<li>最后是连续四次按下鼠标左键，则会选中整个文档。</li>
</ul>
</li>
<li><p>到这里你可能会问，如果我想要使用鼠标，选中其中的多行代码该怎么办？VS Code也考虑到了这个情况，在编辑器的最左边，显示的是每一行的行号。如果你单击行号，就能够直接选中这一行。如果你在某个行号上按下鼠标，然后上下移动，则能够选中多行代码。</p>
</li>
</ul>
<h2 id="VSCode-快速预览"><a href="#VSCode-快速预览" class="headerlink" title="VSCode 快速预览"></a>VSCode 快速预览</h2><ul>
<li>VS Code快速预览是指，有的时候，当我们看到一个建议列表里的某个函数名，我们可能并不能够立刻想起它的作用是什么，它的参数定义是什么样的。</li>
<li>这时候我们可以单击当前这一项建议的最右侧的蓝色图标。</li>
<li>点击这个图标后，建议列表旁边就有出现一个快速预览的窗口，而这个窗口里面呈现的就是这个函数的定义。具体如下图：</li>
<li>除了使用鼠标键外，我们还可以使用 “Ctrl+空格键”组合键来快速调出这个快速预览窗口。</li>
</ul>
<h2 id="VSCode-参数预览"><a href="#VSCode-参数预览" class="headerlink" title="VSCode 参数预览"></a>VSCode 参数预览</h2><ul>
<li>VS Code参数预览,当我们从建议列表选择了一个函数，然后输入括号，准备开始输入参数时，我们会看到一个参数预览的悬浮框。通过这个参数预览的窗口，我们可以知道这个函数可以传入哪些参数，它们的参数类型又是什么样的。</li>
<li>同样的，隐藏这个窗口的快捷键也是 Escape。如果你想再次将其调出的话，需要按下 “Cmd + Shift + Space” （Windows 上是 Ctrl + Shift + Space）。</li>
</ul>
<h2 id="VSCode-重构"><a href="#VSCode-重构" class="headerlink" title="VSCode 重构"></a>VSCode 重构</h2><ul>
<li><p>当我们想要修改一个函数或者变量的名字的时候，我们只需要把光标放到函数或者变量名上，然后按下F2，这样这个函数或者变量出现的地方就都会被修改</p>
</li>
<li><p>这个操作并不是一个粗暴的搜索关键词并替换，在上面的动图中你可以看到，最后一行代码里有个 bar3函数调用，但当我们去重命名 bar这个函数时，bar3并没有受到影响。</p>
</li>
<li><p>除了重命名外，另一个常用的重构的操作就是把一段长代码抽取出来转成一个单独的函数。在VS Code中，我们只需选中那段代码，点击黄色的灯泡图标，然后选择对应的重构操作即可。</p>
</li>
<li><p>要注意的是，并不是每个语言服务都支持重构的操作。如果你选中一段代码后，但没有看到那个黄色的灯泡图标，那么也就是说你使用的这门语言可能还没有支持快速重构。</p>
</li>
</ul>
<h2 id="VSCode-文本编辑"><a href="#VSCode-文本编辑" class="headerlink" title="VSCode 文本编辑"></a>VSCode 文本编辑</h2><ul>
<li><p>VS Code文本编辑，在 VS Code中，我们除了能够使用鼠标来选择文本以外，还能够使用鼠标对文本进行一定程度的修改，我们把它称为拖放功能（drag and drop）。</p>
</li>
<li><p>比如在今天的示例代码中，我们选中 bar 这个函数，然后将鼠标移到这段选中的代码之上，按下鼠标左键不松开。这时你可以看到，鼠标指针已经从一条竖线，变成了一个箭头。这时候我们移动鼠标的话，就可以把这段文本拖拽到我们想要的位置。</p>
</li>
<li><p>在移动的过程当中，我们能够在编辑器中看到一个由虚线构成的光标，当我们松开鼠标左键的时候，这段文本就会被移动到这个虚拟的光标所在的位置。</p>
</li>
<li><p>如果我们在拖拽这段文本的同时，按下 Option 键（Windows 上是 Ctrl 键），鼠标指针上会多一个加号，这时候我们再移动鼠标或虚拟光标至我们想要的位置，然后当我们松开鼠标左键的时候，这段文本将会被复制粘贴到虚拟光标所在的位置，也就是我们既定的目标位置。</p>
</li>
<li><p>你看，在移动鼠标的过程中，多按了个 Option 键（Windows 上是 Ctrl 键），操作结果就由原来的“剪切+粘贴”变为“复制+粘贴”了。</p>
</li>
</ul>
<h2 id="VSCode-多光标"><a href="#VSCode-多光标" class="headerlink" title="VSCode 多光标"></a>VSCode 多光标</h2><ul>
<li><p>VSCode 多光标特性，在我们的日常编码过程中，有很多工作，它本身就是具有“重复”属性的。比如你需要把多个单词的第一个字母从小写变成大写，这种跟业务逻辑相关的重复性操作，编辑器很难为它们一个个单独做优化。</p>
</li>
<li><p>而 VS Code 的多光标特性其实就是用来解决这类问题的。当你在一个文本框或者某个输入框里打入字符时，会有一个竖线来显示你将要输入文字的位置，这就是“光标”。顾名思义，多光标其实就是多个输入位置，这里你可以脑补下多个竖线的场景。</p>
</li>
<li><p>多光标特性允许你在输入框的多个位置创建光标，这样你就可以在多个不同的位置同时输入文字或者执行其他操作</p>
</li>
<li><p>“Cmd + D” 这个命令的作用是，第一次按下时，它会选中光标附近的单词；第二次按下时，它会找到这个单词第二次出现的位置，创建一个新的光标，并且选中它。这样只需要按下三次，你就选中了所有的“5”。这个时候你再按下 “右方向键”，输入“px”，即可完成任务。</p>
</li>
<li><p>接下来讲讲第二种，是跟代码行批量处理有关，也还是用的前面的代码。首先你选择多行代码，然后按下 “Option + Shift + i” （Windows 上是 Alt + Shift + i），这样操作的结果是：每一行的最后都会创建一个新的光标。</p>
</li>
<li><p>不过，VS Code 中还有一个更加便捷的鼠标创建多光标的方式。当然，这首先要求你的鼠标拥有中键。你只需按下鼠标中键，然后对着一段文档拖出一个框，在这个框中的代码就都被选中了，而且每一行被选中的代码，都拥有一个独立的光标。</p>
</li>
</ul>
<h2 id="VSCode-代码跳转和链接"><a href="#VSCode-代码跳转和链接" class="headerlink" title="VSCode 代码跳转和链接"></a>VSCode 代码跳转和链接</h2><ul>
<li>我们还是把鼠标移动到示例代码的第五行 foo 上，然后按下 Cmd 键，这时候 foo下面出现了一个下划线。然后当我们按下鼠标左键，就跳转到了 foo函数的定义处。</li>
</ul>
<h2 id="VSCode-文件跳转"><a href="#VSCode-文件跳转" class="headerlink" title="VSCode 文件跳转"></a>VSCode 文件跳转</h2><ul>
<li>在VS Code中，解决这个问题的第一个方法，就是按下 “Ctrl+Tab”，然后继续按着 “Ctrl”键但是松开 “Tab” 键，这样你就可以打开一个文件列表，这个列表罗列了当前打开的所有文件。接下来，你可以通过按下 “Tab”键在这个列表里跳转，选择你想要打开的文件。最后选到你想打开的文件后，松开 “Ctrl” 键，这个文件就被打开了</li>
<li>还好，VS Code 在命令面板里提供了一种支持搜索的文件跳转方式。当你按下 “Cmd + P” （Windows 上是 Ctrl + P）时，就会跳出一个最近打开文件的列表，同时在列表的顶部还有一个搜索框。</li>
<li>看到这里想必你应该明白了，你可以使用这个搜索框来快速地找到你想要的文件，然后按下 “Enter” 键直接打开，这整个过程简单而且顺畅。</li>
</ul>
<h2 id="VSCode-行跳转"><a href="#VSCode-行跳转" class="headerlink" title="VSCode 行跳转"></a>VSCode 行跳转</h2><ul>
<li>VS Code也提供了一种极为简单的方式来支持行跳转，你只需要按下 “Ctrl + g”，紧接着编辑器就会出现一个输入框</li>
<li>如果你想跳转到某个文件的某一行，你只需要先按下 “Cmd + P”，输入文件名，然后在这之后加上 “:”和指定行号即可。跳转到指定文件的指定行数</li>
</ul>
<h2 id="VSCode-符号跳转"><a href="#VSCode-符号跳转" class="headerlink" title="VSCode 符号跳转"></a>VSCode 符号跳转</h2><ul>
<li><p>VS Code符号跳转，文件跳转和行跳转，是代码跳转的基本操作，也是日常编码中的高频操作。不过有的时候，你可能会希望能够立刻跳转到文件里的类定义，或者函数定义的位置。为了支持这种跳转，VS Code 提供了一套 API 给语言服务插件，它们可以分析代码，告诉 VS Code 项目或者文件里有哪些类、哪些函数或者标识符（我们把这些统称为符号）。</p>
</li>
<li><p>如果要在一个文件里的符号之间跳转，你只需按下 “Cmd + Shift + O” （Windows 上是 Ctrl + Shift + O），就能够看到当前文件里的所有符号。</p>
</li>
<li><p>使用方向键，或者搜索，找到你想要的符号后，按下回车，就能够立刻跳转到那个符号的位置。如下图所示：通过符号功能跳转到指定的代码位置</p>
</li>
<li><p>请注意，在按下 “Cmd + Shift +O”后，输入框里有一个 “@”符号，这个符号在这里的意义，我会在后面的章节里去介绍，你可以先留个心眼。这时，如果你输入 “:”，就可以将当前文件的所有符号，进行分类，这样搜索符号也就更加方便。</p>
</li>
<li><p>有些语言除了提供单个文件里的符号，还支持在多个文件里进行符号跳转。比如在 VS Code 里，如果你打开了多个 JavaScript 文件，就可以按下 “Cmd + T” （Windows 上是 Ctrl + T），搜索这些文件里的符号。</p>
</li>
<li><p>通过“Cmd + T”，搜索多个文件的符号</p>
</li>
</ul>
<h2 id="VSCode-定义和实现间跳转"><a href="#VSCode-定义和实现间跳转" class="headerlink" title="VSCode 定义和实现间跳转"></a>VSCode 定义和实现间跳转</h2><ul>
<li>F12跳转到函数定义的位置</li>
<li>也可以按下 “Cmd + F12” （Windows 上是 Ctrl + F12），跳转到函数的实现的位置。</li>
</ul>
<h2 id="VSCode-跳转到引用的地方"><a href="#VSCode-跳转到引用的地方" class="headerlink" title="VSCode 跳转到引用的地方"></a>VSCode 跳转到引用的地方</h2><ul>
<li><p>VS Code引用跳转，很多时候，除了要知道一个函数或者类的定义和实现以外，你可能还希望知道它们被谁引用了，以及在哪里被引用了。这时你只需要将光标移动到函数或者类上面，然后按下 “Shift + F12”，VS Code 就会打开一个引用列表和一个内嵌的编辑器。在这个引用列表里，你选中某个引用，VS Code 就会把这个引用附近的代码展示在这个内嵌的编辑器里。</p>
</li>
<li><p>Shift+ F12打开函数引用预览</p>
</li>
</ul>
<h2 id="VSCode-代码片段"><a href="#VSCode-代码片段" class="headerlink" title="VSCode 代码片段"></a>VSCode 代码片段</h2><ul>
<li><p>VSCode代码片段，有的时候，我们经常输入的代码是业务强相关的，语言服务没法做出优化；或者是一些我们经常使用的定式，比如循环语句、创建一个新的类或者一个 UI 控件，我们经常写类似的代码，只不过每次都要做细微的修改。对于这些代码，我们可以将它们抽象成模板，保存起来，等下次要使用的时候直接调用即可。</p>
</li>
<li><p>代码片段是对常用代码的一个抽象，它保留了大部分不变的代码，然后把需要经常变动的部分，换成变量，这样等下次调用它的时候，只需要把这些变量换成我们需要的就可以了</p>
</li>
<li><p>首先，我们打开命令面板，搜索“配置用户代码片段”（Configure User Snippets）并且执行。这时候我们会看到一个列表，让我们选择语言。这里我们依然选择 JavaScript 作为我们的示例语言，不用担心，代码都是非常简单和易于理解的。命令面板，搜索“配置用户代码片段”并且执行</p>
</li>
<li><p>选择完语言后，我们就能看到一个 JSON 文件被打开了，这个文件里的内容，现在都是被注释掉的。我们可以选中第七行到第十四行，按下 Cmd+ &#x2F; 取消注释。</p>
</li>
<li><p>在上面的例子里，这个代码片段的名字叫做 Print to console 。这个代码片段对象的值，也就是花括号里的代码，必须要包含 “prefix” 前缀和 “body” 内容这两个属性。同时，这个值还可以包含 “description” 描述这个属性，但这个属性不是必须的。</p>
</li>
<li><p>“prefix” 的作用是，当我们在编辑器里打出跟 “prefix” 一样的字符时，我们就能在建议列表里看到这个代码片段的选项，然后我们按下 Tab 键，就能够将这个代码片段的 “body” 里面的内容插入到编辑器里。如果这个代码片段有 “description” 这个属性的话，那么我们还能够在建议列表的快速查看窗口里看到这段 “description”。</p>
</li>
<li><p>输入 log 即可看到 Print to console 代码片段，然后再按下回车或者 Tab 键，就能够将这个代码片段插入编辑器了。</p>
</li>
</ul>
<h2 id="VSCode-折叠代码快捷键"><a href="#VSCode-折叠代码快捷键" class="headerlink" title="VSCode 折叠代码快捷键"></a>VSCode 折叠代码快捷键</h2><ul>
<li><p>VSCode折叠代码快捷键，我们再来一起看一下有哪些折叠和展开代码的快捷键。首先是折叠和展开代码的两个快捷键。</p>
</li>
<li><p>当我们按下 “Cmd + Option + 左方括号”（Windows 上是 Ctrl + Shift + 左方括号），当前光标所处的最内层的、可以被折叠的代码就会被折叠起来。请注意，我们在这里加了两个限制条件，“最内层”和“可以被折叠”。我们可以先用下面一个小例子来理解这两个条件。</p>
</li>
</ul>
<h2 id="VSCode-小地图"><a href="#VSCode-小地图" class="headerlink" title="VSCode 小地图"></a>VSCode 小地图</h2><ul>
<li><p>如果你是在一个比较大的屏幕上工作，需要快速了解整个文件的全貌，并且还能靠鼠标快速地移动，那么这时小地图就很有用了。这个功能默认是打开的，所以你无需特别设置。这个使用起来比较简单，你可以像我在图中展示的那样试着打开一个较大的文件，感受一下它的妙处。</p>
</li>
<li><p>很多游戏中也有类似的小地图功能，不知道你有没有似曾相识的感觉。</p>
</li>
<li><p>除了控制小地图是否打开，编辑器还为我们提供了几个渲染的配置项。比如说，默认情况下，小地图会将每个字符都渲染出来。但是我们并不能真正地通过小地图来看代码，我们只是要看个大概结构罢了，那么我们可以打开命令面板，搜索“打开设置”（Open Settings），进入设置界面后，搜索 “editor.minimap.renderCharacters” ，找到后将其关闭，这样一来，所有的字符，都会被渲染成一个个小色块。</p>
</li>
<li><p>同样的，我们还可以通过 “editor.minimap.maxColumn” 来控制小地图里每一行渲染多少个字符。很多时候我们只需看下每行代码前的缩进和前面的代码高亮，就能看出个大概来了。</p>
</li>
</ul>
<h2 id="VSCode-单文件搜索"><a href="#VSCode-单文件搜索" class="headerlink" title="VSCode 单文件搜索"></a>VSCode 单文件搜索</h2><ul>
<li><p>VSCode单文件搜索，今天我们重新回到原点，来看一下如何使用编辑器自带的文本搜索功能，快速地穿梭于海量的代码之中。在我看来，一个功能丰富且快速的搜索，在很多情况下甚至会比语言服务还要来得有用。</p>
</li>
<li><p>我们把光标放在编辑器当中，然后按下 “Cmd + F” （Windows 上是 Ctrl + F），就能够快速地调出搜索窗口（可能这个命令你早就发现了或者经常使用了）。当我们调出搜索窗口的时候，编辑器就会把当前光标所在位置的单词自动填充到搜索框中。与此同时，当前文件里和搜索关键词相同的单词都会被高亮出来。</p>
</li>
<li><p>自动填充搜索关键词的好处在于，当我们按下 “Cmd +F” 搜索这个单词之后，我们还能够立刻通过回车键或者 “shift+回车键” 在所有搜索结果当中快速跳转。</p>
</li>
<li><p>这里需要注意的事情是，当我们开始搜索的时候，光标已经被移动到了搜索框当中，如果在这时候我们继续打字的话，那原有的搜索关键词将会被修改。</p>
</li>
<li><p>如果我们希望找到搜索结果后，接下来就直接修改编辑器中的内容，那么就得将光标重新移动到编辑器当中，听起来就挺不方便的，是不是？</p>
</li>
<li><p>这种情况下，我们不妨换一个快捷键。首先我们将光标移动到我们想要搜索的单词处，然后按下 “Cmd + G” （Windows 上是 F3），此时我们同样调出了搜索框，但与前面 “Cmd +F ” 这个快捷键不同的是，这时光标依然是在编辑器当中，而不是在搜索框中。</p>
</li>
<li><p>下面我们再一起来看下这个搜索框中都有哪些功能。</p>
</li>
<li><p>当我们在搜索框中打字的时候，搜索操作是自动触发的，而无需我们再按下回车键去手动地执行搜索这个操作。</p>
</li>
<li><p>除了搜索纯文本以外，搜索框还支持多种不同的搜索方式。比如，在搜索框的最右侧，就有三个配置按钮。</p>
<ul>
<li>第一个是大小写敏感。 这个很好理解，就是在文档中搜索关键词的时候，搜索的结果是否要跟关键词大小写完全一致。默认情况下，VS Code 的搜索是不区分大小写的，也就是说哪怕大小写不一样，也会算到搜索结果里去。但如果我们不想要这个特性，就可以点击这个按钮，或者按下 “Cmd+Option+C” （Windows 上是 Alt + C）来关闭它。</li>
<li>第二个是全单词匹配。 有的时候我们搜索的单词恰好是别的某个单词中间的一部分，如果我们不希望这样的结果出现在搜索结果中，那么就可以点击这个按钮或按下 “Cmd+Option+W” （Windows 上是 Alt + W）来关闭它。</li>
<li>第三个，就是正则表达式匹配了。 当我们点击这个按钮或按下 “Cmd + Option + R” （Windows 上是 Alt + R ），就能够打开正则表达式的支持，然后在搜索框中输入正则表达式来搜索。要注意的是，编辑器中的这个搜索框，它里面的正则表达式使用的是 JavaScript 的正则引擎。</li>
</ul>
</li>
<li><p>这三个功能的快捷键的配置，相信你已经看出其中的诀窍了，它们分别使用了 Case、Word 和 Regular Expression 的第一个字母作为快捷键的一部分，若你知道是这几个单词，那相信对应的快捷键你就不会容易忘了。</p>
</li>
<li><p>我们可以先选中一段文本，然后按下 “Cmd + F” 调出搜索框，这之后点击这个按钮，就可以将这段文本的范围设置为接下来的搜索区域。然后当我们在输入框里输入关键字后，编辑器就只会在这个区域里进行搜索。</p>
</li>
<li><p>上面我们提到的功能，都是 VS Code 的默认行为。但也有部分用户不喜欢搜索框的一部分行为，比如说自动填充搜索关键词。那你可以打开设置，搜索 “editor.find.seedSearchStringFromSelection” 来关闭它。</p>
</li>
<li><p>也有个别用户觉得，如果选中了多行文本，那么当开始搜索时，应该自动地只在这几行代码里进行搜索。要达成这样的目的，你则需要打开设置 “editor.find.autoFindInSelection” 。</p>
</li>
</ul>
<h2 id="VSCode-单文件替换"><a href="#VSCode-单文件替换" class="headerlink" title="VSCode 单文件替换"></a>VSCode 单文件替换</h2><ul>
<li>VSCode单文件替换，在搜索到我们想要的结果之后，我们可以直接在文件中进行修改，也可以使用替换窗口进行批量替换。如果你在使用鼠标或者是触控板的话，只需按一下搜索窗口最左侧的箭头按钮即可打开替换框。</li>
<li>替换框的后面，一共有两个按钮：第一个能够替换单个搜索结果，第二个则能够替换全部的搜索结果。它们对应的快捷键我就不多加赘述，我们只需把鼠标指针移动到它们上面，就能够看到了。</li>
<li>我们也可以通过快捷键直接调出替换窗口。最常用的命令就是按下 “Cmd + Option + F”（Windows 上是 Ctrl + H）键，这样当前光标所在的单词就会被用作为搜索关键词，同时编辑器将光标移动到替换窗口中，我们只需直接输入想要替换的关键词就行了，是不是很便捷呢？</li>
<li>当然，如果你在书写完替换文本后，觉得搜索关键词需要修改，那你可以按下 “Shift + Tab” 键将光标移动到上面的搜索输入框里。“Tab” 和 “Shift + Tab” 键能够帮助你在这两个输入框直接进行跳转。</li>
</ul>
<h2 id="VSCode-多文件搜索和替换"><a href="#VSCode-多文件搜索和替换" class="headerlink" title="VSCode 多文件搜索和替换"></a>VSCode 多文件搜索和替换</h2><ul>
<li><p>多文件搜索的运行方法跟单文件搜索非常类似。单文件搜索，我们是通过按下“Cmd+ F” 来调出搜索窗口的，而多文件搜索则是通过按下 “Cmd + Shift + F” （Windows 上是 Ctrl + Shift + F）来调出多文件搜索的视图。</p>
</li>
<li><p>默认情况下，当我们调出多文件搜索的视图时，VS Code 会在当前打开的文件夹下进行搜索。不过，要发挥多文件搜索的更大功效，我们可以通过书写配置来决定在哪些子文件夹下进行搜索，以及过滤掉哪些特殊的文件或者文件夹。</p>
</li>
<li><p>要完成这样的配置，我们需要点击搜索框下三个点形状的图标，点开后，我们能看到两个输入框，它们的名字分别是“包含的文件” 和 “排除的文件”。这两个配置的书写格式是 glob，很多编程语言和配置都会使用 glob 来模糊匹配文件名和文件夹，估计你已经有所了解。而如果你不熟悉的话，就当作是课后作业了，这一定不是你最后一次需要书写 glob。</p>
</li>
<li><p>第一个是 “search.collapseResults” 。它是用来控制是否自动展开搜索结果。默认的配置是 “auto” 自动， 也就是说，VS Code 会根据搜索结果的多少来决定是否要将某个文件下的搜索结果展开，如果某个文件夹下的结果过多的话，就会将其暂时折叠，用户需要展开结果。我自己喜欢将其设置为 “alwaysExpand”，这样我每次都能直接看到结果了。</p>
</li>
<li><p>第二个是 “search.location” ，也就是多文件搜索视图的位置。默认情况下，搜索视图会出现在侧边栏。但是 VS Code 同样允许你把搜索视图放到底部面板中去，你只需将其修改为 “panel” 即可。相信很多用户都跟我一样，使用过非常多把搜索视图放在底部的开发工具，并且很习惯了，那这个设置就能够帮助到我们。</p>
</li>
</ul>
<h2 id="VSCode-行号"><a href="#VSCode-行号" class="headerlink" title="VSCode 行号"></a>VSCode 行号</h2><ul>
<li>我则是通过更改设置 editor.renderLineHighlight: “all” 把当前代码行的行号下的背景色也修改了，所以你可以看到图 2 的行号 5 的背景色也成为了绿色，整体上看起来更统一。</li>
</ul>
<h2 id="VSCode-渲染出空格符和制表符"><a href="#VSCode-渲染出空格符和制表符" class="headerlink" title="VSCode 渲染出空格符和制表符"></a>VSCode 渲染出空格符和制表符</h2><ul>
<li>在图2中你能够在不少代码行前面看到灰色的“点”，这每一个“点”都代表着一个空格符。你可以通过设置 editor.renderWhitespace: all 让编辑器将所有的空格符、制表符等全部都渲染出来。这样你就能够一眼看出这个文件中使用的究竟是制表符还是空格符，以及有没有在哪里不小心多打了一个空格等。</li>
</ul>
<h2 id="VSCode-缩进参考线和垂直标尺"><a href="#VSCode-缩进参考线和垂直标尺" class="headerlink" title="VSCode 缩进参考线和垂直标尺"></a>VSCode 缩进参考线和垂直标尺</h2><ul>
<li><p>编辑器会根据你指定的制表符的长度，来决定缩进参考线的位置。这样你就可以非常清楚地知道代码有没有正确地缩进，而且也方便你区分出不同代码块之间的层级关系。这个功能是可以通过 editor.renderIndentGuides 来控制开关的。</p>
</li>
<li><p>而图2中的竖线则不一样了，它叫做垂直标尺。如果你的项目中有规定说每一行代码不得超过多少个字符，比如说120个字符，那么你就可以将标尺设置为 120，即 editor.rulers: [120]。这样的话编辑器就会在第120个字符所在的位置处画出这样一条垂直的竖线，所以你一眼就可以看出自己的代码是否达标。</p>
</li>
</ul>
<h2 id="VSCode-光标样式"><a href="#VSCode-光标样式" class="headerlink" title="VSCode 光标样式"></a>VSCode 光标样式</h2><ul>
<li>在图1中，光标是一条竖线，而在图2中光标则相对粗一些。编辑器中的光标样式有非常多种，你可以控制粗细，也可以控制它怎么闪烁。你需要调整的设置是 editor.cursorBlinking editor.cursorStyle 和 editor.cursorWidth。</li>
</ul>
<h2 id="VSCode-如何管理文件和文件夹"><a href="#VSCode-如何管理文件和文件夹" class="headerlink" title="VSCode 如何管理文件和文件夹"></a>VSCode 如何管理文件和文件夹</h2><ul>
<li><p>VS Code是如何管理文件和文件夹，首先需要说明的是，VS Code 的各个功能，都是基于当前打开的文件或者文件夹的。</p>
</li>
<li><p>该怎么去理解这个概念呢？</p>
<ul>
<li>如果你使用过 IDE 的话， 你应该记得在第一次打开 IDE 的时候，它们往往需要你创建一个工程，这个工程会生成一个特殊的工程文件。这个工程文件记载了这个项目有哪些相关的文件、项目的配置、构建脚本等等。这个文件记录着 IDE 管理工程的元信息，开发团队也能够通过共享这个工程文件保证成员工作环境的一致性。但是工程文件对用户体验就不太友好了，比如说项目文件可能对 IDE 的版本有所要求，项目文件损坏了 IDE 读取不了但是我们也不知道如何修复，等等。</li>
</ul>
</li>
<li><p>VS Code 则选择了一种相对轻量，而且大家都易于理解的方式，那就是所有的操作都基于文件和文件夹。当你打开一个文件夹，VS Code 的核心功能就会对这个文件夹进行分析，并提供对应的功能。比如，在打开的文件夹下检测到有 .git 文件，就加载 Git 插件来提供版本管理的功能；或者发现文件夹下有 tsconfig.json ，就会激活 TypeScript 插件提供语言服务</p>
</li>
<li><p>当你第一次打开 VS Code 的时候，工作台中还没有打开任何文件夹。这时候在欢迎界面的左上方，你能够看到：“新建文件”和“打开文件夹”等这样的快捷键。</p>
</li>
<li><p>未打开文件夹，状态栏为紫色</p>
</li>
<li><p>这时候请注意工作台最下方的状态栏，当 VS Code 没有打开任何文件夹的时候，它的颜色是紫色的。而如果在工作台中打开了某个文件夹，状态栏的颜色就会变成蓝色。</p>
</li>
</ul>
<h2 id="VSCode-多文件夹工作区"><a href="#VSCode-多文件夹工作区" class="headerlink" title="VSCode 多文件夹工作区"></a>VSCode 多文件夹工作区</h2><ul>
<li><p>VS Code 多文件夹工作区，多文件夹工作区（multi-root workspace）。老实说呢，这个概念是有一定的理解难度的。</p>
</li>
<li><p>上面我们提到的基于文件夹的这种项目管理方式，从 VS Code 第一天开始就存在了。也几乎从第一天开始，我们就收到了用户对于这一个设计不满的反馈。对于这些不满的用户而言，他们的痛点在于他们经常需要同时对多个文件夹下的代码进行操作。但是 VS Code 关于单个文件夹的这种操作模式，要求了他们必须同时打开多个窗口，并不停地在它们之间切换。</p>
</li>
<li><p>多文件夹工作区就是为了针对这个问题而实现的解决方案。那下面我们就一起来看一看怎样去创建一个多文件夹工作区。</p>
</li>
<li><p>首先，在 VS Code 中打开一个文件夹，此时 VS Code 处于一个单文件夹的状态。然后你可以调出命令面板，搜索 “将文件夹添加到工作区” （add folder to workspace）并执行，或者使用菜单，“文件 —&gt; 将文件夹添加到工作区”，这之后，选择你想要在当前窗口打开的文件夹。</p>
</li>
<li><p>此时在资源管理器里的标题栏里，你能看到“无标题 （工作区）”这样的文字，这说明当前的工作区已经有多个文件夹了，只是现在你还没有保存这个多文件工作区，也没有给它指定一个名字。</p>
</li>
<li><p>要保存这个工作区，接下来你可以调出命令面板，搜索“将工作区另存为” （save workspace as），VS Code 就会为这个工作区创建一个文件，这个文件的后缀名是 “code-workspace”。比如，在下面的动图中，我给这个工作区取名为 sample，然后指定在 Code中这个文件夹下保存。这样操作后，VS Code 就会在 Code 文件夹下创建一个 sample.code-workspace 文件。</p>
</li>
<li><p>你可以看到，操作完之后资源管理器的标题栏已经相应地改变了。另外，sample.code-workspace 虽然有个特殊的后缀，但这个文件的格式其实也是 JSON，你可以自行打开这个文件查看一下。</p>
</li>
<li><p>这个 JSON 文件，默认有两个键（key）。第一个是 folders 文件夹，它里面罗列的是这个多文件工作区里有哪些文件夹。可以看出，这些文件夹的地址，都是这个 sample.code-workspace 文件的相对路径。第二个则是 settings 设置，你可以在这个值里面添加专属于这个多文件夹工作区的设置。它的作用，跟上面我们介绍的 .vscode 文件夹下的 settings.json 文件是类似的。</p>
</li>
</ul>
<h2 id="VSCode-工作区切换"><a href="#VSCode-工作区切换" class="headerlink" title="VSCode 工作区切换"></a>VSCode 工作区切换</h2><ul>
<li>VSCode 工作区切换，如果你同时打开了多个窗口，可以按下 Ctrl + W，或者调出命令面板，搜索 “切换窗口（Switch Window）”，然后选择你要跳转的那个文件夹中去。</li>
<li>如果你只是要跳转到上一个打开的窗口，那就更方便了。打开命令面板，搜索“快速切换窗口（Quick Switch Window）”并执行，就能够直接跳转到之前的窗口了，而无需再做选择。这里我倒是非常建议你给这个命令指定一个快捷键，这样你就能在窗口之间一键切换了。</li>
<li>如果你同一时间只会关注一个项目，那你也大可不必使用多个窗口。我就经常只用一个显示器和一个窗口，然后当我想在另外一个项目上工作时，我就会按下 Ctrl + R（或者使用命令面板，搜索 “打开最近的文件”），此时我就能够看到最近操作过的文件夹并按下回车键进行切换了。</li>
<li>当你按下 Ctrl + R 调出最近打开的文件夹的列表后，也能够按下 Cmd + 回车键，将它在一个新的窗口中打开。</li>
<li>正是因为有上面这几个命令的存在，让我觉得没有多文件夹工作区也是可以的。当然，多文件夹工作区在某些方面的优势是不可比拟的，比如说跨文件夹的代码调试，这个我们后面也会介绍。</li>
</ul>
<h2 id="VSCode-代码调试器"><a href="#VSCode-代码调试器" class="headerlink" title="VSCode 代码调试器"></a>VSCode 代码调试器</h2><ul>
<li><p>VSCode 代码调试器，和语言功能一样，VS Code 是把调试功能的最终实现交给插件来完成的。VS Code 提供了一套通用的图形界面和交互方式，比如怎么创建断点、如何添加条件断点、如何查看当前调试状态下参数的值，等等。无论你使用哪个编程语言或者调试器，这一套交互流程都是相似的。</p>
</li>
<li><p>而对于插件作者而言，他们需要完成的是如何把真正的调试工作跟 VS Code 的界面和交互结合起来，为此 VS Code 为插件作者提供了一套统一的接口，叫做Debug Adapter Protocol（DAP）。当用户在界面上完成一系列调试相关的操作时，VS Code 则通过 DAP 唤起调试插件，由插件完成最终的操作。</p>
</li>
<li><p>VS Code 中有一个专门的用于管理调试功能的视图。我们可以点击界面左侧“昆虫”（也就是 bug 啦）形状的按钮，或者按下 “Cmd + Shift + D” （Windows 上是 Ctrl + Shift + D）来唤出调试视图。</p>
</li>
<li><p>在视图的最上侧，有个绿色的箭头按钮。这个按钮是用于启动调试器的。但是在上面的截图里，你可以看到在绿色箭头的右侧写着 “没有配置”。这说明现在 VS Code 还不知道该使用什么调试器来调试当前的代码。此时点击这个按钮或者按下 F5，我们能够看到一个列表。</p>
</li>
<li><p>首先，我们将鼠标移动到第五行代码的行号前面，点击鼠标左键，我们能够看到一个红色的圆点被创建了出来，这就是断点。当然，我们也可以把光标移动到第五行，然后按下 F9，同样可以在第五行创建断点。</p>
</li>
<li><p>此时，当我们再次点击调试视图上面的绿色箭头按钮，或者按下 F5，启动调试器，并且选择 Node.js ，VS Code 就会进入调试模式。</p>
</li>
<li><p>VSCode 代码调试器配置launch.json介绍，在调试视图的最上方，我们能够看到一个齿轮形状的按钮，它可以用于创建和修改 launch.json 文件。由于当前文件夹下没有 launch.json 文件，所以这个按钮的右上角有个红色的点，它告诉我们当前的调试配置有一点问题，让我们点击这个按钮。</p>
</li>
<li><p>这个 JSON 文件里的 configurations 的值就是当前文件夹下所有的配置了。现在我们只有一个调试配置，它有四个属性：</p>
<ul>
<li>第一个是 type，代表着调试器的类型。它决定了 VS Code 会使用哪个调试插件来调试代码。</li>
<li>第二个是 request，代表着该如何启动调试器。如果我们的代码已经运行起来了，则可以将它的值设为 attach，那么我们则是使用调试器来调试这个已有的代码进程；而如果它的值是 launch，则意味着我们会使用调试器直接启动代码并且调试</li>
<li>第三个属性 name，就是这个配置的名字了。</li>
<li>第四个属性 program，就是告诉 Node.js 调试器，我们想要调试哪个文件。这个值支持预定义参数，比如在上面的例子里，我们使用了${file}，也就是当前编辑器里打开的文件。</li>
</ul>
</li>
<li><p>下面我们把 program 的值改为 ${workspaceFolder}&#x2F;index.js，其中${workspaceFolder} 是代表当前工作区文件夹地址的预定义参数，使用它就能够准确地定位当前工作区里 index.js 文件了。（关于在配置文件里可以使用的预定义参数，请参考Visual Studio Code Variables Reference。 <code>https://code.visualstudio.com/docs/editor/variables-reference</code>）</p>
</li>
<li><p>通用属性</p>
</li>
<li><p>虽然每个调试器各自控制着用户可以使用哪些属性，但是调试器之间还是有很多相同的地方，调试插件在很多时候都会使用相同的属性名来代表同样的功能。比如，我自己就是 Ruby 插件的作者，我在实现 Ruby 调试插件的时候，参考了很多 Node.js 和 PHP 调试插件对于属性的命名和使用。我在书写不同语言的调试配置时，经常使用的有下面这些：</p>
<ul>
<li>program 一般用于指定将要调试的文件。</li>
<li>stopOnEntry，当调试器启动后，是否在第一行代码处暂停代码的执行。这个属性非常方便，如果没有设置断点而代码执行非常快的话，我们就会像文章的最开头那样，代码调试一闪而过，而没有办法在代码执行的过程中暂停了。而设置了 stopOnEntry 后，代码会自动在第一行停下来，然后我们就可以继续我们的代码调试了。</li>
<li>args 参数。相信你应该记得在前面任务系统配置的文章里，我已经说明了可以使用 args 来控制传入任务脚本的参数，同样的，我们也可以通过 args 来把参数传给将要被调试的代码。</li>
<li>env 环境变量。大部分调试器都使用它来控制调试进程的特殊环境变量。</li>
<li>cwd 控制调试程序的工作目录。</li>
<li>port 是调试时使用的端口。</li>
</ul>
</li>
</ul>
<h2 id="VSCode-经典插件推荐"><a href="#VSCode-经典插件推荐" class="headerlink" title="VSCode 经典插件推荐"></a>VSCode 经典插件推荐</h2><ul>
<li>VSCode 经典插件推荐，今天我要介绍的是：能够在某些领域大幅度提高VS Code使用效率和体验的工具。能够取代 VS Code原有功能的工具。对插件 API 的使用别出心裁的工具。</li>
</ul>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul>
<li><p>GitLens</p>
</li>
<li><p>VS Code中的 Git 体验在易用性和完整性之间取得了一个不错的平衡，大部分用户都能够使用它完成工作，同时又不会被太多的功能吓到。但是很多硬核的 Git 用户肯定会觉得功能还不够用。包括但不限于：</p>
<ul>
<li>不能查看某个 commit 中的代码改动；</li>
<li>不能比较两个 commit 或者 branch，然后阅览代码改动；</li>
<li>不能查看代码历史记录。</li>
</ul>
</li>
<li><p>RemoteHub</p>
</li>
<li><p>GitLens 作者 Eric Amodio 又出一款力作——RemoteHub。安装这个插件后，当你想在本地看某个 GitHub repository的代码时，你就不需要将代码 clone 下来了，你可以直接打开这个 repository 相关的工作区，所有文件、文件夹都是从 GitHub 按需下载下来。如果你连接 GitHub 的网速不错的话，那么使用体验可是比 GitHub 网站要好得多。</p>
</li>
<li><p>GitHub Pull Request </p>
</li>
<li><p>除了 Git 支持以外，一个呼声一直非常高的需求，就是在 VS Code中查看和审核 GitHub 上的 Pull Request。好消息是，VS Code团队和 GitHub 的 Editor Tools 团队一起合作，为我们提供了 GitHub Pull Request这个插件。</p>
</li>
</ul>
<h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><ul>
<li><p>Settings Sync</p>
</li>
<li><p>如何在不同设备之间同步个人设置？VS Code自己并没有提供设置的同步，但通过 Settings Sync这个插件，你可以将个人设置同步到 Gist 中。</p>
</li>
<li><p>不过值得注意的是，虽然你的设置是同步到自己私人的 Gist 中，但是如果你的设置中有一些隐私信息，像密码、Token 之类的，还是不要使用此插件比较好。</p>
</li>
<li><p>Project Manager</p>
</li>
<li><p>我们在工作台的部分，介绍过 VS Code支持多文件夹工作区（multi-root workspace），以及如何通过快捷键在不同的项目之间来回切换。如果你不喜欢 VS Code默认的方式，那么你也可以试试 Project Manager。Project Manager 甚至还有一个专门的视图来展示所有的项目，非常方便。</p>
</li>
</ul>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul>
<li><p>VIM</p>
</li>
<li><p>编辑器相关的插件中最厉害的应该就是 Vim 相关的插件了，VS Code提供了一个 API 保证了 Vim 插件能够被正确地实现。不过 Vim 插件并不只有一个，下载量最大的，也是我参与的就是 VSCodeVim，它对 Vim keybings 的覆盖程度非常高。另一个非常受大家欢迎的就是amVim，它的性能也非常不错。</p>
</li>
<li><p>Rainbow Brackets</p>
</li>
<li><p>不管你是不是写函数式语言，当你的代码中有比较多的花括号时，要保证它们对称可以说是非常困难了。Rainbow Brackets这个插件，为同一对花括号指定一个单独的配色，这样你就能够轻松地一眼看出花括号的配对了。</p>
</li>
<li><p>Indent Rainbow</p>
</li>
<li><p>上面的 Rainbow brackets 是给花括号加上多种颜色，而 Indent Rainbow则是为你的代码缩进提供颜色上的提示：</p>
</li>
<li><p>这两个插件有异曲同工之妙，当然我还是建议写代码的时候，不要有太多的层级。</p>
</li>
<li><p>Pigment</p>
</li>
<li><p>既然说到颜色，就不得不提Pigment 这个插件。在介绍择色器（Color Picker）的时候我介绍过，VS Code会在每个颜色前面加上一个方块，用方块来展示代码所对应的颜色。Pigment 则是将颜色渲染在这段代码的下面，我自己还是蛮喜欢这种方式的。</p>
</li>
<li><p>Import Cost</p>
</li>
<li><p>JavaScript 经常被吐槽的一个地方，就是大家对 npm 库的使用程度非常高，经常为了一个简单的功能，引入了几兆甚至十几兆的 npm 包。Import Cost这个插件，很好地在代码中给我们以提示，告诉我们引入的某个包，它最终会导致整个项目的大小增加多少。</p>
</li>
</ul>
<h3 id="调试：Debugger-for-Chrome"><a href="#调试：Debugger-for-Chrome" class="headerlink" title="调试：Debugger for Chrome"></a>调试：Debugger for Chrome</h3><ul>
<li>虽然我们并不介绍语言相关的插件，但是还是有一个调试相关的插件值得一提，那就是 Debugger for Chrome。这个插件，允许在 VS Code中调试前段代码，这样你就不需要再使用 Chrome Dev Tools 了。你可以直接在自己的代码上加上断点，发现错误后直接修改，非常方便。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>Rest Client</p>
</li>
<li><p>我们使用 REST API 的时候，经常需要发送一些样例数据对 API 进行测试，这时我们可以使用 Postman 这类的独立应用，也可以在 VS Code中使用 Rest Client插件，直接在编辑器里发送 REST 请求。</p>
</li>
<li><p>Code Runner</p>
</li>
<li><p>macOS 用户对 Code Runner 这个应用一定非常熟悉了，你可以使用 Code Runner 快速地书写代码并且执行，而无需设置环境配置工程之类的。VS Code里也有这样的插件，如果你有类似的需求，可以试一试。</p>
</li>
<li><p>Live Share</p>
</li>
<li><p>Live Share是微软官方出品的非常强大的服务，通过 Live Share service，你可以将你本地的工作区，直接分享给你的同伴，然后你的同伴就可以直接编辑你的代码，与你共享代码调试、集成终端等等，而无需安装任何环境。Atom 也有类似的服务叫做 Teletype。我工作中每次要和同事 Pair Programming 的时候，就会使用 Live Share。<br>同时 Live Share 服务还支持语音通讯，不过需要安装另一个插件 Live Share Audio。</p>
</li>
</ul>
<h3 id="如何分享插件"><a href="#如何分享插件" class="headerlink" title="如何分享插件"></a>如何分享插件</h3><ul>
<li><p>当然有！你可以通过在项目的 .vscode 文件夹下，创建一个文件 extensions.json。你很熟悉了，这又是一个 JSON 文件，在这个 JSON 文件里，你只需提供一个键（key） recommendations，然后将你想要推荐给这个项目的其他工程师的插件的 ID 们，全部放入到这个数组中。当他们打开这个项目，而且并没有安装这些插件时，VS Code就会给他们提示了。</p>
</li>
<li><p>除了在 .vscode&#x2F;extensions.json 文件推荐插件，如果你在使用多文件夹工作区（multi-root workspace），也可以在多文件夹工作区的配置文件里添加如下的设置：</p>
</li>
</ul>
<h1 id="VSCode-C-配置"><a href="#VSCode-C-配置" class="headerlink" title="VSCode C++ 配置"></a>VSCode C++ 配置</h1><h2 id="三个文件-task-json-launch-json-c-cpp-properties-json"><a href="#三个文件-task-json-launch-json-c-cpp-properties-json" class="headerlink" title="三个文件:task.json launch.json c_cpp_properties.json"></a>三个文件:<code>task.json</code> <code>launch.json</code> <code>c_cpp_properties.json</code></h2><ol>
<li>IntelliSense：Intelligence Sense，代码自动补全</li>
<li>Task.json:<br> 告诉VScode如何编译.cpp文件，配置后将调用g++编译器基于源代码创建可执行文件。<br> 参数：<br> command：设置要运行的指定程序<br> args：参数数组指明要传送给g++的命令行参数，这些参数必须按照编译器要求的顺序来说明<br> ${file}：g++执行的活动文件<br> ${fileDirname}：当前目录<br> label：任务列表中显示的值</li>
<li>launch.json：使用F5启动GDB调试器来调试程序</li>
<li>c_cpp_properties.json：对c&#x2F;c++扩展实现更多控制，可以改变编译器的路径，C++标准以及更多</li>
</ol>
<h2 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h2><ul>
<li>VScode在<code>launch.json</code>调试文件和<code>task.json</code>任务文件中是支持变量替换的，这就意味着可以很方便的使用VScode一些预定以的变量。</li>
<li>变量的使用方式：<code>$&#123;variableName&#125;</code></li>
<li>常用的变量：<ul>
<li><code>$&#123;workspaceFolder&#125;</code> : 项目文件夹在<code>VScode</code>中打开的路径</li>
<li><code>$&#123;file&#125;</code> : 当前打开的文件</li>
<li><code>$&#123;relativeFile&#125;</code> : 相对于<code>$&#123;workspaceFolder&#125;</code>的文件路径</li>
<li><code>$&#123;fileBasename&#125;</code> : 当前打开文件的名称</li>
<li><code>$&#123;fileBasenameNoExtension&#125;</code> : 当前打开文件的名称，不带扩展名</li>
<li><code>$&#123;fileExtname&#125;</code> : 当前打开文件的扩展名</li>
<li><code>$&#123;fileDirname&#125;</code> : 当前打开文件的文件夹名称</li>
</ul>
</li>
</ul>
<h2 id="调试-断点"><a href="#调试-断点" class="headerlink" title="调试 断点"></a>调试 断点</h2><h3 id="日志点，Logpoints"><a href="#日志点，Logpoints" class="headerlink" title="日志点，Logpoints"></a>日志点，<code>Logpoints</code></h3><ul>
<li>日志点是断点的变体，它不会“中断”到调试器中，而是将消息记录到控制台。日志点对于再调试无法暂停或停止的生产服务器时注入日志记录特别有用。(A Logpoint is a variant of a breakpoint that does not “break” into the debugger but instead logs a message to the console. Logpoints are especially useful for injecting logging while debugging production servers that cannot be paused or stopped)</li>
<li>日志消息是纯文本，但可以包含表达式，需要使用花括号</li>
</ul>
<h3 id="表达式条件断点"><a href="#表达式条件断点" class="headerlink" title="表达式条件断点"></a>表达式条件断点</h3><ul>
<li>条件断点是表达式结果为<code>true</code>时才会进行断点</li>
</ul>
<h3 id="命中计数断点"><a href="#命中计数断点" class="headerlink" title="命中计数断点"></a>命中计数断点</h3><ul>
<li>只有该行代码命中了指定次数，才会进行断点</li>
</ul>
<h3 id="内联断点"><a href="#内联断点" class="headerlink" title="内联断点"></a>内联断点</h3><ul>
<li>仅当执行到达与内联断点关联的列时，才会命中内联断点。</li>
<li>这在调试一行中包含多个语句的缩小代码时特别有用。比如for循环，短路运算符等一行代码包含多个表达式时</li>
<li>在指定位置按<code>shift + F9</code></li>
</ul>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li><code>ctrl + p</code> ： 快速搜索文件并跳转，添加<code>:</code>可以跳转到指定行</li>
<li><code>alt + 鼠标左键</code> : 选中多行同时编辑</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Asio/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Asio/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Asio/" itemprop="url" rel="index"><span itemprop="name">Asio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>Asio库相关的理论基础知识</p>
</li>
<li><p>Asio库是仅包含头文件的库</p>
</li>
</ul>
<h2 id="C-Asio库独立版本详解"><a href="#C-Asio库独立版本详解" class="headerlink" title="C++ Asio库独立版本详解"></a>C++ Asio库独立版本详解</h2><p>Boost.Asio 是一个非常流行的 C++ 库，用于实现异步 I&#x2F;O 操作和网络编程。它最初作为 Boost C++ 库的一部分，但后来成为 C++ 标准库的一部分（自 C++11 起）。因此，Boost.Asio 的某些版本也包含在 Boost 库中。</p>
<p>独立版本的 Boost.Asio 是指可单独使用、独立于 Boost 库的版本。它通常是从 Boost 库中分离出来的、具有更轻量级的库。这样的版本可以更容易地集成到项目中，而无需包含整个 Boost 库。</p>
<p>独立版本的 Boost.Asio 通常具有以下特点：</p>
<ol>
<li><strong>独立性：</strong> 它不需要完整的 Boost 库作为依赖，可以单独使用。</li>
<li><strong>轻量级：</strong> 与完整的 Boost 库相比，其体积较小，减少了不必要的依赖。</li>
<li><strong>简化构建和集成：</strong> 由于它是一个独立的库，因此在项目中使用起来更加方便，构建和集成更简单。</li>
</ol>
<p>Boost.Asio 独立版本的详细内容和特性与原始的 Boost.Asio 库非常相似，主要提供异步 I&#x2F;O、TCP、UDP、定时器和网络编程相关的功能。它仍然支持异步事件和异步操作，提供了用于管理 I&#x2F;O 对象、定时器和网络通信的类和函数。</p>
<p>要使用独立版本的 Boost.Asio，你可以从官方的 GitHub 仓库或下载页获取源代码，并按照提供的指南进行构建和集成。通常，独立版本的 Boost.Asio 具有更加现代化和改进的特性，因为它们可能是从较新版本的 Boost 库中提取出来的。</p>
<p>请注意，独立版本的 Boost.Asio 可能会有所不同，具体取决于版本和发布的时间。因此，建议查看官方文档和版本说明以获取特定版本的详细信息和使用说明。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Asio/2024-05-22-1_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Asio/2024-05-22-1_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/" class="post-title-link" itemprop="url">1_2_常用类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Asio/" itemprop="url" rel="index"><span itemprop="name">Asio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Asio常用的类</li>
</ul>
<h2 id="Asio-asio-io-context-详解"><a href="#Asio-asio-io-context-详解" class="headerlink" title="Asio asio::io_context 详解"></a>Asio asio::io_context 详解</h2><p><code>asio::io_context</code> 是 Boost.Asio 库（也是 C++ 标准库中的一部分，自 C++17 起）中的核心类之一。它是实现异步 I&#x2F;O 操作的关键部分，用于驱动异步事件处理。</p>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul>
<li><strong>提供 I&#x2F;O 上下文：</strong> <code>io_context</code> 对象是异步操作的执行上下文，用于管理异步操作、事件处理、任务队列和事件循环。</li>
<li><strong>事件驱动：</strong> 通过 <code>io_context</code>，可以注册异步操作（如套接字操作、定时器事件等），<code>io_context</code> 将在合适的时机进行调度、执行和完成这些异步操作。</li>
</ul>
<h3 id="主要功能和方法："><a href="#主要功能和方法：" class="headerlink" title="主要功能和方法："></a>主要功能和方法：</h3><ul>
<li><strong><code>run()</code>：</strong> 开始 <code>io_context</code> 上的事件循环，处理已注册的所有异步操作，直到所有操作完成或 <code>io_context</code> 被停止。</li>
<li><strong><code>stop()</code>：</strong> 停止 <code>io_context</code> 上的事件循环。停止后，<code>run()</code> 函数将在处理完当前已注册的操作后立即返回。</li>
<li><strong><code>poll()</code>：</strong> 执行 <code>io_context</code> 上的事件循环，但仅处理当前可立即完成的操作，然后立即返回。</li>
<li><strong><code>restart()</code>：</strong> 重新启动已经停止的 <code>io_context</code>。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个定时器</span></span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_context, boost::asio::chrono::seconds(<span class="number">5</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步等待定时器完成</span></span><br><span class="line">    timer.<span class="built_in">async_wait</span>([](<span class="type">const</span> boost::system::error_code&amp; ec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Timer expired!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 上的事件循环，直到所有操作完成</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>io_context</code> 用于驱动异步操作（这里是一个定时器异步等待）。通过调用 <code>run()</code> 方法，<code>io_context</code> 开始处理已注册的异步操作，并在完成所有操作或者遇到停止指令时返回。</p>
<p><code>io_context</code> 是 Boost.Asio 中非常重要的一个类，它为异步操作提供了执行环境，能够有效地管理和调度异步事件，是异步编程的核心。</p>
<h2 id="Asio-asio-thread-pool-详解"><a href="#Asio-asio-thread-pool-详解" class="headerlink" title="Asio asio::thread_pool 详解"></a>Asio asio::thread_pool 详解</h2><p><code>asio::thread_pool</code> 是 Boost.Asio 库中的一个类，它提供了一个线程池，用于管理和执行异步操作。线程池是一种用于管理线程的技术，它可以预先创建一组线程，以便在需要时执行任务或处理异步操作。</p>
<h3 id="主要作用："><a href="#主要作用：" class="headerlink" title="主要作用："></a>主要作用：</h3><ul>
<li><strong>管理线程：</strong> <code>asio::thread_pool</code> 提供了线程池，可用于执行异步操作，避免了频繁创建和销毁线程的开销。</li>
<li><strong>处理异步操作：</strong> 可以将异步操作（如定时器、套接字操作等）提交给线程池，线程池会自动将其分配到可用的线程上执行。</li>
</ul>
<h3 id="主要方法和功能："><a href="#主要方法和功能：" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ul>
<li><strong><code>asio::thread_pool(size_t num_threads)</code> 构造函数：</strong> 创建具有指定数量线程的线程池。</li>
<li><strong><code>~thread_pool()</code> 析构函数：</strong> 销毁线程池，等待所有线程执行完毕并释放资源。</li>
<li><strong><code>submit(Function &amp;&amp; function)</code>：</strong> 提交任务到线程池，执行 <code>function</code> 函数。</li>
<li><strong><code>stop()</code>：</strong> 停止线程池，不再接受新的任务，等待所有任务执行完毕后销毁线程池。</li>
<li><strong><code>join()</code>：</strong> 阻塞等待线程池中的所有任务执行完成。</li>
<li><strong><code>notify_one()</code> 和 <code>notify_all()</code>：</strong> 用于唤醒正在等待的线程。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/thread_pool.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/post.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task executed in thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::<span class="function">asio::thread_pool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// 创建有4个线程的线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务到线程池</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        boost::asio::<span class="built_in">post</span>(pool, task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有任务完成</span></span><br><span class="line">    pool.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，创建了一个具有 4 个线程的线程池 <code>pool</code>，然后向线程池提交了 8 个任务。这些任务会被线程池中的线程异步执行。最后，调用 <code>pool.join()</code> 阻塞等待所有任务执行完成。</p>
<p><code>asio::thread_pool</code> 提供了一种有效地管理和执行异步操作的方式，避免了线程频繁创建和销毁的开销，并提高了异步操作的执行效率。</p>
<h2 id="Asio-asio-ip-tcp-socket-详解"><a href="#Asio-asio-ip-tcp-socket-详解" class="headerlink" title="Asio asio::ip::tcp::socket 详解"></a>Asio asio::ip::tcp::socket 详解</h2><p><code>asio::ip::tcp::socket</code> 是 Boost.Asio 库中用于 TCP 协议的套接字类，用于在 C++ 中进行 TCP 网络通信。</p>
<h3 id="主要作用：-1"><a href="#主要作用：-1" class="headerlink" title="主要作用："></a>主要作用：</h3><ul>
<li><strong>实现 TCP 客户端和服务器：</strong> <code>asio::ip::tcp::socket</code> 允许 C++ 应用程序创建 TCP 客户端或服务器套接字，并进行数据传输。</li>
</ul>
<h3 id="主要方法和功能：-1"><a href="#主要方法和功能：-1" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ul>
<li><strong><code>constructor</code> 构造函数：</strong> 创建 TCP 套接字。</li>
<li><strong><code>open()</code>：</strong> 打开套接字。</li>
<li><strong><code>close()</code>：</strong> 关闭套接字。</li>
<li><strong><code>connect()</code>：</strong> 用于客户端，连接到远程服务器。</li>
<li><strong><code>async_connect()</code>：</strong> 异步连接到远程服务器。</li>
<li><strong><code>bind()</code>：</strong> 将套接字与本地端口或地址绑定。</li>
<li><strong><code>async_bind()</code>：</strong> 异步绑定套接字。</li>
<li><strong><code>listen()</code>：</strong> 在服务器上监听传入连接请求。</li>
<li><strong><code>accept()</code>：</strong> 接受传入的连接请求。</li>
<li><strong><code>async_accept()</code>：</strong> 异步接受传入的连接请求。</li>
<li><strong><code>read_some()</code> 和 <code>write_some()</code>：</strong> 同步读取和写入数据。</li>
<li><strong><code>async_read_some()</code> 和 <code>async_write_some()</code>：</strong> 异步读取和写入数据。</li>
<li><strong><code>shutdown()</code>：</strong> 关闭套接字的输入、输出或全部流。</li>
</ul>
<h3 id="示例（简化的服务器端）："><a href="#示例（简化的服务器端）：" class="headerlink" title="示例（简化的服务器端）："></a>示例（简化的服务器端）：</h3><p>下面是一个简化的 Boost.Asio TCP 服务器端示例，展示了如何使用 <code>asio::ip::tcp::socket</code> 接受连接和读取数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, tcp::endpoint(tcp::v4(), <span class="number">8080</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">        acceptor.<span class="built_in">accept</span>(socket);</span><br><span class="line"></span><br><span class="line">        std::array&lt;<span class="type">char</span>, 128&gt; buffer;</span><br><span class="line">        boost::system::error_code error;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">size_t</span> len = socket.<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(buffer), error);</span><br><span class="line">        <span class="keyword">if</span> (error == boost::asio::error::eof) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Connection closed by peer.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Received data: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(buffer.<span class="built_in">data</span>(), len) &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>asio::ip::tcp::socket</code> 是 Boost.Asio 中用于 TCP 通信的关键类之一，提供了处理 TCP 套接字的方法和功能，可以用于创建 TCP 客户端或服务器，并进行数据的读写操作。</p>
<h2 id="Asio-asio-steady-timer详解"><a href="#Asio-asio-steady-timer详解" class="headerlink" title="Asio asio::steady_timer详解"></a>Asio asio::steady_timer详解</h2><p><code>asio::steady_timer</code> 是 Boost.Asio 库中的一个定时器类，用于在指定时间点执行或触发操作。</p>
<h3 id="主要作用：-2"><a href="#主要作用：-2" class="headerlink" title="主要作用："></a>主要作用：</h3><ul>
<li><strong>定时触发事件：</strong> <code>asio::steady_timer</code> 用于创建定时器对象，可以在设定的时间点之后触发回调函数。</li>
</ul>
<h3 id="主要方法和功能：-2"><a href="#主要方法和功能：-2" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ul>
<li><strong><code>constructor</code> 构造函数：</strong> 创建定时器对象。</li>
<li><strong><code>expires_at()</code> 和 <code>expires_from_now()</code>：</strong> 分别设置定时器的到期时间和到期时刻的相对偏移量。</li>
<li><strong><code>async_wait()</code>：</strong> 异步等待定时器触发。可以向定时器对象提交一个回调函数，在指定时间点触发回调。</li>
<li><strong><code>cancel()</code>：</strong> 取消定时器，终止尚未触发的操作。</li>
<li><strong><code>wait()</code>：</strong> 阻塞等待定时器触发。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><p>下面是一个简单的 Boost.Asio 定时器示例，演示了 <code>asio::steady_timer</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_handler</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Timer expired!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_context, boost::asio::chrono::seconds(<span class="number">5</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步等待定时器触发，并指定回调函数</span></span><br><span class="line">    timer.<span class="built_in">async_wait</span>(timer_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 上的事件循环</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，创建了一个 <code>asio::steady_timer</code> 对象 <code>timer</code>，设置定时器在 5 秒后触发。然后使用 <code>timer.async_wait()</code> 异步等待定时器的触发，并指定了一个回调函数 <code>timer_handler</code>。最后，调用 <code>io_context.run()</code> 运行事件循环，等待定时器触发并执行回调函数。</p>
<p><code>asio::steady_timer</code> 类是 Boost.Asio 中用于管理定时器的重要类之一，允许程序在指定的时间点执行特定操作，通常用于实现定时任务、超时控制等功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Asio/2024-05-22-1_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Asio/2024-05-22-1_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">1_3_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Asio/" itemprop="url" rel="index"><span itemprop="name">Asio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Asio相关的函数</li>
</ul>
<h2 id="Asio-asio-chrono-seconds-函数-详解"><a href="#Asio-asio-chrono-seconds-函数-详解" class="headerlink" title="Asio asio::chrono::seconds()函数 详解"></a>Asio asio::chrono::seconds()函数 详解</h2><p>在 Boost.Asio 中，<code>asio::chrono::seconds()</code> 函数是用于创建时间持续时间（<code>duration</code>）对象的函数，表示以秒为单位的时间段。</p>
<p>这个函数位于 Boost.Asio 的时间相关命名空间中，<code>asio::chrono</code>，用于创建与时间相关的持续时间对象，其中包括 <code>std::chrono::duration</code> 的各种变种。</p>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 asio::chrono::seconds() 创建秒数为 5 的持续时间对象</span></span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(boost::asio::chrono::seconds(<span class="number">5</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印定时器的过期时间（当前时间加上 5 秒）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Timer will expire after 5 seconds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>asio::chrono::seconds(5)</code> 创建了一个表示 5 秒的时间段，然后将该时间段传递给 <code>boost::asio::steady_timer</code> 的构造函数，用于设置定时器在 5 秒后触发。</p>
<p>此函数的作用在于以秒为单位创建时间段，可以用于设置定时器、指定等待时间等场景。 Boost.Asio 中的这些时间函数通常是与异步操作和定时器相关的，使得在异步编程中方便地创建和管理时间段。</p>
<h2 id="Asio-asio-steady-timer-async-wait-函数-详解"><a href="#Asio-asio-steady-timer-async-wait-函数-详解" class="headerlink" title="Asio asio::steady_timer::async_wait() 函数 详解"></a>Asio asio::steady_timer::async_wait() 函数 详解</h2><p><code>asio::steady_timer::async_wait()</code> 是 Boost.Asio 中 <code>steady_timer</code> 类的成员函数，用于异步等待定时器到期并触发回调函数。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> WaitHandler&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_wait</span><span class="params">(WaitHandler&amp;&amp; handler)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><ul>
<li><code>WaitHandler</code>：一个可调用对象，用于处理定时器到期时触发的回调函数。可以是函数指针、函数对象、lambda 函数等。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p><code>async_wait()</code> 函数安排一个异步操作，在指定的定时器到期时执行回调操作。该函数不会阻塞当前线程，而是在设置的时间段之后触发回调函数。</p>
<h3 id="使用示例：-1"><a href="#使用示例：-1" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_handler</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Timer expired!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_context, boost::asio::chrono::seconds(<span class="number">5</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步等待定时器触发，并指定回调函数</span></span><br><span class="line">    timer.<span class="built_in">async_wait</span>(timer_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 上的事件循环</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>async_wait()</code> 函数用于异步等待定时器 <code>timer</code> 到期，并指定了一个名为 <code>timer_handler</code> 的回调函数处理定时器到期时的操作。<code>io_context.run()</code> 开始运行事件循环，等待定时器触发并执行回调函数。</p>
<p>该函数常用于异步编程中，用于设置定时器的到期事件，并在到期时执行相应的操作或回调函数。</p>
<h2 id="Asio-asio-steady-timer-expires-at-函数-详解"><a href="#Asio-asio-steady-timer-expires-at-函数-详解" class="headerlink" title="Asio asio::steady_timer::expires_at() 函数 详解"></a>Asio asio::steady_timer::expires_at() 函数 详解</h2><p><code>asio::steady_timer::expires_at()</code> 是 Boost.Asio 中 <code>steady_timer</code> 类的成员函数之一，用于设置定时器的到期时间点。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TimePoint&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expires_at</span><span class="params">(<span class="type">const</span> TimePoint&amp; time_point)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h3><ul>
<li><code>TimePoint</code>：表示时间点的类型，通常为 <code>std::chrono::time_point</code>，用于指定定时器的到期时间点。</li>
</ul>
<h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><p><code>expires_at()</code> 函数用于设置定时器 <code>steady_timer</code> 的到期时间点。当调用该函数并传递一个特定的时间点参数时，定时器将在指定的时间点触发，即执行定时器的回调函数或触发定时器到期事件。</p>
<h3 id="使用示例：-2"><a href="#使用示例：-2" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器到期时间点为当前时间加上 5 秒</span></span><br><span class="line">    timer.<span class="built_in">expires_at</span>(std::chrono::steady_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步等待定时器触发</span></span><br><span class="line">    timer.<span class="built_in">async_wait</span>([](<span class="type">const</span> boost::system::error_code&amp; ec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Timer expired!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 上的事件循环</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>timer.expires_at()</code> 用于设置定时器 <code>timer</code> 的到期时间点为当前时间加上 5 秒。随后使用 <code>timer.async_wait()</code> 异步等待定时器触发，在定时器到期时执行回调函数。最后，通过 <code>io_context.run()</code> 开始运行事件循环，等待定时器到期并执行回调函数。</p>
<p><code>expires_at()</code> 函数对于预先设置定时器的到期时间非常有用，允许在稍后的时间点触发异步操作，使得在异步编程中更容易地控制定时器的触发时间。</p>
<h2 id="Asio-asio-steady-timer-expiry-详解"><a href="#Asio-asio-steady-timer-expiry-详解" class="headerlink" title="Asio asio::steady_timer::expiry()  详解"></a>Asio asio::steady_timer::expiry()  详解</h2><p>在 Boost.Asio 中，<code>asio::steady_timer::expiry()</code> 是 <code>steady_timer</code> 类的成员函数，用于获取定时器的到期时间点。</p>
<h3 id="方法签名："><a href="#方法签名：" class="headerlink" title="方法签名："></a>方法签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::<span class="function">steady_clock::time_point <span class="title">expiry</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h3><p><code>expiry()</code> 方法用于获取当前设置的定时器 <code>steady_timer</code> 的到期时间点。返回的是一个 <code>std::chrono::steady_clock::time_point</code> 对象，表示定时器将会到期的时间点。</p>
<h3 id="使用示例：-3"><a href="#使用示例：-3" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器到期时间点为当前时间加上 5 秒</span></span><br><span class="line">    timer.<span class="built_in">expires_at</span>(std::chrono::steady_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取定时器的到期时间点并打印</span></span><br><span class="line">    std::chrono::steady_clock::time_point expiry_time = timer.<span class="built_in">expiry</span>();</span><br><span class="line">    std::<span class="type">time_t</span> expiry_time_c = std::chrono::steady_clock::<span class="built_in">to_time_t</span>(expiry_time);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Timer will expire at: &quot;</span> &lt;&lt; std::<span class="built_in">ctime</span>(&amp;expiry_time_c);</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，使用 <code>timer.expires_at()</code> 将定时器 <code>timer</code> 的到期时间点设置为当前时间加上 5 秒。然后调用 <code>expiry()</code> 方法获取定时器的到期时间点，并将其转换为 <code>std::time_t</code> 格式，最后使用 <code>std::ctime()</code> 打印定时器将会到期的时间点。</p>
<p><code>expiry()</code> 方法对于需要了解定时器何时到期的情况非常有用，它允许程序员检查定时器当前的到期时间点，以便在需要时执行相应的操作。</p>
<h2 id="Asio-asio-make-strand-详解"><a href="#Asio-asio-make-strand-详解" class="headerlink" title="Asio asio::make_strand() 详解"></a>Asio asio::make_strand() 详解</h2><p>在 Boost.Asio 中，<code>asio::make_strand()</code> 是一个用于创建 <code>strand</code> 对象的工厂函数。<code>strand</code> 提供了一种同步操作访问序列化（serialized）的方式，用于确保异步操作在多个线程中按照顺序执行，避免出现竞争条件。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutionContext&gt;</span><br><span class="line"><span class="keyword">typename</span> associated_executor&lt;ExecutionContext&gt;::<span class="function">type <span class="title">make_strand</span><span class="params">(ExecutionContext&amp; context)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数说明：-2"><a href="#参数说明：-2" class="headerlink" title="参数说明："></a>参数说明：</h3><ul>
<li><code>ExecutionContext</code>：表示执行上下文的类型，可以是 <code>io_context</code>、<code>strand</code> 或其他支持的执行上下文类型。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回创建的 <code>strand</code> 对象。</li>
</ul>
<h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h3><p><code>make_strand()</code> 函数用于创建一个 <code>strand</code>，它实际上是一个执行器（executor），可以确保在同一个 <code>strand</code> 内排队的操作按顺序执行，而不会发生竞争条件。</p>
<h3 id="使用示例：-4"><a href="#使用示例：-4" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 strand 对象</span></span><br><span class="line">    <span class="keyword">auto</span> strand = boost::asio::<span class="built_in">make_strand</span>(io_context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 strand 内执行异步操作</span></span><br><span class="line">    boost::asio::<span class="built_in">post</span>(strand, []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task 1 executed in strand!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    boost::asio::<span class="built_in">post</span>(strand, []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task 2 executed in strand!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>make_strand()</code> 创建了一个 <code>strand</code> 对象 <code>strand</code>，然后使用 <code>boost::asio::post()</code> 将两个任务（lambda 函数）提交到 <code>strand</code> 内执行。由于这两个任务被提交到同一个 <code>strand</code> 中，它们会按照顺序在该 <code>strand</code> 中执行，避免了并发操作可能引发的竞争条件。</p>
<p><code>strand</code> 对于需要序列化异步操作的情况非常有用，可以确保在一个特定的执行上下文中操作按顺序执行，增加了程序的可靠性和安全性。</p>
<h2 id="Asio-asio-bind-executor-详解"><a href="#Asio-asio-bind-executor-详解" class="headerlink" title="Asio asio::bind_executor() 详解"></a>Asio asio::bind_executor() 详解</h2><p>在 Boost.Asio 中，<code>asio::bind_executor()</code> 是一个用于绑定执行上下文（executor）到处理器（handler）上的函数，它用于创建一个新的处理器对象，将给定的执行上下文绑定到现有的处理器上，从而确保处理器在指定的执行上下文中执行。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Executor, <span class="keyword">typename</span> Handler&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">bind_executor</span><span class="params">(<span class="type">const</span> Executor&amp; ex, Handler&amp;&amp; handler)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数说明：-3"><a href="#参数说明：-3" class="headerlink" title="参数说明："></a>参数说明：</h3><ul>
<li><code>Executor</code>：表示执行上下文的类型，例如 <code>io_context</code> 或 <code>strand</code>。</li>
<li><code>Handler</code>：表示处理器的类型，可以是函数对象、函数指针或者可调用对象。</li>
</ul>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回一个新的处理器对象，将给定的执行上下文与原有的处理器绑定在一起。</li>
</ul>
<h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h3><p><code>bind_executor()</code> 函数用于创建一个新的处理器对象，它在调用原始处理器时，会确保使用提供的执行上下文（executor）进行执行。这样做可以确保处理器在指定的执行上下文中运行，从而实现异步操作的序列化和控制。</p>
<h3 id="使用示例：-5"><a href="#使用示例：-5" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 strand 对象</span></span><br><span class="line">    boost::<span class="function">asio::strand&lt;boost::asio::io_context::executor_type&gt; <span class="title">strand</span><span class="params">(io_context.get_executor())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定执行上下文到处理器</span></span><br><span class="line">    <span class="keyword">auto</span> handler = asio::<span class="built_in">bind_executor</span>(strand, [](<span class="type">const</span> boost::system::error_code&amp; ec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handler executed in strand!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行处理器（实际上是在 strand 内执行）</span></span><br><span class="line">    <span class="built_in">handler</span>(boost::system::<span class="built_in">error_code</span>()); <span class="comment">// 模拟传递错误码</span></span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>asio::bind_executor()</code> 函数将一个处理器对象（lambda 函数）与一个执行上下文（strand）绑定在一起。然后，通过调用返回的新处理器对象 <code>handler</code>，可以确保该处理器在指定的 <code>strand</code> 中运行，从而保证了处理器的操作在该执行上下文中进行。这种绑定执行上下文到处理器的方式常用于确保异步操作的顺序执行或者将处理器绑定到特定的执行上下文中执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-C++17%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-C++17%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" class="post-title-link" itemprop="url">C++17代码整洁之道</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++17代码整洁之道阅读笔记</li>
</ul>
<h2 id="第二章-构建安全体系"><a href="#第二章-构建安全体系" class="headerlink" title="第二章 构建安全体系"></a>第二章 构建安全体系</h2><h3 id="2-3-单元测试"><a href="#2-3-单元测试" class="headerlink" title="2.3 单元测试"></a>2.3 单元测试</h3><ul>
<li><p>单元测试是一小段代码，在特定上下文环境中，单元测试能够执行产品的一部分代码。单元测试能够在很短的时间内，展示出你的代码是否达到了预期的运行结果。</p>
</li>
<li><p>单元测试框架</p>
<ul>
<li>C++的单元测试框架有很多种，例如: CppUnit, Boost.Test, CUTE, Google Test等</li>
<li>一般而言，几个单元测试框架的集合成为xUnit，所有遵循所谓的xUnit的基本设计的单元测试的框架，其结构和功能都是从Smalltalk的SUnit集成而来的。</li>
</ul>
</li>
</ul>
<h3 id="2-5-良好的单元测试原则"><a href="#2-5-良好的单元测试原则" class="headerlink" title="2.5 良好的单元测试原则"></a>2.5 良好的单元测试原则</h3><ul>
<li><p>单元测试的代码的质量</p>
<ul>
<li>高质量的要求产品代码，同样高质量的要求单元测试的代码。更进一步的讲，理论上，产品代码和测试代码之间不应该有任何区别</li>
</ul>
</li>
<li><p>单元测试的命名</p>
<ul>
<li>如果单元测试失败，开发人员希望立即知道以下信息：<ul>
<li>测试单元的名称是什么？谁的单元测试失败了？</li>
<li>单元测试测试了什么？单元测试的环境是怎么样的(测试场景)</li>
<li>预期的单元测试结果是什么？单元测试失败的实例测试结果又是什么</li>
</ul>
</li>
<li>因此，单元测试的命名需要具备直观性和描述性，这是非常重要的</li>
</ul>
</li>
<li><p>首先，以这样的方式命名单元测试模块(依赖于单元测试框架，称为测试用具或者测试夹具)是很好的做法，这样单元测试代码很容易衍生于单元测试框架。单元测试应该有一个像 <Unit_under_Test>Test的名字，很显然，必须用测试对象的名字来替换 <Unit_under_Test>占位符</p>
</li>
<li><p>例如，如果被测试的系统(SUT)是Money单位，与该测试单元对应的单元测试夹具，以及所有的单元测试用例都应该命名为MoneyTest</p>
</li>
<li><p>除此之外，单元测试必须有直观的且易理解的名称，如果单元测试的名称或多或少没有意义，那么单元测试的名称不会有太大的帮助。通过下面的建议，可以为单元测试取一个好名字</p>
<ul>
<li>一般来说，可以在不同场景下使用多种用途的类，一个直观的且易理解的名称应该包含以下三点：<ul>
<li>单元测试的前置条件，也就是执行单元测试之前的SUT的状态</li>
<li>被单元测试测试的部分，通常是被测试的过程，函数或者方法（API）的名称</li>
<li>单元测试预期的测试结果</li>
</ul>
</li>
<li>遵循以上三点建议，测试过程或方法的单元测试命名的模板，如下所示<ul>
<li><PreconditionAndStateOfUnitUnderTest><em><TestedPartOfAPI></em><ExpectedBehavior></li>
</ul>
</li>
<li>示例<ul>
<li>void CustomerCacheTest::cacheIsEmpty_addElement_sizeIsOne();</li>
<li>void MoneyTest::giveTwoMoneyObjectsWithDifferentBalance_theInequalityComparison_Works();</li>
</ul>
</li>
<li>另一个构建直观的且易理解的单元测试名称的方法，就是在单元测试名称中显示特定的需求。这样的单元测试的名称通常能够反应应用程序域的需求</li>
<li>示例<ul>
<li>void UserAccountTest::creatingNewAccountWithExistingEmailAddressThrowsException();</li>
<li>void BookInventoryTest::aBookThatIsAlreadyBorrowedCanNotBeBorrowedTwice();</li>
</ul>
</li>
<li>几乎所有的单元测试框架都会把失败的单元测试名称输出到标准输出</li>
</ul>
</li>
<li><p>单元测试的独立性</p>
<ul>
<li>每个单元测试和其他的单元测试都必须是独立的。如果单元测试之间是以特定的顺序指定的，那么这将是致命的</li>
<li>永远不要编写 一个单元测试的输出是另一个单元测试的输入 的单元测试。当离开一个单元测试的时候，不应该改变测试单元的状态，这是后续单元测试执行的先决条件</li>
</ul>
</li>
<li><p>单元测试环境的独立初始化</p>
<ul>
<li>在运行所有单元测试时，每个单元测试都必须是应用程序的一个独立的可运行的实例，每个单元测试都必须完全自行设置和初始化其所需的环境，着同样适用于执行单元测试后的清理工作。</li>
</ul>
</li>
<li><p>不对getters和setter做单元测试</p>
</li>
<li><p>不对第三方代码做单元测试</p>
<ul>
<li>我们可以预测第三方代码都有自己的单元测试。在你的项目中，不使用那么没有自己的单元测试和质量可疑的库或框架，这是一种明智的架构选择。</li>
</ul>
</li>
<li><p>不对外部系统做单元测试。</p>
</li>
<li><p>如何处理数据库的访问</p>
<ul>
<li>能不使用数据库进行单元测试，就不使用数据库进行单元测试。</li>
<li>只在内存中执行所有的单元测试。</li>
<li>单元测试不要访问数据库，磁盘，网络等外设</li>
<li>数据库测试不是单元测试的内容，它是系统集成和系统测试级别的内容</li>
</ul>
</li>
<li><p>不要混淆测试代码和产品代码</p>
</li>
<li><p>测试必须快速执行</p>
</li>
</ul>
<h2 id="第三章-原则"><a href="#第三章-原则" class="headerlink" title="第三章 原则"></a>第三章 原则</h2><ul>
<li><p>我建议学生们把更多的精力放在学习基本思想上，而不是新技术上，因为新技术在他们毕业之前就有可能过时，而基本思想则永远不会过时。</p>
</li>
<li><p>一般来说，不仅是软件开发，把生活中的一切事情变得尽可能简单并不一定都是坏事。</p>
</li>
<li><p>也就是说，下面这些原则我们不应该学一次就忘掉，建议熟练掌握它们。这些原则非常重要，理想情况下，它们会成为每个开发人员的第二天性。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Asio/2024-12-14-endpoint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Asio/2024-12-14-endpoint/" class="post-title-link" itemprop="url">endpoint</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Asio/" itemprop="url" rel="index"><span itemprop="name">Asio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Asio-asio-ip-tcp-endpoint-是什么"><a href="#Asio-asio-ip-tcp-endpoint-是什么" class="headerlink" title="Asio asio::ip::tcp::endpoint 是什么"></a>Asio asio::ip::tcp::endpoint 是什么</h2><p>在 <strong>Asio</strong>（或 Boost.Asio）中，<code>asio::ip::tcp::endpoint</code> 是一个类，表示一个 <strong>TCP 端点</strong>。它包含了 IP 地址和端口号，用于描述 TCP 网络通信中的目标或源。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p><code>asio::ip::tcp::endpoint</code> 是 TCP 套接字（<code>asio::ip::tcp::socket</code>）操作中的核心组件，用来：</p>
<ol>
<li>指定服务器的地址和端口，作为客户端的目标。</li>
<li>指定本地地址和端口，用于绑定监听服务器或设置客户端绑定信息。</li>
<li>在连接建立后获取对等端的网络信息（如对端 IP 和端口）。</li>
</ol>
<hr>
<h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a><strong>类定义</strong></h3><p><code>asio::ip::tcp::endpoint</code> 是 <code>asio::ip::basic_endpoint&lt;tcp&gt;</code> 的具体实现，用于 TCP 协议。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> asio &#123;</span><br><span class="line"><span class="keyword">namespace</span> ip &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">tcp</span>::endpoint &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">endpoint</span>();                               <span class="comment">// 默认构造，地址为 unspecified，端口为 0</span></span><br><span class="line">        <span class="built_in">endpoint</span>(<span class="type">const</span> address&amp; addr, <span class="type">unsigned</span> <span class="type">short</span> port); <span class="comment">// 使用地址和端口初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置/获取地址</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">address</span><span class="params">(<span class="type">const</span> address&amp; addr)</span></span>;</span><br><span class="line">        <span class="function">address <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置/获取端口</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">port</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">port</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较运算符</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> endpoint&amp; other) <span class="type">const</span>;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> endpoint&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">to_string</span><span class="params">()</span> <span class="type">const</span></span>;           <span class="comment">// 返回可读的字符串表示</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a><strong>常见操作</strong></h3><h4 id="1-创建端点"><a href="#1-创建端点" class="headerlink" title="1. 创建端点"></a><strong>1. 创建端点</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::address addr = asio::ip::<span class="built_in">make_address</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(addr, <span class="number">8080</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这表示一个 TCP 端点，IP 地址是 <code>127.0.0.1</code>，端口号是 <code>8080</code>。</p>
<h4 id="2-默认构造"><a href="#2-默认构造" class="headerlink" title="2. 默认构造"></a><strong>2. 默认构造</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::endpoint endpoint;</span><br></pre></td></tr></table></figure>
<p>创建一个默认的端点，地址为 <code>0.0.0.0</code>（未指定地址），端口为 <code>0</code>。</p>
<h4 id="3-动态绑定（服务器）"><a href="#3-动态绑定（服务器）" class="headerlink" title="3. 动态绑定（服务器）"></a><strong>3. 动态绑定（服务器）</strong></h4><p>当服务器需要绑定一个本地端口时，可以使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line">asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(asio::ip::tcp::v4(), <span class="number">8080</span>)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">open</span>(endpoint.<span class="built_in">protocol</span>());</span><br><span class="line">acceptor.<span class="built_in">bind</span>(endpoint);</span><br><span class="line">acceptor.<span class="built_in">listen</span>();</span><br></pre></td></tr></table></figure>
<p>此处，<code>endpoint</code> 表示监听在 IPv4 地址的所有网络接口（<code>0.0.0.0</code>）上的端口 <code>8080</code>。</p>
<h4 id="4-解析客户端或服务器端地址"><a href="#4-解析客户端或服务器端地址" class="headerlink" title="4. 解析客户端或服务器端地址"></a><strong>4. 解析客户端或服务器端地址</strong></h4><ul>
<li>客户端连接时，解析服务器端点：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::<span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> endpoints = resolver.<span class="built_in">resolve</span>(<span class="string">&quot;example.com&quot;</span>, <span class="string">&quot;80&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>在服务器端，从已接受的连接中获取对端的 IP 和端口：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">accept</span>(socket);</span><br><span class="line">asio::ip::tcp::endpoint remote_endpoint = socket.<span class="built_in">remote_endpoint</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Connected to &quot;</span> &lt;&lt; remote_endpoint.<span class="built_in">address</span>().<span class="built_in">to_string</span>() </span><br><span class="line">          &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; remote_endpoint.<span class="built_in">port</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-转换为字符串"><a href="#5-转换为字符串" class="headerlink" title="5. 转换为字符串"></a><strong>5. 转换为字符串</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(asio::ip::make_address(<span class="string">&quot;192.168.1.1&quot;</span>), <span class="number">12345</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Endpoint: &quot;</span> &lt;&lt; endpoint.<span class="built_in">to_string</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Endpoint: 192.168.1.1:12345</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="重要成员函数"><a href="#重要成员函数" class="headerlink" title="重要成员函数"></a><strong>重要成员函数</strong></h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h4><ol>
<li><p><strong>默认构造</strong></p>
<ul>
<li>创建一个未指定地址和端口的端点（<code>0.0.0.0:0</code> 或 <code>[::]:0</code>）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::<span class="built_in">endpoint</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>地址和端口构造</strong></p>
<ul>
<li>使用指定的 <code>asio::ip::address</code> 和端口初始化。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::<span class="built_in">endpoint</span>(<span class="type">const</span> asio::ip::address&amp; addr, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>协议构造</strong></p>
<ul>
<li>使用协议（IPv4&#x2F;IPv6）和端口初始化，地址为未指定。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::<span class="built_in">endpoint</span>(asio::ip::tcp::<span class="built_in">v4</span>(), <span class="number">8080</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a><strong>成员函数</strong></h4><ol>
<li><p><strong>设置地址</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">address</span><span class="params">(<span class="type">const</span> asio::ip::address&amp; addr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>修改端点的 IP 地址。</p>
</li>
<li><p><strong>获取地址</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::<span class="function">ip::address <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回端点的 IP 地址。</p>
</li>
<li><p><strong>设置端口</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">port</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br></pre></td></tr></table></figure>
<p>修改端点的端口号。</p>
</li>
<li><p><strong>获取端口</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">port</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回端点的端口号。</p>
</li>
<li><p><strong>转换为字符串</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回端点的字符串表示形式，例如 <code>127.0.0.1:8080</code>。</p>
</li>
</ol>
<hr>
<h3 id="典型用例"><a href="#典型用例" class="headerlink" title="典型用例"></a><strong>典型用例</strong></h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line"><span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> endpoints = resolver.<span class="built_in">resolve</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;8080&quot;</span>);</span><br><span class="line"><span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">asio::<span class="built_in">connect</span>(socket, endpoints);</span><br></pre></td></tr></table></figure>

<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a><strong>服务器</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line"><span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, tcp::endpoint(tcp::v4(), <span class="number">8080</span>))</span></span>;</span><br><span class="line"><span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">accept</span>(socket);</span><br><span class="line"></span><br><span class="line">tcp::endpoint remote_endpoint = socket.<span class="built_in">remote_endpoint</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Connected from &quot;</span> &lt;&lt; remote_endpoint.<span class="built_in">to_string</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><code>asio::ip::tcp::endpoint</code> 是 TCP 通信中的一个核心组件，用于描述通信双方的网络位置。它不仅简单易用，而且与其他 Asio 组件（如 <code>tcp::resolver</code>、<code>tcp::socket</code>）紧密配合，为构建高效的网络程序提供了强大支持。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-C++%E6%B2%89%E6%80%9D%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-C++%E6%B2%89%E6%80%9D%E5%BD%95/" class="post-title-link" itemprop="url">C++沉思录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>抽象，是有选择的忽略。</li>
<li>编程依赖于一种选择，<strong>选择什么</strong>和<strong>何时忽略</strong>。</li>
<li>编程就是通过建立抽象来葫芦俄那些我们此刻并不重视的因素</li>
<li>本书坚持以两个思想为核心：实用和抽象</li>
</ul>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul>
<li><p>在处理大问题的时候，这样的工具总是能够帮助将问题分解成<strong>独立的子问题</strong>，并能确保它们相互独立，也就是说当处理问题的某个部分的时候，完全不必担心其他部分</p>
</li>
<li><p>有些抽象不是语言的一部分</p>
</li>
<li><p>文件的概念</p>
<ul>
<li>事实上每种操作系统都以某种方式使文件能为用户所用。在大多数情况下，文件根本不是物理存在的。</li>
<li>文件只是组织长期存储的数据的一种方式，并且由程序和数据结构的集合提供支持来实现这个抽象。</li>
</ul>
</li>
<li><p><strong>通常，我们不可能为特定的工具挑选合适的问题</strong></p>
</li>
</ul>
<h2 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程(OOP)</h2><ul>
<li><p>面向对象编程，指使用继承和动态绑定的编程方式</p>
</li>
<li><p>继承，是一种抽象，它允许程序员在某些时候忽略相似对象间的差异，又在其它时候利用这些差异。</p>
</li>
<li><p>采用这种编译时检查的方式，是因为C++能够为动态绑定的函数调用快速生成代码</p>
</li>
<li><p><strong>只有在程序通过指向基类对象的指针或者基类对象的引用调用虚函数时，才会发生运行时的多态现象。</strong></p>
</li>
<li><p><strong>任何虚函数只有在继承的情况下才有用</strong></p>
</li>
<li><p>对象的创建和复制不是运行时多态的。所以容器：无论是类似于数组或者结构体的内建容器还是用户自定义容器类：<strong>只能获得编译时类型已知的元素值</strong></p>
</li>
<li><p>如果有一系列类之间存在继承关系，当需要创建，复制和存储对象，而这些对象的确切类型只有到运行时才能够知道时，这种编译时的检查会带来一些麻烦</p>
</li>
<li><p>通常，解决这个问题的方法是增加一个间接层。C++采用了一种更自然的方法。就是：定义一个类来提供并且隐藏这个间接层，这种类，通常叫做<strong>句柄(handle)类</strong></p>
</li>
<li><p>句柄类采用最简单的形式，把一个单一类型的对象与一个与之有某种特定继承关系的任意类型的对象捆绑起来。</p>
</li>
<li><p>句柄类的一个常见用户就是通过避免不必要的复制来优化内存管理</p>
</li>
<li><p>容器通常只能包含一种类型的对象，所以很难在容器中存储对象本身</p>
</li>
<li><p>存储指向对象的指针，虽然允许通过继承来处理类型不同的问题，但是也增加了内存分配的额外负担</p>
</li>
<li><p>定义一个行为和<code>Vehicle</code>对象相似，而有潜在地表示了所有继承自<code>Vehicle</code>类的对象的东西。我们把这中类的对象叫做代理(<code>surrogate</code>)</p>
</li>
</ul>
<h2 id="handle-classe"><a href="#handle-classe" class="headerlink" title="handle classe"></a>handle classe</h2><ul>
<li>需要一种方法，让我们在避免某些缺点（如缺乏安全性）的同时能够获取指针的某些优点，尤其是能够在保持多态性的前提下避免复制对象的代价。</li>
<li>C++的解决方法就是定义一个适当的类，由于这些类的对象通常被绑定到它们所控制的类的对象上，所以这些类常被称为<code>handle</code>类(<code>handle classe</code>)。因为这些handle的行为类似指针，所以有时也被称为<strong>智能指针</strong>（<code>smart pointer</code>）</li>
</ul>
<h3 id="引用计数型句柄"><a href="#引用计数型句柄" class="headerlink" title="引用计数型句柄"></a>引用计数型句柄</h3><ul>
<li>之所以要使用句柄，原因之一就是为了避免不必要的对象复制。也就是说，得允许多个句柄绑定到单个对象上</li>
<li>写时复制，<code>copy on write</code>。其有点是只有在绝对必要时才进行复制，从而避免了不必要的复制。在涉及句柄的类库中，这一技术经常用到</li>
</ul>
<h3 id="面向对象程序范例"><a href="#面向对象程序范例" class="headerlink" title="面向对象程序范例"></a>面向对象程序范例</h3><ul>
<li>通常认为，面向对象编程有三个要素：<strong>数据抽象，继承以及动态绑定</strong></li>
<li>解决方法的实质是要对希望模拟的下层系统中的对象进行<strong>建模</strong>。当我们分析出表达式树是有节点和边所构成，便可以设计数据抽象来对树进行建模。</li>
<li>继承让我们抓住了各种节点类型之间的相似之处，而动态绑定帮助我们为各种类型节点定义操作，让编译器来负责安排在运行时能够调用正确的函数。</li>
<li>这样，数据抽象加上动态绑定可以让我们集中精力考虑每个类型的行为和实现，而不必关心与其他对象的交互。</li>
</ul>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul>
<li>在解决问题的时候，有一点要始终牢记，<strong>不仅要看到眼前的问题，还要看到长远的变化。</strong></li>
<li>在实际开发中，灵活性通常是有意义的，因为它使我们面对需求的变更不至于一切推翻重来。至于应当为这种灵活性付出多大代价，当然有一个工程上的权衡问题，只能根据对环境的理解来作出回答。</li>
<li>我们必须清楚，在选择一个设计方案之前，必须首先把问题及其背景搞清楚</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li><strong>虚函数是C++的基本组成部分，也是面向对象编程所必需的</strong>。然而，虚函数并不一定总是适用的</li>
<li>关于虚函数为什么不总是适用，大致有三个原因：<ol>
<li>虚函数有时候会带来很大的消耗</li>
<li>虚函数不总是提供所需的行为</li>
<li>有时候我们写一个类时，可能不想考虑派生的问题</li>
</ol>
</li>
<li>另一个方面，我们还知道了一种必须使用虚函数的情况。当需要删除一个<strong>表面上指向基类对象，实际上却是指向派生类对象的指针，就是需要虚析构函数。</strong></li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul>
<li><p>从某种意义上来说，模板只不过是语法宏的一种受限形式</p>
</li>
<li><p><strong>通常将容器称为模板，而容器内的对象的类型就是模板参数</strong></p>
</li>
<li><p>因此，对于任意类型T，可以想象容器可以是<code>List&lt;T&gt;</code>或者<code>Set&lt;T&gt;</code></p>
</li>
<li><p>模板是<strong>泛型编程</strong>的基础，泛型编程即以一种独立于任何特定类型的方式编写代码</p>
</li>
<li><p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>
</li>
<li><p>每个容器都有一个单一的定义，比如向量，我们可以定义许多不同类型的向量，比如<code>vector&lt;int&gt;</code> 或者<code>vector &lt;string&gt;</code></p>
</li>
<li><p>可以使用模板来定义函数和类</p>
</li>
<li><p>模板函数定义的一般形式如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename type&gt; ret-type func-name(parameter list)&#123;</span><br><span class="line">    // 函数主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在这里，type是函数所使用的数据类型的占位符的名称，这个名称可以在函数定义中使用</p>
</li>
<li><p>类模板，正如定义函数模板一样，也可以定义类模板，泛型类声明的一般形式如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class type&gt; class class-name&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在这里，type是占位符类型名称，可以在类被实例化的时候进行指定。可以使用一个逗号分隔的列表来定义多个泛型数据类型</p>
</li>
<li><p>C++最基本的设计原则就是用类来表示概念。指针把数组的标识和内部空间结合在一起</p>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>通常情况下，每个容器类都有一个或者多个相关的迭代器类型。迭代器能使我们在不暴露容器内部结构的情况下访问容器的元素。</li>
</ul>
<h2 id="模板和泛型算法"><a href="#模板和泛型算法" class="headerlink" title="模板和泛型算法"></a>模板和泛型算法</h2><ul>
<li>1994年7月，在安大略基其纳召开的C++标准会议上，委员会投票通过了一项由Alex Stepanov提出的建议，即将他和他的同事们在Hewlett-Packard实验室开发的一系列泛型算法作为一部分收录到标准C++标准库中。这些被包含到库中的类和算法合起来称为标准模板库（<code>Standard Template Library, STL</code>）</li>
<li>所谓泛型算法，就是这样的算法：对于所操作的数据结构的细节信息，只加入最低限度的了解。当然，理想的情况应该是根本不需要这样的信息，但是现实却不是这样，作为一种折中，STL根据数据结构能够支持的有效操作，将这些数据结构进行分类，然后对于每个算法，它会指出该算法所需要的数据结构类别</li>
<li>被分类的不是算法，也不是数据结构，而是用来访问数据结构的类型。这些类型的对象叫做迭代器。</li>
<li>迭代器共有五种：输入迭代器，输出迭代器，前向迭代器，双向迭代器和随即存取迭代器。</li>
<li>概念继承将这些种类关联起来，之所以称之为“概念的”，是因为这些种类本身都是概念，而不是类型或者对象。</li>
</ul>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><ul>
<li>除了迭代器和配接器外，STL还提供了一种称为函数对象（function object）的概念。</li>
<li>简单地说，函数对象提供了一种方法，将要调用的函数与准备传递给这个函数的隐式参数捆绑起来，这就允许我们使用相当简单的语法来建立复杂的表达式</li>
<li>函数对象表示了一种操作。通过组合函数对象，我们可以得到复杂的操作。</li>
</ul>
<h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><ul>
<li><p>抽象数据类型，ADT</p>
</li>
<li><p>数据抽象的目的就是控制复杂度</p>
</li>
<li><p>C++中的一个更为重要的思想（尽管这个思想不是C++特有的）是：<strong>用户自定义类型可以很容易地当作内建类型使用。通过定义新类型，用户可以为了他们自己的目的来定制语言</strong></p>
</li>
</ul>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><ul>
<li>如果我们准备在接口和实现之间实现完全隔离，就会希望语言支持数据抽象。</li>
<li><strong>C++语言中将接口与实现分隔开的最基本的方法之一就是采用构造函数和析构函数</strong>。正是这两个函数允许类设计者能够说：这个类的对象使用对象本身内容之外的信息。<ul>
<li>构造函数本身提供了生成给定类对象的方法</li>
<li>析构函数则提供了与构造函数相反的行为</li>
</ul>
</li>
</ul>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul>
<li>命名空间解决了一种在C中十分突出而在C++中愈加严重的问题：如何防止不同的程序库设计者为各自组建采用相同的名字</li>
<li>本质上，命名空间允许库设计者对会被库放到全局作用域的所有名称指定一个<strong>包装器（wrapper）</strong>。</li>
</ul>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul>
<li><p>C++的一个基本思想就是：<strong>通过类定义可以明确指明当这个类的对象被构造，销毁，复制和赋值时应该发生什么事情</strong>。这意味着设计的当的类可以为理解程序的动态行为提供一个强有力的工具，这一点往往比人们所认识的更重要</p>
</li>
<li><p>C++程序经常要为一整组对象分配内存，随后将他们同时释放。解决这个问题的方法之一是定义一个包含这样的集合的类。事实证明，为了让一个集合包含不相关的类的对象，一个好方法是使用多重继承。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>一种常见对C++的批评是说该语言太复杂。我认为只有在孤立地看待C++时，这种观点才成立。设计任何一门语言，也可以说是任何软件，都是有特定的背景。</li>
<li>C++面向的是特定的用户群。这个用户群要应付各种复杂的问题，写出要运行相当长时间的解决方案。这些解决方案必须满足任意的性能需求，要工作在不同的硬件和操作平台上，还要和许多已经存在的系统共存。</li>
<li>学习和使用C++的建议：<ul>
<li>做理解的事情；理解要做的事情</li>
<li>逐步加深扩展理解</li>
<li>做练习时要把握分寸，过犹不及</li>
<li>依据操作思考。从C到C++最大的观念性变化就是要停止考虑程序的结构，而开始考虑程序数据的行为。</li>
<li>早些考虑测试</li>
<li>思考。所有的建议都只是建议。是否对你有用是由你决定的。你可以依照我的建议做任何事情，尽量确切的遵循它，或者拼命反其道而行之，或者忽略它，或者对此嗤之以鼻。不管怎么对待，<strong>你都要清楚为什么要这样做</strong>。不管你理不理解都要对结果负责。</li>
</ul>
</li>
</ul>
<h2 id="采访"><a href="#采访" class="headerlink" title="采访"></a>采访</h2><ul>
<li><p>是否应该更加重视标准库教育，而不是语言细节的教育？</p>
</li>
<li><p>当然是库优先于语言细节。两个原因：</p>
<ul>
<li>首先，学生们可以不必费力包装低层次的语言细节，从而更容易建立整体语言的全局观念，了解到其真实威力。不过根据我们的经验，<strong>学生们首先掌握如何使用程序库之后，就会很容易理解类的概念，学会如何构造类的技术</strong>。如果首先去学习语言细节，那么就很难理解类的概念及其功能。这种理解上的缺陷，使他们很难设计和构造自己的类。</li>
<li>更重要的一点是，首先学习程序库，能够是学生培养起良好的习惯，就是复用库代码，而不是凡事自己动手。首先学习语言细节的学生，最后的编程风格往往是C类型的，而不是C++风格。他们不会充分地运用库，而自己的程序带有严重的C主义倾向：指针满天飞，整个程序都是低层次的。结果是，在很多情况下，你为C++的复杂性付出了高昂代价，却没有从中获得任何好处。</li>
</ul>
</li>
<li><p>一个问题产生良好的设计方案的途径，就是使用一种允许你进行各种设计的工具。这样一来，你就可以选择最适合该问题的设计方案。如果你选择了这样的工具，那么你就必须负责选择合适的设计方案。</p>
</li>
<li><p>为什么认为“基于对象”和“基于模板”的抽象机制优先于面向对象抽象机制？</p>
</li>
<li><p>所谓面向对象编程，就是使用继承和动态绑定机制编程。如果你知道有一个很好的程序使用了继承和动态绑定，你能作出怎样的推断？在我们看来，这意味着该程序中有两个或两个以上的类型，至少有一个共同的操作，也至少有一个不同的操作。否则就不需要继承机制。此外，程序中必然有一个场景，需要在运行时从这些类型中挑选出一个，否则就不需要动态绑定机制</p>
</li>
<li><p>某些面向对象编程语言，如Python，其所有类型都是动态的，那么技术书籍的作者就不会面对这样的问题。例如，C++中的容器类大多数用模板写成，因其可以容纳毫无共同之处的对象，所以要求元素类型必须是某个共同基类的派生类毫无道理。然而，在Python中，容器类中本来就可以放置任何对象，所以类似模板那样的类型机制就不必要了。</p>
</li>
<li><p>所以，我认为你所看到的问题，其实是因为很难找到又小又好的面向对象程序做范例，才会产生的。而且，对于其他语言必须依赖动态类型才能解决的问题，C++能够使用模板来高效地解决。</p>
</li>
<li><p>如果我说我只能记住你的一句话，那一定是：用类来表示概念。假设再记住一句话，应该是什么？</p>
</li>
<li><p>避免重复。如果发现自己在程序的两个不同部分里做了相同的事情，试着把这两个部分合并到一个子过程中。如果发现两个类的行为相近，试着把这两个类的相似部分统一到基类或模板中</p>
</li>
<li><p>我们都希望成为更好的C++程序员，请给我们三那个你认为最重要的建议。</p>
<ul>
<li>避免使用指针</li>
<li>提倡使用程序库</li>
<li>使用类来表示概念</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-C++Primerplus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-C++Primerplus/" class="post-title-link" itemprop="url">C++Primerplus</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="C-简介"><a href="#C-简介" class="headerlink" title="C++简介"></a>C++简介</h3><ul>
<li>C++融合了三种不同的编程方式：<ul>
<li>C语言代表的过程性语言</li>
<li>C++在C语言基础上添加的类代表的面向对象语言</li>
<li>C++模板支持的泛型编程</li>
</ul>
</li>
</ul>
<h3 id="C-简史"><a href="#C-简史" class="headerlink" title="C++简史"></a>C++简史</h3><ul>
<li><p>汇编语言，依赖于计算机的内部机器语言。</p>
</li>
<li><p>它是低级语言(low-level)，即直接操作硬件，例如直接访问CPU寄存器和内存单元。因此，汇编语言针对于特定的计算机处理器，要将汇编程序移植到另一种计算机上，必须使用不同的汇编语言重新编写程序</p>
</li>
<li><p>高级语言(high-level)，致力于解决问题，而不针对特定的硬件。</p>
</li>
<li><p>一种被称为<strong>编译器</strong>的特殊程序将高级语言翻译成特定计算机的内部语言。这样，就可以通过对每个平台使用不同的编译器来在不同的平台上使用同一个高级语言程序了</p>
</li>
<li><p>一般来说，计算机语言要处理两个概念–数据和算法</p>
<ul>
<li>数据，是程序使用和处理的信息</li>
<li>算法，是程序使用的方法</li>
</ul>
</li>
<li><p>结构化编程，将分支（决定接下来应执行哪个指令）限制为一小组行为良好的结构。</p>
</li>
<li><p>C语言的词汇表中就包含了这些结构：for循环，while循环，do while循环，if else语句</p>
</li>
<li><p><strong>结构化编程技术反映了过程性编程的思想，根据执行的操作来构思一个程序</strong></p>
</li>
<li><p>面向对象编程(OOP)，与强调算法的过程性编程不同的是，OOP强调的是数据。它不像过程性编程那样，试图使问题满足语言的过程性方法，而是试图<strong>让语言来满足问题的要求</strong>。其理念是设计与问题的本质特性相对应的数据格式。</p>
</li>
<li><p><strong>在C++中，类是一种规范，它描述了这种新型数据格式，对象是根据这种规范构造的特定数据结构。</strong></p>
</li>
<li><p>OOP程序设计方法首先设计类，它们准确地表示了程序要处理的东西。类定义描述了对每个类可执行的操作，然后便可以设计一个使用这些类的对象的程序。</p>
</li>
<li><p>从低级组织（如类）到高级组织（如程序）的处理过程，叫做自下向上(bottom-up)的编程</p>
</li>
<li><p>OOP编程并不仅仅是将数据和方法合并为类定义。</p>
<ul>
<li>它还有助于创建可重用的代码，这将减少大量的工作。</li>
<li>信息隐藏可以保护数据</li>
<li>多态能够为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义</li>
<li>继承能够使用旧类派生出新类</li>
</ul>
</li>
<li><p>OOP引入了很多新的理念，使用的编程方法不同于过程性编程。它不是将重点放在任务上，而是放在表示概念上。</p>
</li>
<li><p>泛型编程(generic programming)是C++支持的另一种编程模式。它与OOP的目标相同，即使重用代码和抽象通用概念的技术更简单。</p>
</li>
<li><p>不过OOP强调的是编程的数据方便，而泛型编程强调的是独立于特定数据类型。它们的侧重点不同。</p>
</li>
<li><p>OOP是一个管理大型项目的工具，而泛型编程提供了执行常见任务（例如对数据排序或合并链表）的工具。</p>
</li>
<li><p>术语泛型(generic)指的是，创建独立于类型的代码。</p>
<ul>
<li>C++的数据表示有多种类型–整数，小数，字符，字符串，用户定义的，由多种类型组成的符合结构。</li>
<li>例如，要对不同类型的数据进行排序，通常必需为每种类型创建一个排序函数。</li>
<li>泛型编程需要对语言进行扩展，以便可以只编写一个泛型（即不是特定类型的）函数，并将其用于各种实际类型。</li>
<li>C++模板提供了完成这种任务的机制。</li>
</ul>
</li>
</ul>
<h2 id="第二章-开始学习C"><a href="#第二章-开始学习C" class="headerlink" title="第二章 开始学习C++"></a>第二章 开始学习C++</h2><ul>
<li><p>语句，是要执行的操作。</p>
</li>
<li><p>为理解源代码，编译器需要直到一条语句何时结束，另一条语句何时开始。有些语句使用语句分隔符。</p>
</li>
<li><p>C++与C一样，使用终止符(terminator)，而不是分隔符。</p>
</li>
<li><p>终止符是一个分号，它是语句的结束标记，是语句的组成部分，而不是语句之间的标记</p>
</li>
<li><p>结论：在C++中，不能省略分号</p>
</li>
<li><p>通常，C++函数可被其他函数激活或调用</p>
</li>
<li><p>函数头描述了函数与调用它的函数之间的接口。</p>
</li>
<li><p>位于函数名前面的部分叫做函数返回类型，<strong>它描述的是从函数返回给调用它的函数的信息</strong>。</p>
</li>
<li><p>函数名后括号中的部分叫做形参列表(argument list)或参数列表(parameter list)。它描述的是从调用函数传递给被调用的函数的信息。</p>
</li>
<li><p>C++注释以双斜杠(<code>//</code>)打头，到行尾结束。注释可以位于单独的一行上，也可以和代码位于同一行</p>
</li>
<li><p>C-风格注释，包括在符号<code>/*</code>和<code>*/</code>之间。由于C-风格注释以<code>*/</code>结束，而不是到行尾结束，因此可以跨越多行。事实上，C99标准也在C语言中添加了<code>//</code>注释</p>
</li>
<li><p>源代码中的标记和空白</p>
<ul>
<li>一行代码中不可分隔的元素叫做标记(token)。</li>
<li>通常，必需用空格，制表符或回车将两个标记分开。空格，制表符和回车统称为空白(white space)。</li>
</ul>
</li>
<li><p>C++源代码风格</p>
<ul>
<li>每条语句占一行</li>
<li>每个函数都有一个开始花括号和一个结束花括号，这两个花括号各占一行</li>
<li>函数中的语句都相对于花括号进行缩进</li>
<li>与函数名称相关的圆括号周围没有空白。</li>
</ul>
</li>
<li><p>C++程序是一组函数，而每个函数又是一组语句</p>
</li>
<li><p>计算机是一种精确的，有条理的机器。要将信息项存储在计算机中，必须指出信息的存储位置和所需的内存空间。</p>
</li>
<li><p>在C++中，完成这种任务的一种相对简便的方法，是使用声明语句来指出存储类型并提供位置标签。</p>
</li>
<li><p>程序中的声明语句叫做定义声明(defining declaration)语句，简称为定义(definition)。这意味着它将导致编译器为变量分配内存空间。在较为复杂的情况下，还可能有引用声明(reference declaration)</p>
</li>
<li><p>总结</p>
<ol>
<li>C++程序由一个或多个被称为函数的模块组成。程序从main()函数开始执行，因此该函数必不可少。函数由函数头和函数体组成。函数头指出函数的返回值的类型和函数期望通过参数传递给它的信息的类型。函数体由一系列位于花括号<code>&#123;&#125;</code>中的C++语句组成</li>
<li>有多种类型的C++语句，包括：<ul>
<li>声明语句，定义函数中使用的变量的名称和类型</li>
<li>赋值语句，使用赋值运算符<code>=</code>给变量赋值</li>
<li>消息语句，将消息发送给对象，激发某种行为</li>
<li>函数调用，执行函数。被调用的函数执行完毕后，程序返回到函数调用语句后面的语句</li>
<li>函数原型，声明函数的返回类型，函数接受的参数数量和类型</li>
<li>返回语句，将一个值从被调用的函数那里返回到调用函数中。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="第三章-处理数据"><a href="#第三章-处理数据" class="headerlink" title="第三章 处理数据"></a>第三章 处理数据</h2><ul>
<li>计算机内存的基本单元是位(bit)。</li>
<li>可以将位看作电子开关，可以开，也可以关。关表示值0，开表示值1。</li>
<li>8为的内存块可以设置出256中不同的组合，因为每一位都可以有两种设置，所以8位的总组合数为256。</li>
<li>字节(byte)，<strong>通常指的是8位的内存单元</strong>。从这个意义上来说，<strong>字节指的就是描述计算机内存量的度量单位</strong>，1KB等于1024字节，1MB等于1024KB。</li>
</ul>
<h2 id="第四章-复合类型"><a href="#第四章-复合类型" class="headerlink" title="第四章 复合类型"></a>第四章 复合类型</h2><h3 id="指针与C-基本原理"><a href="#指针与C-基本原理" class="headerlink" title="指针与C++基本原理"></a>指针与C++基本原理</h3><ul>
<li>面向对象编程与传统的过程性编程的区别在于，OOP强调的是在<strong>运行阶段（而不是编译阶段）进行决策</strong>。<ul>
<li>运行阶段，指的是程序正在运行时</li>
<li>编译阶段，指的是编译器将程序组合起来时。</li>
</ul>
</li>
<li>运行阶段决策，就好比度假时，选择参观那些景点取决于天气和当时的心情；而编译阶段决策更像不管在什么条件下，都坚持预先设定的日程安排。</li>
<li>运行阶段决策提供了灵活性，可以根据当时的情况进行调整</li>
</ul>
<h3 id="指针小结"><a href="#指针小结" class="headerlink" title="指针小结"></a>指针小结</h3><ul>
<li>声明指针</li>
<li>给指针赋值。应将内存地址赋给指针。<strong>可以对变量名应用<code>&amp;</code>运算符，来获得被命名的内存的地址，new运算符返回未命名的内存的地址</strong>。</li>
<li>对指针解除引用。<ul>
<li>对指针解除引用意味着获得指针指向的值。对指针应用解除引用或间接值运算符(<code>*</code>)来解除引用。</li>
<li>另一种对指针解除引用的方法是<strong>使用数组表示法</strong>。例如，<code>pn[0]</code>与<code>*pn</code>是一样的。一定不要对未被初始化为适当地址的指针解除引用。</li>
</ul>
</li>
<li>区分指针和指针所指向的值</li>
<li>数组名。在多数情况下，C++将数组名视为数组的第一个元素的地址。一种例外情况是，将sizeof运算符用于数组名时，此时将返回整个数组的长度（单位为字节）</li>
<li>指针算术</li>
<li>数组的动态联编和静态联编<ul>
<li>使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置</li>
<li>使用<code>new[]</code>运算符创建数组时，将采用动态联编(动态数组),即将在运行时为数组分配空间，其长度也将在运行时设置。使用完这种数组后，应该使用<code>delete[]</code>释放其占用的内存</li>
</ul>
</li>
<li>数组表示法和指针表示法<ul>
<li>使用方括号数组表示法等同于对指针解除引用</li>
<li>数组名和指针变量都是如此，因此对于指针和数组名，即可以使用指针表示法，也可以使用数组表示法</li>
</ul>
</li>
</ul>
<h3 id="自动存储，静态存储和动态存储"><a href="#自动存储，静态存储和动态存储" class="headerlink" title="自动存储，静态存储和动态存储"></a>自动存储，静态存储和动态存储</h3><ul>
<li><p>自动存储</p>
<ul>
<li>在函数内部定义的常规变量使用自动存储空间，被称为自动变量(automatic variable)，这意味着它们在所属的函数被调用时自动产生，在该函数结束时小王</li>
<li>实际上，自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。</li>
<li>自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出(LIFO)。因此，在程序执行过程中，栈将不断地增大和缩小。</li>
</ul>
</li>
<li><p>静态存储</p>
<ul>
<li>静态存储是整个程序执行期间都存在的存储方式。</li>
<li>使变量成为静态的方式有两种：一种是在函数外面定义它，另一种是在声明变量时使用关键字<code>static</code></li>
</ul>
</li>
<li><p>动态存储</p>
<ul>
<li>new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。</li>
<li>它们管理了一个内存池，这在C++中被称为自由存储空间(free store)或堆(heap)。</li>
<li>该内存池同用于静态变量和自动变量的内存是分开的。new和delete能够在一个函数中分配内存，而在另一个函数中释放它。因此数据的生命周期不完全受程序或函数的生存时间控制。</li>
</ul>
</li>
<li><p>栈，堆和内存泄漏</p>
<ul>
<li>如果使用new运算符在自由存储空间（或堆）上创建变量后，没有调用delete，则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。</li>
<li>实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄漏。被泄漏的内存将在程序的整个生命周期内都不可使用；这些内存被分配出去，但无法收回。</li>
<li>极端情况（不过不常见）是，内存泄漏可能会非常严重，以致于应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。另外，这种泄漏还会给一些操作系统或在相同的内存空间中运行的应用程序带来负面影响，导致它们崩溃。</li>
</ul>
</li>
</ul>
<h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ul>
<li><p>内联函数是C++为提供程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。</p>
</li>
<li><p>编译过程的最终产品是可执行程序–由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。</p>
</li>
<li><p>引用变量</p>
<ul>
<li>引用是已定义的变量的别名（另一个名称）</li>
<li>引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的</li>
<li><code>int rats; int &amp; rodents = rats;  // make rodents an alias for rate</code></li>
<li>其中，<code>&amp;</code>不是地址运算符，而是类型标识符的一部分。就像声明中的<code>char*</code>指的是指向<code>char</code>的指针一样，<code>int&amp;</code>指的是指向int的引用。</li>
</ul>
<ul>
<li>引用经常被用作函数参数，使得函数中的变量名称为调用程序中的变量的别名，这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量</li>
</ul>
</li>
</ul>
<h3 id="实例化和具体化"><a href="#实例化和具体化" class="headerlink" title="实例化和具体化"></a>实例化和具体化</h3><ul>
<li>为进一步了解模板，必需理解术语：实例化和具体化</li>
<li>谨记：在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例(instantiation)<ul>
<li>例如，函数调用<code>Swap(i, j)</code>导致编译器生成<code>Swap()</code>的一个实例，该实例使用int类型。模板并非函数定义，但是使用int的模板实例是函数定义。**这种实例化方式被称为隐式实例化(implicit instantiation),因为编译器之所以知道需要进行定义，是由于程序调用<code>Swap()</code>函数时提供了int参数。</li>
<li>最初，编译器只能通过隐式实例化，来使用模板生成函数定义，但是现在C++还允许显式实例化(explicit instantiation)。这意味着可以直接命令编译器创建特定的实例，例如<code>Swap&lt;int&gt;()</code>。其语法是，声明所需要的种类–使用<code>&lt;&gt;</code>符号指示类型，并在声明前加上关键字<code>template</code> – <code>template void Swap&lt;int&gt;(int, int);  // explicit instantiation</code></li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>引用变量是一种伪装指针，它允许为变量创建别名（另一个名称）。引用变量主要被用作处理结构和类对象的函数的参数。</p>
</li>
<li><p>通常，被声明为特定类型引用的标识符只能指向这种类型的数据；然而，如果一个类是从另一个类派生出来的，则基类引用可以指向派生类对象</p>
</li>
<li><p>函数的特征标是它的参数列表。程序员可以定义两个同名函数，只要其特征标不同。这被称为函数多态或函数重载。</p>
</li>
<li><p><strong>通常，通过重载函数来为不同的数据类型提供相同的服务</strong>。</p>
</li>
<li><p>函数模板自动完成重载函数的过程。只需使用泛型和具体算法来定义函数，编译器将为程序中使用的特定参数类型生成正确的函数定义</p>
</li>
</ul>
<h2 id="第九章-内存模型和名称空间"><a href="#第九章-内存模型和名称空间" class="headerlink" title="第九章 内存模型和名称空间"></a>第九章 内存模型和名称空间</h2><h3 id="头文件管理"><a href="#头文件管理" class="headerlink" title="头文件管理"></a>头文件管理</h3><ul>
<li>在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知情的情况下将头文件包含多次。<ul>
<li>例如，可能使用包含了另一个头文件的头文件。有一种标准的C&#x2F;C++技术可以避免多次包含同一个文件。</li>
</ul>
</li>
<li>它是基于预处理编译指令<code>#ifndef</code>（即if not defined)</li>
</ul>
<h3 id="自动变量和栈"><a href="#自动变量和栈" class="headerlink" title="自动变量和栈"></a>自动变量和栈</h3><ul>
<li><p>了解典型的C++编译器如何实现自动变量，有助于更深入地了解自动变量</p>
</li>
<li><p>由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。</p>
</li>
<li><p>常用的方法是留出一段内存，并将其视为栈，以管理变量的增减。之所以被称为栈，是由于新数据被象征性地放在原有数据的上面（也就是说，在相邻的内存单元中，而不是在同一个内存单元中），当程序使用完后，将其从栈中删除。栈的默认长度取决于实现，但编译器通常提供改变栈长度的选项。</p>
</li>
<li><p>程序使用两个指针来跟踪栈，一个指针指向栈底–栈的开始位置，另一个指针指向栈顶–下一个可用内存单元。当函数被调用时，其自动变量将被加入到栈中，栈顶指针指向变量后面的下一个可用的内存单元。函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。</p>
</li>
<li><p>栈是LIFO（后进先出）的，即最后加入到栈中的变量首先被弹出。这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。被调用的函数根据其形参描述来确定每个参数的地址。</p>
</li>
</ul>
<h3 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h3><ul>
<li>关键字<code>register</code>最初是由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量，这样的目的是–提高访问变量的速度。</li>
</ul>
<h3 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h3><ul>
<li><p>有些被称为存储说明符(storage class specifier)或cv-限定符(cv-qualifier)的C++关键字提供了其他有关存储的信息</p>
</li>
<li><p>存储说明符</p>
<ol>
<li><code>auto</code>（在C++11中不再是说明符）<ul>
<li>在C++11之前，可以在声明中使用关键字<code>auto</code>指出变量为自动变量</li>
<li>在C++11中，<code>auto</code>用于自动类型推断。</li>
</ul>
</li>
<li><code>register</code><ul>
<li>用于在声明中指示寄存器存储，</li>
<li>在C++11中，它只是显式地指出变量是自动的</li>
</ul>
</li>
<li><code>static</code><ul>
<li>它被用在作用域为整个文件的声明中时，表示内部链接性</li>
<li>被用于局部声明中，表示局部变量的存储持续性为静态的</li>
</ul>
</li>
<li><code>extern</code><ul>
<li>它表明是引用声明，即声明引用在其他地方定义的变量</li>
</ul>
</li>
<li><code>thread_local</code>（C++11新增加的，可与<code>static</code>或<code>extern</code>结合使用）<ul>
<li>它指出变量的持续性与其所属线程的持续性相同</li>
<li><code>thread_local</code>变量之于线程，犹如常规静态变量之于整个程序</li>
</ul>
</li>
<li><code>mutable</code><ul>
<li>它的含义将根据const来解释</li>
<li>可以用它来指出，即时结构（或类）变量为const，其某个成员也可以被修改</li>
</ul>
</li>
</ol>
</li>
<li><p>cv-限定符(cv表示const volatile)</p>
<ol>
<li><code>const</code> <ul>
<li>它是最常用的cv-限定符，它表明–内存被初始化后，程序便不能再对它进行修改</li>
</ul>
</li>
<li><code>volatile</code><ul>
<li>它表明，即时程序代码没有对内存单元进行修改，其值也可能发生变化；该关键字的作用是为了改善编译器的优化能力</li>
<li>例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为<code>volatile</code>，则编译器将进行这种优化；将变量声明为<code>volatile</code>，相当于告诉编译器，不要进行这种优化。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>C++鼓励程序员在开发程序时使用多个文件。一种有效的组织策略是，使用头文件来定义用户类型，为操纵给用户类型的函数提供函数原型；并将函数定义放在一个独立的源代码文件中。头文件和源代码文件一起定义和实现了用户定义的类型及其使用方式。最后，将<code>main()</code>和其他使用这些函数的函数放在第三个文件中</li>
</ul>
<h2 id="第十章-对象和类"><a href="#第十章-对象和类" class="headerlink" title="第十章 对象和类"></a>第十章 对象和类</h2><ul>
<li><p>过程性编程方法 – 首先考虑要遵循的步骤，然后考虑如何表示这些数据（并不需要程序一直运行，用户可能希望能够将数据存储在一个文件中，然后从这个文件中读取数据）</p>
</li>
<li><p>OOP方法 – 首先从用户的角度考虑对象，描述对象所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据存储。最后，使用新的设计方案创建出程序。</p>
</li>
<li><p>指定基本类型完成了三项工作</p>
<ul>
<li>决定数据对象需要的内存数量</li>
<li>决定如何解释内存中的位（long和float在内存中占用的位数相同，但将它们转换为数值的方法不同）</li>
<li>决定可使用数据对象执行的操作或方法</li>
</ul>
</li>
<li><p>类，是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包</p>
</li>
<li><p>类规范由两个部分组成</p>
<ul>
<li>类声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口</li>
<li>类方法定义：描述如何实现类成员函数</li>
<li>简单地说，类声明提供了类的蓝图，而方法定义则提供了细节</li>
</ul>
</li>
</ul>
<h3 id="什么是接口？"><a href="#什么是接口？" class="headerlink" title="什么是接口？"></a>什么是接口？</h3><ul>
<li><p>接口，是一个共享框架，供两个系统（例如在计算机和打印机之间或者用户和计算机程序之间）交互时使用</p>
</li>
<li><p>对于类，我们说公共接口。在这里，公共(public)是使用类的程序，交互系统由类对象组成，而接口由编写类的人提供的方法组成。</p>
</li>
<li><p>接口，让程序员能够编写与类对象交互的代码，从而让程序能够使用类对象。</p>
</li>
<li><p>为开发一个类并编写一个使用它的程序，需要完成多个步骤。这里将开发过程分成多个阶段，而不是一次性完成。</p>
</li>
<li><p>通常，C++程序员将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码文件中。</p>
</li>
</ul>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><ul>
<li><p>使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数来访问对象的私有成员。</p>
</li>
<li><p>因此，公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏</p>
</li>
<li><p>类设计尽可能将公有接口与实现细节分开。</p>
<ul>
<li>公有接口表示设计的抽象组件。将实现细节放在一起并将它们与抽象分开被称为封装。</li>
<li>数据隐藏（将数据放在类的私有部分中）是一种封装，将实现的细节隐藏在私有部分中，也是一种封装</li>
<li>封装的另一个例子是，将类函数定义和类声明放在不同的文件中</li>
</ul>
</li>
<li><p>类和结构</p>
<ul>
<li>类描述看上去很像是包含成员函数以及public和private可见性标签的结构声明。</li>
<li>实际上，C++对结构进行了扩展，使之具有与类相同的特性。它们之间唯一的区别是，结构的默认访问类型是public，而类为private。C++程序员通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象（常被称为普通老式数据结构）</li>
</ul>
</li>
</ul>
<h3 id="实现类成员函数"><a href="#实现类成员函数" class="headerlink" title="实现类成员函数"></a>实现类成员函数</h3><ul>
<li><p>创建类描述的第二个部分：为那些由类声明中的原型表示的成员函数提供代码。</p>
</li>
<li><p>成员函数定义与常规函数定义非常相似，它们有函数头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征：</p>
<ul>
<li><strong>定义成员函数时，使用作用域解析运算符(<code>::</code>)来表示函数所属的类</strong></li>
<li><strong>类方法可以访问类的<code>private</code>组件</strong></li>
</ul>
</li>
<li><p>成员函数的函数头使用作用域运算符解析(<code>::</code>)来指出函数所属的类。因此，作用域解析运算符确定了方法定义对应的类的身份。</p>
</li>
</ul>
<h3 id="内联方法"><a href="#内联方法" class="headerlink" title="内联方法"></a>内联方法</h3><ul>
<li><p>定义位于类声明中的函数都将自动成为内联函数</p>
</li>
<li><p>内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用的，最简便的方法是：将内联定义放在定义类的头文件中（有些开发系统包含智能链接程序，允许将内联定义放在一个独立的实现文件）</p>
</li>
</ul>
<h3 id="方法使用哪个对象"><a href="#方法使用哪个对象" class="headerlink" title="方法使用哪个对象"></a>方法使用哪个对象</h3><ul>
<li><p>所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。</p>
<ul>
<li>例如，假设kate和joe都是Stock对象，则<code>kate.shares</code>将占据一个内存块，而<code>joe.shares</code>占用另一个内存块，但<code>kate.show()</code>和<code>joe.show()</code>都调用同一个方法，也就是说，它们将执行同一个代码块，只是将这些代码用于不同的数据。</li>
</ul>
</li>
<li><p>在OOP中，调用成员函数被成为发送消息，因此将同样的消息发送给两个不同的对象将调用同一个方法，但是该方法被用于两个不同的对象。</p>
</li>
</ul>
<h3 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h3><ul>
<li><p>在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。</p>
</li>
<li><p>另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。也就是说，要调用公有成员函数，必需通过对象</p>
</li>
<li><p>同样，在定义成员函数时，必需使用作用域解析运算符</p>
</li>
<li><p>总之，在类声明或成员函数定义中，可以使用未修饰的成员名称。</p>
</li>
<li><p>构造函数名称在被调用时，才能被识别，因为它的名称与类名相同</p>
</li>
<li><p>其他情况下，使用类成员名时，必需根据上下文使用直接成员运算符(<code>.</code>)，间接成员运算符(<code>-&gt;</code>)或作用域解析运算符(<code>::</code>)</p>
</li>
</ul>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>面向对象编程强调的是程序如何表示数据。使用OOP方法解决编程问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使用数据。然后，设计一个类来实现该接口。一般来说，私有数据成员存储信息，公有成员函数（又称方法）提供访问数据的唯一途径。类将数据和方法组合成一个单元，其私有性实现数据隐藏</p>
</li>
<li><p>类是用户定义的类型，对象是类的实例。这意味着对象是这种类型的变量。例如由new按类描述分配的内存</p>
</li>
</ul>
<h2 id="第十一章-使用类"><a href="#第十一章-使用类" class="headerlink" title="第十一章 使用类"></a>第十一章 使用类</h2><ul>
<li><p>学习C++的难点之一是需要记住大量的东西，但在拥有丰富的实践经验之前，根本不可能全部记住这些东西。</p>
</li>
<li><p>掌握知识的好的方法是，在自己开发的C++程序中使用其中的新特性。对这些新特性有了充分的认知后就可以添加其他C++特性</p>
</li>
<li><p>正如C++创始人<code>Bjarne Stroustrup</code>在一次C++专业程序员大会上所建议的：<strong>轻松地使用这种语言。不要觉得必须使用所有的特性，不要在第一次学习时就试图使用所有的特性</strong></p>
</li>
</ul>
<h2 id="第十二章-类和动态内存分配"><a href="#第十二章-类和动态内存分配" class="headerlink" title="第十二章 类和动态内存分配"></a>第十二章 类和动态内存分配</h2><h3 id="指针和对象小结"><a href="#指针和对象小结" class="headerlink" title="指针和对象小结"></a>指针和对象小结</h3><ul>
<li><p>使用常规表示法来声明指向对象的指针 – <code>String* gla;</code></p>
</li>
<li><p>可以将指针初始化为指向已有的对象 – <code>String* first = &amp;saying[0];</code></p>
</li>
<li><p>可以使用new来初始化指针，这将创建一个新的对象 – <code>String* favorite = new String(sayings[choice])</code></p>
</li>
<li><p>对类使用new将调用相应的类构造函数来初始化新创建的对象</p>
</li>
<li><p>可以使用<code>-&gt;</code>运算符通过指针访问类方法 – <code>shortest-&gt;length()</code></p>
</li>
<li><p>可以对对象指针应用解除引用运算符(<code>*</code>)来获得对象 – <code>first = &amp;saying[i];</code></p>
</li>
</ul>
<h2 id="第十三章-类继承"><a href="#第十三章-类继承" class="headerlink" title="第十三章 类继承"></a>第十三章 类继承</h2><ul>
<li><p>希望同一个方法在派生类和基类中的行为是不同的。换句话来说，方法的行为应该取决于调用方法的对象。这种较复杂的行为称为多态–具有多种形态，即同一个方法的行为随上下文而异。</p>
</li>
<li><p>有两种重要的机制可用于实现多态公有继承：</p>
<ul>
<li>在派生类中重新定义基类的方法</li>
<li>使用虚方法</li>
</ul>
</li>
<li><p><strong>注意</strong> </p>
<ul>
<li>如果要在派生类中重新定义基类的方法，通常<strong>应将基类方法声明为虚的</strong>。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。</li>
<li>为基类声明一个虚析构函数也是一种惯例</li>
</ul>
</li>
</ul>
<h3 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h3><ul>
<li><p>程序调用函数时，将使用哪一个可执行代码块？  编译器负责回答这个问题</p>
</li>
<li><p>将源代码中的函数调用解释为执行特定的函数代码块被称为<strong>函数名联编(binding)</strong></p>
</li>
<li><p>在C语言中，这非常简单，因为每个函数名都对应一个不同的函数</p>
</li>
<li><p>在C++中，由于函数重载的远古，这项任务更复杂。编译器必须查看函数参数及函数名才能确定使用哪一个函数。</p>
</li>
<li><p>C&#x2F;++编译器可以在编译过程完成这种联编。在编译过程中进行联编被称为<strong>静态联编(static binding)，又称为早期联编(early binding)</strong></p>
</li>
<li><p>然而，虚函数使这项工作变得更困难。因为虚函数使得 – 使用哪一个函数是不能在编译时确定的。因为编译器不知道用户将选择那种类型的对象，所以，编译器必须生成能够在程序运行时选择正确的虚函数的代码，这被称为<strong>动态联编(dynamic binding)，又称为晚期联编(late binding)</strong></p>
</li>
<li><p>将派生类引用或指针转转为基类引用或指针 被称为<strong>向上强制转换(upcasting)</strong>,这使公有继承不需要进行显式类型转换。</p>
</li>
<li><p>相反的过程 – 将基类指针或引用转换为派生类指针或引用 被称为<strong>向下强制转换(downcasting)</strong></p>
</li>
<li><p>编译器对非虚方法使用静态联编</p>
</li>
<li><p>为什么有两种类型的联编以及为什么默认为静态联编？ – 效率和概念模型</p>
</li>
<li><p>效率</p>
<ul>
<li>为了使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销</li>
<li>C++的指导原则之一是 – 不要为不使用的特性付出代价（内存或处理时间）。仅当程序设计确实需要虚函数时，才适用它们</li>
</ul>
</li>
<li><p>虚函数的工作原理</p>
<ol>
<li>通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table, vtbl)。</li>
<li>虚函数表中存储了为类对象进行声明的虚函数的地址。</li>
</ol>
<ul>
<li>例如，基类对象包含了一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中</li>
<li>调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。</li>
</ul>
</li>
<li><p>总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括</p>
<ul>
<li>每个对象都将增大，增大量为存储地址的空间</li>
<li>对于每个类，编译器都要创建一个虚函数地址表（数组)</li>
<li>对于每个函数调用，都需要执行一项额外的操作，即在表中查找地址</li>
</ul>
</li>
<li><p><strong>有关虚函数注意事项</strong></p>
<ul>
<li>在基类方法的声明中使用关键字<code>virtual</code>可以使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的</li>
<li>如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要。因为这样基类指针或引用可以指向派生类对象</li>
<li>如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。</li>
</ul>
</li>
<li><p>当基类和派生类都采用动态内存分配时，派生类的析构函数，复制构造函数，赋值运算符都必须使用相应的基类方法来处理基类元素。</p>
</li>
<li><p>这种要求是要通过三种不同的方式来满足的。对于析构函数，这是自动完成的；对于构造函数，这是通过在初始化成员列表中调用基类的复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函数。对于赋值运算符，这是通过使用作用域解析运算符显式地调用基类的赋值运算符来完成的。</p>
</li>
</ul>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul>
<li>继承，通过使用已有的类（基类）定义新的类（派生类），使得能够根据需要修改编程代码。</li>
</ul>
<h2 id="C-中的代码重用"><a href="#C-中的代码重用" class="headerlink" title="C++中的代码重用"></a>C++中的代码重用</h2><ul>
<li><p>C++的一个主要目标是促进代码重用。公有继承是实现这种目标的机制之一，但并不是唯一的机制。</p>
</li>
<li><p>方法之一是使用这样的类成员–本身是另一个类的对象。这种方法称为包含(containment), 组合(composition)或层次化(layering)</p>
</li>
<li><p>另一种方法是使用私有或保护继承。通常，包含，私有继承和保护继承用于实现<code>has-a</code>关系，即新的类将包含另一个类的对象。</p>
</li>
<li><p>C++和约束</p>
<ul>
<li>C++包含让程序员能够限制程序结构的特性–使用<code>explicit</code>防止单参数构造函数的隐式转换，使用const限制方法修改数据，等等。</li>
<li>这样做的根本原因是：**在编译阶段出现错误优于在运行阶段出现错误</li>
</ul>
</li>
<li><p>使用包含还是私有继承？</p>
<ul>
<li>由于即可以使用包含，也可以使用私有继承来建立<code>has-a</code>关系，那么应该使用那种方式？</li>
<li>通常，应该使用包含来建立<code>has-a</code>关系；</li>
<li>如果新类需要访问原有类的保护成员，或者需要重新定义虚函数，则应该使用私有继承</li>
</ul>
</li>
</ul>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><ul>
<li><code>template &lt;class Type&gt;</code></li>
<li>关键字<code>template</code>告诉编译器，将要定义一个模板。尖括号中的内容相当于函数的参数列表。可以把关键字class看作是变量的类型名，该变量接受类型作为其值，把<code>Type</code>看作是该变量的名称。</li>
<li>这里使用class并不意味着<code>Type</code>必须是一个类；而只是表明<code>Type</code>是一个通用的类型说明符，在使用模板时，将使用实际的类型替换它。较新的C++实现<strong>允许在这种情况下使用不太容易混淆的关键字<code>typename</code>代替class</strong><ul>
<li><code>template &lt;typename Type&gt;  // newer choice</code></li>
</ul>
</li>
<li>可以使用自己的泛型名代替<code>Type</code>，其命名规则与其他标识符相同。**当前流行的选项包括<code>T</code>和<code>Type</code>。</li>
<li>当模板被调用时，<code>Type</code>将被具体的类型值（例如int， string）取代。在模板定义中，可以使用泛型名来表示要存储在栈中的类型。</li>
</ul>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>C++提供了几种重用代码的手段</p>
</li>
<li><p>公有继承能够建立<code>is-a</code>关系，这样派生类可以重用基类的代码</p>
</li>
<li><p>私有继承和保护继承也使得能够重用基类的代码，但是建立的是<code>has-a</code>关系</p>
<ul>
<li>使用私有继承时，基类的公有成员和保护成员将称为派生类的私有成员</li>
<li>使用保护继承时，基类的公有成员和保护成员将成为派生类的保护成员</li>
</ul>
</li>
<li><p><strong>无论使用哪一种继承，基类的公有接口都将成为派生类的内部接口，这有时候被称为继承实现，但并不继承接口，因为派生类对象不能显式地使用基类的接口。因此，不能将派生对象看作是一种基类对象。由于这个原因，在不进行显式类型转换的情况下，基类指针或引用将不能指向派生类对象。</strong></p>
</li>
<li><p>还可以通过开发包含对象成员的类来重用类代码，这种方法被称为包含，层次化或组合。</p>
</li>
<li><p>它建立的是<code>has-a</code>关系。与私有继承和保护继承相比，包含更容易实现和使用，所以通常优先采用这种方式。</p>
</li>
<li><p>然而，私有继承和保护继承比包含有一些不同的功能。例如，继承允许派生类访问基类的保护成员；还允许派生类重新定义从基类那里继承的徐函数。因为包含不是继承，所以通过包含来重用类代码时，不能使用这些功能</p>
</li>
<li><p>另一个方面，如果需要使用某个类的几个对象，则用包含更加合适。</p>
</li>
<li><p>所有这些机制的目的都是为了让程序员能够重用经过测试的代码，而不用手工复制它们，这样可以简化编程工作，提供程序的可靠性。</p>
</li>
</ul>
<h2 id="第十五章-友元，异常和其他"><a href="#第十五章-友元，异常和其他" class="headerlink" title="第十五章 友元，异常和其他"></a>第十五章 友元，异常和其他</h2><ul>
<li>在C++中，可以将类声明放在另一个类中。在另一个类中声明的类称为嵌套类(nested class)，它通过提供新的类型类作用域来避免名称混乱。</li>
<li>包含的类的成员函数可以创建和使用被嵌套类的对象；而仅当声明位于公有部分，才能在包含类的外面使用嵌套类，而且必须使用作用域解析运算符。</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>如果其中一个参数是另一个参数的负值，则调用abort（）函数。Abort（）的函数原型位于头文件<code>cstdlib</code>中，其典型实现是向标准错误流(即<code>cerr</code>使用的错误流)发送消息<code>abnormal program termination（程序异常终止）</code>，然后终止程序。它还返回一个随实现而异的值，告诉操作系统（如果程序是由另一个程序调用的，则告诉父进程）处理失败。</li>
<li><code>abort()</code>是否刷新文件缓冲区（用于存储读写到文件中的数据的内存区域）取决于实现。</li>
</ul>
<h3 id="返回错误码"><a href="#返回错误码" class="headerlink" title="返回错误码"></a>返回错误码</h3><ul>
<li>一种比异常终止更灵活的方法是，使用函数的返回值来指出问题</li>
</ul>
<h3 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h3><ul>
<li><p>C++异常是对程序运行过程中发生的异常情况的一种响应。</p>
</li>
<li><p>异常提供了将控制权从程序的一个部分传递到另一个部分的途径。</p>
</li>
<li><p>对异常的处理有3个组成部分：</p>
<ul>
<li>引发异常；</li>
<li>使用处理程序捕获异常</li>
<li>使用try块</li>
</ul>
</li>
<li><p>程序在出现问题时将引发异常。**<code>throw</code>语句实际上是跳转，即命令程序跳到另一条语句**。</p>
</li>
<li><p><code>throw</code>关键字表示引发异常，紧随其后的值（例如字符串或对象）指出了异常的特征。</p>
</li>
<li><p>程序使用异常处理程序(<code>exception handler</code>)来捕获异常，异常处理程序位于要处理问题的程序中。</p>
</li>
<li><p><code>catch</code>关键字表示捕获异常。处理程序以关键字<code>catch</code>开头，随后是位于括号中的类型声明，它指出了异常处理程序要响应的异常类型；然后是一个用花括号括起来的代码块，指出要采取的措施。</p>
</li>
<li><p><code>catch</code>关键字和异常类型用作标签，指出当异常被引发时，程序应该跳到这个位置执行。异常处理程序也被称为<code>catch</code>块</p>
</li>
<li><p><code>try</code>块标识其中特定的异常可能被激活的代码块，它后面跟一个或多个<code>catch</code>块。<code>try</code>块是由关键字<code>try</code>指示的，关键字<code>try</code>的后面是一个由花括号括起来的代码块，表明需要注意这些代码引发的异常。</p>
</li>
<li><p>通常，引发异常的函数将传递一个对象。这样做的重要优点之一是，可以使用不同的异常类型来区分不同的函数在不同的情况下引发的异常。</p>
</li>
<li><p>另外，对象可以携带信息，程序员可以根据这些信息来确定引发异常的原因。同时，<code>catch</code>块可以根据这些信息来决定采取什么样的措施</p>
</li>
</ul>
<h3 id="栈解退"><a href="#栈解退" class="headerlink" title="栈解退"></a>栈解退</h3><ul>
<li><p>C++通常是如何处理函数调用和返回的。</p>
</li>
<li><p>C++通常通过将信息放在栈中来处理函数调用。具体地说，程序将调用函数的指令的地址（返回地址）放到栈中。当被调用的函数执行完毕后，程序将使用该地址来确定从哪里开始继续执行。另外，函数调用将函数参数放到栈中。在栈中，这些函数参数都被视为自动变量。如果被调用的函数创建了新的自动变量，则这些变量也将被添加到栈中。如果被调用的函数调用了另一个函数，则后者的信息将被添加到栈中，依次类推。</p>
</li>
<li><p>当函数结束时，程序流程将跳到该函数被调用时存储的地址处，同时栈顶的元素被释放。因此，函数通常都返回到调用它的函数，依次类推，同时每个函数都在结束时释放其自动变量。如果自动变量是类对象，则类的析构函数将被调用。</p>
</li>
<li><p>现在假设函数由于出现异常（而不是由于返回）而终止，则程序也将释放栈中的内存，但不会在释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于<code>try</code>块中的返回地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句。这个过程被称为<strong>栈解退</strong></p>
</li>
</ul>
<h2 id="第十六章-string类和标准模板库"><a href="#第十六章-string类和标准模板库" class="headerlink" title="第十六章 string类和标准模板库"></a>第十六章 string类和标准模板库</h2><ul>
<li><p><code>STL</code>提供了一组表示容器，迭代器，函数对象和算法的模板。</p>
</li>
<li><p>容器是一个与数组类似的单元，可以存储若干个值。 STL容器是同质的，即存储的值的类型相同</p>
</li>
<li><p>算法是完成特定任务（如对数组进行排序或在链表中查找特定值）的处方</p>
</li>
<li><p>迭代器能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针；</p>
</li>
<li><p>函数对象是类似于函数的对象，可以是类对象或函数指针（包含函数名，因为函数名被用作指针）。</p>
</li>
<li><p>STL使得能够构造各种容器（包括数组，队列和链表）和执行各种操作（包括搜索，排序和随机排列）</p>
</li>
</ul>
<h3 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h3><ul>
<li><p><code>STL</code>是一种泛型编程(<code>generic programming</code>)。面向对象编程关注的编程的数据方面，而泛型编程关注的是算法。它们之间的共同点是抽象和创建可重用代码，但它们的理念绝然不同。</p>
</li>
<li><p>泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板。当然，模板使得能够按泛型定义函数或类，而STL通过通用算法更进了一步。模板让这一切成为可能，但必须对元素进行仔细地设计。为了解模板和设计是如何协同工作的，来看一看需要迭代器的原因。</p>
</li>
<li><p><strong>理解迭代器是理解<code>STL</code>的关键所在</strong>。模板使得算法独立于存储的数据类型，而迭代器使得算法独立于使用的容器类型。因此，它们都是STL通用方法的重要组成部分。</p>
</li>
<li><p>泛型编程旨在使用同一个find函数来处理数组，链表或任何其他容器类型。即函数不仅独立于容器中存储的数据类型，而且独立于容器本身的俄数据结构。模板提供了存储在容器中的数据类型的通用表示，因此还需要遍历容器中的值的通用表示，迭代器正是这样的通用表示。</p>
</li>
<li><p>每个容器类(<code>vector list deque等</code>)定义了相应的迭代器类型。对于其中的某个类，迭代器可能是指针；而对于另一个类，则可能是对象。不管实现方式如何，迭代器都将提供所需的操作。</p>
</li>
<li><p>其次，每个容器类都有一个超尾标记，当迭代器递增到超越容器的最后一个值后，这个值将被赋给迭代器。每个容器类都有<code>begin()</code>和<code>end()</code>方法，它们分别返回一个指向容器的第一个元素和超尾位置的迭代器。每个容器都有++操作，让迭代器从指向第一个元素逐步指向超尾位置，从而遍历容器中的每一个元素。</p>
</li>
<li><p>使用容器类时，无需知道其迭代器是如何实现的，也无需知道超尾是如何实现的，而只需要知道它有迭代器，其<code>begin()</code>返回一个指向第一个元素的迭代器，<code>end()</code>返回一个指向超尾位置的迭代器即可。</p>
</li>
<li><p>总结一下<code>STL</code>方法。首先是处理容器的算法，应尽可能通用的术语来表达算法，使之独立于数据类型和容器类型。为使通用算法能够适用于具体情况，应定义能够满足算法需求的迭代器，并把要求加到容器设计上。即基于算法的要求，设计基本迭代器的特征和容器特征。</p>
</li>
</ul>
<h4 id="如何理解迭代？？"><a href="#如何理解迭代？？" class="headerlink" title="如何理解迭代？？"></a>如何理解迭代？？</h4><ul>
<li><p>迭代，是一个重复的过程，每次重复都是基于上一次的结果而继续的，<strong>单纯的重复并不是迭代</strong>，例如，A + B &#x3D;》 E ，生成的过程就是迭代，克隆就不是迭代</p>
</li>
<li><p>迭代器，指的是迭代取值的工具。而涉及到把多个值循环取出来的类型有：列表，字符串，元组，字典，集合，打开的文件对象</p>
</li>
<li><p>实现一个简单的迭代取值（基于索引）的方式，只适用于有索引的数据类型：列表，字符串，字典</p>
</li>
<li><p><strong>为了解决基于索引迭代取值的局限性，就必须提供一种能够不依赖索引的取值方式，这就是迭代</strong></p>
</li>
<li><p>在一个迭代器取值干净的情况下，再对其取值，取不到，必须再调用一次迭代器才能取值</p>
</li>
</ul>
<hr>
<ul>
<li><code>STL</code>定义了五种迭代器，并根据所需要的迭代器类型对算法进行了描述。这五种迭代器分别是输入迭代器，输出迭代器，正向迭代器，双向迭代器和随机访问迭代器。<ul>
<li>输入迭代器 – 被程序用来读取容器中的信息，是单向迭代器，可以递增，但不能倒退</li>
<li>输出迭代器 – 用于将信息从程序传输到容器的迭代器，因此程序的输出就是容器的输入。</li>
<li>正向迭代器 – 每次沿容器向前移动一个元素，并总是按照相同的顺序遍历一系列值</li>
<li>双向迭代器 – 具有正向迭代器的所有特性，同时支持两种（前缀和后缀）递减运算符</li>
<li>随机访问迭代器 – 具有双向迭代器的所有特性，同时添加了支持随机访问的操作和用于对元素进行排序的关系运算符</li>
</ul>
</li>
</ul>
<hr>
<h3 id="概念，改进和模型"><a href="#概念，改进和模型" class="headerlink" title="概念，改进和模型"></a>概念，改进和模型</h3><ul>
<li><p>STL有若干个用C++语言无法表达的特性，例如迭代器种类。因此，虽然可以设计具有正向迭代器特征的类，但不能让编译器将算法限制为只使用这个类。</p>
</li>
<li><p>原因在于，正向迭代器是一系列要求，而不是类型。所设计的迭代器类可以满足这种要求，常规指针也能满足这种要求。</p>
</li>
<li><p>STL算法可以使用任何满足其要求的迭代器实现。STL文献使用术语概念(concept)来描述一系列的要求。因此，存在输入迭代器概念，正向迭代器概念等。</p>
</li>
<li><p><strong>概念，可以具有类似继承的关系</strong>。例如，双向迭代器继承了正向迭代器的功能。然而，不能将C++继承机制用于迭代器。例如，可以将正向迭代器实现为一个类，而将双向迭代器实现为一个常规指针。</p>
</li>
<li><p>因此，对C++而言，这种双向迭代器是一种内置类型，不能从类派生而来。然而，从概念上看，它确实能够继承。有些<code>STL</code>文献使用术语**改进(refinement)**来表示这种概念上的继承，因此，双向迭代器是对正向迭代器概念的一种改进。</p>
</li>
<li><p>**概念的具体实现被称为模型(model)**。因此，指向int的常规指针是一个随机访问迭代器模型，也是一个正向迭代器模型，因为它满足该概念的所有要求。</p>
</li>
</ul>
<hr>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><ul>
<li><p>关联容器(associative container)是对容器概念的另一个改进。关联容器将值与键关联在一起，并使用键来查找值。</p>
</li>
<li><p>关联容器的优点在于，它提供了对元素的快速访问。与序列相似，关联容器也允许插入新元素，但不能指定元素的插入位置。原因是关联容器通常有用于确定数据放置位置的算法，以便能够快速检索信息。</p>
</li>
<li><p>关联容器通常是使用某种树实现的。</p>
</li>
<li><p>STL提供了四种关联容器：<code>set, multiset, map, multimap</code>。前两种是在头文件<code>set</code>中定义的，后两种是在头文件<code>map</code>中定义的</p>
</li>
</ul>
<hr>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><ul>
<li>很多<code>STL</code>算法都是用函数对象 – 也叫函数符(functor)。函数符是可以以函数方式与<code>()</code>结合使用的任意对象。这包括函数名，指向函数的指针和重载了<code>()</code>运算符的类对象(即定义了函数<code>operator()</code>的类)</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>C++提供了一组功能强大的库，这些库提供了很多常见编程问题的解决方案以及简化其他问题的工具。<code>string</code>类为将字符串作为对象来处理提供了一种方便的方法。<code>string</code>类提供了自动内存管理功能以及众多处理字符串的方法和函数</p>
</li>
<li><p>STL是一个容器类模板，迭代器类模板，函数对象模板和算法函数模板的集合，它们的设计是一致的，都是基于泛型编程原则的。算法通过使用模板，从而独立于所存储的对象的类型：通过使用迭代器接口，从而独立于容器的类型。迭代器是广义指针</p>
</li>
<li><p><strong>STL使用术语概念来描述一组要求</strong></p>
</li>
<li><p>有些算法被表示为容器类方法，但大量算法都被表示为通用的，非成员函数，这是通过将迭代器作为容器和算法之间的接口得以实现的</p>
</li>
<li><p>容器和算法都是由其提供或需要的迭代器类型表征的。</p>
</li>
</ul>
<h2 id="第十七章-输入，-输出和文件"><a href="#第十七章-输入，-输出和文件" class="headerlink" title="第十七章 输入， 输出和文件"></a>第十七章 输入， 输出和文件</h2><ul>
<li><p>多数计算机语言的输入和输出是以语言本身为基础实现的。但是C和C++都没有将输入和输出建立在语言中。这两种语言的关键字包括for和if，但不包括与I&#x2F;O有关的内容。C语言最初把I&#x2F;O留给了编译器实现人员。这样做的一个原因是为了让实现人员能够自由的设计I&#x2F;O函数，使之最适合于目标计算机的硬件要求。实际上，多数实现人员都把I&#x2F;O建立在最初为UNIX环境开发的库函数的基础之上。ANSI C 正式承认这个I&#x2F;O软件包时，将其称为标准输入&#x2F;输出包，并将其作为标准C库不可或缺的组成部分。C++也认可这个软件包，因此如果熟悉<code>stdio.h</code>文件中声明的C函数系列，则可以在C++程序中使用它们，较新的实现使用头文件<code>cstdio</code>来支持这些函数。</p>
</li>
<li><p>C++依赖于C++的I&#x2F;O解决方案，而不是C语言的I&#x2F;O解决方案，前者是在头文件<code>iostream</code>中定义一组类</p>
</li>
</ul>
<h3 id="流和缓冲区"><a href="#流和缓冲区" class="headerlink" title="流和缓冲区"></a>流和缓冲区</h3><ul>
<li><p>C++程序把输入和输出看作字节流。输入时，程序从输入流中抽取字节；输出时，程序将字节插入到输出流中。对于面向文本的程序，每个字节代表一个字符，更通俗地说，字节可以构成字符或数值数据的二进制表示。</p>
</li>
<li><p>输入流中的字节可能来自键盘，也可能来自存储设备（例如硬盘）或其他程序。同样，输出流中的字节可以流向屏幕，打印机，存储设备或者其他程序。<strong>流充当了程序和流源或流目标之间的桥梁</strong>。</p>
</li>
<li><p>这使得C++程序可以以相同的方式对待来自键盘的输入和来自文件的输入。C++程序只是检查字节流，而不需要知道字节来自何方。同理，通过使用流，C++程序处理输出的方式将独立于其去向。因此管理输入包含两部：</p>
<ul>
<li>将流和输入去向的程序关联起来</li>
<li>将流和文件连接起来</li>
</ul>
</li>
<li><p>换句话说，输入流需要两个连接，每端各一个。文件端部连接提供了流的来源，程序端连接将流的流出部分转储到程序中（文件端连接可以是文件，也可以是设备）。同样，对输出的管理包括将输出流连接到程序以及将输出目标与流关联起来。</p>
</li>
<li><p>通常，通过使用缓冲区可以更高效地处理输入和输出。</p>
</li>
<li><p>缓冲区，<strong>是用作中介的内存块，它是将信息从设备传输到程序或从程序传输给设备的临时存储工具</strong>。</p>
</li>
<li><p>缓冲区帮忙匹配两种不同的信息传输速率。</p>
</li>
<li><p>输出时，程序首先填满缓冲区，然后把整块数据传输给硬盘，并清空缓冲区，以备下一批输出使用，这被称为刷新缓冲区(flushing the buffer)</p>
</li>
</ul>
<h3 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h3><ul>
<li>大多数计算机程序都使用了文件。字处理程序创建文档文件；数据库程序创建和搜索信息文件；编译器读取源代码文件并生成可执行文件。</li>
<li>文件本身是存储在某种设备（磁盘，光盘，软盘或硬盘）上的一系列字节。通常，操作系统管理文件，跟踪它们的位置，大小，创建时间等。</li>
</ul>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><ul>
<li>流，是进出程序的字节流。</li>
<li>缓冲区是内存中的临时存储区域，是程序与文件或其他I&#x2F;O设备之间的桥梁。</li>
<li>信息在缓冲区和文件之间传输时，将使用设备（例如磁盘驱动器）处理效率最高的尺寸以大块数据的方式进行传输。</li>
<li>信息在缓冲区和程序之间传输时，是逐字节传输的。这种方式对于程序中的处理操作更为方便。</li>
<li>C++通过将一个被缓冲流同程序及其输入源相连接来处理输入。同样，C++也通过将一个被缓冲流和程序及其输出目标相连来处理输出。</li>
<li><code>iostream</code>和<code>fstream</code>文件构成了I&#x2F;O类库，该类库定义了大量用于管理流的类。</li>
</ul>
<h2 id="探讨C-新标准"><a href="#探讨C-新标准" class="headerlink" title="探讨C++新标准"></a>探讨C++新标准</h2><ul>
<li><p>如果仔细阅读了本书，则应很好地掌握了C++的规则，然而，这仅仅是学习这种语言的开始，接下来需要学习如何高效地使用该语言，这样的路更长。更好的情况是，工作或学习环境能够接触到优秀的C++代码和程序员。</p>
</li>
<li><p>另外，了解C++后，便可以阅读一些介绍高级主体和面向对象编程的书记，附录H列出了一些这样的资源。</p>
</li>
<li><p>OOP有助于开发大型项目，并提高其可靠性。OOP方法的基本活动之一是发明能够表示正在模拟的情况（被称为问题域(problem domain)）的类。</p>
</li>
<li><p>由于实际问题通常很复杂，因此找到适当的类富有挑战性。创建复杂的系统时，从空白开始通常不可行，最好采用<strong>逐步迭代</strong>的方式。为此，该领域的实践者开发了多种技术和策略。<strong>具体地说，重要的是在分析和设计阶段完成尽可能多的迭代工作，而不要不断地修改实际代码</strong>。</p>
</li>
<li><p>除了加深对C++的总体理解外，还可能需要学习特定的类库</p>
</li>
</ul>
<h2 id="附录H"><a href="#附录H" class="headerlink" title="附录H"></a>附录H</h2><ul>
<li><p>C++常见问题解答，第二版 – Cline, Marshall, Greg Lomow and Mike Girou. C++FAQ, Second Edition</p>
</li>
<li><p>C++标准库教程和参考手册 – Josuttis, Nicolai M. The C++ Standard Library:A Tutorial and Reference</p>
</li>
<li><p>Meyers, Scott. Effective C++:55 Specific Ways to Improve Your Programs and Designs, Third Edition.</p>
<ul>
<li>本书针对的是了解C++的程序员，提供了55条规定和指南。其中一些是技术性的，例如解释何时应该定义复制构造函数和赋值运算符；其他一些更为通用，例如对<code>is-a</code> <code>has-a</code>关系的讨论</li>
</ul>
</li>
<li><p>Stroustrup,Bjarne. The C++ Programming Language. Third Edition. </p>
</li>
<li><p><code>http://webstore.ansi.org</code></p>
</li>
<li><p><code>www.iso.org</code></p>
</li>
<li><p><code>http://www.parashift.com/C++-faq-lite</code></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-C++%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%80%E5%8D%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-C++%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%B8%80%E5%8D%B7/" class="post-title-link" itemprop="url">C++编程思想第一卷</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>不能只把C++看作是语言要素的一个集合，因为有些要素单独使用是没有意义的。如果我们不只是用C++语言编写代码，而是用它思考“设计”问题，那么必须综合使用这些要素。而且，为了以这种方法理解C++，我们必须了解使用C的问题和一般的编程问题。</p>
</li>
<li><p>我将始终坚持一种观点：读者应当在头脑中建立一个模型，以便逐步理解这种语言，直到炉火纯青的程度。如果读者遇到难题，可以将问题纳入这个模型，推导出答案。</p>
</li>
</ul>
<h1 id="第一章-对象导言"><a href="#第一章-对象导言" class="headerlink" title="第一章 对象导言"></a>第一章 对象导言</h1><ul>
<li><p>所有的程序设计语言都提供抽象。可以说，人们能解决的问题的复杂性直接与抽象的类型和质量有关。这里的类型指的是：要抽象的东西</p>
</li>
<li><p>程序员必须在机器模型（<em>在”解空间“，即建模该问题的空间中，例如在计算机上</em>）和实际上要解决的问题的模型（<em>在“问题空间”，即问题存在的空间中</em>）之间建立联系。</p>
</li>
<li><p>由于类描述了一组有相同特性（数据元素）和相同行为（功能）的对象，因此类实际上就是数据类型，例如浮点数也有一组特性和行为。</p>
</li>
<li><p>区别在于：程序员定义类是为了与具体问题相适应，而不是被迫使用已存在的数据类型，而设计这些已经存在的数据类型的动机是为了标识机器中的存储单元。程序员可以通过增添专门针对自己需要的新数据类型来扩展程序设计语言。</p>
</li>
<li><p>面向对象程序设计的难题之一，是在问题空间中的元素和解空间的对象之间建立一对一的映射。</p>
</li>
<li><p>把程序员化为为<strong>类创建者</strong>（创建新数据类型的人）和<strong>客户程序员</strong>（在应用程序中使用数据类型的类的用户）</p>
<ul>
<li>客户程序员的目标是去收集一个装满类的工具箱，用于快速应用开发</li>
<li>类创建者的目标是去建造类，这个类只暴露对于客户程序员是必需的东西，其他的都隐藏起来。</li>
</ul>
</li>
<li><p>为什么呢？因为如果是隐藏的东西，客户程序员就不能使用它，这意味着这个类的创建者可以改变隐藏的部分，而不用担心会影响到其他人</p>
</li>
<li><p><strong>访问控制</strong>的第一个理由是为了防止客户程序员插手不应当杰出的部分；第二个理由是允许库设计者去改变这个类的内部工作方式，而不必担心这样做会影响到客户程序员</p>
</li>
<li><p><strong>代码重用</strong>是面向对象程序设计语言的最大优点之一</p>
</li>
<li><p>重用一个类最简单的方法就是：直接使用这个类的对象，并且还可以将这个类的对象放到一个新类的里面，称之为“创建一个成员对象”。</p>
</li>
<li><p>可以用任何数量和类型的其他对象组成新类，通过组合得到新类所希望的功能。因为这是由已经存在的类组成新类，所以称为<strong>组合</strong>(composition)，或者更通常地称为聚合(aggregation)</p>
</li>
<li><p>当创建新类时，程序员应当首先考虑组合，因为它更简单和更灵活。</p>
</li>
<li><p><strong>对象的思想本身是一种很方便的工具。我们可以将数据和功能通过概念封装在一起，使得我们能描述合适的问题空间思想，而不是被强制使用底层机器的用语。通过使用class关键字，这些概念被表示为程序设计语言中的基本单元。</strong></p>
</li>
<li><p><strong>继承</strong>表示了在基类型和派生类型之间的这种相似性。</p>
</li>
<li><p>一个基类型具有所有由它派生出来的类型所共有的特性和行为。<strong>程序员创建一个基类型以描述关于系统中的一些对象的思想核心</strong>。由这个基类型，我们可以派生出其他类型来表述实现该核心的不同途径。</p>
</li>
<li><p>**早捆绑(early binding)**：编译器会对特定的函数名产生调用，而连接器将这个调用解析为要执行代码的绝对地址。在OOP中，直到程序运行时，编译器才能确定执行代码的地址，所以，当消息被发送给一般对象时，需要采用其他的方案</p>
</li>
<li><p>为了解决这个问题，面向对象语言采用**晚捆绑(late binding)**的思想：当给对象发送消息时，在程序运行时才去确定被调用的代码。编译器保证这个被调用的函数存在，并执行参数和返回值的类型检查（其中不采用这中处理方式的语言称为弱类型(weakly typed)语言），但是它并不知道将执行的确切代码。</p>
</li>
<li><p><strong>我们可以用关键字<code>virtual</code>声明它希望某个函数有晚捆绑的灵活性</strong></p>
</li>
<li><p>在C++中，必须记住添加<code>virtual</code>关键字，因为根据规定，默认情况下成员函数不能动态绑定。<code>virtual</code>函数（虚函数）可用来表示出在相同家族中的类具有不同的行为。这些不同是产生多态行为的原因。</p>
</li>
<li><p>我们把处理派生类型就如同处理其基类型的过程称为<strong>向上类型转换(upcasting)</strong></p>
<ul>
<li><code>cast</code>一次来自铸造领域，<code>up</code>一词来自于继承图的典型排列方式，基类型置于顶层，派生类向下层展开。这样，类型向基类型的转换是沿继承图向上移动，即“向上类型转换”。</li>
</ul>
</li>
<li><p>从技术角度，OOP的论域就是抽象数据类型，继承和多态性。但是，其他一些问题也是重要的</p>
<ul>
<li><strong>特别重要的是对象创建和销毁的方法。</strong>对象的数据存放在何处？如何控制对象的生命期？不同的程序设计语言有不同的行事之道。C++采取的方法是把效率控制作为最重要的问题，所以它为程序员提供了一个选择。<ul>
<li>为了最大化运行速度，通常将对象存放在栈中或静态存储区域中，存储和生命期可以在编写程序时确定。</li>
<li><strong>栈是内存中的一个区域，可以直接由微处理器在程序执行期间存放数据。在栈中的变量有时称为自动变量(automatic variable)或局部变量(scoped variable)</strong></li>
<li>静态存储区域简单说是内存的一个固定块，在程序开始执行以前分配。</li>
<li>使用栈或静态存储区，可以快速分配和释放，有时这是有价值的，然而，这也导致牺牲了灵活性。因为程序员必须在写程序时知道对象的准确数量，生命期和类型。</li>
<li>第二种方法是在称为堆(heap)的区域动态创建对象。这些决定是在程序运行之中作出的。如果需要新的对象，直接使用<code>new</code>关键字让它在堆上生成，当使用结束时，用关键字<code>delete</code>释放。</li>
<li><strong>因为这种存储是在运行时动态管理的，所以在堆上分配存储所需要的时间比在栈上创建存储的时间长的多（在栈上创建存储常常只是一条向下移动栈指针的微处理器指令，另外一条是移回指令）</strong></li>
</ul>
</li>
<li>另一个问题是对象的生命期<ul>
<li>如果在栈上或在静态存储上创建一个对象，编译器决定这个对象持续多长时间并能自动销毁它。然而，如果在堆上创建它，编译器则不知道它的生命期。在C++中，程序员必须编程决定何时销毁此对象。然后使用<code>delete</code>关键字执行这个销毁任务。</li>
<li>作为一个替换，运行环境可以提供一个称为**垃圾收集器(garbage collector)**的功能，当一个对象不再被使用时此功能可以自动发现并销毁这个对象。当然，使用垃圾收集器编写程序是非常方便的，但是它需要所有应用软件能忍受垃圾收集器的存在及垃圾收集的系统开销。这并不符合C++语言的设计需要，因此C++没有包括它，尽管存在用于C++的第三方垃圾收集器。</li>
</ul>
</li>
</ul>
</li>
<li><p>异常处理(exception handling)将错误处理直接与程序设计语言甚至有时是操作系统联系起来。</p>
</li>
<li><p><strong>异常是一个对象，它在出错的地方被抛出，并且被一段用以处理特定类型错误的异常处理代码(exception handler)所接收</strong></p>
</li>
<li><p>方法（method），通常称为方法论(methodology)，是一系列的过程和探索，用以降低程序设计问题的复杂性。</p>
</li>
<li><p>考虑采用一个方法之前，理解它试图要解决什么问题是重要的。</p>
</li>
<li><p>如果我们正在考虑的是一个包含丰富细节而且需要许多步骤和文档的方法学，将很难判断什么时候停止，应当牢记我们正在努力寻找的是什么：</p>
<ul>
<li>什么是对象？（如何将项目分成多个组成部分？）</li>
<li>它们的接口是什么？（需要向每个对象发送什么信息？）</li>
</ul>
</li>
<li><p>C++中引入了异常处理机制来支持复杂的出错处理，从而避免大量的出错处理逻辑干扰程序的代码。</p>
</li>
<li><p>**使用断言(assertion)来表示和强化程序中的不变量(invariant)**，是经验丰富的软件工程师的确切标志</p>
</li>
</ul>
<h1 id="第二章-对象的创建与使用"><a href="#第二章-对象的创建与使用" class="headerlink" title="第二章 对象的创建与使用"></a>第二章 对象的创建与使用</h1><ul>
<li><p>任何一种计算机语言都要从某种人们容易理解的形式（源代码）转化成计算机能执行的形式（机器指令）。通常，翻译其分为两类：解释器(interpreter)和编译器(compiler)</p>
<ul>
<li>解释器将源代码转换成一些动作（它可由多组机器指令组成）并立即执行这些动作。</li>
<li>编译器直接把源代码转换成汇编语言或机器指令。最终的结果是一个或多个机器代码的文件。</li>
</ul>
</li>
<li><p>程序可由多个文件构成，一个文件中的函数很可能要访问另一些文件中的函数和数据。编译一个文件时，C或C++编译器必须知道在另一些文件中的函数和数据，特别是它的名字和基本用法。</p>
</li>
<li><p>编译器就是要确保函数和数据被正确地使用。“告知编译器”外部函数和数据的名称及它们的模样，这一过程就是声明(declaration)。一旦声明了一个函数或变量，编译器知道怎么样检查对它们的引用，以确保引用正确。</p>
</li>
<li><p>声明(declaration)和定义(definition)</p>
<ul>
<li>声明，是向编译器介绍名字–标识符。它告诉编译器：这个函数或这个变量在某处可以找到，它的模样像什么？</li>
<li>定义，为名字分配存储空间。它说：在这里建立变量或者在这里建立函数。无论定义的是函数还是变量，编译器都要为它们在定义点分配存储空间。</li>
</ul>
</li>
<li><p>在C和C++中，可以在不同的地方声明相同的变量和函数，但是只能有一个定义（有时这称为ODR(one-definition rule, 单一定义规则)）</p>
</li>
<li><p>函数声明的语法</p>
<ul>
<li>C&#x2F;C++的函数声明就是给函数取名，指定函数的参数类型和返回值。</li>
<li>说明：对于带空参数表的函数，C和C++有很大的不同<ul>
<li>在C语言中，声明<code>int func();</code>表示：一个可带任意参数（任意数目，任意类型）的函数。这就妨碍了类型检查</li>
<li>在C++语言中它就意味着：不带参数的函数</li>
</ul>
</li>
</ul>
</li>
<li><p>变量声明的语法</p>
<ul>
<li>变量声明告知编译器变量的外表特征</li>
<li>函数声明包括函数类型（即返回值类型），函数名，参数列表和一个分号。这些信息使的编译器足以认出它是一个函数声明并可识别出这个函数的外部特征。</li>
<li>由此推断，变量声明应该是类型标识后面跟一个标识符，例如：<code>int a;</code></li>
<li>可以声明变量a是一个整数，这符合上面的逻辑。但是这就产生了一个矛盾：这段代码有足够的信息让编译器为整数a分配空间，而且编译器也确实给整数a分配了空间。要解决这个矛盾，对于C&#x2F;C++需要一个关键字来说明：这只是一个声明，它的定义在别的地方。</li>
<li>这个关键字就是<code>extern</code>，它标识变量是在文件以外定义的，或者在文件后面部分才定义的。</li>
<li><code>extern</code>也可用于函数声明。这种声明方式和普通的声明方式一样。因为没有函数体，编译器必定把它作为声明而不是函数定义。<code>extern</code>关键字对函数来说是多余的，可选的。</li>
</ul>
</li>
<li><p>标准<code>C++ include</code>语句格式</p>
<ul>
<li>从C继承下来的带有传统<code>.h</code>扩展名的库仍然可用，也可以使用更现代的C++风格使用它们，即**在文件名前面加一个字母<code>c</code>，例如：<code>#include &lt;stdio.h&gt;</code> 变为<code>#include &lt;cstdio&gt;</code></li>
<li>对所有的标准C头文件都一样。这就提供了一个区分标志，说明所使用的是C还是C++库</li>
<li>新的包含格式和老的效果是不一样的：  <ul>
<li>使用<code>.h</code>的文件是老的，非模板化的版本</li>
<li>而没有<code>.h</code>的文件是新的模板化版本。</li>
<li>如果在同一个程序中混用这两种形式，会遇到某些问题</li>
</ul>
</li>
</ul>
</li>
<li><p>名字空间</p>
<ul>
<li>标准的C++有预防名字冲突的机制：<code>namespace</code>关键字。库或程序中的每一个C++定义集被封装在一个名字空间中，如果其他的定义中有相同的名字，但它们在不同的名字空间，就不会产生冲突。</li>
<li>名字空间是十分方便和有用的工具，但是名字空间的出现意味着在写程序之前，必须知道它们。确切的说，如果仅仅只包含头文件，编译器无法找到任何有关函数和对象的声明。其所代表的含义即：<strong>虽然包含了头文件，但是所有的声明都在一个名字空间中，而没有告诉编译其我们想要用这个名字空间中的声明</strong></li>
<li>可以使用一个关键来声明：我要使用这个名字空间中的声明和（或）定义– <code>using</code></li>
</ul>
</li>
<li><p>Vector</p>
<ul>
<li>人们经常会把标准C++库的“容器”与“算法”和被称为STL的东西混淆<ul>
<li>STL（标准模板类库，Standard Template Library）是1994年春天Alex Stepanov在加州San Diego的会议上把他的C++库提交给C++标准委员会时使用的名称。这个名称一直沿用下来</li>
<li>同时，C++标准委员会对STL作了大量的修改，将它整合进标准C++类库。SGI公司不断对STL进行改进。SGI的STL与标准的C++库在许多细节上是不同的。</li>
<li>虽然人们经常产生误解，但实际上C++标准是不“包括”STL的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第三章C-中的C"><a href="#第三章C-中的C" class="headerlink" title="第三章C++中的C"></a>第三章C++中的C</h1><ul>
<li><p>标准C和C++有一个特征叫做函数原型(function prototyping)。</p>
<ul>
<li>用函数原型，在声明和定义一个函数时，必须使用参数类型描述。这种描述就是“原型”</li>
<li>调用函数时，编译器使用原型确保正确传递参数并且正确地处理返回值。如果调用函数时程序员出错了，编译器就会捕获这个错误</li>
</ul>
</li>
<li><p>用C++编程时，当前C函数库中的所有函数都可以使用。在定义自己的函数之前，应该仔细地看一下函数库，可能有人已经解决了我们的问题，而且进行了更多的思考和调试。</p>
</li>
<li><p><code>do-while</code>语句与<code>while</code>语句的区别在于：即时表达式第一次计值就等于假，前面的语句也会至少执行一次。在一般的<code>while</code>语句中，如果条件第一次为假，语句一次也不会执行。</p>
</li>
<li><p><strong>递归</strong></p>
<ul>
<li>递归是十分有趣的，有时也是非常有用的编程技巧，凭借递归可以调用我们所在的函数。</li>
<li>当然，如果这是所做的全部，那么会一直调用下去，直到内存用完，所以一定要有一种确定“到达底点”递归调用的方法。</li>
</ul>
</li>
<li><p>运算符</p>
<ul>
<li>我们可以把运算符看作是一种特殊的函数（<em>C++的运算符重载正是以这种方式对待运算符</em>）。</li>
<li>一个运算符带一个或更多的参数并产生一个新值。运算符参数和普通的函数调用参数相比在形式上不同，但是作用是一样的。</li>
</ul>
</li>
<li><p><strong>数据类型</strong></p>
<ul>
<li>在编写程序中，<strong>数据类型(data type)定义使用存储空间（内存）的方式</strong>。</li>
<li>通过定义数据类型，告诉编译器怎样创建一片特定的存储空间，以及怎样操纵这片存储空间。</li>
<li>数据类型可以是内部的或者是抽象的。<ul>
<li>内部数据类型是编译器本来能理解的数据类型，直接与编译器关联。C和C++中的内部数据类型几乎是一样的。</li>
<li>用户定义的数据类型是我们和别的程序员创建的类型，作为一个类。它们一般被称为抽象数据类型。</li>
<li>编译器启动时，知道怎样处理内部数据类型；编译器再通过读包含类声明的头文件认识怎么处理抽象数据类型。</li>
</ul>
</li>
</ul>
</li>
<li><p>基本内部类型</p>
<ul>
<li>标准C的内部类型（由C++继承）规范不说明每一个内部类型必须有多少位。规范只规定内部类型必须能存储的最大值和最小值</li>
<li>C和C++中有4个基本的内部数据类型<ul>
<li><code>char</code>是用于存储字符的，使用最小的8位（一个字节）的存储，尽管它可能占用更大的空间</li>
<li><code>int</code>存储整数值，使用最小两个字节的存储空间</li>
<li><code>float</code>和<code>double</code>类型存储浮点数，一般使用IEEE的浮点格式。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>说明符(specifier)</strong></p>
<ul>
<li>说明符用于改变基本内部类型的含义并把它们扩展成一个更大的集合。有四个说明符:<code>long, short, signed, unsigned</code></li>
<li><code>long</code>和<code>short</code>修改数据类型具有的最大值和最小值</li>
<li><code>signed</code>和<code>unsigned</code>修饰符告诉编译器怎样使用整数类型和字符的符号位（浮点数总含有一个符号）<code>unsigned</code>数不保存符号，因此有一个多余的位可用，所以它能存储比<code>signed</code>数大两倍的正数。<code>signed</code>是默认的，只有<code>char</code>才一定要使用<code>signed</code>。<code>char</code>可以默认为<code>signed</code>，也可以不默认为<code>signed</code>。通过规定<code>signed char</code>，可以强制使用符号位。</li>
</ul>
</li>
<li><p>指针简介</p>
<ul>
<li>不管什么时候运行一个程序，都是首先把它装入（一般从磁盘装入）计算机内存。因此，程序中所有元素都驻留在内存的某处。</li>
<li>内存一般被布置成一系列连续的内存位置；我们通常把这些位置看作是8位字节，但实际上每一个空间的大小取决于具体机器的结构，一般那称为机器的字长(word size)。每一个空间可按它的地址与其他空间区分。</li>
</ul>
</li>
<li><p>连接</p>
<ul>
<li><strong>在一个执行程序中，标识符代表存放变量或被编译过的函数体的存储空间。</strong></li>
<li>连接用连接器所见的方式描述存储空间。连接的方式有两种：内部连接(internal linkage)和外部连接(external linkage)<ul>
<li>内部连接意味着只对正被编译的文件创建存储空间。用内部连接，别的文件可以使用相同的标识符或全局变量，连接器不会发现冲突–也就是为每一个标识符创建单独的存储空间。在C和C++中，<strong>内部连接是由关键字<code>static</code>指定的</strong>。</li>
<li>外部连接意味着为所有被编译过的文件创建一片单独的存储空间。一旦创建存储空间，连接器必须解决所有对这片存储空间的引用。全局变量和函数名有外部连接。通过用关键字<code>extern</code>声明，可以从其他文件访问这些变量和函数。函数之外定义的所有变量（在C++中除了<code>const</code>）和函数定义默认为外部连接。可以使用关键字<code>static</code>特地强制它们具有内部连接，也可以在定义时使用关键字<code>extern</code>显式指定标识符具有外部连接。在C中，不必使用<code>extern</code>定义变量或函数，但是在C++中对于<code>const</code>有时必须使用</li>
<li>调用函数时，自动（局部）变量只是临时存储在堆栈中。连接器不知道自动变量，所以这些变量没有连接。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第四章-数据抽象"><a href="#第四章-数据抽象" class="headerlink" title="第四章 数据抽象"></a>第四章 数据抽象</h1><ul>
<li><p>什么是对象？</p>
<ul>
<li>把函数放进结构中是从C到C++中的根本改变，这引起我们将结构作为新概念去思考。</li>
<li>在C中，struct是数据的凝聚，它将数据捆绑在一起，使的我们可以将它们看作一个包，但这除了能使编程方便之外，别无其他。对这些结构进行操作的函数可以在别处。</li>
<li>然而将函数也放进这个包内，结构就变成了新的创造物了，它即能描写属性（就像C struct能做的一样），又能描述行为，这就形成了对象的概念。对象是一个独立的捆绑的实体，有自己的记忆和活动。</li>
<li><strong>在C++中，对象就是变量，它的最纯正的定义是“一块存储区”</strong>（更明确的说法是：对象必须有唯一的标识，在C++中是一个唯一的地址）。它是一块空间，在这里能够存放数据，而且还隐含着对这些数据进行处理的操作。</li>
</ul>
</li>
<li><p>抽象数据类型</p>
<ul>
<li><strong>将数据连同函数捆绑在一起的能力可以用于创建新的数据类型。这常常被称为封装(encapsulation)。</strong></li>
</ul>
</li>
<li><p>预处理指示<code>#define #ifdef #endif</code></p>
<ul>
<li>预处理指示<code>#define</code>可以用来创建编译时标记。</li>
<li>一般有两种选择：可以简单地告诉预处理器这个标记被定义，但不指定特定的值；或者给它一个值（这是典型的定义常数的C方法）</li>
<li>无论哪种情况，预处理器都能测试该标记，检查它是否已经被定义，例如<code>#ifdef FLAG</code>，这将得到一个真值，<code>#ifdef</code>后面的代码将包含在发送给编译器的包中。当预处理器遇到语句<code>#endif</code>或者<code>#endif // FLAG</code>时，包含终止</li>
<li><code>#define</code>的反意是<code>#undef</code>（<code>un-define</code>的简写）,它将使得使用相同变量的<code>#ifdef</code>语句得到假值。<code>#undef</code>还引起预处理器停止使用宏。<code>#ifdef</code>的反意是<code>ifndef</code>，如果标记还没有定义，它得到真值</li>
</ul>
</li>
</ul>
<h2 id="第四章小结"><a href="#第四章小结" class="headerlink" title="第四章小结"></a>第四章小结</h2><ul>
<li>C++的基本方法，在结构的内部放入函数。结构的这种新类型称为抽象数据类型(abstract data type)，用这种结构创建的变量称为这个类型的对象(object)或实例(instance)。调用对象的成员函数称为向这个对象发消息(sending a message)。<strong>在面向对象的程序设计中的主要动作就是向对象发消息。</strong></li>
</ul>
<h1 id="第五章-隐藏实现"><a href="#第五章-隐藏实现" class="headerlink" title="第五章 隐藏实现"></a>第五章 隐藏实现</h1><ul>
<li>访问控制通常是指实现细节的隐藏(<code>implementation hiding</code>)。将函数包含到一个结构内（常称为封装）来产生一种带数据和操作的数据类型，由访问控制在该数据类型之内确定边界，这样做的原因有两个<ul>
<li>首先是决定那些客户程序员可以用，那些客户程序员不能用。我们可以建立结构内部的机制，而不必担心客户程序员会把内部的数据机制当作它们可使用的接口的一部分来访问</li>
<li>将具体实现与接口分离开来。如果该结构被用在一系列程序中，而客户程序员只能对<code>public</code>的接口发送消息，这样就可以改变所有声明为<code>private</code>的成员而不必去修改客户程序员的代码。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-C++%E7%8E%B0%E4%BB%A3C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-C++%E7%8E%B0%E4%BB%A3C++/" class="post-title-link" itemprop="url">C++现代C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul>
<li><p>C++ 是一个用户群体相当大的语言。从 C++98 的出现到 C++11 的正式定稿经历了长达十年多之久的积累。</p>
</li>
<li><p>C++14&#x2F;17 则是作为对 C++11 的重要补充和优化，C++20 则将这门语言领进了现代化的大门，所有这些新标准中扩充的特性，给 C++ 这门语言注入了新的活力。 </p>
</li>
<li><p>那些还在坚持使用传统 C++ （本书把 C++98 及其之前的 C++ 特性均称之为传统 C++）而未接触过现代 C++ 的 C++ 程序员在见到诸如 Lambda 表达式这类全新特性时，甚至会流露出『学的不是同一门语言』的惊叹之情</p>
</li>
<li><p>现代 C++ (本书中均指 C++11&#x2F;14&#x2F;17&#x2F;20) 为传统 C++ 注入的大量特性使得整个 C++ 变得更加像一门现代化的语言。现代 C++ 不仅仅增强了 C++ 语言自身的可用性，auto 关键字语义的修改使得我们更加有信心来操控极度复杂的模板类型。同时还对语言运行期进行了大量的强化，Lambda 表达式的出现让 C++ 具有了『匿名函数』的『闭包』特性，而这一特性几乎在现代的编程语言（诸如 Python&#x2F;Swift&#x2F;… ）中已经司空见惯，右值引用的出现解决了 C++ 长期以来被人诟病的临时对象效率问题等等</p>
</li>
<li><p>C++17 则是近三年依赖 C++ 社区一致推进的方向，也指出了 现代C++ 编程的一个重要发展方向。尽管它的出现并不如 C++11 的分量之重，但它包含了大量小而美的语言与特性（例如结构化绑定），这些特性的出现再一次修正了我们在 C++ 中的编程范式。</p>
</li>
<li><p>现代 C++ 还为自身的标准库增加了非常多的工具和方法，诸如在语言自身标准的层面上制定了 std::thread，从而支持了并发编程，在不同平台上不再依赖于系统底层的 API，实现了语言层面的跨平台支持；std::regex 提供了完整的正则表达式支持等等。C++98 已经被实践证明了是一种非常成功的『范型』，而现代 C++ 的出现，则进一步推动这种范型，让 C++ 成为系统程序设计和库开发更好的语言。Concept 提供了对模板参数编译期的检查，进一步增强了语言整体的可用性。</p>
</li>
</ul>
<h2 id="第一章-迈向现代C"><a href="#第一章-迈向现代C" class="headerlink" title="第一章 迈向现代C++"></a>第一章 迈向现代C++</h2><h3 id="1-1-被弃用的特性"><a href="#1-1-被弃用的特性" class="headerlink" title="1.1 被弃用的特性"></a>1.1 被弃用的特性</h3><ul>
<li>注意：弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分特性其实会『永久』保留。</li>
<li>在学习现代 C++ 之前，我们先了解一下从 C++11 开始，被弃用的主要特性：<ul>
<li>不再允许字符串字面值常量赋值给一个 char *。如果需要用字符串字面值常量赋值和初始化一个 char *，应该使用 const char * 或者 auto。<ul>
<li><code>char *str = &quot;hello world!&quot;; // 将出现弃用警告</code></li>
</ul>
</li>
<li>C++98 异常说明、 unexpected_handler、set_unexpected() 等相关特性被弃用，应该使用 noexcept。</li>
<li>auto_ptr 被弃用，应使用 unique_ptr。</li>
<li>register 关键字被弃用，可以使用但不再具备任何实际含义。</li>
<li>bool 类型的 ++ 操作被弃用</li>
<li>如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。</li>
<li>C 语言风格的类型转换被弃用（即在变量前使用 (convert_type)），应该使用 static_cast、reinterpret_cast、const_cast 来进行类型转换。</li>
<li>特别地，在最新的 C++17 标准中弃用了一些可以使用的 C 标准库，例如 <code>&lt;ccomplex&gt;</code>、<code>&lt;cstdalign&gt;</code>、<code>&lt;cstdbool&gt;</code> 与 <code>&lt;ctgmath&gt;</code> 等</li>
<li>……等等</li>
<li>还有一些其他诸如参数绑定（C++11 提供了 std::bind 和 std::function）、export 等特性也均被弃用</li>
</ul>
</li>
</ul>
<h3 id="1-2-与C的兼容性"><a href="#1-2-与C的兼容性" class="headerlink" title="1.2 与C的兼容性"></a>1.2 与C的兼容性</h3><ul>
<li>出于一些不可抗力、历史原因，我们不得不在 C++ 中使用一些 C 语言代码（甚至古老的 C 语言代码），例如 Linux 系统调用。在现代 C++ 出现之前，大部分人当谈及『C 与 C++ 的区别是什么』时，普遍除了回答面向对象的类特性、泛型编程的模板特性外，就没有其他的看法了，甚至直接回答『差不多』，也是大有人在</li>
<li>从现在开始，你的脑子里应该树立『C++ 不是 C 的一个超集』这个观念（而且从一开始就不是，后面的进一步阅读的参考文献中给出了 C++98 和 C99 之间的区别）。</li>
<li>在编写 C++ 时，也应该尽可能的避免使用诸如 <code>void*</code> 之类的程序风格。而在不得不使用 C 时，应该注意使用 <code>extern &quot;C&quot;</code> 这种特性，将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法</li>
</ul>
<h2 id="第二章-语言可用性的强化"><a href="#第二章-语言可用性的强化" class="headerlink" title="第二章 语言可用性的强化"></a>第二章 语言可用性的强化</h2><ul>
<li>当我们声明、定义一个变量或者常量，对代码进行流程控制、面向对象的功能、模板编程等这些都是运行时之前，可能发生在编写代码或编译器编译代码时的行为。</li>
<li>为此，我们通常谈及<strong>语言可用性</strong>，是指那些发生在运行时之前的语言行为。</li>
</ul>
<h3 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h3><h4 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h4><ul>
<li>nullptr 出现的目的是为了替代 NULL。在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。</li>
<li>C++ 不允许直接将 void * 隐式转换到其他类型。但如果编译器尝试把 NULL 定义为 ((void*)0)，那么在下面这句代码中：<code>char *ch = NULL;</code></li>
<li>没有了 void * 隐式转换的 C++ 只好将 NULL 定义为 0。而这依然会产生新的问题，将 NULL 定义成 0 将导致 C++ 中重载特性发生混乱。考虑下面这两个 foo 函数：<ul>
<li><code>void foo(char *);</code></li>
<li><code>void foo(int);</code></li>
</ul>
</li>
<li>那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直觉。</li>
<li>为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较</li>
</ul>
<h4 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h4><ul>
<li><p>C++ 本身已经具备了常量表达式的概念，比如 1+2, 3*4 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。一个非常明显的例子就是在数组的定义阶段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define LEN 10</span><br><span class="line"></span><br><span class="line">int len_foo() &#123;</span><br><span class="line">    int i = 2;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">constexpr int len_foo_constexpr() &#123;</span><br><span class="line">    return 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constexpr int fibonacci(const int n) &#123;</span><br><span class="line">    return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char arr_1[10];                      // 合法</span><br><span class="line">    char arr_2[LEN];                     // 合法</span><br><span class="line"></span><br><span class="line">    int len = 10;</span><br><span class="line">    // char arr_3[len];                  // 非法</span><br><span class="line"></span><br><span class="line">    const int len_2 = len + 1;</span><br><span class="line">    constexpr int len_2_constexpr = 1 + 2 + 3;</span><br><span class="line">    // char arr_4[len_2];                // 非法</span><br><span class="line">    char arr_4[len_2_constexpr];         // 合法</span><br><span class="line"></span><br><span class="line">    // char arr_5[len_foo()+5];          // 非法</span><br><span class="line">    char arr_6[len_foo_constexpr() + 1]; // 合法</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; fibonacci(10) &lt;&lt; std::endl;</span><br><span class="line">    // 1, 1, 2, 3, 5, 8, 13, 21, 34, 55</span><br><span class="line">    std::cout &lt;&lt; fibonacci(10) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上面的例子中，<code>char arr_4[len_2]</code> 可能比较令人困惑，因为 len_2 已经被定义为了常量。为什么 <code>char arr_4[len_2]</code> 仍然是非法的呢？这是因为 C++ 标准中数组的长度必须是一个常量表达式，而对于 len_2 而言，这是一个 const 常数，而不是一个常量表达式，因此（即便这种行为在大部分编译器中都支持，但是）它是一个非法的行为，我们需要使用接下来即将介绍的 C++11 引入的 constexpr 特性来解决这个问题；而对于 arr_5 来说，C++98 之前的编译器无法得知 len_foo() 在运行期实际上是返回一个常数，这也就导致了非法的产生</p>
</li>
<li><p>注意，现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。</p>
</li>
<li><p>C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 len_foo 在编译期就应该是一个常量表达式。</p>
</li>
<li><p>此外，constexpr 修饰的函数可以使用递归：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr int fibonacci(const int n) &#123;</span><br><span class="line">    return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句，例如下面的代码在 C++11 的标准下是不能够通过编译的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constexpr int fibonacci(const int n) &#123;</span><br><span class="line">    if(n == 1) return 1;</span><br><span class="line">    if(n == 2) return 1;</span><br><span class="line">    return fibonacci(n-1) + fibonacci(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-变量及其初始化"><a href="#2-2-变量及其初始化" class="headerlink" title="2.2 变量及其初始化"></a>2.2 变量及其初始化</h3><h4 id="if-switch-变量声明强化"><a href="#if-switch-变量声明强化" class="headerlink" title="if&#x2F;switch 变量声明强化"></a>if&#x2F;switch 变量声明强化</h4><ul>
<li>在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终没有办法在 if 和 switch 语句中声明一个临时的变量。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4&#125;;</span><br><span class="line"></span><br><span class="line">    // 在 c++17 之前</span><br><span class="line">    const std::vector&lt;int&gt;::iterator itr = std::find(vec.begin(), vec.end(), 2);</span><br><span class="line">    if (itr != vec.end()) &#123;</span><br><span class="line">        *itr = 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 需要重新定义一个新的变量</span><br><span class="line">    const std::vector&lt;int&gt;::iterator itr2 = std::find(vec.begin(), vec.end(), 3);</span><br><span class="line">    if (itr2 != vec.end()) &#123;</span><br><span class="line">        *itr2 = 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将输出 1, 4, 3, 4</span><br><span class="line">    for (std::vector&lt;int&gt;::iterator element = vec.begin(); element != vec.end(); </span><br><span class="line">        ++element)</span><br><span class="line">        std::cout &lt;&lt; *element &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在上面的代码中，我们可以看到 itr 这一变量是定义在整个 main() 的作用域内的，这导致当我们需要再次遍历整个 std::vector 时，需要重新命名另一个变量。C++17 消除了这一限制，使得我们可以在 if（或 switch）中完成这一操作：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将临时变量放到 if 语句内</span><br><span class="line">if (const std::vector&lt;int&gt;::iterator itr = std::find(vec.begin(), vec.end(), 3);</span><br><span class="line">    itr != vec.end()) &#123;</span><br><span class="line">    *itr = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><ul>
<li><p>初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。 </p>
</li>
<li><p>在传统 C++ 中，不同的对象有着不同的初始化方法，例如普通数组、 POD （Plain Old Data，即没有构造、析构和虚函数的类或结构体） 类型都可以使用 {} 进行初始化，也就是我们所说的初始化列表。 而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 () 进行。 这些不同方法都针对各自对象，不能通用。</p>
</li>
<li><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">    int value_a;</span><br><span class="line">    int value_b;</span><br><span class="line">    Foo(int a, int b) : value_a(a), value_b(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // before C++11</span><br><span class="line">    int arr[3] = &#123;1, 2, 3&#125;;</span><br><span class="line">    Foo foo(1, 2);</span><br><span class="line">    std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;arr[0]: &quot; &lt;&lt; arr[0] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;foo:&quot; &lt;&lt; foo.value_a &lt;&lt; &quot;, &quot; &lt;&lt; foo.value_b &lt;&lt; std::endl;</span><br><span class="line">    for (std::vector&lt;int&gt;::iterator it = vec.begin(); it != vec.end(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>为解决这个问题，C++11 首先把初始化列表的概念绑定到类型上，称其为 <code>std::initializer_list</code>，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class MagicFoo &#123;</span><br><span class="line">public:</span><br><span class="line">    std::vector&lt;int&gt; vec;</span><br><span class="line">    MagicFoo(std::initializer_list&lt;int&gt; list) &#123;</span><br><span class="line">        for (std::initializer_list&lt;int&gt;::iterator it = list.begin();</span><br><span class="line">             it != list.end(); ++it)</span><br><span class="line">            vec.push_back(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    // after C++11</span><br><span class="line">    MagicFoo magicFoo = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;magicFoo: &quot;;</span><br><span class="line">    for (std::vector&lt;int&gt;::iterator it = magicFoo.vec.begin(); </span><br><span class="line">        it != magicFoo.vec.end(); ++it) </span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照</p>
</li>
<li><p>初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    void foo(std::initializer_list&lt;int&gt; list) &#123;</span><br><span class="line">        for (std::initializer_list&lt;int&gt;::iterator it = list.begin();</span><br><span class="line">            it != list.end(); ++it) vec.push_back(*it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">magicFoo.foo(&#123;6,7,8,9&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>其次，C++11 还提供了统一的语法来初始化任意的对象，例如：<code>Foo foo2 &#123;3, 4&#125;;</code></p>
</li>
</ul>
<h4 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h4><ul>
<li>结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新增了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11&#x2F;14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦</li>
<li>C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;tuple&gt;</span><br><span class="line"></span><br><span class="line">std::tuple&lt;int, double, std::string&gt; f() &#123;</span><br><span class="line">    return std::make_tuple(1, 2.3, &quot;456&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto [x, y, z] = f();</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-类型推导"><a href="#2-3-类型推导" class="headerlink" title="2.3 类型推导"></a>2.3 类型推导</h3><ul>
<li>在传统 C 和 C++ 中，参数的类型都必须明确定义，这其实对我们快速进行编码没有任何帮助，尤其是当我们面对一大堆复杂的模板类型时，必须明确的指出变量的类型才能进行后续的编码，这不仅拖慢我们的开发效率，也让代码变得又臭又长</li>
<li>C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯</li>
</ul>
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><ul>
<li><p>auto 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 register 并存。在传统 C++ 中，如果一个变量没有声明为 register 变量，将自动被视为一个 auto 变量。而随着 register 被弃用（在 C++17 中作为保留关键字，以后使用，目前不具备实际意义），对 auto 的语义变更也就非常自然了</p>
</li>
<li><p>使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。你应该在前面的小节里看到了传统 C++ 中冗长的迭代写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在 C++11 之前</span><br><span class="line">// 由于 cbegin() 将返回 vector&lt;int&gt;::const_iterator</span><br><span class="line">// 所以 it 也应该是 vector&lt;int&gt;::const_iterator 类型</span><br><span class="line">for(vector&lt;int&gt;::const_iterator it = vec.cbegin(); it != vec.cend(); ++it)</span><br></pre></td></tr></table></figure></li>
<li><p>而有了 auto 之后可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class MagicFoo &#123;</span><br><span class="line">public:</span><br><span class="line">    std::vector&lt;int&gt; vec;</span><br><span class="line">    MagicFoo(std::initializer_list&lt;int&gt; list) &#123;</span><br><span class="line">        // 从 C++11 起, 使用 auto 关键字进行类型推导</span><br><span class="line">        for (auto it = list.begin(); it != list.end(); ++it) &#123;</span><br><span class="line">            vec.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    MagicFoo magicFoo = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    std::cout &lt;&lt; &quot;magicFoo: &quot;;</span><br><span class="line">    for (auto it = magicFoo.vec.begin(); it != magicFoo.vec.end(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; &quot;, &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些其他的常见用法：</p>
<ul>
<li><code>auto i = 5;              // i 被推导为 int</code></li>
<li><code>auto arr = new auto(10); // arr 被推导为 int *</code></li>
</ul>
</li>
<li><p>从 C++ 20 起，auto 甚至能用于函数传参，考虑下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int add(auto x, auto y) &#123;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto i = 5; // 被推导为 int</span><br><span class="line">auto j = 6; // 被推导为 int</span><br><span class="line">std::cout &lt;&lt; add(i, j) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：auto 还不能用于推导数组类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto auto_arr2[10] = &#123;arr&#125;; // 错误, 无法推导数组元素类型</span><br><span class="line"></span><br><span class="line">2.6.auto.cpp:30:19: error: &#x27;auto_arr2&#x27; declared as array of &#x27;auto&#x27;</span><br><span class="line">    auto auto_arr2[10] = &#123;arr&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><ul>
<li>decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 typeof 很相似：<code>decltype(表达式)</code></li>
<li>有时候，我们可能需要计算某个表达式的类型，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto x = 1;</span><br><span class="line">auto y = 2;</span><br><span class="line">decltype(x+y) z;</span><br></pre></td></tr></table></figure></li>
<li>你已经在前面的例子中看到 decltype 用于推断类型的用法，下面这个例子就是判断上面的变量 x, y, z 是否是同一类型：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (std::is_same&lt;decltype(x), int&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; &quot;type x == int&quot; &lt;&lt; std::endl;</span><br><span class="line">if (std::is_same&lt;decltype(x), float&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; &quot;type x == float&quot; &lt;&lt; std::endl;</span><br><span class="line">if (std::is_same&lt;decltype(x), decltype(z)&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; &quot;type z == type x&quot; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
<li>其中，<code>std::is_same&lt;T, U&gt;</code> 用于判断 T 和 U 这两个类型是否相等。输出结果为：<ul>
<li><code>type x == int</code></li>
<li><code>type z == type x</code></li>
</ul>
</li>
</ul>
<h4 id="尾返回类型推导"><a href="#尾返回类型推导" class="headerlink" title="尾返回类型推导"></a>尾返回类型推导</h4><ul>
<li><p>你可能会思考，在介绍 auto 时，我们已经提过 auto 不能用于函数形参进行类型推导，那么 auto 能不能用于推导函数的返回类型呢？还是考虑一个加法函数的例子，在传统 C++ 中我们必须这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename R, typename T, typename U&gt;</span><br><span class="line">R add(T x, U y) &#123;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。但在模板中定义有嵌套依赖类型的变量时，需要用 typename 消除歧义</p>
</li>
<li><p>这样的代码其实变得很丑陋，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 add() 这个函数会做什么样的操作，以及获得一个什么样的返回类型</p>
</li>
<li><p>在 C++11 中这个问题得到解决。虽然你可能马上会反应出来使用 decltype 推导 x+y 的类型，写出这样的代码：<code>decltype(x + y) add( T x, U y)</code></p>
</li>
<li><p>但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键字将返回类型后置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename U&gt;</span><br><span class="line">auto add2(T x, U y) -&gt; decltype(x+y)&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>令人欣慰的是从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename U&gt;</span><br><span class="line">auto add3(T x, U y)&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可以检查一下类型推导是否正确：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// after c++11</span><br><span class="line">auto w = add2&lt;int, double&gt;(1, 2.0);</span><br><span class="line">if (std::is_same&lt;decltype(w), double&gt;::value) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;w is double: &quot;;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; w &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">// after c++14</span><br><span class="line">auto q = add3&lt;double, int&gt;(1.0, 2);</span><br><span class="line">std::cout &lt;&lt; &quot;q: &quot; &lt;&lt; q &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h4><ul>
<li><p><code>decltype(auto)</code> 是 C++14 开始提供的一个略微复杂的用法。要理解它你需要知道 C++ 中参数转发的概念，我们会在语言运行时强化一章中详细介绍，你可以到时再回来看这一小节的内容。</p>
</li>
<li><p>简单来说，decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 decltype 的参数表达式。考虑看下面的例子，当我们需要对下面两个函数进行封装时：</p>
<ul>
<li><code>std::string  lookup1();</code></li>
<li><code>std::string&amp; lookup2();</code></li>
</ul>
</li>
<li><p>在 C++11 中，封装实现是如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string look_up_a_string_1() &#123;</span><br><span class="line">    return lookup1();</span><br><span class="line">&#125;</span><br><span class="line">std::string&amp; look_up_a_string_2() &#123;</span><br><span class="line">    return lookup2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>而有了 decltype(auto)，我们可以让编译器完成这一件烦人的参数转发：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    decltype(auto) look_up_a_string_1() &#123;</span><br><span class="line">        return lookup1();</span><br><span class="line">    &#125;</span><br><span class="line">    decltype(auto) look_up_a_string_2() &#123;</span><br><span class="line">        return lookup2();</span><br><span class="line">    &#125;</span><br><span class="line">  ```  </span><br><span class="line"></span><br><span class="line">### 2.4 控制流</span><br><span class="line"></span><br><span class="line">#### if constexpr</span><br><span class="line"></span><br><span class="line">+ 正如本章开头出，我们知道了 C++11 引入了 constexpr 关键字，它将表达式或函数编译为常量结果。一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断，岂不是能让程序效率更高？C++17 将 constexpr 这个关键字引入到 if 语句中，允许在代码中声明常量表达式的判断条件，考虑下面的代码：</span><br></pre></td></tr></table></figure>
<p>  #include <iostream></p>
<p>  template<typename T><br>  auto print_type_info(const T&amp; t) {<br>  if constexpr (std::is_integral<T>::value) {<br>      return t + 1;<br>  } else {<br>      return t + 0.001;<br>  }<br>  }<br>  int main() {<br>  std::cout &lt;&lt; print_type_info(5) &lt;&lt; std::endl;<br>  std::cout &lt;&lt; print_type_info(3.14) &lt;&lt; std::endl;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 在编译时，实际代码就会表现为如下：</span><br></pre></td></tr></table></figure>
<p>  int print_type_info(const int&amp; t) {<br>  return t + 1;<br>  }<br>  double print_type_info(const double&amp; t) {<br>  return t + 0.001;<br>  }<br>  int main() {<br>  std::cout &lt;&lt; print_type_info(5) &lt;&lt; std::endl;<br>  std::cout &lt;&lt; print_type_info(3.14) &lt;&lt; std::endl;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 区间for迭代</span><br><span class="line"></span><br><span class="line">+ 终于，C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句，我们可以进一步简化前面的例子：</span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <vector><br>  #include <algorithm></p>
<p>  int main() {<br>  std::vector<int> vec &#x3D; {1, 2, 3, 4};<br>  if (auto itr &#x3D; std::find(vec.begin(), vec.end(), 3); itr !&#x3D; vec.end()) *itr &#x3D; 4;<br>  for (auto element : vec)<br>      std::cout &lt;&lt; element &lt;&lt; std::endl; &#x2F;&#x2F; read only<br>  for (auto &amp;element : vec) {<br>      element +&#x3D; 1;                      &#x2F;&#x2F; writeable<br>  }<br>  for (auto element : vec)<br>      std::cout &lt;&lt; element &lt;&lt; std::endl; &#x2F;&#x2F; read only<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.5 模板</span><br><span class="line"></span><br><span class="line">+ C++ 的模板一直是这门语言的一种特殊的艺术，模板甚至可以独立作为一门新的语言来进行使用。模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。</span><br><span class="line"></span><br><span class="line">#### 外部模板</span><br><span class="line"></span><br><span class="line">+ 传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板的实例化。</span><br><span class="line">+ 为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化：</span><br></pre></td></tr></table></figure>
<p>  template class std::vector<bool>;          &#x2F;&#x2F; 强行实例化<br>  extern template class std::vector<double>; &#x2F;&#x2F; 不在该当前编译文件中实例化模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 尖括号`&quot;&gt;&quot;`</span><br><span class="line"></span><br><span class="line">+ 在传统 C++ 的编译器中，&gt;&gt;一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码：`std::vector&lt;std::vector&lt;int&gt;&gt; matrix;`</span><br><span class="line">+ 这在传统 C++ 编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。甚至于像下面这种写法都能够通过编译：</span><br></pre></td></tr></table></figure>
<p>  template<bool T><br>  class MagicType {<br>  bool magic &#x3D; T;<br>  };</p>
<p>  &#x2F;&#x2F; in main function:<br>  std::vector&lt;MagicType&lt;(1&gt;2)&gt;&gt; magic; &#x2F;&#x2F; 合法, 但不建议写出这样的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 类型别名模板</span><br><span class="line"></span><br><span class="line">+ 在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：模板是用来产生类型的。在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：</span><br></pre></td></tr></table></figure>
<p>  template&lt;typename T, typename U&gt;<br>  class MagicType {<br>  public:<br>  T dark;<br>  U magic;<br>  };</p>
<p>  &#x2F;&#x2F; 不合法<br>  template<typename T><br>  typedef MagicType&lt;std::vector<T>, std::string&gt; FakeDarkMagic;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效</span><br><span class="line">+ 通常我们使用 typedef 定义别名的语法是：`typedef 原名称 新名称;`，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。</span><br></pre></td></tr></table></figure>
<p>  typedef int (*process)(void <em>);<br>  using NewProcess &#x3D; int(</em>)(void *);<br>  template<typename T><br>  using TrueDarkMagic &#x3D; MagicType&lt;std::vector<T>, std::string&gt;;</p>
<p>  int main() {<br>  TrueDarkMagic<bool> you;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 变成参数模板</span><br><span class="line"></span><br><span class="line">+ 模板一直是 C++ 所独有的黑魔法（一起念：Dark Magic）之一。 在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子， 接受一组固定数量的模板参数；而 C++11 加入了新的表示方法， 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</span><br><span class="line">+ `template&lt;typename... Ts&gt; class Magic;`</span><br><span class="line">+ 模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如下面的定义：</span><br></pre></td></tr></table></figure>
<p>  class Magic&lt;int,<br>          std::vector<int>,<br>          std::map&lt;std::string,<br>          std::vector<int>&gt;&gt; darkMagic;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 既然是任意形式，所以个数为 0 的模板参数也是可以的：`class Magic&lt;&gt; nothing;`。</span><br><span class="line">+ 如果不希望产生的模板参数个数为 0，可以手动的定义至少一个模板参数：</span><br><span class="line">  + `template&lt;typename Require, typename... Args&gt; class Magic;`</span><br><span class="line">+ 变长参数模板也能被直接调整到到模板函数上。传统 C 中的 printf 函数， 虽然也能达成不定个数的形参的调用，但其并非类别安全。 而 C++11 除了能定义类别安全的变长参数函数外， 还可以使类似 printf 的函数能自然地处理非自带类别的对象。 除了在模板参数中能使用 ... 表示不定长模板参数外， 函数参数也使用同样的表示法代表不定长参数， 这也就为我们简单编写变长参数函数提供了便捷的手段，例如：</span><br><span class="line">  + `template&lt;typename... Args&gt; void printf(const std::string &amp;str, Args... args);`</span><br><span class="line"></span><br><span class="line">+ 那么我们定义了变长的模板参数，如何对参数进行解包呢？</span><br><span class="line">  + 首先，我们可以使用 sizeof... 来计算参数的个数，：</span><br></pre></td></tr></table></figure>
<pre><code>template&lt;typename... Ts&gt;
void magic(Ts... args) &#123;
    std::cout &lt;&lt; sizeof...(args) &lt;&lt; std::endl;
&#125;
</code></pre>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 我们可以传递任意个参数给 magic 函数：</span><br></pre></td></tr></table></figure>
<pre><code>magic(); // 输出0
magic(1); // 输出1
magic(1, &quot;&quot;); // 输出2
</code></pre>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ 其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法：</span><br><span class="line">  1. 递归模板函数</span><br><span class="line">    + 递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的：</span><br></pre></td></tr></table></figure>
<pre><code>    #include &lt;iostream&gt;
    template&lt;typename T0&gt;
    void printf1(T0 value) &#123;
        std::cout &lt;&lt; value &lt;&lt; std::endl;
    &#125;
    template&lt;typename T, typename... Ts&gt;
    void printf1(T value, Ts... args) &#123;
        std::cout &lt;&lt; value &lt;&lt; std::endl;
        printf1(args...);
    &#125;
    int main() &#123;
        printf1(1, 2, &quot;123&quot;, 1.1);
        return 0;
    &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. 变参模板展开</span><br><span class="line">  + 你应该感受到了这很繁琐，在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 printf 的编写：</span><br></pre></td></tr></table></figure>
    template&lt;typename T0, typename... T&gt;
    void printf2(T0 t0, T... t) &#123;
        std::cout &lt;&lt; t0 &lt;&lt; std::endl;
        if constexpr (sizeof...(t) &gt; 0) printf2(t...);
    &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   + 事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 std::bind 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。</span><br><span class="line">3. 初始化列表展开</span><br><span class="line">   + 递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。</span><br><span class="line">   + 这里介绍一种使用初始化列表展开的黑魔法：</span><br></pre></td></tr></table></figure>
       template&lt;typename T, typename... Ts&gt;
       auto printf3(T value, Ts... args) &#123;
           std::cout &lt;&lt; value &lt;&lt; std::endl;
           (void) std::initializer_list&lt;T&gt;&#123;([&amp;args] &#123;
               std::cout &lt;&lt; args &lt;&lt; std::endl;
           &#125;(), value)...&#125;;
       &#125;
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        + 在这个代码中，额外使用了 C++11 中提供的初始化列表以及 Lambda 表达式的特性（下一节中将提到）。</span><br><span class="line">        + 通过初始化列表，(lambda 表达式, value)... 将会被展开。由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。 为了避免编译器警告，我们可以将 std::initializer_list 显式的转为 void</span><br><span class="line"></span><br><span class="line">#### 折叠表达式</span><br><span class="line"></span><br><span class="line">+ C++ 17 中将变长参数这种特性进一步带给了表达式，考虑下面这个例子：</span><br></pre></td></tr></table></figure>
</code></pre>
<p>  #include <iostream><br>  template&lt;typename … T&gt;<br>  auto sum(T … t) {<br>  return (t + …);<br>  }<br>  int main() {<br>  std::cout &lt;&lt; sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) &lt;&lt; std::endl;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 非类型模板参数推导</span><br><span class="line"></span><br><span class="line">+ 前面我们主要提及的是模板参数的一种形式：类型模板参数。</span><br></pre></td></tr></table></figure>
<p>  template &lt;typename T, typename U&gt;<br>  auto add(T t, U u) {<br>  return t+u;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 其中模板的参数 T 和 U 为具体的类型。 但还有一种常见模板参数形式可以让不同字面量成为模板参数，即非类型模板参数：</span><br></pre></td></tr></table></figure>
<p>  template &lt;typename T, int BufSize&gt;<br>  class buffer_t {<br>  public:<br>  T&amp; alloc();<br>  void free(T&amp; item);<br>  private:<br>  T data[BufSize];<br>  }</p>
<p>  buffer_t&lt;int, 100&gt; buf; &#x2F;&#x2F; 100 作为模板参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 在这种模板参数形式下，我们可以将 100 作为模板的参数进行传递。 在 C++11 引入了类型推导这一特性后，我们会很自然的问，既然此处的模板参数 以具体的字面量进行传递，能否让编译器辅助我们进行类型推导， 通过使用占位符 auto 从而不再需要明确指明类型？ 幸运的是，C++17 引入了这一特性，我们的确可以 auto 关键字，让编译器辅助完成具体类型的推导， 例如：</span><br></pre></td></tr></table></figure>
<p>  template <auto value> void foo() {<br>  std::cout &lt;&lt; value &lt;&lt; std::endl;<br>  return;<br>  }</p>
<p>  int main() {<br>  foo&lt;10&gt;();  &#x2F;&#x2F; value 被推导为 int 类型<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.6 面向对象</span><br><span class="line"></span><br><span class="line">#### 委托构造</span><br><span class="line"></span><br><span class="line">+ C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：</span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  class Base {<br>  public:<br>  int value1;<br>  int value2;<br>  Base() {<br>      value1 &#x3D; 1;<br>  }<br>  Base(int value) : Base() { &#x2F;&#x2F; 委托 Base() 构造函数<br>      value2 &#x3D; value;<br>  }<br>  };</p>
<p>  int main() {<br>  Base b(2);<br>  std::cout &lt;&lt; b.value1 &lt;&lt; std::endl;<br>  std::cout &lt;&lt; b.value2 &lt;&lt; std::endl;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 继承构造</span><br><span class="line"></span><br><span class="line">+ 在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 using 引入了继承构造函数的概念：</span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  class Base {<br>  public:<br>  int value1;<br>  int value2;<br>  Base() {<br>      value1 &#x3D; 1;<br>  }<br>  Base(int value) : Base() { &#x2F;&#x2F; 委托 Base() 构造函数<br>      value2 &#x3D; value;<br>  }<br>  };<br>  class Subclass : public Base {<br>  public:<br>  using Base::Base; &#x2F;&#x2F; 继承构造<br>  };<br>  int main() {<br>  Subclass s(3);<br>  std::cout &lt;&lt; s.value1 &lt;&lt; std::endl;<br>  std::cout &lt;&lt; s.value2 &lt;&lt; std::endl;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 显式虚函数重载</span><br><span class="line"></span><br><span class="line">+ 在传统 C++ 中，经常容易发生意外重载虚函数的事情。例如：</span><br></pre></td></tr></table></figure>
<p>  struct Base {<br>  virtual void foo();<br>  };<br>  struct SubClass: Base {<br>  void foo();<br>  };</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ `SubClass::foo` 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果</span><br><span class="line"></span><br><span class="line">+ C++11 引入了 override 和 final 这两个关键字来防止上述情形的发生。</span><br><span class="line">+ 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：</span><br></pre></td></tr></table></figure>
<p>  struct Base {<br>  virtual void foo(int);<br>  };<br>  struct SubClass: Base {<br>  virtual void foo(int) override; &#x2F;&#x2F; 合法<br>  virtual void foo(float) override; &#x2F;&#x2F; 非法, 父类没有此虚函数<br>  };</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</span><br></pre></td></tr></table></figure>
<p>  struct Base {<br>  virtual void foo() final;<br>  };<br>  struct SubClass1 final: Base {<br>  }; &#x2F;&#x2F; 合法</p>
<p>  struct SubClass2 : SubClass1 {<br>  }; &#x2F;&#x2F; 非法, SubClass1 已 final</p>
<p>  struct SubClass3: Base {<br>  void foo(); &#x2F;&#x2F; 非法, foo 已 final<br>  };</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 显式禁用默认函数</span><br><span class="line"></span><br><span class="line">+ 在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、 复制构造、赋值算符以及析构函数。 另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。 当程序员有需要时，可以重载这部分函数</span><br><span class="line">+ 这就引发了一些需求：无法精确控制默认函数的生成行为。 例如禁止类的拷贝时，必须将复制构造函数与赋值算符声明为 private。 尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式</span><br><span class="line">+ 并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器将不再生成默认构造函数， 但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬</span><br><span class="line">+ C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数。 例如：</span><br></pre></td></tr></table></figure>
<p>  class Magic {<br>  public:<br>  Magic() &#x3D; default; &#x2F;&#x2F; 显式声明使用编译器生成的构造<br>  Magic&amp; operator&#x3D;(const Magic&amp;) &#x3D; delete; &#x2F;&#x2F; 显式声明拒绝编译器生成构造<br>  Magic(int magic_number);<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 强类型枚举</span><br><span class="line"></span><br><span class="line">+ 在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同，这通常不是我们希望看到的结果</span><br><span class="line">+ C++11 引入了枚举类（enumeration class），并使用 enum class 的语法进行声明：</span><br><span class="line">  ```c++</span><br><span class="line">    enum class new_enum : unsigned int &#123;</span><br><span class="line">        value1,</span><br><span class="line">        value2,</span><br><span class="line">        value3 = 100,</span><br><span class="line">        value4 = 100</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较， 更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_enum::value3 == new_enum::value4) &#123;</span><br><span class="line">    <span class="comment">// 会输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;new_enum::value3 == new_enum::value4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在这个语法中，枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 int）</p>
</li>
<li><p>而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 &lt;&lt; 这个算符来进行输出，可以收藏下面这个代码段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">std::ostream&amp; operator&lt;&lt;(</span><br><span class="line">    typename std::enable_if&lt;std::is_enum&lt;T&gt;::value,</span><br><span class="line">        std::ostream&gt;::type&amp; stream, const T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    return stream &lt;&lt; static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这时，下面的代码将能够被编译：</p>
<ul>
<li><code>std::cout &lt;&lt; new_enum::value3 &lt;&lt; std::endl</code></li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>本节介绍了现代 C++ 中对语言可用性的增强，其中笔者认为最为重要的几个特性是几乎所有人都需要了解并熟练使用的：<ul>
<li>auto 类型推导</li>
<li>范围 for 迭代</li>
<li>初始化列表</li>
<li>变参模板</li>
</ul>
</li>
</ul>
<h2 id="第三章-语言运行期的强化"><a href="#第三章-语言运行期的强化" class="headerlink" title="第三章 语言运行期的强化"></a>第三章 语言运行期的强化</h2><h3 id="3-1-Lambda表达式"><a href="#3-1-Lambda表达式" class="headerlink" title="3.1 Lambda表达式"></a>3.1 Lambda表达式</h3><ul>
<li>Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性， 而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多， 所以匿名函数几乎是现代编程语言的标配。</li>
</ul>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li><p>Lambda 表达式的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line">// 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上面的语法规则除了 <code>[捕获列表]</code> 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去， 返回值使用了一个 <code>-&gt;</code> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）</p>
</li>
<li><p>所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：</p>
<ul>
<li>值捕获<ul>
<li>与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void lambda_value_capture() &#123;</span><br><span class="line">    int value = 1;</span><br><span class="line">    auto copy_value = [value] &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = 100;</span><br><span class="line">    auto stored_value = copy_value();</span><br><span class="line">    std::cout &lt;&lt; &quot;stored_value = &quot; &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    // 这时, stored_value == 1, 而 value == 100.</span><br><span class="line">    // 因为 copy_value 在创建时就保存了一份 value 的拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>引用捕获<ul>
<li>与引用传参类似，引用捕获保存的是引用，值会发生变化。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void lambda_reference_capture() &#123;</span><br><span class="line">    int value = 1;</span><br><span class="line">    auto copy_value = [&amp;value] &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = 100;</span><br><span class="line">    auto stored_value = copy_value();</span><br><span class="line">    std::cout &lt;&lt; &quot;stored_value = &quot; &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    // 这时, stored_value == 100, value == 100.</span><br><span class="line">    // 因为 copy_value 保存的是引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>隐式捕获<ul>
<li>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 &amp; 或 &#x3D; 向编译器声明采用引用捕获或者值捕获.</li>
</ul>
</li>
</ul>
</li>
<li><p>总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：</p>
<ul>
<li><code>[]</code> 空捕获列表</li>
<li><code>[name1, name2, ...]</code> 捕获一系列变量</li>
<li><code>[&amp;]</code> 引用捕获, 让编译器自行推导引用列表</li>
<li><code>[=]</code> 值捕获, 让编译器自行推导值捕获列表</li>
</ul>
</li>
<li><p>表达式捕获。（这部分内容需要了解后面马上要提到的右值引用以及智能指针）</p>
</li>
<li><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。</p>
</li>
<li><p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;  // std::make_unique</span><br><span class="line">#include &lt;utility&gt; // std::move</span><br><span class="line"></span><br><span class="line">void lambda_expression_capture() &#123;</span><br><span class="line">    auto important = std::make_unique&lt;int&gt;(1);</span><br><span class="line">    auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -&gt; int &#123;</span><br><span class="line">        return x+y+v1+(*v2);</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; add(3,4) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在上面的代码中，important 是一个独占指针，是不能够被 “&#x3D;” 值捕获到，这时候我们可以将其转移为右值，在表达式中初始化。</p>
</li>
</ul>
<h4 id="泛型Lambda"><a href="#泛型Lambda" class="headerlink" title="泛型Lambda"></a>泛型Lambda</h4><ul>
<li>上一节中我们提到了 auto 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以在没有明确指明参数表类型的情况下，Lambda 表达式并不能够模板化。 幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，Lambda 函数的形式参数可以使用 auto 关键字来产生意义上的泛型：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto add = [](auto x, auto y) &#123;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(1, 2);</span><br><span class="line">add(1.1, 2.2);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-函数对象包装器"><a href="#3-2-函数对象包装器" class="headerlink" title="3.2 函数对象包装器"></a>3.2 函数对象包装器</h3><ul>
<li>这部分内容虽然属于标准库的一部分，但是从本质上来看，它却增强了 C++ 语言运行时的能力， 这部分内容也相当重要，所以放到这里来进行介绍。</li>
</ul>
<h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h4><ul>
<li><p>Lambda 表达式的本质是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象）， 当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> foo = <span class="built_in">void</span>(<span class="type">int</span>); <span class="comment">// 定义函数类型, using 的使用见上一节中的别名语法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functional</span><span class="params">(foo f)</span> </span>&#123; <span class="comment">// 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo*</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="type">int</span> value) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">functional</span>(f); <span class="comment">// 传递闭包对象，隐式转换为 foo* 类型的函数指针值</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// lambda 表达式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用， 而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型， 统一称之为可调用类型。而这种类型，便是通过 std::function 引入的</p>
</li>
<li><p>C++11 std::function 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。 例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> para)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::function 包装了一个返回值为 int, 参数为 int 的函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = foo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> important = <span class="number">10</span>;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func2 = [&amp;](<span class="type">int</span> value) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+value+important;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="std-bind-和-std-placeholder"><a href="#std-bind-和-std-placeholder" class="headerlink" title="std::bind 和 std::placeholder"></a>std::bind 和 std::placeholder</h4><ul>
<li><p>而 std::bind 则是用来绑定函数调用的参数的， 它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。 例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数1,2绑定到函数 foo 上，</span></span><br><span class="line">    <span class="comment">// 但使用 std::placeholders::_1 来对第一个参数进行占位</span></span><br><span class="line">    <span class="keyword">auto</span> bindFoo = std::<span class="built_in">bind</span>(foo, std::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span></span><br><span class="line">    <span class="built_in">bindFoo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提示：注意 auto 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型， 但是我们却可以通过 auto 的使用来规避这一问题的出现。</p>
</li>
</ul>
<h3 id="3-3-右值引用"><a href="#3-3-右值引用" class="headerlink" title="3.3 右值引用"></a>3.3 右值引用</h3><ul>
<li>右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大量的历史遗留问题， 消除了诸如 std::vector、std::string 之类的额外开销， 也才使得函数对象容器 std::function 成为了可能。</li>
</ul>
<h4 id="左值，-右值的纯右值，将亡值，右值"><a href="#左值，-右值的纯右值，将亡值，右值" class="headerlink" title="左值， 右值的纯右值，将亡值，右值"></a>左值， 右值的纯右值，将亡值，右值</h4><ul>
<li><p>要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。</p>
<ul>
<li>左值 (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。</li>
<li>右值 (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。</li>
</ul>
</li>
<li><p>而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。</p>
<ul>
<li>纯右值 (prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值</li>
</ul>
</li>
<li><p>需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 正确，&quot;01234&quot; 类型为 const char [6]，因此是左值</span><br><span class="line">    const char (&amp;left)[6] = &quot;01234&quot;;</span><br><span class="line"></span><br><span class="line">    // 断言正确，确实是 const char [6] 类型，注意 decltype(expr) 在 expr 是左值</span><br><span class="line">    // 且非无括号包裹的 id 表达式与类成员表达式时，会返回左值引用</span><br><span class="line">    static_assert(std::is_same&lt;decltype(&quot;01234&quot;), const char(&amp;)[6]&gt;::value, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    // 错误，&quot;01234&quot; 是左值，不可被右值引用</span><br><span class="line">    // const char (&amp;&amp;right)[6] = &quot;01234&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是注意，数组可以被隐式转换成相对应的指针类型，而转换表达式的结果（如果不是左值引用）则一定是个右值（右值引用为将亡值，否则为纯右值）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    const char*   p   = &quot;01234&quot;;  // 正确，&quot;01234&quot; 被隐式转换为 const char*</span><br><span class="line">    const char*&amp;&amp; pr  = &quot;01234&quot;;  // 正确，&quot;01234&quot; 被隐式转换为 const char*，该转换的结果是纯右值</span><br><span class="line">    // const char*&amp; pl = &quot;01234&quot;; // 错误，此处不存在 const char* 类型的左值</span><br><span class="line">  ```  </span><br><span class="line"></span><br><span class="line">+ 将亡值 (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中， 纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。</span><br><span class="line">+ 将亡值可能稍有些难以理解，我们来看这样的代码：</span><br></pre></td></tr></table></figure>
<p>  std::vector<int> foo() {<br>  std::vector<int> temp &#x3D; {1, 2, 3, 4};<br>  return temp;<br>  }</p>
<p>  std::vector<int> v &#x3D; foo();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 在这样的代码中，就传统的理解而言，函数 foo 的返回值 temp 在内部创建然后被赋值给 v， 然而 v 获得这个对象时，会将整个 temp 拷贝一份，然后把 temp 销毁，如果这个 temp 非常大， 这将造成大量额外的开销（这也就是传统 C++ 一直被诟病的问题）。</span><br><span class="line">+ 在最后一行中，v 是左值、 foo() 返回的值就是右值（也是纯右值）。但是，v 可以被别的变量捕获到， 而 foo() 产生的那个返回值作为一个临时值，一旦被 v 复制后，将立即被销毁，无法获取、也不能修改。 而将亡值就定义了这样一种行为：临时的值能够被识别、同时又能够被移动</span><br><span class="line"></span><br><span class="line">+ 在 C++11 之后，编译器为我们做了一些工作，此处的左值 temp 会被进行此隐式右值转换， 等价于 `static_cast&lt;std::vector&lt;int&gt; &amp;&amp;&gt;(temp)`，进而此处的 v 会将 foo 局部返回的值进行移动。 也就是后面我们将会提到的移动语义。</span><br><span class="line"></span><br><span class="line">#### 右值引用和左值引用</span><br><span class="line"></span><br><span class="line">+ 要拿到一个将亡值，就需要用到右值引用：`T &amp;&amp;`，其中 T 是类型。 右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</span><br><span class="line">+ C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值， 有了它我们就能够方便的获得一个右值临时对象，例如：</span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <string></p>
<p>  void reference(std::string&amp; str) {<br>  std::cout &lt;&lt; “左值” &lt;&lt; std::endl;<br>  }<br>  void reference(std::string&amp;&amp; str) {<br>  std::cout &lt;&lt; “右值” &lt;&lt; std::endl;<br>  }</p>
<p>  int main()<br>  {<br>  std::string lv1 &#x3D; “string,”; &#x2F;&#x2F; lv1 是一个左值<br>  &#x2F;&#x2F; std::string&amp;&amp; r1 &#x3D; lv1; &#x2F;&#x2F; 非法, 右值引用不能引用左值<br>  std::string&amp;&amp; rv1 &#x3D; std::move(lv1); &#x2F;&#x2F; 合法, std::move可以将左值转移为右值<br>  std::cout &lt;&lt; rv1 &lt;&lt; std::endl; &#x2F;&#x2F; string,<br><br>  const std::string&amp; lv2 &#x3D; lv1 + lv1; &#x2F;&#x2F; 合法, 常量左值引用能够延长临时变量的生命周期<br>  &#x2F;&#x2F; lv2 +&#x3D; “Test”; &#x2F;&#x2F; 非法, 常量引用无法被修改<br>  std::cout &lt;&lt; lv2 &lt;&lt; std::endl; &#x2F;&#x2F; string,string,<br><br>  std::string&amp;&amp; rv2 &#x3D; lv1 + lv2; &#x2F;&#x2F; 合法, 右值引用延长临时对象生命周期<br>  rv2 +&#x3D; “Test”; &#x2F;&#x2F; 合法, 非常量引用能够修改临时变量<br>  std::cout &lt;&lt; rv2 &lt;&lt; std::endl; &#x2F;&#x2F; string,string,string,Test<br><br>  reference(rv2); &#x2F;&#x2F; 输出左值<br><br>  return 0;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。</span><br><span class="line">+ 注意，这里有一个很有趣的历史遗留问题，我们先看下面的代码：</span><br></pre></td></tr></table></figure>
<p>  #include <iostream></p>
<p>  int main() {<br>  &#x2F;&#x2F; int &amp;a &#x3D; std::move(1);    &#x2F;&#x2F; 不合法，非常量左引用无法引用右值<br>  const int &amp;b &#x3D; std::move(1); &#x2F;&#x2F; 合法, 常量左引用允许引用右值<br><br>  std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 第一个问题，为什么不允许非常量引用绑定到非左值？这是因为这种做法存在逻辑错误：</span><br></pre></td></tr></table></figure>
<p>  void increase(int &amp; v) {<br>  v++;<br>  }<br>  void foo() {<br>  double s &#x3D; 1;<br>  increase(s);<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 由于 int&amp; 不能引用 double 类型的参数，因此必须产生一个临时值来保存 s 的值， 从而当 increase() 修改这个临时值时，调用完成后 s 本身并没有被修改。</span><br><span class="line">+ 第二个问题，为什么常量引用允许绑定到非左值？原因很简单，因为 Fortran 需要</span><br><span class="line"></span><br><span class="line">#### 移动语义</span><br><span class="line"></span><br><span class="line">+ 传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的移动操作， 调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。 </span><br><span class="line">+ 试想，搬家的时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份（重买）再放到新家、 再把原来的东西全部扔掉（销毁），这是非常反人类的一件事情。</span><br><span class="line"></span><br><span class="line">+ 传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据拷贝，浪费时间和空间。 右值引用的出现恰好就解决了这两个概念的混淆问题，例如：</span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  class A {<br>  public:<br>  int *pointer;<br>  A():pointer(new int(1)) {<br>      std::cout &lt;&lt; “构造” &lt;&lt; pointer &lt;&lt; std::endl;<br>  }<br>  A(A&amp; a):pointer(new int(*a.pointer)) {<br>      std::cout &lt;&lt; “拷贝” &lt;&lt; pointer &lt;&lt; std::endl;<br>  } &#x2F;&#x2F; 无意义的对象拷贝<br>  A(A&amp;&amp; a):pointer(a.pointer) {<br>      a.pointer &#x3D; nullptr;<br>      std::cout &lt;&lt; “移动” &lt;&lt; pointer &lt;&lt; std::endl;<br>  }<br>  ~A(){<br>      std::cout &lt;&lt; “析构” &lt;&lt; pointer &lt;&lt; std::endl;<br>      delete pointer;<br>  }<br>  };<br>  &#x2F;&#x2F; 防止编译器优化<br>  A return_rvalue(bool test) {<br>  A a,b;<br>  if(test) return a; &#x2F;&#x2F; 等价于 static_cast&lt;A&amp;&amp;&gt;(a);<br>  else return b;     &#x2F;&#x2F; 等价于 static_cast&lt;A&amp;&amp;&gt;(b);<br>  }<br>  int main() {<br>  A obj &#x3D; return_rvalue(false);<br>  std::cout &lt;&lt; “obj:” &lt;&lt; std::endl;<br>  std::cout &lt;&lt; obj.pointer &lt;&lt; std::endl;<br>  std::cout &lt;&lt; *obj.pointer &lt;&lt; std::endl;<br>  return 0;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 在上面的代码中：</span><br><span class="line">  + 首先会在 return_rvalue 内部构造两个 A 对象，于是获得两个构造函数的输出；</span><br><span class="line">  + 函数返回后，产生一个将亡值，被 A 的移动构造（A(A&amp;&amp;)）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁。</span><br><span class="line">+ 从而避免了无意义的拷贝构造，加强了性能。再来看看涉及标准库的例子：</span><br></pre></td></tr></table></figure>
<p>  #include <iostream> &#x2F;&#x2F; std::cout<br>  #include <utility> &#x2F;&#x2F; std::move<br>  #include <vector> &#x2F;&#x2F; std::vector<br>  #include <string> &#x2F;&#x2F; std::string</p>
<p>  int main() {</p>
<pre><code>  std::string str = &quot;Hello world.&quot;;
  std::vector&lt;std::string&gt; v;

  // 将使用 push_back(const T&amp;), 即产生拷贝行为
  v.push_back(str);
  // 将输出 &quot;str: Hello world.&quot;
  std::cout &lt;&lt; &quot;str: &quot; &lt;&lt; str &lt;&lt; std::endl;

  // 将使用 push_back(const T&amp;&amp;), 不会出现拷贝行为
  // 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销
  // 这步操作后, str 中的值会变为空
  v.push_back(std::move(str));
  // 将输出 &quot;str: &quot;
  std::cout &lt;&lt; &quot;str: &quot; &lt;&lt; str &lt;&lt; std::endl;

  return 0;
</code></pre>
<p>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 完美转发</span><br><span class="line"></span><br><span class="line">+ 前面我们提到了，一个声明的右值引用其实是一个左值。这就为我们进行参数转发（传递）造成了问题：</span><br></pre></td></tr></table></figure>
<p>  void reference(int&amp; v) {<br>  std::cout &lt;&lt; “左值” &lt;&lt; std::endl;<br>  }<br>  void reference(int&amp;&amp; v) {<br>  std::cout &lt;&lt; “右值” &lt;&lt; std::endl;<br>  }<br>  template <typename T><br>  void pass(T&amp;&amp; v) {<br>  std::cout &lt;&lt; “普通传参:”;<br>  reference(v); &#x2F;&#x2F; 始终调用 reference(int&amp;)<br>  }<br>  int main() {<br>  std::cout &lt;&lt; “传递右值:” &lt;&lt; std::endl;<br>  pass(1); &#x2F;&#x2F; 1是右值, 但输出是左值<br><br>  std::cout &lt;&lt; “传递左值:” &lt;&lt; std::endl;<br>  int l &#x3D; 1;<br>  pass(l); &#x2F;&#x2F; l 是左值, 输出左值<br><br>  return 0;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 对于 pass(1) 来说，虽然传递的是右值，但由于 v 是一个引用，所以同时也是左值。 因此 reference(v) 会调用 reference(int&amp;)，输出『左值』。 而对于pass(l)而言，l是一个左值，为什么会成功传递给 pass(T&amp;&amp;) 呢？</span><br><span class="line">+ 这是基于引用坍缩规则的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用， 但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用， 既能左引用，又能右引用。但是却遵循如下规则：</span><br><span class="line"></span><br><span class="line">| 函数形参类型 | 实参参数类型 | 推倒后函数形参类型 |</span><br><span class="line">| :---       | :---       | :---            |</span><br><span class="line">| T&amp;         | 左引用      | T&amp;              |</span><br><span class="line">| T&amp;         | 右引用      | T&amp;              |</span><br><span class="line">| T&amp;&amp;        | 左引用      | T&amp;              |</span><br><span class="line">| T&amp;&amp;        | 右引用      | T&amp;&amp;             | </span><br><span class="line"></span><br><span class="line">+ 因此，模板函数中使用 T&amp;&amp; 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。 更准确的讲，无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型。 这才使得 v 作为左值的成功传递</span><br><span class="line">+ 完美转发就是基于上述规律产生的。所谓完美转发，就是为了让我们在传递参数的时候， 保持原来的参数类型（左引用保持左引用，右引用保持右引用）。 为了解决这个问题，我们应该使用 std::forward 来进行参数的转发（传递）：</span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <utility><br>  void reference(int&amp; v) {<br>  std::cout &lt;&lt; “左值引用” &lt;&lt; std::endl;<br>  }<br>  void reference(int&amp;&amp; v) {<br>  std::cout &lt;&lt; “右值引用” &lt;&lt; std::endl;<br>  }<br>  template <typename T><br>  void pass(T&amp;&amp; v) {<br>  std::cout &lt;&lt; “              普通传参: “;<br>  reference(v);<br>  std::cout &lt;&lt; “       std::move 传参: “;<br>  reference(std::move(v));<br>  std::cout &lt;&lt; “    std::forward 传参: “;<br>  reference(std::forward<T>(v));<br>  std::cout &lt;&lt; “static_cast&lt;T&amp;&amp;&gt; 传参: “;<br>  reference(static_cast&lt;T&amp;&amp;&gt;(v));<br>  }<br>  int main() {<br>  std::cout &lt;&lt; “传递右值:” &lt;&lt; std::endl;<br>  pass(1);<br><br>  std::cout &lt;&lt; “传递左值:” &lt;&lt; std::endl;<br>  int v &#x3D; 1;<br>  pass(v);<br><br>  return 0;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 输出结果为：</span><br></pre></td></tr></table></figure>
<p>  传递右值:<br>            普通传参: 左值引用<br>     std::move 传参: 右值引用<br>  std::forward 传参: 右值引用<br>  static_cast&lt;T&amp;&amp;&gt; 传参: 右值引用<br>  传递左值:<br>            普通传参: 左值引用<br>     std::move 传参: 右值引用<br>  std::forward 传参: 左值引用<br>  static_cast&lt;T&amp;&amp;&gt; 传参: 左值引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发， 所以 `std::move` 总会接受到一个左值，从而转发调用了reference(int&amp;&amp;) 输出右值引用。</span><br><span class="line">+ 唯独 `std::forward` 即没有造成任何多余的拷贝，同时完美转发(传递)了函数的实参给了内部调用的其他函数。</span><br><span class="line">+ `std::forward` 和 `std::move` 一样，没有做任何事情，`std::move` 单纯的将左值转化为右值， `std::forward` 也只是单纯的将参数做了一个类型的转换，从现象上来看， `std::forward&lt;T&gt;(v)` 和 `static_cast&lt;T&amp;&amp;&gt;(v)` 是完全一样的。</span><br><span class="line"></span><br><span class="line">+ 读者可能会好奇，为何一条语句能够针对两种类型的返回对应的值， 我们再简单看一看 `std::forward` 的具体实现机制，`std::forward` 包含两个重载：</span><br></pre></td></tr></table></figure>
<p>  template<typename _Tp><br>  constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept<br>  { return static_cast&lt;_Tp&amp;&amp;&gt;(__t); }</p>
<p>  template<typename _Tp><br>  constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept<br>  {<br>  static_assert(!std::is_lvalue_reference&lt;_Tp&gt;::value, “template argument”<br>      “ substituting _Tp is an lvalue reference type”);<br>  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+ 在这份实现中，`std::remove_reference` 的功能是消除类型中的引用，</span><br><span class="line">+  `std::is_lvalue_reference` 则用于检查类型推导是否正确，在 `std::forward` 的第二个实现中 检查了接收到的值确实是一个左值，进而体现了坍缩规则。</span><br><span class="line">+  当 `std::forward` 接受左值时，_Tp 被推导为左值，所以返回值为左值；而当其接受右值时， _Tp 被推导为 右值引用，则基于坍缩规则，返回值便成为了 &amp;&amp; + &amp;&amp; 的右值。 可见 `std::forward` 的原理在于巧妙的利用了模板类型推导中产生的差异。</span><br><span class="line">+  这时我们能回答这样一个问题：为什么在使用循环语句的过程中，auto&amp;&amp; 是最安全的方式？ 因为当 auto 被推导为不同的左右引用时，与 &amp;&amp; 的坍缩组合是完美转发</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line"></span><br><span class="line">+ 本章介绍了现代 C++ 中最为重要的几个语言运行时的增强，其中笔者认为本节中提到的所有特性都是值得掌握的：</span><br><span class="line">  + Lambda 表达式</span><br><span class="line">  + 函数对象容器 `std::function`</span><br><span class="line">  + 右值引用</span><br><span class="line"></span><br><span class="line">## 第四章 容器</span><br><span class="line"></span><br><span class="line">### 4.1 线性容器</span><br><span class="line"></span><br><span class="line">#### std::array</span><br><span class="line"></span><br><span class="line">+ 看到这个容器的时候肯定会出现这样的问题：</span><br><span class="line">  + 为什么要引入 std::array 而不是直接使用 std::vector</span><br><span class="line">  + 已经有了传统数组，为什么要用 std::array</span><br><span class="line"></span><br><span class="line">+ 先回答第一个问题，与 std::vector 不同，std::array 对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用 std::array 容器。</span><br><span class="line">+ 另外由于 std::vector 是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作， 容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 shrink_to_fit() 释放这部分内存:</span><br></pre></td></tr></table></figure>
<p>  std::vector<int> v;<br>  std::cout &lt;&lt; “size:” &lt;&lt; v.size() &lt;&lt; std::endl;         &#x2F;&#x2F; 输出 0<br>  std::cout &lt;&lt; “capacity:” &lt;&lt; v.capacity() &lt;&lt; std::endl; &#x2F;&#x2F; 输出 0</p>
<p>  &#x2F;&#x2F; 如下可看出 std::vector 的存储是自动管理的，按需自动扩张<br>  &#x2F;&#x2F; 但是如果空间不足，需要重新分配更多内存，而重分配内存通常是性能上有开销的操作<br>  v.push_back(1);<br>  v.push_back(2);<br>  v.push_back(3);<br>  std::cout &lt;&lt; “size:” &lt;&lt; v.size() &lt;&lt; std::endl;         &#x2F;&#x2F; 输出 3<br>  std::cout &lt;&lt; “capacity:” &lt;&lt; v.capacity() &lt;&lt; std::endl; &#x2F;&#x2F; 输出 4</p>
<p>  &#x2F;&#x2F; 这里的自动扩张逻辑与 Golang 的 slice 很像<br>  v.push_back(4);<br>  v.push_back(5);<br>  std::cout &lt;&lt; “size:” &lt;&lt; v.size() &lt;&lt; std::endl;         &#x2F;&#x2F; 输出 5<br>  std::cout &lt;&lt; “capacity:” &lt;&lt; v.capacity() &lt;&lt; std::endl; &#x2F;&#x2F; 输出 8</p>
<p>  &#x2F;&#x2F; 如下可看出容器虽然清空了元素，但是被清空元素的内存并没有归还<br>  v.clear();<br>  std::cout &lt;&lt; “size:” &lt;&lt; v.size() &lt;&lt; std::endl;         &#x2F;&#x2F; 输出 0<br>  std::cout &lt;&lt; “capacity:” &lt;&lt; v.capacity() &lt;&lt; std::endl; &#x2F;&#x2F; 输出 8</p>
<p>  &#x2F;&#x2F; 额外内存可通过 shrink_to_fit() 调用返回给系统<br>  v.shrink_to_fit();<br>  std::cout &lt;&lt; “size:” &lt;&lt; v.size() &lt;&lt; std::endl;         &#x2F;&#x2F; 输出 0<br>  std::cout &lt;&lt; “capacity:” &lt;&lt; v.capacity() &lt;&lt; std::endl; &#x2F;&#x2F; 输出 0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 而第二个问题就更加简单，使用 std::array 能够让代码变得更加“现代化”，而且封装了一些操作函数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 std::sort</span><br><span class="line"></span><br><span class="line">+ 使用 std::array 很简单，只需指定其类型和大小即可：</span><br></pre></td></tr></table></figure>
<p>  std::array&lt;int, 4&gt; arr &#x3D; {1, 2, 3, 4};</p>
<p>  arr.empty(); &#x2F;&#x2F; 检查容器是否为空<br>  arr.size();  &#x2F;&#x2F; 返回容纳的元素数</p>
<p>  &#x2F;&#x2F; 迭代器支持<br>  for (auto &amp;i : arr)<br>  {<br>  &#x2F;&#x2F; …<br>  }</p>
<p>  &#x2F;&#x2F; 用 lambda 表达式排序<br>  std::sort(arr.begin(), arr.end(), [](int a, int b) {<br>  return b &lt; a;<br>  });</p>
<p>  &#x2F;&#x2F; 数组大小参数必须是常量表达式<br>  constexpr int len &#x3D; 4;<br>  std::array&lt;int, len&gt; arr &#x3D; {1, 2, 3, 4};</p>
<p>  &#x2F;&#x2F; 非法,不同于 C 风格数组，std::array 不会自动退化成 T*<br>  &#x2F;&#x2F; int *arr_p &#x3D; arr;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 当我们开始用上了 std::array 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：</span><br></pre></td></tr></table></figure>
<p>  void foo(int *p, int len) {<br>  return;<br>  }</p>
<p>  std::array&lt;int, 4&gt; arr &#x3D; {1,2,3,4};</p>
<p>  &#x2F;&#x2F; C 风格接口传参<br>  &#x2F;&#x2F; foo(arr, arr.size()); &#x2F;&#x2F; 非法, 无法隐式转换<br>  foo(&amp;arr[0], arr.size());<br>  foo(arr.data(), arr.size());</p>
<p>  &#x2F;&#x2F; 使用 <code>std::sort</code><br>  std::sort(arr.begin(), arr.end());</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### std::forward_list</span><br><span class="line"></span><br><span class="line">+ std::forward_list 是一个列表容器，使用方法和 std::list 基本类似，因此我们就不花费篇幅进行介绍了。</span><br><span class="line">+ 需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现， 提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点）， 也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。</span><br><span class="line"></span><br><span class="line">### 4.2 无序容器</span><br><span class="line"></span><br><span class="line">+ 我们已经熟知了传统 C++ 中的有序容器 std::map/std::set，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 &lt; 操作符比较元素大小并判断元素是否相同， 并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 &lt; 操作符的顺序来逐个遍历。</span><br><span class="line">+ 而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)， 在不关心容器内部元素顺序时，能够获得显著的性能提升。</span><br><span class="line">+ C++11 引入了的两组无序容器分别是：`std::unordered_map/std::unordered_multimap` 和 `std::unordered_set/std::unordered_multiset`</span><br><span class="line">+ 它们的用法和原有的 `std::map/std::multimap/std::set/set::multiset` 基本类似， 由于这些容器我们已经很熟悉了，便不一一举例，我们直接来比较一下`std::map`和`std::unordered_map`：</span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <string><br>  #include <unordered_map><br>  #include <map></p>
<p>  int main() {<br>  &#x2F;&#x2F; 两组结构按同样的顺序初始化<br>  std::unordered_map&lt;int, std::string&gt; u &#x3D; {<br>      {1, “1”},<br>      {3, “3”},<br>      {2, “2”}<br>  };<br>  std::map&lt;int, std::string&gt; v &#x3D; {<br>      {1, “1”},<br>      {3, “3”},<br>      {2, “2”}<br>  };<br><br>  &#x2F;&#x2F; 分别对两组结构进行遍历<br>  std::cout &lt;&lt; “std::unordered_map” &lt;&lt; std::endl;<br>  for( const auto &amp; n : u)<br>      std::cout &lt;&lt; “Key:[“ &lt;&lt; n.first &lt;&lt; “] Value:[“ &lt;&lt; n.second &lt;&lt; “]\n”;<br><br>  std::cout &lt;&lt; std::endl;<br>  std::cout &lt;&lt; “std::map” &lt;&lt; std::endl;<br>  for( const auto &amp; n : v)<br>      std::cout &lt;&lt; “Key:[“ &lt;&lt; n.first &lt;&lt; “] Value:[“ &lt;&lt; n.second &lt;&lt; “]\n”;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 最终输出的结果为：</span><br></pre></td></tr></table></figure>
<p>  std::unordered_map<br>  Key:[2] Value:[2]<br>  Key:[3] Value:[3]<br>  Key:[1] Value:[1]</p>
<p>  std::map<br>  Key:[1] Value:[1]<br>  Key:[2] Value:[2]<br>  Key:[3] Value:[3]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4.3 元组</span><br><span class="line"></span><br><span class="line">+ 了解过 Python 的程序员应该知道元组的概念，纵观传统 C++ 中的容器，除了 std::pair 外， 似乎没有现成的结构能够用来存放不同类型的数据（通常我们会自己定义结构）。 但 std::pair 的缺陷是显而易见的，只能保存两个元素。</span><br><span class="line"></span><br><span class="line">#### 元组基本操作</span><br><span class="line"></span><br><span class="line">+ 关于元组的使用有三个核心的函数：</span><br><span class="line">  + std::make_tuple: 构造元组</span><br><span class="line">  + std::get: 获得元组某个位置的值</span><br><span class="line">  + std::tie: 元组拆包</span><br><span class="line"></span><br><span class="line">+ 示例：</span><br></pre></td></tr></table></figure>
<p>  #include <tuple><br>  #include <iostream></p>
<p>  auto get_student(int id)<br>  {<br>  &#x2F;&#x2F; 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;<br><br>  if (id &#x3D;&#x3D; 0)<br>      return std::make_tuple(3.8, ‘A’, “张三”);<br>  if (id &#x3D;&#x3D; 1)<br>      return std::make_tuple(2.9, ‘C’, “李四”);<br>  if (id &#x3D;&#x3D; 2)<br>      return std::make_tuple(1.7, ‘D’, “王五”);<br>  return std::make_tuple(0.0, ‘D’, “null”);<br>  &#x2F;&#x2F; 如果只写 0 会出现推断错误, 编译失败<br>  }</p>
<p>  int main()<br>  {<br>  auto student &#x3D; get_student(0);<br>  std::cout &lt;&lt; “ID: 0, “<br>  &lt;&lt; “GPA: “ &lt;&lt; std::get&lt;0&gt;(student) &lt;&lt; “, “<br>  &lt;&lt; “成绩: “ &lt;&lt; std::get&lt;1&gt;(student) &lt;&lt; “, “<br>  &lt;&lt; “姓名: “ &lt;&lt; std::get&lt;2&gt;(student) &lt;&lt; ‘\n’;<br><br>  double gpa;<br>  char grade;<br>  std::string name;<br><br>  &#x2F;&#x2F; 元组进行拆包<br>  std::tie(gpa, grade, name) &#x3D; get_student(1);<br>  std::cout &lt;&lt; “ID: 1, “<br>  &lt;&lt; “GPA: “ &lt;&lt; gpa &lt;&lt; “, “<br>  &lt;&lt; “成绩: “ &lt;&lt; grade &lt;&lt; “, “<br>  &lt;&lt; “姓名: “ &lt;&lt; name &lt;&lt; ‘\n’;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ std::get 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象：</span><br></pre></td></tr></table></figure>
<p>  std::tuple&lt;std::string, double, double, int&gt; t(“123”, 4.5, 6.7, 8);<br>  std::cout &lt;&lt; std::get<a href="std::string">std::string</a>(t) &lt;&lt; std::endl;<br>  std::cout &lt;&lt; std::get<double>(t) &lt;&lt; std::endl; &#x2F;&#x2F; 非法, 引发编译期错误<br>  std::cout &lt;&lt; std::get&lt;3&gt;(t) &lt;&lt; std::endl;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 运行期索引</span><br><span class="line"></span><br><span class="line">+ 如果你仔细思考一下可能就会发现上面代码的问题，std::get&lt;&gt; 依赖一个编译期的常量，所以下面的方式是不合法的：</span><br></pre></td></tr></table></figure>
<p>  int index &#x3D; 1;<br>  std::get<index>(t);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 那么要怎么处理？答案是，使用 std::variant&lt;&gt;（C++ 17 引入），提供给 variant&lt;&gt; 的类型模板参数 可以让一个 variant&lt;&gt; 从而容纳提供的几种类型的变量（在其他语言，例如 Python/JavaScript 等，表现为动态类型）：</span><br></pre></td></tr></table></figure>
<p>  #include <variant><br>  template &lt;size_t n, typename… T&gt;<br>  constexpr std::variant&lt;T…&gt; _tuple_index(const std::tuple&lt;T…&gt;&amp; tpl, size_t i) {<br>  if constexpr (n &gt;&#x3D; sizeof…(T))<br>      throw std::out_of_range(“越界.”);<br>  if (i &#x3D;&#x3D; n)<br>      return std::variant&lt;T…&gt;{ std::in_place_index<n>, std::get<n>(tpl) };<br>  return _tuple_index&lt;(n &lt; sizeof…(T)-1 ? n+1 : 0)&gt;(tpl, i);<br>  }<br>  template &lt;typename… T&gt;<br>  constexpr std::variant&lt;T…&gt; tuple_index(const std::tuple&lt;T…&gt;&amp; tpl, size_t i) {<br>  return _tuple_index&lt;0&gt;(tpl, i);<br>  }<br>  template &lt;typename T0, typename … Ts&gt;<br>  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; s, std::variant&lt;T0, Ts…&gt; const &amp; v) {<br>  std::visit([&amp;](auto &amp;&amp; x){ s &lt;&lt; x;}, v);<br>  return s;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 这样我们就能：</span><br></pre></td></tr></table></figure>
<p>  int i &#x3D; 1;<br>  std::cout &lt;&lt; tuple_index(t, i) &lt;&lt; std::endl;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 元组合并与遍历</span><br><span class="line"></span><br><span class="line">+ 还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现：</span><br><span class="line">  + `auto new_tuple = std::tuple_cat(get_student(1), std::move(t));`</span><br><span class="line"></span><br><span class="line">+ 马上就能够发现，应该如何快速遍历一个元组？但是我们刚才介绍了如何在运行期通过非常数索引一个 tuple 那么遍历就变得简单了， 首先我们需要知道一个元组的长度，可以：</span><br></pre></td></tr></table></figure>
<p>  template <typename T><br>  auto tuple_len(T &amp;tpl) {<br>  return std::tuple_size<T>::value;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ 这样就能够对元组进行迭代了：</span><br></pre></td></tr></table></figure>
<p>  &#x2F;&#x2F; 迭代<br>  for(int i &#x3D; 0; i !&#x3D; tuple_len(new_tuple); ++i)<br>  &#x2F;&#x2F; 运行期索引<br>  std::cout &lt;&lt; tuple_index(new_tuple, i) &lt;&lt; std::endl;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 总结</span><br><span class="line"></span><br><span class="line">+ 本章简单介绍了现代 C++ 中新增的容器，它们的用法和传统 C++ 中已有的容器类似，相对简单，可以根据实际场景丰富的选择需要使用的容器，从而获得更好的性能。</span><br><span class="line">+ std::tuple 虽然有效，但是标准库提供的功能有限，没办法满足运行期索引和迭代的需求，好在我们还有其他的方法可以自行实现。</span><br><span class="line"></span><br><span class="line">## 第五章 智能指针与内存管理</span><br><span class="line"></span><br><span class="line">### 5.1 RAII与引用计数</span><br><span class="line"></span><br><span class="line">+ 引用计数这种计数是为了防止内存泄露而产生的。 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。</span><br><span class="line">+ 在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源而导致泄露。 所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间， 也就是我们常说的 **RAII 资源获取即初始化技术**</span><br><span class="line">+ 凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 new 和 delete 去 『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针包括 `std::shared_ptr/std::unique_ptr/std::weak_ptr`，使用它们需要包含头文件 `&lt;memory&gt;`</span><br><span class="line">+ 注意：引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待， 更能够清晰明确的表明资源的生命周期。</span><br><span class="line"></span><br><span class="line">### 5.2 std::shared_ptr</span><br><span class="line"></span><br><span class="line">+ `std::shared_ptr` 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当引用计数变为零的时候就会将对象自动删除。但还不够，因为使用 `std::shared_ptr` 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。</span><br><span class="line">+ `std::make_shared` 就能够用来消除显式的使用 new，所以 `std::make_shared` 会分配创建传入参数中的对象， 并返回这个对象类型的 `std::shared_ptr` 指针</span><br><span class="line">+ 例如：</span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <memory><br>  void foo(std::shared_ptr<int> i) {<br>  (*i)++;<br>  }<br>  int main() {<br>  &#x2F;&#x2F; auto pointer &#x3D; new int(10); &#x2F;&#x2F; illegal, no direct assignment<br>  &#x2F;&#x2F; Constructed a std::shared_ptr<br>  auto pointer &#x3D; std::make_shared<int>(10);<br>  foo(pointer);<br>  std::cout &lt;&lt; *pointer &lt;&lt; std::endl; &#x2F;&#x2F; 11<br>  &#x2F;&#x2F; The shared_ptr will be destructed before leaving the scope<br>  return 0;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ `std::shared_ptr` 可以通过 `get()` 方法来获取原始指针，通过 `reset()` 来减少一个引用计数， 并通过 `use_count()` 来查看一个对象的引用计数</span><br><span class="line"></span><br><span class="line">### 5.3 std::unique_str</span><br><span class="line"></span><br><span class="line">+ `std::unique_ptr` 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全：</span><br></pre></td></tr></table></figure>
<p>  std::unique_ptr<int> pointer &#x3D; std::make_unique<int>(10); &#x2F;&#x2F; make_unique 从 C++14 引入<br>  std::unique_ptr<int> pointer2 &#x3D; pointer; &#x2F;&#x2F; 非法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ make_unique 并不复杂，C++11 没有提供 std::make_unique，可以自行实现：</span><br></pre></td></tr></table></figure>
<p>  template&lt;typename T, typename …Args&gt;<br>  std::unique_ptr<T> make_unique( Args&amp;&amp; …args ) {<br>return std::unique_ptr<T>( new T( std::forward<Args>(args)… ) );<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 既然是独占，换句话说就是不可复制。但是，我们可以利用 `std::move` 将其转移给其他的 `unique_ptr`</span><br><span class="line">+ 例如：</span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <memory></p>
<p>  struct Foo {<br>  Foo() { std::cout &lt;&lt; “Foo::Foo” &lt;&lt; std::endl; }<br>  <del>Foo() { std::cout &lt;&lt; “Foo::</del>Foo” &lt;&lt; std::endl; }<br>  void foo() { std::cout &lt;&lt; “Foo::foo” &lt;&lt; std::endl; }<br>  };</p>
<p>  void f(const Foo &amp;) {<br>  std::cout &lt;&lt; “f(const Foo&amp;)” &lt;&lt; std::endl;<br>  }</p>
<p>  int main() {<br>  std::unique_ptr<Foo> p1(std::make_unique<Foo>());<br>  &#x2F;&#x2F; p1 不空, 输出<br>  if (p1) p1-&gt;foo();<br>  {<br>      std::unique_ptr<Foo> p2(std::move(p1));<br>      &#x2F;&#x2F; p2 不空, 输出<br>      f(*p2);<br>      &#x2F;&#x2F; p2 不空, 输出<br>      if(p2) p2-&gt;foo();<br>      &#x2F;&#x2F; p1 为空, 无输出<br>      if(p1) p1-&gt;foo();<br>      p1 &#x3D; std::move(p2);<br>      &#x2F;&#x2F; p2 为空, 无输出<br>      if(p2) p2-&gt;foo();<br>      std::cout &lt;&lt; “p2 被销毁” &lt;&lt; std::endl;<br>  }<br>  &#x2F;&#x2F; p1 不空, 输出<br>  if (p1) p1-&gt;foo();<br>  &#x2F;&#x2F; Foo 的实例会在离开作用域时被销毁<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5.4 std::weak_ptr</span><br><span class="line"></span><br><span class="line">+ 如果你仔细思考 `std::shared_ptr` 就会发现依然存在着资源无法释放的问题。看下面这个例子：</span><br></pre></td></tr></table></figure>
<p>  struct A;<br>  struct B;</p>
<p>  struct A {<br>  std::shared_ptr<B> pointer;<br>  ~A() {<br>      std::cout &lt;&lt; “A 被销毁” &lt;&lt; std::endl;<br>  }<br>  };<br>  struct B {<br>  std::shared_ptr<A> pointer;<br>  ~B() {<br>      std::cout &lt;&lt; “B 被销毁” &lt;&lt; std::endl;<br>  }<br>  };<br>  int main() {<br>  auto a &#x3D; std::make_shared<A>();<br>  auto b &#x3D; std::make_shared<B>();<br>  a-&gt;pointer &#x3D; b;<br>  b-&gt;pointer &#x3D; a;<br>  }</p>
<pre><code>
</code></pre>
</li>
<li><p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b，这使得 a,b 的引用计数均变为了 2，而离开作用域时，a,b 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 a,b 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露</p>
</li>
<li><p>解决这个问题的办法就是使用弱引用指针 <code>std::weak_ptr</code>，<code>std::weak_ptr</code> 是一种弱引用（相比较而言 <code>std::shared_ptr</code> 就是一种强引用）</p>
</li>
<li><p><code>std::weak_ptr</code> 没有 <code>*</code> 运算符和 <code>-&gt;</code> 运算符，所以不能够对资源进行操作，它可以用于检查 <code>std::shared_ptr</code> 是否存在，其 <code>expired()</code> 方法能在资源未被释放时，会返回 <code>false</code>，否则返回 <code>true</code>；</p>
</li>
<li><p>除此之外，它也可以用于获取指向原始对象的 <code>std::shared_ptr</code> 指针，其 <code>lock()</code> 方法在原始对象未被释放时，返回一个指向原始对象的 <code>std::shared_ptr</code> 指针，进而访问原始对象的资源，否则返回 <code>nullptr</code></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-FFmpeg%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-FFmpeg%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/" class="post-title-link" itemprop="url">FFmpeg从入门到精通</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>FFmpeg框架的基本组成包含AVFormat, AVCodec, AVFilter, AVDevice, AVUtil等模块库。</p>
</li>
<li><p>FFmpeg的封装模块AVFormat</p>
<ul>
<li>AVFormat中实现了目前多媒体领域中的绝大多数媒体封装格式，包括封装和解封装，例如MP4，FLV，KV，TS等文件封装格式，RTMP，RTSP，MMS，HLS等网络协议封装格式。</li>
<li>FFmpeg是否支持某种媒体封装格式，取决于编译时是否包含了该格式的封装库</li>
</ul>
</li>
<li><p>FFmpeg的编解码模块AVCodec</p>
<ul>
<li>AVCodec中实现了目前多媒体领域绝大多数常用的编解码格式，既支持编码，也支持解码。AVCodec除了支持MJPEG4，AAC，MJPEG等自带的媒体编解码格式之外，还支持第三方的编解码器，例如H.264(AVC)编码，需要使用x264编码器；H.265(HEVC)编码，需要使用x265编码器；MP3(mp3lame)编码，需要使用libmp3lame编码器。</li>
<li>如果希望增加自己的编码格式，或者硬件编码，则需要在AVCodec中增加相应的编解码模块。</li>
</ul>
</li>
<li><p>FFmpeg的滤镜模块AVFilter</p>
<ul>
<li>AVFilter库提供了一个通用的音频，视频，字幕等滤镜过滤框架。在AVFilter中，滤镜框架可以有多个输入和多个输出。</li>
<li>示例：<ul>
<li>.&#x2F;ffmpeg -i INPUT -vf “split [main][tmp]; [tmp] crop&#x3D;iw:ih&#x2F;2:0:0, vflip [flip];[main][flip] overlay&#x3D;0:H&#x2F;2” OUTPUT</li>
</ul>
</li>
<li>相同的Filter线性链之间用逗号分隔 </li>
<li>不同的Filter线性链之间用分号分隔</li>
<li>在以上示例中，crop与vflip使用的时同一个滤镜处理的线性链，split滤镜和overlay滤镜使用的是另一个线性链，一个线性链与另一个线性链汇合时是通过方括号[]括起来的标签进行标示的。在这个例子中，两个流处理后是通过[main]与[flip]进行关联汇合的。</li>
<li>split滤镜将分割后的视频流的第二部分打上标签[tmp]，通过crop滤镜对该部分流进行处理，然后进行纵坐标调换操作，打赏标签[flip]，然后将[main]标签与[flip]标签进行合并，[flip]标签的视频流从视频的左边最中间的位置开始显示，这样就出现了镜像效果</li>
</ul>
</li>
<li><p>FFmpeg的视频图像转换计算模块swscale</p>
<ul>
<li>swscale模块提供了高级别的图像转换API，例如它允许图像缩放和像素格式转换，常见于将图像从1080p转换成720p或者480p的缩放，或者将图像数据从YUV420p转换成YUYV，或者YUV转RGB等图像格式转换。</li>
</ul>
</li>
<li><p>FFmpeg的音频转换计算模块swresample</p>
<ul>
<li>swresample模块提供了高级别的音频重采样API。例如它允许操作音频采样，音频通道布局与布局调整</li>
</ul>
</li>
</ul>
<h2 id="FFmpeg的编解码工具ffmpeg"><a href="#FFmpeg的编解码工具ffmpeg" class="headerlink" title="FFmpeg的编解码工具ffmpeg"></a>FFmpeg的编解码工具ffmpeg</h2><ul>
<li><p>ffmpeg是FFmpeg源代码编译后生成的一个可执行程序，其可以作为命令行工具使用。</p>
</li>
<li><p>ffmpeg的主要工作流程相对比较简单，具体如下：</p>
<ul>
<li>解封装(Demuxing)</li>
<li>解码(Decoding)</li>
<li>编码(Encoding)</li>
<li>封装(Muxing)</li>
</ul>
</li>
<li><p>其中需要经过6个步骤，具体如下：</p>
<ul>
<li>读取输入源</li>
<li>进行音视频的解封装</li>
<li>解码每一帧音视频数据</li>
<li>编码每一帧音视频数据</li>
<li>进行音视频重新封装</li>
<li>输出到目标</li>
</ul>
</li>
<li><p>ffmpeg首先读取输入源；然后通过Demuxer将音视频包进行解封装，这个动作通过调用libavformat中的接口即可实现；</p>
</li>
<li><p>接下来通过Decoder进行解码，将音视频通过Decoder解包成为YVU或者PCM这样的数据，Decoder通过libavcodec中的接口即可实现</p>
</li>
<li><p>然后通过Encoder将对应的数据进行编码，编码可以通过libavcodec中的接口来实现</p>
</li>
<li><p>接下来将编码后的音视频数据包通过Muxer进行封装，Muxer封装通过libavformat中的接口即可实现，输出成为输出流</p>
</li>
</ul>
<h2 id="FFmpeg的播放器ffplay"><a href="#FFmpeg的播放器ffplay" class="headerlink" title="FFmpeg的播放器ffplay"></a>FFmpeg的播放器ffplay</h2><ul>
<li><p>使用FFmpeg的avformat与avcodec，可以播放各种媒体文件或者流。如果想要使用ffplay，那么系统首先需要有SDL来进行ffplay的基础支撑</p>
</li>
<li><p>ffplay是FFmpeg源代码编译后生成的另一个可执行程序，与ffmpeg在FFmpeg项目中充当的角色基本相同，可以作为测试工具进行使用，ffplay提供了音视频显示和播放相关的图像信息，音频的波形信息等。</p>
</li>
</ul>
<h2 id="FFmpeg的多媒体分析器ffprobe"><a href="#FFmpeg的多媒体分析器ffprobe" class="headerlink" title="FFmpeg的多媒体分析器ffprobe"></a>FFmpeg的多媒体分析器ffprobe</h2><ul>
<li>ffprobe也是FFmpeg源码编译后生成的一个可执行程序。ffprobe是一个非常强大的多媒体分析工具，可以从媒体文件或者媒体流中获得想要了解的信息，例如音频的参数，视频的参数，媒体容器的参数信息等。</li>
<li>使用ffprobe可以分析媒体文件中每个包的长度，包的类型，帧的信息等</li>
</ul>
<h2 id="FFmpeg编译"><a href="#FFmpeg编译" class="headerlink" title="FFmpeg编译"></a>FFmpeg编译</h2><ul>
<li>FFmpeg在官方网站中提供已经编译好的可执行文件。</li>
</ul>
<h3 id="FFmpeg之Windows平台编译"><a href="#FFmpeg之Windows平台编译" class="headerlink" title="FFmpeg之Windows平台编译"></a>FFmpeg之Windows平台编译</h3><ul>
<li><p>FFmpeg在Windows平台中的编译需要使用MinGW-w64，MinGW是Minimalist GNU for Windows的缩写，提供了一系列的工具链来辅助编译Windows的本地化程序</p>
</li>
<li><p>MinGW-w64单独使用起来会比较麻烦，但是其可以与MSYS环境配合使用，MSYS是Minimal SYStem的缩写，其主要完成的工作为UNIX on Windows的功能。显而易见，这是一个仿生UNIX环境的Windows工具集</p>
</li>
</ul>
<h2 id="FFmpeg编码支持与定制"><a href="#FFmpeg编码支持与定制" class="headerlink" title="FFmpeg编码支持与定制"></a>FFmpeg编码支持与定制</h2><ul>
<li><p>FFmpeg本身支持一些音视频编码格式，文件封装格式与流媒体传输协议，但是支持的数量依然有限，FFmpeg所做的只是提供一套基础的框架，所有的编码格式，文件封装格式和流媒体协议均可以作为FFmpeg的一个模块挂在在FFmpeg框架中。这些模块以第三方的外部库的方式提供支持，可以通过FFmpeg源码的configure命令查看FFmpeg所支持的音视频编码格式，文件封装格式与 流媒体传输协议，对于FFmpeg不支持的格式，可以通过configure –help查看所需要的第三方外部库，然后通过增加对应的编译参数选项进行支持。</p>
</li>
<li><p>FFmpeg默认支持额音视频编码格式，文件封装格式和流媒体传输协议相对来说比较多，因此编译出来的FFmpeg体积比较大，在有些应用场景中，并不需要FFmpeg所支持的一些编码，封装或者协议。可以通过configure –help查看一些有用的裁剪操作</p>
</li>
<li><p>FFmpeg的编码器支持</p>
<ul>
<li>FFmpeg源代码中可以包含的编码非常多，常见的和不常见的都可以在编译配置列表中见到，可以通过使用编译配置命令.&#x2F;configure –list-encoders参数来查看</li>
</ul>
</li>
<li><p>FFmpeg的解码器支持</p>
<ul>
<li>FFmpeg源代码本身包含了很多的解码支持，解码主要是在输入的时候进行解码，也可以理解为将压缩过的编码进行解压缩，关于解码的支持，可以通过.&#x2F;configure –list-decoders命令来查看</li>
</ul>
</li>
<li><p>FFmpeg的封装支持</p>
<ul>
<li>FFmpeg的封装(Muxing)是指将压缩后的编码封装到一个容器格式中，如果要查看FFmpeg源代码中都可以支持哪些容器格式，可以通过命令.&#x2F;configure –list-muxers来查看</li>
</ul>
</li>
<li><p>FFmpeg的解封装支持</p>
<ul>
<li>FFmpeg的解封装(Demuxing)是指将读入的容器格式拆解开，将里面的压缩的音频流，视频流，字幕流，数据流等提取出来，如果要查看FFmpeg的源代码中都可以支持哪些输入的容器格式，可以通过命令.&#x2F;configure –list-demuxers来查看</li>
</ul>
</li>
<li><p>FFmpeg的通信协议支持</p>
<ul>
<li>FFmpeg不仅仅支持本地的多媒体处理，而且还支持网络流媒体的处理，支持的网络流媒体协议相对来说也很全面，可以通过命令.&#x2F;configure –list-protocols查看</li>
</ul>
</li>
</ul>
<h2 id="ffmpeg常用命令"><a href="#ffmpeg常用命令" class="headerlink" title="ffmpeg常用命令"></a>ffmpeg常用命令</h2><ul>
<li>ffmpeg在做音视频编解码时非常方便，所以在很多场景下转码使用的时ffmpeg，通过ffmpeg –help可以看到ffmpeg常见的命令大概分为6个部分，具体如下：<ul>
<li>ffmpeg信息查询部分</li>
<li>公共操作参数部分</li>
<li>文件主要操作参数部分</li>
<li>视频操作参数部分</li>
<li>音频操作参数部分</li>
<li>字幕操作参数部分</li>
</ul>
</li>
</ul>
<h2 id="ffmpeg的封装转换"><a href="#ffmpeg的封装转换" class="headerlink" title="ffmpeg的封装转换"></a>ffmpeg的封装转换</h2><ul>
<li>ffmpeg的封装转换(转封装)功能包含在AVFormat模块中，通过libavformat库进行Mux和Demux操作；多媒体文件的格式有很多种，这些格式中的很多参数在Mux与Demux的操作参数中是公用的。</li>
</ul>
<h2 id="ffmpeg的转码参数"><a href="#ffmpeg的转码参数" class="headerlink" title="ffmpeg的转码参数"></a>ffmpeg的转码参数</h2><ul>
<li>ffmpeg编解码部分的功能主要是通过模块AVCodec来完成的，通过libavcodec库进行Encode和Decode操作。多媒体编码格式的种类有很多，但是还是有很多通用的基本操作参数设置</li>
</ul>
<h2 id="ffmpeg的基本转码原理"><a href="#ffmpeg的基本转码原理" class="headerlink" title="ffmpeg的基本转码原理"></a>ffmpeg的基本转码原理</h2><ul>
<li>ffmpeg工具的主要用途为编码，解码，转码以及媒体格式转换，ffmpeg常用于进行转码操作。</li>
</ul>
<h2 id="ffprobe常用命令"><a href="#ffprobe常用命令" class="headerlink" title="ffprobe常用命令"></a>ffprobe常用命令</h2><ul>
<li><p>ffprobe主要用来查看多媒体文件的信息。</p>
</li>
<li><p>使用 ffprobe -show_packets input.flv 查看多媒体数据包信息；也可以通过 ffprobe -show_data -show_packets input.flv 组合参数来查看包中的具体数据。</p>
</li>
<li><p>通过 ffprobe -show_format output.mp4 命令可以查看多媒体的封装格式，其使用FORMAT标签括起来显示</p>
</li>
<li><p>通过 ffprobe -show_frames input.flv 命令可以查看视频文件中的帧信息，输出的帧信息将使用FRAME标签括起来</p>
</li>
<li><p>通过 -show_streams 参数可以查看到多媒体文件中的流信息，流的信息将使用STREAM标签括起来</p>
</li>
<li><p>ffprobe使用前面的参数可以获得key-value格式的显示方式；如果要进行格式化的显示，这样就需要用到ffprobe -print_format或者ffprobe -of 参数来进行相应的格式输出，而-print_format 支持多种格式输出，包括XML，INI，JSON，CSV，FLAT等</p>
</li>
</ul>
<h2 id="ffplay常用命令"><a href="#ffplay常用命令" class="headerlink" title="ffplay常用命令"></a>ffplay常用命令</h2><ul>
<li>在FFmpeg中通常使用ffplay作为播放器，其实ffplay同样也可以作为很多音视频数据的图形化分析工具，通过ffplay可以看到视频图像的运动方向，音视频数据的波形等</li>
</ul>
<h2 id="ffplay常用参数"><a href="#ffplay常用参数" class="headerlink" title="ffplay常用参数"></a>ffplay常用参数</h2><ul>
<li>ffplay不仅仅是播放器，同时也是测试ffmpeg的codec引擎，format引擎，以及filter引擎的工具，并且还可以进行可视化的媒体参数分析</li>
</ul>
<h2 id="ffplay的数据可视化分析应用"><a href="#ffplay的数据可视化分析应用" class="headerlink" title="ffplay的数据可视化分析应用"></a>ffplay的数据可视化分析应用</h2><ul>
<li>使用ffplay除了可以播放视频流媒体文件之外，还可以作为可视化的视频流媒体分析工具，例如播放音频文件，如果不确定文件的声音是否正常，则可以直接使用ffplay播放音频文件，播放的时候其将会把解码后的音频数据以音频波形的形式显示出来</li>
</ul>
<h2 id="音视频文件转MP4格式"><a href="#音视频文件转MP4格式" class="headerlink" title="音视频文件转MP4格式"></a>音视频文件转MP4格式</h2><ul>
<li>在互联网常见的格式中，跨平台最好的应该是MP4文件，因为MP4文件既可以在PC平台的Flashplayer中播放，又可以在移动平台的Android，IOS等平台中进行播放，而且使用系统默认的播放器即可播放，因此我们说MP4格式是最常见的多媒体文件格式。</li>
</ul>
<h2 id="视频文件转FLV"><a href="#视频文件转FLV" class="headerlink" title="视频文件转FLV"></a>视频文件转FLV</h2><ul>
<li>在网络的直播与点播场景中，FLV也是一种常见的格式，FLV是Adobe发布的一种可以作为直播也可以作为点播的封装格式，其封装格式非常简单，均以FLVTAG的形式存在，并且每一个TAG都是独立存在的。</li>
</ul>
<h2 id="视频文件转M3U8"><a href="#视频文件转M3U8" class="headerlink" title="视频文件转M3U8"></a>视频文件转M3U8</h2><ul>
<li>M3U8是一种常见的流媒体格式，主要以文件列表的形式存在，即支持直播又支持点播，尤其在Android，IOS等平台最为常用</li>
</ul>
<h2 id="FFmpeg抽取音视频文件中的AAC音频流"><a href="#FFmpeg抽取音视频文件中的AAC音频流" class="headerlink" title="FFmpeg抽取音视频文件中的AAC音频流"></a>FFmpeg抽取音视频文件中的AAC音频流</h2><ul>
<li><p>FFmpeg除了转封装，转码之外，还可以提取音频流，例如需要将音频流提取出来然后合成之后插入到另一个封装中的情况。</p>
</li>
<li><p>FFmpeg提取MP4文件中的AAC音频流方法：</p>
<ul>
<li>.&#x2F;ffmpeg -i input.mp4 -vn -acodec copy output.aac</li>
</ul>
</li>
</ul>
<h2 id="FFmpeg-硬编解码"><a href="#FFmpeg-硬编解码" class="headerlink" title="FFmpeg 硬编解码"></a>FFmpeg 硬编解码</h2><ul>
<li>当使用FFmpeg进行软编码时，常见的基于CPU进行H.264或H.265编码其相对成本会比较高，CPU编码时的性能也很低，所以出于编码效率及成本考虑，很多时候都会考虑采用硬编码，常见的硬编码包含Nvidia GPU与Intel QSV两种，还有常见的嵌入式平台，例如树莓派，瑞芯微等。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-C++_Core_Guidelines/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-C++_Core_Guidelines/" class="post-title-link" itemprop="url">C++_Core_Guidelines</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ Core Guidelines笔记</li>
</ul>
<h2 id="第二章-理念"><a href="#第二章-理念" class="headerlink" title="第二章 理念"></a>第二章 理念</h2><h3 id="在代码中直接表达思想"><a href="#在代码中直接表达思想" class="headerlink" title="在代码中直接表达思想"></a>在代码中直接表达思想</h3><ul>
<li>程序员应该直接用代码直接表达他们的思想，因为代码可以被编译器和工具检查</li>
<li>一个专业的C++开发者应该了解STL算法</li>
</ul>
<h3 id="用ISO标准C-写代码"><a href="#用ISO标准C-写代码" class="headerlink" title="用ISO标准C++写代码"></a>用ISO标准C++写代码</h3><ul>
<li>使用当前的C++标准，不要使用编译器扩展</li>
<li>此外，要注意未定义行为和实现定义行为<ul>
<li>未定义行为： </li>
<li>实现定义行为：程序的行为可能因编译器实现而异。实现必须在文档里描述实现的行为</li>
</ul>
</li>
</ul>
<p>在C++编程中，有两个重要的概念：未定义行为（Undefined Behavior）和实现定义行为（Implementation Defined Behavior）。</p>
<ol>
<li><p><strong>未定义行为 (Undefined Behavior)</strong>:</p>
<ul>
<li>当程序包含未定义行为时，C++标准没有规定程序的行为，允许编译器和运行时环境采用任何行为。这可能导致程序崩溃、产生意外结果、或者在不同的编译器、平台或编译选项下表现不同。</li>
<li>未定义行为可能是由于程序中的错误、溢出、指针操纵等原因引起的，也可能是标准规定没有定义的操作。</li>
</ul>
</li>
<li><p><strong>实现定义行为 (Implementation Defined Behavior)</strong>:</p>
<ul>
<li>当某个方面的行为是由C++标准定义的，但是标准允许不同的实现在这方面做出不同的选择，这被称为实现定义行为。</li>
<li>例如，标准规定某个操作的结果可以有多种可能，但实现需要选择其中一种并在文档中明确说明。</li>
</ul>
</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; arr[<span class="number">5</span>] &lt;&lt; std::endl; <span class="comment">// 未定义行为，越界访问数组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">-5</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; x * y &lt;&lt; std::endl; <span class="comment">// 实现定义行为，结果取决于具体的实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，访问数组<code>arr</code>的第六个元素是未定义行为，因为数组索引越界。而对于<code>x * y</code>的乘法，结果是实现定义的，因为标准并没有规定对于负数和无符号数相乘的具体行为。</p>
<p>在编写C++代码时，尽量避免未定义行为，因为它可能导致代码在不同环境下的行为不可预测。实现定义行为可能会因不同的编译器或平台而异，但至少有一个可预测的结果。</p>
<ul>
<li>当你必须使用没有写在ISO标准里的扩展时，可以用一个稳定的接口将它们封装起来</li>
</ul>
<h3 id="表达意图"><a href="#表达意图" class="headerlink" title="表达意图"></a>表达意图</h3><ul>
<li>表达意图是良好的代码文档的一个重要准则。文档应该说明代码会做什么，而不是代码会怎么做</li>
</ul>
<h3 id="不要泄漏任何资源"><a href="#不要泄漏任何资源" class="headerlink" title="不要泄漏任何资源"></a>不要泄漏任何资源</h3><ul>
<li>资源可以是内存，也可以是文件句柄或者套接字。</li>
<li>处理资源的惯用法是RAII。RAII是 Resource Acquisition Is Initialization(资源获取即初始化)的缩写，本质上意味着你在用户定义类型的构造函数中获取资源，在析构函数中释放资源。通过使对象成为一个有作用于的对象，C++的运行时会自动照顾到资源的生存期</li>
<li>C++大量使用RAII：锁负责处理互斥量，智能指针负责处理原始内存，STL的容器负责处理底层元素，等等</li>
</ul>
<h3 id="不可变数据优先于可变数据"><a href="#不可变数据优先于可变数据" class="headerlink" title="不可变数据优先于可变数据"></a>不可变数据优先于可变数据</h3><ul>
<li>使用不可变数据的理由有很多。</li>
<li>首先，当你使用常量时，你的代码更加容易验证</li>
<li>最重要的是常量在并发程序中具有很大的优势</li>
<li>不可变数据在设计上是没有数据竞争的，因为数据竞争的必要条件就是对数据进行修改</li>
</ul>
<h3 id="封装杂乱的构件，不要让他在代码中散布开"><a href="#封装杂乱的构件，不要让他在代码中散布开" class="headerlink" title="封装杂乱的构件，不要让他在代码中散布开"></a>封装杂乱的构件，不要让他在代码中散布开</h3><ul>
<li>混乱的代码往往是低级代码易于隐藏错误，容易出现问题。</li>
<li>如果可能的话，用STL中的高级构件(例如容器和算法)来取代你的杂乱代码。</li>
<li>如果这不可能，就把那些杂乱的代码封装带一个用户自定义的类型或者函数中</li>
</ul>
<h3 id="适当使用辅助工具"><a href="#适当使用辅助工具" class="headerlink" title="适当使用辅助工具"></a>适当使用辅助工具</h3><ul>
<li>计算机比人类更擅长做枯燥和重复性的工作。也就是说，应该使用静态分析工具，并发工具和测试工具来自动完成这些验证。</li>
<li>用一个以上的C++编译器来编译代码，往往是验证代码的最简单方式。一个编译器可能检测不到某种未定义行为，而另一个编译器可能会在同样的情况下发出警告或者产生错误</li>
</ul>
<h3 id="适当使用支持库"><a href="#适当使用支持库" class="headerlink" title="适当使用支持库"></a>适当使用支持库</h3><ul>
<li>你应该去找设计良好，文档齐全，支持良好的库。</li>
<li>突出的例子包括：<ul>
<li>C++标准库</li>
<li>Guidelines支持的库</li>
<li>Boost库</li>
</ul>
</li>
</ul>
<h2 id="第三章-接口"><a href="#第三章-接口" class="headerlink" title="第三章 接口"></a>第三章 接口</h2><ul>
<li>接口是服务的提供者和使用者之间的契约</li>
</ul>
<h3 id="避免非const的全局变量"><a href="#避免非const的全局变量" class="headerlink" title="避免非const的全局变量"></a>避免非const的全局变量</h3><ul>
<li>全局变量会在函数中注入隐藏的依赖，而该依赖并不是接口的一部分</li>
<li>非const的全局变量有许多弊端。首先，非const的全局变量破坏了封装。这种对封装的破坏让你无法对函数&#x2F;类(实体)进行孤立思考。</li>
</ul>
<h3 id="避免单例"><a href="#避免单例" class="headerlink" title="避免单例"></a>避免单例</h3><ul>
<li>单例就是全局变量，因此你应当尽可能避免单例。单例简单，直接地保证该类最多只有一个实例存在。</li>
<li>C++ 单例模式 详解<br>单例模式是一种设计模式，其目的是确保一个类只有一个实例，并提供全局访问点。这有助于确保在整个应用程序中共享相同的资源或状态，以及提供一种方便的方法来访问该实例。下面详细解释C++中的单例模式。</li>
</ul>
<h3 id="实现单例模式的步骤："><a href="#实现单例模式的步骤：" class="headerlink" title="实现单例模式的步骤："></a>实现单例模式的步骤：</h3><ol>
<li><p><strong>私有构造函数：</strong> 将类的构造函数声明为私有，以防止外部直接实例化类。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;  <span class="comment">// 私有构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态成员变量：</strong> 在类中声明一个静态私有指针，用于保存唯一的实例。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;  <span class="comment">// 静态私有指针</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;  <span class="comment">// 私有构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态方法：</strong> 提供一个公共的静态方法，用于获取类的实例。在这个方法中，检查实例是否已经存在，如果不存在，则创建一个新实例并返回。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;  <span class="comment">// 静态私有指针</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;  <span class="comment">// 私有构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除复制构造函数和赋值运算符：</strong> 为了防止通过复制构造函数或赋值运算符创建新实例，将它们声明为私有并不实现。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;  <span class="comment">// 静态私有指针</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;  <span class="comment">// 私有构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);  <span class="comment">// 禁止复制构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);  <span class="comment">// 禁止赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="线程安全性："><a href="#线程安全性：" class="headerlink" title="线程安全性："></a>线程安全性：</h3><p>上述实现在单线程环境下是有效的，但在多线程环境中可能会有问题。为了确保线程安全，可以使用加锁机制，例如互斥锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;  <span class="comment">// 静态私有指针</span></span><br><span class="line">    <span class="type">static</span> std::mutex mutex;     <span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;               <span class="comment">// 私有构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);             <span class="comment">// 禁止复制构造函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);  <span class="comment">// 禁止赋值运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态成员变量</span></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例实例</span></span><br><span class="line">    Singleton* singletonInstance1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* singletonInstance2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Address of instance 1: &quot;</span> &lt;&lt; singletonInstance1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Address of instance 2: &quot;</span> &lt;&lt; singletonInstance2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，通过 <code>std::mutex</code> 实现了简单的互斥锁，确保在多线程环境中仍然能够正确地创建单例实例。</p>
<h3 id="运用依赖注入化解"><a href="#运用依赖注入化解" class="headerlink" title="运用依赖注入化解"></a>运用依赖注入化解</h3><ul>
<li>当某个对象使用单例的时候，隐藏的依赖就被注入对象中。而借助依赖注入技术，这个依赖可以变成接口的一部分，并且服务是从外界注入的。这样，客户代码和注入的服务之间就没有了依赖。</li>
<li>依赖注入的典型方式是构造函数，设置函数(setter)成员或者模板参数</li>
</ul>
<h3 id="构建良好的接口"><a href="#构建良好的接口" class="headerlink" title="构建良好的接口"></a>构建良好的接口</h3><ul>
<li><p>函数应该通过接口(而不是全局变量)进行沟通。</p>
</li>
<li><p>接口应当遵循以下规则：</p>
<ul>
<li>接口明确</li>
<li>接口精确并且具有强类型</li>
<li>保持较低的参数数目</li>
<li>避免相同类型却不相关的参数相邻</li>
</ul>
</li>
<li><p>术语”可调用”(callable)。可调用实体是在行为上像函数的东西。它可以是函数，也可以是函数对象，或者是lambda表达时。</p>
</li>
<li><p>如果可调用实体接受一个参数，它就是一元可调用实体；如果它接受两个参数，则称为二元可调用实体</p>
</li>
<li><p>std::transform_reduce先将一元可调用实体应用到一个范围或者将二元可调用实体应用到两个范围，然后将二元可调用实体应用到前一步的结果的范围上。</p>
</li>
</ul>
<h3 id="不要用单个指针来传递数组"><a href="#不要用单个指针来传递数组" class="headerlink" title="不要用单个指针来传递数组"></a>不要用单个指针来传递数组</h3><ul>
<li>这条规则的出现是为了解决一些未定义行为</li>
<li>补救的方法也简单，使用STL中的容器，例如std::vector，并在函数体中检查容器的大小</li>
</ul>
<h3 id="为了库ABI的稳定，考虑使用PImpI惯用法"><a href="#为了库ABI的稳定，考虑使用PImpI惯用法" class="headerlink" title="为了库ABI的稳定，考虑使用PImpI惯用法"></a>为了库ABI的稳定，考虑使用PImpI惯用法</h3><ul>
<li><p>应用程序二进制接口(ABI)是两个二进制程序模块间的接口</p>
</li>
<li><p>借助PImpI惯用法，可以隔离类的用户和实现，从而避免重复编译。</p>
</li>
<li><p>PImpI是 pointer to implementation(指向实现的指针)的缩写，它指的是C++中的一种编程技巧：</p>
<ul>
<li>将实现细节放在另一个类中，从而将其从类中移除。而这个包含实现的细节的类是通过一个指针来访问的。</li>
<li>这么做是因为私有数据成员会参与类的内存布局，而私有函数成员会参与重载决策。这些依赖意味着对成员实现细节的修改会导致所有类的用户都需要重新编译。</li>
<li>持有指向实现的指针(PImpI)的类可将用户隔离在类实现的变化之外，而代价则是多了一次间接。</li>
</ul>
</li>
<li><p>C++ PImpI编程技巧  详解<br>PImpl（Pointer to Implementation）是一种编程技巧，也称为“编译期实现”或“内部实现”，它的目的是将类的实现细节封装在一个单独的实现类中，从而减少头文件的依赖关系，提高代码的模块化性和可维护性。</p>
</li>
</ul>
<h3 id="PImpl模式的实现步骤："><a href="#PImpl模式的实现步骤：" class="headerlink" title="PImpl模式的实现步骤："></a>PImpl模式的实现步骤：</h3><ol>
<li><p><strong>声明外部接口：</strong> 在类的头文件中声明类的公共接口，但将实际的成员变量和实现细节的声明放到一个内部类中。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>();</span><br><span class="line">    ~<span class="built_in">MyClass</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicMethod1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicMethod2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Impl</span>;  <span class="comment">// 内部实现类的前向声明</span></span><br><span class="line">    Impl* pImpl;  <span class="comment">// 内部实现类的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>定义实现类：</strong> 在实现文件中定义内部实现类，并将实际的成员变量和函数实现放在这里。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现内部实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>::Impl &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">privateMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现细节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">privateMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现细节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClass 构造函数</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>() : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">Impl</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClass 析构函数</span></span><br><span class="line">MyClass::~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> pImpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共方法的实现调用内部实现类的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::publicMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pImpl-&gt;<span class="built_in">privateMethod1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::publicMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pImpl-&gt;<span class="built_in">privateMethod2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="PImpl的优势："><a href="#PImpl的优势：" class="headerlink" title="PImpl的优势："></a>PImpl的优势：</h3><ol>
<li><p><strong>降低编译依赖：</strong> 将实现细节从头文件中移除，降低了头文件的依赖关系。这样，当实现发生变化时，只有实现文件需要重新编译，而不会影响到调用方。</p>
</li>
<li><p><strong>隐藏实现细节：</strong> 将实现细节放在内部实现类中，可以隐藏对类的具体实现的细节，只需要暴露公共接口给用户。</p>
</li>
<li><p><strong>减小编译时间：</strong> 当头文件发生变化时，只有依赖头文件的文件需要重新编译，而不会触发整个项目的重新编译。</p>
</li>
<li><p><strong>改善二进制兼容性：</strong> 通过将实现细节放在内部实现类中，可以减少对外部接口的更改，提高二进制兼容性。</p>
</li>
<li><p><strong>模块化设计：</strong> 可以更容易地设计模块化的系统，每个模块只关注自己的接口和实现细节。</p>
</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ol>
<li><p><strong>内存管理：</strong> 要确保在类的析构函数中正确释放内部实现类的内存，以防止内存泄漏。</p>
</li>
<li><p><strong>拷贝和赋值：</strong> PImpl模式可能导致默认的拷贝构造函数和赋值运算符不再适用，需要自定义这些函数并确保正确处理内部实现类的拷贝和赋值。</p>
</li>
<li><p><strong>性能开销：</strong> PImpl模式引入了指针和额外的间接层，可能会带来一些微小的性能开销，但通常在维护性和可读性上的优势远远超过了这些开销。</p>
</li>
</ol>
<p>PImpl是一种强大的C++编程技巧，特别适用于大型项目和库的开发，有助于提高代码的模块化性和可维护性。</p>
<h3 id="本章精华"><a href="#本章精华" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>不要使用全局变量，它们会引入隐藏的依赖</li>
<li>单例就是变相的全局变量</li>
<li>接口，尤其是函数，应该表达出意图</li>
<li>接口应当是强类型的，而且应该只有几个不容易弄混的参数</li>
<li>不要按指针接收C数组，而应该使用std::span</li>
<li>如果你想要将类的使用和实现分开，请使用PImpI惯用法</li>
</ul>
<h2 id="第四章-函数"><a href="#第四章-函数" class="headerlink" title="第四章 函数"></a>第四章 函数</h2><ul>
<li>软件开发人员通过将复杂的任务划分为较小的单元来掌控复杂性。在处理完小单元后，他们把小单元放在一起来掌控复杂的任务。</li>
<li>函数是一种典型的单元，也是程序的基本构件。</li>
</ul>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><ul>
<li><p>好软件的最重要原则是好名字。</p>
</li>
<li><p>将有意义的操作打包成精心命名的函数</p>
</li>
<li><p>一个函数应该执行单一的逻辑操作</p>
</li>
<li><p>使函数保持简短</p>
</li>
<li><p>当你无法为函数找到一个有意义的名称时，这充分说明你的函数执行不止一项逻辑操作，而且你的函数并不简短</p>
</li>
</ul>
<h3 id="如果函数有可能需要在编译期求值，就把它声明为-constexpr"><a href="#如果函数有可能需要在编译期求值，就把它声明为-constexpr" class="headerlink" title="如果函数有可能需要在编译期求值，就把它声明为 constexpr"></a>如果函数有可能需要在编译期求值，就把它声明为 constexpr</h3><ul>
<li>constexpr函数是可能在编译期运行的函数。当你在常量表达式中调用constexpr函数时，或者当你要用一个constexpr变量来获取constexpr函数的结果时，它会在编译期运行。也可以用只能在运行其求值的参数来调用constexpr函。</li>
<li>constexpr函数是隐含內联的</li>
<li>编译期求值的constexpr的结果通常会被系统标记为只读</li>
<li>性能是constexpr函数的第一大好处；它的第二大好处是，编译期求值的constexpr函数是纯函数，因此constexpr函数是线程安全的</li>
<li>最后，计算结果会在运行期作为只读存储区域中的常量来提供</li>
</ul>
<h3 id="如果你的函数必定不抛异常，就把它声明为noexcept"><a href="#如果你的函数必定不抛异常，就把它声明为noexcept" class="headerlink" title="如果你的函数必定不抛异常，就把它声明为noexcept"></a>如果你的函数必定不抛异常，就把它声明为noexcept</h3><ul>
<li>通过将函数声明为noexcept，你减少了备选控制路径的数量；因此，noexcept对优化器来说是一个有价值的提示</li>
<li>即使你的函数可以抛出异常，noexcept往往也合理。noexcept在这种情况下意味着：我不在乎异常。其原因可能是：你无法对异常作出反应。在这种情况下，系统处理异常的唯一办法是调用std::terminate()</li>
<li>以下类型的函数永远不应该抛出异常：<ul>
<li>析构函数</li>
<li>swap函数</li>
<li>移动操作和默认构造函数</li>
</ul>
</li>
</ul>
<h3 id="优先使用纯函数"><a href="#优先使用纯函数" class="headerlink" title="优先使用纯函数"></a>优先使用纯函数</h3><ul>
<li><p>纯函数是指在给定相同参数时总是返回相同结果的函数。这个属性也被称为引用透明性。纯函数的行为就像无限大的查找表</p>
</li>
<li><p>非纯函数是指random()或者time()这样的函数，它们会在不同的调用中返回不同的结果。换句话说，与函数体之外的状态交互的函数是不纯的</p>
</li>
<li><p>纯函数有一些非常有趣的属性</p>
<ul>
<li>孤立的测试</li>
<li>孤立的验证或重构</li>
<li>还存其结果</li>
<li>被自动重排或者在其他线程上执行</li>
</ul>
</li>
<li><p>纯函数也常被称为数学函数。</p>
</li>
<li><p>constexpr函数在编译期求值时是纯的。模板元编程是一种嵌在命令式语言C++中的纯函数式语言</p>
</li>
</ul>
<h3 id="优先采用简单而约定俗成的信息传递方式"><a href="#优先采用简单而约定俗成的信息传递方式" class="headerlink" title="优先采用简单而约定俗成的信息传递方式"></a>优先采用简单而约定俗成的信息传递方式</h3><ul>
<li><p>数据的类型：</p>
<ul>
<li>拷贝开销低或者不可能拷贝构造： func(X)</li>
<li>移动开销低：std::vector<T>, std::string</li>
<li>移动开销中: std::array<a href="std::vector">std::vector</a>或者BigPOD(POD代表 Plain Old Data，简旧数据，意为一般的传统数据–没有析构函数，构造函数以及虚成员函数的类)</li>
<li>移动开销未知: 模板</li>
<li>移动开销高：BigPOD[]或者std::array<BigPOD></li>
</ul>
</li>
<li><p>参数传递的方向</p>
<ul>
<li>入：输入参数</li>
<li>入并保留拷贝：被调用者保留一份数据</li>
<li>入并移入：参数处在所谓的被移动状态。被移动状态意味着它处于合法但未指定的状态。基本上，你在重新使用被移动的对象前必须对他进行初始化</li>
<li>入&#x2F;出：参数会被修改</li>
<li>出：输出参数</li>
</ul>
</li>
</ul>
<h3 id="对于入参，拷贝开销低的类型按值传递，其他类型则以const引用来传递"><a href="#对于入参，拷贝开销低的类型按值传递，其他类型则以const引用来传递" class="headerlink" title="对于入参，拷贝开销低的类型按值传递，其他类型则以const引用来传递"></a>对于入参，拷贝开销低的类型按值传递，其他类型则以const引用来传递</h3><ul>
<li>默认情况下，输入值可以拷贝就拷贝。如果拷贝开销不低，就通过const引用来传入。</li>
<li>经验法则：<ul>
<li>如果 sizeof(par) &lt;&#x3D; 2 * sizeof(void*)，则按值传递参数par</li>
<li>如果 sizeof(par) &gt; 2 * sizeof(void*)，则按const引用传递par</li>
</ul>
</li>
</ul>
<h3 id="对于转发参数，要用TP-来传递，并且只std-forward该参数"><a href="#对于转发参数，要用TP-来传递，并且只std-forward该参数" class="headerlink" title="对于转发参数，要用TP&amp;&amp;来传递，并且只std::forward该参数"></a>对于转发参数，要用TP&amp;&amp;来传递，并且只std::forward该参数</h3><ul>
<li>有时你想转发参数par。这意味着你希望保持左值的左值性，以及右值的右值性，这样才能完美地转发参数，使它的语义不发生变化</li>
<li>转发参数的典型用例是工厂函数，工厂函数通过调用某个用户指定对象的构造函数创建出该对象。你不知道参数是不是右值，也不知道构造函数需要多少个参数</li>
</ul>
<p>在C++中，工厂函数是一种设计模式，它提供了一种创建对象的方式，使得在不暴露对象的具体实现细节的情况下能够创建对象。工厂函数通常用于创建类的实例，而不是直接调用类的构造函数。这有助于实现抽象和封装，同时提供了灵活性和可维护性。</p>
<p>以下是关于C++工厂函数的一些详解：</p>
<ol>
<li><p><strong>定义</strong>：<br>工厂函数是一个函数，负责创建和返回类的实例。它通常是类的静态成员函数，或者是一个独立于类的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Product</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体产品的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Product* <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回类型</strong>：<br>工厂函数通常返回一个指向基类（抽象类）的指针或引用，这样可以隐藏具体实现的细节，同时允许客户端代码通过基类接口使用对象。</p>
</li>
<li><p><strong>抽象类</strong>：<br>工厂函数通常用于创建抽象类的实例，这样可以根据需要选择合适的具体实现。在上面的例子中，<code>Product</code> 是抽象类，而 <code>ConcreteProduct</code> 是它的具体实现。</p>
</li>
<li><p><strong>灵活性</strong>：<br>工厂函数提供了一种动态创建对象的方式，允许在运行时根据条件或配置选择要创建的具体类型，从而提供更大的灵活性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Product* product = Factory::<span class="built_in">createProduct</span>();</span><br><span class="line">    product-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">    <span class="keyword">delete</span> product;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多态性</strong>：<br>通过返回基类指针，工厂函数支持多态性，允许通过基类接口调用具体类的方法。</p>
</li>
<li><p><strong>单例工厂</strong>：<br>工厂函数可以实现为单例，确保在应用程序中只存在一个工厂实例，从而确保对对象创建的全局控制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingletonFactory&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> SingletonFactory instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Product* <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingletonFactory</span>() &#123;&#125;  <span class="comment">// 私有构造函数，确保只能通过 getInstance() 访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总的来说，工厂函数是一种有用的设计模式，它提供了一种灵活、可扩展且易于维护的方式来创建对象，特别是在需要隐藏具体实现的情况下。</p>
<ul>
<li>三个点(省略号)表示形参包。我们将使用形参包的模板称为变参模板</li>
<li>形参包的打包和解包<ul>
<li>当省略号在类型参数T1的左边时，参数包被打包；当省略号在右边时，参数包被解包</li>
<li>返回语句 T(std::forward<T1>(t1)…)中的这种解包实质上意味着表达式std::forward<T1>(t1)被不断重复，直到形参表的所有参数都被消耗掉，并且会在每个子表达式之间加一个逗号</li>
</ul>
</li>
<li>C++ 形参包 详解</li>
</ul>
<p>在C++中，形参包（parameter pack）是C++11引入的一个特性，它允许你定义一个可以包含任意数量参数的函数或类模板。形参包的主要优势之一是在不知道参数数量的情况下，仍然能够编写通用的代码。</p>
<p>以下是有关C++形参包的详解：</p>
<ol>
<li><p><strong>定义形参包</strong>：<br>形参包使用省略号 <code>...</code> 表示。它可以用在函数模板或类模板的参数列表中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板形参包的例子</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用args...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>Args</code> 是一个模板参数包，而 <code>args</code> 是函数参数包。</p>
</li>
<li><p><strong>展开形参包</strong>：<br>通过使用展开操作符 <code>...</code>，可以在函数体内展开形参包，以便对每个参数执行相同的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValues</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// 展开形参包，逐个输出参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>(std::cout &lt;&lt; ... &lt;&lt; args)</code> 部分展开了形参包，逐个将参数传递给 <code>std::cout</code>。</p>
</li>
<li><p><strong>递归展开</strong>：<br>形参包可以用于递归展开，实现对每个参数的逐一处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSingleValue</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValues</span><span class="params">(T first, Args... rest)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printSingleValue</span>(first);    <span class="comment">// 处理第一个参数</span></span><br><span class="line">    <span class="built_in">printValues</span>(rest...);       <span class="comment">// 递归展开处理剩余参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>printValues</code> 函数递归展开形参包，对每个参数调用 <code>printSingleValue</code> 函数。</p>
</li>
<li><p><strong>折叠表达式</strong>：<br>C++17 引入了折叠表达式，使得展开形参包更加简洁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValues</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// 折叠表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>折叠表达式使得对形参包的处理更加紧凑和易读。</p>
</li>
<li><p><strong>使用形参包的场景</strong>：<br>形参包通常在需要处理可变数量参数的通用函数或模板中使用，例如元组的操作、可变参数模板、泛型代码等。</p>
</li>
</ol>
<p>形参包是C++中强大的工具，它为编写通用和灵活的代码提供了便利。在处理不定数量参数的场景中，形参包的使用可以显著提高代码的可读性和可维护性。</p>
<ul>
<li>转发与变参模板的结合是C++中典型的创建模式</li>
</ul>
<h3 id="对于-入-出-参数，使用非const的引用来传递"><a href="#对于-入-出-参数，使用非const的引用来传递" class="headerlink" title="对于 入-出 参数，使用非const的引用来传递"></a>对于 入-出 参数，使用非const的引用来传递</h3><ul>
<li>这条规则把函数的设计意图传达给了调用法：该函数会修改它的参数</li>
</ul>
<h3 id="对于-出-的输出值，优先使用返回值而非输出参数"><a href="#对于-出-的输出值，优先使用返回值而非输出参数" class="headerlink" title="对于 出 的输出值，优先使用返回值而非输出参数"></a>对于 出 的输出值，优先使用返回值而非输出参数</h3><ul>
<li>用返回值就好，但是别用const，因为它不但没有附加价值，而且还会干扰移动语义</li>
</ul>
<h3 id="要返回多个-出-值，优先考虑返回结构体或者多元组"><a href="#要返回多个-出-值，优先考虑返回结构体或者多元组" class="headerlink" title="要返回多个 出 值，优先考虑返回结构体或者多元组"></a>要返回多个 出 值，优先考虑返回结构体或者多元组</h3><ul>
<li><p>当你向std::set中插入一个值时，成员函数insert的重载会返回一个std::pair，它由两部分组成：</p>
<ul>
<li>一个指向所插入元素的迭代器</li>
<li>还有一个bool，如果插入成功，它会被设置为true</li>
</ul>
</li>
<li><p>C++11中的std::tie和C++17中的结构化绑定是将两个值绑定到某变量的两种优雅方式</p>
</li>
<li><p>结构化绑定<br>C++结构化绑定（Structured Bindings）是C++17引入的一项特性，它提供了一种方便的方式来将多个变量绑定到结构体、元组或其他类似的数据结构的成员上。结构化绑定的目的是简化对结构化数据的访问和处理。</p>
</li>
</ul>
<p>在结构化绑定中，可以使用<code>auto</code>关键字和花括号来声明和初始化多个变量，这些变量会被绑定到结构体或元组的成员。这使得代码更加简洁和可读。</p>
<p>以下是结构化绑定的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例：使用结构化绑定绑定元组的元素</span></span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; myTuple&#123;<span class="number">42</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [a, b, c] = myTuple;  <span class="comment">// 结构化绑定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在 a, b, c 分别是 myTuple 的元素</span></span><br><span class="line">    <span class="comment">// a = 42, b = 3.14, c = &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子中，<code>auto [a, b, c]</code> 表示使用结构化绑定将<code>myTuple</code>中的元素绑定到变量<code>a</code>、<code>b</code>、<code>c</code>上。</p>
<p>另外，结构化绑定还可以用于对结构体成员的绑定，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [px, py] = p;  <span class="comment">// 结构化绑定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// px = 10, py = 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构化绑定在循环中也非常有用，可以方便地遍历容器中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [index, value] : vec) &#123;</span><br><span class="line">        <span class="comment">// 使用结构化绑定遍历容器中的元素</span></span><br><span class="line">        <span class="comment">// index 和 value 分别绑定到 pair 的第一个和第二个元素</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构化绑定在C++中提供了一种更简洁、更灵活的方式来处理结构化数据，从而使代码更加清晰易读。这个特性的引入使得C++语言更具现代感和表达力。</p>
<h3 id="参数传递：-所有权语义"><a href="#参数传递：-所有权语义" class="headerlink" title="参数传递： 所有权语义"></a>参数传递： 所有权语义</h3><ul>
<li><p>func(value): 函数func自己有一份value的拷贝并且就是其所有者。func会自动释放该资源</p>
</li>
<li><p>func(pointer*)： func借用了资源，所以无权删除该资源。func在每次使用前都必须检查该指针是否为空指针</p>
</li>
<li><p>func(reference&amp;)：func借用了资源。与指针不同，引用的值总是合法的</p>
</li>
<li><p>func(std::unique_ptr): func是资源的新所有者。func的调用方法显式地把资源的所有权传递给了被调用方。func会自动释放该资源</p>
</li>
<li><p>func(std::shared_ptr): func是资源的额外所有者。func会延长资源的生存期。在func结束时，它也会结束对资源的所有权。如果func是资源的最后一个所有者，那么它的结束会导致资源的释放</p>
</li>
<li><p>在应用层面使用std::move的意图并不在于移动。在应用层面使用std::move的目的是所有权的转移</p>
</li>
<li><p>C++ 所有权语义 详解<br>C++的所有权语义指的是对于对象内存的所有权管理方式，即确定何时创建、拥有、传递和销毁对象。在C++中，主要有两种所有权语义，即值语义和引用语义。</p>
</li>
</ul>
<ol>
<li><p><strong>值语义（Value Semantics）</strong>：</p>
<ul>
<li><strong>对象拥有其值</strong>：当使用值语义时，对象在栈上或作为成员变量直接存储其值。当对象复制时，新的对象独立拥有自己的值，不受原始对象的影响。</li>
<li><strong>拷贝构造函数和赋值运算符</strong>：值类型对象通常需要定义拷贝构造函数和赋值运算符，以确保正确地复制对象的值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ValueSemanticsExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ValueSemanticsExample</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">ValueSemanticsExample</span>(<span class="type">const</span> ValueSemanticsExample&amp; other) : <span class="built_in">value</span>(other.value) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值运算符</span></span><br><span class="line">    ValueSemanticsExample&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ValueSemanticsExample&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            value = other.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用语义（Reference Semantics）</strong>：</p>
<ul>
<li><strong>对象拥有引用</strong>：当使用引用语义时，对象本身并不存储值，而是存储对其他对象的引用。多个对象可以共享相同的值。</li>
<li><strong>拷贝构造函数和赋值运算符需小心</strong>：引用类型对象通常需要小心处理拷贝构造函数和赋值运算符，以避免意外地共享底层资源。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReferenceSemanticsExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ReferenceSemanticsExample</span>(<span class="type">int</span>&amp; valRef) : <span class="built_in">valueReference</span>(valRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>&amp; valueReference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在现代C++中，智能指针也提供了一种更灵活的所有权语义。智能指针允许在堆上动态分配内存，并通过引用计数等机制来管理内存的释放。<code>std::unique_ptr</code>提供了独占所有权，而<code>std::shared_ptr</code>允许多个指针共享同一块内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPointerExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmartPointerExample</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(val)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在选择值语义还是引用语义时，需要根据程序的需求和性能考虑。值语义通常更容易理解和使用，而引用语义可以更有效地共享资源，但需要小心管理共享状态，以避免潜在的问题。</p>
<h3 id="返回-T-仅仅-用于表示位置"><a href="#返回-T-仅仅-用于表示位置" class="headerlink" title="返回 T* (仅仅)用于表示位置"></a>返回 T* (仅仅)用于表示位置</h3><ul>
<li><p>指针仅用于表示位置。这正是函数find的作用</p>
</li>
<li><p>指针或引用永远不应该转移所有权</p>
</li>
</ul>
<h3 id="当不希望发生拷贝，也不需要表达-没有返回对象-时，应该返回-T"><a href="#当不希望发生拷贝，也不需要表达-没有返回对象-时，应该返回-T" class="headerlink" title="当不希望发生拷贝，也不需要表达 没有返回对象 时，应该返回 T&amp;"></a>当不希望发生拷贝，也不需要表达 没有返回对象 时，应该返回 T&amp;</h3><ul>
<li><p>当不存在 没有返回对象 这种可能性的时候，就可以返回引用而非指针了</p>
</li>
<li><p>有时你想进行链式操作，但是不详为不必要的临时对象进行拷贝和析构</p>
</li>
<li><p>返回局部对象的引用(指针)是未定义行为。未定义行为本质上意味着，不要假想程序的行为</p>
</li>
</ul>
<h3 id="不要返回-T"><a href="#不要返回-T" class="headerlink" title="不要返回 T&amp;&amp;"></a>不要返回 T&amp;&amp;</h3><h3 id="不要返回-std-move-本地变量"><a href="#不要返回-std-move-本地变量" class="headerlink" title="不要返回 std::move(本地变量)"></a>不要返回 std::move(本地变量)</h3><h3 id="main-的返回类型是-int"><a href="#main-的返回类型是-int" class="headerlink" title="main()的返回类型是 int"></a>main()的返回类型是 int</h3><ul>
<li><p>依照C++标准,main函数有两种变体</p>
<ul>
<li>int main() {…}</li>
<li>int main(int argc, char** argv[]) {…}</li>
</ul>
</li>
<li><p>第二个版本等效于 int main(int argc, char* argv[]) {…}</p>
</li>
<li><p>main函数并不需要返回语句。如果控制流到达main函数的末尾而没有碰到一条返回语句，其效果相当于执行 return 0; 这意味着程序的成功执行</p>
</li>
</ul>
<h3 id="当函数不适用时-需要捕获局部变量，或者编写一个局部函数-，请使用lambda表达式"><a href="#当函数不适用时-需要捕获局部变量，或者编写一个局部函数-，请使用lambda表达式" class="headerlink" title="当函数不适用时(需要捕获局部变量，或者编写一个局部函数)，请使用lambda表达式"></a>当函数不适用时(需要捕获局部变量，或者编写一个局部函数)，请使用lambda表达式</h3><ul>
<li>什么时候必须用lambda表达式，什么是否必须使用普通函数。这里有两条明显的理由<ul>
<li>如果可调用实体必须捕获局部变量或者它是在局部作用域内声明的，你就必须使用lambda函数</li>
<li>如果可调用实体需要支持重载，那么应该使用普通函数</li>
</ul>
</li>
</ul>
<h2 id="在局部使用-包括要传递给算法-的lambda表达式中，优先通过引用来捕获"><a href="#在局部使用-包括要传递给算法-的lambda表达式中，优先通过引用来捕获" class="headerlink" title="在局部使用(包括要传递给算法)的lambda表达式中，优先通过引用来捕获"></a>在局部使用(包括要传递给算法)的lambda表达式中，优先通过引用来捕获</h2><h2 id="在非局部使用-包括要被返回，存储在堆上或者要传递给其他线程-的lambda表达式中，避免通过引用来捕获"><a href="#在非局部使用-包括要被返回，存储在堆上或者要传递给其他线程-的lambda表达式中，避免通过引用来捕获" class="headerlink" title="在非局部使用(包括要被返回，存储在堆上或者要传递给其他线程)的lambda表达式中，避免通过引用来捕获"></a>在非局部使用(包括要被返回，存储在堆上或者要传递给其他线程)的lambda表达式中，避免通过引用来捕获</h2><ul>
<li>这两条规则高度关联，它们可以归结为： lambda表达式应该只对有效数据进行操作。<ul>
<li>当lambda通过拷贝捕获数据时，根据定义，数据总是有效的</li>
<li>当lambda通过引用捕获数据时，数据的生存期必须超过lambda的生存期</li>
</ul>
</li>
</ul>
<h3 id="在有选择的情况下优先采用默认参数而非重载"><a href="#在有选择的情况下优先采用默认参数而非重载" class="headerlink" title="在有选择的情况下优先采用默认参数而非重载"></a>在有选择的情况下优先采用默认参数而非重载</h3><ul>
<li>如果你需要用不同数量的参数来调用一个函数，尽可能优先采用默认参数而不是重载。这样你就遵循了DRY(不要重复自己)原则</li>
</ul>
<h3 id="不要使用-va-arg-参数"><a href="#不要使用-va-arg-参数" class="headerlink" title="不要使用 va_arg 参数"></a>不要使用 va_arg 参数</h3><ul>
<li><p>当你的函数需要接受任意数量的参数时，要使用变参模板而不是va_arg参数</p>
</li>
<li><p>变参数函数(variadic function)是像std::printf这样的函数，可以接受任意数量的参数。</p>
</li>
<li><p>问题是，必须假设传递的类型是正确的。当然这种假设非常容易出错，其正确性依赖于程序员的素养</p>
</li>
<li><p>va_arg宏的背景信息</p>
<ul>
<li>va_list : 保存下列宏的必要信息</li>
<li>va_start : 启用对变参数函数参数的访问</li>
<li>va_arg : 访问下一个变参数函数的参数</li>
<li>va_end : 结束对变参数函数参数的访问</li>
</ul>
</li>
<li><p>C++ va_arg 变参数函数参数 详解<br><code>va_arg</code> 是C语言中用于处理可变参数函数（变参函数）的宏，它允许函数接受可变数量的参数。在C++中，虽然不鼓励使用C风格的可变参数函数，但仍然支持这一特性。</p>
</li>
</ul>
<p>以下是关于<code>va_arg</code>的详解：</p>
<ol>
<li><p><strong>头文件</strong>：<br>使用 <code>va_arg</code> 需要包含 <code>&lt;cstdarg&gt;</code> 头文件，其中定义了一组宏和类型，用于处理可变参数函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可变参数函数的声明和定义</strong>：<br>可变参数函数通常以省略号 <code>...</code> 结尾，其中包含不定数量的参数。<code>va_list</code> 类型用于存储参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myVarArgsFunction</span><span class="params">(<span class="type">int</span> num, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> value = <span class="built_in">va_arg</span>(args, <span class="type">int</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Argument &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>myVarArgsFunction</code> 接受一个整数参数 <code>num</code>，表示后续可变参数的数量。函数通过 <code>va_arg</code> 从参数列表中获取具体的参数值。</p>
</li>
<li><p>**<code>va_start</code> 和 <code>va_end</code>**：<br>在使用 <code>va_arg</code> 之前，需要使用 <code>va_start</code> 宏初始化 <code>va_list</code> 对象，以及在函数结束时使用 <code>va_end</code> 宏清理资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myVarArgsFunction</span><span class="params">(<span class="type">int</span> num, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>参数传递的方式对使用 <code>va_arg</code> 很重要。对于整数、指针等基本类型，<code>va_arg</code> 可以很好地工作。但对于复杂的用户自定义类型，需要谨慎处理。</li>
<li>没有可变参数的方式获取参数数量，需要依赖固定参数来传递数量信息。</li>
<li>使用 <code>va_arg</code> 时，需要清楚每个参数的类型，以避免类型不匹配的问题。</li>
</ul>
</li>
<li><p><strong>C++ 中的替代方案</strong>：<br>在现代C++中，推荐使用模板和标准库中的可变参数模板（variadic templates）来代替传统的可变参数函数。这种方式更类型安全，更灵活。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myVarArgsFunction</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myVarArgsFunction</span>(<span class="number">1</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，使用可变参数模板实现了类似的功能，同时获得了更好的类型安全性。</p>
</li>
</ol>
<ul>
<li>这些问题可以通过C++17的折叠表达式轻松解决。跟va_arg相比，折叠表达式会自动推导出其参数的数量和类型</li>
<li>变参模板可以接受任意数量的参数。这些任意数量的参数由所谓的参数包持有，用省略号表示。</li>
<li>此外，在C++17中，可以用二元运算符直接对参数包进行归约。这一针对变参模板的增强被称为折叠表达式</li>
</ul>
<h3 id="本章精华-1"><a href="#本章精华-1" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>一个函数应该执行一个操作，要简短，并有一个精心选择的名字</li>
<li>要把可以在编译期运行的函数实现为constexpr</li>
<li>如果可能的话，将你的函数实现为纯函数</li>
<li>区分一个函数的入，入&#x2F;出和出参。对入参使用按值传递或者按const引用传递，对入&#x2F;出参数使用按引用传递，对出参使用按值传递</li>
<li>向函数传递参数涉及所有权语义的问题。按值传递使函数成为资源的独立所有者。按指针或引用传递意味着函数值是借用了该资源。std::unique_ptr将所有权转移给函数,std::shared_ptr则使函数称为共享的所有者</li>
<li>当你的函数需要接受任意数量的参数时，要使用变参模板而不是va_arg参数</li>
</ul>
<h2 id="第五章-类和类层次结构"><a href="#第五章-类和类层次结构" class="headerlink" title="第五章 类和类层次结构"></a>第五章 类和类层次结构</h2><ul>
<li><p>类是一种用户定义类型，程序员可以为其指定表示方法，操作和接口。</p>
</li>
<li><p>类的层次结构被用来组织相关的结构</p>
</li>
<li><p>Guidelines先给出了一些概要规则：</p>
<ul>
<li>具体类型</li>
<li>构造函数，赋值和析构函数</li>
<li>类的层次结构</li>
<li>重载和运算符重载</li>
<li>联合体</li>
</ul>
</li>
</ul>
<h3 id="class-类-和struct-结构体-之间的语法差异"><a href="#class-类-和struct-结构体-之间的语法差异" class="headerlink" title="class(类)和struct(结构体)之间的语法差异"></a>class(类)和struct(结构体)之间的语法差异</h3><ul>
<li>在结构体中，所有成员默认为 public(公开)。在类中，所有成员默认 private(私有)</li>
<li>继承的情况也是如此。结构体的基类默认为 public，类的基类默认为 private</li>
</ul>
<h3 id="把相关的数据组织到结构-struct或class-中"><a href="#把相关的数据组织到结构-struct或class-中" class="headerlink" title="把相关的数据组织到结构(struct或class)中"></a>把相关的数据组织到结构(struct或class)中</h3><ul>
<li>通过将相关元素放在结构体中，函数签名变得可以自我描述。</li>
</ul>
<h3 id="当类具有不变式时使用class；如果数据成员可以独立变化，则使用struct"><a href="#当类具有不变式时使用class；如果数据成员可以独立变化，则使用struct" class="headerlink" title="当类具有不变式时使用class；如果数据成员可以独立变化，则使用struct"></a>当类具有不变式时使用class；如果数据成员可以独立变化，则使用struct</h3><ul>
<li><p>类的不变式是用于约束类的实例的不变式。成员函数必须使这个不变式保持成立。不变式约束了类的实例的可能取值。</p>
</li>
<li><p>C++ 类中的不变式是什么意思</p>
<ul>
<li>在C++中，类的不变式（invariant）指的是在类的对象上始终保持成立的条件或属性。这是一种约定或规则，用于确保对象的有效性和一致性。在面向对象编程中，不变式是类设计的一部分，用于描述对象应该具有的状态。</li>
<li>不变式通常与类的公共接口和方法一起工作，确保在对象上执行操作时，类的内部状态不会违反这些不变式。不变式可以看作是类内部约定的一部分，旨在维护对象的有效性。</li>
<li>例如，考虑一个表示时间的类，该类有小时和分钟两个成员变量。一个可能的不变式是，小时应该在0到23之间，分钟应该在0到59之间。在类的方法中，如果有任何操作可能破坏这个不变式，需要在方法执行前或执行后重新确保不变式的成立。</li>
</ul>
</li>
<li><p>类的不变式在构造函数中被初始化和检查</p>
</li>
</ul>
<h3 id="在类中体现出接口和实现之间的区别"><a href="#在类中体现出接口和实现之间的区别" class="headerlink" title="在类中体现出接口和实现之间的区别"></a>在类中体现出接口和实现之间的区别</h3><ul>
<li>类的公开成员函数是类的接口，私有部分则是实现</li>
</ul>
<h3 id="仅当函数需要直接访问类的内部表示时，才把它变成成员"><a href="#仅当函数需要直接访问类的内部表示时，才把它变成成员" class="headerlink" title="仅当函数需要直接访问类的内部表示时，才把它变成成员"></a>仅当函数需要直接访问类的内部表示时，才把它变成成员</h3><ul>
<li><p>如果一个函数不需要访问类的内部结构，它就不应该是成员。这样的话，你会得到松耦合，而类的内部结构的改变不会影响辅助函数</p>
</li>
<li><p>运算符 &#x3D;, (), [] 和 -&gt; 必须是类的成员</p>
</li>
</ul>
<h3 id="将辅助函数与它们支持的类放在同一个命名空间中"><a href="#将辅助函数与它们支持的类放在同一个命名空间中" class="headerlink" title="将辅助函数与它们支持的类放在同一个命名空间中"></a>将辅助函数与它们支持的类放在同一个命名空间中</h3><ul>
<li>辅助函数应该在类的命名空间中，因为它是类的接口的一部分。与成员函数相反，辅助函数不需要直接访问类的内部表示。</li>
</ul>
<h3 id="不要在一条语句里定义类或者枚举的同时声明该类型的变量"><a href="#不要在一条语句里定义类或者枚举的同时声明该类型的变量" class="headerlink" title="不要在一条语句里定义类或者枚举的同时声明该类型的变量"></a>不要在一条语句里定义类或者枚举的同时声明该类型的变量</h3><ul>
<li>如果在一条语句里定义类或者枚举同时声明其类型的变量，会引起混淆，因此应该避免</li>
</ul>
<h3 id="如有任何非公开成员，就使用class，而不是struct"><a href="#如有任何非公开成员，就使用class，而不是struct" class="headerlink" title="如有任何非公开成员，就使用class，而不是struct"></a>如有任何非公开成员，就使用class，而不是struct</h3><h3 id="尽量减少成员的暴露"><a href="#尽量减少成员的暴露" class="headerlink" title="尽量减少成员的暴露"></a>尽量减少成员的暴露</h3><ul>
<li>数据隐藏和封装是面向对象类设计的基石之一:你将类中的成员封装起来，只允许通过公共成员函数进行访问。</li>
<li>你的类可能有两种接口<ul>
<li>一种是用于外部的 public 接口</li>
<li>一种是用于派生类的 protected接口。</li>
</ul>
</li>
<li>其余成员都应该属于 private</li>
</ul>
<h3 id="具体类型"><a href="#具体类型" class="headerlink" title="具体类型"></a>具体类型</h3><ul>
<li>具体类型是 最简单的一种类。它常常被称作为值类型，不属于某个类型层次结构的一部分</li>
<li>规范类型是一种 行为类似于int 的类型，因此，它必须支持拷贝和赋值，相等比较，以及可交换。更正式的说法是，一个规范类型X行为上像int，支持下列操作<ul>
<li>默认构造: X()</li>
<li>拷贝构造: X(const X&amp;)</li>
<li>拷贝赋值: operator &#x3D; (const X&amp;)</li>
<li>移动构造: X(X&amp;&amp;)</li>
<li>移动赋值: operator &#x3D; (X&amp;&amp;)</li>
<li>析构: ~X()</li>
<li>交换操作: swap(X&amp;, X&amp;)</li>
<li>相等运算符: operator &#x3D;&#x3D; (const X&amp;, const X&amp;)</li>
</ul>
</li>
</ul>
<h3 id="优先使用具体类型而不是类层次结构"><a href="#优先使用具体类型而不是类层次结构" class="headerlink" title="优先使用具体类型而不是类层次结构"></a>优先使用具体类型而不是类层次结构</h3><ul>
<li>如果没有需要类层次结构的用例，就使用具体类型。具体的类型更容易实现，更小且更快。</li>
<li>不必担心继承，虚性，引用或指针，包括内存分配和释放。不会有虚派发，因此也没有运行期的开销</li>
</ul>
<h3 id="让具体类型规范化"><a href="#让具体类型规范化" class="headerlink" title="让具体类型规范化"></a>让具体类型规范化</h3><ul>
<li>如果你有一个具体类型，可以考虑将它升级为规范类型</li>
<li>内置类型(例如int或者double)是规范类型，而用户定义类型(例如std::string)或容器(std::vector, std::unordered_map)也是如此</li>
</ul>
<h3 id="构造函数-，赋值函数和析构函数"><a href="#构造函数-，赋值函数和析构函数" class="headerlink" title="构造函数 ，赋值函数和析构函数"></a>构造函数 ，赋值函数和析构函数</h3><ul>
<li><p>六个特殊的成员函数，它们控制着对象的生命周期</p>
<ul>
<li>默认构造函数: X()</li>
<li>拷贝构造函数: X(const X&amp;)</li>
<li>拷贝赋值函数: operator &#x3D; (const X&amp;)</li>
<li>移动构造函数: X(X&amp;&amp;)</li>
<li>移动赋值函数: operator &#x3D; (X&amp;&amp;)</li>
<li>析构函数: ~X()</li>
</ul>
</li>
<li><p>编译期可以为这 六大 生成默认实现，但是也可以明确用 &#x3D;default(预置) 来要求编译提供它们，或者使用 &#x3D;delete(预置) 来删除它们</p>
</li>
<li><p>默认构造函数可以在没有参数的情况下被调用，但是它可能每个参数都有默认值</p>
</li>
</ul>
<h3 id="如果能避免定义默认操作，那就这么做"><a href="#如果能避免定义默认操作，那就这么做" class="headerlink" title="如果能避免定义默认操作，那就这么做"></a>如果能避免定义默认操作，那就这么做</h3><ul>
<li><p>这一规则也被称为 零法则。这意味着你可以通过使用有合适的拷贝&#x2F;移动语义类型，来避免自行编写构造函数，拷贝&#x2F;移动构造函数，赋值运算符或者析构函数。</p>
</li>
<li><p>有合适的拷贝&#x2F;移动语义的类型包括规范类型，例如内置类型bool或者double，也包括标准模板库(STL)的容器，例如std::vector或者std::string</p>
</li>
<li><p>当编译器为一个类自动生成拷贝构造函数时，它调用该类的所有成员和所有基类的拷贝构造函数</p>
</li>
</ul>
<h3 id="如果定义或-delete-了任何默认操作，就对所有默认操作都进行定义或-delete"><a href="#如果定义或-delete-了任何默认操作，就对所有默认操作都进行定义或-delete" class="headerlink" title="如果定义或 &#x3D;delete 了任何默认操作，就对所有默认操作都进行定义或 &#x3D;delete"></a>如果定义或 &#x3D;delete 了任何默认操作，就对所有默认操作都进行定义或 &#x3D;delete</h3><ul>
<li>六大 是紧密相关的。由于这种关系，你应该对所有特殊成员函数进行定义或者 &#x3D;delete</li>
</ul>
<h3 id="让默认操作保持一致"><a href="#让默认操作保持一致" class="headerlink" title="让默认操作保持一致"></a>让默认操作保持一致</h3><h3 id="构造函数应当创建完全初始化的对象"><a href="#构造函数应当创建完全初始化的对象" class="headerlink" title="构造函数应当创建完全初始化的对象"></a>构造函数应当创建完全初始化的对象</h3><ul>
<li><p>构造函数的职责就是创建完全初始化的对象。类不应该有init(初始化)成员函数。将成员函数init设为私有，并从所有构造函数中调用它，这样做好一些，但是仍然不是最佳选择。</p>
</li>
<li><p>当一个类的所有构造函数有共同的操作时，请使用委托构造函数.</p>
</li>
<li><p>C++ 委托构造函数是什么<br>C++11引入了委托构造函数的概念，它允许一个构造函数调用同一类中的另一个构造函数，以便避免代码的重复。</p>
</li>
</ul>
<p>具体来说，委托构造函数是通过在成员初始化列表中使用自身类的其他构造函数来实现的。这样可以在一个构造函数中调用另一个构造函数，从而避免重复初始化相同的代码。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 委托构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">MyClass</span>(x, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructing MyClass(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>MyClass</code>有两个构造函数，其中一个是主要构造函数，另一个是委托构造函数。委托构造函数通过调用主要构造函数来初始化对象。</p>
<p>通过委托构造函数，可以在不同的构造函数中共享初始化逻辑，提高代码的可维护性。需要注意的是，委托构造函数的调用必须在成员初始化列表中完成，而不能在构造函数的函数体内。</p>
<h3 id="如果构造函数无法构造出有效对象-则应该抛出异常"><a href="#如果构造函数无法构造出有效对象-则应该抛出异常" class="headerlink" title="如果构造函数无法构造出有效对象,则应该抛出异常"></a>如果构造函数无法构造出有效对象,则应该抛出异常</h3><ul>
<li>如果使用无效的对象,你就总得在使用之前检查对象的状态.这样非常繁琐,低效而且容易出错.</li>
</ul>
<h3 id="确保可拷贝的-值类型-类有默认构造函数"><a href="#确保可拷贝的-值类型-类有默认构造函数" class="headerlink" title="确保可拷贝的(值类型)类有默认构造函数"></a>确保可拷贝的(值类型)类有默认构造函数</h3><ul>
<li>不正式的说，当类的实例缺少有意义的默认值时，该类就不需要默认构造函数</li>
</ul>
<h3 id="不要定义仅初始化数据成员的默认构造函数，而应该使用成员初始化器"><a href="#不要定义仅初始化数据成员的默认构造函数，而应该使用成员初始化器" class="headerlink" title="不要定义仅初始化数据成员的默认构造函数，而应该使用成员初始化器"></a>不要定义仅初始化数据成员的默认构造函数，而应该使用成员初始化器</h3><ul>
<li>在设计新类时遵循的方法是：在类的主体中定义默认行为。明确定义的构造函数只用来改变默认行为</li>
</ul>
<h3 id="默认情况下，把单参数的构造函数声明为explicit"><a href="#默认情况下，把单参数的构造函数声明为explicit" class="headerlink" title="默认情况下，把单参数的构造函数声明为explicit"></a>默认情况下，把单参数的构造函数声明为explicit</h3><ul>
<li>说的更明确一点，一个没有explicit的单参数构造函数是个转换构造函数。</li>
</ul>
<h3 id="按照成员声明的顺序定义和初始化成员变量"><a href="#按照成员声明的顺序定义和初始化成员变量" class="headerlink" title="按照成员声明的顺序定义和初始化成员变量"></a>按照成员声明的顺序定义和初始化成员变量</h3><ul>
<li>类成员是按照它们的声明顺序进行初始化的</li>
<li>类的成员完全按照它们初始化的相反顺序被销毁</li>
</ul>
<h3 id="在使用常量来初始化时，优先选择类内初始化器，而不是构造函数的成员初始化"><a href="#在使用常量来初始化时，优先选择类内初始化器，而不是构造函数的成员初始化" class="headerlink" title="在使用常量来初始化时，优先选择类内初始化器，而不是构造函数的成员初始化"></a>在使用常量来初始化时，优先选择类内初始化器，而不是构造函数的成员初始化</h3><ul>
<li>虽然类内初始化规定了一个对象的默认行为，但是构造函数可以改变这一默认行为。</li>
</ul>
<h3 id="在构造函数里优先使用初始化而不是赋值"><a href="#在构造函数里优先使用初始化而不是赋值" class="headerlink" title="在构造函数里优先使用初始化而不是赋值"></a>在构造函数里优先使用初始化而不是赋值</h3><ul>
<li>初始化对赋值有两个最明显的优点：<ul>
<li>你不会因为忘记赋值而使用未初始化的成员</li>
<li>初始化可能更快，并且绝不会比赋值慢</li>
</ul>
</li>
</ul>
<h3 id="特殊构造函数"><a href="#特殊构造函数" class="headerlink" title="特殊构造函数"></a>特殊构造函数</h3><ul>
<li>从C++11开始，一个构造函数可把它的工作委托给同一个类的另一个构造函数，并且构造函数可从父类继承。</li>
</ul>
<h3 id="使用委托构造函数来表示类的所有构造函数的共同动作"><a href="#使用委托构造函数来表示类的所有构造函数的共同动作" class="headerlink" title="使用委托构造函数来表示类的所有构造函数的共同动作"></a>使用委托构造函数来表示类的所有构造函数的共同动作</h3><ul>
<li>一个构造函数可以把它的工作委托给同一个类的另一个构造函数。委托是C++中把所有构造函数的共同动作放到一个构造函数中的现代方式。</li>
<li>递归调用构造函数是未定义行为。</li>
</ul>
<h3 id="使用继承构造函数将构造函数导入不需要进一步显式初始化的派生类中"><a href="#使用继承构造函数将构造函数导入不需要进一步显式初始化的派生类中" class="headerlink" title="使用继承构造函数将构造函数导入不需要进一步显式初始化的派生类中"></a>使用继承构造函数将构造函数导入不需要进一步显式初始化的派生类中</h3><ul>
<li>如果可以的话，在派生类中重用基类的构造函数。当派生类没有成员时，这种重用的想法很合适。</li>
<li>如果在可重用构造函数时不重用，就违反了DRY(不要重复自己)原则。</li>
<li>继承的构造函数保留了它们在基类中定义的所有特性，例如访问说明符或者属性explicit和constexpr</li>
</ul>
<h3 id="拷贝操作"><a href="#拷贝操作" class="headerlink" title="拷贝操作"></a>拷贝操作</h3><ul>
<li>在拷贝之后(a &#x3D; b)，a 和 b必须相同(a &#x3D;&#x3D; b)</li>
<li>拷贝可深可浅。<ul>
<li>深拷贝意味着对象a和b之后时相互独立的(值语义)</li>
<li>浅拷贝意味着对象a和b之后共享一个对象(引用语义)</li>
</ul>
</li>
</ul>
<h3 id="移动操作"><a href="#移动操作" class="headerlink" title="移动操作"></a>移动操作</h3><ul>
<li>C++标准要求被移动的对象之后必须处于一个未指定但是有效的状态。通常情况下，这个被移动的状态是移动操作源对象的默认状态</li>
</ul>
<h3 id="多态类应当抑制公开的拷贝-移动操作"><a href="#多态类应当抑制公开的拷贝-移动操作" class="headerlink" title="多态类应当抑制公开的拷贝&#x2F;移动操作"></a>多态类应当抑制公开的拷贝&#x2F;移动操作</h3><ul>
<li>多态类是定义或者继承了至少一个虚函数的类</li>
<li>拷贝一个多态类的操作可能会以切片而告终。切片是C++中最黑暗的部分之一<ul>
<li>切片意味着你想在赋值或者初始化过程中拷贝一个对象，但是你只得到该对象的一部分。</li>
</ul>
</li>
</ul>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul>
<li>对象的析构函数会在其生存期结束时被自动调用。更准确地说，对象的析构函数是在对象超出作用域时调用的</li>
</ul>
<h3 id="如果一个类在对象销毁时需要明确的动作，那就定义析构函数"><a href="#如果一个类在对象销毁时需要明确的动作，那就定义析构函数" class="headerlink" title="如果一个类在对象销毁时需要明确的动作，那就定义析构函数"></a>如果一个类在对象销毁时需要明确的动作，那就定义析构函数</h3><ul>
<li>问题在于，在你的情况下，编译器生成的析构函数是否已经够用。<ul>
<li>如果必须在用户定义类型的生存期结束时执行额外的代码，就必须写析构函数。</li>
<li>反过来说，如果类中没有成员需要额外的清理，就没必要定义析构函数</li>
</ul>
</li>
</ul>
<h3 id="类获得的所有资源都必须在该类的析构函数中释放"><a href="#类获得的所有资源都必须在该类的析构函数中释放" class="headerlink" title="类获得的所有资源都必须在该类的析构函数中释放"></a>类获得的所有资源都必须在该类的析构函数中释放</h3><h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><ul>
<li>如果你的类有原始指针或者引用，则必须要回答一个关键问题: 谁是所有者</li>
</ul>
<h3 id="如果类里有原始指针-T-或者引用-，请考虑它是否有所有权"><a href="#如果类里有原始指针-T-或者引用-，请考虑它是否有所有权" class="headerlink" title="如果类里有原始指针(T*)或者引用(&amp;)，请考虑它是否有所有权"></a>如果类里有原始指针(T*)或者引用(&amp;)，请考虑它是否有所有权</h3><ul>
<li>如果一个类有原始指针或者引用，你必须明确所有权问题，因为指针既可以表示所有权，也可以表示借用。</li>
<li>如果所有权不明确，你可能会删除你不拥有的一个对象的指针，也可能会漏删你拥有的一个指针。在第一种情况下，由于双重删除，会有未定义行为；在第二种情况下，会面临内存泄漏</li>
</ul>
<h3 id="如果类具有所有权的指针成员，请定义析构函数"><a href="#如果类具有所有权的指针成员，请定义析构函数" class="headerlink" title="如果类具有所有权的指针成员，请定义析构函数"></a>如果类具有所有权的指针成员，请定义析构函数</h3><ul>
<li>如果类拥有一个对象，它就要负责销毁它，销毁是析构函数的工作。</li>
</ul>
<h3 id="基类的析构函数应该要么是public且virtual，要么是protected且非virtual"><a href="#基类的析构函数应该要么是public且virtual，要么是protected且非virtual" class="headerlink" title="基类的析构函数应该要么是public且virtual，要么是protected且非virtual"></a>基类的析构函数应该要么是public且virtual，要么是protected且非virtual</h3><ul>
<li><p>公开的虚析构函数</p>
<ul>
<li>如果基类有public且virtual的析构函数，你可以通过基类的指针来销毁派生类的实例，引用也是如此。</li>
</ul>
</li>
<li><p>受保护的非虚析构函数</p>
<ul>
<li>如果基类的析构函数是protected，你就不能用基类的指针或者引用来销毁派生对象；因此，析构函数不需要声明为virtual</li>
</ul>
</li>
<li><p>关于基类的析构函数的访问说明符的一些总结性意见</p>
<ul>
<li>如果基类的析构函数私有(private)，你就无法从该类派生</li>
<li>如果基类的析构函数受保护(protected)，那么你能从该类派生出子类，然而只能使用子类</li>
</ul>
</li>
</ul>
<h3 id="如果你需要明确使用默认语义，则使用-default"><a href="#如果你需要明确使用默认语义，则使用-default" class="headerlink" title="如果你需要明确使用默认语义，则使用 &#x3D;default"></a>如果你需要明确使用默认语义，则使用 &#x3D;default</h3><h3 id="当想要禁用默认行为-且不需要替代方法-时使用-delete"><a href="#当想要禁用默认行为-且不需要替代方法-时使用-delete" class="headerlink" title="当想要禁用默认行为(且不需要替代方法)时使用 &#x3D;delete"></a>当想要禁用默认行为(且不需要替代方法)时使用 &#x3D;delete</h3><h3 id="不要在构造函数和析构函数中调用虚函数"><a href="#不要在构造函数和析构函数中调用虚函数" class="headerlink" title="不要在构造函数和析构函数中调用虚函数"></a>不要在构造函数和析构函数中调用虚函数</h3><ul>
<li>在构造函数或析构函数中调用纯虚函数是未定义行为。</li>
</ul>
<h3 id="使-对操作数的类型对称，并使其-noexcept"><a href="#使-对操作数的类型对称，并使其-noexcept" class="headerlink" title="使 &#x3D;&#x3D; 对操作数的类型对称，并使其 noexcept"></a>使 &#x3D;&#x3D; 对操作数的类型对称，并使其 noexcept</h3><ul>
<li>解决不对称的优雅方法是在类中声明一个友元运算符 &#x3D;&#x3D;</li>
<li>示例<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInt</span>(<span class="type">int</span> n) : <span class="built_in">num</span>(n) &#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> MyInt&amp; lhs, <span class="type">const</span> MyInt&amp; rhs) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.num == rhs.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类层次结构"><a href="#类层次结构" class="headerlink" title="类层次结构"></a>类层次结构</h3><ul>
<li><p>什么是类的层次结构？</p>
<ul>
<li>一个类的层次结构代表了一组分层组织的概念。</li>
<li>基类通常有两种用途。一种通常被称为接口继承，另一种是实现继承。</li>
</ul>
</li>
<li><p>接口继承使用公共继承，它把用户和实现分开，允许派生类增加或者改变基类的功能，而不影响基类的用户。</p>
</li>
<li><p>实现继承经常使用私有继承。在典型情况下，派生类通过调整基类的功能来提供其功能。实现继承的一个突出例子是适配器模式，因为你可以用多重继承来实现。适配器模式的想法是将现有的接口改编成一个新的接口。适配器使用了对实现的四有继承和对新接口的公共继承。新的接口使用现有的实现来为用户提供服务。</p>
</li>
</ul>
<h3 id="仅-使用类的层次结构来表达具有内在层次结构的概念"><a href="#仅-使用类的层次结构来表达具有内在层次结构的概念" class="headerlink" title="(仅)使用类的层次结构来表达具有内在层次结构的概念"></a>(仅)使用类的层次结构来表达具有内在层次结构的概念</h3><h3 id="如果基类被当作接口使用，那就把它变成抽象类"><a href="#如果基类被当作接口使用，那就把它变成抽象类" class="headerlink" title="如果基类被当作接口使用，那就把它变成抽象类"></a>如果基类被当作接口使用，那就把它变成抽象类</h3><ul>
<li>抽象类是至少有一个纯虚函数的类。纯虚函数(virtual void function() &#x3D; 0)是必须由派生类实现的函数(除非派生类也是抽象类)。一个抽象类不能被实例化。</li>
<li>抽象类可以为纯虚函数提供一个实现。这样，派生类也可以使用这个实现。</li>
<li>接口通常应该由公共的纯虚函数组成，没有数据成员，并且有默认&#x2F;空的虚析构函数(virtual ~My_interface() &#x3D; default)</li>
</ul>
<h3 id="当需要完全分离接口和实现时，以抽象类作为接口"><a href="#当需要完全分离接口和实现时，以抽象类作为接口" class="headerlink" title="当需要完全分离接口和实现时，以抽象类作为接口"></a>当需要完全分离接口和实现时，以抽象类作为接口</h3><ul>
<li>抽象类的目的就是分离接口和实现。</li>
</ul>
<h3 id="如果要对多态类进行深拷贝，应该使用虚函数clone，而不是公开的拷贝构造-赋值"><a href="#如果要对多态类进行深拷贝，应该使用虚函数clone，而不是公开的拷贝构造-赋值" class="headerlink" title="如果要对多态类进行深拷贝，应该使用虚函数clone，而不是公开的拷贝构造&#x2F;赋值"></a>如果要对多态类进行深拷贝，应该使用虚函数clone，而不是公开的拷贝构造&#x2F;赋值</h3><ul>
<li><p>拷贝一个多态类可能会导致切片问题。为了解决这个问题，应该覆盖一个虚clone函数，让它根据实际类型进行复制并且返回一个到新对象的有所有权的指针(std::unique_ptr)</p>
</li>
<li><p>在派生类里，通过使用所谓的协变返回类型来返回派生类型</p>
<ul>
<li>协变返回类型 : 允许覆盖成员函数返回被覆盖成员函数的返回类型的派生类型。</li>
</ul>
</li>
<li><p>C++ 协变返回类型是什么<br>C++11引入了协变返回类型（Covariant Return Types）的概念，允许在派生类中覆盖基类的虚函数时，返回类型可以是基类函数返回类型的派生类型。</p>
</li>
</ul>
<p>在使用协变返回类型时，你可以在派生类中重新定义虚函数的返回类型，而不必显式使用类型转换。这使得代码更加清晰和类型安全。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::clone()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Base</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 协变返回类型</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived::clone()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base* basePtr = &amp;derived;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用协变返回类型的虚函数</span></span><br><span class="line">    Base* cloned = basePtr-&gt;<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> cloned;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>Derived</code> 类覆盖了基类 <code>Base</code> 的虚函数 <code>clone</code>，并使用协变返回类型，返回的类型是 <code>Derived*</code> 而不是 <code>Base*</code>。这样，通过基类指针调用虚函数时，返回的是正确的派生类型。</p>
<h3 id="不要无缘无故的把函数变成-virtual"><a href="#不要无缘无故的把函数变成-virtual" class="headerlink" title="不要无缘无故的把函数变成 virtual"></a>不要无缘无故的把函数变成 virtual</h3><ul>
<li><p>虚函数不是一个无代价的特性</p>
<ul>
<li>增加了运行时间和对象代码的大小</li>
<li>因为它可以在派生类中被覆盖，它更容易出问题</li>
</ul>
</li>
<li><p>通常情况下，一个类的所有数据成员的访问说明符都相同：所有数据成员要么全部属于public，要么全部属于private</p>
<ul>
<li>如果数据成员上面没有不变式，则用public。使用struct关键字</li>
<li>如果数据成员上有不变式，则用private。使用class关键字。</li>
</ul>
</li>
</ul>
<h3 id="避免无价值的取值和设值函数"><a href="#避免无价值的取值和设值函数" class="headerlink" title="避免无价值的取值和设值函数"></a>避免无价值的取值和设值函数</h3><ul>
<li>如果取值和设值函数没有对数据成员提供额外的语义，它们就没有价值</li>
<li>x和y可以取任意值。这意味着Point的实例并没有对x和y维持一个不变式。x和y仅仅是数值而以，更合适的做法是以struct作为值的集合。</li>
</ul>
<h3 id="避免protected数据"><a href="#避免protected数据" class="headerlink" title="避免protected数据"></a>避免protected数据</h3><ul>
<li><p>protected数据使程序变得复杂且容易出错。如果把protected数据放到基类里，你就不能单独考虑派生类，因而破坏了封装。你会不得不对类的整个层次结构进行思考</p>
<ul>
<li>我必须实现一个构造函数来初始化protected数据吗</li>
<li>如果我使用protected数据，它们的实际价值是什么</li>
<li>如果我修改protected数据，谁会受影响</li>
</ul>
</li>
<li><p>在类层次结构变得越来越复杂的时候，这些问题也会变得越来越难以回答</p>
</li>
<li><p>换句话说，protected数据都是类层次结构范围内的一种全局数据而你知道非const的全局数据不好。</p>
</li>
</ul>
<h3 id="确保所有的非const数据成员都具有相同的访问级别"><a href="#确保所有的非const数据成员都具有相同的访问级别" class="headerlink" title="确保所有的非const数据成员都具有相同的访问级别"></a>确保所有的非const数据成员都具有相同的访问级别</h3><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul>
<li>多重继承有两个典型的使用场景：<ul>
<li>将接口继承和实现继承分开</li>
<li>实现多个不同的接口</li>
</ul>
</li>
</ul>
<h3 id="在设计类的层次结构时，要区分实现继承和接口继承"><a href="#在设计类的层次结构时，要区分实现继承和接口继承" class="headerlink" title="在设计类的层次结构时，要区分实现继承和接口继承"></a>在设计类的层次结构时，要区分实现继承和接口继承</h3><ul>
<li><p>接口继承关注的是接口和实现的分离，这样派生类的修改就可以不影响基类的用户；</p>
</li>
<li><p>实现继承则使用继承来扩展现有的功能，从而支持新功能。</p>
</li>
<li><p>纯接口继承是指你的基类只有纯虚函数。相反，如果你的基类有数据成员，或者已经有函数实现，那就是实现继承了。</p>
</li>
<li><p>不应该把接口继承和实现继承的概念混在一起。我们如何才能两者兼顾：用接口分层的稳定接口，还有实现继承的代码重用？</p>
<ul>
<li>一个可能的答案是双重继承。</li>
<li>另一个答案是PImpl惯用法。</li>
</ul>
</li>
<li><p>PImpl代表指向实现的指针(pointer to implementation)。它把实现的细节放在一个单独的类里，并通过指针来访问。</p>
</li>
</ul>
<h3 id="使用多重继承来表示多个不同的接口"><a href="#使用多重继承来表示多个不同的接口" class="headerlink" title="使用多重继承来表示多个不同的接口"></a>使用多重继承来表示多个不同的接口</h3><h3 id="使用using为派生类及其基类创建重载集"><a href="#使用using为派生类及其基类创建重载集" class="headerlink" title="使用using为派生类及其基类创建重载集"></a>使用using为派生类及其基类创建重载集</h3><h3 id="不要为虚函数和它的覆盖函数提供不同的默认参数"><a href="#不要为虚函数和它的覆盖函数提供不同的默认参数" class="headerlink" title="不要为虚函数和它的覆盖函数提供不同的默认参数"></a>不要为虚函数和它的覆盖函数提供不同的默认参数</h3><ul>
<li>如果你为虚函数和覆盖函数提供不同的默认参数。你的类可能会引发很多混乱</li>
</ul>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><ul>
<li>dynamic_cast的职责说明:<ul>
<li>沿继承层及向上，向下及侧向，安全的转换到其他类的指针和引用</li>
</ul>
</li>
</ul>
<h3 id="在穿越类层次不可避免时，应该使用-dynamic-cast"><a href="#在穿越类层次不可避免时，应该使用-dynamic-cast" class="headerlink" title="在穿越类层次不可避免时，应该使用 dynamic_cast"></a>在穿越类层次不可避免时，应该使用 dynamic_cast</h3><ul>
<li>dynamic_cast的职责就是在类层次中穿越</li>
</ul>
<h3 id="当-找不到所需的类-被视为错误时，须对引用类型使用-dynamic-cast"><a href="#当-找不到所需的类-被视为错误时，须对引用类型使用-dynamic-cast" class="headerlink" title="当 找不到所需的类 被视为错误时，须对引用类型使用 dynamic_cast"></a>当 找不到所需的类 被视为错误时，须对引用类型使用 dynamic_cast</h3><h3 id="当-找不到所需的类-被视为有效选择时，须对指针类型使用-dynamic-cast"><a href="#当-找不到所需的类-被视为有效选择时，须对指针类型使用-dynamic-cast" class="headerlink" title="当 找不到所需的类 被视为有效选择时，须对指针类型使用 dynamic_cast"></a>当 找不到所需的类 被视为有效选择时，须对指针类型使用 dynamic_cast</h3><ul>
<li>简而言之，你可以对一个指针或引用使用 dynamic_cast。</li>
<li>如果 dynamic_cast 失败了，对于指针，你会得到一个空指针，对于引用，则会出现 std::bad_cast 异常。</li>
<li>因此，如果失败是一种有效选择，请对指针使用 dynamic_cast；如果失败不是一个有效选择，那就是用使用</li>
</ul>
<h3 id="永远不要把指向派生类对象数组的指针赋值给指向基类的指针"><a href="#永远不要把指向派生类对象数组的指针赋值给指向基类的指针" class="headerlink" title="永远不要把指向派生类对象数组的指针赋值给指向基类的指针"></a>永远不要把指向派生类对象数组的指针赋值给指向基类的指针</h3><ul>
<li><p>其结果可能是无效对象访问或者内存破坏</p>
</li>
<li><p>退化，是一种隐式转换的名称，它进行左值到右值，数组到指针以及函数到指针的转换，并去除const和volatile限定。</p>
</li>
</ul>
<h3 id="重载和运算符重载"><a href="#重载和运算符重载" class="headerlink" title="重载和运算符重载"></a>重载和运算符重载</h3><ul>
<li>你可以对函数，成员函数，模板函数和运算符进行重载。你不能重载函数对象，因此你也不能重载lambda表达式。</li>
<li>重载和重载运算符的七条规则遵循一个关键思想：为用户构建直观的软件系统。</li>
</ul>
<h3 id="应当对带有常规含义的操作使用运算符"><a href="#应当对带有常规含义的操作使用运算符" class="headerlink" title="应当对带有常规含义的操作使用运算符"></a>应当对带有常规含义的操作使用运算符</h3><ul>
<li>常规意义暗示着，你应当使用合适的运算符。举例来说：<ul>
<li>&#x3D;&#x3D;, !&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D; : 比较操作</li>
<li>+, -, *, &#x2F;, % : 算术操作</li>
<li>-&gt;, 一元*, [] : 对象访问</li>
<li>&#x3D; : 对象赋值</li>
<li>&lt;&lt;, &gt;&gt; : 输入和输出操作</li>
</ul>
</li>
</ul>
<h3 id="对于对称的运算符，应采用非成员函数"><a href="#对于对称的运算符，应采用非成员函数" class="headerlink" title="对于对称的运算符，应采用非成员函数"></a>对于对称的运算符，应采用非成员函数</h3><h3 id="避免隐式转换运算符"><a href="#避免隐式转换运算符" class="headerlink" title="避免隐式转换运算符"></a>避免隐式转换运算符</h3><h3 id="重载的操作应当大致等价"><a href="#重载的操作应当大致等价" class="headerlink" title="重载的操作应当大致等价"></a>重载的操作应当大致等价</h3><h2 id="仅对大致等价的操作进行重载"><a href="#仅对大致等价的操作进行重载" class="headerlink" title="仅对大致等价的操作进行重载"></a>仅对大致等价的操作进行重载</h2><ul>
<li>等价的操作应该有相同的名字。</li>
</ul>
<h3 id="在操作数所在的命名空间中定义重载运算符"><a href="#在操作数所在的命名空间中定义重载运算符" class="headerlink" title="在操作数所在的命名空间中定义重载运算符"></a>在操作数所在的命名空间中定义重载运算符</h3><ul>
<li>实参依赖查找(ADL,也叫Koenig查找)意味着，对于无限定的(unqualified)函数调用，C++在编译时会把函数参数命令空间中的函数也考虑进去。</li>
<li>对于运算符，C++编译时也考虑操作数的命名空间。因此，应该在操作数的命名空间中定义重载运算符。</li>
</ul>
<h3 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h3><ul>
<li>联合体是一种特殊的类类型。所有成员都从同一地址开始。一个联合体一次只能容纳一个类型：因此你可以节约内存。</li>
<li>一个带标签联合体(又称可辨识联合体)是一个可以跟踪其类型的联合体。std::variant就是一个带标签联合体。</li>
<li>C++ Core Guidelines指出，联合体的职责是节约内存。你不应该使用裸联合体，而应该使用std::variant这样的带标签联合体。</li>
</ul>
<h3 id="使用union来节约内存"><a href="#使用union来节约内存" class="headerlink" title="使用union来节约内存"></a>使用union来节约内存</h3><h3 id="避免裸联合体"><a href="#避免裸联合体" class="headerlink" title="避免裸联合体"></a>避免裸联合体</h3><ul>
<li>裸联合体非常容易出错，因为你必须跟踪底层类型。</li>
</ul>
<h3 id="使用匿名union来实现带标签联合体"><a href="#使用匿名union来实现带标签联合体" class="headerlink" title="使用匿名union来实现带标签联合体"></a>使用匿名union来实现带标签联合体</h3><h3 id="本章精华-2"><a href="#本章精华-2" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>尽量使用具体类型而不是类的层次结构。让你的具体类型称为规范类型。规范类型支持六大(默认构造函数，析构函数，拷贝和移动构造函数，拷贝和移动赋值运算符)，交换函数和相等运算符。</li>
<li>如果可能的话，就让编译器生成这六大。如果不能，就通过default请求所有这些特殊成员函数。如果这也不行，就明确实现所有这些函数，并给它们一个一致的设计。拷贝构造函数或拷贝赋值运算符应该拷贝构造。移动构造函数或移动赋值运算符应该移动。</li>
<li>构造函数应该返回一个完全初始化的对象。使用构造函数来建立不变式。(不变式(invariant),是一个在程序执行过程中永远保持成立的条件。不变式在检测程序是否正确方面非常有用。例如编译器优化就用到了不变式)。不要使用构造函数来设置成员的默认值。尽量使用类内初始化来减少重复。</li>
<li>如果你需要在对象销毁时进行清理动作，请实现析构函数。基类的析构函数应该要么是public且virtual，要么是protected且不是虚函数</li>
<li>要对具有内在层次的结构使用类的层次结构进行建模。如果基类作为一个接口使用，就让基类成为抽象类，以便分离接口和实现。一个抽象类应该只有一个预置的默认构造函数</li>
<li>区分接口继承和实现继承。接口继承的目的是将用户与实现分隔开：实现继承是为了重用现有的实现。不要在一个类中混合这两个概念。</li>
<li>在一个有虚函数的类里，析构函数应该要么是public加virtual，要么是protected。对于一个虚函数，要使用virtual override或者final中的一个，不多也不少。</li>
<li>一个类的数据成员应该要么全部public，要么全部private。如果类建立了一个不变式，就让它们全部private，并使用class。如果不是，就让他们public，并使用struct</li>
<li>把单参数构造函数和转化运算符标记为explicit</li>
<li>使用联合体来节约内存，但不要使用裸联合体；尽量使用带标签联合体，例如C++17中的std::variant</li>
</ul>
<h2 id="第六章-枚举"><a href="#第六章-枚举" class="headerlink" title="第六章 枚举"></a>第六章 枚举</h2><ul>
<li>枚举用来定义整数值的集合，也是这类集合的类型</li>
<li>优先选择有作用域枚举(scopted enumeration)，而不是传统的枚举。有作用域枚举也被称为强类型枚举或枚举类(enum class)</li>
<li>传统的枚举有什么缺陷？<ul>
<li>没有作用域</li>
<li>会隐式转换为int</li>
<li>会污染全局命令空间</li>
<li>类型未知。只要求该类型足够大且能容下所有枚举向</li>
</ul>
</li>
</ul>
<h3 id="优先使用枚举而不是宏"><a href="#优先使用枚举而不是宏" class="headerlink" title="优先使用枚举而不是宏"></a>优先使用枚举而不是宏</h3><ul>
<li>宏没有作用域，且没有类型</li>
</ul>
<h3 id="使用枚举表示相关联的具名常量的集合"><a href="#使用枚举表示相关联的具名常量的集合" class="headerlink" title="使用枚举表示相关联的具名常量的集合"></a>使用枚举表示相关联的具名常量的集合</h3><h3 id="优先使用-enum-class-而不是普通enum"><a href="#优先使用-enum-class-而不是普通enum" class="headerlink" title="优先使用 enum class,而不是普通enum"></a>优先使用 enum class,而不是普通enum</h3><ul>
<li>有作用域枚举项(enum class)不会自动转型为int。要访问它们，就必须要使用作用域运算符</li>
</ul>
<h3 id="不要对枚举项使用ALL-CAPS命令方式"><a href="#不要对枚举项使用ALL-CAPS命令方式" class="headerlink" title="不要对枚举项使用ALL_CAPS命令方式"></a>不要对枚举项使用ALL_CAPS命令方式</h3><ul>
<li>如果对枚举项使用ALL_CAPS(全大写加下划线)，你可能会与宏发生冲突，因为宏通常写成ALL_CAPS的方式</li>
<li>当然，这条规则不仅适用于枚举项，也适用于一般常量</li>
</ul>
<h3 id="避免使用无名枚举"><a href="#避免使用无名枚举" class="headerlink" title="避免使用无名枚举"></a>避免使用无名枚举</h3><ul>
<li>不是每个编译期常量都应该是enum。C++还允许将编译期常量定义为constexpr变量。只是互相关联的常量集合中使用enum</li>
</ul>
<h3 id="仅在必要时指定枚举的底层类型"><a href="#仅在必要时指定枚举的底层类型" class="headerlink" title="仅在必要时指定枚举的底层类型"></a>仅在必要时指定枚举的底层类型</h3><ul>
<li>从C++11开始，可以指定枚举的底层类型，以节省内存。默认情况下，有作用域enum的类型是int，因此，可以前置声明enum</li>
</ul>
<h3 id="仅在必要时指定枚举项的值"><a href="#仅在必要时指定枚举项的值" class="headerlink" title="仅在必要时指定枚举项的值"></a>仅在必要时指定枚举项的值</h3><ul>
<li>通过指定枚举项的值，你可能会设定一个值两次</li>
</ul>
<h3 id="本章精华-3"><a href="#本章精华-3" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>使用有作用域枚举而不是传统的枚举。顾名思义，有作用域枚举具有作用域，不会隐式地转换为int，不会污染全局命名空间，默认情况下其底层类型是int</li>
<li>仅在必要时指定有作用域枚举的底层类型和枚举项的值</li>
</ul>
<h2 id="第七章-资源管理"><a href="#第七章-资源管理" class="headerlink" title="第七章 资源管理"></a>第七章 资源管理</h2><ul>
<li><p>首先，资源是什么？资源就是你必须管理的东西。这意味着，你因为资源的有限而必须获取和释放它，或者你必须对它进行保护。</p>
</li>
<li><p>你拥有的存储空间，套接字，进程或线程都是有限的；而在某个时间点上，只有一个进程可以写入共享文件，只有一个线程可以写入共享变量。</p>
</li>
<li><p>如果考虑到资源管理，一切都可以归结为一个关键点: 所有权。现代C++非常优秀的一点是，我们可以在代码中直接表达对所有权的意图。</p>
<ul>
<li>局部对象: C++运行时作为所有者来自动管理这些资源的生存期。全局对象或类的成员也是如此。C++ Core Guidelines中将它们称为有作用域的对象。</li>
<li>引用: 我不是所有者。我仅仅借用了不可以为空的资源</li>
<li>原始指针: 我不是所有者。我仅仅借用了可能为空的资源。我不可以删除该资源。</li>
<li>std::unique_ptr: 我是资源的独占所有者。我可以显式的释放资源。</li>
<li>std::shared_ptr: 我跟其他的shared_ptr共享资源，并且当我是最后一名所有者时会释放资源。我可以显式地释放我的所有权份额</li>
<li>std::weak_ptr: 我不是该资源的所有者，但是我可以通过使用成员函数lock()暂时称为该资源的共享所有者。</li>
</ul>
</li>
<li><p>第一条通用规则是 C++惯用法: RAII。RAII代表Resource Acquisition Is Initialization(资源获取即初始化)。C++标准库系统性地依赖于RAII</p>
</li>
</ul>
<h3 id="使用资源句柄和RAII-资源获取即初始化-自动管理资源"><a href="#使用资源句柄和RAII-资源获取即初始化-自动管理资源" class="headerlink" title="使用资源句柄和RAII(资源获取即初始化)自动管理资源"></a>使用资源句柄和RAII(资源获取即初始化)自动管理资源</h3><ul>
<li>RAII的理念很简单，你为资源创建一种代理对象。代理的构造函数获取资源，而代理的析构函数释放资源。RAII的中心思想是，这个代理作为局部对象，其所有者是C++运行时，于是，它所代理的资源也归C++运行时所有。当作为本地对象的嗲里对象离开作用域的时候，代理的析构函数会被自动调用。</li>
<li>RAII在C++生态系统中被大量使用。RAII的例子有标准模板库(STL)的容器，智能指针和锁。<ul>
<li>容器管理元素</li>
<li>智能指针管理内存</li>
<li>锁管理互斥量</li>
</ul>
</li>
</ul>
<h3 id="原始指针-T-不表示所有权"><a href="#原始指针-T-不表示所有权" class="headerlink" title="原始指针(T*)不表示所有权"></a>原始指针(T*)不表示所有权</h3><h3 id="原始引用-T-不表示所有权"><a href="#原始引用-T-不表示所有权" class="headerlink" title="原始引用(T&amp;)不表示所有权"></a>原始引用(T&amp;)不表示所有权</h3><ul>
<li>这两条规则都概括了向函数传递指针或引用时，以及要从函数返回指针(T*)或者左值引用(T&amp;)时所有权方面需要考量的规则。</li>
<li>指针和引用的关键问题是，谁是资源的所有者？<ul>
<li>如果你不是所有者，只是借用了它，那你不得删除该资源</li>
</ul>
</li>
</ul>
<h3 id="优先使用有作用域的对象，不做非必要的堆上分配"><a href="#优先使用有作用域的对象，不做非必要的堆上分配" class="headerlink" title="优先使用有作用域的对象，不做非必要的堆上分配"></a>优先使用有作用域的对象，不做非必要的堆上分配</h3><ul>
<li><p>有作用于的对象是一个带有自己作用域的对象。它可能是个本地对象，全局对象或者某个类的成员。</p>
</li>
<li><p>C++运行时会管理好有作用域的对象</p>
</li>
<li><p>一种好用的技巧是使用额外的花括号来定义一个人工作用域。由于人工作用域的存在，你可以显式地控制一个本地对象的生存期。</p>
</li>
</ul>
<h3 id="内存分配和释放"><a href="#内存分配和释放" class="headerlink" title="内存分配和释放"></a>内存分配和释放</h3><ul>
<li>在C++中使用new创建一个对象的操作包括两个步骤<ul>
<li>为该对象分配内存</li>
<li>在分配好的内存上构造该对象</li>
</ul>
</li>
<li>operator new 或 operator new []是第一步；构造函数是第二步</li>
<li>同样的策略也适用于析构函数，不过得反过来。<ul>
<li>首先，调用析构函数(如果有的话)，</li>
<li>然后用operator delete或者operator delete []释放内存</li>
</ul>
</li>
</ul>
<h3 id="避免malloc-和-free"><a href="#避免malloc-和-free" class="headerlink" title="避免malloc() 和 free()"></a>避免malloc() 和 free()</h3><ul>
<li>new 和 malloc，或 delete 和 free 之间有什么区别？<ul>
<li>C 函数malloc 和 free只做了一半的工作。malloc 分配内存，free则释放内存</li>
<li>malloc并不调用构造函数，而free也不调用析构函数</li>
</ul>
</li>
<li>这意味着，你如果使用一个仅仅通过malloc创建的对象，程序有未定义行为</li>
</ul>
<h3 id="避免显式调用-new-和-delete"><a href="#避免显式调用-new-和-delete" class="headerlink" title="避免显式调用 new 和 delete"></a>避免显式调用 new 和 delete</h3><ul>
<li>你应该牢记这条规则。这条规则的重点在于显式这个词，因为智能指针或STL容器会让你的对象隐式地使用 new 和 delete</li>
</ul>
<h3 id="立即将显式资源分配的结果交给一个管理者对象"><a href="#立即将显式资源分配的结果交给一个管理者对象" class="headerlink" title="立即将显式资源分配的结果交给一个管理者对象"></a>立即将显式资源分配的结果交给一个管理者对象</h3><ul>
<li>这条内存分配规则有一个特殊的名字: NNN.NNN是 No Naked New(不要裸的New)的缩写，它意味着内存分配的结果应该交给一个管理者对象。这个管理者对象可以是std::unique_ptr或者std::shared_ptr</li>
</ul>
<h3 id="在一条表达式语句中最多进行一次显式资源分配"><a href="#在一条表达式语句中最多进行一次显式资源分配" class="headerlink" title="在一条表达式语句中最多进行一次显式资源分配"></a>在一条表达式语句中最多进行一次显式资源分配</h3><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ul>
<li>从库的角度，智能指针是C++11标准中最重要的补充。</li>
<li>智能指针的规则归结为两类<ul>
<li>作为所有者的基本用法</li>
<li>以及作为函数参数的基本用法</li>
</ul>
</li>
</ul>
<h3 id="用unique-ptr或shared-ptr表示所有权"><a href="#用unique-ptr或shared-ptr表示所有权" class="headerlink" title="用unique_ptr或shared_ptr表示所有权"></a>用unique_ptr或shared_ptr表示所有权</h3><ul>
<li><p>为了全面，这条规则还包括std::weak_pte。现代C++共有三种智能指针来表达三种不同的所有权</p>
<ul>
<li>std::unique_ptr: 独占所有者</li>
<li>std::shared_ptr: 共享所有者</li>
<li>std::weak_ptr: 对std::shared所管理资源的非占有的引用</li>
</ul>
</li>
<li><p>std::unique_ptr是其资源的独占所有者。它不可以被拷贝，只能被移动</p>
</li>
<li><p>std::shared_ptr则共享所有权。当你拷贝或者拷贝赋值某个共享指针，它的引用计数增加；当你删除或者重置某个共享指针，它的引用计数则减少。当引用计数变为0时，其底层资源将被删除。</p>
</li>
<li><p>std::weak_ptr并不是智能指针。它是一个引用，引用指向被std::shared_ptr所管理的对象。它的接口颇为有限，不可以透明地访问底层资源。通过对std::weak_ptr调用其成员函数lock，可以从某个std::weak_ptr创建出一个std::shared_ptr</p>
</li>
</ul>
<h3 id="除非需要共享所有权，否则能用unique-ptr就别用std-shared-ptr"><a href="#除非需要共享所有权，否则能用unique-ptr就别用std-shared-ptr" class="headerlink" title="除非需要共享所有权，否则能用unique_ptr就别用std::shared_ptr"></a>除非需要共享所有权，否则能用unique_ptr就别用std::shared_ptr</h3><ul>
<li>当你需要智能指针的时候，应该首选std::unique_ptr。在设计上std::unique_ptr和原始指针一样块，且一样可以高效利用内存。</li>
<li>不要为了做拷贝而贪图方便地使用std::shared_ptr。std::unique_ptr不可以被拷贝，但仍可以被移动</li>
</ul>
<h3 id="使用make-shared-创建shared-ptr"><a href="#使用make-shared-创建shared-ptr" class="headerlink" title="使用make_shared()创建shared_ptr"></a>使用make_shared()创建shared_ptr</h3><h3 id="使用make-unique-创建unique-ptr"><a href="#使用make-unique-创建unique-ptr" class="headerlink" title="使用make_unique()创建unique_ptr"></a>使用make_unique()创建unique_ptr</h3><ul>
<li>使用这种方式创建智能指针，有两个理由<ul>
<li>第一个理由是异常安全</li>
<li>第二个理由只对std::shared_ptr成立<ul>
<li>当你调用std::shared_ptr<int>(new int(1998))时，会发生两次内存分配：一次时针对new int(1998)，还有一次是针对std::shared_ptr的控制块。内存分配代价较高，所以你应当尽量避免。</li>
<li>std::make_shared<int>(1998)可将两次内存分配变成一次，因此更快。</li>
<li>此外，分配出来的对象(new int(1998))和控制块彼此相邻，所以访问也会更快。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用std-weak-ptr来打破shared-ptr形成的环"><a href="#使用std-weak-ptr来打破shared-ptr形成的环" class="headerlink" title="使用std::weak_ptr来打破shared_ptr形成的环"></a>使用std::weak_ptr来打破shared_ptr形成的环</h3><ul>
<li>如果std::shared_ptr互相引用，就会形成环状引用</li>
<li>例如，一个双向连表就会形成环。如果使用std::shared_ptr来实现链表，那引用计数永远不会为零，最终导致内存泄漏</li>
</ul>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul>
<li><p>本节其余规则回答了这样几个问题</p>
<ul>
<li>函数该如何接受智能指针作为参数</li>
<li>参数应该是std::unique_ptr还是std::shared_ptr</li>
<li>参数应该以const还是以引用的方式获取</li>
</ul>
</li>
<li><p>你应该将这些以智能指针作为函数参数的规则看作之前更一般函数参数传递规则的细化</p>
</li>
<li><p>首先，必须回答何时以智能指针作为函数参数</p>
</li>
<li><p>其次，如果函数通过引用来获取参数，会带来危险</p>
</li>
</ul>
<h3 id="只在显式表达生存期语义时以智能指针作参数"><a href="#只在显式表达生存期语义时以智能指针作参数" class="headerlink" title="只在显式表达生存期语义时以智能指针作参数"></a>只在显式表达生存期语义时以智能指针作参数</h3><ul>
<li><p>如果你把指针指针作为参数传递给一个函数，而在这个函数中，你只使用智能指针的底层资源，你就做错了。</p>
</li>
<li><p>在这种情况下，应该以原始指针或引用作为函数参数，因为你并不需要智能指针的生存期语义</p>
</li>
<li><p>重装(reset)表示函数会修改引用参数的智能指针的内容，来指向一个不同的对象。</p>
</li>
<li><p>关于类型为std::shared_ptr的参数，有三条规则</p>
<ul>
<li>接受shared_ptr<widget>参数以表达函数是共享的所有者</li>
<li>接受shared_ptr<widget>&amp;参数以表达函数可能会重装共享指针</li>
<li>接受const shared_ptr<widget>&amp;参数以表达函数可能保有指向对象的一份引用计数</li>
</ul>
</li>
</ul>
<h3 id="不要传递从智能指针别名中获得的指针或引用"><a href="#不要传递从智能指针别名中获得的指针或引用" class="headerlink" title="不要传递从智能指针别名中获得的指针或引用"></a>不要传递从智能指针别名中获得的指针或引用</h3><ul>
<li>智能指针的别名(智能指针的引用)是智能指针，但你不是所有者。如果违反这条规则，会造成悬空指针</li>
<li>更为直白的规则：只有当你实际持有共享资源所有权的一部分时，你才可以访问该资源</li>
</ul>
<h3 id="本章精华-4"><a href="#本章精华-4" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>要自动管理资源。为资源创建某种代理对象。代理的构造函数获取资源，而代理的析构函数释放资源。C++运行时会管理好代理</li>
<li>尽可能使用有作用域的对象。有作用域的对象是一个带有自己作用域的对象。它可能是个本地对象，全局对象，或者是某个类的成员。C++运行时会管理好有作用域的对象。</li>
<li>不要使用malloc和free，并避免使用new和delete。立即将显式资源分配的结果交给一个管理者对象，例如std::unique_ptr或std::shared_ptr</li>
<li>使用智能指针std::unique_ptr来表达独占所有权，并使用智能指针std::shared_ptr来表达共享所有权。使用std::make_unique来创建std::unique_ptr，并使用std::make_shared来创建std::shared_ptr</li>
<li>如果你要表达生存期语义，就以智能指针作为函数参数。否则，用普通指针或引用即可</li>
<li>按值接受智能指针作为函数参数以表达所有权语义；按引用接受智能指针以表达函数可能会重装智能指针。</li>
</ul>
<h2 id="第八章-表达式和语句"><a href="#第八章-表达式和语句" class="headerlink" title="第八章 表达式和语句"></a>第八章 表达式和语句</h2><ul>
<li><p>表达式和语句是表达动作和计算的最基本和最直接的方式</p>
</li>
<li><p>表达式和语句的非正式定义</p>
<ul>
<li>表达式的计算结果为值</li>
<li>语句做某事，通常由表达式或语句组成</li>
</ul>
</li>
<li><p>包含在块作用域中的声明是语句。块作用域是指包含在花括号内的内容</p>
</li>
</ul>
<h3 id="优先使用标准库，而不是其他库和-手工代码"><a href="#优先使用标准库，而不是其他库和-手工代码" class="headerlink" title="优先使用标准库，而不是其他库和 手工代码"></a>优先使用标准库，而不是其他库和 手工代码</h3><ul>
<li>如果你想提高组织中的代码质量，那就用一个目标取代所有的编码规则：用算法代替原始循环。</li>
</ul>
<h3 id="优先使用合适的抽象，而非直接使用语言特性"><a href="#优先使用合适的抽象，而非直接使用语言特性" class="headerlink" title="优先使用合适的抽象，而非直接使用语言特性"></a>优先使用合适的抽象，而非直接使用语言特性</h3><ul>
<li>合适的抽象通常意味着不必考虑资源的所有权</li>
</ul>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul>
<li><p>首先，以下是C++ Core Guidelines对声明的定义</p>
<ul>
<li>声明是一条语句。声明将名字引入作用域中，并可能引起具名对象的构造。</li>
</ul>
</li>
<li><p>声明的规则是关于名字，变量及其初始化以及宏的规则</p>
</li>
<li><p>好名字可能是号软件最重要的规则</p>
</li>
</ul>
<h3 id="保持作用域较小"><a href="#保持作用域较小" class="headerlink" title="保持作用域较小"></a>保持作用域较小</h3><ul>
<li>如果作用域很小，你可以把它放在一屏之中以便弄清楚状况。如果作用域变得太大，则应该将代码结构化为函数或类。在重构过程中，要时别逻辑实体并使用自解释的名称。</li>
</ul>
<h3 id="在-for-语句的初始化和条件中声明名字以限制作用域"><a href="#在-for-语句的初始化和条件中声明名字以限制作用域" class="headerlink" title="在 for 语句的初始化和条件中声明名字以限制作用域"></a>在 for 语句的初始化和条件中声明名字以限制作用域</h3><ul>
<li>自第一个C++标准开始，就可以在for语句中声明变量</li>
<li>自C++17以来，我们还可以在if或switch语句中声明变量</li>
</ul>
<h3 id="常用的和局部的名字要短，不常用的和非局部的名字要长"><a href="#常用的和局部的名字要短，不常用的和非局部的名字要长" class="headerlink" title="常用的和局部的名字要短，不常用的和非局部的名字要长"></a>常用的和局部的名字要短，不常用的和非局部的名字要长</h3><ul>
<li><p>给变量起名i或j，或给变量起名T，其意图立即明确</p>
<ul>
<li>i和j是索引</li>
<li>T是模板参数的类型</li>
</ul>
</li>
<li><p>名字应该是自解释的。在简短的上下文中，你一眼就能够理解变量的含义。但它不会自动适用于较长的上下文，这时，应该使用更长的名字</p>
</li>
</ul>
<h3 id="避免看起来相似的名字"><a href="#避免看起来相似的名字" class="headerlink" title="避免看起来相似的名字"></a>避免看起来相似的名字</h3><h3 id="避免ALL-CAPS风格的名字"><a href="#避免ALL-CAPS风格的名字" class="headerlink" title="避免ALL_CAPS风格的名字"></a>避免ALL_CAPS风格的名字</h3><ul>
<li>如果使用了ALL_CAPS(全大写加下划线)风格的名字，宏替换可能会发生，因为ALL_CAPS常常用于宏</li>
</ul>
<h3 id="每条声明-仅-声明一个名字"><a href="#每条声明-仅-声明一个名字" class="headerlink" title="每条声明(仅)声明一个名字"></a>每条声明(仅)声明一个名字</h3><h3 id="使用auto来避免类型名字的多余重复"><a href="#使用auto来避免类型名字的多余重复" class="headerlink" title="使用auto来避免类型名字的多余重复"></a>使用auto来避免类型名字的多余重复</h3><ul>
<li>如果你使用auto，修改代码可能就是小菜一碟</li>
</ul>
<h3 id="不要在嵌套作用域中复用名字"><a href="#不要在嵌套作用域中复用名字" class="headerlink" title="不要在嵌套作用域中复用名字"></a>不要在嵌套作用域中复用名字</h3><ul>
<li>出于可读性和可维护性原因，不应在嵌套作用域中复用名字。</li>
</ul>
<h3 id="始终初始化对象"><a href="#始终初始化对象" class="headerlink" title="始终初始化对象"></a>始终初始化对象</h3><ul>
<li>使用auto，这样，你再也不会忘记初始化变量。</li>
</ul>
<h3 id="不要在确实需要使用变量-或常量-之前就将其引入"><a href="#不要在确实需要使用变量-或常量-之前就将其引入" class="headerlink" title="不要在确实需要使用变量(或常量)之前就将其引入"></a>不要在确实需要使用变量(或常量)之前就将其引入</h3><h3 id="在获得可用来初始化变量的值之前不要声明变量。"><a href="#在获得可用来初始化变量的值之前不要声明变量。" class="headerlink" title="在获得可用来初始化变量的值之前不要声明变量。"></a>在获得可用来初始化变量的值之前不要声明变量。</h3><h3 id="优先使用-初始化语法"><a href="#优先使用-初始化语法" class="headerlink" title="优先使用{}初始化语法"></a>优先使用{}初始化语法</h3><ul>
<li><p>使用 {} 初始化的原因有很多</p>
<ul>
<li>始终可用</li>
<li>克服最令人烦恼的解析</li>
<li>放置窄化转换</li>
</ul>
</li>
<li><p>前两点使C++更符合直觉，而最后一点经常可以防止未定义行为。</p>
</li>
<li><p>利用auto进行类型推导</p>
<ul>
<li>如果你用auto进行自动类型推导，然后结合使用{}初始化，你会得到std::initializer_list。</li>
<li>这种违反直觉的行为在C++17中改掉了</li>
</ul>
</li>
<li><p>窄化转换是指算术值的隐式转换，精度损失也包含在内。</p>
</li>
</ul>
<h3 id="不要将同一个变量用于两个不相关的目的"><a href="#不要将同一个变量用于两个不相关的目的" class="headerlink" title="不要将同一个变量用于两个不相关的目的"></a>不要将同一个变量用于两个不相关的目的</h3><h3 id="使用lambda表达式进行复杂的初始化-尤其是对const变量"><a href="#使用lambda表达式进行复杂的初始化-尤其是对const变量" class="headerlink" title="使用lambda表达式进行复杂的初始化(尤其是对const变量)"></a>使用lambda表达式进行复杂的初始化(尤其是对const变量)</h3><ul>
<li><p>为什么要就地(in place)调用lambda函数？</p>
<ul>
<li>这条规则回答了这个问题。可以把复杂的初始化步骤放在lambda里。</li>
<li>如果你的变量应该变成const，那么lambda的就地调用尤其有价值</li>
</ul>
</li>
<li><p>如果不想在初始化后修改你的变量，则应该让他成为const。但有时，变量的初始化包括不止一个步骤，因此，你不能使变量称为const</p>
</li>
<li><p>这个时候，lambda表达式就可以用来救场了。你可以使用一种技术，它被称为立即调用的lambda表达式。</p>
<ul>
<li>你可以把初始化代码放到lambda表达式中，通过引用捕获环境变量，用就地调用的lambda函数初始化你的const变量。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> widget x = [&amp;]&#123;</span><br><span class="line">  widget val;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">2</span>; i &lt;= N; ++i&gt;)</span><br><span class="line">  &#123;</span><br><span class="line">    val += some_obj.<span class="built_in">do_something_with</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></li>
<li>你需要把整个初始化代码都放在lambda的函数体中，最后一对圆括号调用了它。</li>
</ul>
</li>
</ul>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul>
<li>如果C++标准化委员会中有一个共识，那就是宏必须被淘汰。</li>
</ul>
<h3 id="避免复杂的表达式"><a href="#避免复杂的表达式" class="headerlink" title="避免复杂的表达式"></a>避免复杂的表达式</h3><h3 id="如果对运算符优先级不确定，那就使用括号"><a href="#如果对运算符优先级不确定，那就使用括号" class="headerlink" title="如果对运算符优先级不确定，那就使用括号"></a>如果对运算符优先级不确定，那就使用括号</h3><h3 id="保持指针的使用简单明了"><a href="#保持指针的使用简单明了" class="headerlink" title="保持指针的使用简单明了"></a>保持指针的使用简单明了</h3><ul>
<li>对指针的复杂操纵是错误的一个主要来源</li>
</ul>
<h3 id="避免-魔法常量，采用符号常量"><a href="#避免-魔法常量，采用符号常量" class="headerlink" title="避免 魔法常量，采用符号常量"></a>避免 魔法常量，采用符号常量</h3><ul>
<li>符号常量比魔法常量更明确</li>
</ul>
<h3 id="避免对范围检查的需要"><a href="#避免对范围检查的需要" class="headerlink" title="避免对范围检查的需要"></a>避免对范围检查的需要</h3><ul>
<li>如果不需要检查范围的长度，你就不会遇到 差一错误(off-by-one error)<ul>
<li>一种常见的安全编码错误，指边界条件写错造成的循环次数差一的错误。最常见的原因是不小心把 &lt; 和 &lt;&#x3D; 写错了</li>
</ul>
</li>
</ul>
<h4 id="使用nullptr-而不是0或者NULL"><a href="#使用nullptr-而不是0或者NULL" class="headerlink" title="使用nullptr 而不是0或者NULL"></a>使用nullptr 而不是0或者NULL</h4><ul>
<li><p>为什么不应该使用0或NULL来表示空指针</p>
<ul>
<li>0 ： 字面量0可以是空指针(void*)0，也可以是数字0。这由上下文决定，因此，起初是空指针的东西，最后可能变成数字</li>
<li>NULL ： NULL是一个宏，因此你不知道里面是什么</li>
</ul>
</li>
<li><p>空指针nullptr避免了数字0和宏NULL的歧义。nullptr的类型会一直是std::nullptr_t。</p>
</li>
<li><p>你可以将nullptr赋值给任意一个指针，该指针就会变空，不指向任何数据。</p>
</li>
<li><p>nullptr可以显式的或基于上下文转换为bool类型。因此，你可以在逻辑表达式中使用nullptr。</p>
</li>
</ul>
<h3 id="用delete-删除数组，用delete删除非数组对象"><a href="#用delete-删除数组，用delete删除非数组对象" class="headerlink" title="用delete[]删除数组，用delete删除非数组对象"></a>用delete[]删除数组，用delete删除非数组对象</h3><ul>
<li>手工内存管理，以及不使用STL的容器或智能指针(std:unique_ptr&lt;X[]&gt;)是非常容易出错的</li>
<li>用非数组形式的delete来删除C数组是未定义行为</li>
</ul>
<h3 id="不要对无效指针解引用"><a href="#不要对无效指针解引用" class="headerlink" title="不要对无效指针解引用"></a>不要对无效指针解引用</h3><ul>
<li>如果你对一个无效指针解引用，你的程序就会出现未定义行为。避免这种行为的唯一方法是在使用指针之前检查它</li>
<li>如何解决此问题<ul>
<li>不要使用裸指针。</li>
<li>如果需要像指针的语义，请使用智能指针</li>
</ul>
</li>
</ul>
<h3 id="避免有未定义求值顺序的表达式"><a href="#避免有未定义求值顺序的表达式" class="headerlink" title="避免有未定义求值顺序的表达式"></a>避免有未定义求值顺序的表达式</h3><h3 id="不要依赖函数参数的求值顺序"><a href="#不要依赖函数参数的求值顺序" class="headerlink" title="不要依赖函数参数的求值顺序"></a>不要依赖函数参数的求值顺序</h3><h3 id="避免转型"><a href="#避免转型" class="headerlink" title="避免转型"></a>避免转型</h3><ul>
<li>粗略来说，C风格转型会先从static_cast开始,接着是const_cast，最后执行reinterpret_cast</li>
</ul>
<h3 id="如果必须使用转型，请使用具名转型"><a href="#如果必须使用转型，请使用具名转型" class="headerlink" title="如果必须使用转型，请使用具名转型"></a>如果必须使用转型，请使用具名转型</h3><ul>
<li>在C++11中，我们有以下六种转型<ul>
<li>static_cast : 在类似的类型之间进行转换，例如指针类型或数字类型</li>
<li>const_cast : 添加或删除const或volatile</li>
<li>reinterpret_cast : 在指针之间或在整形和指针之间转换</li>
<li>dynamic_cast : 在同一个类层次中的多态指针或引用之间进行转换</li>
<li>std::move : 转换为右值引用</li>
<li>std::forward : 将左值转换为左值引用，或者将右值转换为右值引用</li>
</ul>
</li>
</ul>
<h3 id="不要用转型去除const"><a href="#不要用转型去除const" class="headerlink" title="不要用转型去除const"></a>不要用转型去除const</h3><ul>
<li>如果底层对象(例如 constInt)是const，而你试图修改底层对象，那么用转型去除const的行为是未定义行为</li>
</ul>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><ul>
<li>语句主要分为两类<ul>
<li>迭代语句和选择语句</li>
</ul>
</li>
</ul>
<h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><ul>
<li><p>C++实现了三种迭代语句: while, do while 和 for</p>
</li>
<li><p>在C++11中，for循环中加入了语法糖: 基于范围的for循环</p>
</li>
<li><p>基于范围的for循环更加容易阅读，而且在循环过程中不会出现索引错误，也不会对索引进行修改</p>
</li>
<li><p>当你有一个明显的循环变量时，应该使用for循环而不是while语句。如果没有，那你应该使用while语句</p>
</li>
<li><p>你应该在for循环中声明循环变量。要提醒你的是，从C++17开始，变量声明也可以在if或switch语句的初始化部分进行。</p>
</li>
<li><p>避免使用do while语句和goto语句，并尽量不在迭代语句中使用break和continue，因为它们难以阅读。</p>
<ul>
<li>如果某样东西难以阅读，它就容易出错，并使你的代码重构变得困难。</li>
<li>break语句会结束迭代语句，而continue语句则结束当前迭代步骤。</li>
</ul>
</li>
<li><p>只要有合适的具名算法，就应该优先使用算法而不是原始循环。</p>
</li>
<li><p>STL的一百多个算法提供了对容器的隐式操作。这种操作常常可通过lambda表达式进行适配，还常常可以利用并行或者并行加向量化的版本来运行</p>
</li>
</ul>
<h3 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h3><ul>
<li>if 和 switch 是C++里从C语句继承下来的选择语句</li>
<li>在可以选择时，你应该首选switch语句而不是if语句，因为switch语句通常更加可读，而且比if语句更好优化</li>
</ul>
<h3 id="不要依赖switch语句中的隐式直落行为"><a href="#不要依赖switch语句中的隐式直落行为" class="headerlink" title="不要依赖switch语句中的隐式直落行为"></a>不要依赖switch语句中的隐式直落行为</h3><ul>
<li>从C++17开始，属性[[fallthrough]]，可以明确地表达你的意图。[[fallthrough]]必须在它自己的语句行中，并紧接在一个case标签之前。</li>
<li>[[fallthrough]]向编译器表明，这里是估计要直落的。这样，编译器就不会发出诊断警告了。</li>
</ul>
<h3 id="仅使用default来处理一般情况"><a href="#仅使用default来处理一般情况" class="headerlink" title="仅使用default来处理一般情况"></a>仅使用default来处理一般情况</h3><h3 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h3><ul>
<li>有符号和无符号证书的算术，以及典型的算术错误，例如上溢和下溢和除以零</li>
</ul>
<h3 id="不要混合有符号和无符号的算术运算"><a href="#不要混合有符号和无符号的算术运算" class="headerlink" title="不要混合有符号和无符号的算术运算"></a>不要混合有符号和无符号的算术运算</h3><ul>
<li>如果你混合有符号和无符号的算术运算，你可能不会得到想要的结果</li>
</ul>
<h3 id="使用无符号类型进行位操作"><a href="#使用无符号类型进行位操作" class="headerlink" title="使用无符号类型进行位操作"></a>使用无符号类型进行位操作</h3><ul>
<li>用位操作符(~, &gt;&gt;, &gt;&gt;&#x3D;, &lt;&lt;, &lt;&lt;&#x3D;, &amp;, &amp;&#x3D;, ^, ^&#x3D;, |, |&#x3D;)对有符号操作数进行操作存在由实现定义的行为。</li>
<li>实现定义的行为意味着该行为在不同的实现之间会不同，并且实现必须记录每种行为的效果。因此，不要在有符号类型上进行位操作，而应该使用无符号类型。</li>
</ul>
<h3 id="使用有符号类型进行算术运算"><a href="#使用有符号类型进行算术运算" class="headerlink" title="使用有符号类型进行算术运算"></a>使用有符号类型进行算术运算</h3><ul>
<li>首先，你不应该用无符号类型做算术，因为减法得到的负值在无符号类型中无法正确表达。</li>
<li>其次，根据前面的规则，不应该混合有符号和无符号的算术</li>
</ul>
<h3 id="不要试图通过使用-unsigned-来避免负值"><a href="#不要试图通过使用-unsigned-来避免负值" class="headerlink" title="不要试图通过使用 unsigned 来避免负值"></a>不要试图通过使用 unsigned 来避免负值</h3><ul>
<li><p>有一个有趣的关系: 当你给unsigned int 变量赋值为-1时，你会得到最大的unsigned int</p>
</li>
<li><p>算术表达式的行为在signed和unsigned类型之间有所不同</p>
</li>
<li><p>检测溢出</p>
<ul>
<li>使用花括号表达式 x &#x3D; {x + 1000}替换错误的赋值 x +&#x3D; 1000。</li>
<li>它们的不同在于，编译器检查窄化转换，因此会检测到溢出</li>
</ul>
</li>
</ul>
<h3 id="典型的算术错误"><a href="#典型的算术错误" class="headerlink" title="典型的算术错误"></a>典型的算术错误</h3><ul>
<li>如果违反以下三条规则，将会导致未定义行为<ul>
<li>避免上溢</li>
<li>避免下溢<ul>
<li>上溢和下溢的效果是一样的: 内存损坏,因此是未定义行为</li>
</ul>
</li>
<li>不要除以零</li>
</ul>
</li>
</ul>
<h3 id="本章精华-5"><a href="#本章精华-5" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>如果你在手写循环，那说明你可能对标准模板库(STL)的算法还不够了解，STL包含一百多种算法</li>
<li>好名字可能是号软件的最重要原则。好的名字意味着你的名字应该是自解释的，是尽可能局部的，不应该与现有的名字相似，不应该使用ALL_CAPS风格，也不应该在嵌套的作用域中重复使用</li>
<li>始终初始化变量。优先使用{}初始化以防止窄化转换。对于const变量的复杂初始化，请使用就地调用lambda表达式</li>
<li>不要把宏用于常量或函数。如果你必须时用它，或者维护现有的宏，请使用为一的ALL_CAPS名字</li>
<li>可能的话，你应该优先选择基于范围的for循环而不是普通for循环。基于范围的for循环更加人容易阅读，而且不会引起下标错误</li>
<li>应该优先选择switch语句，而不是if语句。switch语句更加容易阅读，而且有更多的优化潜力</li>
<li>除非有特殊原因，否则应该使用有符号的整数，不要混合使用有符号和无符号算术</li>
<li>请注意，上溢和下溢是未定义行为，通常在程序运行时以崩溃告终。</li>
</ul>
<h2 id="第九章-性能"><a href="#第九章-性能" class="headerlink" title="第九章 性能"></a>第九章 性能</h2><h3 id="错误的优化"><a href="#错误的优化" class="headerlink" title="错误的优化"></a>错误的优化</h3><ul>
<li>不要无故优化</li>
<li>不要过早进行优化</li>
<li>不要优化并非性能关键的东西</li>
<li>有一句名言可以很好地总结前三条规则<ul>
<li>真正的问题是，程序员们花了太多的时间在错误的地方和错误的时间里担心效率问题：过早优化是编程中万恶之源(或至少是其中大部分罪恶之源)。–高德纳，《计算机程序设计艺术》</li>
</ul>
</li>
<li>简而言之，请务必记住 过早优化是编程中万恶之源 这句话。在进行任何新能假设之前，请使用最关键的规则来进行性能分析: 测量程序的性能</li>
</ul>
<h3 id="错误的假设"><a href="#错误的假设" class="headerlink" title="错误的假设"></a>错误的假设</h3><ul>
<li><p>不要假设复杂的代码一定比简单的快</p>
</li>
<li><p>不要假设低级代码一定比高级代码块</p>
</li>
<li><p>不要在没有测量的情况下对性能妄下断言</p>
</li>
<li><p>在继续之前，必须先声明一下: 不建议使用臭名昭著的单例模式。单例模式有很多缺点。</p>
</li>
</ul>
<h3 id="设计应当允许优化"><a href="#设计应当允许优化" class="headerlink" title="设计应当允许优化"></a>设计应当允许优化</h3><ul>
<li>这条规则尤其适用于移动语义，因为你写算法时应该使用移动语义，而不是拷贝语义。移动语义的使用会自动带来一些好处<ul>
<li>算法使用低开销的移动操作，而不是高开销的拷贝操作</li>
<li>算法要稳定的多，因为它不需要内存分配，所以不会出现std::bad_alloc异常</li>
<li>可将算法用于只能移动的类型，例如std::unique_ptr</li>
</ul>
</li>
</ul>
<h3 id="依赖静态类型系统"><a href="#依赖静态类型系统" class="headerlink" title="依赖静态类型系统"></a>依赖静态类型系统</h3><ul>
<li><p>写本地代码</p>
<ul>
<li>一般来说，若使用就地调用的lambda表达式(而不是函数)来调整 std::sort的行为，代码会更快。编译器拥有所有可用的信息来生成最优化的代码。相反，函数可能定义在另一个翻译单元中，这对优化器来说是一个硬边界</li>
</ul>
</li>
<li><p>写简单代码</p>
<ul>
<li>优化器会搜寻可以被优化的已知模式。如果你的代码是手写的且极为复杂，这会使优化器寻找已知模式的工作变得更加困难。最终，你常常会得到没有充分优化的代码</li>
</ul>
</li>
<li><p>给予编译器额外的提示</p>
<ul>
<li>当函数不能抛出异常，或者你不关心异常时，将它声明为noexcept。如果一个虚函数不应该被覆盖，那么可将其声明为final，这对优化器来说也是很有意义的。</li>
</ul>
</li>
</ul>
<h3 id="将计算从运行期移至编译期"><a href="#将计算从运行期移至编译期" class="headerlink" title="将计算从运行期移至编译期"></a>将计算从运行期移至编译期</h3><ul>
<li>constexpr 函数可以在运行期使用，也可以在编译期使用，如果要在编译期使用它，其参数必须是常量表达式。</li>
</ul>
<h3 id="以可预测的方式访问内存"><a href="#以可预测的方式访问内存" class="headerlink" title="以可预测的方式访问内存"></a>以可预测的方式访问内存</h3><h3 id="本章精华-6"><a href="#本章精华-6" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>在基于错误的假设进行任务所谓的优化之前，请测量程序的性能</li>
<li>帮助编译器来优化程序。请使用移动语义来实现函数，如果可能的话，让他们成为constexpr</li>
<li>现在计算机架构为连续读取内存而进行了优化。因此，应该将std::vector,std::array或std::string作为首选</li>
</ul>
<h2 id="第十章-并发"><a href="#第十章-并发" class="headerlink" title="第十章 并发"></a>第十章 并发</h2><ul>
<li>并发 ： 多个任务的执行可重叠。并发是并行的超集</li>
<li>并行 ： 多个任务再同一时间运行。并行是并发的子集</li>
</ul>
<h3 id="假设代码将作为多线程程序的一部分来运行"><a href="#假设代码将作为多线程程序的一部分来运行" class="headerlink" title="假设代码将作为多线程程序的一部分来运行"></a>假设代码将作为多线程程序的一部分来运行</h3><ul>
<li><p>对共享的非原子变量进行的异步读写是一种数据竞争。因此，程序具有未定义行为。</p>
</li>
<li><p>有什么办法来摆脱数据竞争</p>
<ul>
<li>使用锁来保护整个临界区域</li>
<li>用锁来保护函数cached_computation的调用</li>
<li>将这两个静态变量都设置为thread_local。thread_local保证每个线程都能得到变量cached_x 和 cached_result。静态变量会被绑定到主线程的生存期。thread_local变量则绑定到线程的生存期</li>
</ul>
</li>
<li><p>C++11标准保证C++运行期以线程安全的方式初始化静态变量；因此，不需要保护其初始化</p>
</li>
</ul>
<h3 id="避免数据竞争"><a href="#避免数据竞争" class="headerlink" title="避免数据竞争"></a>避免数据竞争</h3><ul>
<li>什么是数据竞争<ul>
<li>数据竞争是指至少有两个线程在异步的情况下访问一个非原子的共享变量，并且至少有一个线程试图修改该变量</li>
</ul>
</li>
<li>如果你的程序里有数据竞争，那么该程序有未定义行为。</li>
<li>共享的，可变的状态是发生数据竞争的必要条件。</li>
</ul>
<h3 id="尽量减少对可写数据的显式共享"><a href="#尽量减少对可写数据的显式共享" class="headerlink" title="尽量减少对可写数据的显式共享"></a>尽量减少对可写数据的显式共享</h3><ul>
<li>根据前面与数据竞争相关的规则，共享数据应该是不变的</li>
<li>现在，唯一需要解决的困难是如何以线程安全的方式初始化常量共享数据。C++11支持下面几种不同方法来实现这一点<ul>
<li>在启动线程之前初始化数据。这并不是C++11造成的，但却很容易应用</li>
<li>使用常量表达式，因为它们在编译期被初始化</li>
<li>将函数std::call_once与函数std::once_flag结合起来使用。可将重要的初始化内容放入函数onlyOnceFunc中。C++运行期保证这个函数只会成功运行一次；</li>
<li>使用具有块作用域的静态变量，因为C++11的运行时保证它们会以线程安全的方式初始化</li>
</ul>
</li>
</ul>
<h3 id="从任务-而不是线程-的角度进行思考"><a href="#从任务-而不是线程-的角度进行思考" class="headerlink" title="从任务(而不是线程)的角度进行思考"></a>从任务(而不是线程)的角度进行思考</h3><ul>
<li><p>什么是任务？</p>
<ul>
<li>任务是对执行单元的通用术语</li>
</ul>
</li>
<li><p>从C++11开始，我们把任务当作一个特别术语来用，它代表两个组成部分：诺值(promise)和期值(future)。</p>
<ul>
<li>诺值产生期值可以异步获取的值。</li>
<li>诺值和期值可以在不同的线程中运行，然后通过安全的数据通道相连接</li>
</ul>
</li>
<li><p>诺值在C++中存在3中变体: std::async, std::packaged_task和std::promise</p>
</li>
<li><p>std::packaged_task和std::promise的共同点是它们都相当低级。</p>
</li>
<li><p>线程和期值&#x2F;诺值之间的根本区别是什么？</p>
<ul>
<li>线程是关于应该如何计算的；</li>
<li>任务是关于应该计算什么的</li>
</ul>
</li>
<li><p>说的更加具体一点</p>
<ul>
<li>线程t使用共享变量res来提供结果。与此相反，std::async的诺值会建立一个安全的数据通道，并用它把结果传递给期值fut。这种数据共享意味着，对于线程t，必须保护res</li>
</ul>
</li>
<li><p>对于线程，你需要明确进行创建。对于诺值std::async，则不一定会自动创建线程。你指定应该计算什么，而不是应该如何计算。如果有必要，C++运行时会决定是否要创建线程</p>
</li>
</ul>
<h3 id="不要试图使用volatile进行同步"><a href="#不要试图使用volatile进行同步" class="headerlink" title="不要试图使用volatile进行同步"></a>不要试图使用volatile进行同步</h3><ul>
<li><p>在C++中，volatile并没有多线程语义。在C++11中，原子量被称为std::atomic</p>
</li>
<li><p>volatile用于特殊对象，不允许对其进行优化读或写操作。volatile通常用于嵌入式编程领域，表示可以独立于常规程序流程而改变的对象。比如，这些对象代表外部设备(内存映射I&#x2F;O)。因为这些对象可以独立于常规程序流程进行更改，它们的值会被直接写入主存。因此，编译期不能假设它可以根据程序流来判断是否可对读写进行优化</p>
</li>
</ul>
<h3 id="只要可行，就使用工具来对并发代码进行验证"><a href="#只要可行，就使用工具来对并发代码进行验证" class="headerlink" title="只要可行，就使用工具来对并发代码进行验证"></a>只要可行，就使用工具来对并发代码进行验证</h3><ul>
<li><p>动态代码分析工具ThreadSanitizer和静态代码分析工具CppMem</p>
</li>
<li><p>ThreadSnaitizer提供了全局信息，检测程序的执行是否存在数据竞争</p>
</li>
<li><p>Cppem能让你深入理解代码里的小片段，大多数是否包括原子量。你会得到问题的答案：根据内存模型，那些情况下交错是可行的</p>
</li>
<li><p>ThreadSanitizer(又名TSan)是一个C&#x2F;C++的数据竞争检测器。数据竞争是并发系统中最常见和最难处理的错误之一。当两个线程同时访问同一个非原子变量，并且其中至少有一个线程的访问是写操作时，数据竞争就会发生。C++11标准正式禁止数据竞争，并将其归为未定义行为</p>
</li>
<li><p>ThreadSanitizer是Clang3.2和GCC4.8的一部分。要使用它，必须使用-fsanitize&#x3D;thread进行编译和链接，并至少使用优化级别-O2和产生调试信息的标志-g。</p>
<ul>
<li>-fsanitize&#x3D;thread -O2 -g</li>
</ul>
</li>
<li><p>它有很大的运行期开销</p>
<ul>
<li>内存使用量可能会增加5到10倍，执行时间也可能增加2到20倍</li>
</ul>
</li>
<li><p>软件开发的突出法则</p>
<ul>
<li>首先，让程序正确</li>
<li>然后，让它快起来</li>
</ul>
</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li>NNN是 No Naked New(不要裸的New)的缩写，意味着内存分配不应该是一个独立的操作，而应该放在一个管理者对象中进行</li>
<li>互斥量也是如此。互斥量应立即交付给一个管理者对象，在这种情况下，它就是锁对象。</li>
<li>在现代C++中，我们有std::lock_guard, std::unique_lock, std::shared_lock(C++14), std::scoped_lock(C++17)</li>
<li>请记住缩写NNM，它代表 No Naked Mutex，锁实现了RAII惯用法。RAII惯用法背后的关键思想是将资源的生存期和局部变量的生存期绑定。C++会自动管理局部变量的生存期</li>
</ul>
<h3 id="使用RAII，永远不要直接使用lock-unlock"><a href="#使用RAII，永远不要直接使用lock-unlock" class="headerlink" title="使用RAII，永远不要直接使用lock()&#x2F;unlock()"></a>使用RAII，永远不要直接使用lock()&#x2F;unlock()</h3><ul>
<li>将互斥量放入锁对象中，互斥量在std::lock_guard的构造函数中被自动锁定，并在lck超出作用域时解锁</li>
</ul>
<h3 id="使用std-lock-或std-scoped-lock来获取多个互斥量"><a href="#使用std-lock-或std-scoped-lock来获取多个互斥量" class="headerlink" title="使用std::lock()或std::scoped_lock来获取多个互斥量"></a>使用std::lock()或std::scoped_lock来获取多个互斥量</h3><ul>
<li>如果一个线程同时需要多个互斥量，那么必须非常小心，始终以相同的顺序锁定互斥量。否则，糟糕的线程的交错可能会导致死锁</li>
<li>解决死锁的最简单方法是以原子方式锁定两个互斥量</li>
<li>在C++11中，可将std::unique_lock和std::lock一起使用</li>
<li>在C++17中，std::scoped_lock可以原子性的锁定任意数量的互斥量。</li>
</ul>
<h3 id="决不在持有锁的时候调用未知代码-例如回调函数"><a href="#决不在持有锁的时候调用未知代码-例如回调函数" class="headerlink" title="决不在持有锁的时候调用未知代码(例如回调函数)"></a>决不在持有锁的时候调用未知代码(例如回调函数)</h3><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>线程是并发和并行编程的基本构建块。</li>
</ul>
<h3 id="将汇合thread看作一个有作用域的容器"><a href="#将汇合thread看作一个有作用域的容器" class="headerlink" title="将汇合thread看作一个有作用域的容器"></a>将汇合thread看作一个有作用域的容器</h3><h3 id="将thread看作一个全局容器"><a href="#将thread看作一个全局容器" class="headerlink" title="将thread看作一个全局容器"></a>将thread看作一个全局容器</h3><ul>
<li><p>首先，必须汇合或分离子线程。如果不这样做，会在子线程的析构函数中得到std::terminate </p>
</li>
<li><p>一个线程可以被看作一个使用外部变量的全局容器。此外，对于汇合线程，容器的生存期是有作用域的。</p>
</li>
</ul>
<h3 id="优先选择std-jthread，而不是std-thread"><a href="#优先选择std-jthread，而不是std-thread" class="headerlink" title="优先选择std::jthread，而不是std::thread"></a>优先选择std::jthread，而不是std::thread</h3><ul>
<li><p>这条规则的原标题是： 优先选择gsl::join_thread，而不是std::thread</p>
</li>
<li><p>这里用C++20中的std::jthread替换了C++ Core Guidelines支持库中的gsl::joint_thread</p>
</li>
<li><p>除了有std::thread的功能，std::jthread会在析构时自动汇合。</p>
</li>
</ul>
<h3 id="不要对线程调用detach"><a href="#不要对线程调用detach" class="headerlink" title="不要对线程调用detach()"></a>不要对线程调用detach()</h3><ul>
<li>分离线程的难度很大</li>
</ul>
<h3 id="不要在没有条件时wait"><a href="#不要在没有条件时wait" class="headerlink" title="不要在没有条件时wait"></a>不要在没有条件时wait</h3><ul>
<li><p>条件变量(condition variable)支持一个非常简单的概念：一个线程准备好了一些东西，并向等待它的另一个线程发送通知。</p>
</li>
<li><p>条件变量受到两个很严重的问题的影响</p>
<ul>
<li>丢失唤醒(loss wakeup): 丢失唤醒的现象是，发送方在接收方开始等待之前发送了通知。结果通知丢失</li>
<li>虚假唤醒(spurious wakeup): 即使没有发送通知，接收方也可能会被唤醒。至少POSIX线程和WindowsAPI会是这些现象的受害者</li>
</ul>
</li>
</ul>
<h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><ul>
<li>共享数据使用的越少，并且局部变量使用的越多，结果就越好。不过，有时除了共享数据，你别无选择，例如，当子线程想把它的工作传达给父线程时</li>
</ul>
<h3 id="在线程之间传递少量的数据使用值传递，而不是引用或指针"><a href="#在线程之间传递少量的数据使用值传递，而不是引用或指针" class="headerlink" title="在线程之间传递少量的数据使用值传递，而不是引用或指针"></a>在线程之间传递少量的数据使用值传递，而不是引用或指针</h3><ul>
<li>将数据按值传递给线程有两个好处<ul>
<li>没有共享，因此，不可能有数据竞争。数据竞争的前提是有可变并共享的状态</li>
<li>你不需要关心数据的生存期。数据的生存期和所创建的线程的生存期保持一致</li>
</ul>
</li>
</ul>
<h3 id="要在不相关的thread之间分享所有权，请使用shared-ptr"><a href="#要在不相关的thread之间分享所有权，请使用shared-ptr" class="headerlink" title="要在不相关的thread之间分享所有权，请使用shared_ptr"></a>要在不相关的thread之间分享所有权，请使用shared_ptr</h3><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><ul>
<li>使用并发的主要原因之一是性能。</li>
<li>必须牢记，使用线程时需要耗用资源: 时间和内存。</li>
<li>资源的使用从创建开始，然后随着上下文切换从用户空间到内核空间，并以线程销毁而结束。</li>
<li>此外，线程由有自己的状态，需要分配和维护</li>
</ul>
<h3 id="尽量减少上下文切换"><a href="#尽量减少上下文切换" class="headerlink" title="尽量减少上下文切换"></a>尽量减少上下文切换</h3><h3 id="尽量减少线程的创建和销毁"><a href="#尽量减少线程的创建和销毁" class="headerlink" title="尽量减少线程的创建和销毁"></a>尽量减少线程的创建和销毁</h3><h3 id="尽量减少临界区内的时间占用"><a href="#尽量减少临界区内的时间占用" class="headerlink" title="尽量减少临界区内的时间占用"></a>尽量减少临界区内的时间占用</h3><ul>
<li>锁定互斥量的时间越短，其他线程可运行的时间就越长</li>
</ul>
<h3 id="记得给你的lock-guard和unique-lock起名字"><a href="#记得给你的lock-guard和unique-lock起名字" class="headerlink" title="记得给你的lock_guard和unique_lock起名字"></a>记得给你的lock_guard和unique_lock起名字</h3><ul>
<li>如果你没有给std::lock_guard或std::unique_lock起名字，那你只是创建了一个临时变量，它在创建后会立即销毁。</li>
<li>std::lock_guard或std::unique_lock会自动锁定其互斥量和构造函数，并在其析构函数中解锁。这种模式被称为RAII</li>
</ul>
<h3 id="关于并行"><a href="#关于并行" class="headerlink" title="关于并行"></a>关于并行</h3><ul>
<li><p>优先使用STL的并行算法，而不是用线程手写解决方案</p>
</li>
<li><p>std::execution::seq : 顺序执行算法</p>
</li>
<li><p>std::execution::par : 在多个线程上并行的运行该算法</p>
</li>
<li><p>std::execution::par_unseq : 在多个线程上并行运算算法，并允许单个循环的交错</p>
</li>
<li><p>向量化std::execution::par_unseq代表现代处理器指令集的SIMD(单指令多数据)扩展。SIMD使处理器能够在多个数据上并行的执行同一个操作。</p>
</li>
</ul>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><ul>
<li><p>关于消息传递，有两条规则</p>
<ul>
<li>使用future从并发任务返回</li>
<li>使用async()生成并发任务</li>
</ul>
</li>
<li><p>任务是一种C++式的在线程之间传递消息的方式。</p>
</li>
<li><p>消息可以是值，异常或者通知。</p>
</li>
<li><p>任务由诺值和期值两个部分组成。诺值创建消息，期值异步的进行接收</p>
</li>
<li><p>发送值或异常</p>
<ul>
<li>与线程非常不同，诺值和相关联的期值会共享一个安全通道</li>
</ul>
</li>
<li><p>发送通知</p>
<ul>
<li>如果你使用诺值和期值(在短任务中)来同步线程，它们与条件变量有很多共同之处。</li>
<li>大多数情况下，诺值和期值是比条件变量更加安全的选择</li>
</ul>
</li>
<li><p>跟诺值和期值相比，条件变量的优势在于，可以使用条件变量来多次同步线程。</p>
</li>
<li><p>与此相反，一个诺值只能发送一次通知。而如果你只为单次同步使用条件变量，要么把条件变量用对会比用诺值和期值难得多。一对诺值和期值不需要锁，不会出现虚假唤醒和丢失唤醒，也不需要临界区或额外的条件判断</p>
</li>
</ul>
<h3 id="无锁编程"><a href="#无锁编程" class="headerlink" title="无锁编程"></a>无锁编程</h3><ul>
<li>并发和并行的规则是针对非专家的。无锁编程(lock-free programming)是一个仅面向专家的主题。</li>
</ul>
<h3 id="除非绝对需要，否则不要使用无锁编程"><a href="#除非绝对需要，否则不要使用无锁编程" class="headerlink" title="除非绝对需要，否则不要使用无锁编程"></a>除非绝对需要，否则不要使用无锁编程</h3><h3 id="不要轻信硬件-编译器组合"><a href="#不要轻信硬件-编译器组合" class="headerlink" title="不要轻信硬件&#x2F;编译器组合"></a>不要轻信硬件&#x2F;编译器组合</h3><h3 id="本章精华-7"><a href="#本章精华-7" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>区分并发和并行。并发是指多个任务的重叠，而并行是指多个任务同时运行</li>
<li>通过尽量减少数据的共享来避免数据竞争，并使共享的数据不可变</li>
<li>使用ThreadSanitizer或Cppem等工具来验证并发代码</li>
<li>不要直接对互斥量加&#x2F;解锁。将互斥量放入锁对象中，比如std::lock_guard或者std::unique_lock</li>
<li>不要在持有锁的时候调用未知代码。尽量不要在任一时间点获取超过一把锁</li>
<li>当你在某个时候需要超过一把锁时，使用std::lock或者std::scoped_lock来原子性的获取</li>
<li>使用std::jthread而不是std::thread，以便在析构时自动重新汇合</li>
<li>不要使用没有附加谓词的条件变量，以避免虚假唤醒和丢失唤醒</li>
<li>如果逆向并行的执行一项工作，最好使用STL的并行算法，而不是用线程来手工实现解决方案</li>
<li>使用任务在线程之间传递消息或异常。使用任务(而不是条件变量)来同步线程</li>
<li>除非绝对需要，否则不要使用无锁编程。事先请仔细研读文献</li>
</ul>
<h2 id="第十一章-错误处理"><a href="#第十一章-错误处理" class="headerlink" title="第十一章 错误处理"></a>第十一章 错误处理</h2><ul>
<li><p>根据C++ Core Guidelines，错误处理涉及一下操作</p>
<ul>
<li>检查错误</li>
<li>将有关错误的信息传递给某些处理程序代码</li>
<li>保存程序的有效状态</li>
<li>避免资源泄漏</li>
</ul>
</li>
<li><p>应该使用异常来处理错误</p>
</li>
<li><p>C++ Core Guidelines中的规则应该可以帮助避免以下几种类型的错误，这里在括号中添加了典型的例子</p>
<ul>
<li>类型违规(转型)</li>
<li>资源泄漏(内存泄漏)</li>
<li>边界错误(访问到了容器的边界外)</li>
<li>生存期错误(删除后访问对象)</li>
<li>逻辑错误(逻辑表达式)</li>
<li>接口错误(在借口中传递错误的值)</li>
</ul>
</li>
<li><p>总共二十多条规则，可以分为三类</p>
<ul>
<li>前两类说的是错误处理策略的设计及其具体实现</li>
<li>第三类讨论不能抛出异常的情况</li>
</ul>
</li>
</ul>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><ul>
<li><p>每个软件单元都有两条与客户的通信途径</p>
<ul>
<li>一条用于常规情况</li>
<li>另一条用于非常规情况</li>
</ul>
</li>
<li><p>软件单元应该围绕不变式进行设计</p>
</li>
<li><p>通信</p>
<ul>
<li>在设计初期制订错误处理策略</li>
<li>不要试图在每个函数中捕获每个异常</li>
<li>尽量减少显式的try&#x2F;catch使用</li>
</ul>
</li>
<li><p>什么是软件单元？</p>
<ul>
<li>软件单元可以是函数，对象，子系统或者整个系统。</li>
</ul>
</li>
<li><p>软件单元与客户进行通信。因此，通信设计应该在系统设计初期进行。</p>
</li>
<li><p>在边界层面，有两种通信方式：常规和非常规。</p>
<ul>
<li>常规通信是接口的功能方面，换句话说，它规定软件单元应该做什么</li>
<li>非常规通信代表非功能方面。非功能方面规定了系统的运行方式。非功能方面的很大一部分是错误处理，即什么会出错。通常，非功能方面被称为 质量属性</li>
</ul>
</li>
<li><p>从控制流的角度来看，显式的try&#x2F;catch与goto语句有很多共同之处。这意味着如果异常被抛出，控制流会直接跳转到异常处理器，而这段代码可能在不同的软件单元中。</p>
</li>
<li><p>现在的问题是，应该如何组织异常处理？我认为你应该先问自己一个问题：是否可能在本地处理异常？</p>
<ul>
<li>如果是，那就去做；如果否，那就让异常传播，直到有足够的上下文来处理它。处理异常也可能意味着捕获它，然后重新抛出一个不同的，对客户更方便的异常。这种对异常的转换可以达到这样的目的：软件单元的客户只需要处理数量有限的不同异常</li>
</ul>
</li>
<li><p>通常情况下，边界是处理异常的合适位置，因为你会希望保护客户端，使其不会随便受异常的影响。</p>
</li>
<li><p>不变式</p>
<ul>
<li>通过抛出异常来表明函数无法执行其分配的任务</li>
<li>围绕不变式来设计错误处理策略</li>
<li>让构造函数建立不变式，做不到就抛出异常</li>
</ul>
</li>
<li><p>根据C++ Core Guidelines，不变式是 对象成员的一种逻辑条件，构造函数必须建立这个条件，这样公开成员函数就可以假设它一定成立。在不变式建立后(通常通过构造函数)，对象上的每个成员函数就可以调用了</p>
</li>
<li><p>更多关于不变式和如何建立不变式的规则，这些规则补充了本章开头的讨论</p>
<ul>
<li>当类具有不变式时使用class；如果数据成员可以独立变化，则使用struct</li>
<li>构造函数应该创建完全初始化的对象</li>
<li>不要定义仅初始化数据成员的默认构造函数，而应该使用成员初始化器</li>
</ul>
</li>
</ul>
<h3 id="只对错误处理使用异常"><a href="#只对错误处理使用异常" class="headerlink" title="只对错误处理使用异常"></a>只对错误处理使用异常</h3><ul>
<li>异常是一种goto语句</li>
</ul>
<h3 id="应使用专门设计的用户定义类型-而非内置类型-作为异常"><a href="#应使用专门设计的用户定义类型-而非内置类型-作为异常" class="headerlink" title="应使用专门设计的用户定义类型(而非内置类型)作为异常"></a>应使用专门设计的用户定义类型(而非内置类型)作为异常</h3><ul>
<li>你不应该使用内置类型，甚至不应该直接使用标准的异常类型</li>
<li>建议使用标准异常而不是内置类型，因为前者可以给异常附加额外的信息，或者构建异常层次结构。</li>
<li>标准异常也只是相对稍好，但还是算不上号，因为这个异常太通用了。</li>
<li>要解决这些问题，请从std::runtime_error派生出你的具体异常，下面是一个简短的例子<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InputSubsystemException</span> : <span class="keyword">public</span> std::runtime_error</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;在这里提供异常的更多细节&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="通过引用从层次结构中捕获异常"><a href="#通过引用从层次结构中捕获异常" class="headerlink" title="通过引用从层次结构中捕获异常"></a>通过引用从层次结构中捕获异常</h3><ul>
<li><p>如果按值捕获层次结构中的异常，那么你可能会成为切片的受害者</p>
</li>
<li><p>多态类应当抑制公开的拷贝&#x2F;移动操作，说的明确一点</p>
<ul>
<li>应该通过const引用来捕获异常；仅在想要修改异常时通过(非const)引用来捕获</li>
<li>如果你要在异常处理器中重新抛出异常e，只需要使用throw而不是throw e；在第二种情况下，e会被复制</li>
</ul>
</li>
<li><p>要解决按值捕获异常，有个简单的办法：</p>
<ul>
<li>应用规则：如果基类被当作接口使用，那就把他变成抽象类</li>
</ul>
</li>
</ul>
<h3 id="在直接拥有对象时决不抛异常"><a href="#在直接拥有对象时决不抛异常" class="headerlink" title="在直接拥有对象时决不抛异常"></a>在直接拥有对象时决不抛异常</h3><ul>
<li>如果throw被激发，那内存会丢失，你就有了内存泄漏。</li>
<li>简单的解决方案是摆脱所有权，让C++运行时成为对象的直接所有者。这意味着只需要应用RAII</li>
</ul>
<h3 id="不要使用异常规格"><a href="#不要使用异常规格" class="headerlink" title="不要使用异常规格"></a>不要使用异常规格</h3><h3 id="正确排列catch子句的顺序"><a href="#正确排列catch子句的顺序" class="headerlink" title="正确排列catch子句的顺序"></a>正确排列catch子句的顺序</h3><ul>
<li><p>异常的捕获是根据第一次匹配策略进行的。这意味着第一个匹配成功的异常处理器将被使用。这就是应该从具体到一般来组织异常处理器的原因。否则，你的具体异常处理器可能永远不会被调用。</p>
</li>
<li><p>异常处理器有省略号(…)，用来捕获所有其他的异常</p>
</li>
</ul>
<h3 id="如果不能抛出异常"><a href="#如果不能抛出异常" class="headerlink" title="如果不能抛出异常"></a>如果不能抛出异常</h3><ul>
<li><p>如果不能抛出异常，请模仿RAII进行资源管理</p>
</li>
<li><p>如果不能抛出异常，考虑快速失败</p>
<ul>
<li>如果没有办法从内存耗尽等错误中恢复过来，那就快速失败。如果你不能抛异常，就调用std::abort，促使程序异常终止</li>
</ul>
</li>
<li><p>如果不能抛出异常，请系统的使用错误代码</p>
</li>
<li><p>根据C++ Core Guidelines，如果出现错误，你有几个问题需要解决</p>
<ul>
<li>如何将错误指示从函数中传出</li>
<li>在进行错误推出之前，如何从函数中释放所有资源</li>
<li>使用什么作为错误指示</li>
</ul>
</li>
<li><p>一般来说，函数应该有两个返回值： 值和错误提示。 因此，std::pair就很合适。</p>
</li>
<li><p>不过，即使清理代码被封装在函数中，释放资源也很容易成为维护的噩梦</p>
</li>
<li><p>把清理代码放在函数的末尾，并跳转到该部分即可。</p>
</li>
</ul>
<h3 id="本章精华-8"><a href="#本章精华-8" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>软件单元通过常规和非常规的通信途径将结果传达给客户。错误处理是非常规途径的一个主要部分，应该在设计初期进行设定</li>
<li>围绕不变式设计错误处理。构造函数的工作是建立不变式。如果不变式不能被建立，则抛出异常</li>
<li>使用用户定义类型来表示异常。通过引用来捕获异常，顺序应该从具体到一般</li>
<li>仅将异常用于错误处理</li>
<li>切勿直接拥有对象。始终使用RAII类型来管理任何需要释放的资源。RAII有助于资源管理，即使不使用异常，也是如此。</li>
</ul>
<h2 id="第十二章-常量和不可变性"><a href="#第十二章-常量和不可变性" class="headerlink" title="第十二章 常量和不可变性"></a>第十二章 常量和不可变性</h2><ul>
<li>无论如何，const，constexpr和不可变性的思想太重要了。</li>
</ul>
<h3 id="使用const"><a href="#使用const" class="headerlink" title="使用const"></a>使用const</h3><ul>
<li>const正确性，是指 意味着使用关键字const来防止const对象被改变</li>
</ul>
<h3 id="默认情况下，使对象不可变"><a href="#默认情况下，使对象不可变" class="headerlink" title="默认情况下，使对象不可变"></a>默认情况下，使对象不可变</h3><ul>
<li>可以将内置数据类型的值或用户定义的数据类型的实例设为const，其效果是一样的。如果想改变这个对象，就会得到编译错误</li>
<li>如果底层对象是const，则转型去除const的操作可能会导致未定义行为，参见 不要转型去除const</li>
</ul>
<h3 id="默认情况下，成员函数应该声明为const"><a href="#默认情况下，成员函数应该声明为const" class="headerlink" title="默认情况下，成员函数应该声明为const"></a>默认情况下，成员函数应该声明为const</h3><ul>
<li><p>声明成员函数为const的做法有两个明显的好处。</p>
<ul>
<li>不可变的对象只能调用const成员函数</li>
<li>而const成员函数不能修改底层对象</li>
</ul>
</li>
<li><p>物理常量性(physical constness)</p>
<ul>
<li>对象被声明为const，因此不能被改变。它在内存中的表示方法是固定的</li>
</ul>
</li>
<li><p>逻辑常量性(logical constness)</p>
<ul>
<li>对象被声明为const，但可以被改变。它的逻辑值是固定的，但它在内存中的表示方式可能在运行期发生变化</li>
</ul>
</li>
</ul>
<h3 id="默认情况下，传递指向const对象的指针和引用"><a href="#默认情况下，传递指向const对象的指针和引用" class="headerlink" title="默认情况下，传递指向const对象的指针和引用"></a>默认情况下，传递指向const对象的指针和引用</h3><h3 id="使用const定义构造后值不可变的对象"><a href="#使用const定义构造后值不可变的对象" class="headerlink" title="使用const定义构造后值不可变的对象"></a>使用const定义构造后值不可变的对象</h3><ul>
<li>在并发环境中使用不可变数据和共享数据时，还有一个问题需要解决：必须以线程安全的方式初始化共享变量。对此，我能够想到至少四种做法<ul>
<li>在启动线程前初始化共享变量</li>
<li>使用函数std::call_once与标志std::once_flag</li>
<li>使用具有块作用域的static变量</li>
<li>使用constexpr变量</li>
</ul>
</li>
</ul>
<h3 id="对可以在编译期计算的值使用constexpr"><a href="#对可以在编译期计算的值使用constexpr" class="headerlink" title="对可以在编译期计算的值使用constexpr"></a>对可以在编译期计算的值使用constexpr</h3><ul>
<li>constexpr值可以提供更好的性能。会在编译期进行计算，并且永远不会受到数据竞争的影响。必须在编译期初始化constexpr值constexprValue</li>
</ul>
<h3 id="本章精华-9"><a href="#本章精华-9" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>默认情况下，使对象不可变。不可变对象不会受到数据竞争的影响。确保以线程安全的方式初始化这些对象</li>
<li>默认情况下，成员函数应声明为const。辨别你的对象是物理const还是逻辑const</li>
<li>不要用转型从原始const对象中去除const。如果你试图修改该对象，那这种转换是未定义行为</li>
<li>如果可能，把函数声明为constexpr。constexpr函数可以在编译期运行。它在编译期运行时是纯函数，并提供额外的优化机会</li>
</ul>
<h2 id="第十三章-模板和泛型编程"><a href="#第十三章-模板和泛型编程" class="headerlink" title="第十三章 模板和泛型编程"></a>第十三章 模板和泛型编程</h2><ul>
<li>暂不接触，不做记录</li>
</ul>
<h2 id="第十四章-C风格变成"><a href="#第十四章-C风格变成" class="headerlink" title="第十四章 C风格变成"></a>第十四章 C风格变成</h2><h3 id="优先使用C-而不是C"><a href="#优先使用C-而不是C" class="headerlink" title="优先使用C++而不是C"></a>优先使用C++而不是C</h3><ul>
<li>原因：C++提供更好的类型检查和更多的写法支持。它为高级编程提供了更好的支持，并往往生成更快的代码</li>
</ul>
<h3 id="完整的源代码可用"><a href="#完整的源代码可用" class="headerlink" title="完整的源代码可用"></a>完整的源代码可用</h3><h3 id="没有完成的源代码"><a href="#没有完成的源代码" class="headerlink" title="没有完成的源代码"></a>没有完成的源代码</h3><ul>
<li>使用C++编译期编译main函数<ul>
<li>与C编译期不同，C++编译期会生成在main函数之前执行的额外启动代码</li>
</ul>
</li>
<li>使用C++编译期链接程序</li>
<li>使用来自同一供应商的C和C++编译期</li>
</ul>
<h3 id="如果必须使用C作为接口，则调用此类接口的代码里使用C"><a href="#如果必须使用C作为接口，则调用此类接口的代码里使用C" class="headerlink" title="如果必须使用C作为接口，则调用此类接口的代码里使用C++"></a>如果必须使用C作为接口，则调用此类接口的代码里使用C++</h3><ul>
<li>通过使用extern “C”链接说明符，可以防止C++编译器重编这些名字。这样，你既可以从C++调用C函数，也可以从C调用C++函数</li>
<li>可以把extern “C”用在<ul>
<li>每个函数前</li>
<li>一个作用于内的每个函数</li>
<li>整个头文件(通过使用包含保护宏)。当使用C++编译器时，宏__cplusplus会被定义</li>
</ul>
</li>
</ul>
<h3 id="如果必须使用C，请使用C和C-的公共子集，并以C-的方式编译C代码"><a href="#如果必须使用C，请使用C和C-的公共子集，并以C-的方式编译C代码" class="headerlink" title="如果必须使用C，请使用C和C++的公共子集，并以C++的方式编译C代码"></a>如果必须使用C，请使用C和C++的公共子集，并以C++的方式编译C代码</h3><h3 id="本章精华-10"><a href="#本章精华-10" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>如果必须支持C代码，请使用C++编译器编译C代码。如果不可能那样做，请使用C++编译期编译main函数，并使用C++链接器链接程序。使用同一供应商的C和C++编译期</li>
<li>通过使用extern “C”链接说明符，可以防止C++编译器重编名字。这样，你既可以从C++调用C函数，也可以从C调用C++函数。</li>
</ul>
<h2 id="第十五章-源文件"><a href="#第十五章-源文件" class="headerlink" title="第十五章 源文件"></a>第十五章 源文件</h2><ul>
<li>我们应该区分代码的实现和接口</li>
<li>区分声明(用作接口)和定义(用作实现)。使用头文件表示接口并强调逻辑结构。</li>
</ul>
<h3 id="接口和实现文件"><a href="#接口和实现文件" class="headerlink" title="接口和实现文件"></a>接口和实现文件</h3><ul>
<li>声明或接口通常实现在*.h文件中，定义或实现则在*.cpp文件中</li>
</ul>
<h3 id="如果你的项目还没有采用其他约定，那代码文件使用-cpp后缀，接口文件使用-h后缀"><a href="#如果你的项目还没有采用其他约定，那代码文件使用-cpp后缀，接口文件使用-h后缀" class="headerlink" title="如果你的项目还没有采用其他约定，那代码文件使用.cpp后缀，接口文件使用.h后缀"></a>如果你的项目还没有采用其他约定，那代码文件使用.cpp后缀，接口文件使用.h后缀</h3><ul>
<li><p>头文件</p>
<ul>
<li>*.h</li>
<li>*.hpp</li>
<li>*.hxx</li>
<li>*.inl</li>
</ul>
</li>
<li><p>实现文件</p>
<ul>
<li>*.cpp</li>
<li>*.c</li>
<li>*.cc</li>
<li>*.cxx</li>
</ul>
</li>
</ul>
<h3 id="h文件不可含有对象定义或非内联函数定义"><a href="#h文件不可含有对象定义或非内联函数定义" class="headerlink" title=".h文件不可含有对象定义或非内联函数定义"></a>.h文件不可含有对象定义或非内联函数定义</h3><ul>
<li>单一定义定义规则，ODR是 One Definition Rule。下面是它在函数方面的规定<ul>
<li>一个函数在任何翻译单元中不能有一个以上的定义</li>
<li>一个函数在程序中不能有一个以上的定义</li>
<li>有外部链接的內联函数可以在一个以上的翻译单元中被定义。这些定义必须满足一个要求，它们全部相同</li>
</ul>
</li>
</ul>
<h3 id="cpp文件必须包含定义其接口的-h文件"><a href="#cpp文件必须包含定义其接口的-h文件" class="headerlink" title=".cpp文件必须包含定义其接口的.h文件"></a>.cpp文件必须包含定义其接口的.h文件</h3><h3 id="为所有的-h文件使用-include防护宏"><a href="#为所有的-h文件使用-include防护宏" class="headerlink" title="为所有的.h文件使用#include防护宏"></a>为所有的.h文件使用#include防护宏</h3><ul>
<li>通过在头文件首尾放置包含防护宏，头文件就只会被包含一次</li>
<li>有两点需要注意<ul>
<li>给你的防护宏一个唯一的名字。如果你多次使用同一个防护宏名字，可能导致本应该包含的头文件被排除在外</li>
<li>#pragma预处理指令不标准，但广泛受到支持。这个pragma指令意味着下面这种头文件的写法是不可被移植的</li>
</ul>
</li>
</ul>
<h3 id="避免源文件间的循环依赖"><a href="#避免源文件间的循环依赖" class="headerlink" title="避免源文件间的循环依赖"></a>避免源文件间的循环依赖</h3><ul>
<li>直接的解决方法是，在b.h中前置声明A，或者在a.h中前置声明B</li>
<li>标准库头文件 <iosfwd>中有标准输入&#x2F;输出的前置声明</li>
</ul>
<h3 id="避免对隐含-include-进来的名字的依赖"><a href="#避免对隐含-include-进来的名字的依赖" class="headerlink" title="避免对隐含 #include 进来的名字的依赖"></a>避免对隐含 #include 进来的名字的依赖</h3><h3 id="头文件应当是自包含的"><a href="#头文件应当是自包含的" class="headerlink" title="头文件应当是自包含的"></a>头文件应当是自包含的</h3><ul>
<li>一个自包含的头文件可被包含在翻译单元的最上面。</li>
<li>自包含的意思是，头文件不依赖于之前包含的其他文件。</li>
</ul>
<h3 id="仅对代码迁移，基础程序库-例如std-或者在局部作用域中使用using-namespace指令"><a href="#仅对代码迁移，基础程序库-例如std-或者在局部作用域中使用using-namespace指令" class="headerlink" title="仅对代码迁移，基础程序库(例如std)或者在局部作用域中使用using namespace指令"></a>仅对代码迁移，基础程序库(例如std)或者在局部作用域中使用using namespace指令</h3><ul>
<li>using指令隐藏了名称的来源，且破坏了代码的可读性</li>
</ul>
<h3 id="不要在头文件的全局作用域中使用using-namespace"><a href="#不要在头文件的全局作用域中使用using-namespace" class="headerlink" title="不要在头文件的全局作用域中使用using namespace"></a>不要在头文件的全局作用域中使用using namespace</h3><h3 id="使用namespace表示逻辑结构"><a href="#使用namespace表示逻辑结构" class="headerlink" title="使用namespace表示逻辑结构"></a>使用namespace表示逻辑结构</h3><h3 id="不要在头文件中使用无名-匿名-命名空间"><a href="#不要在头文件中使用无名-匿名-命名空间" class="headerlink" title="不要在头文件中使用无名(匿名)命名空间"></a>不要在头文件中使用无名(匿名)命名空间</h3><h3 id="为所有的内部-不导出的实体使用无名-匿名-命名空间"><a href="#为所有的内部-不导出的实体使用无名-匿名-命名空间" class="headerlink" title="为所有的内部&#x2F;不导出的实体使用无名(匿名)命名空间"></a>为所有的内部&#x2F;不导出的实体使用无名(匿名)命名空间</h3><ul>
<li><p>无名namespace使用内部链接。内部链接意味着无名namespace内的名称只能在当前的翻译单元内引用，而不能导出。这同样适用于在无名namespace中声明的名称</p>
</li>
<li><p>当你在头文件中使用无名namespace时，每个翻译单元都定义了这个无名namespace的唯一实例。头文件中的无名namespace会导致</p>
<ul>
<li>所产生的可执行文件大小膨胀</li>
<li>无名namespace中的任何声明都是指每个翻译单元中的不同实体。这可能不是无名所期望的行为</li>
</ul>
</li>
<li><p>无名namespace的用法类似于C语言里使用的static关键字</p>
</li>
</ul>
<h3 id="本章精华-11"><a href="#本章精华-11" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>头文件不应包含对象定义或非內联函数。它们应该是自包含的并且有#include防护宏。不要在头文件中使用using namespace</li>
<li>源文件应该包含必要的头文件，并且避免循环依赖</li>
<li>命名空间应该表达软件的逻辑结构。如果可能的话，应当避免使用using namespace指令以提升可读性</li>
</ul>
<h2 id="第十六章-标准库"><a href="#第十六章-标准库" class="headerlink" title="第十六章 标准库"></a>第十六章 标准库</h2><h3 id="优先采用STL的array或vector而不是C数组"><a href="#优先采用STL的array或vector而不是C数组" class="headerlink" title="优先采用STL的array或vector而不是C数组"></a>优先采用STL的array或vector而不是C数组</h3><ul>
<li><p>与C数组相比，std::vector的一大优势是可以自动管理内存</p>
</li>
<li><p>vector的大小是指它的元素数</p>
</li>
<li><p>容器的容量是指一个vector在没有额外的内存分配的情况下可以容纳的元素数</p>
</li>
<li><p>因此，一个vector的容量至少要和它的大小一样大。我们可以用方法resize来调整一个vector的大小，也可以用成员函数reserve来调整一个容器的容量</p>
</li>
<li><p>有几点需要说明</p>
<ul>
<li>容器大小和容量的调整是自动完成的，不需要使用任何像new和delete那样的内存操作</li>
<li>通过调用成员函数vec.resize(n)，如果 n &gt; vec.size()，那么vec这个vector里面的元素会默认初始化</li>
<li>通过使用成员函数vec.reserve(n)，如果n &gt; vec.capacity()，那么容器vec会获得至少能够容纳n个元素的新内存</li>
<li>shrink_to_fit的调用是没有约束力的。这意味着C++运行时并非必须按照容器的大小来调整其容量。但是到目前为止，在GCC， Clang或cl.exe汇总用到成员函数shrink_to_fit总是会释放掉不必要的内存</li>
</ul>
</li>
</ul>
<h3 id="默认应优先采用STL的vector，除非有理由使用别的容器"><a href="#默认应优先采用STL的vector，除非有理由使用别的容器" class="headerlink" title="默认应优先采用STL的vector，除非有理由使用别的容器"></a>默认应优先采用STL的vector，除非有理由使用别的容器</h3><ul>
<li><p>如果你想在运行期向你的容器中添加元素或者从你的容器中删除元素，请使用std::vector，否则，请使用std::array.</p>
</li>
<li><p>此外，std::vector可以比std::array大的多，因为它的元素会放在堆里。std::array使用的缓冲区则和使用它的上下文在一起</p>
</li>
<li><p>std::array和std::vector具有以下优点</p>
<ul>
<li>最快的通用访问(随机访问，包括对CPU向量化友好)</li>
<li>最快的默认访问模式(从头到尾或者从尾到头的访问对CPU缓存预取友好)</li>
<li>最低的空间开销(连续布局的每个元素额外开销为零，对CPU缓存友好)</li>
</ul>
</li>
</ul>
<h3 id="避免边界错误"><a href="#避免边界错误" class="headerlink" title="避免边界错误"></a>避免边界错误</h3><ul>
<li>C数组本身不支持检测边界错误。而STL的许多容器都支持一个容器检查边界的at成员函数。在访问一个不存在的元素的情况下，会抛出一个std::out_of_range异常</li>
<li>下面的容器都有一个带边界检查的at成员函数<ul>
<li>序列容器: std::array, std::vector和std::deque</li>
<li>关联容器: std::map 和 std::unordered_map</li>
<li>std::string</li>
</ul>
</li>
</ul>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ul>
<li>std::string : 拥有一个字符序列</li>
<li>std::string_view : 指向一个字符序列</li>
<li>char* : 指向单个字符</li>
<li>std::byte : 描述字节值(不一定是字符)</li>
<li>总结一下：<ul>
<li>只有std::string是一个所有者，其他的都是指向已有的文本</li>
</ul>
</li>
</ul>
<h3 id="使用std-string-来拥有字符序列"><a href="#使用std-string-来拥有字符序列" class="headerlink" title="使用std::string 来拥有字符序列"></a>使用std::string 来拥有字符序列</h3><h3 id="使用std-string-view来指向字符序列"><a href="#使用std-string-view来指向字符序列" class="headerlink" title="使用std::string_view来指向字符序列"></a>使用std::string_view来指向字符序列</h3><ul>
<li>std::string_view指向一个字符序列。说的明确一些，std::string_view并不拥有该字符序列。它代表的是一个子符序列的视图。这个字符序列可以是一个C++字符串或C字符串</li>
<li>std::string_view需要两样信息：指向字符序列的指针和长度。</li>
</ul>
<h3 id="用char-来指向单个字符"><a href="#用char-来指向单个字符" class="headerlink" title="用char*来指向单个字符"></a>用char*来指向单个字符</h3><h3 id="使用std-byte来指向未必表示字符的字节值"><a href="#使用std-byte来指向未必表示字符的字节值" class="headerlink" title="使用std::byte来指向未必表示字符的字节值"></a>使用std::byte来指向未必表示字符的字节值</h3><ul>
<li>std::byte(C++17)是实现C++语言定义中规定的字节概念的一个独立类型。这意味着字节即不是整数，也不是字符。</li>
<li>它的作用是访问对象存储。std::byte的接口包含了比特位逻辑操作的方法</li>
</ul>
<h3 id="对当作标准库string使用的字符串字面量使用后缀s"><a href="#对当作标准库string使用的字符串字面量使用后缀s" class="headerlink" title="对当作标准库string使用的字符串字面量使用后缀s"></a>对当作标准库string使用的字符串字面量使用后缀s</h3><ul>
<li>在C++14之前，没办法不用C字符串来创建C++字符串</li>
<li>到了C++14,我们有了C++字符串字面量，它们是C字符串字面量加上后缀s: “CstringLiteral”s</li>
</ul>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul>
<li><p>当你和外部世界交互时，有两个输入&#x2F;输出库发挥作用：</p>
<ul>
<li>基于流的I&#x2F;O库(简称为iostream库)</li>
<li>C风格I&#x2F;O函数</li>
</ul>
</li>
<li><p>当然你应该优先选择iostream库。</p>
<ul>
<li>iostream是一种用于流式I&#x2F;O的类型安全，可扩展，支持有格式和无格式输出的库。他支持多种(用户可扩展)缓冲策略和多种地域设置。它可被用于传统的I&#x2F;O，对内存的读写(字符串流)，以及用户定义的扩展，例如跨网络的流(asio)</li>
</ul>
</li>
</ul>
<h3 id="仅在必要时使用字符级输入"><a href="#仅在必要时使用字符级输入" class="headerlink" title="仅在必要时使用字符级输入"></a>仅在必要时使用字符级输入</h3><h3 id="当进行读取时，始终要考虑非法输入的情况"><a href="#当进行读取时，始终要考虑非法输入的情况" class="headerlink" title="当进行读取时，始终要考虑非法输入的情况"></a>当进行读取时，始终要考虑非法输入的情况</h3><ul>
<li>只有当流处于std::ios::goodbit状态时，对流的操作才会产生影响。当流处于std::ios::badbit状态时，它不能被重置为std::ios::goodbit状态</li>
</ul>
<h3 id="优先使用iostream进行I-O操作"><a href="#优先使用iostream进行I-O操作" class="headerlink" title="优先使用iostream进行I&#x2F;O操作"></a>优先使用iostream进行I&#x2F;O操作</h3><ul>
<li>printf和iostream库之间有一些微妙但是关键的区别<ul>
<li>printf的格式字符串指定格式和显式值的类型，而iostream库的格式操纵器只指定格式。</li>
<li>反过来说，在使用iostream库时，编译器会自动推断出正确的类型</li>
</ul>
</li>
</ul>
<h3 id="除非你要使用printf系列函数，否则应该调用ios-base-sync-with-stdio-false"><a href="#除非你要使用printf系列函数，否则应该调用ios-base-sync-with-stdio-false" class="headerlink" title="除非你要使用printf系列函数，否则应该调用ios_base::sync_with_stdio(false)"></a>除非你要使用printf系列函数，否则应该调用ios_base::sync_with_stdio(false)</h3><ul>
<li><p>默认情况下，对C++流的操作与C流的操作是同步的。这种同步发生在每个输入或输出操作之后</p>
<ul>
<li>C++流: std::cin, std::cout, std::cerr, std::clog, std::wcin, std::wcout, std::wcerr 和 std::wclog</li>
<li>C流: stdin, stdout 和 stderr</li>
</ul>
</li>
<li><p>这种同步允许混合C++和C的输入或输出操作，因为对C++流的操作会不加缓冲的进入C流中。</p>
</li>
<li><p>从并发的角度来看，还需要注意的是，同步的C++流是线程安全的。所有的线程都可以写到C++流，而不需要同步机制，有可能会出现字符交错的效果，但不会有数据竞争</p>
</li>
<li><p>当你设置std::ios_base::sync_with_stdio(false)时，C++流和C流之间的同步不会发生，因为C++流可能会把它们的输出放到一个缓冲区里。有了缓冲区之后，输入和输出的操作可能会变得更快。</p>
</li>
<li><p>你应该在任何输入或输出操作之前调用std::ios_base::sync_with_stdio(false)。如果不这样做，行为将由实现决定</p>
</li>
</ul>
<h3 id="避免使用endl"><a href="#避免使用endl" class="headerlink" title="避免使用endl"></a>避免使用endl</h3><ul>
<li>操纵器std::endl和’\n’之间有什么区别<ul>
<li>std::endl ： 写一个换行符并刷新输出缓冲区</li>
<li>‘\n’ : 写一个换行符</li>
</ul>
</li>
<li>刷新缓冲区操作代价较高，因此应该避免。如果有必要，缓冲区会被自动刷新</li>
</ul>
<h3 id="相关规则"><a href="#相关规则" class="headerlink" title="相关规则"></a>相关规则</h3><ul>
<li>理想情况下，程序应该是静态类型安全的</li>
<li>不要用单个指针来传递数组</li>
<li>保持指针的使用简单明了</li>
<li>避免对范围检查的需要</li>
</ul>
<h3 id="本章精华-12"><a href="#本章精华-12" class="headerlink" title="本章精华"></a>本章精华</h3><ul>
<li>使用std::array或std::vector而不是C数组。如果容器必须在运行其曾长，或者元素的数量对std::array来说太大，那么首选std::vector而不是std::array.std::vector和std::array支持使用at成员函数对元素进行安全访问</li>
<li>C++有多种文本支持方式。std::string文本的所有者，而std::string_view, const char *只是指向文本。另外,std::byte包含字节值(不一定是字符)</li>
<li>在输入&#x2F;输出功能方面，首选iostream库而不是C风格的函数。读取文本时，始终要考虑非法输入</li>
</ul>
<h2 id="第十七章-架构观念"><a href="#第十七章-架构观念" class="headerlink" title="第十七章 架构观念"></a>第十七章 架构观念</h2><h3 id="从不稳定的代码中分离稳定的代码"><a href="#从不稳定的代码中分离稳定的代码" class="headerlink" title="从不稳定的代码中分离稳定的代码"></a>从不稳定的代码中分离稳定的代码</h3><ul>
<li><p>格里不稳定的代码有助于单元测试，接口改进，重构和最终的废弃</p>
</li>
<li><p>在稳定的和不太稳定的代码之间放置一个接口是一种分离的方式。由于接口的存在，不稳定的代码变成了一种子系统，你可以单独测试或重构它。</p>
</li>
<li><p>这样你不仅可以测试子系统，还可以测试子系统和系统的集成。</p>
<ul>
<li>第一种测试通常被称为子系统测试</li>
<li>第二种测试通常被称为系统集成测试</li>
</ul>
</li>
<li><p>子系统有两个进入系统的通道： 功能通道和非功能通道。两者都必须被测试</p>
<ul>
<li>功能通道提供了子系统的功能</li>
<li>非功能通道则传播了可能发生的异常，系统可以对其作出反应。</li>
</ul>
</li>
<li><p>由于接口的存在，具体的子系统是接口的实现，因此可以很快被另一个可能更稳定的实现所代替</p>
</li>
</ul>
<h3 id="将潜在可复用的部分表达为程序库"><a href="#将潜在可复用的部分表达为程序库" class="headerlink" title="将潜在可复用的部分表达为程序库"></a>将潜在可复用的部分表达为程序库</h3><ul>
<li><p>基于 你不会需要它(you aren’t gonna need it, YANGNI)原则，不要在代码中预先投入过多的精力以使其成为可重用的库，而是要先写出代码，使其有可能被复用。</p>
</li>
<li><p>不要重复自己(DRY)原则，当你不止一次需要相同或者类似的功能时，它就会发生作用。这时，你应该考虑以下如何抽象。当我有两个类似的函数时，我会写第三个函数来提供实现，而那两个类似的函数则成为使用这个函数的封装</p>
</li>
<li><p>以库的形式编写可复用的软件，比做一次性的实现要花三到四倍的精力。</p>
</li>
<li><p>我的经验法则是，当知道你会重复使用某个功能时，应该考虑库的问题。而只有当你会重用某功能至少两次时，才应该把它写成一个库。</p>
</li>
</ul>
<h3 id="程序库之间不应该有循环依赖"><a href="#程序库之间不应该有循环依赖" class="headerlink" title="程序库之间不应该有循环依赖"></a>程序库之间不应该有循环依赖</h3><ul>
<li>库C1和C2之间的循环依赖使你的软件系统更加复杂<ul>
<li>重新包装C1和C2,使它们不再相互依赖</li>
<li>在物理上将C1和C2合并成一个单独组件C12</li>
<li>把C1和C2放在一起考虑，把两者当作一个单独组件C12</li>
</ul>
</li>
</ul>
<h2 id="第十八章-伪规则和误解"><a href="#第十八章-伪规则和误解" class="headerlink" title="第十八章 伪规则和误解"></a>第十八章 伪规则和误解</h2><h3 id="不要坚持认为声明都应当放在函数的最上面"><a href="#不要坚持认为声明都应当放在函数的最上面" class="headerlink" title="不要坚持认为声明都应当放在函数的最上面"></a>不要坚持认为声明都应当放在函数的最上面</h3><ul>
<li>这条规则是C89标准的遗留问题。C89不允许在语句之后声明一个变量。这导致变量声明和使用之间有很大的距离。<ul>
<li>将变量的声明放在其第一次使用之前</li>
<li>始终初始化一个变量，例如int i{}或者最好使用auto</li>
</ul>
</li>
</ul>
<h3 id="不要坚持在一个函数中只保留一条return语句"><a href="#不要坚持在一个函数中只保留一条return语句" class="headerlink" title="不要坚持在一个函数中只保留一条return语句"></a>不要坚持在一个函数中只保留一条return语句</h3><h3 id="不要避免使用异常"><a href="#不要避免使用异常" class="headerlink" title="不要避免使用异常"></a>不要避免使用异常</h3><ul>
<li><p>反对异常四个主要原因</p>
<ul>
<li>异常是低效的</li>
<li>异常会导致泄漏和错误</li>
<li>异常的性能不可预测</li>
<li>异常处理的运行需要太多空间</li>
</ul>
</li>
<li><p>通过使用异常，可以</p>
<ul>
<li>明确区分错误的返回和普通的返回</li>
<li>不会被遗忘或忽视</li>
<li>可以系统的使用</li>
</ul>
</li>
</ul>
<h3 id="不要坚持把每个类声明放在独立的源文件中"><a href="#不要坚持把每个类声明放在独立的源文件中" class="headerlink" title="不要坚持把每个类声明放在独立的源文件中"></a>不要坚持把每个类声明放在独立的源文件中</h3><ul>
<li>组织代码的合适方式并不是用文件，正确的方式是使用命名空间。</li>
<li>如果为每个类的声明使用一个独立的文件，将产生过多的文件，进而使你的程序更难管理，编译更慢</li>
</ul>
<h3 id="不要采用两阶段初始化"><a href="#不要采用两阶段初始化" class="headerlink" title="不要采用两阶段初始化"></a>不要采用两阶段初始化</h3><ul>
<li><p>显然，构造函数的工作很简单： 在执行构造函数之后，应该有一个完整初始化的对象</p>
</li>
<li><p>你也许经常使用构造函数来设置一个对象的默认行为。不要这样做，而应该直接在类的主题中设置对象的默认行为。</p>
</li>
<li><p>构造函数只是用来改变这些默认行为。参见 不要定义一个只初始化数据成员的默认构造函数，而应该使用成员初始化器</p>
</li>
</ul>
<h3 id="不要把所有清理操作放在函数末尾并使用goto-exit"><a href="#不要把所有清理操作放在函数末尾并使用goto-exit" class="headerlink" title="不要把所有清理操作放在函数末尾并使用goto exit"></a>不要把所有清理操作放在函数末尾并使用goto exit</h3><h3 id="不要使所有数据成员protected"><a href="#不要使所有数据成员protected" class="headerlink" title="不要使所有数据成员protected"></a>不要使所有数据成员protected</h3><ul>
<li>受保护的数据使程序变得复杂且容易出错。如果把受保护的数据放到基类中，你就不能孤立的仅根据派生类来推理，因此，你破坏了封装。</li>
<li>受保护的数据意味着你至少要回答以下三个问题<ul>
<li>我是否必须在派生类中实现一个构造函数来初始化受保护的数据</li>
<li>如果我使用受保护的数据，它的实际价值是什么</li>
<li>如果我修改受保护的数据，谁会受到影响</li>
</ul>
</li>
<li>类的层次越深，这些问题的答案就会变得越复杂</li>
<li>受保护的数据是类层次结构范围内的一种全局数据。而你知道，可变的，共享的状态非常糟糕。比如，它会使测试和并发的处理变得相当棘手</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC-Google/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC-Google/" class="post-title-link" itemprop="url">代码风格-Google</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>尽量避免前置声明那些定义在其他项目中的实体</p>
</li>
<li><p>只有当函数只有<code>10</code>行甚至更少时才将其定义为<strong>内联函数</strong></p>
</li>
<li><p><code>#include</code>的包含顺序：</p>
<ol>
<li><code>C</code>系统文件</li>
<li><code>C++</code>系统文件</li>
<li>其他库的<code>.h</code>文件</li>
<li>本项目内的<code>.h</code>文件</li>
</ol>
</li>
<li><p>局部变量：将函数变量尽可能置于最小作用域内，并在变量声明时进行初始化</p>
<ol>
<li><code>Warning</code>：有一个例外，如果变量是一个对象，每次进入作用域都要调用其构造函数，每次退出作用域都要调用其析构函数，这样会导致效率降低</li>
<li><code>Solution</code>：在循环作用域外面声明这类变量要高效的多</li>
</ol>
</li>
<li><p>类：构造函数不允许调用虚函数</p>
<ol>
<li>隐式类型转换：不要定义隐式类型转换，对于转换运算符和单参数构造函数，请使用<code>explicit</code>关键字</li>
<li>结构体和类：仅当只有数据成员时使用<code>struct</code>，其他一概使用<code>class</code></li>
</ol>
</li>
<li><p>编写简短函数：</p>
<ul>
<li>我们倾向于编写简短、凝练的函数。长函数有时是合理的，因此并不硬性限制函数的长度；</li>
<li>如果函数超过<code>40</code>行，可以思考一下能不能在不影响程序结构的前提下对其进行分割。</li>
</ul>
</li>
<li><p>所有按引用传递的参数必须加上<code>const</code></p>
</li>
<li><p>类型转换：使用<code>C++</code>的类型转换，如<code>static_cast&lt;&gt;()</code>,不要使用<code>int = (int)x</code></p>
</li>
<li><p>流：不要使用流，除非是日志接口需要；使用 <code>printf</code> 之类代替</p>
</li>
<li><p><code>const</code>变量，数据成员、函数和参数为编译时类型检测增加了一层保障，便于尽早发现错误，因此强烈建议在任何情况下使用<code>const</code></p>
</li>
<li><p>在<code>C++</code>中，用<code>constexpr</code>来定义真正的常量，或实现常量初始化</p>
</li>
<li><p>用<code>auto</code>绕过繁琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方</p>
</li>
<li><p>通用命名规则：函数命名、变量命名、文件命名要有描述性，少用缩写</p>
<ul>
<li><strong>文件名</strong>，要全部小写，包含下划线或连字符；</li>
<li><code>C++</code>文件要以<code>.cc</code>结尾，头文件以<code>.h</code>结尾</li>
<li><strong>类型名称</strong>，每个单词首字母均大写，不包含下划线，例如：<code>MyExcitingClass</code></li>
<li>变量名、函数参数和数据成员名一律小写，单词之间用下划线连接；</li>
<li>类的成员变量以下划线结尾，但结构体就不用，例如：<code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code></li>
<li>常量命名：声明为<code>constexpr</code>或<code>const</code>的变量，或在程序要运行期间其值始终保持不变的，<strong>命名时以k开头，大小写混合</strong>，例如：<code>const int kDaysInAWeek = 7</code>;</li>
<li>常规函数使用大小写混合，取值或设值函数则要求与变量名匹配，一般来说，<strong>函数名的每个单词首字母均大写</strong></li>
</ul>
</li>
<li><p>在每一个文件开头加入版权公告</p>
</li>
<li><p>每个类的定义都要附带一份注释，描述类的功能和用法，除非它的功能相当明显</p>
</li>
<li><p>函数注释，函数声明处的注释描述函数功能；定义处的注释描述函数实现</p>
</li>
<li><p>条件语句：不在圆括号内使用空间，关键字if和else另起一行</p>
</li>
<li><p>预处理指令：预处理指令不要缩进，从行首开始</p>
</li>
<li><p>不到万不得已，不要使用空行，函数之间的空行不要超出2行</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-UnixNetworkProgramming02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-UnixNetworkProgramming02/" class="post-title-link" itemprop="url">UnixNetworkProgramming02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-16 13:07:48" itemprop="dateModified" datetime="2025-06-16T13:07:48+08:00">2025-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li><p>IPC，是进程间通信(interprocess communication)的简称。传统上该术语描述的是运行在某个操作系统之上的不同进程间各种消息传递(message passing)的方式</p>
</li>
<li><p>在Unix操作系统过去三十年的演变史中，消息传递经历了如下几个发展阶段：</p>
<ul>
<li>管道(pipe，第四章)，是第一个广泛使用的IPC形式，既可在程序中使用，也可从shell中使用。管道的问题在于它们只能在具有共同祖先（指父子进程关系）的进程间使用，不过该问题已随有名管道(named pipe)既FIFO（第四章）的引入而解决了</li>
<li>System V消息队列(System V message queue，第六章)，是在20世纪80年代早期加到System V内核中的。它们可用在同一主机上有亲缘关系或无亲缘关系的进程之间。（谈论Unix进程时，有亲缘关系(related)的说法意味着所论及的进程具有某个共同的祖先。说的更明白点，这些有亲缘关系的进程是从该祖先进程经过一次或多次fork派生来的。我们还得注意，从理论上来说，所有Unix进程与init进程都有亲缘关系，它是系统自举时启动所有初始化进程的祖先进程。然而从实践上说，进程亲缘关系开始于一个登录shell（称为一个会话）以及由该shell派生的所有进程</li>
<li>Posix消息队列（Posix消息队列，第五章），是由Posix实时标准加入的，它们可用在同一主机上有亲缘关系和无亲缘关系的进程之间</li>
<li>远程过程调用（Remote Procedure Call，简称RPC，第五部分），出现在20世纪80年代中期，它是从一个系统（客户主机）上某个程序调用另一个系统（服务器主机）上某个函数的一种方法，是作为显式网络编程的一种替换方法开发的。既然客户和服务器之间通常传递一些信息（被调用函数的参数与返回值），而且RPC可用在同一主机上的客户和服务器之间，因此可认为RPC是另一种形式的消息传递</li>
</ul>
</li>
<li><p>看一看由Unix提供的各种同步形式的演变同样颇有效益</p>
<ul>
<li>需要某种同步形式（往往是为了防止多个进程同时修改同一文件）的早期程序使用了文件系统的诡秘特性</li>
<li>记录上锁（record locking，第九章），是在20世纪80年代早期加到Unix内核中的，然后在1988年由Posix.1标准化的</li>
<li>System V信号量（System V semaphore，第十一章），是在System V消息队列加入System V内核的同时（20世纪80年代早期）伴随System V共享内存区(System V shared memory)加入的。当今多数版本的Unix都支持它们</li>
<li>Posix信号量（Posix semaphore，第十章）和Posix共享内存区（Posix shared memory，第十三章）也由Posix实时标准加入</li>
<li>互斥锁(mutex)和条件变量(condition variable，第七章)，是由Posix线程标准定义的两种同步形式。尽管往往用于线程间的同步，它们也能提供不同进程间的同步</li>
<li>读写锁(read-write lock，第八章)，是另一种形式的同步。它们还没有被Posix标准化，不过也许不久后会被标准化</li>
</ul>
</li>
</ul>
<h3 id="1-2-进程，线程与信息共享"><a href="#1-2-进程，线程与信息共享" class="headerlink" title="1.2 进程，线程与信息共享"></a>1.2 进程，线程与信息共享</h3><ul>
<li><p>按照传统的Unix编程模型，我们在一个系统上运行多个进程，每个进程都有各自的地址空间</p>
</li>
<li><p>Unix进程间的信息共享可以有多种方式，总结：</p>
<ul>
<li>两个进程共享存留于文件系统中某个文件上的某些信息。为访问这些信息，每个进程都得穿越内核（例如read，write，lseek等）。当一个文件有待更新时，某种形式的同步是必要的，这样既可保护多个写入者，防止互相串扰，也可保护一个或多个读出者，防止写入者的干扰</li>
<li>两个进程共享驻留于内核中的某些信息。管道是这种共享类型的一个例子，System V消息队列和System V信号量也是。现在访问共享信息的每次操作涉及对内核的一次系统调用</li>
<li>两个进程有一个双方都能访问的共享内存区。每个进程一旦设置好该共享内存区，就能根本不涉及内核而访问其中的数据。共享该内存区的进程需要某种形式的同步</li>
</ul>
</li>
<li><p>需要注意的是，没有任何东西限制任何IPC技术只能使用两个进程。我们讲述的技术适用于任意数目的进程</p>
</li>
<li><p>虽然Unix系统中进程的概念已使用了很久，一个给定进程内多个线程（thread）的概念却相对较新。Posix.1线程标准（称为Pthreads）是于1995年通过的。</p>
</li>
<li><p>从IPC角度看来，一个给定进程内的所有线程共享同样的全局变量（也就是说共享内存区的概念对这种模型来说是内存在）。然而我们必须关注的是各个线程间对全局数据的同步访问。同步尽管不是一种明确的IPC形式，但它确实伴随许多形式的IPC使用，以控制对某些共享数据的访问</p>
</li>
<li><p>本书中，我们讲述进程间的IPC和线程间的IPC。我们假设有一个线程环境，并作类似如下形式的陈述：如果管道为空，调用线程就阻塞在它的read调用上，直到某个线程往该管道写入数据。要是你的系统不支持线程，那你可以将该句子中的”线程“替换成”进程“，从而提供“阻塞在对空管道的read调用上”的经典Unix定义。</p>
</li>
<li><p>然而在支持线程的系统上，只有对空管道调用read的那个线程阻塞，同一进程中的其余线程才可以继续执行。向该空管道写入数据的工作既可以由同一进程中的另一个线程去做，也可以由另一个进程中的某个线程去做</p>
</li>
</ul>
<h3 id="1-3-IPC对象的持续性"><a href="#1-3-IPC对象的持续性" class="headerlink" title="1.3 IPC对象的持续性"></a>1.3 IPC对象的持续性</h3><ul>
<li>我们可以把任意类型的IPC的持续性(persistence)定义成该类型的一个对象一直存在多长时间。以下有三种类型的持续性：<ul>
<li>随进程持续的(process-persistent)IPC对象，一直存在到打开着该对象的最后一个进程关闭该对象为止。例如管道和FIFO就是这种对象。</li>
<li>随内核持续的(kernel-persistent)IPC对象，一直存在到内核重新自举或显式删除该对象为止。例如System V的消息队列，信号量和共享内存区就是此类对象。Posix的消息队列，信号量和共享内存区必须至少是随内核持续的，但也可以是随文件系统持续的，具体取决于实现</li>
<li>随文件系统持续的(filesystem-persistent)IPC对象，一直存在到显式删除该对象为止。即使内核重新自举了，该对象还是保持其值。Posix消息队列，信号量和共享内存区如果是使用映射文件实现的（不是必需条件），那么它们就是随文件系统持续的</li>
</ul>
</li>
</ul>
<h3 id="1-4-名字空间"><a href="#1-4-名字空间" class="headerlink" title="1.4 名字空间"></a>1.4 名字空间</h3><ul>
<li>当两个或多个无亲缘关系的进程使用某种类型的IPC对象来彼此交换信息时，该IPC对象必须有一个某种形式的名字(name)或标识符(identifier)，这样其中一个进程（往往是服务器）可以创建该IPC对象，其余进程则可以指定同一个IPC对象</li>
<li>管道没有名字（因此不能用于无亲缘关系的进程间），但是FIFO有一个在文件系统中的Unix路径名作为其标识符（因此可用于无亲缘关系的进程间）。</li>
<li>对于一种给定的IPC类型，其可能的名字的集合称为它的名字空间(name space)。名字空间非常重要，因为对于除普通管道以外的所有形式的IPC来说，名字是客户与服务器彼此连接以交换消息的手段</li>
</ul>
<h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><ul>
<li>为分析各种特性，全书主要使用了三种交互模式：<ul>
<li>文件服务器：客户-服务器应用程序，客户向服务器发送一个路径名，服务器把该文件的内容返回给客户</li>
<li>生产者-消费者：一个或多个线程或进程（生产者）把数据放到一个共享缓冲区种，另有一个或多个线程或进程（消费者）对该共享缓冲区种的数据进行操作</li>
<li>序列号持续增1：一个或多个线程或进程给一个共享的序列号持续增1.该序列号有时在一个共享文件中，有时在共享内存区种</li>
</ul>
</li>
<li>第一个例子分析各种形式的消息传递，另外两个例子则分析各种类型的同步和共享内存区</li>
</ul>
<h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><ul>
<li>IPC传统上是Unix中一个杂乱不堪的领域，虽然有了各种各样的解决办法，但没有一个是完美的。我们的讨论分成四个主要领域：<ul>
<li>消息传递（管道，FIFO，消息队列）</li>
<li>同步（互斥锁，条件变量，读写锁，信号量）</li>
<li>共享内存区（匿名共享内存区，有名共享内存区）</li>
<li>过程调用（Solaris门，Sun RPC）</li>
</ul>
</li>
</ul>
<h2 id="Posix-IPC"><a href="#Posix-IPC" class="headerlink" title="Posix IPC"></a>Posix IPC</h2><h3 id="1-1-概述-1"><a href="#1-1-概述-1" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li>以下三种类型的IPC合称为 Posix IPC<ul>
<li>Posix消息队列（第五章）</li>
<li>Posix信号量（第十章）</li>
<li>Posix共享内存区（第十三章）</li>
</ul>
</li>
</ul>
<h3 id="1-2-小结"><a href="#1-2-小结" class="headerlink" title="1.2 小结"></a>1.2 小结</h3><ul>
<li>三种类型的Posix IPC：消息队列，信号量，共享内存区，都是用路径名标识的。但是这些路径名既可以是文件系统中的实际路径名，也可以不是，而这一点不一致性会导致一个移植性问题。全书采用的解决办法是使用我们自己的px_ipc_name函数</li>
<li>当创建或打开一个IPC对象时，我们指定一组类似于open函数所用的标志。创建一个新的IPC对象时，我们必须给这个新对象指定访问呢权限，所用的是同样由open函数使用的S_xxx常值</li>
</ul>
<h2 id="System-V-IPC"><a href="#System-V-IPC" class="headerlink" title="System V IPC"></a>System V IPC</h2><h3 id="1-1-概述-2"><a href="#1-1-概述-2" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li>以下三种类型的IPC合称为System V IPC<ul>
<li>System V消息队列（第六章）</li>
<li>System V信号量（第十一章）</li>
<li>System V共享内存区（第十四章）</li>
</ul>
</li>
<li>这个称谓作为这三种IPC机制的通常是因为它们源自System V Unix</li>
</ul>
<h2 id="管道和FIFO"><a href="#管道和FIFO" class="headerlink" title="管道和FIFO"></a>管道和FIFO</h2><h3 id="1-1-概述-3"><a href="#1-1-概述-3" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li>管道是最初的Unix IPC形式，可追溯到1973的Unix第三版。</li>
<li>尽管对于许多操作来说很有用，但它们的根据局限在于没有名字，从而只能由有亲缘关系的进程使用。这一点随FIFO的加入在System III Unix（1982年）中得以改正。FIFO有时称为有名管道(named pipe)。管道和FIFO都是使用通常的read和write函数访问的</li>
<li>技术上讲，自从可以在进程间传递描述符后，管道也能用于无亲缘关系的进程间。然而现实中，管道通常用于具有共同祖先的进程间</li>
</ul>
<h3 id="1-2-管道"><a href="#1-2-管道" class="headerlink" title="1.2 管道"></a>1.2 管道</h3><ul>
<li><p>所有式样的Unix都提供管道。它由pipe函数创建，提供一个单路（单向）数据流</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;unistd.h&gt;</code></li>
<li><code>int pipe(int fd[2]);</code></li>
</ul>
</li>
<li><p>该函数返回两个文件描述符：fd[0]和fd[1]。前者打开来读，后者打开来写</p>
</li>
<li><p>有些版本的Unix提供全双工管道，也就是说这些管道的两端都是即可用于读，也可用于写。创建一个全双工IPC管道的另一种方法是使用UNPV1的14.3节中讲述的socketpair函数，它在大多数现行Unix系统上都能工作。然而管道的最常见用途是用在各种shell中，这种情况下半双工管道足够了</p>
</li>
<li><p>尽管管道是由单个进程创建的，它却很少在单个进程内使用。管道的典型用途是以下述方式为两个不同进程（一个是父进程，一个是子进程）提供进程间的通信手段。</p>
<ul>
<li>首先，由一个进程（它将成为父进程）创建一个管道后调用fork派生一个自身的副本</li>
<li>接着，父进程关闭这个管道的读出端，子进程关闭同一管道的写入端。这就在父子进程间提供了一个单向数据流</li>
</ul>
</li>
<li><p>我们在某个Unix shell中输入一个像如下这样的命令时：<code>who | sort|lp</code>，该shell将执行上述步骤创建三个进程和其间的两个管道。它还把每个管道的读出端复制到相应进程的标准输入，把每个管道的写入端复制到相应进程的标准输出</p>
</li>
<li><p>到此为止所示的所有管道都是半双工的即单向的，只提供一个方向的数据流。当需要一个双向数据流时，我们必须创建两个管道，每个方向一个。实际步骤如下：</p>
<ul>
<li>创建管道1(fd1[0]和fd1[1])和管道2(fd2[0]和fd2[1])</li>
<li>fork</li>
<li>父进程关闭管道1的读出端(fd1[0])</li>
<li>父进程关闭管道2的写入端(fd2[1])</li>
<li>父进程关闭管道1的写入端(fd1[1])</li>
<li>父进程关闭管道2的读出端(fd2[0])</li>
</ul>
</li>
</ul>
<h3 id="1-3-FIFO"><a href="#1-3-FIFO" class="headerlink" title="1.3 FIFO"></a>1.3 FIFO</h3><ul>
<li>FIFO，指代先进先出(first in, first out)，Unix中的FIFO类似于管道。它是一个单项（半双工）数据流。不同于管道的是，每个FIFO有一个路径名与之关联，从而允许无亲缘关系的进程访问同一个FIFO。FIFO也称为有名管道(named pipe)</li>
<li>FIFO由mkfifo函数创建</li>
<li>声明：<ul>
<li><code>#include &lt;sys/types.h&gt;</code></li>
<li><code>#include &lt;sys/stat.h&gt;</code></li>
<li><code>int mkfifo(const char *pathname, mode_t mode);</code></li>
</ul>
</li>
<li>其中pathname，是一个普通的Unix路径名，它是该FIFO的名字</li>
<li>mode参数，指定文件权限位，类似于open的第二个参数</li>
<li>mkfifo函数，已隐含指定O_CREAT | O_EXCL。也就是说，它要么创建一个新的FIFO，要么返回一个EEXIST错误（如果所指定名字的FIFO已经存在）</li>
<li>在创建出一个FIFO后，它必须或者打开来读，或者打开来写。所用的可以是open函数，也可以是某个标准I&#x2F;O打开函数</li>
<li>对管道或FIFO的write总是往末尾添加数据，对他们的read则总是从开头返回数据。如果对管道或FIFO调用lseek，那就返回ESPIPE错误</li>
</ul>
<h3 id="1-4-管道和FIFO的额外属性"><a href="#1-4-管道和FIFO的额外属性" class="headerlink" title="1.4 管道和FIFO的额外属性"></a>1.4 管道和FIFO的额外属性</h3><ul>
<li><p>我们需要就管道和FIFO的打开，读出和写入更为详细地描述它们的某些属性。</p>
</li>
<li><p>首先，一个描述符能以两种方式设置成非阻塞</p>
<ul>
<li>调用open时可指定O_NONBLOCK标志</li>
<li>如果一个描述符已经打开，那么可以调用fcntl以启用O_NONBLOCK标志。对于管道来说，必须使用这种技术，因为管道没有open调用，在pipe调用中也无法指定O_NONBLOCK标志。使用fcntl时，我们先使用F_GETFL命令获取当前文件状态标志，将它与O_NONBLOCK标志按位或后，再使用F_SETFL命令存储这些文件状态标志</li>
</ul>
</li>
<li><p>关于管道或FIFO的读出与写入的若干额外规则：</p>
<ul>
<li>如果请求读出的数据量多余管道或FIFO中当前可用数据量，那么只返回这些可用的数据。我们必须准备好处理来自read的小于所请求数目的返回值</li>
<li>如果请求写入的数据的字节数小于或等于PIPE_BUF（一个Posix限制值），那么write操作保证是原子的。这意味着，如果有两个进程差不多同时往同一个管道或FIFO写，那么或者先写入来自第一个进程的所有数据，再写入来自第二个进程的所有数据，或者颠倒过来。系统不会互相混杂来自这两个进程的数据。然而，如果请求写入的数据的字节数大于PIPE_BUF，那么write操作不能保证是原子的。（Posix.1要求PIPE_BUF至少为512字节）</li>
<li>O_NONBLOCK标志的设置对write操作的原子性没有影响–原子性完全由所请求字节数是否小于等于PIPE_BUF决定的。然而当一个管道或FIFO设置成非阻塞时，来自write的返回值取决于待写的字节数以及该管道或FIFO中当前可用空间的大小。<ul>
<li>如果待写的字节数小于等于PIPE_BUF：<ul>
<li>如果该管道或FIFO中有足以存放所请求字节数的空间，那么所有数据字节都写入</li>
<li>如果该管道或FIFO中没有足以存放所请求字节数的空间，那么立即返回一个EAGAIN错误。既然设置了O_NONBLOCK标志，调用进程就不希望自己被投入睡眠中。但是内核无法在接受部分数据的同时仍保证write操作的原子性，于是它必须返回一个错误告诉调用进程以后再试</li>
</ul>
</li>
<li>如果待写的字节数大于PIPE_BUF;<ul>
<li>如果该管道或FIFO中至少有1字节空间，那么内核写入该管道或FIFO能容纳数目的数据字节，概述同时作为来自write的返回值</li>
<li>如果该管道或FIFO已满，那么立即返回一个EAGAIN错误</li>
</ul>
</li>
</ul>
</li>
<li>如果向一个没有为读打开着的管道或FIFO写入，那么内核将产生一个SIGPIPE信号：<ul>
<li>如果调用进程既没有捕获也没有忽略该SIGPIPE信号，所采取的默认行为就是终止该进程</li>
<li>如果调用进程忽略了该SIGPIPE信号，或者捕获了该信号并从其信号处理程序中返回，那么write返回一个EPIPE错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-5-字节流与消息"><a href="#1-5-字节流与消息" class="headerlink" title="1.5 字节流与消息"></a>1.5 字节流与消息</h3><ul>
<li><p>到此为止所给出的使用管道和FIFO的例子都使用字节流I&#x2F;O模型，这是Unix的原生I&#x2F;O模型。这种模型不存在记录边界，也就是说读写操作根本不检查数据。</p>
</li>
<li><p>举例来说，从某个FIFO中读出100个字节的进程无法判定往该FIFO中写入这100个字节的进程执行了单个100字节的写操作，5个20字节的写操作，2个50字节的写操作还是另外某种总共为100字节的写操作的组合。一个进程往该FIFO中写入55个字节后，另一个进程再写入45字节，这样的情况同样是可能的。</p>
</li>
<li><p>这样的数据是一个字节流(byte stream)，系统不对它作解释。如果需要某种解释，写进程和读进程就得先验地同意这种解释，并亲自去做。（由原因推结果）</p>
</li>
<li><p>有时候应用希望对所传送的数据加上某种结构。当数据由长度可变消息构成，并且读出者必须知道这些消息的边界以判定何时已读出单个消息时，这种需求可能发生。下面三种技巧经常用于这个目的：</p>
<ul>
<li>带内特殊终止序列：许多Unix应用程序使用换行符来分隔消息。写进程会给每个消息添加一个换行符，读进程则每次读出一行。这种技巧一般要求数据中任何出现分隔符处都作转义处理（也就是说以某种方式把它们标志成数据，而不是作为分隔符）。许多因特网应用程序（FTP, SMTP, HTTP, NNTP）使用由一个回车符后跟一个换行符构成双字符序列（CT&#x2F;LF）来分隔文本记录</li>
<li>显式长度：每个记录前冠以它的长度。我们将马上使用这种技巧。当用在TCP上时，Sun RPC也使用这种技巧。这种技巧的优势之一是不再需要通过转义出现在数据中的分隔符，因为接收者不必扫描整个数据以寻找每个记录的结束位置</li>
<li>每次连接一个记录：应用通过关闭与其对端的连接（网络应用时为TCP连接，IPC应用时为IPC连接）来指示一个记录的结束，。这要求为每个记录创建一个新连接，HTTP1.0就使用这一技术</li>
</ul>
</li>
<li><p>也可以更见更为结构化的消息，这种能力是由Posix消息队列和System V消息队列提供的。我们将看到每个消息有一个长度和一个优先级（System V成后者为类型）。长度和优先级是由发送者指定的，消息被读出后，这两者都返回给读出者。每个消息是一个记录(record)，类似于UDP数据报</p>
</li>
</ul>
<h3 id="1-6-管道和FIFO限制"><a href="#1-6-管道和FIFO限制" class="headerlink" title="1.6 管道和FIFO限制"></a>1.6 管道和FIFO限制</h3><ul>
<li>系统加于管道和FIFO的唯一限制为：<ul>
<li>OPEN_MAX  一个进程在任意时刻打开的最大描述符（Posix要求至少为16）</li>
<li>PIPE_BUF  可原子地写往一个管道或FIFO的最大数据量（Posix要求至少为512）</li>
</ul>
</li>
<li>我们马上会看到OPEN_MAX的值可通过调用sysconf函数查询。它通常可通过执行ulimit命令或limit命令从shell中修改，它也可以通过调用setrlimit函数从一个进程中修改</li>
<li>PIPE_BUF的值通常定义在<code>&lt;limits.h&gt;</code>头文件中，但是Posix认为它是一个路径名变量(pathname variable)。这意味着它的值可以随所指定的路径名而变化（只对FIFO而言，因为管道没有名字），因为不同的路径名可以落在不同的文件系统上，而这些文件系统可能有不同的特征。于是PIPE_BUF的值可在运行时通过调用pathconf或fpathconf取得</li>
</ul>
<h3 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h3><ul>
<li>管道和FIFO，是许多应用程序的基本构建模块。管道普遍用于shell中，不过也可以从程序中使用，往往是用于从子进程向父进程回传消息。使用管道时涉及的某些代码(pipe, fork, close, exec, waitpid)可通过使用popen和pclose来避免，由它们处理具体细节并激活一个shell</li>
<li>FIFO与管道类似，但是它们使用mkfifo创建的，之后需要open打开。打开管道时必须小心，因为有许多规则制约着open的阻塞与否</li>
<li>管道和FIFO的特征之一，是它们的数据是一个字节流，类似于TCP连接。把这种字节流分隔成各个记录的任何方法都得由应用程序来实现</li>
</ul>
<h2 id="Posix消息队列"><a href="#Posix消息队列" class="headerlink" title="Posix消息队列"></a>Posix消息队列</h2><h3 id="1-1-概述-4"><a href="#1-1-概述-4" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li>消息队列可认为是一个消息链表。有足够写权限的线程可往队列中放置消息，有足够读权限的线程可从队列中取走消息。每个消息都是一个记录，它由发送者赋予一个优先级。在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。这跟管道和FIFO是相反的，对于后者来说，除非读出者已存在，否则先有写入者是没有意义的。</li>
<li>一个进程可以往某个队列写入一些消息，然后终止，再让另外一个进程在以后某个时刻读出这些消息。我们说过消息队列具有随内核的持续性，这跟管道和FIFO不一样。我们在第四章中说过，当一个管道或FIFO的最后一次关闭发生时，仍在该管道或FIFO上的数据将被丢弃</li>
</ul>
<h3 id="1-2-mq-open-mq-close-mq-unlink函数"><a href="#1-2-mq-open-mq-close-mq-unlink函数" class="headerlink" title="1.2 mq_open, mq_close, mq_unlink函数"></a>1.2 mq_open, mq_close, mq_unlink函数</h3><ul>
<li><p>mq_open函数，创建一个新的消息队列或打开一个已存在的消息队列</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;mqueue.h&gt;</code></li>
<li><code>mqd_t mq_open(const char *name, int oflag, ... /* mode_t mode, struct mq_attr *attr*/);</code></li>
</ul>
</li>
<li><p>在2.2节描述过有关name参数的规则</p>
</li>
<li><p>oflag参数，是O_RDONLY, O_WRONLY, O_RDWR之一，可能按位或上O_CREAT, O_EXCL, O_NONBLOCK</p>
</li>
<li><p>当实际操作是创建一个新队列时（已指定O_CREAT标志，且所请求的消息队列尚未存在），mode和attr参数是需要的。attr参数，用于给新队列指定某些属性。如果它为空指针，那就使用默认属性</p>
</li>
<li><p>mq_open的返回值，称为消息队列描述符(message queue descriptor)，但它不必是（而且很可能不是）像文件描述符或套接字描述符这样的短整数。这个值用作其余7个消息队列函数的第一个参数</p>
</li>
<li><p>已打开的消息队列是由mq_close关闭的</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;mqueue.h&gt;</code></li>
<li><code>int mq_close (mqd_t mqdes);</code></li>
</ul>
</li>
<li><p>其功能与关闭一个已打开的close函数类似：调用进程可以不再使用该描述符，但其消息队列并不从系统中删除。一个进程终止时，它的所有打开着的消息队列都关闭，就像调用了mq_close一样</p>
</li>
<li><p>要从系统中删除用作mq_open的第一个参数的某个name，必须调用mq_unlink</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;mqueue.h&gt;</code></li>
<li><code>int mq_unlink(const char *name);</code></li>
</ul>
</li>
<li><p>每个消息队列有一个保存其当前打开着描述符数的引用计数器（就像文件一样），因而本函数能够实现类似于unlink函数删除一个文件的机制：当一个消息队列的引用计数仍大于0时，其name就能删除，但是该队列的析构（这与从系统中删除其名字不同）要到最后一个mq_close发生时才进行</p>
</li>
<li><p>Posix消息队列至少具备随内核的持续性。这就是说，即使当前没有进程打开着某个消息队列，该队列及其上的各个消息也将一直存在，直到调用mq_unlink并让它的引用计数达到0以删除该队列为止</p>
</li>
</ul>
<h3 id="1-3-mq-getattr和mq-setattr函数"><a href="#1-3-mq-getattr和mq-setattr函数" class="headerlink" title="1.3 mq_getattr和mq_setattr函数"></a>1.3 mq_getattr和mq_setattr函数</h3><ul>
<li>每个消息队列有四个属性，mq_getattr返回所有这些属性，mq_setattr则设置其中某个属性</li>
<li>声明：<ul>
<li><code>#include &lt;mqueue.h&gt;</code></li>
<li><code>int mq_getattr (mqd_t mqdes, struct mq_attr *attr);</code></li>
<li><code>int mq_setattr (mqd_t mqdes, const struct mq_attr *attr, struct mq_attr *oattr);</code></li>
</ul>
</li>
<li>mq_attr结构含有以下属性： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct mq_attr &#123;</span><br><span class="line">    long mq_flags;    /* message queue flag: 0, O_NONBLOCK */</span><br><span class="line">    long mq_maxmsg;   /* max number of messages allowed on queue */</span><br><span class="line">    long mq_msgsize;  /* max size of a message (in bytes) */</span><br><span class="line">    long mq_curmsgs;  /* number of messages currently on queue */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>mg_getattr把所指定队列的当前属性填入由attr指向的结构</li>
<li>mg_setattr给所指定队列设置属性，但是只使用由attr指向的mq_attr结构的mq_flags成员，以设置或清除非阻塞标志。该结构的另外三个成员被忽略：<ul>
<li>每个队列的最大消息数和每个消息的最大字节数只能在创建队列时设置</li>
<li>队列中的当前消息数则只能获取而不能设置</li>
</ul>
</li>
</ul>
<h3 id="1-4-mq-send和mq-receive函数"><a href="#1-4-mq-send和mq-receive函数" class="headerlink" title="1.4 mq_send和mq_receive函数"></a>1.4 mq_send和mq_receive函数</h3><ul>
<li>这两个函数分别用于往一个队列中放置一个消息和从一个队列中取走一个消息。每个消息有一个优先级，它是一个小于MQ_PRIO_MAX的无符号整数。Posix要求这个上限至少为32</li>
<li>声明：<ul>
<li><code>#include &lt;mqueue.h&gt;</code></li>
<li><code>int mq_send(mqd_t mqdes, const char *ptr, size_t len, unsigned int prio);</code></li>
<li><code>ssize_t mq_receive(mqd_t mqdes, char *ptr, size_t len, unsigned int *priop);</code></li>
</ul>
</li>
<li>mq_receive总是返回所指定队列中最高优先级的最早消息，而且该优先级能随该消息的内容及其长度一同返回</li>
<li>这两个函数的前三个参数分别与write和read的前三个参数类似</li>
<li>mq_receive的len参数的值不能小于能加到所指定队列中的消息的最大大小（该队列mq_attr结构的mq_msgsize成员）。要是len小于该值，mq_receive就立即返回EMSGSIZE错误。<ul>
<li>这意味着使用Posix消息队列的大多数应用程序必须在打开某个队列后调用mq_getattr确定最大消息大小，然后分配一个或多个那样大小的读缓冲区。通过要求每个缓冲区总是足以存放队列中的任意消息，mq_receive就不必返回消息是否大于缓冲区的通知</li>
</ul>
</li>
<li>mq_send的prio参数是待发送消息的优先级，其值必须小于MQ_PRIO_MAX。如果mq_receive的priop参数是一个非空指针，所返回消息的优先级就通过该指针存放。如果应用不必使用优先级不同的消息，那就给mq_send指定值为0的优先级，给mq_receive指定一个空指针作为其最后参数</li>
<li>待发送消息的大小和优先级必须作为命令行参数指定。所用缓冲区使用calloc分配，该函数会把该缓冲区初始化为0</li>
</ul>
<h3 id="1-5-消息队列限制"><a href="#1-5-消息队列限制" class="headerlink" title="1.5 消息队列限制"></a>1.5 消息队列限制</h3><ul>
<li><p>我们已遇到任意给定队列的两个限制，它们都是在创建该队列时建立的</p>
<ul>
<li>mq_maxmsg  队列中的最大消息数</li>
<li>mq_msgsize 给定消息的最大字节数</li>
</ul>
</li>
<li><p>消息队列的实现定义了另外两个限制：</p>
<ul>
<li>MQ_OPEN_MAX    一个进程能够同时拥有的打开着消息队列的最大数目（Posix要求它至少为8）</li>
<li>MQ_PRIO_MAX    任意消息的最大优先级值加1（Posix要求它至少为32）</li>
</ul>
</li>
<li><p>这两个常值往往定义在<code>&lt;unistd.h&gt;</code>头文件中，也可以在运行时通过调用sysconf函数获取</p>
</li>
</ul>
<h3 id="1-6-mq-notify函数"><a href="#1-6-mq-notify函数" class="headerlink" title="1.6 mq_notify函数"></a>1.6 mq_notify函数</h3><ul>
<li><p>第六章中讨论的System V消息队列的问题之一，是无法通知一个进程何时在某个队列中放置了一个消息。</p>
</li>
<li><p>我们可以阻塞在msgrcv调用中，但那将阻止我们在等待期间做其他任何事。如果给msgrcv指定非阻塞标志（IPC_NOWAIT），那么尽管不阻塞了，但必须持续调用该函数以确定何时有一个消息到达。我们说过着称为轮询(polling)，是对CPU时间的一种浪费。我们需要一种方法，让系统告诉我们何时有一个消息放置到了先前为空的某个队列中</p>
</li>
<li><p>Posix消息队列允许异步事件通知(asynchronous event notification)，以告知何时有一个消息放置到了某个空消息队列中。这种通知有两种方式可供选择：</p>
<ul>
<li>产生一个信号</li>
<li>创建一个线程来执行一个指定的函数</li>
</ul>
</li>
<li><p>这种通知通过调用mq_notify建立</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;mqueue.h&gt;</code></li>
<li><code>int mq_notify (mqd_t mqdes, const struct sigevent *notification);</code></li>
</ul>
</li>
<li><p>该函数为指定队列建立或删除异步事件通知。sigevent结构是随Posix.1实时信号新加的。该结构以及本章中引入的所有新的信号相关的常值都定义在<code>&lt;signal.h&gt;</code>头文件中</p>
</li>
<li><p>一些普遍适用于该函数的若干规则</p>
<ul>
<li>如果notification参数非空，那么当前进程希望在有一个消息到达所指定的先前为空的队列时得到通知。我们说：该进程被注册为接收该队列的通知</li>
<li>如果notification参数为空指针，而且当前进程目前被注册为接收所指定队列的通知，那么已存在的注册将被撤销</li>
<li>任意时刻只有一个进程可以被注册为接收某个给定队列的通知</li>
<li>当有一个消息到达某个先前为空的队列，而且已有一个进程被注册为接收该队列的通知时，只有在没有任何线程阻塞在该队列的mq_receive调用中的前提下，通知才会阿初。这就是说，在mq_receive调用中的阻塞比任何通知的注册都优先</li>
<li>当该通知被发送给它的注册进程时，其注册即被撤销。该进程必须再次调用mq_notify以重新注册（如果想要的话）</li>
</ul>
</li>
<li><p>更为简易（并且可能更为高效）的办法之一，是阻塞在某个函数中，仅仅等待该信号的递交，而不是让内核执行一个只为设置一个标志的信号处理程序。sigwait提供了这种能力</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;signal.h&gt;</code></li>
<li><code>int sigwait (const sigset_t *set, int *sig);</code></li>
</ul>
</li>
<li><p>调用sigwait前，我们阻塞某个信号集。我们将这个信号集指定为set参数。sigwait然后一直阻塞到这些信号中有一个或多个待处理，这时它返回其中一个信号。该信号值通过指针sig存放，函数的返回值则为0.这个过程称为：同步地等待一个异步事件。我们是在使用信号，但没有涉及异步信号处理程序</p>
</li>
</ul>
<h3 id="1-7-实时信号"><a href="#1-7-实时信号" class="headerlink" title="1.7 实时信号"></a>1.7 实时信号</h3><ul>
<li>在过去几十年中，Unix信号经历了多次重大的演变。信号可划分为两个大组<ul>
<li>其值在SIGRTMIN和SIGRTMAX之间（包括两者在内）的实时信号。Posix要求至少提供PTSIG_MAX这种实时信号，而该常值的最小值为8</li>
<li>所有其他信号：SIGALRM, SIGINT, SIGKILL，等等</li>
</ul>
</li>
</ul>
<h3 id="1-8-小结"><a href="#1-8-小结" class="headerlink" title="1.8 小结"></a>1.8 小结</h3><ul>
<li><p>Posix消息队列比较简单：</p>
<ul>
<li>mq_open创建一个新队列或打开一个已存在的队列</li>
<li>mq_close关闭队列</li>
<li>mq_unlink则删除队列名。</li>
<li>往一个队列中放置消息使用mq_send，从一个队列中读出消息使用mq_receive。</li>
<li>队列属性的查询与设置使用mq_getattr和mq_setattr，</li>
<li>函数mq_notify则允许我们注册一个信号或线程，它们在有一个消息被放置到某个空队列上时发送（信号）或激活（线程）。队列中的每个消息被赋予一个小整数优先级，mq_receive每次被调用时总是返回最高优先级的最早消息</li>
</ul>
</li>
<li><p>rnq_notify的使用给我们引入了Posix实时信号，它们在SIGRTMIN和SIGRTMAX之间。当设置SA_SIGINFO标志来安装这些信号的处理程序时</p>
<ul>
<li>这些信号是排队的</li>
<li>排了队的信号是以FIFO顺序递交的</li>
<li>给信号处理程序传递两个额外的参数</li>
</ul>
</li>
<li><p>最后，使用内存映射I&#x2F;O以及一个Posix互斥锁和一个Posix条件变量，以约500行C代码实现了Posix消息队列的大多数特性。该实现展示了处理新队列的创建中存在的一个竞争状态</p>
</li>
</ul>
<h2 id="互斥锁和条件变量"><a href="#互斥锁和条件变量" class="headerlink" title="互斥锁和条件变量"></a>互斥锁和条件变量</h2><h3 id="1-1-概述-5"><a href="#1-1-概述-5" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li>从本章开始关于同步的讨论：怎样同步多个线程或多个进程的活动。为允许在线程或进程间共享数据，同步通常是必需的。互斥锁和条件变量是同步的基本组成部分</li>
<li>互斥锁和条件变量出自Posix.1线程标准，它们总是可用来同步一个进程内的各个线程的。如果一个互斥锁或条件变量存放多个进程间共享的某个内存区中，那么Posix还允许它用于这些进程间的同步</li>
</ul>
<h3 id="1-2-互斥锁：上锁与解锁"><a href="#1-2-互斥锁：上锁与解锁" class="headerlink" title="1.2 互斥锁：上锁与解锁"></a>1.2 互斥锁：上锁与解锁</h3><ul>
<li>互斥锁指代互相排斥(mutual exclusion)，它是最基本的同步形式。互斥锁用于保护临界区(critical region)，以保证任何时刻只有一个线程在执行其中的代码（假设互斥锁由多个线程共享），或者任何时刻只有一个进程在执行其中的代码（假设互斥锁由多个进程共享）</li>
</ul>
<h3 id="1-3-对比上锁与等待"><a href="#1-3-对比上锁与等待" class="headerlink" title="1.3 对比上锁与等待"></a>1.3 对比上锁与等待</h3><ul>
<li>现在展示互斥锁用于上锁(locking)而不能用于等待(waiting)</li>
</ul>
<h3 id="1-4-条件变量：等待与信号发送"><a href="#1-4-条件变量：等待与信号发送" class="headerlink" title="1.4 条件变量：等待与信号发送"></a>1.4 条件变量：等待与信号发送</h3><ul>
<li>互斥锁用于上锁，条件变量则用于等待。这两种不同类型的同步都是需要的</li>
<li>条件变量是类型为pthread_cond_t的变量，以下两个函数使用了这些变量：<ul>
<li><code>#include &lt;pthread.h&gt;</code></li>
<li><code>int pthread_cond_wait(pthread_cond_t *cptr, pthread_mutex_t *mptr);</code></li>
<li><code>int pthread_cond_singal(pthread_cond_t *cptr);</code></li>
</ul>
</li>
<li>这两个函数所等待或由之得以通知的条件，其定义由我们选择：我们在代码中测试这种条件</li>
</ul>
<h3 id="1-5-小结-1"><a href="#1-5-小结-1" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><ul>
<li><p>互斥锁用于保护代码临界区，从而保证任何时刻只有一个线程在临界区内执行。有时候一个线程获得某个互斥锁后，发现自己需要等待某个条件变为真。如果是这样，该线程就可以等待在某个条件变量上。条件变量总是有一个互斥锁与之关联。把调用线程投入睡眠的pthread_cond_wait函数在这么做之前先给所关联的互斥锁解锁，以后某个时刻唤醒该线程前再给该互斥锁上锁。该条件变量由另外某个线程向它发送信号，而这个发送信号的线程即可以只唤醒一个线程(pthread_cond_signal)，也可以唤醒等待相应条件变为真的所有线程(pthread_cond_broadcast)</p>
</li>
<li><p>互斥锁和条件变量可以静态分配并静态初始化。它们也可以动态分配，那要求动态地初始化它们。动态初始化允许我们指定进程间共享属性，从而允许在不同进程间共享某个互斥锁或条件变量，其前提是该互斥锁或条件变量必须存放在由这些进程共享的内存区中</p>
</li>
</ul>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h2 id="记录上锁"><a href="#记录上锁" class="headerlink" title="记录上锁"></a>记录上锁</h2><h3 id="1-1-小结"><a href="#1-1-小结" class="headerlink" title="1.1 小结"></a>1.1 小结</h3><ul>
<li>fcntl记录上锁提供了对一个文件的劝告性或强制性上锁功能，而我们是通过该文件打开着的描述符来访问它的。这些锁用于不同进程间的上锁，而不是同一进程内不同线程间的上锁。</li>
<li>术语“记录”是个不确切的名字，因为Unix内核没有文件内记录的概念。更好的称谓是“范围上锁(range locking)”，因为我们上锁或解锁的是文件内的一个字节范围。这类记录上锁几乎都用作写作进程之间的劝告性锁，因为即使强制性上锁也会导致不一致数据</li>
</ul>
<h2 id="Posix信号量"><a href="#Posix信号量" class="headerlink" title="Posix信号量"></a>Posix信号量</h2><h3 id="1-1-概述-6"><a href="#1-1-概述-6" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li>信号量(semaphore)，是一种用于提供不同进程间或一个给定进程的不同线程间同步手段的原语。本书讨论三种类型的信号量：<ul>
<li>Posix有名信号量：使用Posix IPC名字标识，可用于进程或线程间的同步</li>
<li>Posix基于内存的信号量：存放在共享内存区中，可用于进程或线程间的同步</li>
<li>System V信号量：在内核中维护，可用于进程或线程间的同步</li>
</ul>
</li>
</ul>
<h3 id="1-2-小结-1"><a href="#1-2-小结-1" class="headerlink" title="1.2 小结"></a>1.2 小结</h3><ul>
<li>Posix信号量是计数信号量，它提供以下三种基本操作：<ul>
<li>创建一个信号量；</li>
<li>等待一个信号量的值变为大于0，然后将它的值减一；</li>
<li>给一个信号量的值加1，并唤醒等待该信号量的任意线程，以此挂出该信号量</li>
</ul>
</li>
<li>Posix信号量可以是有名的，也可以是基于内存的。有名信号量总是能够在不同进程间共享，基于内存的信号量则必须在创建时指定成是否在进程间共享。这两类信号量的持续性也有差别，有名信号量至少有随内核的持续性，基于内存的信号量则具有随进程的持续性</li>
</ul>
<h2 id="System-V信号量"><a href="#System-V信号量" class="headerlink" title="System V信号量"></a>System V信号量</h2><h2 id="共享内存区介绍"><a href="#共享内存区介绍" class="headerlink" title="共享内存区介绍"></a>共享内存区介绍</h2><h3 id="1-1-概述-7"><a href="#1-1-概述-7" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li><p>共享内存区是可用IPC形式中最快的。一旦这样的内存区映射到共享它的进程的地址空间，这些进程间数据的传递就不再涉及内核。然而往该共享内存区存放消息或从中取走消息的进程间通常需要某种形式的同步。我们在第三部分讨论了各种形式的同步：互斥锁，条件变量，读写锁，记录锁，信号量</p>
</li>
<li><p>这里说的“不再涉及内核”的含义是：进程不再通过执行任何进入内核的系统调用来彼此传递数据。显然，内核必须建立允许各个进程共享该内存区的内存映射关系，然后一直管理该内存区</p>
</li>
<li><p>考虑用来传递各种类型消息的一个实例客户-服务器文件复制程序中涉及的通常步骤：</p>
<ul>
<li>服务器从输入文件读。该文件的数据由内核读入自己的内存空间，然后从内核复制到服务器进程</li>
<li>服务器往一个管道，FIFO或消息队列以一条消息的形式写入这些数据。这些IPC形式通常需要把这些数据从进程复制到内核</li>
<li>客户从该IPC通道读出这些数据，这通常需要把这些数据从内核复制到进程</li>
<li>最后，将这些数据从由write函数的第二个参数指定的客户缓冲区复制到输出文件</li>
</ul>
</li>
<li><p>这里通常需要总共四次数据复制。而且这四次复制是在内核和某个进程间进行的，往往开销很大。</p>
</li>
<li><p>这些IPC形式（管道，FIFO和消息队列）的问题在于，两个进程要交换信息时，这些信息必须经由内核传递</p>
</li>
<li><p>通过让两个或多个进程共享一个内存区，共享内存区这种IPC形式提供了绕过上述问题的办法。当然，这些进程必须协调或同步对该共享内存区的使用。第三部分讲述的任何技巧都可用于这样的同步目的。前面的客户-服务器例子现在涉及的步骤如下：</p>
<ul>
<li>服务器使用（例如）一个信号量取得访问某个共享内存区对象的权力</li>
<li>服务器将数据从输入文件读入到该共享内存区对象。read函数的第二个参数所指定的数据缓冲区地址指向这个共享内存区对象</li>
<li>服务器读入完毕时，使用一个信号量通知客户</li>
<li>客户将这些数据从该共享内存区对象写出到输入文件中</li>
</ul>
</li>
</ul>
<h3 id="1-2-mmap，-munmap和msync函数"><a href="#1-2-mmap，-munmap和msync函数" class="headerlink" title="1.2 mmap， munmap和msync函数"></a>1.2 mmap， munmap和msync函数</h3><ul>
<li><p>mmap函数，把一个文件或一个Posix共享内存区对象映射到调用进程的地址空间。使用该函数有三个目的：</p>
<ul>
<li>使用普通文件以提供内存映射I&#x2F;O</li>
<li>使用特殊文件以提供匿名内存映射</li>
<li>使用shm_open以提供无亲缘关系进程间的Posix共享内存区</li>
</ul>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;sys/mman.h&gt;</code></li>
<li><code>void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);</code></li>
</ul>
</li>
<li><p>其中addr可以指定描述符fd应被映射到的进程内空间的起始地址。它通常被指定为一个空指针，这样告诉内核自己去选择起始地址。无论哪种情况下，该函数的返回值都是描述符fd所映射到内存区的起始地址</p>
</li>
<li><p>len是映射到调用进程地址空间中的字节数，它从被映射文件开头起第offset个字节处开始算。offset通常设置为0</p>
</li>
<li><p>内存映射区的保护由prot参数指定。该参数的常见值是代表读写访问的PROT_READ | PROT_WRITE</p>
<ul>
<li>PROT_READ  数据可读</li>
<li>PROT_WRITE 数据可写</li>
<li>PROT_EXEC  数据可执行</li>
<li>PROT_NONE 数据不可访问</li>
</ul>
</li>
<li><p>flags使用常值指定。MAP_SHARED或MAP_PRIVATE这两个标志必须指定一个，并可有选择地或上MAP_FIXED</p>
<ul>
<li>如果指定了MAP_PRIVATE，那么调用进程对被映射数据所作的修改只对该进程可见，而不改变其底层支撑对象（或者是一个文件对象，或者是一个共享内存区对象）</li>
<li>如果指定了MAP_SHARED，那么调用进程对被映射数据所作的修改对于共享该对象的所有基础南横都可见，而且确实改变了其底层支撑对象</li>
</ul>
</li>
<li><p>为从某个进程的地址空间删除一个映射关系，我们调用munmap</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;sys/mman.h&gt;</code></li>
<li><code>int munmap(void *addr, size_t len);</code></li>
</ul>
</li>
<li><p>其中addr参数是由mmap返回的地址，len是映射区的大小</p>
</li>
<li><p>如果我们修改了处于内存映射到某个文件的内存区中某个位置的内容，那么内核将在稍后某个时刻相应地更新文件。然而有时候我们希望确信硬盘上的文件内容与内存映射去中的内容一致，于是调用msync来执行这种同步</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;sys/mman.h&gt;</code></li>
<li><code>int msync (void *addr, size_t len, int flags);</code></li>
</ul>
</li>
<li><p>其中addr和len参数通常指代内存中的整个内存映射区，不过也可以指定该内存区的一个子集</p>
</li>
<li><p>flags参数是常值的组合</p>
<ul>
<li>MS_ASYNC    执行异步写</li>
<li>MS_SYNC     执行同步写</li>
<li>MS_INVALIDATE 使高速缓存的数据失效</li>
<li>MS_ASYNC和MS_SYNC这两个常值中必须指定一个，但不能都指定。它们的差别使，一旦写操作已由内核排入队列，MS_ASYNC即返回，而MS_SYNC则要等到写操作完成后才返回。如果还指定了MS_INVALIDATE，那么与其最终副本不一致的文件数据的所用内存中副本都失效，后续的引用将从文件中读取数据</li>
</ul>
</li>
<li><p>我们如此详尽地讨论mmap的理由有两个：</p>
<ul>
<li>一是文件的内存映射是一种很有用的技巧</li>
<li>二是Posix共享内存区也使用mmap</li>
</ul>
</li>
<li><p>Posix还定义了处理内存管理的四个额外函数：</p>
<ul>
<li>mlockall函数会使调用进程的整个内存空间常驻内存。munlockall则撤销这种锁定</li>
<li>mlock会使调用进程地址空间的某个指定范围常驻内存，该函数的参数指定了这个范围的起始地址以及从该地址算起的字节数。munlock则撤销某个指定内存区的锁定</li>
</ul>
</li>
</ul>
<h2 id="Posix共享内存区"><a href="#Posix共享内存区" class="headerlink" title="Posix共享内存区"></a>Posix共享内存区</h2><h3 id="1-1-概述-8"><a href="#1-1-概述-8" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li>Posix.1提供了两种在无亲缘关系进程间共享内存区的方法：<ul>
<li>内存映射文件(memory-mapped file)：由open函数打开，由mmap函数把得到的描述符映射到当前进程地址空间中的一个文件</li>
<li>共享内存区对象(shared-memory object)：由shm_open打开一个Posix.1 IPC名字（也许是在文件系统中的一个路径名），所返回的描述符由mmap函数映射到当前进程的地址空间</li>
</ul>
</li>
<li>这两种技术都需要调用mmap，差别在于作为mmap的参数之一的描述符的获取手段：通过open或通过shm_open。Posix把两者合称为内存区对象(memory object)</li>
</ul>
<h2 id="System-V-共享内存区"><a href="#System-V-共享内存区" class="headerlink" title="System V 共享内存区"></a>System V 共享内存区</h2><h2 id="门"><a href="#门" class="headerlink" title="门"></a>门</h2><h3 id="1-1-概述-9"><a href="#1-1-概述-9" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li><p>当讨论客户-服务器情形和过程调用时，存在着三种不同类型的过程调用：</p>
<ul>
<li>本地过程调用(local procedure call)。被调用的过程（函数）与调用过程处于同一个进程中。典型的情况是，调用者通过执行某条机器指令把控制传给新进程，被调用过程保存机器寄存器的值，并在栈顶分配存放其本地变量的空间</li>
<li>远程过程调用(remote procedure call, 简称RPC)：被调用过程和调用过程处于不同的进程中。我们通常称调用者为客户，称被调用者的过程为服务器。门(door)所提供的能力：一个进程调用同一台主机上另一个进程中的某个过程(函数)。通过给本进程内的某个过程创建一个门，一个进程（服务器）就使得该过程能为其他进程（客户）所调用</li>
<li>RPC通常允许一台主机上的某个客户调用另一台主机上的某个服务器过程。只要这两台主机以某种形式的网络连接着</li>
</ul>
</li>
<li><p>本地过程调用是同步的：调用者直到被调用过程返回后才重新获得控制。</p>
</li>
<li><p>线程可认为是提供了某种形式的异步过程调用：有一个函数被调用(pthread_create的第三个参数)，该函数和调用者看起来在同步执行。调用者可通过调用pthread_join等待这个新线程的完成。</p>
</li>
<li><p>远程过程调用可能是同步的，也可能是异步的，不过我们将看到门调用是同步的</p>
</li>
<li><p>在进程（客户或服务器）内部，门是用描述符标识的。在进程以外，门可能是用文件系统中路径名标识的。</p>
</li>
<li><p>一个服务器通过调用<code>door_create()</code>创建一个门，传递给该函数的参数是将与该门关联的过程的一个指针，该函数的返回值是新创建的门的一个描述符。</p>
</li>
<li><p>该服务器然后通过调用<code>fattach</code>给这个门描述符关联一个路径名。一个客户通过调用open来打开一个门，传递给该函数的参数是该门的服务器关联在其上的路径名，该函数的返回值是本客户访问该门的描述符。该客户然后通过调用door_call调用服务器过程。自然，某个门的服务器可以是另一个门的客户</p>
</li>
</ul>
<h3 id="1-2-door-create函数"><a href="#1-2-door-create函数" class="headerlink" title="1.2 door_create函数"></a>1.2 door_create函数</h3><ul>
<li>服务器进程通过调用door_create建立一个服务器过程</li>
<li>声明：<ul>
<li><code>#include &lt;door.h&gt;</code></li>
<li><code>typedef void Door_server_proc(void *cookie, char *dataptr, size_t datasize, door_desc_t *descptr, size_t ndesc);</code></li>
<li><code>int door_create(DOor_server_proc *proc, void *cookie, u_int attr);</code></li>
</ul>
</li>
<li>在上述的声明中，我们加上了自己的typedef，这样简化了服务器过程的函数原型。这个typedef语句说，们服务器过程是以五个参数调用的，不返回任何值</li>
</ul>
<h3 id="1-3-door-return函数"><a href="#1-3-door-return函数" class="headerlink" title="1.3 door_return函数"></a>1.3 door_return函数</h3><ul>
<li>服务器过程完成工作时通过调用door_return返回。这会使客户中相关联的door_call调用返回</li>
<li>声明<ul>
<li><code>#include &lt;door.h&gt;</code></li>
<li><code>int door_return(char *dataptr, size_t datasize, door_desc_t *descptr, size_t *ndesc);</code></li>
</ul>
</li>
<li>数据结果由dataptr和datasize指定，描述符结果由descptr和ndesc指定</li>
</ul>
<h3 id="1-4-door-cred函数"><a href="#1-4-door-cred函数" class="headerlink" title="1.4 door_cred函数"></a>1.4 door_cred函数</h3><ul>
<li>门有一个很不错的特性：服务器过程能够获取每个调用对应的客户凭证。这是由door_cred函数完成的。</li>
<li>声明：<ul>
<li><code>#include &lt;door.h&gt;</code></li>
<li><code>int door_cred(door_cred_t *cred);</code></li>
</ul>
</li>
<li>其中由cread指向的door_cred_t结构将在返回时填入客户的凭证</li>
</ul>
<h3 id="1-5-door-info函数"><a href="#1-5-door-info函数" class="headerlink" title="1.5 door_info函数"></a>1.5 door_info函数</h3><ul>
<li>我们刚才描述的door_cred函数给服务器提供关于客户的信息。客户也可通过调用door_info函数找出有关服务器的信息</li>
<li>声明<ul>
<li><code>#include &lt;door.h&gt;</code></li>
<li><code>int door_info(int fd, door_info_t *info);</code></li>
</ul>
</li>
<li>其中fd指定一个已打开的门。由info指向的door_info_t结构将在返回时填入关于服务器的信息</li>
</ul>
<h3 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h3><ul>
<li>门提供了调用同一台主机上另一个进程中某个过程的能力。下一章中我们将对这种远程过程调用概念加以扩展，讲述如何调用另一台主机上另一个过程中的某个进程</li>
<li>基本的API函数比较简单。服务器调用door_create创建一个门，并给他关联一个服务器过程，然后调用fattach给该门附接一个文件系统中的路径名。客户对该路径名调用open，然后调用door_call以调用服务器进程中的服务器进程。该服务器过程通过调用door_return返回</li>
<li>门允许从客户向服务器以及从服务器向客户传递描述符。这是一个非常有用的技巧，因为Unix中描述符代表着许多访问手段：<ul>
<li>访问文件以进行文件或设备I&#x2F;O</li>
<li>访问套接字或XTI以进行网络通信</li>
<li>访问门以进行远程过程调用</li>
</ul>
</li>
</ul>
<h2 id="Sun-RPC"><a href="#Sun-RPC" class="headerlink" title="Sun RPC"></a>Sun RPC</h2><h3 id="1-1-概述-10"><a href="#1-1-概述-10" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li><p>构筑一个应用程序时，我们首先在以下两者之间做出选择：</p>
<ul>
<li>构建一个庞大的单一程序，完成全部工作</li>
<li>把整个应用程序散步在彼此通信的多个进程中</li>
</ul>
</li>
<li><p>如果我们选择后者，接下去的抉择是：</p>
<ul>
<li>假设所有进程运行在同一台主机上（允许IPC用于这些进程间的通信）；</li>
<li>假设某些进程会运行在其他主机上（要求使用进程间某种形式的网络通信）</li>
</ul>
</li>
<li><p>本书的大部分关注的是：使用消息传递，共享内存区，并可能使用某种形式的同步来进行同一台主机上的进程间IPC。同一进程内不同线程间的IPC以及不同进程内各个线程间的IPC只是这种情况的特殊情况</p>
</li>
<li><p>不同部分之间需要网络通信的应用程序大多数是使用显示网络编程(explicit network programming)方式编写的，也就是直接调用套接字API或XTI API。使用套接字API时，客户调用socket，connect，read和write；服务器则调用socket，bind，listen，accept，read和write。我们熟悉的大多数应用程序（Web浏览器，web服务器，Telnet客户，Telnet服务器等程序）就是以这种方式编写的。</p>
</li>
<li><p>编写分布式应用程序的另一种方式是使用隐式网络编程(implicit network programming)。远程过程调用（RPC）提供了这样的一个工具</p>
</li>
</ul>
<h3 id="1-2-小结-2"><a href="#1-2-小结-2" class="headerlink" title="1.2 小结"></a>1.2 小结</h3><ul>
<li>Sun RPC允许我们编写分布式应用程序，让客户运行在一台主机上，服务器运行在另一台主机上。</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>本书详细讲述了用于进程间通信(IPC)的四种不同技术：</p>
<ul>
<li>消息传递（管道，FIFO，Posix和System V消息队列）</li>
<li>同步（互斥锁，条件变量，读写锁，文件和记录锁，Posix和System V信号量）</li>
<li>共享内存区（匿名共享内存区，有名Posix共享内存区，有名System V共享内存区）</li>
<li>过程调用（Solaris门，Sun RPC）</li>
</ul>
</li>
<li><p>消息队列和过程调用往往单独使用，也就是说它们通过提供了自己的同步机制。相反，共享内存区通常需要某种由应用程序提供的同步形式才能正确工作。同步技术有使用单独使用，也就是说不涉及其他形式的IPC</p>
</li>
<li><p>讨论了共十六章的细节后，很显然的一个问题是：解决某个待定问题应使用哪种形式的IPC？</p>
</li>
<li><p>遗憾的是不存在关于IPC的简单判定。Unix提供的类型如此之多的IPC表明，不存在解决全部（或者甚至于大部分）问题的单一方法。</p>
</li>
<li><p>你能做的仅仅是：逐渐熟悉各种IPC形式提供的机制，然后根据特定应用的要求比较它们的特性</p>
</li>
<li><p>我们首先列出必须考虑的四个前提，因为它们对于你的应用程序相当重要：</p>
<ul>
<li>连网的(networked)还是非连网的(nonnetworked)。我们假设已作出这个决定，IPC就是用于单台主机上的进程或线程间的。如果应用程序有可能散布多台主机上，那就考虑使用套接字代替IPC，从而简化以后向连网的应用程序转移的工作</li>
<li>可移植性(portability)。几乎所有Unix系统都支持Posix管道，Posix FIFO和Posix记录上锁。几乎所有Unix系统都可使用Sun RPC，门则是Solaris特有的特性</li>
<li>性能(performance)。如果性能是应用程序设计中的一个关键前提，那就在你自己的系统上运行附录A中开发的程序。更好的做法是，把这些程序修改称模拟待定应用的实际环境，再再这样的环境中测量它们的性能</li>
<li>实时调度(realtime scheduling)。如果你的应用需要这一特性，而且你的系统支持Posix实时调度选项，那就考虑使用Posix的消息传递和同步函数（消息队列，信号量，互斥锁，条件变量）。举例来说，当某个线程挂出一个有多个线程阻塞在其上的信号量时，待解阻塞的线程是以一种适合于所阻塞线程的调度策略和参数的方式选择的。相反，System V信号量不能保证实时调度</li>
</ul>
</li>
<li><p>为了帮助理解各种类型IPC的一些特性和局限，我们汇总了它们的一些主要差异：</p>
<ul>
<li>管道和FIFO是字节流，没有消息边界。Posix消息和System V消息则有从发送者向接收者维护的记录边界。（TCP是没有记录边界的字节流，UDP则提供具有记录边界的消息）</li>
<li>当有一个消息放置到一个空队列中时，Posix消息队列可向一个进程发送一个信号，或者启动一个新的线程。System V</li>
<li>消息队列不提供类似的通知形式。这两种消息队列都不能直接跟select和poll一起使用，不过我们分别在图5-14和6.9节中提供了间接的方法</li>
<li>管道或FIFO中的数据字节是先进先出的。Posix消息和System V消息具备由发送者赋予的优先级。从一个Posix消息队列读出消息时，首先返回的总是具有最高优先级的消息。从一个System V消息队列读出时，读出者可以请求所想要的任意优先级的消息</li>
<li>当有一个消息放置到一个Posix或System V消息队列，或者写到一个管道胡FIFO时，只有一个副本递交给刚好一个线程。这些IPC形式不存在窥探能力（即类似于套接字API的MSG_PEEK标志，UNPV1的13.7节），它们的消息不能广播或多播到多个接收者（这对于使用UDP协议的套接字程序和XTI程序时可能的，UNPv1第十八章和第十九章</li>
<li>互斥锁，条件变量和读写锁都是无名的，也就是说，它们是基于内存的。它们能够很容易地在单个进程内的不同线程间共享。然而只有当它们存放在不同进程间共享的内存区中时，它们才有可能为这些进程所共享。而Posix信号量就有两种形式：有名的和基于内存的。有名信号量总能在不同进程间共享（因为它们是用Posix IPC名字标识的），基于内存的信号量也能在不同进程间共享，条件是必须村房子这些进程间共享的内存区中。System V信号量也是有名的，不过所用的是key_t数据类型，它往往是从某个文件的路径名获取的。这些信号量能够很容易地在不同进程间共享</li>
<li>如果持有某个锁的进程没有释放它就终止，内核就自动释放fcntl记录锁。System V信号量将这一特性作为一个选项提供。互斥锁，条件变量，读写锁和Posix信号量不具备该特性</li>
<li>每个fcntl锁都与通过其相应描述符访问的文件中的某个字节范围（我们称之为一个“记录”）相关联。读写锁则不与任何类型的记录关联</li>
<li>Posix共享内存区和System V共享内存区都具有随内核的持续性。它们一直存在到被显式地删除为止，即使当前没有任何进程在使用它们也这样</li>
<li>Posix共享内存区对象的大小可在其使用期间扩张。System V共享内存区的大小则是在创建时固定下来的</li>
<li>System V IPC所存在的三种内核限制往往需要系统管理员对它们进行调整，因为它们的默认值通常不能满足现实应用的需要（3.8节）。Posix IPC所存在的三种内核限制则通常根本不需要调整</li>
<li>有关System V IPC对象的信息（当前大小，属主ID，最后修改时间等等）可使用三个XXXctl函数的IPC_STAT命令获取，也可执行ipcs命令获取。有关Posix IPC对象的信息则不存在标准的获取方式。如果这些对象是用文件系统中的文件实现的，而且我们知道从Posix IPC名字到路径名的映射关系，那么这些对象的信息可使用stat函数或ls命令获取。但是如果这些对象不是使用文件实现的，那么可能获取不了这样的信息</li>
<li>在众多的同步技术–互斥锁，条件变量，读写锁，记录锁，Posix信号量和System V信号量中，可从信号处理程序中调用的函数只有sem_post和fcntl</li>
<li>在众多的消息传递技术：管道，FIFO，Posix消息队列和System V消息队列中，可从一个信号处理程序中调用的函数只有read和write（适用于管道和FIFO）</li>
<li>在所有的消息传递技术中，只有门向服务器准确地提供了客户的标识（15.5节）.在5.4节中我们提到过，另外两种消息传递类型也标识客户：BSD&#x2F;OS在使用Unix域套接字时提供这种标识（UNPv1的15.2节），SVR4则在通过某个管道传递一个描述符时通过同一个管道传递发送者的标识</li>
</ul>
</li>
</ul>
<h2 id="性能测量"><a href="#性能测量" class="headerlink" title="性能测量"></a>性能测量</h2><h3 id="1-1-概述-11"><a href="#1-1-概述-11" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li><p>本书讨论了六种类型的消息传递：</p>
<ul>
<li>管道</li>
<li>FIFO</li>
<li>Posix消息队列</li>
<li>System V消息队列</li>
<li>门</li>
<li>Sun RPC</li>
</ul>
</li>
<li><p>五种类型的同步</p>
<ul>
<li>互斥锁和条件变量</li>
<li>读写锁</li>
<li>fcntl记录上锁</li>
<li>Posix信号量</li>
<li>System V信号量</li>
</ul>
</li>
<li><p>我们现在开发一些简单的程序来测量这些IPC类型的性能，这样有助于我们就何时该使用某种特定形式的IPC做出明智的决策</p>
</li>
<li><p>比较不同形式的消息传递时，我们感兴趣的是以下两种测量尺度：</p>
<ul>
<li>带宽(bandwidth)：数据通过IPC通道转移的速度。为测量该值，我们从一个进程向另一个进程发送大量数据（几百万字节）。我们还给不同大小的I&#x2F;O操作测量该值，期待发现带宽随每个I&#x2F;O操作数据量的增长而增长的规律</li>
<li>延迟(latency)：一个小的IPC消息从一个进程到另一个进程再返回所花的时间。我们测量的是只有一个字节的消息从一个进程到另一个进程再回来的时间（往返时间）</li>
</ul>
</li>
<li><p>在现实世界中，带宽高速我们大块数据通过一个IPC通道发送出去需花多长时间，然而IPC也由于传送小的控制信息，系统处理这些小消息所需的时间就由延迟提供。这两个数都很重要。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
