<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/25/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/25/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/CMake/cmake_99_%E5%85%B6%E4%BB%96/2024-05-22-cmake_3_%E6%9D%82%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/CMake/cmake_99_%E5%85%B6%E4%BB%96/2024-05-22-cmake_3_%E6%9D%82%E9%A1%B9/" class="post-title-link" itemprop="url">cmake_3_杂项</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="cmake自定义模块-Module"><a href="#cmake自定义模块-Module" class="headerlink" title="cmake自定义模块(Module)"></a>cmake自定义模块(Module)</h3><ul>
<li>项目一般从CMakelists.txt开始编写，但是随着时间的推移，CMakeLists.txt文件会变得越来越大，这个时候我们就需要将CMakeLists.txt文件拆开分成几个小的模块，这样做的好处是<ul>
<li>主文件CMakeList.txt易读性强</li>
<li>CMake模块能够在其他项目中重复使用</li>
<li>和CMake的函数相比，模块能够帮助我们限制变量的作用域</li>
</ul>
</li>
</ul>
<h3 id="cmake-指定C-版本"><a href="#cmake-指定C-版本" class="headerlink" title="cmake 指定C++版本"></a>cmake 指定C++版本</h3><ul>
<li><p>在 CmakeLists.txt 中增加对 C++ 版本的定义。方法如下：</p>
<ul>
<li><code>SET(CMAKE_CXX_STANDARD 11)</code></li>
</ul>
</li>
<li><p>生成 Makefile 的时候指定,方法如下:</p>
<ul>
<li><code>cmake -DCMAKE_CXX_STANDARD=11 ..</code></li>
</ul>
</li>
</ul>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul>
<li>foreach:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set(VAR a b c)</span><br><span class="line"> </span><br><span class="line">foreach(f $&#123;VAR&#125;)</span><br><span class="line">  message($&#123;f&#125;)</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="cmake-加入调试信息"><a href="#cmake-加入调试信息" class="headerlink" title="cmake 加入调试信息"></a>cmake 加入调试信息</h3><ul>
<li>首先，加入：<code>SET(CMAKE_BUILD_TYPE &quot;Debug&quot;)</code></li>
<li>然后在下面加入：<ul>
<li><code>SET(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb&quot;)</code></li>
<li><code>SET(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;)</code></li>
</ul>
</li>
</ul>
<h3 id="execute-process"><a href="#execute-process" class="headerlink" title="execute_process()"></a>execute_process()</h3><ul>
<li><p>execute_process 命令将从当前正在执行的CMake进程中派生一个或多个子进程，从而提供了在配置项目时运行任意命令的方法。可以在一次调用 execute_process 时执行多个命令。但请注意，每个命令的输出将通过管道传输到下一个命令中。该命令接受多个参数：</p>
<ul>
<li><code>COMMAND</code>：子进程命令行。</li>
<li><code>WORKING_DIRECTORY</code>：指定应该在哪个目录中执行命令。</li>
<li><code>TIMEOUT</code>：如果在指定的时间内（以秒为单位计算，允许有小数位）子进程执行仍未完成，则将会被中断。</li>
<li><code>RESULT_VARIABLE</code>：包含进程运行的结果。这要么是一个整数表示执行成功，要么是一个带有错误条件的字符串。</li>
<li><code>RESULTS_VARIABLE</code>：变量将被设置为以分号分隔的列表形式包含所有进程的结果，按给定命令参数的顺序排列。每个条目都是对应子项的整数返回码或描述错误条件的字符串。</li>
<li><code>OUTPUT_VARIABLE</code>和<code>ERROR_VARIABLE</code>将包含执行命令的标准输出和标准错误。由于命令的输出是通过管道传输的，因此只有最后一个命令的标准输出才会保存到OUTPUT_VARIABLE中。</li>
<li><code>INPUT_FILE</code> 指定标准输入重定向的文件名。</li>
<li><code>OUTPUT_FILE</code> 指定标准输出重定向的文件名。</li>
<li><code>ERROR_FILE</code> 指定标准错误输出重定向的文件名</li>
<li><code>设置OUTPUT_QUIET和ERROR_QUIET</code>后，CMake将静默地忽略标准输出和标准错误。</li>
<li><code>COMMAND_ECHO &lt;where&gt;</code>：正在运行的命令将被回送到<code>&lt;where&gt;</code>，而<code>&lt;where&gt;</code>将被设置为STDERR、STDOUT或NONE中的一个。</li>
<li><code>设置OUTPUT_STRIP_TRAILING_WHITESPACE</code>，可以删除运行命令的标准输出中的任何尾随空 格。</li>
<li><code>设置ERROR_STRIP_TRAILING_WHITESPACE</code>，可以删除运行命令的错误输出中的任何尾随空格。</li>
<li><code>ENCODING &lt;name&gt;</code>：适用于windows平台，编码名称有NONE、AUTO、ANSI、OEM、UTF8或UTF-8。</li>
<li><code>ECHO_OUTPUT_VARIABLE, ECHO_ERROR_VARIABLE</code>：标准输出或标准错误不会被专门重定向到配置的变量。</li>
<li><code>COMMAND_ERROR_IS_FATAL &lt;ANY|LAST&gt;</code>：<ul>
<li><code>ANY</code>：如果命令列表中的任何命令失败，<code>execute_process（）</code>命令将因错误而停止。</li>
<li><code>LAST</code>：如果命令列表中的最后一个命令失败，则<code>execute_process（）</code>命令会因错误而停止。列表中前面的命令不会导致致命错误。</li>
</ul>
</li>
<li>如果在同一管道中同时指定了多个<code>OUTPUT_*</code>或<code>ERROR_*</code>选项，则优先级顺序是未知的（应避免这种情况）。</li>
<li>如果未指定任何<code>OUTPUT_*</code>或<code>ERROR_*</code>选项，则命令CMake所在进程共享输出管道。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">execute_process(</span><br><span class="line">  COMMAND</span><br><span class="line">    $&#123;PYTHON_EXECUTABLE&#125; &quot;-c&quot; &quot;import $&#123;_module_name&#125;; print($&#123;_module_name&#125;.__version__)&quot;</span><br><span class="line">  OUTPUT_VARIABLE _stdout</span><br><span class="line">  ERROR_VARIABLE _stderr</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  ERROR_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="CMake-定义宏"><a href="#CMake-定义宏" class="headerlink" title="CMake 定义宏"></a>CMake 定义宏</h3><h4 id="add-definitions"><a href="#add-definitions" class="headerlink" title="add_definitions()"></a><code>add_definitions()</code></h4><ul>
<li><p>采用<code>add_definitions</code>定义宏，对于无值宏：</p>
<ul>
<li><code>add_definitions(-DMG_ENABLE_OPENSSL)</code></li>
</ul>
</li>
<li><p>对应于C语言中的</p>
<ul>
<li><code>#define MG_ENABLE_OPENSSL</code></li>
</ul>
</li>
<li><p>而对于有值宏：</p>
<ul>
<li><code>add_definitions(-DLIBEVENT_VERSION_NUMBER=0x02010800)</code></li>
</ul>
</li>
<li><p>对应于C语言：</p>
<ul>
<li><code>#define LIBEVENT_VERSION_NUMBER 0x02010800</code></li>
</ul>
</li>
</ul>
<h4 id="add-compile-definitions"><a href="#add-compile-definitions" class="headerlink" title="add_compile_definitions()"></a><code>add_compile_definitions()</code></h4><ul>
<li><code>add_compile_definitions</code>定义宏，但是这个指令只要高版本的cmake支持，所以推荐使用第1种，比如：<ul>
<li><code>add_compile_definitions(MG_ENABLE_OPENSSL=1)</code></li>
</ul>
</li>
<li>对应于C语言中的<ul>
<li><code>#define MG_ENABLE_OPENSSL 1</code></li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>CMakeLists.txt 文件中定义的宏在后面C&#x2F;C++程序中是可以直接使用的</li>
</ul>
<h3 id="CMake-调试"><a href="#CMake-调试" class="headerlink" title="CMake 调试"></a>CMake 调试</h3><ul>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">include(CMakePrintHelpers)</span><br><span class="line"># 打印变量 PROJECT_SOURCE_DIR</span><br><span class="line">cmake_print_variables(PROJECT_SOURCE_DIR)</span><br><span class="line"></span><br><span class="line">cmake_print_properties(TARGETS arwen-webserver PROPERTIES POSITION_INDEPENDENT_CODE)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="CMake-常用命令"><a href="#CMake-常用命令" class="headerlink" title="CMake 常用命令"></a>CMake 常用命令</h2><h3 id="aux-source-directory"><a href="#aux-source-directory" class="headerlink" title="aux_source_directory()"></a>aux_source_directory()</h3><ul>
<li>简介：查找在某个路径下的所有源文件。<ul>
<li>搜集所有在指定路径下的源文件的文件名，将输出结果列表储存在指定的变量中。</li>
<li>该命令主要用在那些使用显式模板实例化的工程上。模板实例化文件可以存储在Templates子目录下，然后可以使用这条命令自动收集起来；这样可以避免手工罗列所有的实例。</li>
</ul>
</li>
<li>语法：<code>aux_source_directory(&lt; dir &gt; &lt; variable &gt;)</code></li>
</ul>
<h3 id="add-executable"><a href="#add-executable" class="headerlink" title="add_executable()"></a>add_executable()</h3><ul>
<li>简介：使用指定的源文件来生成目标可执行文件。这里的目标可执行文件分为三类：普通可执行目标文件、导入可执行目标文件、别名可执行目标文件。分别对应下面的三种命令格式。</li>
<li>语法：<ul>
<li><code>add_executable (&lt;name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [source1] [source2 ...])</code></li>
<li><code>add_executable (&lt;name&gt; IMPORTED [GLOBAL])</code></li>
<li><code>add_executable (&lt;name&gt; ALIAS &lt;target&gt;)</code></li>
</ul>
</li>
</ul>
<h2 id="CMake-常用操作"><a href="#CMake-常用操作" class="headerlink" title="CMake 常用操作"></a>CMake 常用操作</h2><h3 id="生成动态库或静态库"><a href="#生成动态库或静态库" class="headerlink" title="生成动态库或静态库"></a>生成动态库或静态库</h3><p>+ </p>
<h3 id="添加动态链接库"><a href="#添加动态链接库" class="headerlink" title="添加动态链接库"></a>添加动态链接库</h3><ul>
<li><p>如果使用gcc进行单个c文件编译的时候，有时候后面会需要添加如-L -l之类的参数，如下</p>
<ul>
<li><code>gcc -o test test.c -L/usr/local/lib/ -lopencv</code></li>
</ul>
</li>
<li><p>在这里</p>
<ul>
<li><code>-L</code>是制定动态库的位置，</li>
<li><code>-l</code>则是指定打算连接的动态库名字</li>
</ul>
</li>
<li><p>那么在进行项目编译的时候就需要通过cmake来通过Cmakelist.txt引导make进行项目编译。</p>
</li>
<li><p>那么就需要在cmakelists.txt文件内添加动态链接库的配置，具体参数如下</p>
<ul>
<li>首先申明动态库的位置,<code>LINK_DIRECTORIES(&#123;your_library_path&#125;)</code>，例如：<ul>
<li><code>LINK_DIRECTORIES(/usr/local/lib)</code></li>
</ul>
</li>
<li>然后制定具体的动态库的名称, <code>target_link_libraries($&#123;PROJECT_NAME&#125; -l&#123;library_name&#125;)</code>，例如：<ul>
<li>指定hiredis的动态链接文件 libhiredis.dylib ： <code>target_link_libraries($&#123;PROJECT_NAME&#125; -lhiredis)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="引入外部静态库"><a href="#引入外部静态库" class="headerlink" title="引入外部静态库"></a>引入外部静态库</h3><ul>
<li><p><code>include_directories($&#123;ROOT_DIR&#125;/3party/include)</code></p>
<ul>
<li>用于指定头文件的搜索路径</li>
</ul>
</li>
<li><p><code>link_directories($&#123;ROOT_DIR&#125;/3party/lib)</code></p>
<ul>
<li>指定静态库或者动态库的搜索路径</li>
</ul>
</li>
<li><p><code>target_link_libraries(sample libmath.a)</code></p>
<ul>
<li>指定要连接的静态库，必须要有，第二个参数也可以换成math，那么将自动去搜索libmath.a或者libmath.so或者libmath.dyld动态库</li>
</ul>
</li>
</ul>
<h2 id="arwen-机械臂项目-CMakeLists-txt-笔记"><a href="#arwen-机械臂项目-CMakeLists-txt-笔记" class="headerlink" title="arwen 机械臂项目 CMakeLists.txt 笔记"></a>arwen 机械臂项目 CMakeLists.txt 笔记</h2><h3 id="cmake-minimum-required"><a href="#cmake-minimum-required" class="headerlink" title="cmake_minimum_required()"></a>cmake_minimum_required()</h3><ul>
<li>为项目设置cmake的最低要求版本</li>
<li>示例：<ul>
<li><code>cmake_minimum_required(VERSION 3.10)</code></li>
</ul>
</li>
</ul>
<h3 id="project"><a href="#project" class="headerlink" title="project()"></a>project()</h3><ul>
<li>为整个项目设置名称、版本并启用语言</li>
<li>示例：<ul>
<li><code>project(arwen)</code></li>
</ul>
</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><ul>
<li>将常规变量、缓存变量或环境变量设置为给定值。</li>
<li>示例：<ul>
<li><code>set(CMAKE_CXX_STANDARD 17)</code></li>
</ul>
</li>
</ul>
<h3 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories()"></a>include_directories()</h3><ul>
<li>向构建中添加包含目录</li>
<li>示例：<ul>
<li><code>include_directories(./include)</code></li>
</ul>
</li>
</ul>
<h3 id="PROJECT-SOURCE-DIR"><a href="#PROJECT-SOURCE-DIR" class="headerlink" title="${PROJECT_SOURCE_DIR}"></a>${PROJECT_SOURCE_DIR}</h3><ul>
<li>内置变量，当前项目的顶级源目录。</li>
</ul>
<h3 id="PROJECT-BINARY-DIR"><a href="#PROJECT-BINARY-DIR" class="headerlink" title="${PROJECT_BINARY_DIR}"></a>${PROJECT_BINARY_DIR}</h3><ul>
<li>内置变量，为项目构建目录的完整路径(Full path to build directory for project.)</li>
</ul>
<h3 id="execute-process-1"><a href="#execute-process-1" class="headerlink" title="execute_process()"></a>execute_process()</h3><ul>
<li>执行一个或多个子进程</li>
<li>示例：<ul>
<li><code>execute_process( COMMAND $&#123;CMAKE_COMMAND&#125; -E make_directory $&#123;LOG_DIR&#125;)</code></li>
</ul>
</li>
</ul>
<h3 id="CMAKE-COMMAND"><a href="#CMAKE-COMMAND" class="headerlink" title="${CMAKE_COMMAND}"></a>${CMAKE_COMMAND}</h3><ul>
<li>可执行文件“cmake(1)”的完整路径</li>
</ul>
<h3 id="add-subdirectory"><a href="#add-subdirectory" class="headerlink" title="add_subdirectory()"></a>add_subdirectory()</h3><ul>
<li>向构建中添加子目录。</li>
<li>示例：<ul>
<li><code>add_subdirectory(src)</code></li>
</ul>
</li>
</ul>
<h3 id="file"><a href="#file" class="headerlink" title="file()"></a>file()</h3><ul>
<li>文件操作命令</li>
<li>规则：<ul>
<li><code>file(WRITE &lt;filename&gt; &lt;content&gt;...)</code></li>
<li><code>file(APPEND &lt;filename&gt; &lt;content&gt;...)</code></li>
</ul>
</li>
<li>详解：<ul>
<li>将<code>&lt;content&gt;</code>写入名为<code>&lt;filename&gt;</code>的文件中。如果这个文件不存在，则创建该文件。如果该文件已经存在，则<code>WRITE</code>模式下将会覆盖该文件，<code>APPEND</code>模式下将会追加到该文件的末尾.由<code>&lt;filename&gt;</code>指定的路径中任何不存在的目录将被创建</li>
<li>如果文件是一个构建输入，使用<code>configure_file()</code>命令仅在其内容更改时更新文件。</li>
</ul>
</li>
</ul>
<h3 id="add-library"><a href="#add-library" class="headerlink" title="add_library()"></a>add_library()</h3><ul>
<li>该指令的主要作用就是将指定的源文件生成链接文件，然后添加到工程中去。该指令常用的语法如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_library(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">            [EXCLUDE_FROM_ALL]</span><br><span class="line">            [source1] [source2] [...])</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>其中<code>&lt;name&gt;</code>表示库文件的名字，该库文件会根据命令里列出的源文件来创建。</li>
<li>而<code>STATIC</code>、<code>SHARED</code>和<code>MODULE</code>的作用是指定生成的库文件的类型。<ul>
<li><code>STATIC</code>库是目标文件的归档文件，在链接其它目标的时候使用。</li>
<li><code>SHARED</code>库会被动态链接（动态链接库），在运行时会被加载。</li>
<li><code>MODULE</code>库是一种不会被链接到其它目标中的插件，但是可能会在运行时使用dlopen-系列的函数。</li>
<li>默认状态下，库文件将会在于源文件目录树的构建目录树的位置被创建，该命令也会在这里被调用</li>
</ul>
</li>
<li>而语法中的<code>source1</code> <code>source2</code>分别表示各个源文件。</li>
</ul>
</li>
<li>使用指定的源文件向项目添加库</li>
<li>示例：<ul>
<li><code>add_library($&#123;PROJECT_NAME&#125; STATIC  $&#123;SOURCE_FILES&#125;)</code></li>
</ul>
</li>
</ul>
<h3 id="link-directories"><a href="#link-directories" class="headerlink" title="link_directories()"></a>link_directories()</h3><ul>
<li>该指令的作用主要是指定要链接的库文件的路径，该指令有时候不一定需要。因为find_package和find_library指令可以得到库文件的绝对路径。该指令的常用语法如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">link_directories(</span><br><span class="line">    lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>不过你自己写的动态库文件放在自己新建的目录下时，可以用该指令指定该目录的路径以便工程能够找到。</li>
<li>指定链接器将在其中查找库的目录</li>
<li>示例：<ul>
<li><code>link_directories($&#123;PROJECT_BINARY_DIR&#125;/lib)</code></li>
</ul>
</li>
</ul>
<h3 id="target-link-libraries"><a href="#target-link-libraries" class="headerlink" title="target_link_libraries()"></a>target_link_libraries()</h3><ul>
<li>该指令的作用为将目标文件与库文件进行链接。该指令的语法如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(&lt;target&gt; [item1] [item2] [...]</span><br><span class="line">                      [[debug|optimized|general] &lt;item&gt;] ...)</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>指令中的<code>&lt;target&gt;</code>是指通过<code>add_executable()</code>和<code>add_library()</code>指令生成已经创建的目标文件。</li>
<li>而<code>[item]</code>表示库文件没有后缀的名字。默认情况下，库依赖项是传递的。当这个目标链接到另一个目标时，链接到这个目标的库也会出现在另一个目标的连接线上。</li>
<li>这个传递的接口存储在<code>interface_link_libraries</code>的目标属性中，可以通过设置该属性直接重写传递接口。</li>
</ul>
</li>
<li>指定链接给定目标和&#x2F;或其依赖项时要使用的库或标志</li>
<li>示例：<ul>
<li><code>target_link_libraries($&#123;PROJECT_NAME&#125; PUBLIC $&#123;Etherlab_LIBRARIES&#125;)</code></li>
</ul>
</li>
</ul>
<h3 id="target-include-directories"><a href="#target-include-directories" class="headerlink" title="target_include_directories()"></a>target_include_directories()</h3><ul>
<li>向目标添加包含目录</li>
<li>示例：<ul>
<li><code>target_include_directories( $&#123;PROJECT_NAME&#125; PUBLIC $&#123;PRJECT_SOURCE_DIR&#125;)</code></li>
</ul>
</li>
</ul>
<h3 id="find-package"><a href="#find-package" class="headerlink" title="find_package()"></a>find_package()</h3><ul>
<li>加载外部项目的设置。</li>
<li>示例：<ul>
<li><code>find_package(Etherlab REQUIRED)</code></li>
</ul>
</li>
</ul>
<h3 id="set-target-properties"><a href="#set-target-properties" class="headerlink" title="set_target_properties()"></a>set_target_properties()</h3><ul>
<li>目标可以具有影响如何构建它们的属性。</li>
<li>示例：<ul>
<li><code>set_target_properties(arwen-planning PROPERTIES LINKER_LANGUAGE CXX)</code></li>
</ul>
</li>
</ul>
<h1 id="modern-cmake-3-11"><a href="#modern-cmake-3-11" class="headerlink" title="modern cmake &gt;&#x3D; 3.11"></a>modern cmake &gt;&#x3D; 3.11</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul>
<li>CMake可以编译源代码,制作程序库,产生适配器(wrapper),可以用任意的顺序构建执行档</li>
<li>CMake支持in-place建构(二进档和源代码在同一个目录树中)和out-of-place构建(二进档在别的目录里),因此可以很容易从一个源代码目录树中建构出多个二进档.</li>
<li>CMake也支持静态与动态程式库的建构</li>
<li>CMake是一种工具,它读入用于描述软件如何构建的脚本,CMake将评估这些脚本并构建出表达软件项目的内部结构,如果它处理完这些脚本并没有发现错误,CMake将生成用于实际构建项目的构建文件(可能是脚本或者IDE工程文件)</li>
<li>CMake支持多种构建工具,包括一系列命令行构建工具和主流IDE,运行cmake –help可以看到在当前平台下CMake所支持的构建工具.</li>
<li>CMake中将这些构建系统称作generator.<strong>因此,CMake不是构建系统,而是构建系统生成器,具体的构建工作还是要交给Make, Ninja等构建系统去做</strong></li>
<li>运行CMake时,它会运行多项检查,在检查和评估构建脚本期间,它会将一些值缓存到CMakeCache.txt当中,这让我们在增量式开发中,可以跳过长时间的检查过程,但是CMake的缓存也会带来一些问题,比如:修改了某些配置没有办法及时的反映在下次构建中,所以有时构建出问题可以尝试删除CMake缓存文件后重新构建</li>
</ul>
<p>什么是CMakeList.txt文件?</p>
<ul>
<li>放置所有CMake命令的文件,当cmake在某个文件夹下运行时,会寻找该文件,如果找不到则报错</li>
</ul>
<p>为什么要使用cmake?</p>
<ul>
<li>跨平台</li>
<li>可配置</li>
<li>众多开源项目都只支持(或仅支持)CMake构建</li>
</ul>
<h2 id="构建CMake项目"><a href="#构建CMake项目" class="headerlink" title="构建CMake项目"></a>构建CMake项目</h2><p>CMake构建的两种形式:就地构建(in-source)和源码外构建(out-of-source)</p>
<ul>
<li>就地构建:在源文件目录下构建,产生的二进制文件将于源文件生成在一个文件夹里</li>
<li>源码外构建:单独创建一个build文件夹,在该文件夹下构建二进制文件,与源代码文件分开</li>
</ul>
<p>源码树和构建树</p>
<ul>
<li>源码树是源代码目录,里面放着源代码文件和CMakeLists.txt文件</li>
<li>构建树就是存放构建系统文件和输出文件的目录</li>
<li>通过变量<code>CMAKE_BINARY_DIR</code>访问到构建树的顶层文件夹(执行cmake命令的目录)</li>
<li>通过变量<code>CMAKE_SOURCE_DIR</code>访问到源码树的顶层文件夹(根CMakeLists.txt文件所在的目录).</li>
<li>注:对于就地构建,源码树和构建树是等价的</li>
</ul>
<p>CMake的执行过程分为三个阶段:<br>英文:</p>
<ol>
<li><strong>Configure</strong>:  <ul>
<li>Parse top level CMakeLists.txt, </li>
<li>Generates cache variables, </li>
<li>Only relevant in GUI builds</li>
</ul>
</li>
<li><strong>Generate</strong>:<ul>
<li>Generate native build tool files, </li>
<li>Can do cross compilation passing toolchain files</li>
</ul>
</li>
<li><strong>Build</strong>:<ul>
<li>Uses native build tools to compile the sources, </li>
<li>All it takes is cmake –build<br>中文:</li>
</ul>
</li>
<li>配置阶段:<ul>
<li>CMake将解析源码树顶层的<code>CMakeLists.txt</code>,并生成一个<code>CMakeCache.txt</code>以存储cache变量</li>
<li>对于CMake-GUI,该阶段由点击Configure出发,</li>
<li>对于命令版本的CMake,该阶段与生成阶段结合在一起</li>
<li>CMake打印消息:<code>Configuring done</code>以表示配置阶段结束</li>
</ul>
</li>
<li>生成阶段:<ul>
<li>CMake将根据<code>CMakeLists.txt</code>和<code>CMakeCache.txt</code>生成构建系统文件</li>
<li>在CMake-GUI中,该阶段由点击Generate出发</li>
<li>CMake打印消息<code>Generating done</code>以表示生成阶段结束</li>
</ul>
</li>
<li>构建阶段:<ul>
<li>这一阶段由构建系统负责,在这个阶段中将生成项目的目标</li>
</ul>
</li>
</ol>
<h2 id="CMake-基础"><a href="#CMake-基础" class="headerlink" title="CMake 基础"></a>CMake 基础</h2><ul>
<li>在经过一番搜索和学习，我开始了解 Modern CMake 的一些用法与理念，它主张放弃传统的基于变量的方法，而采用基于 target 的结构化模式，使其成为一个更可维护、更直观、更易集成、更具意义的方案。</li>
</ul>
<h3 id="1-1-Modern-CMake-介绍"><a href="#1-1-Modern-CMake-介绍" class="headerlink" title="1.1 Modern CMake 介绍"></a>1.1 Modern CMake 介绍</h3><ul>
<li><p>这部分内容是 <code>An Introduction to Modern CMake</code> 的总结，并不会讲的非常详细，希望通过几句话来高度总结各个用法，旨在了解 CMake 有哪能力，如果对某些部分感兴趣请大家自行查阅具体内容。</p>
</li>
<li><p>为什么需要一个好的构建系统？如果你有以下需求，那么使用 CMake 可以从中获益</p>
<ul>
<li>你想避免硬编码路径</li>
<li>你需要在多台电脑上建立一个软件包</li>
<li>你想使用CI（持续集成）</li>
<li>你需要支持不同的操作系统（甚至可能只是Unix的不同版本）</li>
<li>你想支持多个编译器</li>
<li>你想使用IDE，但也许并不是所有时间都想使用</li>
<li>你想要更好地组织程序的结构</li>
<li>你想使用别人的库</li>
<li>你想使用工具，比如Clang-Tidy，来帮助你编写代码</li>
<li>你想使用调试器</li>
</ul>
</li>
<li><p>为什么一定是 CMake？其他工具不行吗？</p>
<ul>
<li>各个 IDE 都支持 CMake，使用 CMake 可以有更大程度的方便, save you life</li>
<li>目前很多 C&#x2F;C++ 开源项目都在使用 CMake，通过 find CMake 或者 CMake config 很容易将它们集成至你的项目中</li>
<li>使用 CMake 来管理发布，让别人更容易使用你的库</li>
</ul>
</li>
<li><p>为什么要用现代 CMake？</p>
<ul>
<li>通常认为 3.1+ 版本是现代 CMake。CMake 是向下兼容的，可以放心使用</li>
<li>至少应该使用你的编译器出来之后的 CMake 版本，因为它需要知道该版本的编译标志等等</li>
<li>高版本 CMake 有更多特性，可以节省数百行和数小时的 CMakeLists.txt 编写工作，长运来看更容易维护</li>
</ul>
</li>
</ul>
<h3 id="1-2-运行CMake"><a href="#1-2-运行CMake" class="headerlink" title="1.2 运行CMake"></a>1.2 运行CMake</h3><ul>
<li><p>经典用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/package $ mkdir build</span><br><span class="line">~/package $ cd build</span><br><span class="line">~/package/build $ cmake ..</span><br><span class="line">~/package/build $ make</span><br></pre></td></tr></table></figure>
</li>
<li><p>新版本可以简单一点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/package $ cmake -S . -B build</span><br><span class="line">~/package $ cmake --build build</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#From the build directory (pick one)</span><br><span class="line">~/package/build $ make install</span><br><span class="line">~/package/build $ cmake --build . --target install</span><br><span class="line">~/package/build $ cmake --install . # CMake 3.15+ only</span><br><span class="line"></span><br><span class="line">#From the source directory (pick one)</span><br><span class="line">~/package $ cmake --build build --target install</span><br><span class="line">~/package $ cmake --install build # CMake 3.15+ only</span><br></pre></td></tr></table></figure>
</li>
<li><p>推荐使用 <code>--build</code> 用法</p>
<ul>
<li>通过 <code>-v</code> 显示执行的构建命令: <code>cmake --build build -v</code></li>
<li>通过 <code>--target</code> 来选择目标：<code>cmake --build --target install</code></li>
</ul>
</li>
<li><p>设置 CC 和 CXX 环境变量来选择 C&#x2F;C++ 编译器</p>
<ul>
<li><code>~/package/build $ CC=clang CXX=clang++ cmake ..</code></li>
</ul>
</li>
<li><p>选择不同的工具进行构建</p>
<ul>
<li>make 通常是默认的，通过 cmake –help 查看支持的构建器</li>
<li><code>cmake -G&quot;My Tool&quot;</code> 设置构建器，例如 <code>cmake -S . -B buildXcode -G&quot;Xcode&quot;</code></li>
</ul>
</li>
<li><p>通过 <code>-D</code> 来设置选项，例如 <code>cmake -S . -B build -DCMAKE_INSTALL_PREFIX=dist</code></p>
</li>
<li><p><code>--trace</code> 打印 <code>CMake configure</code> 阶段的输出，例如 <code>cmake -S . -B build --trace</code></p>
</li>
<li><p>不好的 CMake 的用法</p>
<ul>
<li>不要使用全局函数，例如 <code>link_directories</code>，<code>include_libraries</code>，<code>add_definitions</code> 等，请你忘记它们</li>
<li>不要滥用 <code>PUBLIC</code>，除非有依赖传递，否则请你使用 <code>PRIVATE</code> 替换 <code>PUBLIC</code></li>
<li>不要使用 <code>GLOB</code> 来添加文件</li>
<li>不要直接链接文件，而是链接目标</li>
<li>链接时千万不要跳过 <code>PUBLIC/PRIVATE</code>，这会导致未来的链接都没有关键字</li>
</ul>
</li>
<li><p>良好的 CMake 用法</p>
<ul>
<li>把 CMake 视作代码，保持它的整洁和可读性</li>
<li>围绕 target 构建你的 CMake。将需要的信息打包在 target 里，然后链接那个目标</li>
<li>导出你的接口</li>
<li>写 Config.cmake 文件，这是一个库作者应该做的，可以方便别人使用你的库</li>
<li>使用 ALAS 目标，以保持使用一致性</li>
<li>将常用的功能提取成函数或者宏，通常函数更好</li>
<li>使用小写的函数名，全大写是变量</li>
<li>使用 cmake_policy 或者 range of versions</li>
</ul>
</li>
</ul>
<h3 id="1-3-基础语法"><a href="#1-3-基础语法" class="headerlink" title="1.3 基础语法"></a>1.3 基础语法</h3><ul>
<li><p>最低版本</p>
<ul>
<li><code>cmake_minimum_required(VERSION 3.1)</code> 指定最低版本</li>
<li><code>cmake_minimum_required(VERSION 3.7...3.18)</code> CMake 3.12+ 后，可以指定版本范围</li>
</ul>
</li>
<li><p>Project</p>
<ul>
<li><code>VERSION</code> 指定版本，并设置一系列变量，例如<code>MyProject_VERSION</code> 等</li>
<li><code>DESCRIPTION</code> 项目的描述</li>
<li><code>LANGUAGES</code> 支持 <code>C/CXX/Fortran/ASM/CUDA(3.8+)/CSharp(3.8+)/SWIFT(3.15+)</code>, C&#x2F;C++ 为默认值</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">project(MyProject VERSION 1.0</span><br><span class="line">                  DESCRIPTION &quot;Very nice project&quot;</span><br><span class="line">                  LANGUAGES CXX)</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成可执行文件</p>
<ul>
<li><code>add_executable(one two.cpp three.h)</code></li>
</ul>
</li>
<li><p>生成库</p>
<ul>
<li>库类型包括 <code>STATIC</code>、<code>SHARED</code>、<code>MODULE</code>、<code>OBJECT</code> 等。如果没有指定库类型，那么 <code>BUILD_SHARED_LIBS</code> 的值将决定编译 <code>STATIC</code> 或者 <code>SHARED</code></li>
<li>有些库并不需要编译，例如 <code>header only</code> 库。基于 <code>target</code> 的思想，我们可以将它们打包在一种叫 <code>INTERFACE</code> 的库中。</li>
</ul>
</li>
<li><p>示例</p>
<ul>
<li><code>add_library(one STATIC two.cpp three.h)</code></li>
</ul>
</li>
<li><p>给 target 添加属性</p>
<ul>
<li><code>target_include_directories</code> 为 target 添加 <code>include</code> 路径</li>
<li><code>PUBLIC</code> 对于可执行文件而言意义不大，对于库来说，它让 CMake 知道链接这个目标的目标也需要这个 include 目录。也就是 “我自己要用，其他链接我的也要用”，具有传递性</li>
<li><code>PRIVATE</code> 表示 “我自己用，其他人不用”</li>
<li><code>INTERFACE</code> 表示 “我自己不用，其他链接我的要用”</li>
<li>target 的属性包括 include 文件夹、需要链接的库、编译选项、宏定义等，这些都可以通过 <code>target_link_libraries</code> 进行传递</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># PUBLIC 表示外部也需要这个 include 目录</span><br><span class="line">target_include_directories(one PUBLIC include)</span><br><span class="line">add_library(another STATIC another.cpp another.h)</span><br><span class="line"># 由于具有传递性，another 可以连接 one 的 include 目录</span><br><span class="line">target_link_libraries(another PUBLIC one)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-4-变量与缓存"><a href="#1-4-变量与缓存" class="headerlink" title="1.4 变量与缓存"></a>1.4 变量与缓存</h3><ul>
<li><p>局部变量</p>
<ul>
<li><code>set(MY_VARIABLE &quot;value&quot;)</code> 设置局部变量，其作用域为当前文件夹，以及 <code>add_subdirectory</code> 进入的文件夹</li>
<li><code>set(MY_VARIABLE &quot;value&quot; PARENT_SCOPE)</code> 将作用域设置为父目录，通常用在子目录向父目录传递信息</li>
<li><code>set(MY_LIST &quot;one&quot; &quot;two&quot;)</code> 会在变量值中间加入 <code>“;”</code>，等价于 <code>set(MY_LIST &quot;one;two&quot;)</code></li>
</ul>
</li>
<li><p>缓存变量</p>
<ul>
<li>通过 <code>set(MY_CACHE_VARIABLE &quot;VALUE&quot; CACHE STRING &quot;Description&quot;)</code> 设置缓存变量</li>
<li>缓存变量将持久存在于 CMakeCache.txt 中</li>
<li>通过 <code>cmake -DXXX</code> 命令传递的参数为缓存变量</li>
</ul>
</li>
<li><p>环境变量</p>
<ul>
<li><code>set(ENV&#123;variable_name&#125; value)</code> 设置环境变量</li>
<li><code>$ENV&#123;variable_name&#125;</code> 获取环境变量</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>属性有点像变量，但它依附在某个 target 或者文件、目录上。许多属性的初始值来自于 <code>CMAKE_</code> 开头的变量，例如设置 <code>CMAKE_CXX_STANDARD</code>，将会设置 target 的 <code>CXX_STANDARD</code> 属性初始值。</li>
<li><code>set_property</code> 用于设置属性，<code>get_property</code> 用于获取属性</li>
</ul>
</li>
</ul>
<h3 id="1-5-用CMake编程"><a href="#1-5-用CMake编程" class="headerlink" title="1.5 用CMake编程"></a>1.5 用CMake编程</h3><ul>
<li><p>控制流</p>
<ul>
<li>利用 if 语句来控制程序流</li>
<li>if 语句中支持的关键字包括：<ul>
<li>一元判断：<code>NOT、‘TARGET’、EXISTS、DEFINED</code> 等</li>
<li>二元判断：<code>STRQUAL，AND，OR，MATCH，VERSION_LESS，VERSION_LESS_EQUAL</code></li>
</ul>
</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(variable)</span><br><span class="line">    # If variable is `ON`, `YES`, `TRUE`, `Y`, or non zero number</span><br><span class="line">else()</span><br><span class="line">    # If variable is `0`, `OFF`, `NO`, `FALSE`, `N`, `IGNORE`, `NOTFOUND`, `&quot;&quot;`, or ends in `-      NOTFOUND`</span><br><span class="line">endif()</span><br><span class="line"># If variable does not expand to one of the above, CMake will expand it then try again</span><br><span class="line"></span><br><span class="line">if(NOT TARGET libA OR EXISTS &quot;test.xml&quot;)</span><br><span class="line"> # If libA or test.xml exist </span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成器表达式, generator-expressions</p>
<ul>
<li>CMake 大多数命令在 configure 阶段就被执行了，而生成器表达可以在 build 阶段，或者 install 阶段被执行</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target_include_directories(MyTarget </span><br><span class="line">    PUBLIC</span><br><span class="line">    $&lt;BUILD_INTERFACE:$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include&gt;</span><br><span class="line">    $&lt;INSTALL_INTERFACE:include&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏与函数</p>
<ul>
<li>它们的区别：函数里头的变量作用域为该函数，而宏没有作用域</li>
<li>推荐用函数，因为它不会 “泄露” 变量。即使想要从函数中传递某些变量给外面，可以主动通过 PARENT_SCOPE 来设置</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li>可以通过 <code>cmake_parse_arguments</code> 来解析函数参数</li>
</ul>
</li>
</ul>
<h3 id="1-6-与你的代码进行交互"><a href="#1-6-与你的代码进行交互" class="headerlink" title="1.6 与你的代码进行交互"></a>1.6 与你的代码进行交互</h3><ul>
<li>从 CMake 中获取信息，并生成代码。configure_file 命令可以实现这个。</li>
<li>读取文件，例如从 version.h 中获取版本信息。file 命令可以实现这个。</li>
</ul>
<h3 id="1-7-如何组织你的工程"><a href="#1-7-如何组织你的工程" class="headerlink" title="1.7 如何组织你的工程"></a>1.7 如何组织你的工程</h3><ul>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- project</span><br><span class="line">  - .gitignore</span><br><span class="line">  - README.md</span><br><span class="line">  - LICENCE.md</span><br><span class="line">  - CMakeLists.txt</span><br><span class="line">  - cmake</span><br><span class="line">    - FindSomeLib.cmake</span><br><span class="line">    - something_else.cmake</span><br><span class="line">  - include</span><br><span class="line">    - project</span><br><span class="line">      - lib.hpp</span><br><span class="line">  - src</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">    - lib.cpp</span><br><span class="line">  - apps</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">    - app.cpp</span><br><span class="line">  - tests</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">    - testlib.cpp</span><br><span class="line">  - docs</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">  - extern</span><br><span class="line">    - googletest</span><br><span class="line">  - scripts</span><br><span class="line">    - helper.py</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 configure 阶段运行命令</p>
<ul>
<li><code>execute_process</code> 在 configure 阶段运行命令</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find_package(Git QUIET)</span><br><span class="line"></span><br><span class="line">if(GIT_FOUND AND EXISTS &quot;$&#123;PROJECT_SOURCE_DIR&#125;/.git&quot;)</span><br><span class="line">    execute_process(COMMAND $&#123;GIT_EXECUTABLE&#125; submodule update --init --recursive</span><br><span class="line">                    WORKING_DIRECTORY $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">                    RESULT_VARIABLE GIT_SUBMOD_RESULT)</span><br><span class="line">    if(NOT GIT_SUBMOD_RESULT EQUAL &quot;0&quot;)</span><br><span class="line">        message(FATAL_ERROR &quot;git submodule update --init failed with $&#123;GIT_SUBMOD_RESULT&#125;, please checkout submodules&quot;)</span><br><span class="line">    endif()</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 build 阶段运行命令</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">find_package(PythonInterp REQUIRED)</span><br><span class="line">add_custom_command(OUTPUT &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/include/Generated.hpp&quot;</span><br><span class="line">    COMMAND &quot;$&#123;PYTHON_EXECUTABLE&#125;&quot; &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/scripts/GenerateHeader.py&quot; --argument</span><br><span class="line">    DEPENDS some_target)</span><br><span class="line"></span><br><span class="line">add_custom_target(generate_header ALL</span><br><span class="line">    DEPENDS &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/include/Generated.hpp&quot;)</span><br><span class="line"></span><br><span class="line">install(FILES $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/include/Generated.hpp DESTINATION include)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cmake -E &lt;mode&gt;</code> 运行内置的一些命令，例如解压、复制等</p>
</li>
</ul>
<h2 id="添加特性"><a href="#添加特性" class="headerlink" title="添加特性"></a>添加特性</h2><h3 id="1-1-C-11及以后"><a href="#1-1-C-11及以后" class="headerlink" title="1.1 C++11及以后"></a>1.1 C++11及以后</h3><ul>
<li><p>CMake 3.8+: Meta compiler features</p>
<ul>
<li>target_compile_features(myTarget PUBLIC cxx_std_11) 开启 c++11 特性，当然你也可以选择 cxx_std_14 和 cxx_std_17</li>
<li>set_target_properties(myTarget PROPERTIES CXX_EXTENSIONS OFF)，关闭扩展特性</li>
</ul>
</li>
<li><p>CMake 3.1+: 全局和属性设置</p>
<ul>
<li>全局变量设置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="line">set(CMAKE_CXX_EXTENSIONS OFF)</span><br></pre></td></tr></table></figure></li>
<li>属性设置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(myTarget PROPERTIES</span><br><span class="line">    CXX_STANDARD 11</span><br><span class="line">    CXX_STANDARD_REQUIRED YES</span><br><span class="line">    CXX_EXTENSIONS NO</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>地址无关代码（Position independent code; PIC），CMake 会自动将 -fPIC 添加到 SHARED 和 MODULE 库中，当然你也可以显示指定</p>
<ul>
<li>作用于全局变量，<code>set(CMAKE_POSITION_INDEPENDENT_CODE ON)</code></li>
<li>或者作用于 target，<code>set_target_properties(lib1 PROPERTIES POSITION_INDEPENDENT_CODE ON)</code></li>
</ul>
</li>
<li><p>小型库</p>
<ul>
<li>如果你需要 dl 库，那么这么写最简单 <code>target_link_libraries(libA PRIVATE $&#123;CMAKE_DL_LIBS&#125;)</code></li>
</ul>
</li>
<li><p>有些库就没有这么方便了，例如 m, pthread 等，但你可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find_library(MATH_LIBRARY m)</span><br><span class="line">if(MATH_LIBRARY)</span><br><span class="line">    target_link_libraries(MyTarget PUBLIC $&#123;MATH_LIBRARY&#125;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>Interprocedural optimization，运行时优化（link time optimization），即 -flto</p>
<ul>
<li>CMake 3.9+ 支持设置全局变量开启 set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON)</li>
<li>CMake 3.8+ 支持设置属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(myTarget PROPERTIES </span><br><span class="line">                    INTERPROCEDURAL_OPTIMIZATION ON)</span><br></pre></td></tr></table></figure></li>
<li>通过 check_ipo_supported 来检查当前版本是否支持 LTO<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include(CheckIPOSupported)</span><br><span class="line">check_ipo_supported(RESULT result)</span><br><span class="line">if(result)</span><br><span class="line">  set_target_properties(foo PROPERTIES </span><br><span class="line">                INTERPROCEDURAL_OPTIMIZATION TRUE)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在 CMake 中可以配合其他工具</p>
<ul>
<li>CCache，使用它来加快编译速度</li>
<li>Clang tidy，对你的代码做静态扫描</li>
<li>Include what you use, 检查冗余头文件</li>
</ul>
</li>
<li><p>CMake Modules 非常有用，简单介绍一些常用的</p>
<ul>
<li>CMakeDependentOption，根据一组变量来设置选项，例如 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include(CMakeDependentOption)</span><br><span class="line">cmake_dependent_option(BUILD_TESTS &quot;Build your tests&quot; ON &quot;VAL1;VAL2&quot; OFF)</span><br></pre></td></tr></table></figure></li>
<li>CMakePrintHelpers，用于打印属性或变量</li>
<li>CheckCXXCompilerFlag，用于判断是否支持某个编译选项</li>
<li>WriteCompilerDetectionHeader，与 CheckCXXCompilerFlag 类似，但它更强大。它可以找到编译器支持的特性列表，并生成 C++ 头文件，让你知道哪些特性可用</li>
<li>try_compile&#x2F;try_run，可以让尝试编译（运行）一些代码，这可以让你获得系统能力的信息</li>
</ul>
</li>
<li><p>调试CMake代码</p>
<ul>
<li>打印永远是调试的最简单的办法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message(STATUS &quot;MY_VARIABLE=$&#123;MY_VARIABLE&#125;&quot;)</span><br><span class="line"></span><br><span class="line">include(CMakePrintHelpers)</span><br><span class="line">cmake_print_variables(MY_VARIABLE)</span><br><span class="line"></span><br><span class="line">cmake_print_properties(</span><br><span class="line">  TARGETS my_target</span><br><span class="line">  PROPERTIES POSITION_INDEPENDENT_CODE)</span><br></pre></td></tr></table></figure></li>
<li>–trace-source&#x3D;”filename” 让你观察 CMake 文件到底发生了什么，例如<ul>
<li><code>cmake -S . -B build --trace-source=CMakeLists.txt</code></li>
</ul>
</li>
</ul>
</li>
<li><p>引入其他项目</p>
<ul>
<li>Submodule<ul>
<li>通过 <code>git submodule add ../../owner/repo.git extern/repo</code> 将 <code>extern</code> 添加为子仓库</li>
<li>可以在 CMake 中内置子仓库更新命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">find_package(Git QUIET)</span><br><span class="line">if(GIT_FOUND AND EXISTS &quot;$&#123;PROJECT_SOURCE_DIR&#125;/.git&quot;)</span><br><span class="line"># Update submodules as needed</span><br><span class="line">    option(GIT_SUBMODULE &quot;Check submodules during build&quot; ON)</span><br><span class="line">    if(GIT_SUBMODULE)</span><br><span class="line">        message(STATUS &quot;Submodule update&quot;)</span><br><span class="line">        execute_process(COMMAND $&#123;GIT_EXECUTABLE&#125; submodule update --init --recursive</span><br><span class="line">                        WORKING_DIRECTORY $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">                        RESULT_VARIABLE GIT_SUBMOD_RESULT)</span><br><span class="line">        if(NOT GIT_SUBMOD_RESULT EQUAL &quot;0&quot;)</span><br><span class="line">            message(FATAL_ERROR &quot;git submodule update --init failed with $&#123;GIT_SUBMOD_RESULT&#125;, please checkout submodules&quot;)</span><br><span class="line">        endif()</span><br><span class="line">    endif()</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">if(NOT EXISTS &quot;$&#123;PROJECT_SOURCE_DIR&#125;/extern/repo/CMakeLists.txt&quot;)</span><br><span class="line">    message(FATAL_ERROR &quot;The submodules were not downloaded! GIT_SUBMODULE was turned off or failed. Please update submodules and try again.&quot;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>DownloadProject</p>
<ul>
<li>在 CMake 3.11 以前，主要下载命令都是在 build 阶段完成的（例如 ExternalProject_Add）。这就导致你无法使用 add_subdirectory。</li>
<li>CMake 3.11之前，如果想要在 configure 阶段下载，参考 Crascit&#x2F;DownloadProject</li>
</ul>
</li>
<li><p>Fetch(CMake 3.11+)</p>
<ul>
<li>CMake 3.11 后，你可以使用 FetchContent 在 configure 阶段下载文件或者项目</li>
</ul>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="1-1-1"><a href="#1-1-1" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>通常不在子目录时编译测试代码</p>
</li>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME AND BUILD_TESTING)</span><br><span class="line">  add_subdirectory(tests)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></li>
<li><p>通过 <code>add_test(NAME TestName COMMAND TargetName)</code> 注册测试</p>
</li>
<li><p>GoogleTest</p>
<ul>
<li>推荐通过以 git submodule 的形式引入 GoogleTest</li>
<li>可以通过作者提供的 AddGoogleTest 工具引入 GoogleTest</li>
<li>通过 FetchContent 引入 GoogleTest</li>
</ul>
</li>
<li><p>Catch</p>
<ul>
<li>Catch 是个 header only 库，如果直接将它的 include 引入你的仓库中，你需要做一些准备，以便使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Prepare &quot;Catch&quot; library for other executables</span><br><span class="line">set(CATCH_INCLUDE_DIR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/extern/catch)</span><br><span class="line">add_library(Catch2::Catch IMPORTED INTERFACE)</span><br><span class="line">set_property(Catch2::Catch PROPERTY INTERFACE_INCLUDE_DIRECTORIES &quot;$&#123;CATCH_INCLUDE_DIR&#125;&quot;)</span><br></pre></td></tr></table></figure></li>
<li>通过 ExternalProject、FetchContent 或者 git submodule 引入 Catch，那么直接 add_subdirectory 即可</li>
</ul>
</li>
</ul>
<h2 id="Exporting-and-Installing"><a href="#Exporting-and-Installing" class="headerlink" title="Exporting and Installing"></a>Exporting and Installing</h2><h3 id="1-1-2"><a href="#1-1-2" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li>关于 Installing，参考 CMake之install方法的使用</li>
<li>关于 Exporting，可以将 build directories 信息导出，以供其他工程使用（注意与 Installing 的区别：Installing 导出的是安装目录的信息）</li>
<li>关于 Package ，没怎么用过，似乎是将你需要的内容进行打包</li>
</ul>
<h2 id="寻找库"><a href="#寻找库" class="headerlink" title="寻找库"></a>寻找库</h2><h3 id="1-1-3"><a href="#1-1-3" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li>介绍了引入 CUDA、OpenMP、Boost、MPI、ROOT、Minuit2 等库的标准姿势</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/CMake/cmake_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-cmake_2_01_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/CMake/cmake_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-cmake_2_01_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">cmake_2_01_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cmake 常用函数</li>
</ul>
<h2 id="cmake-check-one-config-函数-详解"><a href="#cmake-check-one-config-函数-详解" class="headerlink" title="cmake check_one_config() 函数 详解"></a>cmake check_one_config() 函数 详解</h2><p><code>check_one_config()</code> 函数是 CMake 中的一个函数，通常用于在配置过程中检查和验证某些条件或选项是否正确设置。它常见于 CMake 模块或工具链文件中，尤其是在进行跨平台构建配置时。具体来说，它用于检查单个配置或条件是否满足，并输出相关信息。</p>
<h3 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a><strong>功能概述</strong></h3><p><code>check_one_config()</code> 函数主要用于验证一个特定的配置或条件，并根据验证的结果采取相应的行动。通常，这些条件可能涉及到 CMake 配置变量的值、环境设置或库的可用性等。</p>
<p>这个函数并不是 CMake 的标准库函数，而是一些 CMake 模块中自定义的辅助函数。在 OpenCV 或其他大型 CMake 项目的配置中，<code>check_one_config()</code> 可能用于检查工具链、编译器、依赖库或其他配置是否符合要求。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul>
<li><strong>验证工具链配置</strong>：检查是否指定了正确的编译器或编译选项。</li>
<li><strong>检查依赖库</strong>：确认所需的库是否存在。</li>
<li><strong>输出配置状态</strong>：根据条件输出构建信息或错误信息。</li>
</ul>
<h3 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a><strong>典型用法</strong></h3><p><code>check_one_config()</code> 的实际实现和用法通常依赖于所使用的 CMake 模块和构建脚本。假设在一个项目中，<code>check_one_config()</code> 被用于检查一个必需的配置选项是否已设置，可以像这样使用：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(check_one_config option_name option_value)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> <span class="variable">$&#123;option_name&#125;</span>)</span><br><span class="line">        <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Configuration error: $&#123;option_name&#125; is not defined.&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$&#123;option_name&#125;</span> <span class="keyword">STREQUAL</span> <span class="variable">$&#123;option_value&#125;</span>)</span><br><span class="line">        <span class="keyword">message</span>(STATUS <span class="string">&quot;Configuration: $&#123;option_name&#125; is set to $&#123;option_value&#125;.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line">        <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Configuration error: $&#123;option_name&#125; is not set to $&#123;option_value&#125;.&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 check_one_config 来检查某个选项</span></span><br><span class="line">check_one_config(MY_OPTION <span class="string">&quot;SomeValue&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>check_one_config</code> 用于检查名为 <code>MY_OPTION</code> 的选项是否定义，并且其值是否等于 <code>&quot;SomeValue&quot;</code>。如果不符合条件，CMake 将输出致命错误并终止配置过程。</p>
<h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a><strong>参数解释</strong></h3><p><code>check_one_config()</code> 的函数定义通常包含以下几个参数：</p>
<ul>
<li><strong>option_name</strong>：待检查的配置选项名称。它通常是一个 CMake 变量的名称，用于表示某个设置或选项。</li>
<li><strong>option_value</strong>：期望的选项值，用于比较。如果配置选项的值与期望值不匹配，则执行相应的操作。</li>
</ul>
<h3 id="CMake-版本及实现差异"><a href="#CMake-版本及实现差异" class="headerlink" title="CMake 版本及实现差异"></a><strong>CMake 版本及实现差异</strong></h3><p>由于 <code>check_one_config()</code> 不是 CMake 的标准内建函数，而是特定 CMake 模块中的自定义函数，其具体实现可能会根据不同的项目或模块有所不同。上述示例是一个常见的自定义实现，但某些项目（如 OpenCV）可能会根据其构建需求对 <code>check_one_config()</code> 进行扩展和修改。</p>
<h3 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a><strong>示例场景</strong></h3><ul>
<li><p><strong>检查是否找到某个库</strong>：在项目中，可能需要检查某个依赖库（如 OpenCV、Boost 或其他）是否被正确发现。如果没有找到该库，<code>check_one_config()</code> 可以输出错误并终止构建。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line">check_one_config(OpenCV_FOUND <span class="keyword">TRUE</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查编译器支持的选项</strong>：某些构建选项可能仅在特定的编译器或工具链下有效。使用 <code>check_one_config()</code> 可以确保编译器支持所需的选项。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_one_config(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>check_one_config()</code> 是一个 CMake 中用于检查和验证特定配置的函数。</li>
<li>它通常用于确保某个选项、工具链、库或环境变量符合预期。</li>
<li>它并不是 CMake 的内建标准函数，而是项目自定义的帮助函数，可能用于构建配置的验证。</li>
<li><code>check_one_config()</code> 常用于输出配置状态、验证选项值，或在配置失败时输出错误并终止构建过程。</li>
</ul>
<p>如果你在使用某个项目时遇到 <code>check_one_config()</code>，通常需要查阅项目的 CMake 文件以了解该函数的具体实现和使用方式。</p>
<h2 id="cmake-get-target-property-详解"><a href="#cmake-get-target-property-详解" class="headerlink" title="cmake get_target_property() 详解"></a>cmake get_target_property() 详解</h2><p><code>get_target_property()</code> 是 CMake 中用于获取目标（target）属性的命令。它可以从指定的目标中检索特定的属性值，并将其存储在变量中。其常见语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_target_property</span>(&lt;variable&gt; &lt;<span class="keyword">target</span>&gt; &lt;property&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li><p><code>&lt;variable&gt;</code>：这是存储属性值的变量名。如果属性存在，其值将存储在此变量中。如果属性不存在，变量将设置为特殊值 <code>NOTFOUND</code>。</p>
</li>
<li><p><code>&lt;target&gt;</code>：这是你希望查询属性的目标（通常是通过 <code>add_executable()</code>、<code>add_library()</code> 或 <code>add_custom_target()</code> 创建的目标）。</p>
</li>
<li><p><code>&lt;property&gt;</code>：这是要查询的属性名称。CMake 中有许多内置的属性，比如 <code>INTERFACE_INCLUDE_DIRECTORIES</code>、<code>LOCATION</code>、<code>LINK_LIBRARIES</code> 等。</p>
</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设有以下 CMake 配置：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_executable main.cpp)</span><br><span class="line"><span class="keyword">set_target_properties</span>(my_executable PROPERTIES VERSION <span class="number">1.0</span> SOVERSION <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>get_target_property()</code> 获取属性值：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_target_property</span>(version my_executable VERSION)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;my_executable version is: $&#123;version&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出可能为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_executable version is: 1.0</span><br></pre></td></tr></table></figure>

<h3 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h3><ul>
<li><code>LOCATION</code>：目标生成的二进制文件路径。</li>
<li><code>INTERFACE_INCLUDE_DIRECTORIES</code>：指定此目标暴露给依赖它的目标的包含目录列表。</li>
<li><code>LINK_LIBRARIES</code>：链接到该目标的库列表。</li>
<li><code>COMPILE_DEFINITIONS</code>：目标的编译定义列表。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>如果指定的属性不存在，结果变量会被设置为 <code>NOTFOUND</code>，这在处理未定义属性时要特别注意。</li>
<li>使用 <code>get_target_property()</code> 时，目标必须已经定义，否则会报错。</li>
</ul>
<h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><p>可以结合 <code>get_target_property()</code> 和条件判断来实现动态配置，例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_target_property</span>(is_shared my_library TYPE)</span><br><span class="line"><span class="keyword">if</span>(is_shared <span class="keyword">STREQUAL</span> <span class="string">&quot;SHARED_LIBRARY&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;my_library is a shared library&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>这种用法对于复杂的 CMake 构建系统非常有用，能够动态获取目标的属性并做进一步操作。</p>
<h2 id="cmake-add-custom-command"><a href="#cmake-add-custom-command" class="headerlink" title="cmake add_custom_command()"></a>cmake add_custom_command()</h2><p><code>add_custom_command()</code> 是 CMake 中的一个常用函数，用于为目标（target）添加自定义命令。这个函数可以配置在构建过程中生成文件、执行脚本、生成资源等操作。<code>add_custom_command()</code> 有两种主要的使用方式：一种是作为生成文件的一部分（<code>OUTPUT</code>），另一种是作为构建目标的依赖项（<code>TARGET</code>）。</p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    OUTPUT output1 [output2 ...]</span><br><span class="line">    <span class="keyword">COMMAND</span> command1 [ARGS [arg1 [arg2 ...]]] [command2 ...]</span><br><span class="line">    [MAIN_DEPENDENCY depend]</span><br><span class="line">    [DEPENDS [depend1 [depend2 ...]]]</span><br><span class="line">    [BYPRODUCTS [files ...]]</span><br><span class="line">    [IMPLICIT_DEPENDS &lt;lang1&gt; depend1 [&lt;lang2&gt; depend2] ...]</span><br><span class="line">    [WORKING_DIRECTORY dir]</span><br><span class="line">    [COMMENT comment]</span><br><span class="line">    [VERBATIM] [APPEND] [USES_TERMINAL]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    <span class="keyword">TARGET</span> <span class="keyword">target</span></span><br><span class="line">    PRE_BUILD | PRE_LINK | POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> command1 [ARGS [arg1 [arg2 ...]]] [command2 ...]</span><br><span class="line">    [BYPRODUCTS [files ...]]</span><br><span class="line">    [WORKING_DIRECTORY dir]</span><br><span class="line">    [COMMENT comment]</span><br><span class="line">    [VERBATIM] [USES_TERMINAL]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="2-参数说明"><a href="#2-参数说明" class="headerlink" title="2. 参数说明"></a>2. 参数说明</h3><h4 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h4><ul>
<li><p><strong>OUTPUT</strong>: 指定自定义命令生成的文件列表。这些文件将被 CMake 认为是构建过程中的产物，因此可以在后续的构建步骤中使用。通常与 <code>DEPENDS</code> 配合使用。</p>
</li>
<li><p><strong>COMMAND</strong>: 这是最重要的部分，指定要运行的命令。可以有多个 <code>COMMAND</code>，它们会按顺序执行。可以使用 <code>ARGS</code> 指定命令的参数。</p>
</li>
<li><p><strong>DEPENDS</strong>: 指定该命令依赖的文件或目标。在这些依赖项发生变化时，自定义命令会重新运行。</p>
</li>
<li><p><strong>MAIN_DEPENDENCY</strong>: 为某些工具链优化时指定主依赖文件，通常与编译相关。</p>
</li>
<li><p><strong>BYPRODUCTS</strong>: 指定命令生成的副产物文件。特别是在多线程构建中有用，帮助 CMake 正确处理文件的生成顺序。</p>
</li>
<li><p><strong>WORKING_DIRECTORY</strong>: 指定命令运行的工作目录。</p>
</li>
<li><p><strong>COMMENT</strong>: 在执行命令时，显示的注释信息。</p>
</li>
<li><p><strong>VERBATIM</strong>: 确保命令行是精确传递的，防止 CMake 对命令进行不必要的转义。通常建议使用。</p>
</li>
<li><p><strong>USES_TERMINAL</strong>: 指示该命令需要一个终端运行，适用于需要用户交互的命令。</p>
</li>
</ul>
<h4 id="针对目标的参数"><a href="#针对目标的参数" class="headerlink" title="针对目标的参数"></a>针对目标的参数</h4><ul>
<li><p><strong>TARGET</strong>: 指定一个目标（例如可执行文件或库）。</p>
</li>
<li><p><strong>PRE_BUILD</strong>: 命令在目标构建之前执行。</p>
</li>
<li><p><strong>PRE_LINK</strong>: 命令在目标链接之前执行。</p>
</li>
<li><p><strong>POST_BUILD</strong>: 命令在目标构建完成后执行。</p>
</li>
</ul>
<h3 id="3-常见用法示例"><a href="#3-常见用法示例" class="headerlink" title="3. 常见用法示例"></a>3. 常见用法示例</h3><h4 id="生成文件的自定义命令"><a href="#生成文件的自定义命令" class="headerlink" title="生成文件的自定义命令"></a>生成文件的自定义命令</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    OUTPUT <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/generated_file.cpp</span><br><span class="line">    <span class="keyword">COMMAND</span> python <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/generate_script.py <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/generated_file.cpp</span><br><span class="line">    DEPENDS <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/generate_script.py</span><br><span class="line">    COMMENT <span class="string">&quot;Generating source file&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个例子展示了如何在构建过程中调用一个 Python 脚本生成源文件，并将其作为后续构建步骤的一部分。</p>
<h4 id="为目标添加构建步骤"><a href="#为目标添加构建步骤" class="headerlink" title="为目标添加构建步骤"></a>为目标添加构建步骤</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    <span class="keyword">TARGET</span> MyExecutable</span><br><span class="line">    POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E echo <span class="string">&quot;Build finished!&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个命令将在 <code>MyExecutable</code> 构建完成后，打印一条信息。</p>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul>
<li>如果你使用 <code>OUTPUT</code> 参数，必须确保这些输出文件在命令成功执行后生成，否则 CMake 可能会重复运行命令。</li>
<li>使用 <code>VERBATIM</code> 参数通常是最佳实践，因为它可以确保命令行正确传递，无需担心平台相关的转义问题。</li>
<li>在复杂项目中，自定义命令应合理使用依赖关系，确保构建顺序的正确性。</li>
</ul>
<p><code>add_custom_command()</code> 在处理自定义构建步骤时非常强大，合理利用可以显著提高项目构建的灵活性。</p>
<h2 id="cmake-add-subdirectory-函数-详解"><a href="#cmake-add-subdirectory-函数-详解" class="headerlink" title="cmake add_subdirectory() 函数 详解"></a>cmake add_subdirectory() 函数 详解</h2><p><code>add_subdirectory()</code> 是 CMake 中的一个函数，用于向 CMake 构建系统添加一个子目录。当你的项目结构比较复杂，需要将代码分割成多个目录时，<code>add_subdirectory()</code> 可以很方便地帮助你组织代码和构建系统。</p>
<p>这个函数的语法是：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>source_dir</code>：要添加的子目录的路径。</li>
<li><code>binary_dir</code>：可选参数，用于指定存放构建输出的目录。如果省略，则默认为 <code>source_dir</code> 下的 <code>bin</code> 目录。</li>
<li><code>EXCLUDE_FROM_ALL</code>：可选参数，如果设置了这个选项，则生成的构建目标将不会被默认构建。</li>
</ul>
<p>使用 <code>add_subdirectory()</code> 的典型场景是，你的项目主目录下有多个子目录，每个子目录都包含了一个独立的 CMakeLists.txt 文件来描述这个子目录的构建过程。例如，一个简单的项目结构可能是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">project_root/</span><br><span class="line">    CMakeLists.txt</span><br><span class="line">    src/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        file1.cpp</span><br><span class="line">        file2.cpp</span><br><span class="line">    test/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        test1.cpp</span><br><span class="line">        test2.cpp</span><br></pre></td></tr></table></figure>

<p><code>project_root/CMakeLists.txt</code> 中可以通过 <code>add_subdirectory()</code> 来引入 <code>src/</code> 和 <code>test/</code> 目录的构建规则：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">test</span>)</span><br></pre></td></tr></table></figure>

<p>然后在 <code>src/CMakeLists.txt</code> 和 <code>test/CMakeLists.txt</code> 中分别描述 <code>src/</code> 和 <code>test/</code> 目录下的构建规则。</p>
<p>通过这种方式，可以将项目的各个部分分开管理，每个部分有独立的构建规则，便于项目的组织和维护。</p>
<h2 id="cmake-target-link-directories-函数-详解"><a href="#cmake-target-link-directories-函数-详解" class="headerlink" title="cmake target_link_directories() 函数 详解"></a>cmake target_link_directories() 函数 详解</h2><p>在 CMake 中，<code>target_link_directories()</code> 函数用于为一个目标（target）指定要搜索链接库的目录。这允许你为特定目标指定链接库的搜索路径，而不是全局设置。</p>
<h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_directories</span>(<span class="keyword">target</span></span><br><span class="line">    [BEFORE]</span><br><span class="line">    directory1 [directory2 ...]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>target</code>：要指定链接库搜索路径的目标名称。</p>
</li>
<li><p><code>directory1 [directory2 ...]</code>：一个或多个链接库搜索路径。</p>
</li>
<li><p><code>BEFORE</code>：可选参数，用于指定搜索路径的添加位置。如果使用 <code>BEFORE</code>，则新的搜索路径将插入到当前搜索路径列表的最前面；否则，它们将添加到列表的末尾。</p>
</li>
</ul>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_executable main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定链接库搜索路径</span></span><br><span class="line"><span class="keyword">target_link_directories</span>(my_executable PRIVATE</span><br><span class="line">    /path/to/library/directory</span><br><span class="line">    /another/path/to/library</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>target_link_directories()</code> 函数为目标 <code>my_executable</code> 指定了两个链接库搜索路径。这意味着在构建 <code>my_executable</code> 时，CMake 将会在这两个目录中查找链接库。</p>
<p>需要注意的是，推荐使用 <code>target_link_directories()</code> 函数是因为它允许你为每个目标指定不同的链接库搜索路径。如果你只想全局指定链接库搜索路径，可以使用 <code>link_directories()</code> 函数。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局指定链接库搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(</span><br><span class="line">    /path/to/library/directory</span><br><span class="line">    /another/path/to/library</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>虽然 <code>link_directories()</code> 也可以用于指定链接库搜索路径，但在现代 CMake 中，更推荐使用 <code>target_link_directories()</code> 以提供更好的目标特定性。</p>
<h2 id="cmake-message-函数-详解"><a href="#cmake-message-函数-详解" class="headerlink" title="cmake message()函数 详解"></a>cmake message()函数 详解</h2><p>在CMake中，<code>message()</code> 函数用于在构建过程中输出消息。这对于调试CMake脚本或者提供一些提示信息非常有用。<code>message()</code>函数的基本语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([&lt;mode&gt;] <span class="string">&quot;message string&quot;</span> ...)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>&lt;mode&gt;</code> 是可选的，用于指定消息的模式，包括 <code>STATUS</code>、<code>WARNING</code>、<code>AUTHOR_WARNING</code>、<code>SEND_ERROR</code> 和 <code>FATAL_ERROR</code> 等。如果省略 <code>&lt;mode&gt;</code>，则默认是 <code>STATUS</code> 模式。</li>
<li><code>&quot;message string&quot;</code> 是要输出的消息字符串。</li>
</ul>
<p>以下是一些使用<code>message()</code>函数的示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出一般消息</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;This is a general message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出带有 STATUS 模式的消息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;This is a status message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出带有 WARNING 模式的消息</span></span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;This is a warning message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出带有 AUTHOR_WARNING 模式的消息</span></span><br><span class="line"><span class="keyword">message</span>(AUTHOR_WARNING <span class="string">&quot;This is an author warning message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出带有 SEND_ERROR 模式的消息</span></span><br><span class="line"><span class="keyword">message</span>(SEND_ERROR <span class="string">&quot;This is a send error message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出带有 FATAL_ERROR 模式的消息</span></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;This is a fatal error message&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在输出消息时，<code>message()</code>函数会根据指定的模式在终端上显示不同的颜色和标识。例如，<code>STATUS</code>模式通常是蓝色的，而<code>WARNING</code>模式是黄色的。<code>SEND_ERROR</code>和<code>FATAL_ERROR</code>模式将导致构建过程中的错误，<code>FATAL_ERROR</code>还会停止构建过程。</p>
<p><code>message()</code>函数对于在构建过程中提供有用的信息以及与开发者和用户进行交互非常有用。</p>
<h2 id="cmake-target-link-include-详解"><a href="#cmake-target-link-include-详解" class="headerlink" title="cmake target_link_include() 详解"></a>cmake target_link_include() 详解</h2><p>在CMake中，<code>target_link_libraries()</code> 和 <code>target_include_directories()</code> 是两个常用的命令，它们用于配置构建目标（通常是可执行文件或库）的依赖关系和包含目录。以下是对这两个命令的详解：</p>
<h3 id="1-target-link-libraries"><a href="#1-target-link-libraries" class="headerlink" title="1. target_link_libraries()"></a>1. <code>target_link_libraries()</code></h3><p><code>target_link_libraries()</code> 命令用于指定一个目标（可执行文件、库等）所依赖的库。它的基本语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">target</span>-name</span><br><span class="line">                      library1</span><br><span class="line">                      library2</span><br><span class="line">                      ...</span><br><span class="line">                      libraryN)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>target-name</code> 是你要链接的目标的名称。</li>
<li><code>library1</code>, <code>library2</code>, …, <code>libraryN</code> 是要链接到目标的库的名称。</li>
</ul>
<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app</span><br><span class="line">                      my_lib1</span><br><span class="line">                      my_lib2</span><br><span class="line">                      )</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>my_app</code> 可执行文件依赖于 <code>my_lib1</code> 和 <code>my_lib2</code> 库。</p>
<h3 id="2-target-include-directories"><a href="#2-target-include-directories" class="headerlink" title="2. target_include_directories()"></a>2. <code>target_include_directories()</code></h3><p><code>target_include_directories()</code> 命令用于为目标指定包含目录。它的基本语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">target</span>-name</span><br><span class="line">                           PRIVATE|PUBLIC|INTERFACE</span><br><span class="line">                           directory1</span><br><span class="line">                           directory2</span><br><span class="line">                           ...</span><br><span class="line">                           directoryN)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>target-name</code> 是你要配置的目标的名称。</li>
<li><code>PRIVATE</code>, <code>PUBLIC</code>, 或 <code>INTERFACE</code> 用于指定目录的使用范围。</li>
<li><code>directory1</code>, <code>directory2</code>, …, <code>directoryN</code> 是要包含的目录路径。</li>
</ul>
<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(my_lib my_source.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(my_lib</span><br><span class="line">                           PUBLIC</span><br><span class="line">                           <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">                           )</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>my_lib</code> 库将公开包含目录 <code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include</code>，这意味着在使用该库的目标中，这个目录将被添加到编译器的包含路径中。</p>
<p>总体而言，<code>target_link_libraries()</code> 用于指定目标依赖的库，而 <code>target_include_directories()</code> 用于指定目标的包含目录。这两个命令允许你在 CMake 中有效地管理项目的依赖关系和包含路径。</p>
<h2 id="cmake-find-package-函数-详解"><a href="#cmake-find-package-函数-详解" class="headerlink" title="cmake find_package() 函数 详解"></a>cmake find_package() 函数 详解</h2><p><code>find_package()</code> 函数是 CMake 中用于查找和引入外部软件包（例如库）的关键函数。它被用于在 CMake 项目中引入依赖项，让 CMake 知道如何定位并使用外部库或工具。</p>
<p>该函数的一般形式如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(&lt;PackageName&gt; [version] [EXACT] [QUIET] [MODULE] [REQUIRED] [[COMPONENTS] [components...]] [OPTIONAL_COMPONENTS components...])</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>&lt;PackageName&gt;</code>：指定要查找的软件包的名称，可以是已知的软件包，也可以是自定义的软件包。</li>
<li><code>[version]</code>：可选，用于指定软件包的版本号要求。</li>
<li><code>[EXACT]</code>：可选，如果指定了版本号要求，使用 EXACT 表示需要精确匹配指定版本。</li>
<li><code>[QUIET]</code>：可选，不显示查找过程中的详细信息。</li>
<li><code>[MODULE]</code>：可选，明确指定要查找的是 CMake 模块文件。</li>
<li><code>[REQUIRED]</code>：可选，如果软件包未找到，则停止 CMake 过程，报错。</li>
<li><code>[[COMPONENTS] [components...]]</code>：可选，指定软件包的组件（如果软件包有多个组件）。</li>
<li><code>[OPTIONAL_COMPONENTS components...]</code>：可选，指定可选的软件包组件。</li>
</ul>
<p>下面是一个例子，演示如何使用 <code>find_package()</code> 查找并引入 Boost 库：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 Boost 库</span></span><br><span class="line"><span class="keyword">find_package</span>(Boost <span class="number">1.65</span>.<span class="number">0</span> REQUIRED COMPONENTS filesystem system)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果找到 Boost 库，则输出信息</span></span><br><span class="line"><span class="keyword">if</span> (Boost_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Boost found. Include dirs: $&#123;Boost_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Boost libraries: $&#123;Boost_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Boost not found.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>find_package(Boost 1.65.0 REQUIRED COMPONENTS filesystem system)</code> 表示查找 Boost 库的版本号至少为 1.65.0，必须包含 <code>filesystem</code> 和 <code>system</code> 两个组件。如果找到了 Boost 库，则输出相应的信息，否则停止 CMake 过程并报错。</p>
<p>总体而言，<code>find_package()</code> 函数使得在 CMake 项目中集成外部依赖项变得更加灵活和方便。</p>
<h2 id="CMakeLists-add-definitions-详解"><a href="#CMakeLists-add-definitions-详解" class="headerlink" title="CMakeLists add_definitions() 详解"></a>CMakeLists add_definitions() 详解</h2><p><code>add_definitions()</code> 是 CMake 中用于添加编译器宏定义的命令。它允许您在整个项目中为源代码文件添加全局宏定义，以实现条件编译或其他编译时配置。以下是有关 <code>add_definitions()</code> 的详解：</p>
<p><strong>语法：</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-D&lt;DEFINE_1&gt; -D&lt;DEFINE_2&gt; ... -D&lt;DEFINE_N&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-D&lt;DEFINE&gt;</code>: 指定一个宏定义，<code>-D</code> 后跟宏的名称。您可以使用多个 <code>-D</code> 来指定多个宏定义。</li>
</ul>
<p><strong>示例：</strong></p>
<p>假设您希望在整个项目中定义一个宏，例如 <code>ENABLE_FEATURE_X</code>，以便在源代码文件中进行条件编译。您可以在项目的 CMakeLists.txt 文件中使用 <code>add_definitions()</code> 来定义宏：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-DENABLE_FEATURE_X)</span><br></pre></td></tr></table></figure>

<p>这将使 <code>-DENABLE_FEATURE_X</code> 添加到编译器命令行，以便在编译源文件时启用该宏。您可以在源代码文件中使用 <code>#ifdef</code> 或 <code>#ifndef</code> 指令来检查该宏的存在，然后根据需要执行不同的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENABLE_FEATURE_X</span></span><br><span class="line"><span class="comment">// 这部分代码只在 ENABLE_FEATURE_X 定义时编译</span></span><br><span class="line"><span class="comment">// 执行 Feature X 相关的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 这部分代码在 ENABLE_FEATURE_X 未定义时编译</span></span><br><span class="line"><span class="comment">// 执行其他操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li><code>add_definitions()</code> 命令将全局宏定义应用于整个项目，因此请确保不会意外地影响其他目标或源文件。如果需要更精确的控制，可以考虑使用 <code>target_compile_definitions()</code> 命令来为特定目标添加宏定义。</li>
<li>如果您需要定义带有值的宏，例如 <code>-DVERSION_NUMBER=42</code>，只需在 <code>-D</code> 后添加宏的名称和值即可。</li>
<li>使用 <code>add_definitions()</code> 命令会为所有目标和源文件添加宏定义，这可能会导致不必要的宏定义冲突。因此，在 CMake 3.12 及更高版本中，推荐使用 <code>target_compile_definitions()</code> 来更精确地控制宏定义的作用范围。</li>
</ul>
<p>总之，<code>add_definitions()</code> 是用于添加全局宏定义的 CMake 命令，它可以帮助您在整个项目中进行条件编译和其他编译时配置。</p>
<h2 id="cmake-CMakeLists-txt-include-directories-函数-详解"><a href="#cmake-CMakeLists-txt-include-directories-函数-详解" class="headerlink" title="cmake CMakeLists.txt include_directories()函数 详解"></a>cmake CMakeLists.txt include_directories()函数 详解</h2><p><code>include_directories()</code>函数是CMake中的一个用于指定头文件包含路径的函数。它用于告诉CMake编译器在哪里查找头文件。在CMakeLists.txt文件中使用<code>include_directories()</code>函数非常有用，因为它允许您配置项目以便正确找到所有所需的头文件。</p>
<p>下面是关于<code>include_directories()</code>函数的详细解释：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(directory1 [directory2 ...])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>directory1</code>, <code>directory2</code>, …：这些参数是包含头文件的目录路径。您可以指定一个或多个目录，用于告诉CMake查找头文件的位置。通常，这些目录路径是相对于<code>CMakeLists.txt</code>文件的。</li>
</ul>
<p><code>include_directories()</code>函数的作用是将指定的目录路径添加到CMake项目的头文件包含路径中，以使编译器能够找到所需的头文件。当您使用<code>#include</code>指令包含头文件时，编译器将在这些目录中查找头文件。</p>
<p>示例用法：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)  <span class="comment"># 添加一个名为&quot;include&quot;的头文件目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者指定多个头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">    <span class="keyword">include</span></span><br><span class="line">    common</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>include_directories()</code>函数用于指定项目的头文件搜索路径，通常这些路径包括项目中的<code>include</code>目录和<code>common</code>目录。这使得您可以在CMake项目中使用相对路径来包含头文件，而无需手动指定完整的文件路径。</p>
<p>请注意，从CMake 3.15开始，更推荐使用<code>target_include_directories()</code>函数，它允许更好的目标级别控制，以及更容易实现接口库的目录传递。这是一个更现代和更具有可维护性的做法。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(target_name</span><br><span class="line">    PUBLIC</span><br><span class="line">        <span class="keyword">include</span></span><br><span class="line">    PRIVATE</span><br><span class="line">        private_include</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上述示例中，<code>target_include_directories()</code>函数将头文件目录添加到名为<code>target_name</code>的目标（可执行文件或库）中，可以使用<code>PUBLIC</code>和<code>PRIVATE</code>修饰符来指定头文件目录的可见性。这提供了更灵活的控制选项。</p>
<h2 id="cmake-CMakeLists-txt-内置变量"><a href="#cmake-CMakeLists-txt-内置变量" class="headerlink" title="cmake CMakeLists.txt 内置变量"></a>cmake CMakeLists.txt 内置变量</h2><p>CMake提供了一些内置变量，用于获取有关项目和构建环境的信息，您可以在CMakeLists.txt文件中使用这些变量来进行配置和生成目标。以下是一些常用的内置变量：</p>
<ol>
<li><p><code>CMAKE_SOURCE_DIR</code>：指向CMakeLists.txt文件所在的源代码根目录的路径。</p>
</li>
<li><p><code>CMAKE_BINARY_DIR</code>：指向CMake生成构建文件的根目录的路径。这通常是项目构建的目录，与源代码分开。</p>
</li>
<li><p><code>CMAKE_CURRENT_SOURCE_DIR</code>：指向当前处理的CMakeLists.txt文件所在的目录。</p>
</li>
<li><p><code>CMAKE_CURRENT_BINARY_DIR</code>：指向与当前处理的CMakeLists.txt文件关联的构建目录。</p>
</li>
<li><p><code>CMAKE_PROJECT_NAME</code>：包含当前项目的名称，通常由<code>project()</code>命令指定。</p>
</li>
<li><p><code>CMAKE_VERSION</code>：CMake的版本信息。</p>
</li>
<li><p><code>CMAKE_CXX_COMPILER</code>：指向C++编译器的可执行文件路径。</p>
</li>
<li><p><code>CMAKE_C_COMPILER</code>：指向C编译器的可执行文件路径。</p>
</li>
<li><p><code>CMAKE_SYSTEM</code>：指定操作系统的名称。</p>
</li>
<li><p><code>CMAKE_SYSTEM_NAME</code>：指定操作系统的名称，通常是与<code>CMAKE_SYSTEM</code>相同。</p>
</li>
<li><p><code>CMAKE_SYSTEM_VERSION</code>：指定操作系统的版本号。</p>
</li>
<li><p><code>CMAKE_SYSTEM_PROCESSOR</code>：指定操作系统的处理器架构。</p>
</li>
<li><p><code>CMAKE_BUILD_TYPE</code>：用于指定构建类型（例如，Debug、Release、RelWithDebInfo等）。可以使用此变量来控制编译器标志和优化级别。</p>
</li>
<li><p><code>CMAKE_INSTALL_PREFIX</code>：指定安装目标的根目录。默认情况下，它通常是<code>/usr/local</code>（Linux）或<code>C:\Program Files</code>（Windows）。</p>
</li>
<li><p><code>CMAKE_MODULE_PATH</code>：用于指定查找CMake模块的路径。模块通常用于共享一些通用的CMake配置。</p>
</li>
</ol>
<p>这些内置变量可用于配置项目的不同方面，包括源文件路径、构建文件路径、编译器信息、操作系统信息和其他构建选项。您可以在CMakeLists.txt文件中使用这些变量，以根据项目的需求自定义构建过程。</p>
<h2 id="cmake-构建选项-打开开关"><a href="#cmake-构建选项-打开开关" class="headerlink" title="cmake 构建选项 打开开关"></a>cmake 构建选项 打开开关</h2><p>在 CMake 中，你可以使用 <code>option</code> 命令创建构建选项开关，以便在构建时根据用户的选择来开启或关闭某些功能。这些选项通常用于控制编译和构建过程中的一些特定配置。以下是如何在 CMake 中创建和使用构建选项开关的示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 CMakeLists.txt 中添加以下代码</span></span><br><span class="line"><span class="keyword">option</span>(BUILD_FEATURE_X <span class="string">&quot;Build feature X&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">option</span>(BUILD_FEATURE_Y <span class="string">&quot;Build feature Y&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在合适的位置，根据选项的状态来设置相关内容</span></span><br><span class="line"><span class="keyword">if</span>(BUILD_FEATURE_X)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Building feature X&quot;</span>)</span><br><span class="line">    <span class="keyword">add_subdirectory</span>(feature_x)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_FEATURE_Y)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Building feature Y&quot;</span>)</span><br><span class="line">    <span class="keyword">add_subdirectory</span>(feature_y)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了两个构建选项：<code>BUILD_FEATURE_X</code> 和 <code>BUILD_FEATURE_Y</code>。选项的初始状态分别设置为 <code>ON</code> 和 <code>OFF</code>。如果用户希望构建时开启 “Feature X”，可以在构建命令中使用 <code>-DBUILD_FEATURE_X=ON</code>，而如果希望关闭 “Feature Y”，可以使用 <code>-DBUILD_FEATURE_Y=OFF</code>。</p>
<p>根据选项的状态，我们在适当的位置添加了相关的配置。在这个例子中，如果选项 <code>BUILD_FEATURE_X</code> 被设置为 <code>ON</code>，就会构建名为 <code>feature_x</code> 的子目录中的内容。类似地，如果选项 <code>BUILD_FEATURE_Y</code> 被设置为 <code>ON</code>，就会构建 <code>feature_y</code> 子目录中的内容。</p>
<p>在实际项目中，你可以根据需要添加更多的选项和配置。这样的构建选项使得用户能够根据项目需求自定义构建过程，只构建他们需要的功能。</p>
<h2 id="cmake-变量"><a href="#cmake-变量" class="headerlink" title="cmake 变量"></a>cmake 变量</h2><p>在CMake中，变量用于存储和操作数据，可以在CMake脚本中定义、设置和使用。下面是对CMake变量的详细解释：</p>
<ol>
<li><p>CMake缓存变量（CMake Cache Variables）：这些变量存储在CMake缓存中，并可以通过CMake GUI或命令行进行设置。它们在多次运行CMake时保持持久，并且可以影响项目的配置。常见的CMake缓存变量包括<code>CMAKE_INSTALL_PREFIX</code>（安装路径）、<code>CMAKE_BUILD_TYPE</code>（构建类型）等。</p>
</li>
<li><p>CMake内部变量（CMake Internal Variables）：这些变量由CMake自身设置和使用，用于控制CMake的行为和功能。它们具有特殊的前缀或名称，例如<code>CMAKE_SOURCE_DIR</code>（项目根目录路径）、<code>CMAKE_BINARY_DIR</code>（构建目录路径）等。</p>
</li>
<li><p>用户定义变量：这些变量由用户在CMake脚本中定义和设置。使用<code>set()</code>函数可以创建用户定义变量，并使用<code>$&#123;&#125;</code>语法引用它们。例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_VARIABLE <span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>环境变量：CMake可以读取和使用系统环境变量。可以使用<code>$ENV&#123;VAR_NAME&#125;</code>语法引用环境变量。例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Home directory: $ENV&#123;HOME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cache Entry变量：CMake提供了<code>set()</code>函数的高级形式，用于创建带有用户友好描述和其他属性的缓存变量。例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_VARIABLE <span class="string">&quot;Hello, world!&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;A user-friendly description&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为<code>MY_VARIABLE</code>的缓存变量，它具有用户友好的描述和其他属性，可以在CMake GUI中显示和设置。</p>
</li>
<li><p>List变量：List变量是一种特殊类型的变量，可以包含多个值。你可以使用<code>set()</code>函数将多个值存储到List变量中，并使用<code>$&#123;&#125;</code>语法访问和操作它们。例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(LIST_VARIABLE <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;List variable: $&#123;LIST_VARIABLE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果将是<code>value1;value2;value3</code>。</p>
</li>
</ol>
<p>这些是CMake中常见的变量类型和用法。在CMake脚本中，你可以根据需要使用这些变量来控制和配置项目。</p>
<hr>
<h2 id="cmake-3-10-2-option"><a href="#cmake-3-10-2-option" class="headerlink" title="cmake 3.10.2 option"></a>cmake 3.10.2 option</h2><p>在CMake 3.10.2版本中，<code>option</code>命令用于定义和处理用户选项。它允许您在CMake配置过程中提供一些可配置的选项，以便用户可以根据需要进行选择。</p>
<p>以下是<code>option</code>命令的语法：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span>(&lt;option_variable&gt; <span class="string">&quot;&lt;option_description&gt;&quot;</span> [initial_value])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;option_variable&gt;</code>：要定义的选项的变量名。</li>
<li><code>&lt;option_description&gt;</code>：选项的描述文本，将在配置过程中显示给用户。</li>
<li><code>[initial_value]</code>：选项的初始值，默认情况下为<code>OFF</code>。如果用户选择了该选项，则变量的值为<code>ON</code>。</li>
</ul>
<p>使用<code>option</code>命令定义选项后，可以通过<code>$&#123;&lt;option_variable&gt;&#125;</code>来引用选项的值。</p>
<p>以下是一个示例，展示了CMake 3.10.2中<code>option</code>命令的使用：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span>(BUILD_TESTS <span class="string">&quot;Build test targets&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">option</span>(DEBUG_LOGGING <span class="string">&quot;Enable debug logging&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_TESTS)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Building test targets&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Not building test targets&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(DEBUG_LOGGING)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Debug logging is enabled&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Debug logging is disabled&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>在上述示例中，定义了两个选项：<code>BUILD_TESTS</code>和<code>DEBUG_LOGGING</code>。<code>BUILD_TESTS</code>的初始值为<code>ON</code>，而<code>DEBUG_LOGGING</code>的初始值为<code>OFF</code>。</p>
<p>根据选项的值，使用<code>if</code>语句来执行相应的操作。如果<code>BUILD_TESTS</code>为<code>ON</code>，则输出”Building test targets”；否则输出”Not building test targets”。如果<code>DEBUG_LOGGING</code>为<code>ON</code>，则输出”Debug logging is enabled”；否则输出”Debug logging is disabled”。</p>
<p>在CMake的配置过程中，用户可以通过设置这些选项来控制构建的行为。</p>
<p>请注意，选项的值是通过CMake<strong>缓存系统</strong>进行保存的，可以通过命令行选项或图形界面工具来修改选项的值。</p>
<h2 id="cmake-find-library-和-find-package"><a href="#cmake-find-library-和-find-package" class="headerlink" title="cmake find_library 和 find_package"></a>cmake find_library 和 find_package</h2><p><code>find_library</code> 和 <code>find_package</code> 是 CMake 中用于查找库的两个不同的命令，它们各自适用于不同的场景和目的。</p>
<h3 id="find-library"><a href="#find-library" class="headerlink" title="find_library:"></a><code>find_library</code>:</h3><ul>
<li><strong>用途：</strong> <code>find_library</code> 用于查找和定位系统中的库文件。</li>
<li><strong>语法：</strong> <code>find_library(&lt;VAR&gt; names...)</code></li>
<li><strong>示例：</strong><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_library</span>(MY_LIBRARY mylib)</span><br><span class="line"><span class="keyword">if</span>(MY_LIBRARY)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Library found: $&#123;MY_LIBRARY&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Library not found&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li>
<li><strong>说明：</strong> <code>find_library</code> 将库文件的名称传递给 <code>names</code> 参数，并尝试在系统中找到该库文件。如果找到，它将设置 <code>&lt;VAR&gt;</code> 变量为库文件的完整路径。在上述示例中，如果找到名为 <code>libmylib.so</code> 的库文件，<code>MY_LIBRARY</code> 变量将被设置为该库文件的完整路径。</li>
</ul>
<h3 id="find-package"><a href="#find-package" class="headerlink" title="find_package:"></a><code>find_package</code>:</h3><ul>
<li><strong>用途：</strong> <code>find_package</code> 用于查找和配置第三方软件包，通常用于查找 CMake 模块。</li>
<li><strong>语法：</strong> <code>find_package(&lt;PackageName&gt; [version] [EXACT] [QUIET] [MODULE] [REQUIRED] [COMPONENTS [components...]])</code></li>
<li><strong>示例：</strong><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost <span class="number">1.70</span> REQUIRED COMPONENTS filesystem system)</span><br><span class="line"><span class="keyword">if</span>(Boost_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Boost found: $&#123;Boost_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Boost libraries: $&#123;Boost_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Boost not found&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li>
<li><strong>说明：</strong> <code>find_package</code> 用于查找并配置第三方软件包，通常使用 CMake 模块来实现。在上述示例中，<code>find_package</code> 尝试查找 Boost 库，并确保找到指定版本以及必需的组件（filesystem 和 system）。如果找到，它将设置相应的变量（例如，<code>Boost_INCLUDE_DIRS</code> 和 <code>Boost_LIBRARIES</code>）以供后续使用。</li>
</ul>
<h3 id="选择使用："><a href="#选择使用：" class="headerlink" title="选择使用："></a>选择使用：</h3><ul>
<li>如果你只需要查找和链接系统中的某个库文件，可以使用 <code>find_library</code>。</li>
<li>如果你需要查找和配置第三方软件包，使用 <code>find_package</code> 通常更方便，因为它可以利用 CMake 模块提供的更多信息。</li>
</ul>
<p>总体来说，选择使用哪一个命令取决于你的具体需求和项目的复杂性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/CMake/cmake_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-cmake_3_01_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/CMake/cmake_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-cmake_3_01_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">cmake_3_01_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>CMake常用的方法和CMakeLists编程技巧</li>
</ul>
<h2 id="cmake-选择编译器及设置编译器选项"><a href="#cmake-选择编译器及设置编译器选项" class="headerlink" title="cmake 选择编译器及设置编译器选项"></a>cmake 选择编译器及设置编译器选项</h2><h3 id="使用命令行"><a href="#使用命令行" class="headerlink" title="使用命令行"></a>使用命令行</h3><ul>
<li>在编译时可以通过参数直接选择指定的编译器的完整路径，例如gcc8.3.0安装在&#x2F;usr&#x2F;local&#x2F;gcc&#x2F;bin路径下，在编译时输入： cmake .. -DCMAKE_CXX_COMPILER&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc&#x2F;bin&#x2F;g++</li>
</ul>
<h3 id="在配置文件中指定"><a href="#在配置文件中指定" class="headerlink" title="在配置文件中指定"></a>在配置文件中指定</h3><ul>
<li>在CMakeLists.txt文件中添加<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">&quot;/usr/local/gcc/bin/gcc&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;/usr/local/gcc/bin/g++&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>直接修改全局变量CMAKE_C_COMPILER和CMAKE_CXX_COMPILER为指定的编译器路径</li>
<li>注：<strong>这两条命令应该放在文件的开始位置(cmake_minimum_required命令之下，其他命令之上，否则可能无效)</strong></li>
</ul>
<h2 id="CMakeLists-添加宏定义"><a href="#CMakeLists-添加宏定义" class="headerlink" title="CMakeLists 添加宏定义"></a>CMakeLists 添加宏定义</h2><p>在 CMake 中，要添加宏定义（宏定义通常用于条件编译），您可以使用 <code>add_definitions</code> 或 <code>target_compile_definitions</code> 命令，具体取决于您希望将宏定义应用于整个项目还是特定的目标。</p>
<p><strong>1. 使用 <code>add_definitions</code> 添加宏定义（全局）：</strong></p>
<p><code>add_definitions</code> 命令用于在整个项目范围内添加宏定义。在 CMakeLists.txt 文件中，您可以像这样添加宏定义：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-DMY_MACRO=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这将定义一个名为 <code>MY_MACRO</code> 的宏，其值为 <code>1</code>。您可以在项目的任何源文件中使用该宏。</p>
<p><strong>2. 使用 <code>target_compile_definitions</code> 添加宏定义（特定目标）：</strong></p>
<p>如果您只想为特定目标（如可执行文件或库）添加宏定义，可以使用 <code>target_compile_definitions</code> 命令。例如，假设您有一个名为 <code>my_target</code> 的目标：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(my_target PRIVATE MY_MACRO=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这将为 <code>my_target</code> 目标添加一个名为 <code>MY_MACRO</code> 的宏，其值为 <code>1</code>。<code>PRIVATE</code> 关键字表示该宏定义仅应用于 <code>my_target</code>，而不会传播到其他目标。</p>
<p>请根据您的项目需求和结构选择适当的方法来添加宏定义。无论是使用 <code>add_definitions</code> 还是 <code>target_compile_definitions</code>，都可以为您的 CMake 项目添加宏定义以进行条件编译。</p>
<h2 id="cmake-CMakeLists-txt文件编译多个可执行文件-for循环-示例-详解"><a href="#cmake-CMakeLists-txt文件编译多个可执行文件-for循环-示例-详解" class="headerlink" title="cmake CMakeLists.txt文件编译多个可执行文件 for循环 示例 详解"></a>cmake CMakeLists.txt文件编译多个可执行文件 for循环 示例 详解</h2><p>要在CMake中使用循环来生成多个可执行文件，通常需要使用CMake的<code>foreach</code>循环结构。下面是一个示例CMakeLists.txt文件，展示如何使用<code>foreach</code>循环来生成多个可执行文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有要编译的可执行文件</span></span><br><span class="line"><span class="keyword">set</span>(executables</span><br><span class="line">    MyExecutable1</span><br><span class="line">    MyExecutable2</span><br><span class="line">    MyExecutable3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历可执行文件列表并生成它们</span></span><br><span class="line"><span class="keyword">foreach</span>(executable <span class="variable">$&#123;executables&#125;</span>)</span><br><span class="line">    <span class="comment"># 每个可执行文件的源文件</span></span><br><span class="line">    <span class="keyword">set</span>(<span class="variable">$&#123;executable&#125;</span>_sources <span class="variable">$&#123;executable&#125;</span>.cpp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加可执行文件</span></span><br><span class="line">    <span class="keyword">add_executable</span>(<span class="variable">$&#123;executable&#125;</span> <span class="variable">$&#123;$&#123;executable&#125;</span>_sources&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果可执行文件有依赖库文件，可以在这里链接它们</span></span><br><span class="line">    <span class="comment"># target_link_libraries($&#123;executable&#125; SomeLibrary)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>

<p>这个示例CMakeLists.txt文件包含以下关键部分：</p>
<ol>
<li><p><code>set(executables ...)</code>：这一行定义了一个变量<code>executables</code>，其中包含了要编译的多个可执行文件的名称。在这个示例中，我们列出了三个可执行文件的名称，但您可以根据需要添加更多。</p>
</li>
<li><p><code>foreach(executable $&#123;executables&#125;)</code>：这是一个<code>foreach</code>循环，用于迭代<code>executables</code>变量中的每个可执行文件名称。</p>
</li>
<li><p><code>set($&#123;executable&#125;_sources $&#123;executable&#125;.cpp)</code>：在循环内，我们为每个可执行文件设置了一个源文件变量，例如<code>MyExecutable1_sources</code>，这是根据可执行文件的名称构建的。</p>
</li>
<li><p><code>add_executable($&#123;executable&#125; $&#123;$&#123;executable&#125;_sources&#125;)</code>：在循环内，我们使用<code>add_executable</code>命令为每个可执行文件生成目标。<code>add_executable</code>使用了之前定义的源文件变量。</p>
</li>
<li><p>（可选）<code>target_link_libraries($&#123;executable&#125; SomeLibrary)</code>：如果可执行文件有依赖的库文件，可以使用此命令将它们链接到可执行文件。</p>
</li>
</ol>
<p>这种结构使您能够轻松地扩展项目，以支持多个可执行文件，而无需手动为每个文件编写<code>add_executable</code>命令。这在大型项目中特别有用，因为它可以减少配置文件的复杂性。</p>
<h2 id="cmake-CMakeLists-txt文件编译多个可执行文件常见结构-示例-详解"><a href="#cmake-CMakeLists-txt文件编译多个可执行文件常见结构-示例-详解" class="headerlink" title="cmake CMakeLists.txt文件编译多个可执行文件常见结构 示例 详解"></a>cmake CMakeLists.txt文件编译多个可执行文件常见结构 示例 详解</h2><p>CMake是一个用于管理C++项目的跨平台构建工具，它允许您配置项目并生成适用于不同编译器和操作系统的构建系统。在CMake中，通常将项目的构建配置信息保存在一个名为CMakeLists.txt的文件中。</p>
<p>如果您想要在一个CMake项目中编译多个可执行文件，通常可以按照以下结构来组织CMakeLists.txt文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)  <span class="comment"># 指定最低的CMake版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(MyProject)  <span class="comment"># 指定项目名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件1</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable1</span><br><span class="line">    source1.cpp</span><br><span class="line">    source2.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件2</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable2</span><br><span class="line">    source3.cpp</span><br><span class="line">    source4.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：如果项目中有共享的库文件，可以使用add_library添加库文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库文件到可执行文件1</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable1</span><br><span class="line">    SomeLibrary1</span><br><span class="line">    SomeLibrary2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库文件到可执行文件2</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable2</span><br><span class="line">    SomeLibrary3</span><br><span class="line">    SomeLibrary4</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上述代码是一个简单的CMakeLists.txt文件，用于编译两个可执行文件。以下是对代码的详细解释：</p>
<ol>
<li><p><code>cmake_minimum_required(VERSION 3.0)</code>：这一行指定了项目所需的最低CMake版本。您可以根据您的需要更改此版本号。</p>
</li>
<li><p><code>project(MyProject)</code>：这一行指定了项目的名称。在这里，项目名称被设置为”MyProject”，您可以将其替换为您的项目名称。</p>
</li>
<li><p><code>add_executable(MyExecutable1 source1.cpp source2.cpp)</code>：这一行添加了一个名为”MyExecutable1”的可执行文件，并指定了源代码文件(source1.cpp和source2.cpp)。您可以根据您的项目需要添加更多的源文件。</p>
</li>
<li><p><code>add_executable(MyExecutable2 source3.cpp source4.cpp)</code>：同样，这一行添加了一个名为”MyExecutable2”的可执行文件，并指定了不同的源代码文件。</p>
</li>
<li><p><code>target_link_libraries(MyExecutable1 SomeLibrary1 SomeLibrary2)</code>：如果您的项目依赖于一些库文件，您可以使用这行来链接这些库文件到”MyExecutable1”。类似地，您可以为”MyExecutable2”链接其他库文件。</p>
</li>
</ol>
<p>这只是一个简单的示例，CMake支持更复杂的项目结构和配置选项，可以根据实际需求进行定制。在实际项目中，您可能需要添加更多的配置信息，如编译选项、包含路径、安装规则等。请根据您的项目需求进一步扩展和定制CMakeLists.txt文件。</p>
<h2 id="cmake-CMakeLists-txt文件常见结构-示例-详解"><a href="#cmake-CMakeLists-txt文件常见结构-示例-详解" class="headerlink" title="cmake CMakeLists.txt文件常见结构 示例 详解"></a>cmake CMakeLists.txt文件常见结构 示例 详解</h2><p>CMakeLists.txt文件是CMake项目的核心配置文件，它定义了项目的属性、源文件、依赖关系和构建规则。以下是一个常见的CMakeLists.txt文件结构示例，带有详细的解释：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定CMake的最低版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义项目名称</span></span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件并指定源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(myapp</span><br><span class="line">    main.cpp         <span class="comment"># 主程序入口</span></span><br><span class="line">    utils.cpp        <span class="comment"># 自定义工具函数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可选的编译标志</span></span><br><span class="line"><span class="comment"># add_compile_options(-std=c++11)  # 设置C++标准，可选</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找并添加依赖的库（例如，查找并添加Boost库）</span></span><br><span class="line"><span class="comment"># find_package(Boost REQUIRED)</span></span><br><span class="line"><span class="comment"># include_directories($&#123;Boost_INCLUDE_DIRS&#125;)</span></span><br><span class="line"><span class="comment"># target_link_libraries(myapp $&#123;Boost_LIBRARIES&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出目录，将可执行文件放在bin目录中</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置C++标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加子目录，可以在子目录中定义更多的CMakeLists.txt文件</span></span><br><span class="line"><span class="comment"># add_subdirectory(subdirectory_name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以定义自定义的构建规则、安装规则等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以包括其他CMakeLists.txt文件</span></span><br><span class="line"><span class="comment"># include(subdirectory_name/CMakeLists.txt)</span></span><br></pre></td></tr></table></figure>

<p>上述示例演示了一个简单的CMakeLists.txt文件，以下是各个部分的详细解释：</p>
<ol>
<li><p><code>cmake_minimum_required(VERSION 3.0)</code>：这一行指定了最低的CMake版本要求。</p>
</li>
<li><p><code>project(MyProject)</code>：这一行定义了项目的名称。项目名称将用于生成构建文件和可执行文件的前缀。</p>
</li>
<li><p><code>add_executable(myapp ...)</code>：这一行定义了可执行文件（myapp）以及与之关联的源文件。列出了要包括在可执行文件中的所有源文件。</p>
</li>
<li><p><code>add_compile_options(-std=c++11)</code>：这是一个可选部分，用于设置编译选项。在这里，它设置了C++标准为C++11。</p>
</li>
<li><p><code>find_package(Boost REQUIRED)</code>：这是一个可选的示例，用于查找并添加依赖的库。在这里，它查找并添加了Boost库。</p>
</li>
<li><p><code>set(EXECUTABLE_OUTPUT_PATH $&#123;CMAKE_BINARY_DIR&#125;/bin)</code>：这一行指定了可执行文件的输出目录，通常会将可执行文件放在<code>bin</code>子目录中。</p>
</li>
<li><p><code>set(CMAKE_CXX_STANDARD 11)</code>：这一行指定了项目所使用的C++标准。</p>
</li>
<li><p><code>add_subdirectory(subdirectory_name)</code>：这一行用于包括子目录，如果项目需要包括其他模块或库，你可以在子目录中定义另一个CMakeLists.txt文件。</p>
</li>
<li><p><code>include(subdirectory_name/CMakeLists.txt)</code>：这一行可以用于包括其他CMakeLists.txt文件，如果你希望将其他项目的构建规则包括到当前项目中。</p>
</li>
</ol>
<p>这只是一个简单的示例，你可以根据项目的需求和复杂性来扩展和修改CMakeLists.txt文件。CMake提供了广泛的选项和命令，以支持各种不同类型的项目和构建需求。</p>
<h2 id="cmake-3-10-2-退出-终止-命令"><a href="#cmake-3-10-2-退出-终止-命令" class="headerlink" title="cmake 3.10.2 退出 终止 命令"></a>cmake 3.10.2 退出 终止 命令</h2><p>在CMake 3.10.2版本中，可以使用<code>return()</code>命令来退出当前的CMake脚本的执行。这个命令会立即终止当前脚本的执行，并返回到调用方。</p>
<p>以下是<code>return()</code>命令的用法：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>()</span><br></pre></td></tr></table></figure>

<p>当调用<code>return()</code>命令时，CMake会立即停止执行当前的CMake脚本，并返回到调用方。</p>
<p>以下是一个简单的示例，演示如何使用<code>return()</code>命令退出CMake脚本的执行：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查条件，如果不满足则退出脚本</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> SOME_CONDITION)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Condition not met, exiting...&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行其他操作</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Continuing execution...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，如果<code>SOME_CONDITION</code>条件不满足，那么在执行到<code>return()</code>命令时，脚本将立即退出并返回到调用方。否则，将继续执行后续的操作。</p>
<p>请注意，<code>return()</code>命令只能用于退出当前的CMake脚本，并返回到调用方。它不会终止整个CMake过程。如果您需要终止整个CMake过程，可以使用<code>message(FATAL_ERROR &quot;Error message&quot;)</code>命令，该命令会显示一个致命错误消息并终止整个CMake过程的执行。</p>
<hr>
<h2 id="cmake-3-10-2-switch-选择实现"><a href="#cmake-3-10-2-switch-选择实现" class="headerlink" title="cmake 3.10.2 switch 选择实现"></a>cmake 3.10.2 switch 选择实现</h2><p>在CMake 3.10.2版本中，由于没有直接支持的<code>switch</code>语句，您可以使用多个<code>if</code>和<code>elseif</code>语句来实现类似的功能。</p>
<p>以下是一个示例，展示如何使用多个<code>if</code>和<code>elseif</code>语句实现类似<code>switch</code>的功能：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(SWITCH_VAR <span class="string">&quot;value2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SWITCH_VAR <span class="keyword">STREQUAL</span> <span class="string">&quot;value1&quot;</span>)</span><br><span class="line">    <span class="comment"># 执行value1对应的操作</span></span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Switch case: value1&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(SWITCH_VAR <span class="keyword">STREQUAL</span> <span class="string">&quot;value2&quot;</span>)</span><br><span class="line">    <span class="comment"># 执行value2对应的操作</span></span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Switch case: value2&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(SWITCH_VAR <span class="keyword">STREQUAL</span> <span class="string">&quot;value3&quot;</span>)</span><br><span class="line">    <span class="comment"># 执行value3对应的操作</span></span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Switch case: value3&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="comment"># 执行默认的操作</span></span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Switch default case&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了多个<code>if</code>和<code>elseif</code>语句来检查变量<code>SWITCH_VAR</code>的值，并根据不同的条件执行相应的操作。如果<code>SWITCH_VAR</code>的值等于<code>value1</code>，则执行与<code>value1</code>对应的操作；如果<code>SWITCH_VAR</code>的值等于<code>value2</code>，则执行与<code>value2</code>对应的操作，依此类推。如果没有匹配的条件，将执行<code>else</code>语句中定义的默认操作。</p>
<p>虽然这种方式在CMake 3.10.2中没有直接的<code>switch</code>语句，但通过使用多个<code>if</code>和<code>elseif</code>语句，您可以根据不同的条件选择不同的操作，实现类似<code>switch</code>的功能。请根据实际需求编写适当的条件判断，并执行相应的操作。</p>
<hr>
<h2 id="cmake-3-10-2-通过宏选择不同目标编译"><a href="#cmake-3-10-2-通过宏选择不同目标编译" class="headerlink" title="cmake 3.10.2 通过宏选择不同目标编译"></a>cmake 3.10.2 通过宏选择不同目标编译</h2><p>在CMake 3.10.2版本中，可以使用<code>option</code>命令来定义宏，并通过<code>if</code>语句来选择不同的目标编译。以下是一个示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义宏，用于选择编译选项</span></span><br><span class="line"><span class="keyword">option</span>(BUILD_TARGET_A <span class="string">&quot;Build target A&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">option</span>(BUILD_TARGET_B <span class="string">&quot;Build target B&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加源文件</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES src/main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据宏的值，选择要构建的目标</span></span><br><span class="line"><span class="keyword">if</span>(BUILD_TARGET_A)</span><br><span class="line">    <span class="keyword">add_executable</span>(targetA <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line">    <span class="comment"># 其他针对目标A的配置</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_TARGET_B)</span><br><span class="line">    <span class="keyword">add_executable</span>(targetB <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line">    <span class="comment"># 其他针对目标B的配置</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用<code>option</code>命令定义了两个宏：<code>BUILD_TARGET_A</code>和<code>BUILD_TARGET_B</code>。这两个宏的默认值分别为ON和OFF。根据这些宏的值，我们使用<code>if</code>语句选择要构建的目标。</p>
<p>要使用CMake 3.10.2版本运行上述CMakeLists.txt文件，可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -H. -Bbuild</span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>

<p>这将在<code>build</code>目录中生成构建文件，并使用生成的构建文件来构建目标。</p>
<p>请注意，如果您的CMake版本较旧，某些语法可能不受支持。确保在运行CMake命令之前，检查您所使用的CMake版本是否支持所需的功能。</p>
<hr>
<h2 id="cmake-3-10-2-打印-语法"><a href="#cmake-3-10-2-打印-语法" class="headerlink" title="cmake 3.10.2 打印 语法"></a>cmake 3.10.2 打印 语法</h2><p>在CMake 3.10.2版本中，您可以使用<code>message</code>命令来打印消息、变量值和其他调试信息。<code>message</code>命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([&lt;mode&gt;] <span class="string">&quot;&lt;message string&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>其中，<code>mode</code>是可选参数，用于指定消息的类型。常用的<code>mode</code>参数有以下几种：</p>
<ul>
<li><code>STATUS</code>：打印带有前缀<code>--</code>的消息。</li>
<li><code>WARNING</code>：打印带有前缀<code>-- Warning:</code>的警告消息。</li>
<li><code>AUTHOR_WARNING</code>：打印带有前缀<code>-- Author Warning:</code>的作者警告消息。</li>
<li><code>SEND_ERROR</code>：打印带有前缀<code>-- Send Error:</code>的错误消息，并停止配置过程。</li>
<li><code>FATAL_ERROR</code>：打印带有前缀<code>-- FATAL_ERROR:</code>的严重错误消息，并停止配置过程。</li>
<li><code>DEPRECATION</code>：打印带有前缀<code>-- DEPRECATION:</code>的过时警告消息。</li>
</ul>
<p>以下是一些示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印普通消息</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;This is a message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印带有前缀的消息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;This is a status message&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;This is a warning message&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(AUTHOR_WARNING <span class="string">&quot;This is an author warning message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印错误消息并停止配置过程</span></span><br><span class="line"><span class="keyword">message</span>(SEND_ERROR <span class="string">&quot;This is an error message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印严重错误消息并停止配置过程</span></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;This is a fatal error message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印过时警告消息</span></span><br><span class="line"><span class="keyword">message</span>(DEPRECATION <span class="string">&quot;This is a deprecation warning message&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当运行CMake时，这些消息将显示在终端上，以便您查看配置过程中的相关信息、警告和错误。</p>
<p>请注意，<code>message</code>命令在CMake 3.10.2版本中的语法与较新版本（如CMake 3.21）中的语法略有不同。如果您的CMake版本是3.10.2，可以使用上述示例来打印消息。如果使用的是较新版本的CMake，请参考官方文档以获取更准确的语法信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Compiler/LLVM/2024-05-22-Clang-llvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Compiler/LLVM/2024-05-22-Clang-llvm/" class="post-title-link" itemprop="url">Clang-llvm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p><code>-fsyntax-only</code>  –  语义分析</p>
</li>
<li><p><code>-D&lt;macroname&gt;=&lt;value&gt;</code>  –  定义宏</p>
</li>
<li><p><code>-include &lt;filename&gt;</code>  </p>
</li>
<li><p><code>-I&lt;directory&gt;</code>  –  头文件路径</p>
</li>
<li><p><code>-ferror-limit=9999</code>  –  错误警告数量</p>
</li>
<li><p><code>clang++</code>  – C++编译器</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/CMake/cmake_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-cmake_3_02_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/CMake/cmake_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-cmake_3_02_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">cmake_3_02_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cmake 常用的技巧</li>
</ul>
<h2 id="CMake-引用第三方库的CMakelists"><a href="#CMake-引用第三方库的CMakelists" class="headerlink" title="CMake 引用第三方库的CMakelists"></a>CMake 引用第三方库的CMakelists</h2><p>在 CMake 中引用第三方库的 <code>CMakeLists.txt</code> 主要有以下几种方式：</p>
<h2 id="1-使用-find-package"><a href="#1-使用-find-package" class="headerlink" title="1. 使用 find_package"></a>1. <strong>使用 <code>find_package</code></strong></h2><p>适用于已安装在系统中的库（如 OpenCV、Boost）。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 OpenCV 库</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 OpenCV 库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含 OpenCV 头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-使用-add-subdirectory"><a href="#2-使用-add-subdirectory" class="headerlink" title="2. 使用 add_subdirectory"></a>2. <strong>使用 <code>add_subdirectory</code></strong></h2><p>适用于将源码包含在项目中的库。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第三方库的源码目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(third_party/MyLib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接第三方库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE MyLib)</span><br></pre></td></tr></table></figure>

<h2 id="3-使用-FetchContent"><a href="#3-使用-FetchContent" class="headerlink" title="3. 使用 FetchContent"></a>3. <strong>使用 <code>FetchContent</code></strong></h2><p>适用于自动下载并编译第三方库。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">    fmt</span><br><span class="line">    GIT_REPOSITORY https://github.com/fmtlib/fmt.git</span><br><span class="line">    GIT_TAG <span class="number">10.0</span>.<span class="number">0</span></span><br><span class="line">)</span><br><span class="line">FetchContent_MakeAvailable(fmt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE fmt)</span><br></pre></td></tr></table></figure>

<h2 id="4-使用-ExternalProject-Add"><a href="#4-使用-ExternalProject-Add" class="headerlink" title="4. 使用 ExternalProject_Add"></a>4. <strong>使用 <code>ExternalProject_Add</code></strong></h2><p>适用于构建时拉取和编译外部库，而不直接暴露给 CMake。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(ExternalProject)</span><br><span class="line">ExternalProject_Add(</span><br><span class="line">    MyExternalLib</span><br><span class="line">    GIT_REPOSITORY https://github.com/some/library.git</span><br><span class="line">    GIT_TAG master</span><br><span class="line">    CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/external</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定库的路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/external/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/external/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE MyExternalLib)</span><br></pre></td></tr></table></figure>

<h2 id="5-使用-pkg-config"><a href="#5-使用-pkg-config" class="headerlink" title="5. 使用 pkg-config"></a>5. <strong>使用 <code>pkg-config</code></strong></h2><p>适用于 Linux 上的系统库。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PkgConfig REQUIRED)</span><br><span class="line">pkg_check_modules(GLIB REQUIRED glib-<span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(MyExecutable PRIVATE <span class="variable">$&#123;GLIB_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE <span class="variable">$&#123;GLIB_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="选择合适的方法："><a href="#选择合适的方法：" class="headerlink" title="选择合适的方法："></a>选择合适的方法：</h3><ul>
<li><strong>已安装库</strong> → <code>find_package</code></li>
<li><strong>源码包含在项目中</strong> → <code>add_subdirectory</code></li>
<li><strong>在线拉取</strong> → <code>FetchContent</code> 或 <code>ExternalProject_Add</code></li>
<li><strong>Linux 系统库</strong> → <code>pkg-config</code></li>
</ul>
<p>你具体是想引用哪个库？</p>
<h2 id="vscode中cmake项目配置文件手动修改编译器路径"><a href="#vscode中cmake项目配置文件手动修改编译器路径" class="headerlink" title="vscode中cmake项目配置文件手动修改编译器路径"></a>vscode中cmake项目配置文件手动修改编译器路径</h2><p>在 VSCode 中，如果你想为 CMake 项目手动配置编译器路径，可以通过修改 <code>CMakeSettings.json</code> 或者 <code>.vscode/settings.json</code> 文件来实现。以下是配置步骤：</p>
<h3 id="1-使用-CMakeSettings-json"><a href="#1-使用-CMakeSettings-json" class="headerlink" title="1. 使用 CMakeSettings.json"></a>1. 使用 <code>CMakeSettings.json</code></h3><p>CMake 支持通过 <code>CMakeSettings.json</code> 来设置不同的构建配置，比如指定编译器路径。创建或修改项目根目录中的 <code>CMakeSettings.json</code> 文件，添加类似下面的配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x64-Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;generator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Ninja&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;configurationType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;buildRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;projectDir&#125;\\out\\build\\$&#123;name&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;installRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;projectDir&#125;\\out\\install\\$&#123;name&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cmakeCommandArgs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;buildCommandArgs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ctestCommandArgs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;variables&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CMAKE_C_COMPILER&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/Your/Compiler/gcc.exe&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CMAKE_CXX_COMPILER&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/Your/Compiler/g++.exe&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这会告诉 CMake 使用指定的编译器路径。</p>
<h3 id="2-使用-vscode-settings-json"><a href="#2-使用-vscode-settings-json" class="headerlink" title="2. 使用 .vscode/settings.json"></a>2. 使用 <code>.vscode/settings.json</code></h3><p>你也可以直接在 VSCode 的工作区配置中设置编译器路径，方法是修改 <code>.vscode/settings.json</code> 文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cmake.cmakePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/CMake/cmake.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cmake.generator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Ninja&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cmake.buildDirectory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cmake.environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;CC&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/Your/Compiler/gcc.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;CXX&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/Your/Compiler/g++.exe&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里 <code>cmake.environment</code> 变量用于指定 C 和 C++ 编译器路径。</p>
<h3 id="3-通过-CMakeLists-txt-文件"><a href="#3-通过-CMakeLists-txt-文件" class="headerlink" title="3. 通过 CMakeLists.txt 文件"></a>3. 通过 <code>CMakeLists.txt</code> 文件</h3><p>你也可以在 <code>CMakeLists.txt</code> 中直接添加设置编译器的指令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">&quot;C:/Path/To/Your/Compiler/gcc.exe&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;C:/Path/To/Your/Compiler/g++.exe&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-使用-cmake-kits-json"><a href="#4-使用-cmake-kits-json" class="headerlink" title="4. 使用 cmake-kits.json"></a>4. 使用 <code>cmake-kits.json</code></h3><p>VSCode 的 CMake Tools 扩展提供了一种通过 <code>cmake-kits.json</code> 来管理编译器的方式。你可以在 <code>.vscode/cmake-kits.json</code> 中定义编译器路径：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GCC&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;compilers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;C&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/Your/Compiler/gcc.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;CXX&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/Your/Compiler/g++.exe&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>然后在 VSCode 的 CMake Tools 扩展中选择这个编译器套件。</p>
<h3 id="5-选择编译器"><a href="#5-选择编译器" class="headerlink" title="5. 选择编译器"></a>5. 选择编译器</h3><p>如果你已经配置了多个编译器，可以通过命令面板（<code>Ctrl+Shift+P</code>）打开 <code>CMake: Select a Kit</code>，然后从列表中选择你配置的编译器。</p>
<p>这几种方式都可以帮助你手动指定 CMake 项目的编译器路径。</p>
<h2 id="cmake-静态链接库顺序问题"><a href="#cmake-静态链接库顺序问题" class="headerlink" title="cmake 静态链接库顺序问题"></a>cmake 静态链接库顺序问题</h2><ul>
<li><p>默认情况下要求被依赖的库放在依赖它的库后面，当一个程序或共享库依赖的静态库较多时，可能会陷入解决链接问题的坑中。如果对静态库不熟悉，需要结构nm等工具来解决顺序问题。</p>
</li>
<li><p>如果去掉顺序的烦恼和痛苦，可以采用如下方法</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    x</span><br><span class="line">    -Wl,--start-group</span><br><span class="line">    libX1.a</span><br><span class="line">    libX3.a</span><br><span class="line">    libX2.a</span><br><span class="line">    -Wl,--end-group</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="cmake-设置编译线程数量"><a href="#cmake-设置编译线程数量" class="headerlink" title="cmake 设置编译线程数量"></a>cmake 设置编译线程数量</h2><p>在使用 CMake 构建项目时，你可以通过设置编译器选项来指定编译时使用的线程数量。具体步骤如下：</p>
<ol>
<li><p><strong>使用 <code>cmake</code> 命令配置项目：</strong><br>例如，你可以在项目根目录中运行以下命令来生成构建文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>cmake --build</code> 命令进行构建并指定线程数量：</strong><br>使用 <code>--parallel</code> 选项可以指定编译时使用的线程数量。例如，如果你想使用 8 个线程来进行编译，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build build --parallel 8</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样，CMake 会根据你指定的线程数量来并行执行构建任务，从而加快编译速度。</p>
<p>完整的流程示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build</span><br><span class="line">cmake --build build --parallel 8</span><br></pre></td></tr></table></figure>

<p>此外，你还可以直接在 <code>make</code> 或 <code>ninja</code> 命令中指定线程数量（假设你使用的是这些生成器）：</p>
<ul>
<li>对于 <code>make</code> 生成器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure></li>
<li>对于 <code>ninja</code> 生成器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -j8</span><br></pre></td></tr></table></figure></li>
</ul>
<p>CMake 会根据你的项目配置选择合适的生成器并使用相应的构建工具。</p>
<h2 id="CMakeLists-txt-编译性能参数配置"><a href="#CMakeLists-txt-编译性能参数配置" class="headerlink" title="CMakeLists.txt 编译性能参数配置"></a>CMakeLists.txt 编译性能参数配置</h2><p>在 <code>CMakeLists.txt</code> 中配置编译性能参数，可以通过一些特定的编译选项和设置来优化编译时间和资源使用。以下是一些常见的方法和配置选项，可以用来提升编译性能：</p>
<h3 id="1-使用-CMAKE-BUILD-TYPE"><a href="#1-使用-CMAKE-BUILD-TYPE" class="headerlink" title="1. 使用 CMAKE_BUILD_TYPE"></a>1. 使用 <code>CMAKE_BUILD_TYPE</code></h3><p>通过设置 <code>CMAKE_BUILD_TYPE</code> 可以启用特定的编译器优化选项。例如，在开发过程中可以设置为 <code>Debug</code>，在发布时设置为 <code>Release</code>。使用 <code>Release</code> 模式可以启用优化选项，从而减少生成的代码大小和提升执行性能。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br></pre></td></tr></table></figure>

<h3 id="2-使用-CMAKE-CXX-FLAGS-和-CMAKE-C-FLAGS"><a href="#2-使用-CMAKE-CXX-FLAGS-和-CMAKE-C-FLAGS" class="headerlink" title="2. 使用 CMAKE_CXX_FLAGS 和 CMAKE_C_FLAGS"></a>2. 使用 <code>CMAKE_CXX_FLAGS</code> 和 <code>CMAKE_C_FLAGS</code></h3><p>可以为编译器指定一些优化选项，比如 <code>-O2</code> 或者 <code>-O3</code>，这些选项可以启用更多的编译器优化，从而提升生成代码的性能。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -O2&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -O2&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-使用-CMAKE-LINKER-FLAGS"><a href="#3-使用-CMAKE-LINKER-FLAGS" class="headerlink" title="3. 使用 CMAKE_LINKER_FLAGS"></a>3. 使用 <code>CMAKE_LINKER_FLAGS</code></h3><p>对于链接阶段，可以设置 <code>CMAKE_EXE_LINKER_FLAGS</code> 和 <code>CMAKE_SHARED_LINKER_FLAGS</code> 来优化链接器的行为。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -Wl,--as-needed&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125; -Wl,--as-needed&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-启用并行链接"><a href="#4-启用并行链接" class="headerlink" title="4. 启用并行链接"></a>4. 启用并行链接</h3><p>某些编译器和链接器支持并行链接，可以显著减少链接时间。对于 GNU 链接器，可以使用 <code>-Wl,--parallel</code>。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -Wl,--parallel&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125; -Wl,--parallel&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-使用-ccache"><a href="#5-使用-ccache" class="headerlink" title="5. 使用 ccache"></a>5. 使用 <code>ccache</code></h3><p><code>ccache</code> 是一个编译缓存工具，可以显著减少重复编译的时间。要在 CMake 中启用 <code>ccache</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_program</span>(CCACHE_PROGRAM ccache)</span><br><span class="line"><span class="keyword">if</span>(CCACHE_PROGRAM)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_C_COMPILER_LAUNCHER <span class="variable">$&#123;CCACHE_PROGRAM&#125;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_COMPILER_LAUNCHER <span class="variable">$&#123;CCACHE_PROGRAM&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h3 id="6-使用-Ninja-生成器"><a href="#6-使用-Ninja-生成器" class="headerlink" title="6. 使用 Ninja 生成器"></a>6. 使用 <code>Ninja</code> 生成器</h3><p><code>Ninja</code> 是一个快速的构建系统，通常比默认的 <code>Make</code> 更快。要使用 <code>Ninja</code>，可以在 CMake 配置阶段指定生成器：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G Ninja ..</span><br></pre></td></tr></table></figure>

<p>在 <code>CMakeLists.txt</code> 中没有直接指定 <code>Ninja</code> 的方法，但可以通过命令行来指定。</p>
<h3 id="7-预编译头文件"><a href="#7-预编译头文件" class="headerlink" title="7. 预编译头文件"></a>7. 预编译头文件</h3><p>预编译头文件可以显著减少编译时间，特别是当项目包含大量头文件时。可以通过 <code>target_precompile_headers</code> 指令来设置预编译头文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_precompile_headers(my_target PRIVATE precompiled.h)</span><br></pre></td></tr></table></figure>

<h3 id="8-使用编译选项优化"><a href="#8-使用编译选项优化" class="headerlink" title="8. 使用编译选项优化"></a>8. 使用编译选项优化</h3><p>根据不同的编译器，可以启用一些特定的优化选项。例如，针对 GCC，可以启用以下选项：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">STREQUAL</span> <span class="string">&quot;GNU&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -march=native -flto&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -march=native -flto&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><p>以下是一个包含上述多个优化配置的 <code>CMakeLists.txt</code> 示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译类型</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译器优化选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -O2 -march=native -flto&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -O2 -march=native -flto&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接器优化选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -Wl,--as-needed -Wl,--parallel&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125; -Wl,--as-needed -Wl,--parallel&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 ccache</span></span><br><span class="line"><span class="keyword">find_program</span>(CCACHE_PROGRAM ccache)</span><br><span class="line"><span class="keyword">if</span>(CCACHE_PROGRAM)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_C_COMPILER_LAUNCHER <span class="variable">$&#123;CCACHE_PROGRAM&#125;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_COMPILER_LAUNCHER <span class="variable">$&#123;CCACHE_PROGRAM&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预编译头文件</span></span><br><span class="line">target_precompile_headers(MyTarget PRIVATE precompiled.h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyTarget main.cpp)</span><br></pre></td></tr></table></figure>

<p>通过在 <code>CMakeLists.txt</code> 中添加这些配置，可以显著提升编译性能并减少系统资源的使用。</p>
<h2 id="cmake-子项目设置二进制文件保存路径"><a href="#cmake-子项目设置二进制文件保存路径" class="headerlink" title="cmake 子项目设置二进制文件保存路径"></a>cmake 子项目设置二进制文件保存路径</h2><p>要设置子项目的二进制文件保存路径，你可以在使用 <code>add_subdirectory()</code> 函数添加子项目时，通过第二个参数 <code>binary_dir</code> 来指定。</p>
<p>假设你有如下的项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">project_root/</span><br><span class="line">    CMakeLists.txt</span><br><span class="line">    src/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        file1.cpp</span><br><span class="line">        file2.cpp</span><br><span class="line">    test/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        test1.cpp</span><br><span class="line">        test2.cpp</span><br></pre></td></tr></table></figure>

<p>如果你希望将子项目的二进制文件保存在不同的目录中，可以像这样在父项目的 <code>CMakeLists.txt</code> 中设置：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src bin/src)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">test</span> bin/<span class="keyword">test</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>src</code> 子项目的二进制文件将保存在 <code>project_root/bin/src</code> 目录中，而 <code>test</code> 子项目的二进制文件将保存在 <code>project_root/bin/test</code> 目录中。</p>
<p>如果不指定 <code>binary_dir</code> 参数，子项目的二进制文件将默认保存在子项目目录下的 <code>bin</code> 目录中。</p>
<h2 id="cmake-在子项目中设置头文件包含目录"><a href="#cmake-在子项目中设置头文件包含目录" class="headerlink" title="cmake 在子项目中设置头文件包含目录"></a>cmake 在子项目中设置头文件包含目录</h2><p>在 CMake 中，你可以在子项目中使用 <code>target_include_directories()</code> 函数来设置头文件包含目录。这个函数用于为指定的目标（例如库或可执行文件）设置头文件搜索路径。假设你有如下的项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">project_root/</span><br><span class="line">    CMakeLists.txt</span><br><span class="line">    src/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        file1.cpp</span><br><span class="line">        file2.cpp</span><br><span class="line">        include/</span><br><span class="line">            header1.h</span><br><span class="line">            header2.h</span><br><span class="line">    test/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        test1.cpp</span><br><span class="line">        test2.cpp</span><br></pre></td></tr></table></figure>

<p>在 <code>src/CMakeLists.txt</code> 中，你可以这样设置头文件包含目录：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(my_target_name PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>my_target_name</code> 是你在 <code>src/CMakeLists.txt</code> 中定义的目标名称，<code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</code> 表示当前源码目录的路径，<code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include</code> 就是 <code>include</code> 目录的路径。使用 <code>PUBLIC</code> 关键字可以将这个头文件包含目录设置为公开的，这意味着这个目录将会被导出到依赖这个目标的其他目标中。</p>
<p>在 <code>test/CMakeLists.txt</code> 中，你也可以类似地设置头文件包含目录：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(test_target_name PRIVATE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/../src/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>test_target_name</code> 是你在 <code>test/CMakeLists.txt</code> 中定义的目标名称，<code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../src/include</code> 是相对于 <code>test</code> 目录的父目录 <code>src/include</code> 的路径。使用 <code>PRIVATE</code> 关键字可以将这个头文件包含目录设置为私有的，这意味着这个目录只对当前目标有效，不会被导出到依赖当前目标的其他目标中。</p>
<h2 id="cmake-打印目标的头文件路径和编译选项"><a href="#cmake-打印目标的头文件路径和编译选项" class="headerlink" title="cmake 打印目标的头文件路径和编译选项"></a>cmake 打印目标的头文件路径和编译选项</h2><p>要打印目标的头文件路径和编译选项，您可以使用 <code>get_target_property</code> 命令来获取目标的属性。以下是一个示例代码，假设您的目标名为 <code>my_target</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取目标的头文件路径</span></span><br><span class="line"><span class="keyword">get_target_property</span>(<span class="keyword">TARGET_INCLUDE_DIRECTORIES</span> my_target <span class="keyword">INCLUDE_DIRECTORIES</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;My target include directories: $&#123;TARGET_INCLUDE_DIRECTORIES&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目标的编译选项</span></span><br><span class="line"><span class="keyword">get_target_property</span>(<span class="keyword">TARGET_COMPILE_OPTIONS</span> my_target COMPILE_OPTIONS)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;My target compile options: $&#123;TARGET_COMPILE_OPTIONS&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码将打印出目标 <code>my_target</code> 的头文件路径和编译选项。您可以根据需要获取和打印其他属性。</p>
<h2 id="cmake-find-package-配置opencv库"><a href="#cmake-find-package-配置opencv库" class="headerlink" title="cmake find_package 配置opencv库"></a>cmake find_package 配置opencv库</h2><p>配置 OpenCV 库时，通常会使用 CMake 的 <code>find_package</code> 命令。以下是一个简单的示例，展示如何在 CMake 中配置和链接 OpenCV 库：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 find_package 查找并配置 OpenCV 库</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出找到的 OpenCV 库信息</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;OpenCV_INCLUDE_DIRS: $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;OpenCV_LIBRARIES: $&#123;OpenCV_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件，并链接 OpenCV 库</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(MyExecutable PRIVATE <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE <span class="variable">$&#123;OpenCV_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>在上述代码中：</p>
<ul>
<li><code>find_package(OpenCV REQUIRED)</code> 用于查找并配置 OpenCV 库。<code>REQUIRED</code> 表示如果找不到 OpenCV 库，将产生一个错误。</li>
<li><code>OpenCV_INCLUDE_DIRS</code> 包含了 OpenCV 库的头文件目录。</li>
<li><code>OpenCV_LIBRARIES</code> 包含了 OpenCV 库的链接库的名称。</li>
<li><code>add_executable</code> 添加了一个可执行文件，并使用 <code>target_include_directories</code> 将 OpenCV 库的头文件目录包含进来，使用 <code>target_link_libraries</code> 将 OpenCV 库链接到可执行文件中。</li>
</ul>
<p>确保 OpenCV 已经安装在你的系统中，或者你可以使用 CMake 的 <code>ExternalProject</code> 或其他方法在 CMake 中构建 OpenCV。</p>
<p>此外，<code>find_package</code> 还可以通过指定版本号和特定组件来细化查找过程。例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV <span class="number">4.5</span>.<span class="number">1</span> REQUIRED COMPONENTS core imgproc highgui)</span><br></pre></td></tr></table></figure>

<p>这将查找并配置 OpenCV 版本为 4.5.1，并确保包含了 core、imgproc 和 highgui 组件。</p>
<h2 id="cmake-find-package-配置gflags库"><a href="#cmake-find-package-配置gflags库" class="headerlink" title="cmake find_package 配置gflags库"></a>cmake find_package 配置gflags库</h2><p>当使用 CMake 的 <code>find_package</code> 配置 <code>gflags</code> 库时，你需要确保 <code>gflags</code> 库的 CMake 模块文件 <code>Findgflags.cmake</code> 被正确找到并使用。以下是一个简单的例子，演示如何在 CMake 中使用 <code>find_package</code> 配置 <code>gflags</code> 库：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 find_package 查找 gflags 库</span></span><br><span class="line"><span class="keyword">find_package</span>(gflags REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出找到的 gflags 库信息</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;gflags_INCLUDE_DIRS: $&#123;gflags_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;gflags_LIBRARIES: $&#123;gflags_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件，并链接 gflags 库</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE gflags)</span><br></pre></td></tr></table></figure>

<p>在上述代码中：</p>
<ul>
<li><code>find_package(gflags REQUIRED)</code> 用于查找并配置 <code>gflags</code> 库。<code>REQUIRED</code> 表示如果找不到 gflags 库，将产生一个错误。</li>
<li><code>gflags_INCLUDE_DIRS</code> 包含了 <code>gflags</code> 库的头文件目录。</li>
<li><code>gflags_LIBRARIES</code> 包含了 <code>gflags</code> 库的链接库的名称。</li>
<li><code>add_executable</code> 添加了一个可执行文件，并使用 <code>target_link_libraries</code> 将 <code>gflags</code> 库链接到可执行文件中。</li>
</ul>
<p>确保 <code>gflags</code> 库已经安装在系统中，或者你可以使用 <code>ExternalProject</code> 或其他方法在 CMake 中构建 <code>gflags</code>。</p>
<p>此外，如果你的项目中还用到其他外部库，可能需要在 <code>find_package</code> 后面添加其他库的查找，以确保这些库的依赖关系也得到正确配置。</p>
<p>最后，记得在 <code>CMakeLists.txt</code> 中引入 <code>main.cpp</code> 或其他源代码文件，以确保它们被编译到可执行文件中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/Trash/2024-05-22-C++_%E6%A0%87%E5%87%86%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/Trash/2024-05-22-C++_%E6%A0%87%E5%87%86%E5%BA%93/" class="post-title-link" itemprop="url">C++_标准库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>所有标准库类和函数都在std名称空间或其子名称空间中声明</li>
<li>C++标准库的核心是泛型容器和泛型算法。该库中的这个子集通常程序标准模板库(Standard Template Library, STL)，因为它最初基于第三方库“标准模板库”，该库大量使用了模板。</li>
</ul>
<h2 id="–-字符串-ok"><a href="#–-字符串-ok" class="headerlink" title="&lt;string&gt; – 字符串 [ok]"></a><code>&lt;string&gt;</code> – 字符串 [ok]</h2><ul>
<li>C++20包括了一个强大的类型安全的字符串格式化库，可以通过定义在<code>&lt;format&gt;</code>头文件中的<code>std::format()</code>进行访问</li>
</ul>
<h2 id="–-正则表达式-ok"><a href="#–-正则表达式-ok" class="headerlink" title="&lt;regex&gt; – 正则表达式[ok]"></a><code>&lt;regex&gt;</code> – 正则表达式[ok]</h2><h2 id="–-I-O流-ok"><a href="#–-I-O流-ok" class="headerlink" title="&lt;fstream&gt; – I&#x2F;O流[ok]"></a><code>&lt;fstream&gt;</code> – I&#x2F;O流[ok]</h2><ul>
<li>大多数的I&#x2F;O功能在如下几个头文件中定义：<ul>
<li><code>&lt;fstream&gt;</code></li>
<li><code>&lt;iomanip&gt;</code></li>
<li><code>&lt;ios&gt;</code></li>
<li><code>&lt;iosfwd&gt;</code></li>
<li><code>&lt;iostream&gt;</code></li>
<li><code>&lt;istream&gt;</code></li>
<li><code>&lt;ostream&gt;</code></li>
<li><code>&lt;sstream&gt;</code></li>
<li><code>&lt;streambuf&gt;</code></li>
<li><code>&lt;strstream&gt;</code></li>
</ul>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title="&lt;iomanip&gt;"></a><code>&lt;iomanip&gt;</code></h3><h4 id="resetiosflags"><a href="#resetiosflags" class="headerlink" title="resetiosflags()"></a><code>resetiosflags()</code></h4><ul>
<li>简述：清除指定的 ios_base 标志</li>
</ul>
<h4 id="setiosflags"><a href="#setiosflags" class="headerlink" title="setiosflags()"></a><code>setiosflags()</code></h4><ul>
<li>简述：设置指定的 ios_base 标志</li>
</ul>
<h4 id="setbase"><a href="#setbase" class="headerlink" title="setbase()"></a><code>setbase()</code></h4><ul>
<li>简述：更改用于整数 I&#x2F;O 的基数</li>
</ul>
<h4 id="setfill"><a href="#setfill" class="headerlink" title="setfill()"></a><code>setfill()</code></h4><ul>
<li>简述：更改填充字符</li>
</ul>
<h4 id="setprecision"><a href="#setprecision" class="headerlink" title="setprecision()"></a><code>setprecision()</code></h4><ul>
<li>简述：更改浮点精度</li>
</ul>
<h4 id="setw"><a href="#setw" class="headerlink" title="setw()"></a><code>setw()</code></h4><ul>
<li>简述：更改下个输入&#x2F;输出域的宽度</li>
</ul>
<h4 id="get-money"><a href="#get-money" class="headerlink" title="get_money()"></a><code>get_money()</code></h4><ul>
<li>简述：剖析货币值</li>
</ul>
<h4 id="put-money"><a href="#put-money" class="headerlink" title="put_money()"></a><code>put_money()</code></h4><ul>
<li>简述：格式化并输出货币值</li>
</ul>
<h4 id="get-time"><a href="#get-time" class="headerlink" title="get_time()"></a><code>get_time()</code></h4><ul>
<li>简述：剖析指定格式的日期&#x2F;时间值</li>
</ul>
<h4 id="put-time"><a href="#put-time" class="headerlink" title="put_time()"></a><code>put_time()</code></h4><ul>
<li>简述：按照指定格式格式化并输出日期&#x2F;时间值</li>
<li>声明：<code>template&lt;class CharT&gt; put_time(const std::tm* tmb, const CharT* fmt);</code></li>
<li>参数：<ul>
<li><code>tmb</code> – 指向从 std::localtime 或 std::gmtime 获得的日历时间结构体的指针</li>
<li><code>fmt</code> – 指向指定转换格式的空终止 CharT 串的指针，具体参考：<code>https://zh.cppreference.com/w/cpp/io/manip/put_time</code>（默认使用<code>%c %Z</code>）</li>
</ul>
</li>
</ul>
<h4 id="quoted"><a href="#quoted" class="headerlink" title="quoted()"></a><code>quoted()</code></h4><ul>
<li>简述：插入和读取带有内嵌空格的被引号括起来的字符串</li>
</ul>
<h2 id="–-智能指针-ok"><a href="#–-智能指针-ok" class="headerlink" title="&lt;memory&gt; – 智能指针[ok]"></a><code>&lt;memory&gt;</code> – 智能指针[ok]</h2><ul>
<li>编写健壮程序时，需要面对的一个问题就是要知道何时删除对象。</li>
<li>有几种可能发生的故障：<ul>
<li>根本没有删除对象（没有释放内存），这称为内存泄漏(memory leaks)。</li>
<li>一段代码删除了内存，而另一段代码仍然引用了这个内存，导致直线那个内存的指针不再可用或已重新分配作他用，这称为悬空指针(dangling pointer)</li>
<li>一段代码释放了内存，而另一端代码试图释放同一块内存，这称为双重释放(double deletion)</li>
</ul>
</li>
</ul>
<h2 id="–-异常-ok"><a href="#–-异常-ok" class="headerlink" title="&lt;exception&gt; – 异常[ok]"></a><code>&lt;exception&gt;</code> – 异常[ok]</h2><ul>
<li>大多数异常支持在下面几个头文件中定义：<ul>
<li><code>&lt;exception&gt;</code></li>
<li><code>&lt;stdexcept&gt;</code></li>
<li><code>&lt;system_error&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="–-数学工具"><a href="#–-数学工具" class="headerlink" title="&lt;cmath&gt; – 数学工具"></a><code>&lt;cmath&gt;</code> – 数学工具</h2><ul>
<li>数学工具类和函数</li>
</ul>
<h2 id="–-时间和日期工具-ok"><a href="#–-时间和日期工具-ok" class="headerlink" title="&lt;chrono&gt; – 时间和日期工具[ok]"></a><code>&lt;chrono&gt;</code> – 时间和日期工具[ok]</h2><ul>
<li>简述：在C++11的日期时间库中，共有3个概念，分别是持续时间（Duration）、时间点（timepoint）、时钟（clock）。</li>
</ul>
<h3 id="Clocks"><a href="#Clocks" class="headerlink" title="Clocks"></a>Clocks</h3><ul>
<li><p>定义中的时钟主要有3个，分别是:</p>
<ul>
<li>system_clock，顾名思义，就是系统时钟，他一般是unix时间，即从1970年1月1日到现在的间隔。如果系统时间发生调整，那么调用该方法获取的时间值也会跟着变化。</li>
<li>steady_clock，是单调时间，即每后一次调用都一定会比前一次调用的时间要晚，它并不反映真实的世界时间。在内部的实现中，有可能是系统开启以来的时间。通过该时钟很适合用来获取一段时间内的间隔，它不随系统时间改变而改变</li>
<li>high_resolution_clock，高精度时间，用来测量细微间隔的一段时间，它的内部实现中可能是system_clock或是steady_clock，也可能是其他独立的时间。</li>
</ul>
</li>
<li><p>一般来说，我们使用的都是system_clock</p>
</li>
<li><p>system_clock的主要方法有3个，分别是</p>
<ul>
<li>now，用来获取当前时间。</li>
<li>to_time_t，用来将系统时间转变为std::time_t类型。</li>
<li>from_time_t，用来将std::time_t类型转换为系统时间点</li>
</ul>
</li>
<li><p>使用system_clock获取当前系统时间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">auto</span> time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> tt = std::chrono::system_clock::<span class="built_in">to_time_t</span>(time);</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;tt), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计函数的执行耗时，这种情况更适合使用steady_clock。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">fibonacci</span><span class="params">(<span class="type">unsigned</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;f(42) = &quot;</span> &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">42</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">auto</span> end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        std::chrono::duration&lt;<span class="type">double</span>&gt; elapsed_seconds = end-start;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;elapsed time: &quot;</span> &lt;&lt; elapsed_seconds.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ```  </span><br><span class="line"></span><br><span class="line">### Duration</span><br><span class="line"></span><br><span class="line">+ 持续时间表示一个时间段，比如<span class="number">1</span>s、<span class="number">1</span>min、<span class="number">1</span>day等等，这些时间段是有单位的，因此持续时间也是一个模板变量，用来指定不同的单位</span><br><span class="line">+ 它的定义如下：</span><br><span class="line">  ```cpp</span><br><span class="line">    <span class="comment">// Rep表示单位的数量单位</span></span><br><span class="line">    <span class="comment">// Period表示单位</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Rep</span>,  <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;&gt; <span class="keyword">class</span> duration;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Period用来表示时间的单位，比如秒、天、小时等等，而Rep则表示容纳某个数量时间的单位。比较绕口，举个例子，比如说10天，那么Period是单位day，那么其数量是10，而10的类型可以是int型，也可以short型，Rep就用来表示这到底是什么类型存储这个量，如果类型过小，如果时间太长的话将会导致溢出。</p>
</li>
<li><p>再来看下Period的定义，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Num，表示分子</span></span><br><span class="line"><span class="comment">// Denom，表示分母</span></span><br><span class="line"><span class="keyword">template</span>&lt;std::<span class="type">intmax_t</span> Num, std::<span class="type">intmax_t</span> Denom = <span class="number">1</span>&gt; <span class="keyword">class</span> ratio;</span><br></pre></td></tr></table></figure></li>
<li><p>举个简单点的例子，Num为1，Denom也为1时，表示是1s，如果Num为1，Denom为1000，那么相当于是1&#x2F;1000s，也即毫秒。如果Num为60，Denom为1，那么表示 60 &#x2F; 1s，也即相当于1min。</p>
</li>
<li><p>下面是chrono头文件中的一些常见持续时间定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Type	Definition</span><br><span class="line">std::chrono::nanoseconds	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">64</span> bits*/, std::nano&gt;</span><br><span class="line">std::chrono::microseconds	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">55</span> bits*/, std::micro&gt;</span><br><span class="line">std::chrono::milliseconds	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">45</span> bits*/, std::milli&gt;</span><br><span class="line">std::chrono::seconds	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">35</span> bits*/&gt;</span><br><span class="line">std::chrono::minutes	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">29</span> bits*/, std::ratio&lt;<span class="number">60</span>&gt;&gt;</span><br><span class="line">std::chrono::hours	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">23</span> bits*/, std::ratio&lt;<span class="number">3600</span>&gt;&gt;</span><br><span class="line">std::chrono::<span class="built_in">days</span> (since C+<span class="number">+20</span>)	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">25</span> bits*/, std::ratio&lt;<span class="number">86400</span>&gt;&gt;</span><br><span class="line">std::chrono::<span class="built_in">weeks</span> (since C+<span class="number">+20</span>)	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">22</span> bits*/, std::ratio&lt;<span class="number">604800</span>&gt;&gt;</span><br><span class="line">std::chrono::<span class="built_in">months</span> (since C+<span class="number">+20</span>)	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">20</span> bits*/, std::ratio&lt;<span class="number">2629746</span>&gt;&gt;</span><br><span class="line">std::chrono::<span class="built_in">years</span> (since C+<span class="number">+20</span>)	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">17</span> bits*/, std::ratio&lt;<span class="number">31556952</span>&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>针对Duraion来说，一般有两种操作，</p>
<ul>
<li>时间的增减。</li>
<li>不同持续时间单位之间的转换。</li>
</ul>
</li>
<li><p>Duration重载了+&#x2F;-运算符，可以直接进行+&#x2F;-操作，类型之间的转换可以使用duration_cast方法。</p>
</li>
<li><p>下面是一些使用实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ms.<span class="built_in">count</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> second = std::chrono::duration&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    <span class="keyword">auto</span> s = std::chrono::<span class="built_in">duration_cast</span>&lt;second&gt;(ms);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%llf\n&quot;</span>, s.<span class="built_in">count</span>());</span><br><span class="line"></span><br><span class="line">    std::<span class="function">chrono::seconds <span class="title">sec</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> du = sec + ms;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, du.<span class="built_in">count</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="TimePoint"><a href="#TimePoint" class="headerlink" title="TimePoint"></a>TimePoint</h3><ul>
<li><p>从时钟拿到的时间是时间点，它代表了时间段上的一个点，比如2019年10月21日10:20:10。</p>
</li>
<li><p>时间点的定义如下。</p>
<ul>
<li><code>template&lt;class Clock, class Duration = typename Clock::duration&gt; class time_point;</code></li>
</ul>
</li>
<li><p>通过time_point的模板参数，我们可以看到，一个是时钟，另外一个是持续时间，实际上timepoint就是一个时钟的基准时间加上一个时间段</p>
</li>
<li><p>对于时间点来说，下面这几个方法比较重要。</p>
<ul>
<li>time_since_epoch，获取以模板时钟的起始时间到现在的这个持续时间</li>
<li>time_point_cast，用来将时间点转换为基于同一个时钟，但不同类型持续时间的时间点。</li>
<li>时间点也重载了+&#x2F;-运算符，用来进行两个时间点之间的相加减</li>
</ul>
</li>
<li><p>下面是一些使用示例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::<span class="function">chrono::minutes <span class="title">m</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; then = now + m;</span><br><span class="line">    std::<span class="type">time_t</span> tt = std::chrono::system_clock::<span class="built_in">to_time_t</span>(then);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;timestamp is : &quot;</span> &lt;&lt; now.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;tt), <span class="string">&quot;%F %T&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降低时间精度，默认system_clock的duration精度是 1/10 micro sec</span></span><br><span class="line">    <span class="keyword">auto</span> then_min = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::minutes&gt;(then);</span><br><span class="line">    tt = std::chrono::system_clock::<span class="built_in">to_time_t</span>(then_min);</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;tt), <span class="string">&quot;%F %T&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="一些应用"><a href="#一些应用" class="headerlink" title="一些应用"></a>一些应用</h3><ul>
<li><p>获取时间戳。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::<span class="type">time_t</span> <span class="title">getTimeStamp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock,std::chrono::milliseconds&gt; tp = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::milliseconds&gt;(std::chrono::system_clock::<span class="built_in">now</span>());</span><br><span class="line">    <span class="keyword">auto</span> tmp=std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(tp.<span class="built_in">time_since_epoch</span>());</span><br><span class="line">    std::<span class="type">time_t</span> timestamp = tmp.<span class="built_in">count</span>();</span><br><span class="line">    <span class="comment">//std::time_t timestamp = std::chrono::system_clock::to_time_t(tp);</span></span><br><span class="line">    <span class="keyword">return</span> timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将时间戳转为日期。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tm* <span class="title">gettm</span><span class="params">(int64 timestamp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 milli = timestamp+ (int64)<span class="number">8</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>;<span class="comment">//此处转化为东八区北京时间，如果是其它时区需要按需求修改</span></span><br><span class="line">    <span class="keyword">auto</span> mTime = std::chrono::<span class="built_in">milliseconds</span>(milli);</span><br><span class="line">    <span class="keyword">auto</span> tp=std::chrono::<span class="built_in">time_point</span>&lt;std::chrono::system_clock,std::chrono::milliseconds&gt;(mTime);</span><br><span class="line">    <span class="keyword">auto</span> tt = std::chrono::system_clock::<span class="built_in">to_time_t</span>(tp);</span><br><span class="line">    std::tm* now = std::<span class="built_in">gmtime</span>(&amp;tt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%4d年%02d月%02d日 %02d:%02d:%02d\n&quot;</span>,now-&gt;tm_year<span class="number">+1900</span>,now-&gt;tm_mon<span class="number">+1</span>,now-&gt;tm_mday,now-&gt;tm_hour,now-&gt;tm_min,now-&gt;tm_sec);</span><br><span class="line">   <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在上面的程序中，时间精度只到秒，这是time_t结构的限制，如果希望获取到ms精度，那么直接使用timestamp % 1000的方式就行。</p>
</li>
</ul>
<h2 id="–-随机数-ok"><a href="#–-随机数-ok" class="headerlink" title="&lt;random&gt; – 随机数[ok]"></a><code>&lt;random&gt;</code> – 随机数[ok]</h2><ul>
<li>随机数库，带有随机数引擎，随机数引擎适配器以及随机数分布。</li>
<li>通过这些组件可以生成更适合特定问题的随机数，例如正态分布，负指数分布等</li>
</ul>
<h2 id="–-初始化列表"><a href="#–-初始化列表" class="headerlink" title="&lt;initializer_list&gt; – 初始化列表"></a><code>&lt;initializer_list&gt;</code> – 初始化列表</h2><ul>
<li>它们便于编写参数数目可变的函数</li>
</ul>
<h2 id="–-pair"><a href="#–-pair" class="headerlink" title="&lt;utility&gt; – pair"></a><code>&lt;utility&gt;</code> – pair</h2><ul>
<li>它定义了pair类模板，用于存储两种不同类型的元素。这称为存储异构元素</li>
<li>pair允许在一个对象中保存类型毫不相关的元素</li>
</ul>
<h2 id="–-tuple"><a href="#–-tuple" class="headerlink" title="&lt;tuple&gt; – tuple"></a><code>&lt;tuple&gt;</code> – tuple</h2><ul>
<li>它定义的tuple是pair的一种泛化，它是固定大小的序列，元组的元素可以是异构的，tuple实例化的元素数目和类型在编译器是固定不变的。</li>
</ul>
<h2 id="词汇类型-vocabulary-type"><a href="#词汇类型-vocabulary-type" class="headerlink" title="词汇类型(vocabulary type)"></a>词汇类型(vocabulary type)</h2><ul>
<li><p><code>&lt;optional&gt;</code></p>
<ul>
<li>要么存储指定类型的值，要么什么都不存储</li>
</ul>
</li>
<li><p><code>&lt;variant&gt;</code></p>
<ul>
<li>可存储单个值（属于一组给定类型中的一种类型）</li>
</ul>
</li>
<li><p><code>&lt;any&gt;</code></p>
<ul>
<li>可包含单个值，值可以是任何类型</li>
</ul>
</li>
</ul>
<h2 id="–-函数对象"><a href="#–-函数对象" class="headerlink" title="&lt;functional&gt; – 函数对象"></a><code>&lt;functional&gt;</code> – 函数对象</h2><ul>
<li><p>在<code>&lt;functional&gt;</code>中定义的<code>std::function</code>函数模板是一个多态函数包装器，可以用来创建指向任何可调用对象的类型，例如函数，函数对象或者lambda表达式</p>
</li>
<li><p><code>std::function</code>的示例可以用作函数指针，也可以用作函数实现回调的参数，可以存储，赋值，移动，也可以执行</p>
</li>
<li><p>函数模板的模板参数看起来和大多数模板参数有些不同，语法如下：</p>
<ul>
<li><code>std::function&lt;R(ArgTypes...)&gt;</code></li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li><code>R</code> : 是函数的返回类型</li>
<li><code>ArgTypes</code> : 是函数参数类型的逗号分隔列表</li>
</ul>
</li>
<li><p>实现函数调用运算符的类称为函数对象(function object)</p>
</li>
<li><p>函数对象可用作某些标准库算法的谓词</p>
</li>
</ul>
<h2 id="–-文件系统"><a href="#–-文件系统" class="headerlink" title="&lt;filesystem&gt; – 文件系统"></a><code>&lt;filesystem&gt;</code> – 文件系统</h2><h2 id="–-多线程-ok"><a href="#–-多线程-ok" class="headerlink" title="&lt;thread&gt;  – 多线程[ok]"></a><code>&lt;thread&gt;</code>  – 多线程[ok]</h2><h2 id="–-类型萃取"><a href="#–-类型萃取" class="headerlink" title="&lt;type_traits&gt; – 类型萃取"></a><code>&lt;type_traits&gt;</code> – 类型萃取</h2><h2 id="–-标准整数类型"><a href="#–-标准整数类型" class="headerlink" title="&lt;cstdint&gt; – 标准整数类型"></a><code>&lt;cstdint&gt;</code> – 标准整数类型</h2><ul>
<li>它定义了大量标准整数类型，例如int8_t 和 int64_t 等，还包含了多个宏（指定这些类型的最小值和最大值）</li>
</ul>
<h2 id="–-相关实现信息-ok"><a href="#–-相关实现信息-ok" class="headerlink" title="&lt;version&gt; – 相关实现信息[ok]"></a><code>&lt;version&gt;</code> – 相关实现信息[ok]</h2><ul>
<li>它可用于查询正在使用的C++标准库的相关实现信息<ul>
<li>版本号</li>
<li>发布日期</li>
<li>版权声明</li>
</ul>
</li>
</ul>
<h2 id="–-源位置"><a href="#–-源位置" class="headerlink" title="&lt;source_location&gt; – 源位置"></a><code>&lt;source_location&gt;</code> – 源位置</h2><ul>
<li>C++20添加了<code>std::source_location</code>类，用来查询有关源代码的信息，例如文件名，函数名，行号和列号，并可用于替换旧的C风格宏<code>__FILE__</code>和<code>__LINE__</code></li>
</ul>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="ok"><a href="#ok" class="headerlink" title="&lt;vector&gt;[ok]"></a><code>&lt;vector&gt;</code>[ok]</h3><h3 id="-1"><a href="#-1" class="headerlink" title="&lt;list&gt;"></a><code>&lt;list&gt;</code></h3><h3 id="-2"><a href="#-2" class="headerlink" title="&lt;forward_list&gt;"></a><code>&lt;forward_list&gt;</code></h3><h3 id="-3"><a href="#-3" class="headerlink" title="&lt;deque&gt;"></a><code>&lt;deque&gt;</code></h3><h3 id="-4"><a href="#-4" class="headerlink" title="&lt;array&gt;"></a><code>&lt;array&gt;</code></h3><h3 id="-5"><a href="#-5" class="headerlink" title="&lt;span&gt;"></a><code>&lt;span&gt;</code></h3><h3 id="-6"><a href="#-6" class="headerlink" title="&lt;queue&gt;"></a><code>&lt;queue&gt;</code></h3><h3 id="-7"><a href="#-7" class="headerlink" title="&lt;stack&gt;"></a><code>&lt;stack&gt;</code></h3><h3 id="-8"><a href="#-8" class="headerlink" title="&lt;set&gt;"></a><code>&lt;set&gt;</code></h3><h3 id="-9"><a href="#-9" class="headerlink" title="&lt;map&gt;"></a><code>&lt;map&gt;</code></h3><h2 id="–-算法-ok"><a href="#–-算法-ok" class="headerlink" title="&lt;alogrithm&gt; – 算法[ok]"></a><code>&lt;alogrithm&gt;</code> – 算法[ok]</h2><h2 id="–-范围库"><a href="#–-范围库" class="headerlink" title="&lt;ranges&gt; – 范围库"></a><code>&lt;ranges&gt;</code> – 范围库</h2><ul>
<li>C++20引入了范围库，这使得处理元素序列变得更加简单和优雅</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/2024-05-22-1_2_%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/2024-05-22-1_2_%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">1_2_模型部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>模型部署相关笔记</li>
<li>模型部署需要的技术栈还是比较复杂的，不仅需要底层并行知识，还需要模型算法知识，不过对于两者的要求都不是很高，只需要能够看的懂最新进展，能够跟着复现就行，模型部署，最重要的还是工程能力</li>
</ul>
<h2 id="模型有几种形式"><a href="#模型有几种形式" class="headerlink" title="模型有几种形式"></a>模型有几种形式</h2><ul>
<li>模型的形式有很多种，模型部署说到底还是编程任务，使用代码来实现一套函数，只不过这个函数中的参数都被提取出来封装到了一起，称为模型。</li>
<li>也正是因为如此，不同的框架不同的代码生成的模型格式五花八门，从Pytorch到tf到mxnet等训练框架，它们保存的模型各不相同，我们首先要解决的就是统一模型的格式，这里的统一格式并不是指文件的后缀一样就可以了，而是指所要支持的算子要统一。</li>
</ul>
<h2 id="模型部署是什么"><a href="#模型部署是什么" class="headerlink" title="模型部署是什么"></a>模型部署是什么</h2><ul>
<li><p>模型部署是指将训练好的机器学习模型部署到生产环境中，以便实际应用中使用。在模型发布之前，需要将模型从训练环境中导出，然后将其部署到生产环境中，通常是作为一个服务或者一个库的形式。</p>
</li>
<li><p>在软件工程中，部署指把开发完毕的软件投入使用的过程，包括环境配置，软件安装等步骤。类似的，对于深度学习模型来说，模型部署指让训练好的模型在特定环境中运行的过程。相比于软件部署，模型部署会面临更多的难题：</p>
<ul>
<li>运行模型所需要的环境难以配置。深度学习模型通常是由一些框架编写的，例如PyTorch, TensorFlow。由于框架规模，依赖环境的限制，这些框架不适合在手机，开发板等生产环境中安装</li>
<li>深度学习模型的结构通常比较庞大，需要大量的算力才能满足实时运行的需求。模型的运行效率需要优化</li>
</ul>
</li>
<li><p>因为这些难题的存在，模型部署不能靠简单的环境配置与安装完成。经过工业界和学术界数年的探索，模型部署有了一条流行的流水线：</p>
<ul>
<li>为了让模型最终能够部署到某一环境上，开发者们可以使用任意一种深度学习框架来定义网络结构，并通过训练确定网络中的参数</li>
<li>之后，模型的结构和参数会被转换成一种只描述网络结构的中间表示，一些针对网络结构的优化会在中间表示上进行</li>
<li>最后，用面向硬件的高性能编程框架（如 CUDA，OpenCL）编写，能高效执行深度学习网络中算子的推理引擎会把中间表示转换成特定的文件格式，并在对应硬件平台上高效运行模型。</li>
</ul>
</li>
<li><p>这一条流水线解决了模型部署中的两大问题：使用对接深度学习框架和推理引擎的中间表示，开发者不必担心如何在新环境中运行各个复杂的框架；通过中间表示的网络结构优化和推理引擎对运算的底层优化，模型的运算效率大幅提升</p>
</li>
</ul>
<h2 id="如何模型部署"><a href="#如何模型部署" class="headerlink" title="如何模型部署"></a>如何模型部署</h2><ul>
<li><p>模型部署的过程通常包括以下几个步骤</p>
<ul>
<li>导出模型: 将训练好的模型导出为可部署的格式，例如PMML， ONNX， TensorFlow等</li>
<li>部署模型: 将导出的模型部署到生产环境中，通常是作为一个服务或者一个库的形式。</li>
<li>测试模型: 在生产环境中对模型进行测试，以确保其能够正常工作，并且输出结果符合预期</li>
<li>监控模型: 在生产环境中对模型进行监控，以便及时发现并解决问题</li>
</ul>
</li>
<li><p>模型发布是机器学习应用中重要的一环，它可以帮助企业快速将机器学习应用落地，并带来实际的商业价值。</p>
</li>
<li><p>模型的部署方式可以根据具体的应用场景和需求而定，以下是一些常见的模型部署方式</p>
<ul>
<li>WebAPI: 将模型部署为一个Web服务，通过HTTP请求来获取模型预测的结果。可以使用Flask,Django等</li>
<li>嵌入式设备: 将模型部署到嵌入式设备上，例如数梅派，Jetson Nano等。可以使用TensorFlow Lit, Pytorch Mobile等框架来实现</li>
<li>容器化: 将模型打包成docker镜像，然后部署到云服务器上。可以使用Kubernetes, Docker Swarm等容器编排工具来实现</li>
<li>边缘计算: 将模型部署到边缘设备上，例如智能摄像头，智能家居等。可以使用TensorFlow.js, TensorFlow Lite等框架来实现。</li>
</ul>
</li>
<li><p>无论采用哪种部署方式，都需要考虑模型的性能，安全性，可靠性，可维护性等方面的问题。</p>
</li>
</ul>
<h2 id="模型部署的应用场景"><a href="#模型部署的应用场景" class="headerlink" title="模型部署的应用场景"></a>模型部署的应用场景</h2><ul>
<li>图像识别：将图像识别模型部署到智能摄像头、安防监控系统等设备上，实现人脸识别、车牌识别等功能。</li>
<li>自然语言处理：将自然语言处理模型部署到智能客服、聊天机器人等应用中，实现自然语言理解、情感分析等功能。</li>
<li>推荐系统：将推荐系统模型部署到电商、社交网络等应用中，实现商品推荐、好友推荐等功能。</li>
<li>工业控制：将模型部署到工业生产线上，实现质量检测、故障预测等功能。</li>
<li>金融风控：将模型部署到银行、保险等金融机构中，实现风险评估、欺诈检测等功能。</li>
<li>医疗诊断：将模型部署到医疗设备中，如医学影像诊断、病理分析等应用中，实现疾病诊断、治疗方案推荐等功能。</li>
<li>智能交通：将模型部署到交通系统中，实现交通流量预测、智能路灯等功能。</li>
<li>物联网：将模型部署到物联网设备中，如智能家居、智能城市等应用中，实现环境监测、交通管理等功能。</li>
<li>游戏开发：将模型部署到游戏中，实现智能 NPC、游戏推荐等功能。</li>
</ul>
<h2 id="模型部署的注意事项"><a href="#模型部署的注意事项" class="headerlink" title="模型部署的注意事项"></a>模型部署的注意事项</h2><ul>
<li>确保模型的正确性：在部署模型之前，需要对模型进行充分的测试，以确保其能够正确地工作，并且输出结果符合预期。</li>
<li>选择适合的部署方式：不同的应用场景需要不同的部署方式，需要根据具体的需求选择适合的部署方式。</li>
<li>考虑性能和资源消耗：在部署模型时需要考虑模型的性能和资源消耗，以确保模型能够在生产环境中高效地运行。</li>
<li>考虑安全性和隐私保护：在部署模型时需要考虑安全性和隐私保护，以确保模型不会被恶意攻击或者泄露用户隐私。</li>
<li>建立监控和反馈机制：在部署模型后，需要建立监控和反馈机制，及时发现并解决模型出现的问题，以确保模型能够持续地稳定运行。</li>
</ul>
<h2 id="模型部署模型的实现类库"><a href="#模型部署模型的实现类库" class="headerlink" title="模型部署模型的实现类库"></a>模型部署模型的实现类库</h2><ul>
<li>Python中有很多方法可以实现模型部署，以下是一些常见的方法：<ul>
<li>Flask：Flask是一个轻量级的Web框架，可以用来搭建Web API。通过Flask，可以将模型部署为一个Web服务，通过HTTP请求来获取模型预测结果。</li>
<li>Django：Django是一个功能强大的Web框架，可以用来搭建Web应用程序。通过Django，可以将模型部署为一个Web应用程序，实现更复杂的业务逻辑。</li>
<li>FastAPI：FastAPI是一个高性能的Web框架，可以用来搭建Web API。与Flask相比，FastAPI具有更高的性能和更好的类型注释支持。</li>
<li>TensorFlow Serving：TensorFlow Serving是一个专门用于模型部署的框架，可以快速部署TensorFlow模型，并提供高性能的预测服务。</li>
<li>ONNX Runtime：ONNX Runtime是一个高性能的推理引擎，可以用于部署ONNX格式的模型。ONNX Runtime支持多种硬件平台和操作系统，包括CPU、GPU、FPGA等。</li>
<li>PyTorch Serving：PyTorch Serving是一个专门用于PyTorch模型部署的框架，可以快速部署PyTorch模型，并提供高性能的预测服务。</li>
<li>AWS Lambda：AWS Lambda是亚马逊云提供的一种无服务器计算服务，可以用来运行代码。通过AWS Lambda，可以将模型部署为一个无服务器应用程序，实现高可用性和低成本。</li>
</ul>
</li>
</ul>
<h2 id="模型部署后的性能评价"><a href="#模型部署后的性能评价" class="headerlink" title="模型部署后的性能评价"></a>模型部署后的性能评价</h2><ul>
<li>模型部署后，我们需要对模型的性能进行评价，以确保模型能够在生产环境中高效地运行。以下是一些常见的模型性能评价方法：<ul>
<li>响应时间：响应时间是指从接收请求到返回结果所需的时间。在模型部署后，我们需要对模型的响应时间进行评价，以确保模型能够在实时应用中快速响应。</li>
<li>吞吐量：吞吐量是指在单位时间内处理的请求数量。在模型部署后，我们需要对模型的吞吐量进行评价，以确保模型能够在高并发场景下处理大量请求。</li>
<li>准确率：准确率是指模型在测试集上的分类准确率。在模型部署后，我们需要对模型的准确率进行评价，以确保模型在生产环境中能够保持良好的预测性能。</li>
<li>内存占用：内存占用是指模型在运行时所占用的内存大小。在模型部署后，我们需要对模型的内存占用进行评价，以确保模型能够在生产环境中高效地利用资源。</li>
<li>CPU和GPU利用率：CPU和GPU利用率是指在模型运行时，CPU和GPU的利用率。在模型部署后，我们需要对CPU和GPU的利用率进行评价，以确保模型能够充分利用硬件资源。</li>
</ul>
</li>
</ul>
<h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h2><ul>
<li><p>保存为pt文件或者pth文件，pytorch导出的模型有两种方案</p>
<ul>
<li>第一种是不仅仅包含参数，还包含了模型结构，读取的时候不需要预先建立模型</li>
<li>第二种是仅仅包含参数，读取之前需要将模型建立好，通过pth文件往里面填参数。</li>
</ul>
</li>
<li><p>但是第一种方案也不是在任何地方都可以直接使用，还是要有模型定义代码，也就是说这两种模型都只能由pytorch使用。</p>
</li>
<li><p>pytorch还支持另一种导出</p>
<ul>
<li>导出成torchscript格式，这种确确实实是将模型结构和参数都保存了，不仅可以用在pytorch，还可以用在C++推理上，不过C++推理依旧需要torchlib，相当于还是离不开torch</li>
</ul>
</li>
</ul>
<h2 id="ONNX"><a href="#ONNX" class="headerlink" title="ONNX"></a>ONNX</h2><ul>
<li><p>onnx是一套开放的中间格式标准，目前大部分深度学习相关的工具都支持onnx。onnx与训练框架，推理框架都无关</p>
</li>
<li><p>onnx模型由三部分组成</p>
<ul>
<li>节点Node: 就是神经网络中一层</li>
<li>输入Input: 存储了输入矩阵的维度信息</li>
<li>初始化器Initializer: 存储了权重和参数</li>
</ul>
</li>
<li><p>三种之间互关联，相互依赖，很难修改</p>
</li>
<li><p>在编译器领域，为了支持不同的编程语言和不同的运行平台，提出了一种与编程语言和运行平台无关的中间表达语言称为IR，onnx也可以看作是深度学习领域的IR</p>
</li>
</ul>
<h2 id="推理系统"><a href="#推理系统" class="headerlink" title="推理系统"></a>推理系统</h2><ul>
<li>有了通用的模型格式，深度学习要融入到整个产品中需要设计成一个单独的系统，响应处理外界请求，这就是推理系统的工作。</li>
<li>推理系统需要考虑包括模型管理，服务接口设计，系统检测，系统调度等。推理系统更多的是将推理工作包装成一个服务，供外界使用，推理系统需要考虑的事情<ul>
<li>吞吐量</li>
<li>响应效率</li>
<li>扩展性</li>
<li>灵活性</li>
</ul>
</li>
</ul>
<h2 id="推理引擎"><a href="#推理引擎" class="headerlink" title="推理引擎"></a>推理引擎</h2><ul>
<li>推理引擎主要做的是： 优化模型，实现核心算子，开发目标平台调度引擎。</li>
<li>本来像OpenVINO和TensorRT这种是厂家做出来的，支持的平台也只有它们自己的平台。</li>
<li>随着深度学习大火，各种推理框架都发展了起来。</li>
</ul>
<h2 id="模型转换"><a href="#模型转换" class="headerlink" title="模型转换"></a>模型转换</h2><ul>
<li><p>不同的训练框架，如Tensorflow、PyTorch、MindSpore、MXNet、CNTK等，都定义了自己的模型的数据结构，推理系统需要将它们转换到统一的一种数据结构上。开发神经网络交换协议（Open Neural Network Exchange，ONNX）正是为此目的而设计的。ONNX支持广泛的机器学习运算符集合，并提供了不同训练框架的转换器，例如TensorFlow模型到ONNX模型的转换器、PyTorch模型到ONNX模型的转换器等。</p>
</li>
<li><p>模型转换本质上是将模型这种结构化的数据，从一种数据结构转换为另一种数据结构的过程。进行模型转换首先要分析两种数据结构的异同点，然后针对结构相同的数据做搬运；对于结构相似的数据做一一映射；对于结构差异较大的数据则需要根据其语义做合理的数据转换；更进一步如果两种数据结构上存在不兼容，则模型转换无法进行。</p>
</li>
<li><p>ONNX的一个优势就在于其强大的表达能力，从而大多数业界框架的模型都能够转换到ONNX的模型上来而不存在不兼容的情况。</p>
</li>
<li><p>模型可以抽象为一种图，从而模型的数据结构可以解构为以下两个要点：</p>
<ul>
<li>模型拓扑连接：从图的角度来说，就是图的边；从AI模型的角度来说，就是AI模型中的数据流和控制流等。模型数据流和控制流的定义又可以引申出子图的表达形式、模型输入输出的表达形式、控制流结构的表达形式等。比如Tensorflow1.x中的控制流表达为一种有环图，通过Enter、Exit、Switch、LoopCond、NextIteration等算子来解决成环，而ONNX通过Loop，If等算子来表达控制流，从而避免引入了有环，所以在将Tensorflow1.x的控制流模型转化为ONNX模型时，需要将Tensorflow模型中的控制流图结构融合成ONNX的While或者If算子。</li>
<li>算子原型定义：从图的角度来说，就是图的顶点；从AI模型角度来说，就是AI模型中的数据处理节点或者控制流节点。算子原型包括但不限于算子类型、算子输入输出的定义、算子属性的定义等。比如Caffe的slice算子和ONNX的slice算子的语义其实是不一致的，Caffe的slice算子应该映射到ONNX的Split算子，所以在将Caffe模型转换成ONNX模型时，需要将Caffe的Slice算子映射到ONNX的Split算子。比如Tensorflow中的中的FusedBatchNorm算子在Caffe中找不到相同语义的算子，需要将Caffe的BatchNorm算子和Scale算子组合起来才能表达相同的语义。</li>
</ul>
</li>
<li><p>在完成模型转换之后，通常地，框架会将一些不依赖于输入的工作提前去完成。这些工作包括了如常量折叠、算子融合、算子替换、算子重排等一些优化手段。这些优化手段的概念在前面的章节其实已经提及到，比如在编译器前端阶段，通常也会做常量折叠；在编译器后端阶段，通常会根据后端的硬件支持程度，对算子进行融合和拆分。但是有些优化工作只有在部署阶段才能进行或者彻底进行</p>
</li>
</ul>
<h2 id="模型部署场景"><a href="#模型部署场景" class="headerlink" title="模型部署场景"></a>模型部署场景</h2><ul>
<li>这个问题主要源于中心服务器云端部署和边缘部署两种方式的差异 <ul>
<li>云端部署常见的模式是模型部署在云端服务器，用户通过网页访问或者 API 接口调用等形式向云端服务器发出请求，云端收到请求后处理并返回结果。</li>
<li>边缘部署则主要用于嵌入式设备，主要通过将模型打包封装到 SDK，集成到嵌入式设备，数据的处理和模型推理都在终端设备上执行。</li>
</ul>
</li>
</ul>
<h2 id="模型部署方式"><a href="#模型部署方式" class="headerlink" title="模型部署方式"></a>模型部署方式</h2><ul>
<li>针对中心服务器云端部署方式和边缘部署方式，分别有两种不同的部署方案，Service部署和SDK部署。<ul>
<li>Service 部署：主要用于中心服务器云端部署，一般直接以训练的引擎库作为推理服务模式。</li>
<li>SDK 部署：主要用于嵌入式端部署场景，以 C++ 等语言实现一套高效的前后处理和推理引擎库（高效推理模式下的 Operation&#x2F;Layer&#x2F;Module 的实现），用于提供高性能推理能力。此种方式一般需要考虑模型转换（动态图静态化）、模型联合编译等进行深度优化。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>SDK 部署</th>
<th>Service 部署</th>
</tr>
</thead>
<tbody><tr>
<td>部署环境</td>
<td>SDK 引擎</td>
<td>训练框架</td>
</tr>
<tr>
<td>模型语义转换</td>
<td>需要进行前后处理和模型的算子重实现</td>
<td>一般框架内部负责语义转换</td>
</tr>
<tr>
<td>前后处理对齐算子</td>
<td>训练和部署对应两套实现，需要进行算子数值对齐</td>
<td>共用算子</td>
</tr>
<tr>
<td>计算优化</td>
<td>偏向于挖掘芯片编译器的深度优化能力</td>
<td>利用引擎已有训练优化能力</td>
</tr>
</tbody></table>
<h2 id="部署的核心优化指标"><a href="#部署的核心优化指标" class="headerlink" title="部署的核心优化指标"></a>部署的核心优化指标</h2><ul>
<li><p>部署的核心目标是合理把控成本、功耗、性价比三大要素</p>
</li>
<li><p>成本问题是部署硬件的重中之重，AI 模型部署到硬件上的成本将极大限制用户的业务承受能力。</p>
</li>
<li><p>成本问题主要聚焦于芯片的选型，比如，对比寒武纪 MLU220 和 MLU270，MLU270 主要用作数据中心级的加速卡，其算力和功耗都相对于边缘端的人工智能加速卡MLU220要低。至于 Nvida 推出的 Jetson 和 Tesla T4 也是类似思路，Tesla T4 是主打数据中心的推理加速卡，而 Jetson 则是嵌入式设备的加速卡。对于终端场景，还会根据对算力的需求进一步细分，比如表中给出的高通骁龙芯片，除 GPU 的浮点算力外，还会增加 DSP 以增加定点算力，篇幅有限，不再赘述，主要还是根据成本和业务需求来进行权衡。</p>
</li>
<li><p>在数据中心服务场景，对于功耗的约束要求相对较低；在边缘终端设备场景，硬件的功耗会影响边缘设备的电池使用时长。因此，对于功耗要求相对较高，一般来说，利用 NPU 等专用优化的加速器单元来处理神经网络等高密度计算，能节省大量功耗</p>
</li>
<li><p>不同的业务场景对于芯片的选择有所不同，以达到更高的性价比。 从公司业务来看，云端相对更加关注是多路的吞吐量优化需求，而终端场景则更关注单路的延时需要。在目前主流的 CV 领域，低比特模型相对成熟，且 INT8&#x2F;INT4 芯片因成本低，且算力比高的原因已被广泛使用；但在NLP或者语音等领域，对于精度的要求较高，低比特模型精度可能会存在难以接受的精度损失，因此 FP16 是相对更优的选择。在 CV 领域的芯片性价比选型上，在有 INT8&#x2F;INT4 计算精度的芯片里，主打低精度算力的产品是追求高性价比的主要选择之一，但这也为平衡精度和性价比提出了巨大的挑战</p>
</li>
</ul>
<h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><ul>
<li>上面简要介绍了部署的主要方式和场景，以及部署芯片的选型考量指标，接下来以 SDK 部署为例，给大家概括介绍一下 SenseParrots 在部署中的整体流程。SenseParrots 部署流程大致分为以下几个步骤：模型转换、模型量化压缩、模型打包封装 SDK。</li>
</ul>
<h3 id="模型转换-1"><a href="#模型转换-1" class="headerlink" title="模型转换"></a>模型转换</h3><ul>
<li>模型转换主要用于模型在不同框架之间的流转，常用于训练和推理场景的连接。目前主流的框架都以 ONNX 或者 caffe 为模型的交换格式，SenseParrots 也不例外。SenseParrots 的模型转换主要分为计算图生成和计算图转换两大步骤，另外，根据需要，还可以在中间插入计算图优化，对计算机进行推理加速（诸如常见的 CONV&#x2F;BN 的算子融合）</li>
<li>计算图生成是通过一次 inference 并追踪记录的方式，将用户的模型完整地翻译成静态的表达。在模型 inference 的过程中，框架会记录执行算子的类型、输入输出、超参、参数和调用该算子的模型层次，最后把 inference 过程中得到的算子信息和模型信息结合得到最终的静态计算图</li>
<li>在计算图生成之后与计算图转换之前，可以进行计算图优化，例如去除冗余 op，计算合并等。SenseParrots 原生实现了一批计算图的精简优化 pass，也开放接口鼓励用户对计算图进行自定义的处理和优化操作</li>
<li>计算图转换是指分析静态计算图的算子，对应转换到目标格式。SenseParrots 支持了多后端的转换，能够转换到各个 opset 的 ONNX、原生 caffe 和多种第三方版本的 caffe。框架通过算子转换器继承或重写的方式，让 ONNX 和 caffe 的不同版本的转换开发变得更加简单。同时，框架开放了自定义算子生成和自定义算子转换器的接口，让第三方框架开发者也能够轻松地自主开发实现 SenseParrots 到第三方框架的转换</li>
</ul>
<h3 id="模型量化压缩"><a href="#模型量化压缩" class="headerlink" title="模型量化压缩"></a>模型量化压缩</h3><ul>
<li>终端场景中，一般会有内存和速度的考虑，因此会要求模型尽量小，同时保证较高的吞吐率。除了人工针对嵌入式设备设计合适的模型，如 MobileNet 系列，通过 NAS(Neural Architecture Search) 自动搜索小模型，以及通过蒸馏&#x2F;剪枝的方式压缩模型外，一般还会使用量化来达到减小模型规模和加速的目的。</li>
<li>量化的过程主要是将原始浮点 FP32 训练出来的模型压缩到定点 INT8(或者 INT4&#x2F;INT1) 的模型，由于 INT8 只需要 8 比特来表示，因此相对于 32 比特的浮点，其模型规模理论上可以直接降为原来的 1&#x2F;4，这种压缩率是非常直观的。 另外，大部分终端设备都会有专用的定点计算单元，通过低比特指令实现的低精度算子，速度上会有很大的提升，当然，这部分还依赖协同体系结构和算法来获得更大的加速</li>
<li>量化的技术栈主要分为量化训练（QAT, Quantization Aware Training）和离线量化（PTQ, Post Training Quantization）, 两者的主要区别在于，量化训练是通过对模型插入伪量化算子（这些算子用来模拟低精度运算的逻辑），通过梯度下降等优化方式在原始浮点模型上进行微调，从来调整参数得到精度符合预期的模型。离线量化主要是通过少量校准数据集（从原始数据集中挑选 100-1000 张图，不需要训练样本的标签）获得网络的 activation 分布，通过统计手段或者优化浮点和定点输出的分布来获得量化参数，从而获取最终部署的模型。 两者各有优劣，量化训练基于原始浮点模型的训练逻辑进行训练，理论上更能保证收敛到原始模型的精度，但需要精细调参且生产周期较长；离线量化只需要基于少量校准数据，因此生产周期短且更加灵活，缺点是精度可能略逊于量化训练。 实际落地过程中，发现大部分模型通过离线量化就可以获得不错的模型精度（1% 以内的精度损失，当然这部分精度的提升也得益于优化策略的加持），剩下少部分模型可能需要通过量化训练来弥补精度损失，因此实际业务中会结合两者的优劣来应用</li>
<li>量化主要有两大难点：一是如何平衡模型的吞吐率和精度，二是如何结合推理引擎充分挖掘芯片的能力。 比特数越低其吞吐率可能会越大，但其精度损失可能也会越大，因此，如何通过算法提升精度至关重要，这也是组内的主要工作之一。另外，压缩到低比特，某些情况下吞吐率未必会提升，还需要结合推理引擎优化一起对模型进行图优化，甚至有时候会反馈如何进行网络设计，因此会是一个算法与工程迭代的过程</li>
</ul>
<h3 id="模型打包封装SDK"><a href="#模型打包封装SDK" class="headerlink" title="模型打包封装SDK"></a>模型打包封装SDK</h3><ul>
<li>实际业务落地过程中，模型可能只是产品流程中的一环，用于实现某些特定功能，其输出可能会用于流程的下一环。因此，模型打包会将模型的前后处理，一个或者多个模型整合到一起，再加入描述性的文件（前后处理的参数、模型相关参数、模型格式和版本等）来实现一个完整的功能。因此，SDK 除了需要一些通用前后处理的高效实现，对齐训练时的前后处理逻辑，还需要具有足够好的扩展性来应对不同的场景，方便业务线同学扩展新的功能。可以看到，模型打包过程更多是模型的进一步组装，将不同模型组装在一起，当需要使用的时候将这些内容解析成整个流程（pipeline）的不同阶段（stage），从而实现整个产品功能</li>
<li>另外，考虑到模型很大程度是研究员的研究成果，对外涉及保密问题，因此会对模型进行加密，以保证其安全性。加密算法的选择需要根据实际业务需求来决定，诸如不同加密算法其加解密效率不一样，加解密是否有中心验证服务器，其核心都是为了保护研究成果</li>
</ul>
<h2 id="模型推理"><a href="#模型推理" class="headerlink" title="模型推理"></a>模型推理</h2><ul>
<li><p>实际上，用训练好的模型对新数据进行预测，在机器学习工程上有一个更专业的名词叫做 推理(inference)。</p>
</li>
<li><p>通过训练集构建的神经网络对新输入数据进行预测，就是推理。</p>
</li>
<li><p>一般情况下，推理又分为: 静态推理与动态推理</p>
<ul>
<li>静态推理很好理解，我们通过集中对批量数据进行推理，并将结果存放在数据表或者数据库中。当有需要的时候，再直接通过查询来获得推理结果。</li>
<li>而动态推理一般表示我们将模型部署到服务器中。当有需要时，通过向服务器发送请求来获得模型返回的预测结果。与静态推理不同的是，动态推理的过程是实时计算的，而静态推理是提前批量处理好的。</li>
</ul>
</li>
<li><p>当然，静态和动态推理各有优缺点。静态推理适合于对大批量数据进行处理，因为动态推理面对大数据量时非常耗时。但是静态推理无法实时更新，而动态推理的结果是即时计算结果</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/FFmpeg/ffmpeg_1_%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/2024-05-22-ffmpeg_1_2_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/FFmpeg/ffmpeg_1_%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/2024-05-22-ffmpeg_1_2_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">ffmpeg_1_2_基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>FFmpeg 理论基础知识</li>
</ul>
<h2 id="ffmpeg-依赖库"><a href="#ffmpeg-依赖库" class="headerlink" title="ffmpeg 依赖库"></a>ffmpeg 依赖库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apt -y install autoconf automake libass-dev libfreetype6-dev libsdl2-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev pkg-config texinfo zlib1g-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 汇编库</span></span><br><span class="line">apt -y install yasm nasm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频库</span></span><br><span class="line">apt -y install libx264-dev libx265-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 音频库</span></span><br><span class="line">apt -y install libfdk-aac-dev libmp3lame-dev libopus-dev</span><br></pre></td></tr></table></figure>

<h2 id="ffmpeg-编译安装"><a href="#ffmpeg-编译安装" class="headerlink" title="ffmpeg 编译安装"></a>ffmpeg 编译安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ffmpeg-5.1.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部的</span></span><br><span class="line">./configure --enable-ffplay --enable-libx264 --enable-libx265 --enable-pic --enable-libvorbis --enable-libass --enable-nonfree --enable-libass --enable-libfreetype --enable-libfdk-aac --enable-shared --enable-gpl --enable-libmp3lame --enable-libopus --disable-x86asm </span><br><span class="line"></span><br><span class="line"><span class="comment"># mp3库版本不够 屏蔽掉libmp3lame库</span></span><br><span class="line">./configure --enable-ffplay --enable-libx264 --enable-libx265 --enable-pic --enable-libvorbis --enable-libass --enable-nonfree --enable-libass --enable-libfreetype --enable-libfdk-aac --enable-shared --enable-gpl --disable-libmp3lame --enable-libopus --disable-x86asm  --prefix=/data/usr/local/ffmpeg</span><br><span class="line"></span><br><span class="line">make -j16</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/FFmpeg/ffmpeg_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-ffmpeg_3_1_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/FFmpeg/ffmpeg_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-ffmpeg_3_1_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">ffmpeg_3_1_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ffmpeg 常用技巧</li>
</ul>
<h2 id="ffmpeg-安装"><a href="#ffmpeg-安装" class="headerlink" title="ffmpeg 安装"></a>ffmpeg 安装</h2><ul>
<li>下载FFmpge源代码 <code>http://ffmpeg.org/download.html</code></li>
<li>安装依赖库 <code>yasm  libsdl1.2-dev libsdl2-dev</code></li>
<li>编译安装  <code>./configure --prefix=/usr/local/ffmpeg &amp;&amp; make &amp;&amp; make install</code></li>
</ul>
<h2 id="使用ffserver-将本地视频转为rtsp视频流"><a href="#使用ffserver-将本地视频转为rtsp视频流" class="headerlink" title="使用ffserver 将本地视频转为rtsp视频流"></a>使用ffserver 将本地视频转为rtsp视频流</h2><ul>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HTTPPort 9554</span><br><span class="line">RTSPPort 554</span><br><span class="line">MaxClients 1000</span><br><span class="line">MaxBandwidth 1000</span><br><span class="line">CustomLog -</span><br><span class="line"></span><br><span class="line">&lt;Stream stat.html&gt;</span><br><span class="line">Format status</span><br><span class="line">ACL allow localhost</span><br><span class="line">ACL allow 192.167.0.0 192.167.255.255</span><br><span class="line">&lt;/Stream&gt;</span><br><span class="line"></span><br><span class="line">&lt;Stream new_year.mp4&gt;</span><br><span class="line">File &quot;/home/user/Videos/new_year.mp4&quot;</span><br><span class="line">Format rtp</span><br><span class="line">&lt;/Stream&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：<code>rtsp://192.167.15.58:554/new_year.mp4</code></p>
</li>
<li><p>参数说明</p>
<ul>
<li><code>HTTPPort 9554</code> – HTTP服务器监听的tcp端口</li>
<li><code>Port 9554</code> – 和<code>HTTPPort</code>一样，但是不推荐使用</li>
<li><code>RTSPPort 554</code> – rtsp服务器监听的tcp端口</li>
<li><code>HTTPBindAddress 0.0.0.0</code> – http服务器绑定地址</li>
<li><code>RTSPBindAddress</code> – rtsp服务器绑定的地址</li>
<li><code>MaxHTTPConnections 2000</code> – 可以同时处理的http连接数，必须在<code>MaxClients</code>之前，默认2000</li>
<li><code>MaxClients 1000</code> – 可以同时处理的请求数,默认为5</li>
<li><code>MaxBandwidth 1000</code> – 最大的传输比特率(kbps) kbit&#x2F;sec 默认为1000</li>
<li><code>CustomLog [filename/-]</code> – 日志文件，使用标准的Apache日志文件格式， <code>-</code> 代表标准输出，没有这个选项不会产生日志，<code>-d</code>启动时忽略此配置并打印在标准输出上</li>
<li><code>NoDaemon</code> – 禁止为守护进程，若要以守护进程启动去掉此属性即可</li>
<li><code>ACL allow 127.0.0.1</code> – 允许本机连接feed</li>
<li><code>Feed feed.ffm</code> – 所关联的feed文件</li>
<li><code>File filename</code> – 预先准备好的文件</li>
<li><code>Format flv/rtp</code> – 输出流的格式</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/FFmpeg/ffmpeg_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-ffmpeg_2_1_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/FFmpeg/ffmpeg_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-ffmpeg_2_1_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">ffmpeg_2_1_常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ffmpeg 常用命令和常用技巧</li>
</ul>
<h2 id="ffmpeg-多张图片编码成h264视频"><a href="#ffmpeg-多张图片编码成h264视频" class="headerlink" title="ffmpeg 多张图片编码成h264视频"></a>ffmpeg 多张图片编码成h264视频</h2><p>你可以使用FFmpeg将多张图片编码成H.264视频。以下是一个示例命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 24 -i image%d.jpg -c:v libx264 -preset slow -crf 20 output.mp4</span><br></pre></td></tr></table></figure>

<p>这个命令的解释如下：</p>
<ul>
<li><code>-framerate 24</code>：指定视频的帧率为24帧每秒。你可以根据需要调整这个值。</li>
<li><code>-i image%d.jpg</code>：指定输入图片的路径和格式。<code>%d</code>会被替换为数字序列，比如image1.jpg、image2.jpg等。</li>
<li><code>-c:v libx264</code>：指定视频编码器为libx264，即H.264编码器。</li>
<li><code>-preset slow</code>：指定编码速度为慢速，可以提高视频质量。</li>
<li><code>-crf 20</code>：设置视频的质量。CRF值越低，视频质量越高，范围一般在18-28之间。你可以根据需要调整这个值。</li>
<li><code>output.mp4</code>：指定输出视频的文件名和格式。</li>
</ul>
<p>你可以根据需要修改参数来满足你的具体需求。</p>
<h2 id="从指定时间截取指定长度视频"><a href="#从指定时间截取指定长度视频" class="headerlink" title="从指定时间截取指定长度视频"></a>从指定时间截取指定长度视频</h2><ul>
<li><p>命令：</p>
<ul>
<li><code>ffmpeg -ss 00:00:00 -t 00:00:14 -i zhuoer_face.mkv -vcodec copy -acodec copy aaa.mp4</code></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>-ss</code> : 开始截取的时间点</li>
<li><code>-t</code>  : 要截取视频的时间长度</li>
<li><code>-i</code>  : 输入的视频文件</li>
<li><code>-vcodec copy</code> : 拷贝原视频，不更改格式</li>
<li><code>-acodec copy</code> : 拷贝原音频，不更改格式</li>
<li><code>aaa.mp4</code> : 输出视频文件</li>
</ul>
</li>
</ul>
<h2 id="合并视频文件"><a href="#合并视频文件" class="headerlink" title="合并视频文件"></a>合并视频文件</h2><ul>
<li><p>命令：</p>
<ul>
<li><code>ffmpeg -f concat -i list.txt -c copy zhuoer_face_new.mp4</code></li>
</ul>
</li>
<li><p>list.txt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file aaa.mp4</span><br><span class="line">file bbb.mp4</span><br><span class="line">file ccc.mp4</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>-f concat</code> : </li>
<li><code>-i list.txt</code> : 输入配置文件</li>
<li><code>-c copy</code> : 拷贝原视频，不更改格式</li>
<li><code>zhuoer_face_new.mp4</code> : 输出视频文件</li>
</ul>
</li>
</ul>
<h2 id="ffmpeg保存摄像头视频到本地"><a href="#ffmpeg保存摄像头视频到本地" class="headerlink" title="ffmpeg保存摄像头视频到本地"></a>ffmpeg保存摄像头视频到本地</h2><ul>
<li><code>ffmpeg -rtsp_transport tcp -i rtsp://admin:a1234567@192.167.0.56:554 -c copy -f mp4 -t 00:10:00 /data/output.mp4</code></li>
</ul>
<h2 id="ffmpeg缩放视频（等比例）"><a href="#ffmpeg缩放视频（等比例）" class="headerlink" title="ffmpeg缩放视频（等比例）"></a>ffmpeg缩放视频（等比例）</h2><ul>
<li><code>ffmpeg -i input-video.mp4 -vf scale=300:180 ./output.mp4</code></li>
<li>参数：<ul>
<li><code>-vf</code>  –  filter_graph, set video filters</li>
</ul>
</li>
</ul>
<h2 id="FFmpeg将视频按帧截取保存为图片"><a href="#FFmpeg将视频按帧截取保存为图片" class="headerlink" title="FFmpeg将视频按帧截取保存为图片"></a>FFmpeg将视频按帧截取保存为图片</h2><ul>
<li><code>ffmpeg -i /home/user/Videos/new_year.mp4 -r 5 -f image2 image-%03d.jpg</code></li>
<li>参数：<ul>
<li><code>-i</code>  –  指定输入源</li>
<li><code>-r</code>  –  指定抽取的帧，即从视频中每秒抽取的图片数量</li>
<li><code>-f</code>  –  fmt，强迫采用格式fmt 保存图片使用的格式</li>
<li><code>image-%03d.jpg</code>  –  指定文件的输出名字</li>
</ul>
</li>
</ul>
<h2 id="获取音视频信息"><a href="#获取音视频信息" class="headerlink" title="获取音视频信息"></a>获取音视频信息</h2><ul>
<li><code>ffprobe</code>是FFmpeg项目提供的用于分析视频信息的命令工具</li>
<li>例如:<code>ffprobe -v quiet -print_format json -show_format -show_streams test.mp4</code>可以活动json格式的输出的视频信息<ul>
<li><code>-v quiet</code> : 将日志级别设为quiet，避免日志信息污染json</li>
<li><code>-show_format</code> : 显式文件的容器信息</li>
<li><code>-show_stream</code> : 显式容器中流的信息</li>
<li><code>-show_frames</code> : 则可以显式视频中每一帧的信息</li>
</ul>
</li>
</ul>
<h2 id="使用ffmpeg进行视频处理"><a href="#使用ffmpeg进行视频处理" class="headerlink" title="使用ffmpeg进行视频处理"></a>使用ffmpeg进行视频处理</h2><ul>
<li><p>ffmpeg的命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg \</span><br><span class="line">    [global_options] \</span><br><span class="line">    [input_file_options] -i input_url \</span><br><span class="line">    [actions] \</span><br><span class="line">    [output_file_options] output_url</span><br></pre></td></tr></table></figure></li>
<li><p>可以将ffmpeg的选项分为全局选项和局部选项</p>
<ul>
<li>局部选项用于设置输入输出或滤镜等，通常位于被修饰的指令前面</li>
</ul>
</li>
<li><p>ffmpeg的基本流程为：将容器中的各流进行解码，然后重新编码为指定的格式。在编码之前，可以使用<code>filter</code>对视频进行处理</p>
</li>
<li><p>选项</p>
<ul>
<li><code>-y / -n</code> : 全局选项，<code>-y</code>表示直接覆盖已经存在的输入文件，<code>-n</code>表示若某个输出文件已经存在则退出。若没有设置<code>-y</code>或<code>-n</code>选项，且某个输出文件已经存在，ffmpeg会询问是否要覆盖输出文件</li>
<li><code>-codec , -c</code> ： 指定输入输出的编解码器，可用的编解码器参考官方文档<ul>
<li>codec指定为<code>copy</code>，<strong>则将输入流直接复制到输出流不进行编码操作</strong></li>
<li>使用<code>-c:STREAM_INDEX</code>方式可以指定某一个流的编码器，<code>STREAM_INDEX</code>为stream对象的index属性</li>
<li><code>-c:v, -vcodec</code>，可以为所有视频流指定编解码器， <code>-c:v:1</code>为第2各视频流指定编解码器</li>
<li><code>-c:a, -acodec</code>，可以为所有音频流指定编解码器， <code>-c:a:12</code>为第13个视频流指定编解码器</li>
</ul>
</li>
<li><code>-ss</code> : 用于设置流的开始视频，可以设置输入输出或滤镜，在开始时间之前的帧将被跳过部处理（输入不被解码，输出不被编码，滤镜不被处理）<ul>
<li>秒数 ： <code>-t 10, -t 24.134</code></li>
<li>时分秒 ： <code>-t 10:23, -t 21:31:00.233</code></li>
</ul>
</li>
<li><code>-t</code> ： 选项用于设置输入输出，它在<code>-i</code>前可以限制输入时长，在输入文件前可限制输出时长</li>
<li><code>-to</code> : 类似于<code>-t</code>选项，不同的是它指定结束时刻，<code>-t</code>指定持续时间</li>
<li><code>-f</code> : 强制设置输入输出的文件格式，<strong>默认情况下ffmpeg会根据文件后缀名判断格式</strong><ul>
<li><code>ffmpeg-formats</code> 命令会显示所有支持的编码格式</li>
</ul>
</li>
<li><code>-vframes</code> : 设置输出文件中包含的总帧数</li>
<li><code>-vn</code> : 不将视频流写到输出文件中</li>
<li><code>-an</code> : 不将音频流写到输出文件中</li>
<li><code>-r</code> : 设置某个流的帧率</li>
<li><code>-s</code> ： 设置帧的大小</li>
<li><code>-threads</code> : 设置处理线程数</li>
<li><code>-shortest</code> : 当最短的输入流结束后，即停止编码和输出</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-linux_1_02_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-linux_1_02_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">linux_1_02_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux系统下理论基础知识笔记</li>
</ul>
<h2 id="linux-命令执行失败的错误码的意义"><a href="#linux-命令执行失败的错误码的意义" class="headerlink" title="linux 命令执行失败的错误码的意义"></a>linux 命令执行失败的错误码的意义</h2><p>在Linux系统中，命令执行失败时通常返回一个错误码，也称为退出码（Exit Code）。这个退出码是一个8位的整数，范围从0到255。通常情况下，0表示成功，而非零值表示错误。</p>
<p>以下是一些常见的退出码及其一般的意义：</p>
<ul>
<li>0: 成功（通常表示命令成功执行）</li>
<li>1: 一般性错误（通用错误，不具体指明）</li>
<li>2: 误用shell命令（用户不正确使用shell命令）</li>
<li>126: 不可执行的命令（命令存在但不可执行）</li>
<li>127: 找不到命令（命令未找到）</li>
<li>128: 无效的退出参数（传递给exit的参数无效）</li>
<li>130: Ctrl+C终止（通常由用户按下Ctrl+C中断命令）</li>
<li>137: 被kill -9终止（进程被强制终止）</li>
<li>255: 退出状态出界（退出状态超出0-255的范围）</li>
</ul>
<p>注意，不同的命令可能有自己特定的退出码含义，你可以查阅相关文档或命令的man页面以获取更详细的信息。一般来说，成功的退出码是0，非零值表示失败或错误。</p>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><ul>
<li><code>$#</code>, 传递到脚本或函数的参数个数</li>
<li><code>$*</code>, 以一个单字符串显示所有向脚本传递的参数</li>
<li><code>$$</code>, 脚本运行的当前进程ID号</li>
<li><code>$!</code>, 后台运行的最后一个进程的ID号</li>
<li><code>$@</code>, 与<code>$*</code>相同,但是使用时加引号,并在引号中返回每个参数</li>
<li><code>$-</code>, 显示Shell使用的当前选项,与set命令功能相同</li>
<li><code>$?</code>, 显示最后命令的退出状态,0表示没有错误,其他任何值表明有错误</li>
</ul>
<h2 id="信号详情"><a href="#信号详情" class="headerlink" title="信号详情"></a>信号详情</h2><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">默认动作</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SIGHUP</td>
<td align="left">终止进程</td>
<td align="left">终端线路挂断</td>
</tr>
<tr>
<td align="left">SIGINT</td>
<td align="left">终止进程</td>
<td align="left">中断进程</td>
</tr>
<tr>
<td align="left">SIGQUIT</td>
<td align="left">建立CORE文件</td>
<td align="left">终止进程，并且生成core文件</td>
</tr>
<tr>
<td align="left">SIGILL</td>
<td align="left">建立CORE文件</td>
<td align="left">非法指令</td>
</tr>
<tr>
<td align="left">SIGTRAP</td>
<td align="left">建立CORE文件</td>
<td align="left">跟踪自陷</td>
</tr>
<tr>
<td align="left">SIGBUS</td>
<td align="left">建立CORE文件</td>
<td align="left">总线错误</td>
</tr>
<tr>
<td align="left">SIGSEGV</td>
<td align="left">建立CORE文件</td>
<td align="left">段非法错误</td>
</tr>
<tr>
<td align="left">SIGFPE</td>
<td align="left">建立CORE文件</td>
<td align="left">浮点异常</td>
</tr>
<tr>
<td align="left">SIGIOT</td>
<td align="left">建立CORE文件</td>
<td align="left">执行I&#x2F;O自陷</td>
</tr>
<tr>
<td align="left">SIGKILL</td>
<td align="left">终止进程</td>
<td align="left">杀死进程</td>
</tr>
<tr>
<td align="left">SIGPIPE</td>
<td align="left">终止进程</td>
<td align="left">向一个没有读进程的管道写数据</td>
</tr>
<tr>
<td align="left">SIGALARM</td>
<td align="left">终止进程</td>
<td align="left">计时器到时</td>
</tr>
<tr>
<td align="left">SIGTERM</td>
<td align="left">终止进程</td>
<td align="left">软件终止信号</td>
</tr>
<tr>
<td align="left">SIGSTOP</td>
<td align="left">停止进程</td>
<td align="left">非终端来的停止信号</td>
</tr>
<tr>
<td align="left">SIGTSTP</td>
<td align="left">停止进程</td>
<td align="left">终端来的停止信号</td>
</tr>
<tr>
<td align="left">SIGCONT</td>
<td align="left">忽略信号</td>
<td align="left">继续执行一个停止的进程</td>
</tr>
<tr>
<td align="left">SIGURG</td>
<td align="left">忽略信号</td>
<td align="left">I&#x2F;O紧急信号</td>
</tr>
<tr>
<td align="left">SIGIO</td>
<td align="left">忽略信号</td>
<td align="left">描述符上可以进行I&#x2F;O</td>
</tr>
<tr>
<td align="left">SIGCHLD</td>
<td align="left">忽略信号</td>
<td align="left">当子进程停止或退出时通知父进程</td>
</tr>
<tr>
<td align="left">SIGTTOU</td>
<td align="left">停止进程</td>
<td align="left">后台进程写终端</td>
</tr>
<tr>
<td align="left">SIGTTIN</td>
<td align="left">停止进程</td>
<td align="left">后台进程读终端</td>
</tr>
<tr>
<td align="left">SIGXGPU</td>
<td align="left">终止进程</td>
<td align="left">CPU时限超时</td>
</tr>
<tr>
<td align="left">SIGXFSZ</td>
<td align="left">终止进程</td>
<td align="left">文件长度过长</td>
</tr>
<tr>
<td align="left">SIGWINCH</td>
<td align="left">忽略信号</td>
<td align="left">窗口大小发生变化</td>
</tr>
<tr>
<td align="left">SIGPROF</td>
<td align="left">终止进程</td>
<td align="left">统计分布图用计时器到时</td>
</tr>
<tr>
<td align="left">SIGUSR1</td>
<td align="left">终止进程</td>
<td align="left">用户定义信号1</td>
</tr>
<tr>
<td align="left">SIGUSR2</td>
<td align="left">终止进程</td>
<td align="left">用户定义信号2</td>
</tr>
<tr>
<td align="left">SIGVTALRM</td>
<td align="left">终止进程</td>
<td align="left">虚拟计时器到时</td>
</tr>
</tbody></table>
<h2 id="linux-build-essential是什么"><a href="#linux-build-essential是什么" class="headerlink" title="linux build-essential是什么"></a>linux build-essential是什么</h2><p><code>build-essential</code> 是一个针对 Linux 系统的软件包集合，旨在提供编译和构建软件所需的基本工具和库。它通常包括一些核心的开发工具，如 <code>gcc</code> 编译器、<code>g++</code> 编译器、<code>make</code> 构建工具等。这些工具对于编译和构建大多数软件项目都是必需的。</p>
<p>在许多基于 Debian 的发行版（比如 Ubuntu）中，可以通过包管理器如 <code>apt</code> 来安装 <code>build-essential</code>。在安装了这个软件包之后，你就能够开始在你的 Linux 系统上编译和构建各种 C、C++ 或其他语言的程序。</p>
<h2 id="linux-build-essential详解"><a href="#linux-build-essential详解" class="headerlink" title="linux build-essential详解"></a>linux build-essential详解</h2><p><code>build-essential</code> 是针对 Debian 和基于 Debian 的 Linux 发行版（如 Ubuntu）的一个元包（meta-package），它捆绑了一系列用于软件编译和构建的基本工具和库。这个软件包的安装通常是在开始开发或编译源代码之前需要进行的一个重要步骤。</p>
<p>以下是 <code>build-essential</code> 软件包通常包含的一些主要组件：</p>
<ol>
<li><p><strong>编译器</strong>：</p>
<ul>
<li><code>gcc</code>：GNU Compiler Collection，用于编译 C 代码。</li>
<li><code>g++</code>：GNU C++ 编译器，用于编译 C++ 代码。</li>
</ul>
</li>
<li><p><strong>构建工具</strong>：</p>
<ul>
<li><code>make</code>：一种自动化构建工具，通过 Makefile 文件管理源代码的编译和构建过程。</li>
<li><code>dpkg-dev</code>：包含了构建 Debian 软件包所需的工具。</li>
</ul>
</li>
<li><p><strong>库文件</strong>：</p>
<ul>
<li><code>libc6-dev</code>：C 语言标准库的头文件和其他开发文件。</li>
<li>其他可能需要的开发库文件，具体依赖于项目的需求。</li>
</ul>
</li>
</ol>
<p>安装 <code>build-essential</code> 软件包可以简化软件开发和编译过程，因为它提供了必要的工具和库，使用户能够在系统上直接编译和构建源代码而无需手动安装每个单独的组件。通过包管理器（如 <code>apt</code>）安装 <code>build-essential</code> 是相对简单和方便的。</p>
<p>要安装 <code>build-essential</code> 软件包，在终端中执行以下命令（假设你的系统使用的是 <code>apt</code> 包管理器）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install build-essential</span><br></pre></td></tr></table></figure>

<p>这样做会自动安装 <code>build-essential</code> 及其所包含的工具和库，使你可以立即开始进行软件开发、编译和构建工作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-linux_1_01_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-linux_1_01_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">linux_1_01_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux系统的相关理论知识</li>
</ul>
<h2 id="linux-psmisc-软件包-详解"><a href="#linux-psmisc-软件包-详解" class="headerlink" title="linux psmisc 软件包 详解"></a>linux psmisc 软件包 详解</h2><p><code>psmisc</code> 是一个用于 Linux 操作系统的软件包，它包含了一些有用的进程管理工具，通常用于查找和操作进程。以下是有关 <code>psmisc</code> 软件包的详细信息和一些常见工具：</p>
<ol>
<li><p><strong><code>killall</code> 命令</strong>：<code>killall</code> 命令用于终止具有指定名称的进程。通常，您可以提供要终止的进程的名称，然后 <code>killall</code> 会尝试找到并终止所有与该名称匹配的进程。</p>
<p>示例用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall process_name</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>pkill</code> 命令</strong>：<code>pkill</code> 命令允许根据进程的名称或其他属性来终止进程。与 <code>killall</code> 不同，<code>pkill</code> 具有更多的灵活性，可以使用正则表达式等来匹配进程。</p>
<p>示例用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -u username process_name</span><br></pre></td></tr></table></figure>

<p>这将终止特定用户 (<code>-u</code> 参数) 启动的具有特定名称的进程。</p>
</li>
<li><p><strong><code>pstree</code> 命令</strong>：<code>pstree</code> 命令用于以树形结构显示系统上的进程，显示进程之间的父子关系，使您可以更好地了解进程之间的关联。</p>
<p>示例用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree</span><br></pre></td></tr></table></figure>

<p>这将显示整个进程树。</p>
</li>
<li><p><strong><code>fuser</code> 命令</strong>：<code>fuser</code> 命令用于查找正在使用特定文件或文件系统的进程。它可以帮助您找出哪个进程占用了文件或目录。</p>
<p>示例用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser -u filename</span><br></pre></td></tr></table></figure>

<p>这将列出正在使用指定文件的进程，并显示它们的用户名。</p>
</li>
<li><p><strong><code>peekfd</code> 命令</strong>：<code>peekfd</code> 命令用于查看进程的文件描述符。它可以用于监视进程的文件操作。</p>
<p>示例用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peekfd process_id</span><br></pre></td></tr></table></figure>

<p>这将显示指定进程的文件描述符信息。</p>
</li>
</ol>
<p><code>psmisc</code> 软件包提供了这些实用工具，可用于查找和管理进程，以及诊断与进程相关的问题。这些工具在系统管理员和开发人员之间广泛使用，用于处理进程管理任务。如果您需要执行进程管理操作或诊断进程相关问题，<code>psmisc</code> 软件包是一个有用的工具集。要在大多数 Linux 发行版中安装它，您可以使用包管理器，如 <code>apt</code>（Debian&#x2F;Ubuntu）或 <code>yum</code>（Red Hat&#x2F;CentOS）。</p>
<h2 id="常见的处理器架构"><a href="#常见的处理器架构" class="headerlink" title="常见的处理器架构"></a>常见的处理器架构</h2><p>计算机领域中有许多不同的处理器架构，每种都有其独特的特点和用途。以下是一些常见的处理器架构：</p>
<ol>
<li><p><strong>x86&#x2F;x86-64（Intel和AMD）：</strong> x86 架构是最常见的桌面和服务器处理器架构之一。x86-64 是其 64 位版本，也被称为 AMD64。它广泛用于个人计算机、工作站和服务器。</p>
</li>
<li><p><strong>ARM：</strong> ARM 架构是一种低功耗、高性能的处理器架构，广泛用于移动设备、嵌入式系统、物联网设备和一些服务器。它是许多智能手机和平板电脑的基础。</p>
</li>
<li><p><strong>PowerPC：</strong> PowerPC 架构最初由 IBM、Motorola 和苹果合作开发，用于 Macintosh 计算机。虽然在桌面领域的份额不大，但在嵌入式和服务器市场中仍有用武之地。</p>
</li>
<li><p><strong>SPARC（Scalable Processor Architecture）：</strong> SPARC 架构是由甲骨文公司开发的，用于高性能计算和企业级服务器。它具有强大的多线程能力。</p>
</li>
<li><p><strong>MIPS（Microprocessor without Interlocked Pipeline Stages）：</strong> MIPS 架构用于嵌入式系统、网络设备和某些路由器。它还曾用于一些游戏机，如索尼的 PlayStation。</p>
</li>
<li><p><strong>RISC-V：</strong> RISC-V 是一种开源的指令集架构，具有灵活性，广泛用于教育、嵌入式系统和一些自定义处理器的设计。</p>
</li>
<li><p><strong>Itanium（IA-64）：</strong> Itanium 架构是由英特尔和HP合作开发的，用于高性能计算和企业级服务器。然而，它在市场上的成功有限，已经逐渐被其他架构取代。</p>
</li>
<li><p><strong>Z系列（IBM System z）：</strong> Z 系列是 IBM 用于大型企业主机的处理器架构，用于处理高度事务性的应用程序。</p>
</li>
<li><p><strong>Alpha：</strong> Alpha 架构是由 DEC（Digital Equipment Corporation）开发的高性能 RISC 处理器架构，已经停止生产，但曾在科学计算和高性能计算中广泛使用。</p>
</li>
</ol>
<p>这只是一些常见的处理器架构，还有许多其他特定用途的架构和自定义架构，适用于各种不同的应用领域。不同的处理器架构适合不同的用途，选择取决于性能、功耗、成本和应用程序的需求。</p>
<h2 id="芯片架构-amd-x86-64-详解"><a href="#芯片架构-amd-x86-64-详解" class="headerlink" title="芯片架构 amd x86_64 详解"></a>芯片架构 amd x86_64 详解</h2><p>“AMD x86_64”，也称为”AMD64”或”x86-64”，是一种 64 位的 CPU 架构，由 AMD 公司于 2003 年首次引入。它是一种扩展的 x86 架构，用于替代传统的 32 位 x86 架构，以支持更大的内存寻址范围和更高的性能。以下是 AMD x86_64 架构的一些详细信息：</p>
<ol>
<li><p><strong>寻址范围：</strong> 最显著的优势是它可以寻址更大的内存范围。32 位系统的极限是约 4GB 内存，而 x86_64 架构可以支持数百 TB（1 TB &#x3D; 1024 GB）的内存，这使得它特别适用于大规模数据处理和高性能计算任务。</p>
</li>
<li><p><strong>寄存器：</strong> AMD x86_64 架构引入了更多的通用寄存器和 SIMD（单指令多数据）寄存器，这有助于提高并行计算性能。</p>
</li>
<li><p><strong>指令集：</strong> x86_64 架构是对传统 x86 指令集的扩展，增加了一些新的指令，以提高性能和支持更多的数据类型。它仍然能够运行 32 位的 x86 软件，通过一种称为“兼容模式”的方式。</p>
</li>
<li><p><strong>操作系统支持：</strong> 主流操作系统，包括 Windows、Linux 和 macOS，都支持 AMD x86_64 架构。这使得它成为通用计算平台的首选架构。</p>
</li>
<li><p><strong>性能：</strong> 64 位的处理能力和更多的寄存器通常导致更好的性能，特别是在处理大规模数据和复杂计算时。</p>
</li>
<li><p><strong>虚拟化：</strong> AMD x86_64 架构还增强了虚拟化支持，使得在一个物理主机上运行多个虚拟机成为可能。</p>
</li>
<li><p><strong>兼容性：</strong> 大多数现有的 32 位 x86 软件可以在 x86_64 系统上运行，通常通过一种称为“多架构支持”的方式，同时也能够运行专为 64 位系统编译的软件。</p>
</li>
</ol>
<p>总之，AMD x86_64 架构是一种高性能、高扩展性的架构，适用于各种计算任务，从桌面计算机到数据中心服务器。它已成为现代计算领域的标准之一，广泛用于各种计算场景。</p>
<h2 id="sha256码"><a href="#sha256码" class="headerlink" title="sha256码"></a>sha256码</h2><p>SHA-256（安全散列算法 256 位）是一种密码散列函数，用于将输入数据（消息）转换为 256 位（32 字节）的散列值。这个散列值通常以十六进制表示，由 64 个字符组成。SHA-256 是 SHA-2 家族中的一员，提供了高度的安全性和散列性能，广泛用于密码学、数字签名、数据完整性验证以及其他安全相关应用。</p>
<p>SHA-256 的主要特点包括：</p>
<ol>
<li><p><strong>不可逆性（One-way Function）</strong>：无法从散列值还原出原始输入数据。你可以计算散列值，但不能反向计算出输入数据。</p>
</li>
<li><p><strong>唯一性</strong>：不同的输入数据将产生不同的 SHA-256 散列值。即使输入数据仅有微小的改变，也会导致不同的散列值。</p>
</li>
<li><p><strong>固定长度</strong>：SHA-256 的输出始终是 256 位（32 字节）的散列值。</p>
</li>
<li><p><strong>抗碰撞（Collision Resistance）</strong>：在实际应用中，很难找到两个不同的输入数据产生相同的 SHA-256 散列值。</p>
</li>
</ol>
<p>SHA-256 在许多领域都有广泛的应用，包括密码学、数字签名、区块链、数据完整性验证、密码存储等。它被认为是目前非常安全的散列算法之一，因为攻击者需要耗费极大的计算资源才能破解或找到碰撞（相同散列值的两个不同输入数据）。</p>
<p>要计算数据的 SHA-256 散列值，你可以使用各种编程语言和工具库提供的函数或命令。例如，在 Linux 命令行中，你可以使用以下命令计算一个文件的 SHA-256 散列值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sha256sum</span> file_name</span><br></pre></td></tr></table></figure>

<p>其中 <code>file_name</code> 是要计算散列值的文件名。</p>
<p>请注意，SHA-256 散列值通常用于验证数据的完整性，而不是加密数据。要加密数据，通常需要使用加密算法而不是散列函数。</p>
<h2 id="dpkg-dev-详解"><a href="#dpkg-dev-详解" class="headerlink" title="dpkg-dev 详解"></a>dpkg-dev 详解</h2><p>在Ubuntu中，<code>dpkg-dev</code> 是一个软件包，提供了一些开发工具和功能，用于创建和管理 Debian 软件包。Debian 软件包是 Ubuntu 及其衍生版操作系统所使用的软件包格式。<code>dpkg-dev</code> 工具使得创建、构建和管理这些软件包变得更加容易和自动化。</p>
<p>以下是 <code>dpkg-dev</code> 的一些主要功能和用法的详细解释：</p>
<ol>
<li><p><strong>创建 Debian 软件包：</strong><br><code>dpkg-dev</code> 提供了 <code>dh_make</code> 工具，用于生成初始的 Debian 软件包模板。该工具可以根据源代码目录自动创建 <code>debian/</code> 目录和一些必要的文件，以便开始构建一个 Debian 软件包。</p>
</li>
<li><p><strong>构建 Debian 软件包：</strong><br>使用 <code>dpkg-buildpackage</code> 工具可以根据软件包的源代码和 <code>debian/</code> 目录中的控制文件，自动构建 Debian 软件包。该工具会编译源代码、创建二进制文件、打包文件和文档，并生成一个完整的 Debian 软件包。</p>
</li>
<li><p><strong>修改和更新软件包：</strong><br>在修改现有的 Debian 软件包时，<code>dpkg-dev</code> 工具提供了一些有用的工具和指南，以确保正确地进行修改并更新软件包的版本号、更新说明等信息。</p>
</li>
<li><p><strong>软件包信息和元数据：</strong><br><code>dpkg-dev</code> 包含一些工具来查看和检查软件包的信息和元数据。例如，<code>dpkg-deb</code> 工具可以用于查看软件包文件的详细信息，而 <code>dpkg-genchanges</code> 工具可以生成变更记录文件。</p>
</li>
<li><p><strong>生成软件包差异：</strong><br><code>dpkg-dev</code> 提供了 <code>dpkg-gencontrol</code> 和 <code>dpkg-genchanges</code> 等工具，用于生成二进制软件包和源代码软件包之间的差异文件，方便软件包的升级和维护。</p>
</li>
</ol>
<p>请注意，<code>dpkg-dev</code> 工具通常用于开发人员和软件打包者，而普通用户通常不需要直接使用这些工具。如果您只是想使用和安装 Debian 软件包，请使用 <code>apt</code> 命令，它是 Ubuntu 包管理器的前端，会自动处理软件包的下载、安装和依赖关系。</p>
<p>如果您对软件包的开发和打包有兴趣，可以参考 <code>dpkg-dev</code> 的文档和相关资源，了解更多详细信息和使用方法。</p>
<h2 id="ubuntu-ftp-服务器-详解"><a href="#ubuntu-ftp-服务器-详解" class="headerlink" title="ubuntu ftp 服务器 详解"></a>ubuntu ftp 服务器 详解</h2><p>在 Ubuntu 上设置 FTP 服务器通常可以使用 vsftpd（Very Secure FTP Daemon）。vsftpd 是一个非常流行的 FTP 服务器软件，它被设计为简单、安全且高效。以下是在 Ubuntu 上搭建 vsftpd FTP 服务器的详细步骤：</p>
<ol>
<li>安装 vsftpd：<br>打开终端，使用以下命令安装 vsftpd：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install vsftpd</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置 vsftpd：<br>安装完成后，您需要进行一些配置来设置 FTP 服务器的参数。主要的配置文件是 <code>/etc/vsftpd.conf</code>，您可以使用文本编辑器（如 nano 或 vim）来编辑该文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>

<p>在该文件中，您可以根据需要调整一些设置，例如：</p>
<ul>
<li><p>启用或禁用匿名访问：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=YES   <span class="comment"># 允许匿名访问</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=NO    <span class="comment"># 禁止匿名访问</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置本地用户访问：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local_enable=YES       <span class="comment"># 允许本地用户登录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置写权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write_enable=YES       <span class="comment"># 允许用户上传文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定用户根目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local_root=/home/ftp   <span class="comment"># 指定FTP用户的根目录</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>重新启动 vsftpd：<br>编辑配置文件后，保存并退出文本编辑器。然后，重新启动 vsftpd 以应用新的配置：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart vsftpd</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>防火墙设置：<br>如果您的系统上启用了防火墙（如 ufw），需要允许 FTP 的数据传输端口（默认为 20 和 21 端口）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 20/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 21/tcp</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>添加 FTP 用户（可选）：<br>如果您希望用户可以访问 FTP 服务器并上传文件，您需要在系统上创建相应的本地用户。您可以使用以下命令创建新用户并设置密码：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> adduser ftpuser  <span class="comment"># 创建名为 &quot;ftpuser&quot; 的用户</span></span><br><span class="line"><span class="built_in">sudo</span> passwd ftpuser   <span class="comment"># 设置 &quot;ftpuser&quot; 用户的密码</span></span><br></pre></td></tr></table></figure>

<p>现在，您的 Ubuntu 系统上已经成功安装和配置了 vsftpd FTP 服务器。用户可以使用 FTP 客户端连接到您的服务器，上传和下载文件。请注意，为了保障数据传输的安全，建议使用 SFTP（SSH File Transfer Protocol）或 FTPS（FTP Secure，基于 TLS&#x2F;SSL 加密）等加密的方式进行传输。</p>
<h2 id="linux-可用交换内存-与实际空闲内存-区别-详解"><a href="#linux-可用交换内存-与实际空闲内存-区别-详解" class="headerlink" title="linux 可用交换内存 与实际空闲内存 区别 详解"></a>linux 可用交换内存 与实际空闲内存 区别 详解</h2><p>在Linux系统中，有两种类型的内存可用性，分别是可用交换内存（Swap）和实际空闲内存（Free Memory）。这两者的区别如下：</p>
<ol>
<li><p>可用交换内存（Swap）：<br>可用交换内存是指交换空间（Swap Space）中未被使用的内存。交换空间是指硬盘上专门用于作为虚拟内存的一部分。当系统的物理内存（RAM）不足时，Linux系统会将一部分不常用的内存页面转移到交换空间，以释放物理内存给正在运行的进程使用。这个过程称为交换（Swap）。</p>
<p>交换空间的设置对于系统性能是有益的，因为它可以避免系统的物理内存耗尽，从而防止系统崩溃或应用程序因为内存不足而崩溃。然而，当系统频繁进行交换时，会导致性能下降，因为硬盘速度远慢于内存访问速度。</p>
<p>在Linux系统中，你可以使用<code>free</code>命令查看交换内存的情况，其中的<code>Swap</code>列显示的就是可用交换内存。</p>
</li>
<li><p>实际空闲内存（Free Memory）：<br>实际空闲内存是指当前未被任何进程使用的物理内存。它是系统中真正空闲可用的内存，可以用于立即分配给新的进程或者已经运行的进程的内存需求。实际空闲内存直接影响着系统的性能，因为足够的空闲内存可以保证系统响应速度和运行稳定性。</p>
<p>同样，你可以使用<code>free</code>命令查看实际空闲内存，其中的<code>free</code>列显示的是实际空闲内存的大小。</p>
</li>
</ol>
<p>需要注意的是，虽然可用交换内存（Swap）可以提供一种缓解内存不足的方式，但它并不能完全替代实际的物理内存。当系统过度依赖交换空间来弥补物理内存的不足时，会导致系统性能下降，因为交换到硬盘的数据访问速度较慢。因此，对于性能敏感的应用和系统，建议增加物理内存以避免频繁的交换行为。</p>
<h2 id="debian-NetworkManager-详解"><a href="#debian-NetworkManager-详解" class="headerlink" title="debian NetworkManager 详解"></a>debian NetworkManager 详解</h2><p>NetworkManager 是一个用于在 Linux 系统上管理网络连接的服务和工具集。它是一个常见的网络管理器，广泛用于各种 Linux 发行版中，包括 Debian。</p>
<p>下面是关于 NetworkManager 在 Debian 上的一些详细说明：</p>
<ol>
<li><p>功能：NetworkManager 提供了一种集中管理网络连接的方式，包括有线连接、Wi-Fi 连接、移动数据连接等。它可以自动检测和配置网络设备，管理 IP 地址、DNS 设置、路由表等网络参数，以及处理连接的自动连接、断开和重连。</p>
</li>
<li><p>配置文件：NetworkManager 的配置文件通常位于 <code>/etc/NetworkManager/</code> 目录下。其中，<code>/etc/NetworkManager/NetworkManager.conf</code> 是主要的配置文件，定义了全局配置选项。此外，每个用户的网络连接配置存储在 <code>/etc/NetworkManager/system-connections/</code> 目录下。</p>
</li>
<li><p>命令行工具：Debian 提供了一组命令行工具用于管理 NetworkManager。其中，<code>nmcli</code> 是一个强大的命令行界面工具，用于配置和管理网络连接。你可以使用 <code>nmcli</code> 查看连接状态、添加、编辑或删除网络连接配置，以及执行其他与网络管理相关的操作。</p>
</li>
<li><p>图形界面：Debian 也提供了各种图形界面工具来管理 NetworkManager。其中，<code>nm-applet</code> 是 NetworkManager 的系统托盘应用程序，提供了一个简单的界面来查看和管理网络连接。此外，许多桌面环境（如 GNOME、KDE 等）也提供自己的网络管理工具，可以与 NetworkManager 集成。</p>
</li>
<li><p>集成和兼容性：NetworkManager 与许多网络设备和协议兼容，并能与各种网络服务和工具集成。它支持以太网、Wi-Fi、移动数据（3G&#x2F;4G）等多种连接类型，并与 DHCP、DNS、VPN、PPPoE 等网络服务协议配合工作。</p>
</li>
</ol>
<p>总体而言，NetworkManager 提供了一种方便和灵活的方式来管理网络连接，在 Debian 系统中被广泛使用。它通过命令行工具和图形界面工具提供了多种管理选项，可适应各种网络环境和需求。</p>
<p>要深入了解 NetworkManager 的使用和配置，请参考 Debian 官方文档和 NetworkManager 的官方文档，以获得更详细和准确的信息。</p>
<h2 id="dummy-output"><a href="#dummy-output" class="headerlink" title="dummy output"></a>dummy output</h2><p>“dummy output” 是一个常见的术语，用于描述一个没有实际输出或功能的占位符或虚拟输出。</p>
<p>在计算机领域中，”dummy output” 通常用于表示一个虚拟的输出设备或占位符，它不会实际产生任何输出，或者仅仅是为了满足某些需求而存在。这种虚拟输出通常用于测试、模拟或占位的目的。</p>
<p>例如，在音频设备的设置中，你可能会看到一个名为 “dummy output” 的选项。这个选项表示一个虚拟的输出设备，用于模拟音频输出，而不是实际连接到物理设备。它可以用于测试音频设置或在没有物理音频设备的情况下进行音频处理。</p>
<p>类似地，在软件开发中，”dummy output” 也可以指代一个占位符或虚拟的输出对象。它可能是一个空函数、空类或其他形式的占位符，用于满足代码结构或接口的要求，但没有实际的功能或输出。</p>
<p>总的来说，”dummy output” 表示一个没有实际输出或功能的占位符或虚拟输出，通常用于测试、模拟或占位的目的。</p>
<hr>
<h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p><code>systemd</code> 是用于管理Linux系统的初始化进程和服务管理器。它是最新的系统初始化方案，用于代替传统的 <code>init</code> 系统。<code>systemd</code> 提供了一套功能丰富的命令行工具，用于管理系统服务、单元（units）、日志和其他系统资源。</p>
<p>下面是一些常用的 <code>systemd</code> 命令及其简要说明：</p>
<ol>
<li><p><code>systemctl</code>：<code>systemctl</code> 命令用于管理系统服务，包括启动、停止、重启、启用、禁用等操作。例如：</p>
<ul>
<li>启动服务：<code>systemctl start service-name</code></li>
<li>停止服务：<code>systemctl stop service-name</code></li>
<li>重启服务：<code>systemctl restart service-name</code></li>
<li>启用服务：<code>systemctl enable service-name</code></li>
<li>禁用服务：<code>systemctl disable service-name</code></li>
</ul>
</li>
<li><p><code>journalctl</code>：<code>journalctl</code> 命令用于查看系统日志，可以显示 <code>systemd</code> 单元的日志、内核消息等。例如：</p>
<ul>
<li>查看所有日志：<code>journalctl</code></li>
<li>查看特定服务的日志：<code>journalctl -u service-name</code></li>
<li>根据时间范围过滤日志：<code>journalctl --since &quot;2022-01-01&quot; --until &quot;2022-01-02&quot;</code></li>
</ul>
</li>
<li><p><code>systemd-analyze</code>：<code>systemd-analyze</code> 命令用于分析系统启动时间和性能。例如：</p>
<ul>
<li>显示启动时间：<code>systemd-analyze</code></li>
<li>显示关键路径：<code>systemd-analyze critical-chain</code></li>
<li>显示各个服务的启动时间：<code>systemd-analyze blame</code></li>
</ul>
</li>
<li><p><code>systemd-resolve</code>：<code>systemd-resolve</code> 命令用于管理系统的网络解析器和 DNS 配置。例如：</p>
<ul>
<li>查看 DNS 服务器：<code>systemd-resolve --status</code></li>
<li>清除 DNS 缓存：<code>systemd-resolve --flush-caches</code></li>
</ul>
</li>
</ol>
<p>这只是 <code>systemd</code> 提供的一小部分命令，它还具有许多其他功能和选项，可用于管理系统的各个方面。您可以通过查阅 <code>systemd</code> 的官方文档或运行 <code>man</code> 命令来获取更详细的信息，例如 <code>man systemctl</code>、<code>man journalctl</code> 等。</p>
<hr>
<h2 id="压缩与解压"><a href="#压缩与解压" class="headerlink" title="压缩与解压"></a>压缩与解压</h2><ul>
<li>将文件压缩不只是为了节省硬盘空间,同时也可以节省网络传输时间,归档文件方便管理等</li>
<li>压缩可分为无损压缩与有损压缩两种,但不管是采用何种技术模型,其本质内容都是一样的,即** 通过某种特殊的编码方式将数据信息中存在的重复度,冗余度有效地降低,从而达到数据压缩的目的** </li>
<li>在Linux中很多压缩程序只能针对一个文件进行压缩,当要压缩一大堆文件时,首先得先将一堆文件打成一个包(tar命令),然后再用压缩程序进行压缩(gzip, bzip2命令),就是说压缩会分为两步:先打包再压缩</li>
<li>打包,tar命令可以将多个文件和目录创建一个档案(归档),tar最初是用来在磁带上创建档案;tar命令也可以修改档案中的文件,或者加入新的文件;使用tar程序打出来的包常称为tar包,tar包通常以<code>.tar</code>结尾</li>
<li>归档的一般用途:<ul>
<li>把一大堆的文件和目录打包成一个tar包,便于网络传输</li>
<li>生成tar包后,再用其他的程序进行压缩</li>
</ul>
</li>
<li>压缩<ul>
<li>gzip,是GNUzip的缩写,它是一个GNU自由软件的文件压缩程序,文件经过它压缩以后以<code>.gz</code>为扩展名.</li>
<li>gzip不能用来压缩目录,需要先归档目录,然后再压缩,gzip和tar一起构成了Linux操作系统中流行的文件压缩格式(<code>.tar.gz</code>)</li>
</ul>
</li>
</ul>
<h2 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h2><ul>
<li>“一切皆文件”是Unix&#x2F;Linux的基本哲学之一,它是指Linux系统中的所有的一切都可以通过文件的方式访问和管理,即使不是文件,也以文件的形式来管理.例如硬件设备,进程,套接字等都抽象成文件,使用统一的用户接口,虽然文件类型各不相同,但是对其提供的却是同一套操作</li>
<li>这里的一切都是单项的,也即所有的东西都单向通过文件系统呈现,反向不一定可行.例如:通过新建文件的方式来创建磁盘设备是行不通的</li>
<li>在Linux中共有7种类型的文件,分为3大类:<ul>
<li><code>-</code> : 普通文件,包括文本文件和二进制文件</li>
<li><code>d</code> : 目录文件(文件夹文件)</li>
<li>特殊文件<ul>
<li><code>l</code> : 链接文件</li>
<li><code>c</code> : 字符设备文件</li>
<li><code>s</code> : 套接字(Socket)文件,用于网络通讯,一般由应用程序创建</li>
<li><code>p</code> : 命名管道文件</li>
<li><code>b</code> : 块文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Linux文件基本属性"><a href="#Linux文件基本属性" class="headerlink" title="Linux文件基本属性"></a>Linux文件基本属性</h2><ul>
<li><p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等</p>
<ul>
<li>当为 <code>d</code> 则是目录</li>
<li>当为 <code>-</code> 则是文件</li>
<li>若是 <code>l</code> 则表示为链接文档(link file)</li>
<li>若是 <code>b</code> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)</li>
<li>若是 <code>c</code> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)</li>
</ul>
</li>
<li><p>接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)</p>
</li>
<li><p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已</p>
</li>
<li><p>每个文件的属性由左边第一部分的 10 个字符来确定</p>
</li>
<li><p>从左至右用 0-9 这些数字来表示</p>
<ul>
<li>第 0 位确定文件类型，</li>
<li>第 1-3 位确定属主（该文件的所有者）拥有该文件的权限</li>
<li>第 4-6 位确定属组（所有者的同组用户）拥有该文件的权限</li>
<li>第 7-9 位确定其他用户拥有该文件的权限</li>
</ul>
</li>
<li><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户</p>
</li>
<li><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组</p>
</li>
<li><p>文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户</p>
</li>
<li><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限</p>
</li>
<li><p>Linux文件属性有两种设置方法，一种是数字，一种是符号</p>
</li>
<li><p>Linux 文件的基本权限就有九个，分别是 owner&#x2F;group&#x2F;others(拥有者&#x2F;组&#x2F;其他) 三种身份各有自己的 read&#x2F;write&#x2F;execute 权限</p>
</li>
<li><p>文件的权限字符为： -rwxrwxrwx ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限</p>
<ul>
<li>r  –  4</li>
<li>w  –  2</li>
<li>x  –  1</li>
</ul>
</li>
<li><p>每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为： -rwxrwx— 分数则是</p>
<ul>
<li>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</li>
</ul>
</li>
</ul>
<h2 id="inode索引节点"><a href="#inode索引节点" class="headerlink" title="inode索引节点"></a>inode索引节点</h2><ul>
<li><p><code>inode</code> 是理解<code>Unix/Linux</code>文件系统和硬盘存储的基础</p>
</li>
<li><p>理解<code>inode</code>,不仅有助于提高系统操作水平,还有助于体会Unix设计哲学,即如何把底层的复杂性抽象成一个简单概念,从而大大简化用户接口</p>
</li>
<li><p><code>inode</code>是什么?</p>
<ul>
<li>理解<code>inode</code>,要从文件存储说起 – 文件储存在硬盘上,硬盘的最小存储单位叫做<strong>扇区(<code>Sector</code>)</strong> ,每个扇区储存<code>512</code>字节(相当于<code>0.5KB</code>)</li>
<li>操作系统读取硬盘的时候,不会一个扇区一个扇区地读取,这样效率太低.而是<strong>一次性连续读取多个扇区,即一次性读取一个块(<code>block</code>)</strong>,这种由多个扇区组成的<strong>块</strong> ,是文件存取的最小单位.<strong>块</strong> 的大小通常是<code>4KB</code>,即连续八个扇区(<code>sector</code>)组成一个块(<code>block</code>)</li>
<li>文件数据都存储在块中,那么还需要一个地方储存文件的<strong>元信息</strong> ,比如文件的创建者,文件的创建日期,文件的大小等.<strong>这种储存文件元信息的区域就叫做<code>inode</code></strong> ,中文译名为<strong>索引节点</strong> </li>
<li>每一个文件都有对应的inode,里面包含了与该文件有关的信息</li>
</ul>
</li>
<li><p><code>inode</code>的内容:</p>
<ul>
<li><code>inode</code>包含文件的元信息,具体来说有:<ul>
<li>文件的字节数</li>
<li>文件拥有者的<code>User ID</code></li>
<li>文件用户组的<code>Group ID</code></li>
<li>文件的读,写,执行权限</li>
<li>文件的时间戳,共有三个<ul>
<li><code>ctime</code>,指inode上一次变动的时间</li>
<li><code>mtime</code>,指文件内容上一次变动的时间</li>
<li><code>atime</code>,指文件上一次打开的时间</li>
</ul>
</li>
<li>链接数,即有多少文件名指向这个<code>inode</code></li>
<li>文件数据<code>block</code>的位置</li>
</ul>
</li>
<li>可以使用<code>stat</code>命令,查看某个文件的inode信息</li>
</ul>
</li>
<li><p><code>inode</code>的大小</p>
<ul>
<li><code>inode</code>也会消耗硬盘空间,所以在格式化硬盘的时候,操作系统自动将硬盘分成两个区域,一个是数据区,存放文件数据;另一个是<code>inode</code>区(<code>inode table</code>),存放<code>inode</code>所包含的信息</li>
<li><code>inode</code>节点一般占用<code>128</code>字节或<code>256</code>字节.<code>inode</code>节点的总数,在格式化时会自动设定.一般是每<code>1KB</code>或每<code>2KB</code>就设置一个<code>inode</code></li>
</ul>
</li>
<li><p>inode号码</p>
<ul>
<li>每个<code>inode</code>都有一个号码,操作系统用<code>inode</code>号码来识别不同的文件.</li>
<li><strong><code>Unix/Linux</code>系统内部不使用文件名,而是使用<code>inode</code>号码来识别文件</strong>.对于系统来说,文件名只是inode号码便于识别的别称或者绰号.</li>
<li>表面上,用户通过文件名打开文件.实际上,系统内部将这个过程分为三步:<ul>
<li>系统找到文件名对应的<code>inode</code>号码</li>
<li>通过<code>inode</code>号码,获取<code>inode</code>信息</li>
<li>根据<code>inode</code>信息,找到文件数据所在的<code>block</code>,读出数据</li>
</ul>
</li>
<li>通过命令<code>ls -i filename</code>查看文件名对应的inode号码</li>
</ul>
</li>
<li><p>目录文件</p>
<ul>
<li><code>Unix/Linux</code>系统中,目录(<code>directory</code>)也是一种文件.打开目录,实际上就是打开目录文件</li>
<li>目录文件的结构非常简单,就是一系列目录项(<code>dirent</code>)的列表.每个目录项由两个部分组成:所包含文件的文件名,以及该文件名对应的<code>inode</code>号码</li>
<li><strong>所以在使用<code>ls -lh</code>命令查看文件夹大小时,所有的文件夹只有<code>4KB</code>大小</strong></li>
</ul>
</li>
<li><p><code>inode</code>的特殊作用</p>
<ul>
<li>由于<code>inode</code>号码与文件名分离,这种机制导致了一些<code>Unix/Linux</code>系统特有的现象</li>
<li>当文件名包含特殊字符,无法正常删除时,可以删除<code>inode</code>节点,就能直接删除文件</li>
<li>移动文件或重命名文件,只是改变文件名,不影响<code>inode</code>号码,所以在<code>Linux</code>中移动文件不论大小基本秒成</li>
<li>打开一个文件后,系统就以<code>inode</code>号码来识别文件,不再考虑文件名.因此,系统无法从<code>inode</code>号码得知文件名.</li>
</ul>
</li>
</ul>
<h2 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h2><ul>
<li>在Linux中有两种link(链接)的概念,一般称之为硬链接和软链接(或符号链接)</li>
<li>硬链接<ul>
<li>一般情况下,文件名和inode号码是”一一对应”的关系,每个inode号码对应一个文件名(每个文件默认有一个硬链接).但是Unix&#x2F;Linux系统允许多个文件名指向同一个inode号码</li>
<li>这意味着,可以用不同的文件名访问同样的内容,对文件内容进行修改后,会影响所有文件名.但是,删除一个文件名,不影响另一个文件名的访问,这种情况就被称为”硬链接(hard link)”</li>
<li>创建一个硬链接,就会为文件创建了一个新的文件名.硬链接有两个重要局限性:<ul>
<li>硬链接不能链接不在同一系统的文件,也就是说硬链接不能链接与文件不在同一磁盘分区上的文件;</li>
<li>硬链接不能链接目录</li>
</ul>
</li>
<li>一个硬链接和文件本身没有什么区别.当列出一个包含硬链接的文件时,不会有特殊的链接指示说明.当一个硬链接被删除时,文件本身的内容仍然存在(也就是说,它所占用的磁盘空间不会被重新分配),直到所有关联这个文件的硬链接都删掉.</li>
</ul>
</li>
<li>软链接:<ul>
<li>创建软链接是为了克服硬链接的局限性</li>
<li>软链接是通过创建一个特殊类型的文件(指针)链接到文件或目录,就像windows的快捷方式</li>
<li>文件A和文件B的inode号码虽然不一样,但是文件A的内容是文件B的路径.读取文件A时,系统会自动将访问指向文件B.因此,无论打开哪一个文件,最终读取的都是文件B,但是,文件A依赖于文件B而存在,如果删除了文件B,打开文件A就会报错:”No such file or directory”</li>
<li>软链接与硬链接最大的不同:文件A指向文件B的文件名,而不是文件B的inode号码</li>
</ul>
</li>
</ul>
<h2 id="安全模型与权限"><a href="#安全模型与权限" class="headerlink" title="安全模型与权限"></a>安全模型与权限</h2><ul>
<li>在linux系统中,所有的操作实质上都是在进行进程访问文件的操作.在访问文件之前需要取得相应的权限,而权限是通过Linux系统中的安全模型获得的.理论上进程所拥有的权限与执行它的用户的权限相同.其中涉及的一切内容,都是围绕这个核心进行的.</li>
<li>Linux系统中的安全模型,有两种类型:<ul>
<li>Linux系统上最初的安全模型称为** 自主访问控制(DAC, Discretionary Access Control)** </li>
<li>后来又增加设计了一个新的安全模型叫** 强制访问控制(MAC, Mandatory Access Control)** </li>
<li>MAC和DAC不是互斥的,DAC是最基本的安全模型,也是最常用的访问控制机制,是Linux必须具有的功能;而MAC是构建在DAC智商的加强安全机制,属于可选模块</li>
</ul>
</li>
<li>文件权限控制<ul>
<li>对文件的权限分三组进行控制:<ul>
<li><code>user</code>对文件属主设定的权限</li>
<li><code>group</code>对文件属组设定的权限</li>
<li><code>othre</code>对其他者设定的权限</li>
</ul>
</li>
<li>常用的可设定的权限值,包括:<ul>
<li><code>r</code> : 读权限</li>
<li><code>w</code> : 写权限</li>
<li><code>x</code> : 执行权限</li>
<li><code>s</code> : 强制位权限</li>
<li><code>t</code> : 粘滞位权限</li>
<li><code>i</code> : 不可修改权限</li>
<li><code>a</code> : 只追加权限</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><ul>
<li><code>netstat  -a  # 列出所有端口</code></li>
<li><code>netstat -at  # 列出所有tcp端口</code></li>
<li><code>netstat -au  # 列出所有udp端口</code></li>
<li><code>netstat -l   # 只显示监听端口</code></li>
<li><code>netstat -lt  # 只列出所有监听tcp端口</code></li>
<li><code>netstat -lu  # 只列出所有监听udp端口</code></li>
</ul>
<h3 id="查看指定端口"><a href="#查看指定端口" class="headerlink" title="查看指定端口"></a>查看指定端口</h3><ul>
<li><code>sudo netstat -tlnp | grep 8083</code></li>
<li><code>sudo lsof -i:8083</code></li>
</ul>
<h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><ul>
<li>apt install lsof</li>
</ul>
<h2 id="终端-控制台和shell的区别"><a href="#终端-控制台和shell的区别" class="headerlink" title="终端,控制台和shell的区别"></a>终端,控制台和shell的区别</h2><ul>
<li>终端(terminal)</li>
<li>控制台(console)<ul>
<li>控制台是计算机的基本设备,而终端是附加设备</li>
</ul>
</li>
<li>Shell俗称壳(用来区别于核)<ul>
<li>软件shell,俗称壳,是读取并解释命令的程序.</li>
<li>Shell是一个用C语言编写的程序,它是用户使用Linux的桥梁,用户通过Shell访问操作系统内核的服务</li>
</ul>
</li>
</ul>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><ul>
<li>启动<code>mysql</code><ul>
<li>使用<code>service</code>启动: <code>service mysql start</code></li>
</ul>
</li>
</ul>
<h2 id="Linux系统启动过程"><a href="#Linux系统启动过程" class="headerlink" title="Linux系统启动过程"></a>Linux系统启动过程</h2><ul>
<li>Linux系统的启动过程可以分为五个阶段:<ul>
<li>内核的引导<ul>
<li>当计算机打开电源后,首先是<code>BIOS</code>开机自检,按照<code>BIOS</code>中设置的启动设备(通常是硬盘)来启动.</li>
<li>操作系统接管硬件以后,首先读入<code>/boot</code>目录下的内核文件</li>
</ul>
</li>
<li>运行init<ul>
<li>(init程序的类型)<ul>
<li>SysV:init</li>
<li>Upstart:init</li>
<li>Systemd:systemd</li>
</ul>
</li>
<li><code>init</code>进程是系统所有进程的起点,可以把它比作系统所有进程的老祖宗,没有这个进程,系统中任何进程都不会启动.</li>
</ul>
</li>
<li>系统初始化</li>
<li>建立终端</li>
<li>用户登录系统</li>
</ul>
</li>
</ul>
<h2 id="Linux下RTC时间：系统时间与RTC实时时钟时间"><a href="#Linux下RTC时间：系统时间与RTC实时时钟时间" class="headerlink" title="Linux下RTC时间：系统时间与RTC实时时钟时间"></a>Linux下RTC时间：系统时间与RTC实时时钟时间</h2><ul>
<li>Linux系统下包含两个时间：<strong>系统时间</strong> 和 <strong>RTC时间</strong><ul>
<li>系统时间：是由主芯片的定时器进行维护的时间，一般情况下都会选择芯片上最高精度的定时器作为系统时间的定时基准，以避免在系统运行较长时间后出现大的时间偏移。特点是掉电后不保存</li>
<li>RTC时间：是指系统中包含的RTC芯片内部所维护的时间。RTC芯片都有电池+系统电源的双重供电机制，在系统正常工作时由系统供电，在系统掉电后由电池进行供电。因此系统电源掉电后RTC时间仍然能够正常运行</li>
</ul>
</li>
<li>每次Linux系统启动后在启动过程中会检测和挂在RTC驱动，在挂在后会自动从RTC芯片中读取时间并设置到系统时间中去。此后如果没有显式的通过命令去控制RTC的读写操作，系统将不会再从RTC中获取或者同步设置时间</li>
<li>Linux命令中<code>date</code>和<code>time</code>等命令都是用来设置系统时间的；而<code>hwclock</code>命令是用来设置和读写RTC时间的</li>
</ul>
<h2 id="文件系统标识"><a href="#文件系统标识" class="headerlink" title="文件系统标识"></a>文件系统标识</h2><ul>
<li><p>在<code>/etc/fstab</code>配置文件中你可以以三种不同的方法表示文件系统：内核名称，UUID或者label。</p>
</li>
<li><p>使用UUID或者是label的好处再与它们与磁盘顺序无关。</p>
</li>
<li><p>如果你在BIOS中改变了你的存储设备顺序，或者是重新拔插了存储设备，或是因为一些BIOS可能会随即地改变存储设备的顺序，那么用UUID或者是label来表示将更有效</p>
</li>
<li><p>显示分区的基本信息：<code>lsblk -f</code></p>
</li>
<li><p>内核名称：<code>fdisk -l</code> 来获得内核名称，前缀是<code>dev</code></p>
</li>
<li><p><code>UUID</code>：所有分区和设备都有唯一的UUID。<strong>它们由文件系统生成工具<code>(mkfs.*)</code>在创建文件系统时生成。</strong></p>
</li>
<li><p>路径名有空格，可以使用<code>\040</code>转义字符来表示空格（以三位八进制数来进行表示）</p>
<ul>
<li><code>UUID=47FA-4071 /home/username/Camera\040Pictures vfat defaults, noatime 0 2</code></li>
</ul>
</li>
<li><p><code>tmpfs</code></p>
<ul>
<li><code>tmpfs</code>是一个临时文件系统，驻留于你的交换分区或者是内存中（取决于你的使用情况）。使用它可以提高文件访问速度，并能够保证重启时会自动清除这些文件</li>
<li>经常使用<code>tmpfs</code>的目录有<code>/tmp, /var/lock, /var/run</code>。不要把tmpfs使用于<code>/var/tmp</code>，因为这一个目录中的临时文件在重启过程中需要被保留。</li>
<li>默认情况下，tmpfs分区被和设置为总的内存的一半，当然可以自由设定</li>
</ul>
</li>
</ul>
<h2 id="POSIX-API"><a href="#POSIX-API" class="headerlink" title="POSIX API"></a>POSIX API</h2><ul>
<li><p>POSIX，全称为<strong>可移植性操作系统接口</strong>，是一种关于信息技术的IEEE标准。它包括了系统应用程序的接口（API），以及实时扩展（C语言）</p>
</li>
<li><p>该标准的目的是定义了标准的基于UNIX操作系统的系统接口和环境来支持源代码级的可移植性。现在，标准主要提供了依赖C语言的一系列标准服务，在将来的版本中，标准将致力于提供基于不同语言的规范。</p>
</li>
<li><p>该标准对核心需求部分定义了一系列任何编程语言都通用的服务，这一部分服务主要从其功能需求方面阐述，而非定义依赖于编程语言的接口。</p>
</li>
<li><p>语言规范主要由两部分组成</p>
<ul>
<li>一部分包括了访问核心服务的编程语言的标准接口，这些核心服务为标准中基于编程语言的核心需求部分所定义</li>
<li>另一部分包含了一个特殊语言服务的标准接口。</li>
</ul>
</li>
<li><p>该标准一共被分为四个部分：</p>
<ul>
<li>陈述的范围和一系列标准参考</li>
<li>定义和总概念</li>
<li>各种接口设备</li>
<li>头文件</li>
</ul>
</li>
</ul>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><ul>
<li><p>挂载目录:</p>
<ul>
<li>工具:nfs, sshfs,</li>
</ul>
</li>
<li><p>挂载(mount):</p>
<ul>
<li>“挂载”发生在计算机想要使用任何类型的存储设备(如硬盘,CD-ROM,网络设备)之前,操作系统必须讲这个设备纳入自己的文件系统中</li>
</ul>
</li>
<li><p><code>mount -t type device dir</code> </p>
<ul>
<li>挂载操作,实际上是把设备(device)中的文件系统附加到dir上,可以通过访问dic来访问这个设备</li>
<li>其本质就是针对某一设备,分析出其文件系统结构,并根据其文件系统类型调用linux中相应的驱动,处理该设备的元数据,将这些信息附加到linux的目录树上,并呈现出来.</li>
</ul>
</li>
</ul>
<h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><ul>
<li><p>内网，就是在公司或者家庭内部，建立的一种局域网络或者是办公网络，从而实现多台电脑之间可以进行资源的共享，包括设备，资料，数据等。而外网则是由一个网关与其他的网络系统连接，相对于内网而言，这种网络称之为外部网络，也就是我们经常说到的互联网。</p>
</li>
<li><p>内网穿透，是我们在进行网络连接时的一种术语，也叫做NAT穿透，即在计算机是局域网内的时候，外网与内网的计算机的节点进行连接时所需要的连接通信，有时候就会出现内网穿透不支的情况。</p>
</li>
<li><p>内网穿透的功能就是，当我们在端口映射时设置时，内网穿透起到了地址转换的功能，也就是把公网的地址进行翻译，转成一种私有的地址，然后再采用路由的方式ADSL的宽带路由器，具有一个动态或者是固定的公网IP，最后ADSL直接在交换机上，这样所有的电脑都可以共享上网。内网穿透除了可以实现内网之间机器的网络通信功能之外，还可以解决UDP中出现的数据传输不稳定的问题</p>
</li>
<li><p>内网穿透可以通过开放的第三方端口来实现，可以安装一个NAT123端口内网穿透软件，然后再添加映射，并且配置出映射端口的信息，外网的地址是映射之后访问的域名，同时也可以是自己或者默认的域名，通过内网穿透，可以用域名进行对应的内网应用。如果是外网地址使用的是自己的域名，可以把域名的解析只想提示目标地址来使用。</p>
</li>
<li><p>简单来说，内网穿透就是在我们没有公网IP的时候，也可以通过内网穿透服务器的转发，在任何互联网（广域网）连接内网的设备。</p>
</li>
<li><p>推荐工具：Zero Tier , frp, <strong>socat命令</strong></p>
</li>
<li><p><code>ngrok</code>:</p>
<ul>
<li><code>ngrok config add-authtoken 2Fyd9ZRXPYDbBNIZQRXAPd036Un_cCTH2CsrmttkSzKE1ind</code></li>
<li><code>ngrok tcp 22 </code></li>
<li><code>ssh user@0.tcp.jp.ngrok.io -p 11111</code></li>
</ul>
</li>
</ul>
<h2 id="ubuntu18-显卡配置"><a href="#ubuntu18-显卡配置" class="headerlink" title="ubuntu18 显卡配置"></a>ubuntu18 显卡配置</h2><ol>
<li>查看显卡设备和显卡驱动 –&gt; <code>ubuntu-drivers devices</code></li>
<li>自动安装合适的显卡     –&gt; <code>sudo ubuntu-drivers autoinstall</code></li>
<li>重启系统</li>
</ol>
<h2 id="开机启动服务-脚本"><a href="#开机启动服务-脚本" class="headerlink" title="开机启动服务&#x2F;脚本"></a>开机启动服务&#x2F;脚本</h2><ul>
<li><p>系统启动时需要加载的配置文件</p>
<ul>
<li>&#x2F;etc&#x2F;profile</li>
<li>&#x2F;root&#x2F;.bash_profile</li>
<li>&#x2F;etc&#x2F;bashrc</li>
<li>&#x2F;root&#x2F;.bashrc</li>
<li>&#x2F;etc&#x2F;profile.d&#x2F;*.sh</li>
<li>&#x2F;etc&#x2F;sysconfig&#x2F;</li>
<li>&#x2F;etc&#x2F;rc.local</li>
</ul>
</li>
<li><p>自定义服务文件，添加到系统服务，通过<code>Systemctl</code>管理</p>
<ul>
<li>写服务文件，例如nginx.service, redis.service, supervisord.service<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]      --  服务说明</span><br><span class="line">Description --  描述服务</span><br><span class="line">After       --  描述服务类别</span><br><span class="line"></span><br><span class="line">[Service]    -- 服务运行参数的设置</span><br><span class="line">Type=forking -- 为后台运行的形式</span><br><span class="line">ExecStart    -- 为服务的具体运行命令</span><br><span class="line">ExecReload   -- 为服务的重启命令</span><br><span class="line">ExecStop     -- 为服务的停止命令</span><br><span class="line">PrivateTmp=True  -- 表示给服务分配独立的临时空间</span><br><span class="line">注意：启动，重启，停止命令全部要求使用绝对路径</span><br><span class="line"></span><br><span class="line">[Install]    --  服务安装的相关设置，可设置为多用户</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>文件保存在<code>/usr/lib/systemd/system/</code>路径下，权限为<code>754</code></p>
</li>
<li><p>设置开机自动启动</p>
<ul>
<li><code>systemctl enable nginx.service</code></li>
</ul>
</li>
<li><p>停止开机自启动</p>
<ul>
<li><code>systemctl disable nginx.service</code></li>
</ul>
</li>
<li><p>验证是否为开机自启动</p>
<ul>
<li><code>systemctl is-enabled nginx</code></li>
</ul>
</li>
<li><p>查看所有已经启动的服务</p>
<ul>
<li><code>systemctl list-units --type=service</code></li>
</ul>
</li>
</ul>
<h1 id="什么是socks"><a href="#什么是socks" class="headerlink" title="什么是socks"></a>什么是socks</h1><ul>
<li>socks是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是SOCKets的缩写</li>
<li>当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格。允许的话，就将客户端的请求发往外部的服务器。这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到版本4。最新协议是版本5，与前一版相比，增加支持UDP，验证以及IPv6</li>
</ul>
<h2 id="共享目录"><a href="#共享目录" class="headerlink" title="共享目录"></a>共享目录</h2><h3 id="linux之间建立共享目录"><a href="#linux之间建立共享目录" class="headerlink" title="linux之间建立共享目录"></a>linux之间建立共享目录</h3><p>如何使A服务器的某个目录挂载到B服务器的某个目录下,使其达到B服务下的目录文件一旦变更,可以实时的在A服务器的目录下体现出来?</p>
<p>Linux的解决方式</p>
<ul>
<li>将B服务器的该目录,设置为共享文件夹</li>
<li>A服务器通过mount的方式,指定对应的远程主机所抛出来的共享文件夹进行连接.</li>
</ul>
<p>原理:</p>
<ul>
<li>挂载,并非将远程服务的文件实时拷贝到目标文件夹中</li>
<li>A服务器每次对于自身挂载文件的访问,实际上都是发送了一次新的RPC请求,请求目标服务器将其对应的目录数据实时返回到A服务器的文件当中进行展示.</li>
<li>Linux中存在一个应用:NFS网络文件系统(Network File System),它是一种适用于分散式文件系统的协定,让应用程序在客户端通过网络访问位于磁盘中的数据,是在类Unix系统间实现对应的磁盘文件共享的一种方法.</li>
</ul>
<p>NFS和RPC的关系:</p>
<ul>
<li>NFS在文件传送或信息传送过程中依赖于RPC协议.</li>
<li>RPC,远程过程调用(Remote Procedure Call)是能使客户端执行其他系统中程序的一种机制.</li>
<li>NFS本身是没有提供信息传输的协议和功能,但是NFS却能让我们通过网络进行资料的分享,这是因为NFS使用了一些其他的传输协议.而这些传输协议用到这个RPC功能,可以说NFS本身就是使用RPC的一个程序.只要用到NFS的地方都要启动RPC服务,不论是NFS 服务器还是NFS客户端,因为这样服务器和客户端才能通过RPC来实现程序端口的对应.</li>
<li>可以这么理解:NFS是一个文件系统,而RPC是负责信息的传输</li>
</ul>
<h3 id="安装并配置NFS服务"><a href="#安装并配置NFS服务" class="headerlink" title="安装并配置NFS服务"></a>安装并配置NFS服务</h3><ol>
<li>安装nfs服务器端服务: <code>apt-get install nfs-kernel-server</code>        </li>
<li>编辑<code>/etc/exports</code>下的配置文件: <ol>
<li><code>sudo vim /etc/exports</code></li>
<li>添加配置信息:<code>/home/zjy/share_folder *(rw, sync, no_root_squash, no_subtree_check)</code><ol>
<li><code>/home/zjy/share_folder</code>:共享文件夹的路径</li>
<li><code>*</code> : 允许所有的网段访问,也可以使用具体的IP</li>
<li><code>rw</code> : 挂接此目录的客户端对该共享目录的权限:读,写</li>
<li><code>sync</code>:资料同步写入内存和硬盘</li>
<li><code>no_root_squash</code>:root用户具有对根目录的完全管理访问权限</li>
<li><code>no_subtree_check</code> : 不检查父目录的权限</li>
</ol>
</li>
</ol>
</li>
<li>重启服务,将会自动映射端口:<code>sudo /etc/init.d/rpcbind restart</code></li>
<li>重启nfs服务:<code>sudo /etc/init.d/nfs-kernel-server restart</code></li>
<li>创建共享文件夹</li>
<li>查看ip地址,准备给客户端挂载</li>
</ol>
<p>客户端配置:</p>
<ol>
<li>创建用于存放挂载的目录:<code>sudo mkdir /opt/share_folder</code></li>
<li>挂载服务器端共享目录:<code>sudo mount -t nfs 192.167.15.5:/mnt/A311D_share_folder /opt/share_folder</code></li>
<li>取消挂载:<code>sudo umount /opt/share_folder</code></li>
</ol>
<h2 id="etc-apt-source-list"><a href="#etc-apt-source-list" class="headerlink" title="&#x2F;etc&#x2F;apt&#x2F;source.list"></a>&#x2F;etc&#x2F;apt&#x2F;source.list</h2><h3 id="debian-9-strech-arm64"><a href="#debian-9-strech-arm64" class="headerlink" title="debian 9 strech arm64"></a>debian 9 strech arm64</h3><ul>
<li>apt源<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># debian</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian stable main contrib non-free</span><br><span class="line"># deb-src http://mirrors.ustc.edu.cn/debian stable main contrib non-free</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span><br><span class="line"># deb-src http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span><br><span class="line"></span><br><span class="line"># deb http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span><br><span class="line"># deb-src http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="apt-出现-Certificate-verification-failed"><a href="#apt-出现-Certificate-verification-failed" class="headerlink" title="apt 出现 Certificate verification failed"></a>apt 出现 Certificate verification failed</h2><ul>
<li><code>apt install ca-certificates --reinstall</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/FFmpeg/ffmpeg_4_%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-ffmpeg_4_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/FFmpeg/ffmpeg_4_%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-ffmpeg_4_1/" class="post-title-link" itemprop="url">ffmpeg_4_1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ffmpeg C开发 常用技巧</li>
</ul>
<h2 id="ffmpeg-AVPacket-初始化和反初始化"><a href="#ffmpeg-AVPacket-初始化和反初始化" class="headerlink" title="ffmpeg AVPacket 初始化和反初始化"></a>ffmpeg AVPacket 初始化和反初始化</h2><ul>
<li>av_init_packet()函数被弃用了</li>
<li>应该使用 av_packet_alloc()函数对packet进行申请，使用av_packet_free()函数继续释放</li>
</ul>
<h2 id="ffmpeg-AVFrame-转-cv-Mat"><a href="#ffmpeg-AVFrame-转-cv-Mat" class="headerlink" title="ffmpeg AVFrame 转 cv::Mat"></a>ffmpeg AVFrame 转 cv::Mat</h2><ul>
<li><p>上面函数传入的参数frame中的图像格式，可以是YUV, RGB ,等等，，经过sws_scale（）转换之后，写入cv::Mat 数据区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AVFrame 转 cv::mat  </span></span><br><span class="line"><span class="function">cv::Mat <span class="title">frame_to_mat</span><span class="params">(<span class="type">const</span> AVFrame * frame)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> width = frame-&gt;width;</span><br><span class="line">    <span class="type">int</span> height = frame-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Mat <span class="title">image</span><span class="params">(height, width, CV_8UC3)</span></span>;</span><br><span class="line">    <span class="type">int</span> cvLinesizes[<span class="number">1</span>];</span><br><span class="line">    cvLinesizes[<span class="number">0</span>] = image.<span class="built_in">step1</span>();</span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == _swsContext) &#123;</span><br><span class="line">        _swsContext = <span class="built_in">sws_getContext</span>(width, height,</span><br><span class="line">            (AVPixelFormat)frame-&gt;format, width, height,</span><br><span class="line">            AVPixelFormat::AV_PIX_FMT_BGR24, SWS_FAST_BILINEAR, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sws_scale</span>(_swsContext, frame-&gt;data, </span><br><span class="line">        frame-&gt;linesize, <span class="number">0</span>, height, &amp;image.data, cvLinesizes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一种方式 是直接将AVFrame 中的RGB数据赋值给cv::Mat</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat img;</span><br><span class="line">img = cv::<span class="built_in">Mat</span>(height, width, CV_8UC3);</span><br><span class="line">img.data =  _rgb_frame-&gt;data[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ffmpeg开发库-C-输入rtsp流地址-录制指定长度的视频到本地-编程示例"><a href="#ffmpeg开发库-C-输入rtsp流地址-录制指定长度的视频到本地-编程示例" class="headerlink" title="ffmpeg开发库 C++ 输入rtsp流地址 录制指定长度的视频到本地 编程示例"></a>ffmpeg开发库 C++ 输入rtsp流地址 录制指定长度的视频到本地 编程示例</h2><p>要使用FFmpeg的C++开发库来录制指定长度的RTSP流视频到本地，你可以使用libavcodec、libavformat等库来完成。下面是一个简单的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/time.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// av_register_all();  // 新版本弃用</span></span><br><span class="line">    <span class="built_in">avformat_network_init</span>();</span><br><span class="line"></span><br><span class="line">    AVFormatContext *pFormatCtx = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line">    AVDictionary *options = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;options, <span class="string">&quot;rtsp_transport&quot;</span>, <span class="string">&quot;tcp&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *rtsp_url = <span class="string">&quot;rtsp://example.com/stream&quot;</span>;  <span class="comment">// RTSP流地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *output_file = <span class="string">&quot;output.mp4&quot;</span>;             <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="type">int</span> duration = <span class="number">60</span>;                                   <span class="comment">// 录制时长（秒）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avformat_open_input</span>(&amp;pFormatCtx, rtsp_url, <span class="literal">NULL</span>, &amp;options) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开RTSP流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avformat_find_stream_info</span>(pFormatCtx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法获取流信息&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVFormatContext *pOutputFormatCtx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avformat_alloc_output_context2</span>(&amp;pOutputFormatCtx, <span class="literal">NULL</span>, <span class="literal">NULL</span>, output_file) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法分配输出格式上下文&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVStream *pStream = <span class="built_in">avformat_new_stream</span>(pOutputFormatCtx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pStream) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法创建输出流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avcodec_parameters_copy</span>(pStream-&gt;codecpar, pFormatCtx-&gt;streams[<span class="number">0</span>]-&gt;codecpar) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法拷贝编解码参数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(pOutputFormatCtx-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">avio_open</span>(&amp;pOutputFormatCtx-&gt;pb, output_file, AVIO_FLAG_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;无法打开输出文件&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">avformat_write_header</span>(pOutputFormatCtx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    AVPacket packet;</span><br><span class="line">    <span class="type">int64_t</span> startTime = <span class="built_in">av_gettime</span>();</span><br><span class="line">    <span class="type">int64_t</span> endTime = startTime + duration * <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">av_read_frame</span>(pFormatCtx, &amp;packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">av_gettime</span>() &gt;= endTime) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">av_packet_rescale_ts</span>(&amp;packet, pFormatCtx-&gt;streams[<span class="number">0</span>]-&gt;time_base, pStream-&gt;time_base);</span><br><span class="line">        packet.stream_index = pStream-&gt;index;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">av_interleaved_write_frame</span>(pOutputFormatCtx, &amp;packet);</span><br><span class="line">        <span class="built_in">av_packet_unref</span>(&amp;packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_write_trailer</span>(pOutputFormatCtx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">avformat_close_input</span>(&amp;pFormatCtx);</span><br><span class="line">    <span class="built_in">avio_closep</span>(&amp;pOutputFormatCtx-&gt;pb);</span><br><span class="line">    <span class="built_in">avformat_free_context</span>(pOutputFormatCtx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_dict_free</span>(&amp;options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先初始化了FFmpeg库，然后打开了指定的RTSP流。我们创建了一个输出格式上下文，并且设置了输出文件名。然后，我们复制了输入流的编解码参数到输出流，接着开始逐帧读取输入流，并将其写入输出流。当录制时长达到指定时长后，我们退出录制，并释放相关资源。请确保将 <code>rtsp_url</code> 替换为你的 RTSP 流地址，<code>output_file</code> 为输出文件的路径和名称，<code>duration</code> 为录制时长（以秒为单位）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/FFmpeg/ffmpeg_1_%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/2024-05-22-ffmpeg_1_1_%E9%9F%B3%E8%A7%86%E9%A2%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/FFmpeg/ffmpeg_1_%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/2024-05-22-ffmpeg_1_1_%E9%9F%B3%E8%A7%86%E9%A2%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">ffmpeg_1_1_音视频理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="一、视频解码编解码的一些基本概念"><a href="#一、视频解码编解码的一些基本概念" class="headerlink" title="一、视频解码编解码的一些基本概念"></a>一、视频解码编解码的一些基本概念</h2><h3 id="数字图像的基本概念"><a href="#数字图像的基本概念" class="headerlink" title="数字图像的基本概念"></a>数字图像的基本概念</h3><ol>
<li><p>数字图像的硬件介绍</p>
<ol>
<li>图像输入设备：输入，采样量化，专用处理。（相机、摄像机、扫描仪等）</li>
</ol>
<ul>
<li>线阵相机和面阵相机<ul>
<li>面阵相机：一次拍摄一个区域，视觉检测中绝大部分应用面阵相机</li>
<li>线阵相机：一次拍摄一行像素，通过移动以及拼接来获取图像，分辨率更高，成像质量更高，价格更贵</li>
</ul>
</li>
</ul>
<ol start="2">
<li>电脑：数字图像处理（PC机，服务器集群，硬件电路等）</li>
<li>图像输出设备：专用处理，D&#x2F;A转换，输出。（打印机、显示器等）</li>
</ol>
</li>
<li><p>数字图像的几个基本概念</p>
<ol>
<li>图像的采样和量化<ul>
<li>数字化坐标值称为采样</li>
<li>数字化幅度值称为量化</li>
</ul>
</li>
<li>图像的分辨率<ul>
<li>采样的程度通常用采样率来表示，也就是通常所说的分辨率。分辨率160 × 128 的意思是水平像素数为160个，垂直像素数128个。分辨率越高，像素的数目越多，感受的图像越精密</li>
</ul>
</li>
<li>图像的灰度级<ul>
<li>最常见的图像为8位图像，灰度级为256级，即2的8次方。</li>
<li>灰度级越多，可以展现的图像细节就越多，有时候也把灰度级称为灰度分辨率。</li>
</ul>
</li>
<li>图像的坐标系<ul>
<li>在图像中，如果要表示图像中的某一个像素，可以用它的坐标来表示</li>
<li>图像原点为图像的左上角，坐标记做[0,0]</li>
<li>一副M × N的图像可以用一个矩阵来表示</li>
</ul>
</li>
<li>像素的空间关系：8-邻接和4-邻接</li>
</ol>
</li>
<li><p>数字图像的种类和色彩模型</p>
<ol>
<li>图像的种类<ol>
<li>二值图像：<ul>
<li>像素取值仅为0和1，“0“代表黑色，”1“代表白色。通常用来表示状态，如区分图像中的前景和背景</li>
</ul>
</li>
<li>灰度图像：<ul>
<li>像素取值范围为[0,255]，”0”表示纯黑，“255”表示纯白色，一些图像算法中需要使用灰度图进行运算</li>
</ul>
</li>
<li>彩色图像：<ul>
<li>显示设备通常使用RGB格式的彩色图像，即红（red）绿（green）蓝（blue）三种颜色的组合叠加起来获得各种颜色。</li>
<li>如果把RGB值看做是3个维度的坐标，构建的空间称为RGB色彩空间</li>
<li>除了RGB外，常见的色彩模型还有HSV&#x2F;HSI（数字图像算法常用），CMYK（主要用于印刷），YUV（用于图像传输）</li>
</ul>
</li>
</ol>
</li>
<li>色彩模型：通过数学模型表示颜色，所用的数学模型即颜色模型。<ol>
<li>CMYK色彩模型<ul>
<li>印刷业通过青（C）、品（M）、黄（Y）三原色油墨的不同网点面积率的叠印来表现颜色，一般采用青（C）、品（M）、黄（Y）、黑（BK）四色印刷。</li>
<li>CMYK可以看做是从黑色中减少颜色得到新的颜色，故可以称之为减色模型。而RGB是在白色上叠加颜色得到新的颜色，故称为加色模型。</li>
</ul>
</li>
<li>HSV色彩模型<ul>
<li>HSV即色相（Hue）、饱和度（Saturation）、明度（Value），又称HSI（I即intensity）。常用于图像算法中的色彩分析，对光照具有较强的鲁棒性。</li>
<li>H：用角度表示，从红色开始按逆时针方向计算，红色为0度，绿色为120度，蓝色为240度，该值表示颜色接近于哪种纯色值</li>
<li>S：通常取值范围为0%~100%。圆锥的中心为0，该值越大表示颜色越饱满，直观的说即颜色深而艳</li>
<li>V：亮度，表示颜色的明亮程度</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>图像直方图</p>
<ol>
<li>图像的直方图<ul>
<li>直方图（histogram）是图像处理中的一个非常重要工具，被广泛应用。直方图本质是概率分布的图形化，同时直方图也可以用来表示向量。</li>
<li>直方图的作用<ul>
<li>图像匹配：比较两幅图像的直方图，可以得到两幅图像的相似程度，其本质是对比灰度出现的概率是否相似  </li>
<li>判断成像质量</li>
<li>二值化阈值：所谓二值化即通过设置一个门限值，把灰度图像转换为二值化图像，通常的目的是分离前景和背景。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="视频数据的一些基本概念"><a href="#视频数据的一些基本概念" class="headerlink" title="视频数据的一些基本概念"></a>视频数据的一些基本概念</h3><ol>
<li>音视频领域早起采用模拟化技术，目前已发展为数字化技术。数字化后，音视频处理就进入了计算机技术领域，<strong>音视频处理本质上就是对计算机数据的处理</strong></li>
<li>帧内编码：帧内编码是<strong>空间域编码</strong>，利用图像空间冗余度进行图像压缩，处理的是一副独立的图像，不会跨越多幅图像。空间域编码依赖于一幅图像中<strong>相邻像素间的相似性和图案区的主要空间域频率</strong>。（JPEG标准用于静止图像，即图片，只是用了空间域压缩，只是用帧内编码。）<ul>
<li>熵与冗余<ul>
<li>在所有的实际节目素材中，存在这两种类型的信号分量：即异常的、不可预见的信号分量和可以预见的信号分量。</li>
<li>异常分量称为<strong>熵</strong>，它是信号中的<em>真正信息</em></li>
<li>其余部分称为<strong>冗余</strong>，因为它不是必须的信息。<ul>
<li>冗余可以是空间性的，例如在图像的大片区域中，邻近像素几乎具有相同的数值。</li>
<li>冗余也可以是时间性的，例如连续图像之间的相似部分。</li>
</ul>
</li>
<li>在所有的压缩系统<em>编码器</em>中都是将熵与冗余分离，只有熵被编码和传输，而在<em>解码器</em>中再从编码器的发送的信号中计算出冗余。</li>
</ul>
</li>
</ul>
</li>
<li>帧间编码，是<strong>时间域编码</strong>，利用一组连续图像间的时间性冗余度进行图像压缩。如果某帧图像可被解码器使用，那么解码器只需利用两帧图像的差异即可得到下一阵图像。<ul>
<li>比如运动平缓的几帧图像的相似性大，差异性小，而运动剧烈的几幅图像则相似性小，差异性大。当得到一帧完整的图像信息后，可以利用与后一帧图像的差异值推算得到后一帧图像，这样就实现了数据量的压缩。<strong>时间域编码依赖于连续图像帧间的相似性</strong>，尽可能利用已接受的图像来“预测”生成当前图像。（MPEG标准用于运动图像，即视频，会使用空间域编码和时间域编码，因此是帧内编码和帧间编码结合使用）</li>
</ul>
</li>
<li>I帧：I帧（Intra-coded picture,帧内编码帧，常称为<strong>关键帧</strong>）包含一副完整的图像信息，属于帧内编码图像，不含运动矢量，在解码时不需要参考其他帧图像。因此，在I帧图像出可以切换频道，而不会导致图像丢失或无法解码。I帧图像用于组织误差的累计和扩散。在闭合式GOP中，每个GOP的第一个帧一定是I帧，且当前GOP的数据不会参考前后GOP的数据。<ul>
<li>运动矢量：一组连续图像记录了目标的运动。运动矢量用于衡量两帧图像间目标的<strong>运动程度</strong>，<em>运动矢量由水平位移和垂直位移二者构成</em>。</li>
<li>闭合式GOP：<ul>
<li>GOP(Group Of Pictures,图像组)是一组连续的图像，由一个I帧和多个B&#x2F;P帧组成，是编解码存取的基本单位。GOP结构常用的两个参数M和N：M指定GOP中两个anhor frame（anchor frame指可被其他帧参考的帧，即I帧或P帧）之间的距离；N指定一个GOP的大小，例如M&#x3D;2，N&#x3D;13，GOP结构为：IBBPBBPBBPBB</li>
<li>B帧：（Bi-directionally predicted picture,双向预测编码图像帧），是帧间编码帧，利用之前和（或）之后的I帧或P帧进行<em>双向预测编码</em>。<strong>B帧不可以作为参考帧。</strong>B帧具有更高的压缩率，但需要更多的缓冲时间以及更高的CPU占用率，因此B帧适合本地存储以及视频点播，而不是用对实时性要求较高的直播系统。<ul>
<li>双向预测编码：<ul>
<li>连续的三幅图像中，目标块有垂直位置上的移动，背景块无位置移动，考虑如何得到当前帧图像（画面N）：<ul>
<li>画面N中，目标向上移动后，露出背景块</li>
<li>画面N-1中，因为背景块被目标快遮挡住了，因此没有背景块相关信息。</li>
<li>画面N+1中，完整包含背景块的数据，因此画面N可以从画面N-1中取得背景块。</li>
</ul>
</li>
<li>如何可以得到画面N？<ul>
<li>解码器可以先解码得到画面N-1和画面N+1，通过画面N-1中的目标块数据结合运动矢量即可得到画面N中的目标块数据，通过画面N+1中的背景块数据则可得到画面N中的背景块数据。</li>
<li>三幅画面的解码顺序为：N-1，N+1，N</li>
<li>三幅画面的显示顺序为N-1，N，N+1</li>
</ul>
</li>
<li><strong>画面N通过其前一幅画面N-1和后一副画面N+1推算（预测，predicted）得到，因此这种方式称为双向预测（或前向预测，双向参考）</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>P帧：（Predictive-coded picture,预测编码图像帧），是帧间编码帧，利用之前的I帧或P帧进行预测编码。</li>
<li>GOP有两种：闭合式GOP和开放式GOP<ul>
<li>闭合式GOP：闭合式GOP只需要参考本GOP内的图像即可，不需要参考前后GOP的数据。这种模式决定了，<strong>闭合式GOP的显示顺序总是以I帧开始,以P帧结束。</strong>(闭合式GOP是否一定是以P帧结束？可能未必有此定义，有些视频文件GOP以B帧结束)</li>
<li>开放式GOP：开放式GOP中的B帧解码时可能要用到其前一个GOP或后一个GOP的某些帧。码流里面包含B帧的时候才会出现开放式GOP。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>I帧,B帧,P帧的编码基本流程:</p>
<ul>
<li>I帧编码的基本流程:<ol>
<li>进行帧内预测,决定所采用的帧内预测模式</li>
<li>像素值减去预测值,得到残差</li>
<li>对残差进行变换和量化</li>
<li>变长编码和算数编码</li>
<li>重构图像并滤波,得到的图像作为其它帧的参考帧</li>
</ol>
</li>
<li>P帧和B帧编码的基本流程为:</li>
</ul>
<ol>
<li>进行运动估计,计算采用帧间编码模式的率失真函数(节)值.P帧只参考前面的帧,B帧可参考后面的帧</li>
<li>进行帧内预测,选取率失真函数值最小的帧内模式与帧间模式比较,确定采用哪种编码模式</li>
<li>计算实际值和预测值的差值</li>
<li>对残差进行变换和量化</li>
<li>熵编码,如果是帧间编码模式,编码运动矢量</li>
</ol>
<p><strong>小结</strong></p>
<ul>
<li>I帧只需考虑本帧;</li>
<li>P帧记录的是与前一帧的差别</li>
<li>B帧记录的是前一帧及后一帧的差别,能节约更多的空间,视频文件小了,但是相对来说解码的时候就比较麻烦.因为在解码时,不仅要用之前缓存的画面,而且要知道下一个I或者P的画面,对于不支持B帧解码的播放器容易卡顿.</li>
</ul>
<h3 id="FFmpeg解码涉及的一些基本概念"><a href="#FFmpeg解码涉及的一些基本概念" class="headerlink" title="FFmpeg解码涉及的一些基本概念"></a>FFmpeg解码涉及的一些基本概念</h3><ol>
<li>封装格式(container format)：可以看做是编码流（音频流、视频流等）数据的一层外壳，将编码后的数据存储于此封装格式的文件之内。<ul>
<li>封装，又称容器，<strong>所谓容器，就是存放内容的器具</strong>。 容器的本质就是文件，是特定的视频文件，如mp4，mkv，flv等格式的音视频文件,其内部存放一帧帧的视频信息和音频信息。因此，视频文件内部尝尝包含不止一个信息流，而是包含一组信息流（若干视频流和若干音频流）<ul>
<li>所谓信息流，就是随时间分布的信息，比如视频可以看成是一组随时间分布的图片。</li>
<li>视频流中的一个数据元通常被称为一帧（frame），每一种视频流都有属于自己的编解码器（encoder&#x2F;decoder,在FFmpeg中被简写为coderc），用于说明该种视频流是如何编码和解码的。</li>
<li>数据包（packets）则尝尝指从裸数据解析而来的数据片断。</li>
</ul>
</li>
<li>容器的作用：容器中可以存放音频、视频、字幕流等信息，将这些信息整合在一起，按照特定规则放置在容器中。</li>
</ul>
</li>
<li>编解码器(Codec)：数据帧（原始数据）与数据包（压缩数据）之间的转换工具<ul>
<li>数据帧（原始数据）-&gt; 编解码器（编码）-&gt; 数据包（压缩数据）</li>
<li>数据包（压缩数据）-&gt; 编解码器（解码）-&gt; 数据帧（原始数据）</li>
</ul>
</li>
<li>媒体流(Stream)：时间上的一段连续数据。一段声音数据，称为音频流；一段视频数据，称为视频流；一段字母数据，称为字幕流</li>
<li>数据帧(Data Frame)：媒体流，由若干数据帧构成；压缩格式中，数据帧是最小的处理单元。<ul>
<li>在容器中，如果有多个数据流，那么视频帧、音频帧、字母信息、交错存储，以保证实时性</li>
<li>数据帧是未压缩的原始数据，如：视频帧每一帧都是一张完整的YUV图片，音频帧是PCM格式的。</li>
</ul>
</li>
<li>数据包(Data Packet)：将数据帧压缩后就是数据包，数据帧是未压缩的原始数据，数据包是压缩后的数据。</li>
<li>复用（Mux）：将不同的媒体流，按照一定规则放入容器，复用的关键工具是：复用器（Muxer）</li>
<li>解复用（Demux）：从容器中解析不通的流出来，解复用的关键工具是：解复用器（Demuxer）</li>
</ol>
<h3 id="FFmpeg开发环境构建"><a href="#FFmpeg开发环境构建" class="headerlink" title="FFmpeg开发环境构建"></a>FFmpeg开发环境构建</h3><ol>
<li>ffmpeg官网：<a target="_blank" rel="noopener" href="https://www.ffmpeg.org/">https://www.ffmpeg.org/</a></li>
<li>SDL（Simple DirectMedia Layer）：是一套开源的跨平台多媒体开发库。SDL提供了书中控制图像、声音、输出输入的函数，封装了复杂的音视频底层操作，简化了音视频处理的难度。目前SDL多用于开发游戏、模拟器、媒体播放器等多媒体应用领域。官网: <a target="_blank" rel="noopener" href="https://www.libsdl.org/">https://www.libsdl.org/</a></li>
<li>yasm&#x2F;nasm<ul>
<li>旧版ffmpeg及x264&#x2F;x265使用yasm汇编器</li>
<li>新版ffmpeg及x264&#x2F;x265改用nasm汇编器<ul>
<li>NASM（Netwide Assembler），是一款基于英特尔x86架构的汇编与反汇编工具。官网：<a target="_blank" rel="noopener" href="https://www.nasm.us/">https://www.nasm.us/</a></li>
</ul>
</li>
</ul>
</li>
<li>x264：是开源的h264编码器，使用非常广泛。ffmpeg工程中实现了h264解码器，但是没有264编码器。因此需要安装第三方编码器x264。官网：<a target="_blank" rel="noopener" href="https://www.videolan.org/developers/x264.html">https://www.videolan.org/developers/x264.html</a></li>
<li>x265：是开源的h265编码器。ffmpeg工程中实现了h265解码器，但是没有h265编码器，因此需要安装第三方编码器x265.官网：<a target="_blank" rel="noopener" href="https://www.x265.org/">https://www.x265.org/</a> 下载地址：<a target="_blank" rel="noopener" href="https://www.videolan.org/developers/x265.html">https://www.videolan.org/developers/x265.html</a></li>
<li>libmp3lame：是开源的mp3编码器。官网：<a target="_blank" rel="noopener" href="https://lame.sourceforge.net/">https://lame.sourceforge.net/</a></li>
<li>librtmp：RTMPDump Read-Time Messaging Protocol API，又成rtmpdump，是用于处理RTMP流的工具。支持所有形式的RTMP，文档：<a target="_blank" rel="noopener" href="https://rtmpdump.mplayerhq.hu/librtmp.3.html">https://rtmpdump.mplayerhq.hu/librtmp.3.html</a> 官网：<a target="_blank" rel="noopener" href="https://rtmpdump.mplayerhq.hu/">https://rtmpdump.mplayerhq.hu/</a></li>
</ol>
<h3 id="处理音视频流的一般过程："><a href="#处理音视频流的一般过程：" class="headerlink" title="处理音视频流的一般过程："></a>处理音视频流的一般过程：</h3><ol>
<li>打开音视频文件，获取音视频流</li>
<li>从数据流中读取数据帧</li>
<li>如果数据帧不完整，就回到第二步</li>
<li>处理数据帧</li>
<li>回到第二步</li>
</ol>
<h2 id="二、FFmpeg视频解码过程"><a href="#二、FFmpeg视频解码过程" class="headerlink" title="二、FFmpeg视频解码过程"></a>二、FFmpeg视频解码过程</h2><ol>
<li>注册所支持的所有的文件（容器）格式及其对应的Codec：<code>av_register_all()</code></li>
<li>打开输入文件：<code>avformat_open_input()</code></li>
<li>解封装，从文件中提取流信息：<code>avformat_find_stream_info()</code></li>
<li>查找video stream相对应的解码器：<code>avcodec_find_decoder()</code></li>
<li>给相应解码器的上下文容器分配内存：<code>avcodec_alloc_context3() avcode_parameters_to_context()</code></li>
<li>打开解码器，并初始化解码器的上下文容器：<code>avcodec_open2()</code></li>
<li>创建SwsContext对象，并初始化:<code>av_image_fill_arrays(),sws_getContext()</code></li>
<li>为解码帧分配内存：<code>av_frame_alloc()</code></li>
<li>从流中读取数据到Packet中：<code>av_read_fream()</code></li>
<li>发送数据包到解码队列：<code>avcodec_send_packet()</code></li>
<li>接受一帧解码数据，并解码：<code>avcodec_receive_frame()</code></li>
<li>对视频帧（YUV）进行图像格式转换（RGB）:<code>sws_scale()</code></li>
</ol>
<h2 id="三、（用到的）结构体的功能和参数简要分析"><a href="#三、（用到的）结构体的功能和参数简要分析" class="headerlink" title="三、（用到的）结构体的功能和参数简要分析"></a>三、（用到的）结构体的功能和参数简要分析</h2><h3 id="关键的结构体分类："><a href="#关键的结构体分类：" class="headerlink" title="关键的结构体分类："></a>关键的结构体分类：</h3><ol>
<li>解协议（http，rtsp，rtmp，mms）<ol>
<li>AVIOContext</li>
<li>URLProtocol<ol>
<li>存储输入视音频使用的封装格式，每种协议都对应一个URLProtocol结构</li>
<li>FFmpeg中文件也被当做一种协议“file”</li>
</ol>
</li>
<li>URLContext<ol>
<li>主要存储视音频使用的协议的类型</li>
</ol>
</li>
</ol>
</li>
<li>解封装（flv,avi,rmvb,mp4)<ol>
<li>AVFormatContext<ol>
<li>主要存储视音频封装格式中包含的信息</li>
<li>几个主要变量（解码）：<ol>
<li>AVIOContext * pb ： 输入数据的缓存</li>
<li>unsigned int nb_streams : 视音频流的个数</li>
<li>AVStream **streams：视音频流</li>
<li>char filename[1024]：文件名</li>
<li>int64_t duration：时长（单位：微秒）</li>
<li>int bit_rate：比特率（单位：bps）</li>
</ol>
</li>
</ol>
</li>
<li>AVInputFormat<ol>
<li>存储输入视音频使用的封装格式</li>
<li>每种视音频封装格式都对应一个AVInputFormat结构</li>
</ol>
</li>
</ol>
</li>
<li>解码（h264, mpeg2, aac, mp3）<ol>
<li>AVStream：<ol>
<li>每一个AVStream存储一个视频&#x2F;音频流的相关数据</li>
</ol>
</li>
<li>AVCodecContext：<ol>
<li>存储该视频&#x2F;音频流使用的解码方式的相关数据</li>
<li>每个AVStream对应一个AVCodecContext</li>
</ol>
</li>
<li>AVCodec：<ol>
<li>包含视频&#x2F;音频对应的解码器,每种解码器都对应一个AVCodec结构</li>
<li>每个AVCodecContext中对应一个AVCodec</li>
</ol>
</li>
</ol>
</li>
<li>存数据<ol>
<li>视频：每个结构一般都是存一帧，音频可能是一帧，也可能是多帧</li>
<li>解码前的数据格式：AVPacket</li>
<li>解码后的数据格式：AVFrame</li>
</ol>
</li>
</ol>
<h3 id="一些相关的类及其参数"><a href="#一些相关的类及其参数" class="headerlink" title="一些相关的类及其参数"></a>一些相关的类及其参数</h3><ol>
<li>int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align);<ol>
<li>函数的作用：通过指定像素格式、图像宽、图像高来计算所需要的内存大小</li>
<li>重要参数：<ol>
<li>“align：设定内存对齐的对齐数，也就是按多大的字节对齐”</li>
</ol>
</li>
</ol>
</li>
<li>int av_image_alloc(uint8_t* pointers[4], int linesize[4], int w, int h, enum AVPixelFormat pix_fmt, int align);<ol>
<li>函数作用：按计算的内存大小申请所需要的内存</li>
<li>参数：<ol>
<li>pointers[4]：保存图像通道的地址。如果是RGB，则前三个指针分别指向R,G,B的内存地址，第四个保留不用</li>
<li>linesize[4]：保存图像每个通道的内存对齐的<strong>步长</strong>,即一行的对齐内存的宽度，此值的大小等于图像的宽度</li>
<li>w：要申请内存的图像宽度</li>
<li>h：要申请内存的图像高度</li>
<li>pix_fmt：要申请内存的图像的像素格式</li>
<li>align：用于内存对齐的值</li>
<li>@return：所申请的内存空间的总大小，如果为负值，申请失败</li>
</ol>
</li>
</ol>
</li>
<li>int av_image_fill_arrays(uint8_t ** dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align);<ol>
<li>函数作用：<ol>
<li>org: <ol>
<li>Setup the data pointers and linesizes based on the specified image parameters and provided array.（根据指定的图像参数和提供的数据设置数据指针和行宽的大小）The fields of the given image are filled in by using the src address which points to the image data buffer. Depending on the specified pixel format, one or multiple image data pointers and line sizes will be set.（给定图像的字段是使用指向图像数据缓冲区的src地址填充的，根据指定的像素格式，将设置一个或多个图像数据指针和行宽大小）</li>
</ol>
</li>
</ol>
</li>
<li>参数：<ol>
<li>dst_data[4]：data pointers to be filled in.（要填充的数据指针）<del>对申请的内存格式分为三个通道后，分别保存其地址</del></li>
<li>dst_linesize[4]：linesizes for the image in dst_data to be filled in.(dst_data中要填充的图像的行宽大小)<del>格式化的内存步长（即内存对齐后的宽度）</del></li>
<li>src：buffer which will contain or contains the actual image data can be NULL.（将包含或包含实际图像数据的缓冲区）<del>av_alloc()函数申请的内存地址</del></li>
<li>pix_fmt：the pixel format of the image.（图像的像素格式）<del>申请src内存时的像素格式</del></li>
<li>width：the width of the image in pixels. （图像的宽度，以像素为单位）<del>申请src的宽度</del></li>
<li>height：the height of the image in pixels. （图像的高度，以像素为单位）<del>申请src的高度</del></li>
<li>align：the value use in src for linesize alignment.（src中用于行大小对齐的值）<del>用于内存对齐的值</del></li>
<li>return：the size in bytes required for src.（src所需的大小，以字节为单位 ）</li>
</ol>
</li>
</ol>
</li>
<li>int avcodec_send_packet(AVCodecContext* avctx, const AVPacket* avpkt);<ol>
<li>函数功能：Supple raw packet data as input to a decoder.（提供原始数据包数据做为解码器的输入）Internally, this call will copy relevant AVCodecContext fields, which can influence decoding per-packet, and apply them when the packet is actually decoded.（在内部，此调用将复制相关的AVCodecContext字段，这些字段可能会影响到每个数据包的解码，并在数据包实际解码时应用这些字段）</li>
</ol>
</li>
<li>int avcodec_receive_frame(AVCodecContext* acvtx, AVFrame* frame)<ol>
<li>函数功能：Return decoded output data from a decoder.(从解码器返回解码数据)</li>
<li>参数：<ol>
<li>avctx: codec context.（编解码器上下文）</li>
<li>frame: This will be set to a reference-counted video or audion frame(depending on the decoder type) allocated by the decoder.（这将被设置为解码器分配的参考计数视频或音频帧，取决于解码器类型）Note that the function will always call av_frame_unref(frame) before doing anything else.（在调用av_frame_unref函数之前，它可以做任何其他的事情。）</li>
</ol>
</li>
</ol>
</li>
<li>int sws_scale(struct SwsContext* c, const uint8_t* const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t* const dst[], const int dstStride[]);<ol>
<li>函数功能：Scale the image slice in srcSlice and put the resulting scaled slice in the image in dst.（在srcSlice中缩放图像切片，并将生成缩放切片放在dst中的图像）A slice is a sequence of consecutive rows in an image.（一个切片是图像中连续行的一个序列）Slice have to be provided in sequential order, either in top-bottom or bottom-top order. If slices are provided in non-sequential order the behavior of the function is undefined.（切片必须是按顺序提供的，可以是上下顺序，也可以是下上顺序。如果切片以非顺序提供，则函数的行为未定义）</li>
<li>参数：<ol>
<li>c:the scaling context previously created with sws_getContext</li>
<li>srcSlice: the array containing the pointers to the planes of the source slice.（包含指向源切片平面的指针的数组）</li>
<li>srcStride: the array containing the stride for each plane of the source image.（包含源图像的每个平面的步长的数组）</li>
<li>srcSliceY: the position in the source image of the slice to process, that is the number(couted starting from zero) in the image of the first row of the slice.（要处理的切片的源图像的位置，即切片第一行图像张的数字（从零开始计数））</li>
<li>srcSliceH: the height of the source slice, that is the number of rows in the slice.（源切片的高度，即切片中的行数）</li>
<li>dst: the array containing the pointers to the planes of the destination image.（包含指向目标图像平面的指针的数组）</li>
<li>dstStride : the array containing the strides for each plane of the destination image.（包含目标图像的每个平面的步长的数组）</li>
<li>@return：the height of the output slice.（输出切片的高度）</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><ol>
<li>字节对齐、内存对齐<ol>
<li>现代计算机中内存空间都是按照byte划分的，从理论上将似乎对任何类型的变量额访问可以从任何地址开始，但是实际上的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常是4或者8）的背书，这就是所谓的内存对齐</li>
<li>图像在存储或传输的过程中，一般一个行宽会是某个数的倍数，行宽一般是以字节为单位的，所以便有字节对齐。（例如：一个图像的行宽为1023，想向1024对齐，差的1个字节，就是字节对齐数）<ol>
<li>行宽 &#x3D;  宽度 × 通道数</li>
<li>高度 &#x3D; 就是行数，因为每一行是在高度上是1</li>
<li>那么申请的内存大小为：height * width * channels</li>
<li>图像在电脑里存储的是二维数据，也就是数字矩阵。（不管是1通道还是3通道，都是以数字矩阵（二维）方式存储，不通的是一个像素是对应一个值还是三个值）</li>
<li>而现实中，对图像存储的描述，可以是立体的，例如三通道的图像，就是立方体，长是行宽，宽是高度，高是通道数。（<del>这样一说，好像更迷了哈哈哈，但它就是立方体，第三个坐标轴代表的是通道数</del>）</li>
</ol>
</li>
</ol>
</li>
<li>AVFrame结构体中的几个参数：<ol>
<li>width、height：Video dimensions. Video frames only. The coded dimensions(in pixels) of the video frame, i.e. the size of the rectangle that contains some well-defined values.（仅限视频帧，视频帧的编码尺寸（以像素为单位），即包含一些明确定义的值的矩形大小）</li>
<li>linesize ：for video, size in bytes of each picture line.（对于视频，每条图片行的大小（以字节为单位））for video the linesizes should be multiples of the CPUs alignment preference, this is 16 or 32 for modern destop CPUs.（对于视频，线条大小应该是CPU对齐首选项的倍数，对于现代桌面CPU，这是16或32.）</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/FFmpeg/ffmpeg_5_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-ffmpeg_5_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/FFmpeg/ffmpeg_5_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-ffmpeg_5_01/" class="post-title-link" itemprop="url">ffmpeg_5_01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ffmpeg常用函数</li>
</ul>
<h2 id="ffmpeg-sws-scale-函数-详解"><a href="#ffmpeg-sws-scale-函数-详解" class="headerlink" title="ffmpeg sws_scale() 函数 详解"></a>ffmpeg sws_scale() 函数 详解</h2><p><code>sws_scale()</code> 函数是 FFmpeg 中的一个函数，用于执行图像的像素格式转换和尺寸缩放等操作。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sws_scale</span><span class="params">(<span class="keyword">struct</span> SwsContext *c, <span class="type">const</span> <span class="type">uint8_t</span> *<span class="type">const</span> srcSlice[],</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="type">int</span> srcStride[], <span class="type">int</span> srcSliceY, <span class="type">int</span> srcSliceH,</span></span><br><span class="line"><span class="params">              <span class="type">uint8_t</span> *<span class="type">const</span> dst[], <span class="type">const</span> <span class="type">int</span> dstStride[])</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<ul>
<li><code>c</code>：指向 <code>SwsContext</code> 结构的指针，表示图像转换器上下文。</li>
<li><code>srcSlice</code> 和 <code>dst</code>：分别是源图像和目标图像的数据缓冲区。<code>srcSlice</code> 是一个指针数组，用于存储源图像的每一行数据的指针；<code>dst</code> 也是一个指针数组，用于存储目标图像的每一行数据的指针。</li>
<li><code>srcStride</code> 和 <code>dstStride</code>：分别是源图像和目标图像的行字节步长数组。<code>srcStride</code> 数组中存储了源图像每一行数据的字节步长；<code>dstStride</code> 数组中存储了目标图像每一行数据的字节步长。</li>
<li><code>srcSliceY</code> 和 <code>srcSliceH</code>：分别表示要处理的源图像的起始行号和行数。</li>
</ul>
<p>调用 <code>sws_scale()</code> 函数将会执行图像的像素格式转换和尺寸缩放等操作。该函数将源图像数据转换为目标图像数据，并根据需要进行尺寸缩放。</p>
<p>在调用该函数之前，需要先创建一个图像转换器上下文（<code>SwsContext</code>），并对其进行适当的初始化。通常情况下，可以使用 <code>sws_getContext()</code> 函数来创建一个图像转换器上下文，并指定源图像和目标图像的相关参数。</p>
<p>需要注意的是，<code>sws_scale()</code> 函数执行的是图像转换操作，因此需要确保输入和输出缓冲区的大小和格式是正确匹配的。另外，对于需要进行尺寸缩放的情况，需要根据源图像和目标图像的尺寸比例来设置相应的缩放比例。</p>
<p>使用 <code>sws_scale()</code> 函数可以实现图像的像素格式转换、尺寸缩放等功能，常用于视频处理和图像处理等应用场景。</p>
<h2 id="ffmpeg-avcodec-receive-frame-函数-详解"><a href="#ffmpeg-avcodec-receive-frame-函数-详解" class="headerlink" title="ffmpeg avcodec_receive_frame() 函数 详解"></a>ffmpeg avcodec_receive_frame() 函数 详解</h2><p><code>avcodec_receive_frame()</code> 函数是 FFmpeg 中的一个函数，用于从解码器中获取解码后的音频或视频帧。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">avcodec_receive_frame</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<ul>
<li><code>avctx</code> 是指向 <code>AVCodecContext</code> 结构的指针，表示要使用的解码器上下文。</li>
<li><code>frame</code> 是指向 <code>AVFrame</code> 结构的指针，表示要接收解码后的音频或视频帧。</li>
</ul>
<p>调用 <code>avcodec_receive_frame()</code> 函数后，将会从解码器中获取解码后的音频或视频帧，并将帧数据保存到 <code>frame</code> 中。这个函数通常用于解码过程的第二步，用于从解码器获取解码后的帧数据。</p>
<p>需要注意的是，由于解码器可能会对帧数据进行缓冲和延迟处理，因此调用该函数并不会立即返回已解码的帧数据。如果解码器内部缓冲区中没有可用的解码帧，该函数将会阻塞，直到解码器解码完成并有可用的解码帧为止。</p>
<p>在解码器解码完所有数据包后，需要调用 <code>avcodec_receive_frame()</code> 函数并传递 <code>NULL</code> 作为帧参数，以表示已经接收完所有解码帧，解码器可以进行最后的清理工作。这样做可以确保解码器在解码完所有数据包后能够正确地结束解码过程。</p>
<p>需要注意的是，<code>AVFrame</code> 结构中存储的帧数据通常是解码后的原始音频或视频数据，需要根据实际情况进行后续处理，例如播放音频或显示视频。</p>
<h2 id="ffmpeg-avcodec-send-packet-函数-详解"><a href="#ffmpeg-avcodec-send-packet-函数-详解" class="headerlink" title="ffmpeg avcodec_send_packet() 函数 详解"></a>ffmpeg avcodec_send_packet() 函数 详解</h2><p><code>avcodec_send_packet()</code> 函数是 FFmpeg 中的一个函数，用于向解码器发送压缩数据包。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">avcodec_send_packet</span><span class="params">(AVCodecContext *avctx, <span class="type">const</span> AVPacket *pkt)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>avctx</code> 是指向 <code>AVCodecContext</code> 结构的指针，表示要使用的解码器上下文；<code>pkt</code> 是指向 <code>AVPacket</code> 结构的指针，表示要发送的压缩数据包。</p>
<p>调用 <code>avcodec_send_packet()</code> 函数后，将会向解码器发送一个压缩数据包，解码器将会从这个数据包中解析出压缩的音频或视频帧，并进行解码操作。这个函数通常用于解码过程的第一步，将压缩的音视频数据发送给解码器。</p>
<p>需要注意的是，由于解码器可能会对压缩数据进行缓冲和延迟处理，因此调用该函数并不会立即触发解码操作。解码器将会在后续调用 <code>avcodec_receive_frame()</code> 函数时，从缓冲区中获取压缩数据包并进行解码。</p>
<p>在解码器解码完所有数据包后，需要调用 <code>avcodec_send_packet()</code> 函数并传递 <code>NULL</code> 作为数据包参数，以表示已经发送完所有数据包，解码器可以进行最后的解码操作。这样做可以确保解码器在解码完所有数据包后能够正确地结束解码过程。</p>
<p>需要注意的是，<code>AVPacket</code> 结构中的数据通常来自于读取媒体文件或网络流等操作，或者是从编码器中获取到的压缩数据。因此，在调用 <code>avcodec_send_packet()</code> 函数之前，需要先正确地获取到压缩数据，并将数据填充到 <code>AVPacket</code> 结构中。</p>
<h2 id="ffmpeg-sws-getContext-函数-详解"><a href="#ffmpeg-sws-getContext-函数-详解" class="headerlink" title="ffmpeg sws_getContext() 函数 详解"></a>ffmpeg sws_getContext() 函数 详解</h2><p><code>sws_getContext()</code> 是 FFmpeg 中的一个函数，用于创建和初始化图像转换器上下文（SWSContext）。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SwsContext *<span class="title function_">sws_getContext</span><span class="params">(<span class="type">int</span> srcW, <span class="type">int</span> srcH, <span class="keyword">enum</span> AVPixelFormat srcFormat,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> dstW, <span class="type">int</span> dstH, <span class="keyword">enum</span> AVPixelFormat dstFormat,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> flags, SwsFilter *srcFilter,</span></span><br><span class="line"><span class="params">                                  SwsFilter *dstFilter, <span class="type">const</span> <span class="type">double</span> *param)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<ul>
<li><code>srcW</code> 和 <code>srcH</code>：源图像的宽度和高度。</li>
<li><code>srcFormat</code>：源图像的像素格式。</li>
<li><code>dstW</code> 和 <code>dstH</code>：目标图像的宽度和高度。</li>
<li><code>dstFormat</code>：目标图像的像素格式。</li>
<li><code>flags</code>：额外的标志，用于控制图像转换的行为。</li>
<li><code>srcFilter</code> 和 <code>dstFilter</code>：分别是源图像和目标图像的滤波器。如果不使用滤波器，可以传递 <code>NULL</code>。</li>
<li><code>param</code>：用于设置特定参数的指针数组。通常情况下，可以传递 <code>NULL</code>。</li>
</ul>
<p>调用 <code>sws_getContext()</code> 函数将会创建一个图像转换器上下文，并返回一个指向该上下文的指针。通过这个上下文，您可以执行图像的像素格式转换、尺寸缩放等操作。</p>
<p>一旦创建了图像转换器上下文，您就可以使用 <code>sws_scale()</code> 函数来执行实际的图像转换操作。该函数将源图像转换为目标图像，同时进行必要的缩放和格式转换。在完成图像转换后，您需要调用 <code>sws_freeContext()</code> 函数来释放图像转换器上下文，以避免内存泄漏。</p>
<p>图像转换器上下文的创建和释放通常是在图像处理流程的开始和结束时进行的。在实际应用中，您可以根据需要多次创建和释放图像转换器上下文，以便处理不同格式和尺寸的图像。</p>
<h2 id="ffmpeg-avcodec-open2-函数-详解"><a href="#ffmpeg-avcodec-open2-函数-详解" class="headerlink" title="ffmpeg avcodec_open2() 函数 详解"></a>ffmpeg avcodec_open2() 函数 详解</h2><p><code>avcodec_open2()</code> 函数是 FFmpeg 中的一个函数，用于初始化编解码器的上下文，并打开编解码器。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">avcodec_open2</span><span class="params">(AVCodecContext *avctx, <span class="type">const</span> AVCodec *codec, AVDictionary **options)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>avctx</code> 是指向 <code>AVCodecContext</code> 结构的指针，表示要初始化和打开的编解码器的上下文；<code>codec</code> 是一个指向 <code>AVCodec</code> 结构的指针，表示要使用的编解码器；<code>options</code> 是一个指向指向 <code>AVDictionary</code> 结构的指针的指针，用于设置额外的选项。</p>
<p>调用 <code>avcodec_open2()</code> 函数后，将会根据给定的 <code>codec</code> 参数初始化并打开 <code>avctx</code> 表示的编解码器上下文。</p>
<p>这个函数在解码视频或音频之前通常需要被调用。在调用该函数之前，需要确保 <code>AVCodecContext</code> 结构已经被正确地设置了编解码器相关的参数。而且，<code>codec</code> 参数需要通过 <code>avcodec_find_decoder()</code> 或其他相关函数找到并指定为相应的解码器。</p>
<p>此外，您可以通过 <code>options</code> 参数传递一些额外的选项给编解码器。这个参数通常是一个字典，包含了一些键值对，用于设置编解码器的一些特定选项，例如编码器的配置参数、输出格式等。</p>
<p>需要注意的是，如果调用成功，<code>avcodec_open2()</code> 函数将返回零。如果发生错误，将会返回一个负值，表示打开编解码器失败的原因。</p>
<p>在使用完编解码器后，通常需要调用 <code>avcodec_close()</code> 函数来关闭编解码器并释放相关资源。</p>
<h2 id="ffmpeg-avcodec-alloc-context3-函数-详解"><a href="#ffmpeg-avcodec-alloc-context3-函数-详解" class="headerlink" title="ffmpeg avcodec_alloc_context3() 函数 详解"></a>ffmpeg avcodec_alloc_context3() 函数 详解</h2><p><code>avcodec_alloc_context3()</code> 是 FFmpeg 中的一个函数，用于分配一个新的 <code>AVCodecContext</code> 结构，并返回一个指向该结构的指针。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVCodecContext *<span class="title function_">avcodec_alloc_context3</span><span class="params">(<span class="type">const</span> AVCodec *codec)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>codec</code> 参数是一个指向 <code>AVCodec</code> 结构的指针，用于指定要分配上下文的编解码器。</p>
<p><code>AVCodecContext</code> 结构是 FFmpeg 中的一个重要结构，用于存储编解码器的状态信息、编解码参数、输入和输出格式等。在使用 FFmpeg 进行编解码操作时，通常需要先分配一个 <code>AVCodecContext</code> 结构，并对其进行适当的设置，然后才能使用该结构来执行编解码操作。</p>
<p>通过调用 <code>avcodec_alloc_context3()</code> 函数，您可以创建一个新的 <code>AVCodecContext</code> 结构。通常情况下，您可以在查找到要使用的编解码器后，调用该函数来分配一个对应的上下文，并将编解码器的相关参数复制到该上下文中。</p>
<p>需要注意的是，分配的 <code>AVCodecContext</code> 结构在使用完毕后，需要通过调用 <code>avcodec_free_context()</code> 函数来释放内存，以避免内存泄漏问题。</p>
<h2 id="ffmpeg-avcodec-find-decoder-函数-详解"><a href="#ffmpeg-avcodec-find-decoder-函数-详解" class="headerlink" title="ffmpeg avcodec_find_decoder() 函数 详解"></a>ffmpeg avcodec_find_decoder() 函数 详解</h2><p><code>avcodec_find_decoder()</code> 函数是 FFmpeg 中的一个函数，用于查找指定编解码器的解码器。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVCodec *<span class="title function_">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>id</code> 参数是要查找的编解码器的 ID。通常情况下，您可以通过查找编码视频或音频流时获取到的编码器 ID 来调用该函数。</p>
<p>该函数返回一个指向 <code>AVCodec</code> 结构的指针，该结构包含了编解码器的详细信息，包括名称、类型、支持的像素格式等。</p>
<p>使用 <code>avcodec_find_decoder()</code> 函数的典型场景是在解码视频或音频流之前，先根据流的编码器 ID 查找对应的解码器。然后，您可以使用返回的 <code>AVCodec</code> 结构中的信息来初始化解码器并进行解码操作。</p>
<p>需要注意的是，查找编解码器的过程是基于 FFmpeg 中已注册的编解码器列表进行的。因此，在使用该函数之前，您需要确保已经调用了 <code>av_register_all()</code> 或者其他相关的注册函数，以确保 FFmpeg 能够识别和访问所有可用的编解码器。</p>
<h2 id="ffmpeg-avcodec-parameters-to-context-函数-详解"><a href="#ffmpeg-avcodec-parameters-to-context-函数-详解" class="headerlink" title="ffmpeg avcodec_parameters_to_context() 函数 详解"></a>ffmpeg avcodec_parameters_to_context() 函数 详解</h2><p><code>avcodec_parameters_to_context()</code> 函数是 FFmpeg 中的一个函数，用于将 <code>AVCodecParameters</code> 结构中的编解码器参数复制到 <code>AVCodecContext</code> 结构中。</p>
<p>在 FFmpeg 中，<code>AVCodecParameters</code> 结构包含了描述音频或视频流的编码参数的信息，例如编码类型、图像大小、帧率等。而 <code>AVCodecContext</code> 结构则是编解码器的上下文，包含了编解码器的状态信息、编解码选项等。</p>
<p><code>avcodec_parameters_to_context()</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">avcodec_parameters_to_context</span><span class="params">(AVCodecContext *codec, <span class="type">const</span> AVCodecParameters *par)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>codec</code> 是指向目标 <code>AVCodecContext</code> 结构的指针，<code>par</code> 是指向源 <code>AVCodecParameters</code> 结构的指针。</p>
<p>该函数将 <code>par</code> 中的编解码器参数复制到 <code>codec</code> 中，使 <code>codec</code> 中的属性与 <code>par</code> 中的属性匹配。这样做的目的是为了使得在使用 FFmpeg 进行编解码时，可以直接使用 <code>AVCodecContext</code> 中的属性，而无需重新设置这些属性。</p>
<p>例如，您可以使用该函数将解码器参数复制到解码器的上下文中，以便初始化解码器并进行解码操作。</p>
<p>需要注意的是，调用该函数后，<code>AVCodecContext</code> 中的属性会被 <code>AVCodecParameters</code> 中的属性所覆盖。因此，在调用该函数之后，您可能需要检查 <code>AVCodecContext</code> 中的属性是否正确设置，或者根据需要进行进一步的调整。</p>
<h2 id="ffmpeg-avformat-network-init-函数-详解"><a href="#ffmpeg-avformat-network-init-函数-详解" class="headerlink" title="ffmpeg avformat_network_init() 函数  详解"></a>ffmpeg avformat_network_init() 函数  详解</h2><p><code>avformat_network_init()</code> 函数是FFmpeg库提供的一个函数，用于初始化 FFmpeg 中的网络功能。</p>
<p>以下是对 <code>avformat_network_init()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_network_init()</code> 函数的主要目的是初始化 FFmpeg 中与网络相关的组件，以便处理网络流和网络协议。这包括 HTTP、RTMP、RTP 等协议。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>在处理 FFmpeg 中的网络流或协议时，需要初始化网络子系统，以启用网络相关功能。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>该函数初始化 FFmpeg 中的网络组件，使其能够在网络协议上建立连接、发送请求和接收响应。</li>
<li>它设置了网络操作所需的必要结构和资源。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<ul>
<li>在应用程序开始时，在使用 FFmpeg 函数进行任何网络相关操作之前，通常应调用 <code>avformat_network_init()</code> 函数。</li>
<li>通常在应用程序的初始化阶段调用一次。</li>
</ul>
</li>
<li><p><strong>线程安全性</strong>：</p>
<ul>
<li>值得注意的是，<code>avformat_network_init()</code> 函数不是线程安全的。因此，如果您的应用程序是多线程的，并且在多个线程中使用 FFmpeg，应以线程安全的方式调用此函数，确保它只调用一次，并且在执行任何网络操作之前调用。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_network_init()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化网络组件</span></span><br><span class="line">    avformat_network_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里放置用于网络操作的 FFmpeg 代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    avformat_network_deinit(); <span class="comment">// 函数名中没有提到，但是有一个对应的清理函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li>此函数依赖于提供网络功能的外部库，例如 libavutil、libavcodec 等。确保这些库与您的应用程序正确链接。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_network_init()</code> 函数用于初始化 FFmpeg 中的网络组件，从而使多媒体应用程序能够处理基于网络的输入&#x2F;输出操作。在使用 FFmpeg 处理网络流或协议时，这是一个关键步骤。</p>
<h2 id="ffmpeg-avformat-network-deinit-函数-详解"><a href="#ffmpeg-avformat-network-deinit-函数-详解" class="headerlink" title="ffmpeg avformat_network_deinit() 函数  详解"></a>ffmpeg avformat_network_deinit() 函数  详解</h2><p><code>avformat_network_deinit()</code> 函数是 FFmpeg 库中的一个函数，用于释放 <code>avformat_network_init()</code> 函数所初始化的网络相关资源。以下是对 <code>avformat_network_deinit()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_network_deinit()</code> 函数的主要目的是释放由 <code>avformat_network_init()</code> 函数初始化的网络相关资源。这个函数通常用于在应用程序关闭或不再需要网络功能时进行清理。</li>
</ul>
</li>
<li><p><strong>释放资源</strong>：</p>
<ul>
<li>在使用 <code>avformat_network_init()</code> 函数初始化网络组件后，可能会分配一些资源，例如分配的内存、打开的网络连接等。<code>avformat_network_deinit()</code> 函数用于释放这些资源，以避免资源泄漏或内存泄漏。</li>
</ul>
</li>
<li><p><strong>调用时机</strong>：</p>
<ul>
<li>通常情况下，应在不再需要网络功能时调用 <code>avformat_network_deinit()</code> 函数。例如，在应用程序关闭时或者在不再需要处理网络流或协议时。</li>
</ul>
</li>
<li><p><strong>线程安全性</strong>：</p>
<ul>
<li>与 <code>avformat_network_init()</code> 函数类似，<code>avformat_network_deinit()</code> 函数也不是线程安全的。如果您的应用程序是多线程的，并且在多个线程中使用了 FFmpeg，应以线程安全的方式调用此函数。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_network_deinit()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化网络组件</span></span><br><span class="line">    avformat_network_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里放置用于网络操作的 FFmpeg 代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理网络资源</span></span><br><span class="line">    avformat_network_deinit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li>与 <code>avformat_network_init()</code> 函数相同，<code>avformat_network_deinit()</code> 函数也依赖于外部库，如 libavutil、libavcodec 等。确保这些库与您的应用程序正确链接。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_network_deinit()</code> 函数用于释放 <code>avformat_network_init()</code> 函数初始化的网络相关资源。在不再需要网络功能时，应当调用该函数以避免资源泄漏。</p>
<h2 id="ffmpeg-avformat-alloc-context-函数-详解"><a href="#ffmpeg-avformat-alloc-context-函数-详解" class="headerlink" title="ffmpeg avformat_alloc_context() 函数  详解"></a>ffmpeg avformat_alloc_context() 函数  详解</h2><p><code>avformat_alloc_context()</code> 是 FFmpeg 中的一个函数，用于分配一个 <code>AVFormatContext</code> 结构体，并进行初始化。这个结构体是 FFmpeg 中用来表示输入或输出格式上下文的重要数据结构。</p>
<p>以下是对 <code>avformat_alloc_context()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_alloc_context()</code> 函数的主要目的是为了创建一个 <code>AVFormatContext</code> 结构体，这是 FFmpeg 中用来表示音视频格式的上下文信息的数据结构。这个上下文包含了音视频流、封装格式、编解码器等相关信息。</li>
</ul>
</li>
<li><p><strong>分配和初始化</strong>：</p>
<ul>
<li>此函数分配了一个 <code>AVFormatContext</code> 结构体，并对其进行了初始化，以便后续可以使用该结构体进行音视频处理操作。</li>
</ul>
</li>
<li><p><strong>使用方法</strong>：</p>
<ul>
<li>在使用 <code>avformat_alloc_context()</code> 函数后，可以通过设置 <code>AVFormatContext</code> 结构体中的各种属性来定义音视频文件的格式和编解码器等信息。</li>
<li>在打开、创建或解析音视频文件时，通常会使用此函数来创建一个 <code>AVFormatContext</code> 结构体，并在后续的操作中传递和使用该结构体。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_alloc_context()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 分配 AVFormatContext 结构体</span></span><br><span class="line">    AVFormatContext *formatContext = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!formatContext) &#123;</span><br><span class="line">        <span class="comment">// 分配失败</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error allocating format context\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续操作，设置或使用 formatContext</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 AVFormatContext 结构体</span></span><br><span class="line">    avformat_free_context(formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_alloc_context()</code> 函数本身并不依赖外部库，但是创建的 <code>AVFormatContext</code> 结构体在使用过程中可能涉及到其他 FFmpeg 库函数，这些函数可能会依赖于其他外部库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_alloc_context()</code> 函数用于创建并初始化一个 <code>AVFormatContext</code> 结构体，该结构体在 FFmpeg 中用于表示音视频文件的格式和相关信息。在进行音视频文件处理时，通常会使用此函数来创建一个格式上下文，并在后续的操作中使用该上下文。</p>
<h2 id="ffmpeg-av-dict-set-函数-详解"><a href="#ffmpeg-av-dict-set-函数-详解" class="headerlink" title="ffmpeg av_dict_set() 函数  详解"></a>ffmpeg av_dict_set() 函数  详解</h2><p><code>av_dict_set()</code> 函数是 FFmpeg 中用于设置字典（dictionary）中键值对的函数。这个函数主要用于向字典中添加或修改键值对。</p>
<p>以下是对 <code>av_dict_set()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_dict_set()</code> 函数的主要目的是在字典中设置键值对。在 FFmpeg 中，字典通常用于存储各种元数据、选项或参数。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVDictionary **dict</code>：指向指针的指针，指向需要设置键值对的字典。这个指针可以是指向 NULL 的空指针，如果字典不存在，则会自动创建一个新的字典。</li>
<li><code>const char *key</code>：要设置的键的名称。</li>
<li><code>const char *value</code>：要设置的值。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>如果字典中已存在具有相同键的条目，则此函数将替换现有条目的值。</li>
<li>如果字典中不存在具有相同键的条目，则此函数将在字典中添加一个新的键值对。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_dict_set()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/dict.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVDictionary *dict = <span class="literal">NULL</span>; <span class="comment">// 定义一个空字典</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置键值对到字典中</span></span><br><span class="line">    av_dict_set(&amp;dict, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    av_dict_set(&amp;dict, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 av_dict_set() 后，字典中将包含以下键值对：</span></span><br><span class="line">    <span class="comment">// &quot;key1&quot; -&gt; &quot;value1&quot;</span></span><br><span class="line">    <span class="comment">// &quot;key2&quot; -&gt; &quot;value2&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放字典</span></span><br><span class="line">    av_dict_free(&amp;dict);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_dict_set()</code> 函数本身并不依赖外部库，但是创建的字典在使用过程中可能涉及到其他 FFmpeg 库函数，这些函数可能会依赖于其他外部库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_dict_set()</code> 函数用于设置字典中的键值对。通过这个函数，可以向字典中添加新的键值对，或者修改现有键的值。在处理 FFmpeg 中的元数据、选项或参数时，通常会使用这个函数来管理字典中的键值对。</p>
<h2 id="ffmpeg-avformat-open-input-函数-详解"><a href="#ffmpeg-avformat-open-input-函数-详解" class="headerlink" title="ffmpeg avformat_open_input() 函数  详解"></a>ffmpeg avformat_open_input() 函数  详解</h2><p><code>avformat_open_input()</code> 是 FFmpeg 中用于打开输入音视频文件或流的函数。这个函数负责初始化并打开一个输入格式上下文，以便后续可以进行音视频解码、编码或者其他处理操作。</p>
<p>以下是对 <code>avformat_open_input()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_open_input()</code> 函数的主要目的是打开一个输入音视频文件或者流，并为后续的音视频处理操作创建一个输入格式上下文（<code>AVFormatContext</code>）。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext **ps</code>：指向指针的指针，用于存储创建的输入格式上下文。</li>
<li><code>const char *url</code>：输入文件的 URL 或者文件名。</li>
<li><code>AVInputFormat *fmt</code>：输入文件的格式，通常可以传入 NULL 以让 FFmpeg 自动检测输入文件的格式。</li>
<li><code>AVDictionary **options</code>：附加选项，例如设置解码器选项等。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_open_input()</code> 函数会根据提供的 URL 或者文件名打开相应的音视频文件或者流，并将文件的格式信息存储在创建的输入格式上下文中。</li>
<li>如果指定了输入文件的格式（<code>fmt</code> 参数不为 NULL），则 FFmpeg 会尝试以指定的格式打开文件。否则，它将会自动检测文件的格式。</li>
<li>可以通过 <code>options</code> 参数传递一些附加选项，例如设置解码器选项、设置连接超时等。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_open_input()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入文件</span></span><br><span class="line">    <span class="type">int</span> ret = avformat_open_input(&amp;formatContext, <span class="string">&quot;input.mp4&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 打开失败</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open input file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续操作，例如解码、编码等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输入文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_open_input()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_open_input()</code> 函数用于打开输入音视频文件或者流，并创建一个输入格式上下文，以便后续进行音视频处理操作。在处理音视频文件时，通常会使用这个函数来打开输入文件，以便后续进行解码、编码或其他处理。</p>
<h2 id="ffmpeg-avformat-find-stream-info-函数-详解"><a href="#ffmpeg-avformat-find-stream-info-函数-详解" class="headerlink" title="ffmpeg avformat_find_stream_info() 函数  详解"></a>ffmpeg avformat_find_stream_info() 函数  详解</h2><p><code>avformat_find_stream_info()</code> 函数是 FFmpeg 中用于获取音视频文件或流的基本信息的函数。它会尝试从输入的音视频文件或流中提取流信息，如编解码器、时长、帧率等，并填充到 <code>AVFormatContext</code> 结构体中的 <code>streams</code> 数组中的 <code>AVStream</code> 结构体中。</p>
<p>以下是对 <code>avformat_find_stream_info()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_find_stream_info()</code> 函数的主要目的是从音视频文件或流中提取流信息。这些信息包括每个音视频流的编解码器、时长、帧率、分辨率等。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *ic</code>：指向已经打开的输入格式上下文的指针。</li>
<li><code>AVDictionary **options</code>：附加选项，用于设置解码器选项等。通常可以传入 NULL。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_find_stream_info()</code> 函数会在已打开的输入格式上下文中尝试从文件或流中读取流信息，并将这些信息填充到 <code>AVFormatContext</code> 结构体中的 <code>streams</code> 数组中的 <code>AVStream</code> 结构体中。</li>
<li>它会尝试解码几个帧来获取一些基本信息，例如帧率、分辨率等。这些信息对于后续的音视频处理操作非常重要。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。如果在读取流信息时需要进行一些解码操作，可能会返回 <code>AVERROR(EAGAIN)</code>，表示需要更多数据才能继续解码。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_find_stream_info()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入文件</span></span><br><span class="line">    <span class="type">int</span> ret = avformat_open_input(&amp;formatContext, <span class="string">&quot;input.mp4&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open input file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取流信息</span></span><br><span class="line">    ret = avformat_find_stream_info(formatContext, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to find stream information\n&quot;</span>);</span><br><span class="line">        avformat_close_input(&amp;formatContext);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流信息现在可以在 formatContext-&gt;streams 中访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输入文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_find_stream_info()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_find_stream_info()</code> 函数用于从音视频文件或流中提取流信息，并填充到 <code>AVFormatContext</code> 结构体中的 <code>streams</code> 数组中的 <code>AVStream</code> 结构体中。在处理音视频文件时，通常会在打开文件后调用这个函数，以便获取文件的基本信息，从而为后续的处理操作做准备。</p>
<h2 id="ffmpeg-avformat-alloc-output-context2-函数-详解"><a href="#ffmpeg-avformat-alloc-output-context2-函数-详解" class="headerlink" title="ffmpeg avformat_alloc_output_context2() 函数  详解"></a>ffmpeg avformat_alloc_output_context2() 函数  详解</h2><p><code>avformat_alloc_output_context2()</code> 是 FFmpeg 中用于创建输出格式上下文的函数。它用于分配并初始化一个 <code>AVFormatContext</code> 结构体，用于封装输出的音视频数据流。</p>
<p>以下是对 <code>avformat_alloc_output_context2()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_alloc_output_context2()</code> 函数的主要目的是创建一个输出格式上下文，用于封装输出的音视频数据流。这个函数通常用于编码和封装音视频文件，生成最终的音视频文件或者流。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext **ctx</code>：指向指针的指针，用于存储创建的输出格式上下文。</li>
<li><code>AVOutputFormat *oformat</code>：要使用的输出格式，通常可以传入 NULL 以让 FFmpeg 自动选择输出格式。</li>
<li><code>const char *format_name</code>：指定要输出的格式的名称，例如 “mp4”、”flv” 等。</li>
<li><code>const char *filename</code>：输出文件的路径或者 URL。</li>
<li><code>AVDictionary **options</code>：附加选项，例如设置编码器选项、容器格式选项等。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_alloc_output_context2()</code> 函数会根据指定的输出格式或者输出文件的扩展名创建一个输出格式上下文。</li>
<li>它将会为这个输出格式上下文分配内存，并对其进行初始化，以便后续可以进行音视频编码和封装操作。</li>
<li>可以通过 <code>options</code> 参数传递一些附加选项，例如设置编码器选项、容器格式选项等。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_alloc_output_context2()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出格式上下文</span></span><br><span class="line">    <span class="type">int</span> ret = avformat_alloc_output_context2(&amp;formatContext, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;output.mp4&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create output format context\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续操作，例如设置编码器、添加音视频流等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放输出格式上下文</span></span><br><span class="line">    avformat_free_context(formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_alloc_output_context2()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_alloc_output_context2()</code> 函数用于创建输出格式上下文，用于封装输出的音视频数据流。在编码和封装音视频文件时，通常会使用这个函数来创建一个输出格式上下文，以便后续进行编码和封装操作。</p>
<h2 id="ffmpeg-avformat-new-stream-函数-详解"><a href="#ffmpeg-avformat-new-stream-函数-详解" class="headerlink" title="ffmpeg avformat_new_stream() 函数  详解"></a>ffmpeg avformat_new_stream() 函数  详解</h2><p><code>avformat_new_stream()</code> 函数是 FFmpeg 中用于创建新的音视频流的函数。它用于向输出格式上下文中添加一个新的音视频流，并返回一个指向该流的指针。</p>
<p>以下是对 <code>avformat_new_stream()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_new_stream()</code> 函数的主要目的是创建一个新的音视频流，并将其添加到输出格式上下文中。这个函数通常用于在封装音视频文件时向文件中添加新的音视频流。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *s</code>：指向输出格式上下文的指针，表示要向哪个输出格式上下文中添加新的音视频流。</li>
<li><code>const AVCodec *c</code>：表示新创建的流将使用的编解码器。可以为 NULL，表示不指定编解码器，后续可以手动设置。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值是一个指向新创建的音视频流的指针（<code>AVStream*</code>）。如果创建失败或者输出格式上下文没有被分配，则返回 NULL。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_new_stream()</code> 函数会在输出格式上下文中添加一个新的音视频流，并返回一个指向该流的指针。</li>
<li>新创建的音视频流将会被添加到输出格式上下文的 <code>streams</code> 数组中，并被编号为数组中的索引值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_new_stream()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line">    AVStream *stream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出格式上下文</span></span><br><span class="line">    avformat_alloc_output_context2(&amp;formatContext, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;output.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个音视频流</span></span><br><span class="line">    stream = avformat_new_stream(formatContext, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!stream) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create new stream\n&quot;</span>);</span><br><span class="line">        avformat_free_context(formatContext);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新创建的音视频流的参数，例如编码器、分辨率、帧率等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放输出格式上下文</span></span><br><span class="line">    avformat_free_context(formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_new_stream()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_new_stream()</code> 函数用于创建一个新的音视频流，并将其添加到输出格式上下文中。在封装音视频文件时，通常会使用这个函数来向输出文件中添加新的音视频流。</p>
<h2 id="ffmpeg-avcodec-parameters-copy-函数-详解"><a href="#ffmpeg-avcodec-parameters-copy-函数-详解" class="headerlink" title="ffmpeg avcodec_parameters_copy() 函数  详解"></a>ffmpeg avcodec_parameters_copy() 函数  详解</h2><p><code>avcodec_parameters_copy()</code> 函数是 FFmpeg 中用于复制编解码器参数的函数。它用于将源编解码器参数复制到目标编解码器参数，以便在不同的上下文中重用参数。</p>
<p>以下是对 <code>avcodec_parameters_copy()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avcodec_parameters_copy()</code> 函数的主要目的是将一个编解码器参数结构体的内容复制到另一个编解码器参数结构体中。这样可以在不同的编解码器或者上下文中重用参数。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVCodecParameters *dst</code>：目标编解码器参数结构体指针，用于存储复制后的参数。</li>
<li><code>const AVCodecParameters *src</code>：源编解码器参数结构体指针，要复制的参数将从这里获取。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avcodec_parameters_copy()</code> 函数会将源编解码器参数结构体中的参数值复制到目标编解码器参数结构体中。</li>
<li>它将会复制编解码器的类型、格式、分辨率、帧率、比特率等参数。</li>
<li>这个函数通常用于在不同的上下文中重用编解码器参数，例如在转码、封装、解封装等操作中。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avcodec_parameters_copy()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVCodecParameters *dst_params = avcodec_parameters_alloc();</span><br><span class="line">    AVCodecParameters *src_params = avcodec_parameters_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设已经设置了 src_params 中的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制编解码器参数</span></span><br><span class="line">    <span class="type">int</span> ret = avcodec_parameters_copy(dst_params, src_params);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to copy codec parameters\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在 dst_params 中包含了与 src_params 相同的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    avcodec_parameters_free(&amp;dst_params);</span><br><span class="line">    avcodec_parameters_free(&amp;src_params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avcodec_parameters_copy()</code> 函数依赖于 FFmpeg 的 libavcodec 库，该库负责处理各种音视频编解码器。因此，在使用这个函数之前，需要确保正确链接了 libavcodec 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avcodec_parameters_copy()</code> 函数用于复制编解码器参数结构体的内容，以便在不同的上下文中重用参数。在处理音视频编解码器参数时，通常会使用这个函数来复制参数结构体，以确保在不同的操作中使用相同的参数设置。</p>
<h2 id="ffmpeg-avio-open-函数-详解"><a href="#ffmpeg-avio-open-函数-详解" class="headerlink" title="ffmpeg avio_open() 函数  详解"></a>ffmpeg avio_open() 函数  详解</h2><p><code>avio_open()</code> 函数是 FFmpeg 中用于打开媒体文件或者流的函数。它用于初始化 AVIOContext 结构体，以便后续可以通过该上下文读取或者写入媒体数据。</p>
<p>以下是对 <code>avio_open()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avio_open()</code> 函数的主要目的是打开媒体文件或者流，并为后续的读取或写入操作创建一个 AVIOContext 结构体。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVIOContext **s</code>：指向指针的指针，用于存储创建的 AVIOContext 结构体。</li>
<li><code>const char *url</code>：媒体文件的 URL 或者文件名。</li>
<li><code>int flags</code>：打开文件的标志位，可以指定为 <code>AVIO_FLAG_READ</code>（只读）、<code>AVIO_FLAG_WRITE</code>（只写）、<code>AVIO_FLAG_READ_WRITE</code>（读写）等。</li>
<li><code>const AVIOInterruptCB *int_cb</code>：中断回调函数，用于处理中断事件。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avio_open()</code> 函数会根据指定的 URL 或者文件名打开对应的媒体文件或者流，并为其创建一个 AVIOContext 结构体。</li>
<li>AVIOContext 结构体是用于媒体数据的输入输出上下文，它提供了读取或者写入媒体数据的接口。</li>
<li>可以通过 flags 参数指定打开文件的模式，例如只读、只写或者读写模式。</li>
<li>可以通过 int_cb 参数设置中断回调函数，用于处理中断事件。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avio_open()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVIOContext *avio_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开媒体文件</span></span><br><span class="line">    <span class="type">int</span> ret = avio_open(&amp;avio_ctx, <span class="string">&quot;input.mp4&quot;</span>, AVIO_FLAG_READ);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open input file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续操作，例如读取媒体数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭媒体文件</span></span><br><span class="line">    avio_close(avio_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avio_open()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avio_open()</code> 函数用于打开媒体文件或者流，并为后续的读取或写入操作创建一个 AVIOContext 结构体。在处理媒体文件时，通常会使用这个函数来打开文件，并通过 AVIOContext 结构体读取或者写入媒体数据。</p>
<h2 id="ffmpeg-avformat-write-header-函数-详解"><a href="#ffmpeg-avformat-write-header-函数-详解" class="headerlink" title="ffmpeg avformat_write_header() 函数  详解"></a>ffmpeg avformat_write_header() 函数  详解</h2><p><code>avformat_write_header()</code> 函数是 FFmpeg 中用于写入输出文件的头部信息的函数。在使用 FFmpeg 进行音视频编码和封装时，通常需要在开始写入数据之前调用该函数，以确保输出文件的头部信息正确设置。</p>
<p>以下是对 <code>avformat_write_header()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_write_header()</code> 函数的主要目的是将输出文件的头部信息写入到输出文件中。这个头部信息包括文件格式、流信息、编解码器信息等。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *s</code>：指向已经创建的输出格式上下文的指针。这个上下文包含了输出文件的各种信息。</li>
<li><code>const AVDictionary *options</code>：附加选项，用于设置输出文件的一些额外信息。通常可以传入 NULL。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_write_header()</code> 函数会根据输出格式上下文中的信息，将文件的头部信息写入到输出文件中。</li>
<li>头部信息包括文件格式的标识、流的编码器参数、文件的元数据等。这些信息对于后续的解码或者播放是非常重要的。</li>
<li>在调用该函数之前，需要确保已经通过其他函数设置了输出格式上下文中的各种参数，例如添加音视频流、设置编码器参数等。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_write_header()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出格式上下文，添加音视频流等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输出文件</span></span><br><span class="line">    <span class="type">int</span> ret = avio_open(&amp;formatContext-&gt;pb, <span class="string">&quot;output.mp4&quot;</span>, AVIO_FLAG_WRITE);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open output file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入文件头部信息</span></span><br><span class="line">    ret = avformat_write_header(formatContext, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error writing header\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续操作，例如写入音视频帧数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输出文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_write_header()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_write_header()</code> 函数用于将输出文件的头部信息写入到输出文件中。在使用 FFmpeg 进行音视频编码和封装时，通常会在开始写入数据之前调用该函数，以确保输出文件的头部信息正确设置。</p>
<h2 id="ffmpeg-av-gettime-函数-详解"><a href="#ffmpeg-av-gettime-函数-详解" class="headerlink" title="ffmpeg av_gettime() 函数  详解"></a>ffmpeg av_gettime() 函数  详解</h2><p><code>av_gettime()</code> 是 FFmpeg 中用于获取当前时间的函数。它返回以微秒为单位的当前系统时间，可以用于测量时间间隔、计算程序执行时间等。</p>
<p>以下是对 <code>av_gettime()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_gettime()</code> 函数的主要目的是获取当前系统时间，以微秒为单位。它通常用于测量时间间隔、计算程序执行时间等。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li>该函数没有参数。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_gettime()</code> 函数返回当前系统时间，以微秒为单位。它返回的是自某个固定时间点以来的纳秒数。</li>
<li>时间点的起始值并不重要，只要能够正确计算时间间隔即可。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为 <code>int64_t</code> 类型，表示以微秒为单位的当前系统时间。如果系统支持高精度时钟，可能会返回更高精度的时间。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_gettime()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> start_time, end_time, elapsed_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取开始时间</span></span><br><span class="line">    start_time = av_gettime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些操作，例如编解码、处理数据等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结束时间</span></span><br><span class="line">    end_time = av_gettime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算时间间隔</span></span><br><span class="line">    elapsed_time = end_time - start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印时间间隔（以微秒为单位）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Elapsed time: %&quot;</span>PRId64<span class="string">&quot; microseconds\n&quot;</span>, elapsed_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_gettime()</code> 函数依赖于 FFmpeg 的 libavutil 库，该库提供了一些常用的工具函数。因此，在使用这个函数之前，需要确保正确链接了 libavutil 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_gettime()</code> 函数用于获取当前系统时间，以微秒为单位。它可以用于测量时间间隔、计算程序执行时间等。在处理音视频数据时，通常会使用这个函数来评估处理操作的性能或者控制处理速度。</p>
<h2 id="ffmpeg-av-read-frame-函数-详解"><a href="#ffmpeg-av-read-frame-函数-详解" class="headerlink" title="ffmpeg av_read_frame() 函数  详解"></a>ffmpeg av_read_frame() 函数  详解</h2><p><code>av_read_frame()</code> 函数是 FFmpeg 中用于从输入文件中读取音视频帧数据的函数。它从已打开的输入格式上下文中读取下一帧数据，并存储在 AVPacket 结构体中。</p>
<p>以下是对 <code>av_read_frame()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_read_frame()</code> 函数的主要目的是从已打开的输入文件中读取下一帧音视频数据，并将其存储在 AVPacket 结构体中。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *s</code>：指向已经打开的输入格式上下文的指针。这个上下文包含了输入文件的各种信息。</li>
<li><code>AVPacket *pkt</code>：指向 AVPacket 结构体的指针，用于存储读取到的音视频帧数据。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_read_frame()</code> 函数会从输入文件中读取下一帧音视频数据，并将其存储在 AVPacket 结构体中。</li>
<li>输入文件中的音视频数据通常被封装为一系列的帧，每个帧都包含了一定时间范围内的音视频数据。</li>
<li>函数会自动选择合适的流，并从这些流中读取下一帧数据。如果某个流中没有数据可读，函数将会等待直到有数据可读。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果成功读取了一帧数据，则返回0；如果出现错误或者到达文件尾部，则返回负值。一般来说，返回值小于0时表示读取出错或者已到达文件结尾。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_read_frame()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket packet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入文件</span></span><br><span class="line">    <span class="type">int</span> ret = avformat_open_input(&amp;formatContext, <span class="string">&quot;input.mp4&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open input file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取帧数据</span></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(formatContext, &amp;packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理音视频帧数据，例如解码、处理等</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放帧数据</span></span><br><span class="line">        av_packet_unref(&amp;packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输入文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_read_frame()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_read_frame()</code> 函数用于从输入文件中读取音视频帧数据，并将其存储在 AVPacket 结构体中。在处理音视频文件时，通常会使用这个函数来读取文件中的音视频数据，以便后续进行解码、处理或者播放操作。</p>
<h2 id="ffmpeg-av-packet-rescale-ts-函数-详解"><a href="#ffmpeg-av-packet-rescale-ts-函数-详解" class="headerlink" title="ffmpeg av_packet_rescale_ts() 函数  详解"></a>ffmpeg av_packet_rescale_ts() 函数  详解</h2><p><code>av_packet_rescale_ts()</code> 函数是 FFmpeg 中用于重新调整 AVPacket 中时间戳（timestamp）的函数。它可以将 AVPacket 中的时间戳从一种时间基准（time base）转换到另一种时间基准，通常用于音视频流处理中的时间戳转换操作。</p>
<p>以下是对 <code>av_packet_rescale_ts()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_packet_rescale_ts()</code> 函数的主要目的是重新调整 AVPacket 中的时间戳（timestamp），将其从一个时间基准转换到另一个时间基准。这个函数通常用于音视频流处理中，用于处理不同时间基准下的音视频帧数据。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>const AVPacket *pkt</code>：指向待处理的 AVPacket 结构体的指针，其中包含了要重新调整时间戳的音视频帧数据。</li>
<li><code>AVRational tb_src</code>：源时间基准，即 AVPacket 中时间戳的原始时间基准。</li>
<li><code>AVRational tb_dst</code>：目标时间基准，即要转换成的时间基准。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_packet_rescale_ts()</code> 函数会根据源时间基准和目标时间基准，重新调整 AVPacket 中的时间戳。</li>
<li>它将会对 AVPacket 中的时间戳进行数学运算，将其转换成目标时间基准下的对应值。</li>
<li>时间戳的时间基准通常用 AVRational 结构体表示，其中包含了分子和分母，用于表示时间单位的比率。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_packet_rescale_ts()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVPacket packet;</span><br><span class="line">    AVRational tb_src, tb_dst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设已经初始化 packet 和设置了源时间基准 tb_src、目标时间基准 tb_dst</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新调整时间戳</span></span><br><span class="line">    av_packet_rescale_ts(&amp;packet, tb_src, tb_dst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续操作，例如处理 packet 中的音视频帧数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_packet_rescale_ts()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_packet_rescale_ts()</code> 函数用于重新调整 AVPacket 中的时间戳，将其从一个时间基准转换到另一个时间基准。在处理音视频流时，通常会使用这个函数来处理不同时间基准下的音视频帧数据，以确保时间戳的一致性和正确性。</p>
<h2 id="ffmpeg-av-interleaved-write-frame-函数-详解"><a href="#ffmpeg-av-interleaved-write-frame-函数-详解" class="headerlink" title="ffmpeg av_interleaved_write_frame() 函数  详解"></a>ffmpeg av_interleaved_write_frame() 函数  详解</h2><p><code>av_interleaved_write_frame()</code> 函数是 FFmpeg 中用于将音视频帧数据写入到输出文件的函数。它将音视频帧数据写入到输出文件，保证音频和视频数据交错存储，符合特定的封装格式要求。</p>
<p>以下是对 <code>av_interleaved_write_frame()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_interleaved_write_frame()</code> 函数的主要目的是将音视频帧数据写入到输出文件，并保证音频和视频数据交错存储，符合特定的封装格式要求。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *s</code>：指向已经创建的输出格式上下文的指针。这个上下文包含了输出文件的各种信息。</li>
<li><code>AVPacket *pkt</code>：指向 AVPacket 结构体的指针，其中包含了要写入到输出文件的音视频帧数据。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_interleaved_write_frame()</code> 函数会将音视频帧数据写入到输出文件。</li>
<li>在写入到输出文件时，它会保证音频和视频数据交错存储，符合特定的封装格式要求。不同的封装格式对音频和视频的存储方式有不同的要求，这个函数会自动处理这些细节。</li>
<li>该函数通常在调用了 <code>avformat_write_header()</code> 函数后，循环调用，将所有音视频帧数据写入到输出文件，直到所有数据都被写入完成，然后再调用 <code>av_write_trailer()</code> 函数完成文件尾部的写入。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果成功写入了音视频帧数据，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_interleaved_write_frame()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket packet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输出文件、写入头部信息等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环写入音视频帧数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="comment">/* 有音视频帧数据需要写入 */</span>) &#123;</span><br><span class="line">        <span class="comment">// 将音视频帧数据写入到 AVPacket 结构体 packet 中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入音视频帧数据到输出文件</span></span><br><span class="line">        <span class="type">int</span> ret = av_interleaved_write_frame(formatContext, &amp;packet);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error writing frame\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入文件尾部信息</span></span><br><span class="line">    av_write_trailer(formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输出文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_interleaved_write_frame()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_interleaved_write_frame()</code> 函数用于将音视频帧数据写入到输出文件，并保证音频和视频数据交错存储，符合特定的封装格式要求。在编码和封装音视频文件时，通常会使用这个函数将所有音视频帧数据写入到输出文件中。</p>
<h2 id="ffmpeg-av-packet-unref-函数-详解"><a href="#ffmpeg-av-packet-unref-函数-详解" class="headerlink" title="ffmpeg av_packet_unref() 函数  详解"></a>ffmpeg av_packet_unref() 函数  详解</h2><p><code>av_packet_unref()</code> 函数是 FFmpeg 中用于释放 AVPacket 结构体的函数。它将 AVPacket 结构体中的数据引用计数减一，并在计数归零时释放结构体所占用的内存空间。</p>
<p>以下是对 <code>av_packet_unref()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_packet_unref()</code> 函数的主要目的是释放 AVPacket 结构体所占用的内存空间，以便重用或释放该结构体。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVPacket *pkt</code>：指向要释放的 AVPacket 结构体的指针。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_packet_unref()</code> 函数会将 AVPacket 结构体中的数据引用计数减一。</li>
<li>当引用计数归零时，函数会释放 AVPacket 结构体所占用的内存空间。</li>
<li>这个函数通常在不再需要使用 AVPacket 结构体时调用，以确保释放内存空间，避免内存泄漏。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>该函数没有返回值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_packet_unref()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVPacket packet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 packet，例如分配内存、设置数据等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 packet 处理音视频帧数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完成后释放 packet</span></span><br><span class="line">    av_packet_unref(&amp;packet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_packet_unref()</code> 函数依赖于 FFmpeg 的 libavcodec 库，该库负责处理音视频编解码相关的操作。因此，在使用这个函数之前，需要确保正确链接了 libavcodec 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_packet_unref()</code> 函数用于释放 AVPacket 结构体所占用的内存空间。在处理音视频帧数据时，通常会使用这个函数在不再需要使用 AVPacket 结构体时释放其内存空间，以避免内存泄漏。</p>
<h2 id="ffmpeg-av-write-trailer-函数-详解"><a href="#ffmpeg-av-write-trailer-函数-详解" class="headerlink" title="ffmpeg av_write_trailer() 函数  详解"></a>ffmpeg av_write_trailer() 函数  详解</h2><p><code>av_write_trailer()</code> 函数是 FFmpeg 中用于写入封装格式的文件尾部信息的函数。在音视频文件封装过程中，通常会在所有音视频帧数据写入完成后调用该函数，以完成文件的封装过程。</p>
<p>以下是对 <code>av_write_trailer()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_write_trailer()</code> 函数的主要目的是完成封装格式的文件尾部信息的写入。这个函数在音视频文件封装过程中是必不可少的一步，它确保文件的封装过程完成。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *s</code>：指向已经创建的输出格式上下文的指针。这个上下文包含了输出文件的各种信息。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_write_trailer()</code> 函数会在所有音视频帧数据写入完成后，写入封装格式的文件尾部信息。</li>
<li>在文件尾部信息中，通常包含了一些与文件格式相关的元数据，例如索引信息、文件格式标识、流结尾标识等。</li>
<li>调用该函数后，输出文件将被关闭，不再允许写入操作。因此，该函数通常是封装过程的最后一步。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_write_trailer()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输出文件、写入头部信息等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入音视频帧数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入文件尾部信息</span></span><br><span class="line">    <span class="type">int</span> ret = av_write_trailer(formatContext);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error writing trailer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输出文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_write_trailer()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_write_trailer()</code> 函数用于写入封装格式的文件尾部信息，以完成音视频文件的封装过程。在处理音视频文件时，通常会在所有音视频帧数据写入完成后调用该函数，以确保文件的完整性和正确性。</p>
<h2 id="ffmpeg-avformat-close-input-函数-详解"><a href="#ffmpeg-avformat-close-input-函数-详解" class="headerlink" title="ffmpeg avformat_close_input() 函数  详解"></a>ffmpeg avformat_close_input() 函数  详解</h2><p><code>avformat_close_input()</code> 函数是 FFmpeg 中用于关闭已打开的输入文件的函数。它释放与输入文件相关的资源，并关闭输入文件。</p>
<p>以下是对 <code>avformat_close_input()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_close_input()</code> 函数的主要目的是关闭已打开的输入文件，并释放与输入文件相关的资源。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext **ps</code>：指向已经打开的输入格式上下文的指针的指针。在函数调用完成后，指针会被设置为 NULL。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_close_input()</code> 函数会释放与输入文件相关的资源，并关闭输入文件。</li>
<li>这个函数通常在不再需要读取输入文件时调用，以确保释放输入文件占用的资源，避免资源泄漏。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_close_input()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入文件</span></span><br><span class="line">    <span class="type">int</span> ret = avformat_open_input(&amp;formatContext, <span class="string">&quot;input.mp4&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open input file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取音视频帧数据等操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输入文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_close_input()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_close_input()</code> 函数用于关闭已打开的输入文件，并释放与输入文件相关的资源。在读取完毕输入文件并不再需要时，通常会使用这个函数关闭输入文件，以避免资源泄漏。</p>
<h2 id="ffmpeg-avio-closep-函数-详解"><a href="#ffmpeg-avio-closep-函数-详解" class="headerlink" title="ffmpeg avio_closep() 函数  详解"></a>ffmpeg avio_closep() 函数  详解</h2><p><code>avio_closep()</code> 函数是 FFmpeg 中用于关闭通过 <code>avio_open()</code> 函数打开的输入&#x2F;输出上下文的函数。它会关闭并释放相应的资源，以确保资源被正确释放，避免资源泄漏。</p>
<p>以下是对 <code>avio_closep()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avio_closep()</code> 函数的主要目的是关闭通过 <code>avio_open()</code> 函数打开的输入&#x2F;输出上下文，并释放相应的资源。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVIOContext **s</code>：指向指针的指针，用于存储输入&#x2F;输出上下文的地址。这个指针在函数调用后将被置为 NULL。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avio_closep()</code> 函数会关闭通过 <code>avio_open()</code> 函数打开的输入&#x2F;输出上下文。</li>
<li>在关闭输入&#x2F;输出上下文之前，函数会确保已经将缓冲区中的数据刷新到文件中，以确保数据的完整性。</li>
<li>关闭输入&#x2F;输出上下文后，函数会释放相应的资源，包括关闭文件描述符、释放内存等。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>该函数没有返回值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avio_closep()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVIOContext *avio_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入/输出文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输入/输出文件</span></span><br><span class="line">    avio_closep(&amp;avio_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avio_closep()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avio_closep()</code> 函数用于关闭通过 <code>avio_open()</code> 函数打开的输入&#x2F;输出上下文，并释放相应的资源。在使用 FFmpeg 处理音视频文件时，通常会使用这个函数在不再需要使用输入&#x2F;输出上下文时关闭并释放相关资源，以确保资源被正确释放，避免资源泄漏。</p>
<h2 id="ffmpeg-avformat-free-context-函数-详解"><a href="#ffmpeg-avformat-free-context-函数-详解" class="headerlink" title="ffmpeg avformat_free_context() 函数  详解"></a>ffmpeg avformat_free_context() 函数  详解</h2><p><code>avformat_free_context()</code> 函数是 FFmpeg 中用于释放 AVFormatContext 结构体及其内部资源的函数。它用于释放由 <code>avformat_alloc_context()</code> 函数分配的 AVFormatContext 结构体，以及该结构体内部所包含的流信息、封装器上下文等资源。</p>
<p>以下是对 <code>avformat_free_context()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_free_context()</code> 函数的主要目的是释放 AVFormatContext 结构体及其内部资源，以确保内存被正确释放，避免内存泄漏。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *s</code>：指向要释放的 AVFormatContext 结构体的指针。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_free_context()</code> 函数会释放由 <code>avformat_alloc_context()</code> 函数分配的 AVFormatContext 结构体及其内部资源。</li>
<li>在释放 AVFormatContext 结构体之前，函数会先释放该结构体内部包含的流信息、封装器上下文等资源。</li>
<li>调用这个函数后，AVFormatContext 结构体及其内部资源将不再可用，应该避免在之后的代码中再次使用它们。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>该函数没有返回值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_free_context()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 formatContext 处理音视频文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 AVFormatContext 结构体及其内部资源</span></span><br><span class="line">    avformat_free_context(formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_free_context()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_free_context()</code> 函数用于释放 AVFormatContext 结构体及其内部资源，以确保内存被正确释放，避免内存泄漏。在处理音视频文件时，通常会使用这个函数在不再需要使用 AVFormatContext 结构体时释放相关资源。</p>
<h2 id="ffmpeg-av-dict-free-函数-详解"><a href="#ffmpeg-av-dict-free-函数-详解" class="headerlink" title="ffmpeg av_dict_free() 函数  详解"></a>ffmpeg av_dict_free() 函数  详解</h2><p><code>av_dict_free()</code> 函数是 FFmpeg 中用于释放 AVDictionary 结构体及其内部资源的函数。AVDictionary 结构体用于存储键值对数据，通常用于传递元数据、选项参数等。</p>
<p>以下是对 <code>av_dict_free()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_dict_free()</code> 函数的主要目的是释放 AVDictionary 结构体及其内部资源，以确保内存被正确释放，避免内存泄漏。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVDictionary **m</code>：指向要释放的 AVDictionary 结构体的指针。这个指针在函数调用后将被置为 NULL。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_dict_free()</code> 函数会释放由 FFmpeg 分配的 AVDictionary 结构体及其内部资源。</li>
<li>在释放 AVDictionary 结构体之前，函数会先释放该结构体内部包含的键值对数据。</li>
<li>调用这个函数后，AVDictionary 结构体及其内部资源将不再可用，应该避免在之后的代码中再次使用它们。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>该函数没有返回值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_dict_free()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/dict.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVDictionary *dict = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向字典中添加键值对数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 AVDictionary 结构体及其内部资源</span></span><br><span class="line">    av_dict_free(&amp;dict);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_dict_free()</code> 函数依赖于 FFmpeg 的 libavutil 库，该库提供了一些常用的工具函数。因此，在使用这个函数之前，需要确保正确链接了 libavutil 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_dict_free()</code> 函数用于释放 AVDictionary 结构体及其内部资源，以确保内存被正确释放，避免内存泄漏。在处理音视频文件时，通常会使用这个函数在不再需要使用 AVDictionary 结构体时释放相关资源。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_05_pkg_config/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_05_pkg_config/" class="post-title-link" itemprop="url">linux_2_05_pkg_config</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>pkg-config 工具的笔记</li>
</ul>
<h2 id="linux-pkg-config-是什么"><a href="#linux-pkg-config-是什么" class="headerlink" title="linux pkg-config 是什么"></a>linux pkg-config 是什么</h2><p><code>pkg-config</code> 是一个用于帮助管理软件包依赖关系的工具，特别是在 Linux 系统上。它允许开发者查询已安装的库的信息，以便在编译和链接时正确地设置相关的编译器和链接器选项。</p>
<p>具体而言，<code>pkg-config</code> 主要有以下功能：</p>
<ol>
<li><p><strong>查询已安装库的信息：</strong> 开发者可以使用 <code>pkg-config</code> 查询已安装的库的版本、包含路径、链接标志等信息。</p>
</li>
<li><p><strong>提供正确的编译和链接选项：</strong> 在编译和链接程序时，<code>pkg-config</code> 可以生成正确的编译器和链接器选项，确保程序正确地链接到所需的库。</p>
</li>
<li><p><strong>简化构建过程：</strong> 使用 <code>pkg-config</code> 可以使构建过程更加简化和可移植。开发者可以通过查询库的信息来适应不同的系统和环境。</p>
</li>
</ol>
<p>例如，如果你想编写一个使用 GTK+ 图形库的程序，你可以使用 <code>pkg-config</code> 查询 GTK+ 库的信息，并在编译和链接时使用返回的选项，而不必手动设置这些选项。</p>
<p>以下是 <code>pkg-config</code> 命令的一些基本用法：</p>
<ul>
<li><code>pkg-config --list-all</code>: 列出系统上所有已安装的库和它们的信息。</li>
<li><code>pkg-config --cflags &lt;package&gt;</code>: 返回指定库的编译选项。</li>
<li><code>pkg-config --libs &lt;package&gt;</code>: 返回指定库的链接选项。</li>
</ul>
<p>例如，要获取 GTK+ 库的编译选项，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags gtk+-3.0</span><br></pre></td></tr></table></figure>

<p><code>pkg-config</code> 在许多 Linux 发行版中都是默认安装的，因此大多数开发者可以直接使用它来简化软件构建过程。</p>
<h2 id="pkg-config-详解"><a href="#pkg-config-详解" class="headerlink" title="pkg-config 详解"></a>pkg-config 详解</h2><p><code>pkg-config</code> 是一个在 Linux 和类 Unix 系统中用于获取编译和链接库信息的工具。它可以帮助开发者配置和编译软件项目，以便正确地链接所需的外部库和头文件。以下是关于 <code>pkg-config</code> 的详细解释：</p>
<p><strong>基本用法：</strong><br><code>pkg-config</code> 的基本用法是通过在命令行中调用它，并传递一些选项和参数来获取有关库的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config [options] package-names</span><br></pre></td></tr></table></figure>

<ul>
<li><code>options</code>：一些选项，用于控制 <code>pkg-config</code> 的行为。</li>
<li><code>package-names</code>：要查询的库的名称。它通常是你希望查找的库的名称，如 <code>opencv</code>, <code>gtk+-3.0</code> 等。</li>
</ul>
<p><strong>常用选项：</strong></p>
<ul>
<li><code>--cflags</code>：获取用于编译的头文件路径和编译器选项。</li>
<li><code>--libs</code>：获取用于链接的库路径和链接器选项。</li>
<li><code>--modversion</code>：获取库的版本号。</li>
<li><code>--list-all</code>：列出系统中所有已安装的库及其版本。</li>
</ul>
<p><strong>示例用法：</strong><br>以下是一个使用 <code>pkg-config</code> 的示例，假设你想编译一个使用 GTK+ 3 的简单程序：</p>
<ol>
<li>查询 GTK+ 3 的编译选项（头文件路径和编译器选项）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags gtk+-3.0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询 GTK+ 3 的链接选项（库路径和链接器选项）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --libs gtk+-3.0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编译程序（假设程序名为 <code>myapp</code>）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc myapp.c -o myapp `pkg-config --cflags --libs gtk+-3.0`</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><code>pkg-config</code> 确保了在编译和链接软件时，所需的库路径、头文件路径以及编译和链接选项都是正确的，减少了因为路径错误或选项不匹配而导致的问题。</li>
<li>它是一个跨平台的工具，在多个 Linux 发行版和类 Unix 系统中都可使用。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>要使用 <code>pkg-config</code>，你需要安装相关的库及其开发包（通常是以 <code>-dev</code> 或 <code>-devel</code> 结尾的包）。</li>
<li>一些库可能不支持 <code>pkg-config</code>，或者可能有不同的名称和用法，需要查阅它们的文档。</li>
</ul>
<p>总之，<code>pkg-config</code> 是一个有助于简化库配置和编译过程的工具，它可以提供关于库的编译和链接信息，减少了配置和构建软件项目的复杂性。</p>
<h2 id="pkg-config-常用选项"><a href="#pkg-config-常用选项" class="headerlink" title="pkg-config 常用选项"></a>pkg-config 常用选项</h2><p><code>pkg-config</code> 工具提供了一些常用选项，用于获取有关库的信息，例如头文件路径、库路径和版本等。以下是一些常用的 <code>pkg-config</code> 选项：</p>
<ol>
<li><code>--cflags</code>：用于获取用于编译的头文件路径和编译器选项。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags package-name</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags gtk+-3.0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>--libs</code>：用于获取用于链接的库路径和链接器选项。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --libs package-name</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --libs gtk+-3.0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>--modversion</code>：获取库的版本号。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion package-name</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion opencv</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>--list-all</code>：列出系统中所有已安装的库及其版本。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --list-all</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>--static</code>：获取静态库的链接选项。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --static package-name</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --static zlib</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>--variable</code>：获取特定变量的值，如 <code>pkg-config --variable=prefix package-name</code> 可以获取库的安装路径。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --variable=variable-name package-name</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --variable=prefix opencv</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>--exists</code>：检查库是否存在。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --exists package-name</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --exists libpng</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><code>--help</code>：获取关于 <code>pkg-config</code> 命令的帮助信息。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>这些选项可以根据你的需要来使用，它们可以帮助你获取关于特定库的编译和链接信息，以便在开发过程中正确地配置和编译你的项目。</p>
<h2 id="pkg-config-查看所有库"><a href="#pkg-config-查看所有库" class="headerlink" title="pkg-config 查看所有库"></a>pkg-config 查看所有库</h2><p>要查看系统中安装的所有库及其版本，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --list-all</span><br></pre></td></tr></table></figure>

<p>运行这个命令会列出系统中已安装的所有库的名称和版本信息。输出可能会非常长，所以你可以将输出通过分页工具如 <code>less</code> 进行分页显示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --list-all | less</span><br></pre></td></tr></table></figure>

<p>使用上述命令，你可以查看系统中已经安装的所有库，以便在开发软件项目时了解可用的库资源。</p>
<h2 id="linux-pkg-config-查看指定目录的配置文件"><a href="#linux-pkg-config-查看指定目录的配置文件" class="headerlink" title="linux pkg-config 查看指定目录的配置文件"></a>linux pkg-config 查看指定目录的配置文件</h2><p>要使用<code>pkg-config</code>命令查看指定目录的配置文件，你可以通过设置<code>PKG_CONFIG_PATH</code>环境变量来指定<code>pkg-config</code>应该搜索的目录。然后，你可以使用<code>pkg-config</code>命令来查询指定库的配置信息。</p>
<p>以下是一些步骤：</p>
<ol>
<li>设置<code>PKG_CONFIG_PATH</code>环境变量以包含你希望<code>pkg-config</code>搜索的目录。假设你希望<code>pkg-config</code>在<code>/path/to/your/dir</code>目录中搜索配置文件，你可以执行以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=/path/to/your/dir:<span class="variable">$PKG_CONFIG_PATH</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>pkg-config</code>命令查询指定库的配置信息。例如，如果你想查询<code>libfoo</code>库的配置信息，你可以执行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion libfoo</span><br></pre></td></tr></table></figure>

<p>或者，如果你想获取更多有关该库的信息，你可以执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --libs --cflags libfoo</span><br></pre></td></tr></table></figure>

<p>这将显示用于编译和链接应用程序的选项。</p>
<p>请注意，设置<code>PKG_CONFIG_PATH</code>只是临时的，仅在当前终端会话中有效。如果你希望在每次登录时都设置这个环境变量，你可以将其添加到你的shell配置文件（例如<code>~/.bashrc</code>或<code>~/.bash_profile</code>）中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_01_readme/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_01_readme/" class="post-title-link" itemprop="url">linux_2_01_readme</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux常用命令模块</li>
</ul>
<h2 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h2><ul>
<li><p>other</p>
<ul>
<li>linux_2_02_other</li>
</ul>
</li>
<li><p>pkg_config</p>
<ul>
<li>linux_2_05_pkg_config</li>
</ul>
</li>
<li><p>open_ssh</p>
<ul>
<li>linux_2_06_open_ssh</li>
</ul>
</li>
<li><p>objdump</p>
<ul>
<li>linux_2_07_objdump</li>
</ul>
</li>
<li><p>head</p>
<ul>
<li>linux_2_08_head</li>
</ul>
</li>
<li><p>vim</p>
<ul>
<li>linux_2_09_vim</li>
</ul>
</li>
<li><p>tmux</p>
<ul>
<li>linux_2_10_tmux</li>
</ul>
</li>
<li><p>apt</p>
<ul>
<li>linux_2_11_apt</li>
</ul>
</li>
<li><p>dpkg</p>
<ul>
<li>linux_2_12_dpkg</li>
</ul>
</li>
<li><p>free</p>
<ul>
<li>linux_2_13_free</li>
</ul>
</li>
<li><p>trap</p>
<ul>
<li>linux_2_14_trap</li>
</ul>
</li>
<li><p>read</p>
<ul>
<li>linux_2_15_read</li>
</ul>
</li>
<li><p>more</p>
<ul>
<li>linux_2_16_more</li>
</ul>
</li>
<li><p>less</p>
<ul>
<li>linux_2_17_less</li>
</ul>
</li>
<li><p>nohup</p>
<ul>
<li>linux_2_18_nohup</li>
</ul>
</li>
<li><p>split</p>
<ul>
<li>linux_2_19_split</li>
</ul>
</li>
<li><p>mktemp</p>
<ul>
<li>linux_2_20_mktemp</li>
</ul>
</li>
<li><p>wc</p>
<ul>
<li>linux_2_21_wc</li>
</ul>
</li>
<li><p>ar</p>
<ul>
<li>linux_2_22_ar</li>
</ul>
</li>
<li><p>lsmod</p>
<ul>
<li>linux_2_23_lsmod</li>
</ul>
</li>
<li><p>screen</p>
<ul>
<li>linux_2_24_screen</li>
</ul>
</li>
<li><p>source</p>
<ul>
<li>linux_2_25_source</li>
</ul>
</li>
<li><p>tar</p>
<ul>
<li>linux_2_26_tar</li>
</ul>
</li>
<li><p>df</p>
<ul>
<li>linux_2_27_df</li>
</ul>
</li>
<li><p>useradd</p>
<ul>
<li>linux_2_28_useradd</li>
</ul>
</li>
<li><p>userdel</p>
<ul>
<li>linux_2_29_userdel</li>
</ul>
</li>
<li><p>usermod</p>
<ul>
<li>linux_2_30_usermod</li>
</ul>
</li>
<li><p>grep</p>
<ul>
<li>linux_2_31_grep</li>
</ul>
</li>
<li><p>eval</p>
<ul>
<li>linux_2_32_eval</li>
</ul>
</li>
<li><p>mount</p>
<ul>
<li>linux_2_33_mount</li>
</ul>
</li>
<li><p>export</p>
<ul>
<li>linux_2_34_export</li>
</ul>
</li>
<li><p>awk</p>
<ul>
<li>linux_2_35_awk</li>
</ul>
</li>
<li><p>sed</p>
<ul>
<li>linux_2_36_sed</li>
</ul>
</li>
<li><p>whereis</p>
<ul>
<li>linux_2_37_whereis</li>
</ul>
</li>
<li><p>chown</p>
<ul>
<li>linux_2_38_chown</li>
</ul>
</li>
<li><p>which</p>
<ul>
<li>linux_2_39_which</li>
</ul>
</li>
<li><p>file</p>
<ul>
<li>linux_2_40_file</li>
</ul>
</li>
<li><p>stat</p>
<ul>
<li>linux_2_41_stat</li>
</ul>
</li>
<li><p>realpath</p>
<ul>
<li>linux_2_42_realpath</li>
</ul>
</li>
<li><p>diff</p>
<ul>
<li>linux_2_43_diff</li>
</ul>
</li>
<li><p>patch</p>
<ul>
<li>linux_2_44_patch</li>
</ul>
</li>
<li><p>expr</p>
<ul>
<li>linux_2_45_expr</li>
</ul>
</li>
<li><p>dstat</p>
<ul>
<li>linux_2_46_dstat</li>
</ul>
</li>
<li><p>tail</p>
<ul>
<li>linux_2_47_tail</li>
</ul>
</li>
<li><p>ip</p>
<ul>
<li>linux_2_48_ip</li>
</ul>
</li>
<li><p>systemctl</p>
<ul>
<li>linux_2_49_systemctl</li>
</ul>
</li>
<li><p>loginctl</p>
<ul>
<li>linux_2_50_loginctl</li>
</ul>
</li>
<li><p>lspci</p>
<ul>
<li>linux_2_51_lspci</li>
</ul>
</li>
<li><p>lsmod</p>
<ul>
<li>linux_2_52_lsmod</li>
</ul>
</li>
<li><p>gperf</p>
<ul>
<li>linux_2_53_gperf</li>
</ul>
</li>
<li><p>mkdir</p>
<ul>
<li>linux_2_54_mkdir</li>
</ul>
</li>
<li><p>rename</p>
<ul>
<li>linux_2_55_rename</li>
</ul>
</li>
<li><p>find</p>
<ul>
<li>linux_2_56_find</li>
</ul>
</li>
<li><p>init</p>
<ul>
<li>linux_2_57_init</li>
</ul>
</li>
<li><p>md5sum</p>
<ul>
<li>linux_2_58_md5sum</li>
</ul>
</li>
<li><p>readelf</p>
<ul>
<li>linux_2_59_readelf</li>
</ul>
</li>
<li><p>ldd</p>
<ul>
<li>linux_2_60_ldd</li>
</ul>
</li>
<li><p>watch</p>
<ul>
<li>linux_2_61_watch</li>
</ul>
</li>
<li><p>unset</p>
<ul>
<li>linux_2_62_unset</li>
</ul>
</li>
<li><p>ln</p>
<ul>
<li>linux_2_63_ln</li>
</ul>
</li>
<li><p>snap</p>
<ul>
<li>linux_2_64_snap</li>
</ul>
</li>
<li><p>iostat</p>
<ul>
<li>linux_2_65_iostat</li>
</ul>
</li>
<li><p>dmesg</p>
<ul>
<li>linux_2_66_dmesg</li>
</ul>
</li>
<li><p>pgrep</p>
<ul>
<li>linux_2_67_pgrep</li>
</ul>
</li>
<li><p>ps</p>
<ul>
<li>linux_2_68_ps</li>
</ul>
</li>
<li><p>top</p>
<ul>
<li>linux_2_69_top</li>
</ul>
</li>
<li><p>ss</p>
<ul>
<li>linux_2_70_ss</li>
</ul>
</li>
<li><p>date</p>
<ul>
<li>linux_2_71_date</li>
</ul>
</li>
<li><p>egrep</p>
<ul>
<li>linux_2_72_egrep</li>
</ul>
</li>
<li><p>nc</p>
<ul>
<li>linux_2_73_nc</li>
</ul>
</li>
<li><p>gprof</p>
<ul>
<li>linux_2_74_gprof</li>
</ul>
</li>
<li><p>wget</p>
<ul>
<li>linux_2_75_wget</li>
</ul>
</li>
<li><p>uname</p>
<ul>
<li>linux_2_76_uname</li>
</ul>
</li>
<li><p>valgrind</p>
<ul>
<li>linux_2_77_valgrind</li>
</ul>
</li>
<li><p>gcore</p>
<ul>
<li>linux_2_78_gcore</li>
</ul>
</li>
<li><p>pidstat</p>
<ul>
<li>linux_2_79_pidstat</li>
</ul>
</li>
<li><p>sshpass</p>
<ul>
<li>linux_2_80_sshpass</li>
</ul>
</li>
<li><p>tcpdump</p>
<ul>
<li>linux_2_81_tcpdump</li>
</ul>
</li>
<li><p>alias</p>
<ul>
<li>linux_2_82_alia</li>
</ul>
</li>
<li><p>update-alternatives</p>
<ul>
<li>linux_2_83_update-alternatives</li>
</ul>
</li>
<li><p>blkid</p>
<ul>
<li>linux_2_84_blkid.md</li>
</ul>
</li>
<li><p>autoconf</p>
<ul>
<li>linux_2_85_autoconf.md</li>
</ul>
</li>
<li><p>automake</p>
<ul>
<li>linux_2_86_automake.md</li>
</ul>
</li>
<li><p>uptime</p>
<ul>
<li>linux_2_87_uptime.md</li>
</ul>
</li>
<li><p>mii</p>
<ul>
<li>linux_2_88_mii-tool.md</li>
</ul>
</li>
<li><p>crontab</p>
<ul>
<li>linux_2_89_crontab.md</li>
</ul>
</li>
<li><p>traceroute</p>
<ul>
<li>linux_2_90_traceroute.md</li>
</ul>
</li>
<li><p>route</p>
<ul>
<li>linux_2_91_route.md</li>
</ul>
</li>
<li><p>ifconfig</p>
<ul>
<li>linux_2_92_ifconfig.md</li>
</ul>
</li>
<li><p>nslookup</p>
<ul>
<li>linux_2_93_nslookup.md</li>
</ul>
</li>
<li><p>nmap</p>
<ul>
<li>linux_2_94_nmap.md</li>
</ul>
</li>
<li><p>p7zip</p>
<ul>
<li>linux_2_95_p7zip.md</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_07_objdump/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_07_objdump/" class="post-title-link" itemprop="url">linux_2_07_objdump</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>objdump命令相关笔记</li>
</ul>
<h2 id="linux-objdump命令-详解"><a href="#linux-objdump命令-详解" class="headerlink" title="linux objdump命令 详解"></a>linux objdump命令 详解</h2><p><code>objdump</code> 是一个用于显示目标文件（object file）信息的强大工具，它通常随着 GNU binutils 工具集一起提供。<code>objdump</code> 可以用于分析二进制文件、共享库、可执行文件等，提供了很多有用的信息，包括汇编代码、符号表、段信息等。以下是一些常见的用法和选项：</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法:"></a>基本用法:</h3><ol>
<li><p><strong>查看文件信息:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -f your_file</span><br></pre></td></tr></table></figure>
<p>显示文件头的基本信息，包括目标架构、文件大小、入口点等。</p>
</li>
<li><p><strong>查看节（section）信息:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -h your_file</span><br></pre></td></tr></table></figure>
<p>显示目标文件的各个节的详细信息，包括名称、大小、VMA（虚拟内存地址）、LMA（加载内存地址）、对齐等。</p>
</li>
</ol>
<h3 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码:"></a>汇编代码:</h3><ol>
<li><p><strong>显示全部汇编代码:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d your_file</span><br></pre></td></tr></table></figure>
<p>显示目标文件中的所有汇编代码。</p>
</li>
<li><p><strong>指定节进行汇编代码显示:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d -j .text your_file</span><br></pre></td></tr></table></figure>
<p>只显示指定节（这里是 <code>.text</code> 节）的汇编代码。</p>
</li>
<li><p><strong>以反汇编形式显示:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -D your_file</span><br></pre></td></tr></table></figure>
<p>以反汇编形式显示目标文件的所有代码。</p>
</li>
</ol>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表:"></a>符号表:</h3><ol>
<li><p><strong>显示符号表:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -t your_file</span><br></pre></td></tr></table></figure>
<p>显示目标文件的符号表，包括函数、变量等。</p>
</li>
<li><p><strong>显示动态符号表:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -T your_file</span><br></pre></td></tr></table></figure>
<p>显示目标文件的动态符号表。</p>
</li>
</ol>
<h3 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项:"></a>其他选项:</h3><ol>
<li><p><strong>显示重定位信息:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -r your_file</span><br></pre></td></tr></table></figure>
<p>显示目标文件的重定位信息。</p>
</li>
<li><p><strong>输出到文件:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d your_file &gt; output.asm</span><br></pre></td></tr></table></figure>
<p>将汇编代码输出到文件。</p>
</li>
</ol>
<p>这只是 <code>objdump</code> 的一些基本用法，该工具提供了更多选项，可以根据需要进行定制。可以通过 <code>man objdump</code> 命令查看 <code>objdump</code> 的手册页，获取更详细的信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_09_vim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_09_vim/" class="post-title-link" itemprop="url">linux_2_09_vim</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>vim命令 相关笔记</li>
</ul>
<h2 id="linux-vim命令-详解"><a href="#linux-vim命令-详解" class="headerlink" title="linux vim命令 详解"></a>linux vim命令 详解</h2><p>Vim是一款功能强大的文本编辑器，支持多种操作模式和丰富的命令。以下是一些常用的Vim命令的详解：</p>
<h3 id="1-基本移动命令（Normal-Mode）："><a href="#1-基本移动命令（Normal-Mode）：" class="headerlink" title="1. 基本移动命令（Normal Mode）："></a>1. <strong>基本移动命令（Normal Mode）：</strong></h3><ul>
<li><code>h</code>：向左移动一个字符。</li>
<li><code>j</code>：向下移动一行。</li>
<li><code>k</code>：向上移动一行。</li>
<li><code>l</code>：向右移动一个字符。</li>
<li><code>w</code>：跳到下一个单词的开头。</li>
<li><code>b</code>：跳到前一个单词的开头。</li>
<li><code>e</code>：跳到当前或下一个单词的末尾。</li>
<li><code>0</code>：跳到当前行的开头。</li>
<li><code>^</code>：跳到当前行的第一个非空字符。</li>
<li><code>$</code>：跳到当前行的末尾。</li>
</ul>
<h3 id="2-插入文本（Insert-Mode）："><a href="#2-插入文本（Insert-Mode）：" class="headerlink" title="2. 插入文本（Insert Mode）："></a>2. <strong>插入文本（Insert Mode）：</strong></h3><ul>
<li><code>i</code>：在光标前插入文本。</li>
<li><code>I</code>：在当前行的开头插入文本。</li>
<li><code>a</code>：在光标后插入文本。</li>
<li><code>A</code>：在当前行的末尾插入文本。</li>
<li><code>o</code>：在当前行的下方插入新行，并进入插入模式。</li>
<li><code>O</code>：在当前行的上方插入新行，并进入插入模式。</li>
</ul>
<h3 id="3-删除和复制（Normal-Mode）："><a href="#3-删除和复制（Normal-Mode）：" class="headerlink" title="3. 删除和复制（Normal Mode）："></a>3. <strong>删除和复制（Normal Mode）：</strong></h3><ul>
<li><code>x</code>：删除光标所在位置的字符。</li>
<li><code>dd</code>：删除当前行。</li>
<li><code>yy</code>：复制当前行。</li>
<li><code>p</code>：在光标后粘贴复制的内容。</li>
<li><code>P</code>：在光标前粘贴复制的内容。</li>
</ul>
<h3 id="4-撤销和重做（Normal-Mode）："><a href="#4-撤销和重做（Normal-Mode）：" class="headerlink" title="4. 撤销和重做（Normal Mode）："></a>4. <strong>撤销和重做（Normal Mode）：</strong></h3><ul>
<li><code>u</code>：撤销上一次操作。</li>
<li><code>Ctrl + r</code>：重做上一次撤销的操作。</li>
</ul>
<h3 id="5-搜索与替换（Normal-Mode）："><a href="#5-搜索与替换（Normal-Mode）：" class="headerlink" title="5. 搜索与替换（Normal Mode）："></a>5. <strong>搜索与替换（Normal Mode）：</strong></h3><ul>
<li><code>/pattern</code>：正向搜索匹配 <code>pattern</code> 的文本。</li>
<li><code>?pattern</code>：反向搜索匹配 <code>pattern</code> 的文本。</li>
<li><code>:s/old_text/new_text/g</code>：替换当前行中所有的 <code>old_text</code> 为 <code>new_text</code>。</li>
<li><code>:%s/old_text/new_text/g</code>：全局替换文件中所有的 <code>old_text</code> 为 <code>new_text</code>。</li>
</ul>
<h3 id="6-保存和退出（Normal-Mode）："><a href="#6-保存和退出（Normal-Mode）：" class="headerlink" title="6. 保存和退出（Normal Mode）："></a>6. <strong>保存和退出（Normal Mode）：</strong></h3><ul>
<li><code>:w</code>：保存文件。</li>
<li><code>:q</code>：退出。</li>
<li><code>:wq</code>：保存并退出。</li>
<li><code>:q!</code>：强制退出，不保存修改。</li>
</ul>
<h3 id="7-显示行号和状态栏（Normal-Mode）："><a href="#7-显示行号和状态栏（Normal-Mode）：" class="headerlink" title="7. 显示行号和状态栏（Normal Mode）："></a>7. <strong>显示行号和状态栏（Normal Mode）：</strong></h3><ul>
<li><code>:set number</code>：显示行号。</li>
<li><code>:set nonumber</code>：隐藏行号。</li>
<li><code>:set ruler</code>：显示状态栏。</li>
</ul>
<h3 id="8-多窗口操作（Normal-Mode）："><a href="#8-多窗口操作（Normal-Mode）：" class="headerlink" title="8. 多窗口操作（Normal Mode）："></a>8. <strong>多窗口操作（Normal Mode）：</strong></h3><ul>
<li><code>:vsp</code>：垂直分割当前窗口。</li>
<li><code>:sp</code>：水平分割当前窗口。</li>
<li><code>Ctrl + w + (h/j/k/l)</code>：切换焦点到左&#x2F;下&#x2F;上&#x2F;右窗口。</li>
</ul>
<h3 id="9-保存会话（Normal-Mode）："><a href="#9-保存会话（Normal-Mode）：" class="headerlink" title="9. 保存会话（Normal Mode）："></a>9. <strong>保存会话（Normal Mode）：</strong></h3><ul>
<li><code>:mksession filename</code>：保存当前会话到文件 <code>filename</code>。</li>
<li><code>:source filename</code>：加载会话文件。</li>
</ul>
<h3 id="10-帮助（Normal-Mode）："><a href="#10-帮助（Normal-Mode）：" class="headerlink" title="10. 帮助（Normal Mode）："></a>10. <strong>帮助（Normal Mode）：</strong></h3><ul>
<li><code>:help</code>：打开帮助文档。</li>
<li>在帮助文档中，使用 <code>:q</code> 退出。</li>
</ul>
<p>这是一些常用的Vim命令，Vim有很多其他功能和命令，可以根据需要深入学习。在Vim中，熟练使用键盘快捷键和命令可以大大提高编辑效率。</p>
<h2 id="linux-vim命令-常用技巧"><a href="#linux-vim命令-常用技巧" class="headerlink" title="linux vim命令 常用技巧"></a>linux vim命令 常用技巧</h2><p>在Linux中使用Vim时，以下是一些常用的技巧和命令：</p>
<h3 id="1-插入模式切换："><a href="#1-插入模式切换：" class="headerlink" title="1. 插入模式切换："></a>1. <strong>插入模式切换：</strong></h3><ul>
<li><code>i</code>：在当前光标位置前插入。</li>
<li><code>I</code>：在当前行首插入。</li>
<li><code>a</code>：在当前光标位置后插入。</li>
<li><code>A</code>：在当前行尾插入。</li>
</ul>
<h3 id="2-删除和复制："><a href="#2-删除和复制：" class="headerlink" title="2. 删除和复制："></a>2. <strong>删除和复制：</strong></h3><ul>
<li><code>x</code>：删除光标所在位置的字符。</li>
<li><code>dd</code>：删除整行。</li>
<li><code>yy</code>：复制整行。</li>
<li><code>p</code>：在光标后粘贴复制的内容。</li>
<li><code>P</code>：在光标前粘贴复制的内容。</li>
</ul>
<h3 id="3-跳转和定位："><a href="#3-跳转和定位：" class="headerlink" title="3. 跳转和定位："></a>3. <strong>跳转和定位：</strong></h3><ul>
<li><code>gg</code>：跳到文件开头。</li>
<li><code>G</code>：跳到文件末尾。</li>
<li><code>:n</code>：跳到第 n 行。</li>
<li><code>Ctrl + g</code>：显示当前行号和文件信息。</li>
</ul>
<h3 id="4-搜索与替换："><a href="#4-搜索与替换：" class="headerlink" title="4. 搜索与替换："></a>4. <strong>搜索与替换：</strong></h3><ul>
<li><code>/pattern</code>：正向搜索匹配 <code>pattern</code> 的文本。</li>
<li><code>?pattern</code>：反向搜索匹配 <code>pattern</code> 的文本。</li>
<li><code>:s/old/new/g</code>：替换当前行中所有匹配的 <code>old</code> 为 <code>new</code>。</li>
<li><code>:%s/old/new/g</code>：替换文件中所有匹配的 <code>old</code> 为 <code>new</code>。</li>
</ul>
<h3 id="5-撤销和重做："><a href="#5-撤销和重做：" class="headerlink" title="5. 撤销和重做："></a>5. <strong>撤销和重做：</strong></h3><ul>
<li><code>u</code>：撤销上一步操作。</li>
<li><code>Ctrl + r</code>：重做上一步撤销的操作。</li>
</ul>
<h3 id="6-保存和退出："><a href="#6-保存和退出：" class="headerlink" title="6. 保存和退出："></a>6. <strong>保存和退出：</strong></h3><ul>
<li><code>:w</code>：保存文件。</li>
<li><code>:q</code>：退出。</li>
<li><code>:wq</code>：保存并退出。</li>
<li><code>:q!</code>：强制退出，不保存修改。</li>
</ul>
<h3 id="7-文本块操作："><a href="#7-文本块操作：" class="headerlink" title="7. 文本块操作："></a>7. <strong>文本块操作：</strong></h3><ul>
<li><code>v</code>：进入可视模式，按字符选择。</li>
<li><code>V</code>：进入可视行模式，按行选择。</li>
<li><code>Ctrl + v</code>：进入可视块模式，按块选择。</li>
<li><code>y</code>：复制选择的文本。</li>
<li><code>d</code>：删除选择的文本。</li>
<li><code>p</code>：在光标后粘贴文本。</li>
<li><code>P</code>：在光标前粘贴文本。</li>
</ul>
<h3 id="8-自动补全："><a href="#8-自动补全：" class="headerlink" title="8. 自动补全："></a>8. <strong>自动补全：</strong></h3><ul>
<li>在插入模式下，按 <code>Ctrl + n</code> 可以进行关键字自动补全。</li>
</ul>
<h3 id="9-多文件编辑："><a href="#9-多文件编辑：" class="headerlink" title="9. 多文件编辑："></a>9. <strong>多文件编辑：</strong></h3><ul>
<li><code>:e filename</code>：打开文件。</li>
<li><code>:vsp filename</code>：垂直分割窗口并打开文件。</li>
<li><code>:sp filename</code>：水平分割窗口并打开文件。</li>
<li><code>:bnext</code>：切换到下一个缓冲区。</li>
</ul>
<h3 id="10-宏录制："><a href="#10-宏录制：" class="headerlink" title="10. 宏录制："></a>10. <strong>宏录制：</strong></h3><ul>
<li><code>q&lt;register&gt;</code>：开始录制宏到指定寄存器。</li>
<li><code>q</code>：停止录制宏。</li>
<li><code>@&lt;register&gt;</code>：执行录制的宏。</li>
</ul>
<h3 id="11-折叠和展开："><a href="#11-折叠和展开：" class="headerlink" title="11. 折叠和展开："></a>11. <strong>折叠和展开：</strong></h3><ul>
<li><code>zf</code>：创建折叠。</li>
<li><code>zo</code>：展开折叠。</li>
<li><code>zc</code>：关闭折叠。</li>
</ul>
<p>这些是一些Vim中常用的技巧和命令，能够帮助你更高效地进行文本编辑。熟练掌握这些技巧可以提升你在Vim中的编辑体验。</p>
<h2 id="linux-vim命令-高级技巧"><a href="#linux-vim命令-高级技巧" class="headerlink" title="linux vim命令 高级技巧"></a>linux vim命令 高级技巧</h2><p>高级的Vim技巧涉及到更深层次的编辑和定制，下面是一些高级技巧：</p>
<h3 id="1-正则表达式搜索和替换："><a href="#1-正则表达式搜索和替换：" class="headerlink" title="1. 正则表达式搜索和替换："></a>1. <strong>正则表达式搜索和替换：</strong></h3><ul>
<li>使用正则表达式进行更灵活的搜索和替换。例如，<code>:s/\vpattern/replace/g</code>，其中 <code>\v</code> 表示启用“very magic”模式，使得正则表达式更简洁。</li>
</ul>
<h3 id="2-宏（Macro）："><a href="#2-宏（Macro）：" class="headerlink" title="2. 宏（Macro）："></a>2. <strong>宏（Macro）：</strong></h3><ul>
<li>使用宏记录和重放操作序列。录制宏：<code>q&lt;register&gt;</code>开始录制，<code>q</code>结束录制。执行宏：<code>@&lt;register&gt;</code>。</li>
</ul>
<h3 id="3-折叠："><a href="#3-折叠：" class="headerlink" title="3. 折叠："></a>3. <strong>折叠：</strong></h3><ul>
<li>使用 <code>zf</code> 创建折叠，<code>zo</code> 展开折叠，<code>zc</code> 关闭折叠。可通过 <code>zM</code> 全部折叠，<code>zR</code> 全部展开。</li>
</ul>
<h3 id="4-标签页和窗口管理："><a href="#4-标签页和窗口管理：" class="headerlink" title="4. 标签页和窗口管理："></a>4. <strong>标签页和窗口管理：</strong></h3><ul>
<li>使用 <code>:tabnew</code> 打开新标签页，<code>:tabnext</code> 切换到下一个标签页，<code>:sp</code> 和 <code>:vsp</code> 打开新窗口。使用 <code>Ctrl + w</code> 然后 <code>h/j/k/l</code> 在窗口之间移动。</li>
</ul>
<h3 id="5-会话管理："><a href="#5-会话管理：" class="headerlink" title="5. 会话管理："></a>5. <strong>会话管理：</strong></h3><ul>
<li>使用 <code>:mksession</code> 保存当前会话，<code>:source</code> 加载会话文件。这允许你保存并重新加载编辑器状态。</li>
</ul>
<h3 id="6-自动命令："><a href="#6-自动命令：" class="headerlink" title="6. 自动命令："></a>6. <strong>自动命令：</strong></h3><ul>
<li>使用 <code>autocmd</code> 命令在特定事件发生时自动执行命令。例如，在文件保存时自动运行某个命令。</li>
</ul>
<h3 id="7-自定义键盘映射："><a href="#7-自定义键盘映射：" class="headerlink" title="7. 自定义键盘映射："></a>7. <strong>自定义键盘映射：</strong></h3><ul>
<li>使用 <code>map</code> 命令将一系列命令映射到键盘快捷键。例如，<code>:map &lt;F2&gt; :w&lt;CR&gt;</code> 将 <code>&lt;F2&gt;</code> 键映射到保存文件。</li>
</ul>
<h3 id="8-插件管理器："><a href="#8-插件管理器：" class="headerlink" title="8. 插件管理器："></a>8. <strong>插件管理器：</strong></h3><ul>
<li>使用插件管理器（如Vim-Plug、Pathogen、Vundle）安装和管理Vim插件，以扩展Vim的功能。</li>
</ul>
<h3 id="9-模式和语法高亮："><a href="#9-模式和语法高亮：" class="headerlink" title="9. 模式和语法高亮："></a>9. <strong>模式和语法高亮：</strong></h3><ul>
<li>定制Vim的显示模式和语法高亮，以适应不同的文件类型。可以使用 <code>autocmd</code> 在文件类型加载时设置不同的选项。</li>
</ul>
<h3 id="10-查找文件和替换："><a href="#10-查找文件和替换：" class="headerlink" title="10. 查找文件和替换："></a>10. <strong>查找文件和替换：</strong></h3><ul>
<li>使用 <code>:find</code> 查找文件，<code>:grep</code> 在项目中搜索，<code>:vimgrep</code> 在多个文件中进行搜索，<code>:cfdo</code> 在搜索结果上执行命令。</li>
</ul>
<h3 id="11-异步运行命令："><a href="#11-异步运行命令：" class="headerlink" title="11. 异步运行命令："></a>11. <strong>异步运行命令：</strong></h3><ul>
<li>使用 <code>:terminal</code> 打开一个终端窗口，或使用插件执行异步任务，如<code>:AsyncRun</code>。</li>
</ul>
<h3 id="12-自定义颜色方案："><a href="#12-自定义颜色方案：" class="headerlink" title="12. 自定义颜色方案："></a>12. <strong>自定义颜色方案：</strong></h3><ul>
<li>修改或添加颜色方案以改变Vim的外观。可以使用 <code>:colorscheme</code> 切换颜色方案，或手动编辑 <code>.vimrc</code> 文件。</li>
</ul>
<h3 id="13-局部配置："><a href="#13-局部配置：" class="headerlink" title="13. 局部配置："></a>13. <strong>局部配置：</strong></h3><ul>
<li>使用 <code>autocmd FileType</code> 和 <code>augroup</code> 在不同的文件类型下应用不同的配置。</li>
</ul>
<p>这些高级技巧可以让你更深入地定制和利用Vim的功能。记住，Vim是非常灵活的编辑器，通过深入了解和使用其高级功能，你可以提高编辑效率和适应不同的工作流程。</p>
<h2 id="linux-vim命令-搜索相关使用技巧-详解"><a href="#linux-vim命令-搜索相关使用技巧-详解" class="headerlink" title="linux vim命令 搜索相关使用技巧 详解"></a>linux vim命令 搜索相关使用技巧 详解</h2><p>在Vim中，搜索是一个常见而强大的操作。以下是一些搜索相关的使用技巧的详解：</p>
<h3 id="1-正向搜索和反向搜索："><a href="#1-正向搜索和反向搜索：" class="headerlink" title="1. 正向搜索和反向搜索："></a>1. <strong>正向搜索和反向搜索：</strong></h3><ul>
<li><code>/pattern</code>：在光标后正向搜索匹配 <code>pattern</code> 的文本。</li>
<li><code>?pattern</code>：在光标前反向搜索匹配 <code>pattern</code> 的文本。</li>
</ul>
<h3 id="2-匹配整个单词："><a href="#2-匹配整个单词：" class="headerlink" title="2. 匹配整个单词："></a>2. <strong>匹配整个单词：</strong></h3><ul>
<li>在搜索模式下，使用 <code>\b</code> 来匹配整个单词。例如，搜索 <code>\bword\b</code> 可以匹配单独的 “word”。</li>
</ul>
<h3 id="3-忽略大小写："><a href="#3-忽略大小写：" class="headerlink" title="3. 忽略大小写："></a>3. <strong>忽略大小写：</strong></h3><ul>
<li>在搜索模式下，使用 <code>\c</code> 来忽略大小写。例如，搜索 <code>ignore\c</code> 可以匹配 “ignore”、”IGNORE”、”IgNore”等。</li>
</ul>
<h3 id="4-使用正则表达式："><a href="#4-使用正则表达式：" class="headerlink" title="4. 使用正则表达式："></a>4. <strong>使用正则表达式：</strong></h3><ul>
<li>Vim支持强大的正则表达式。例如，<code>/^\d\&#123;3\&#125;</code> 可以匹配以三个数字开头的行。</li>
</ul>
<h3 id="5-高亮搜索结果："><a href="#5-高亮搜索结果：" class="headerlink" title="5. 高亮搜索结果："></a>5. <strong>高亮搜索结果：</strong></h3><ul>
<li>在正常模式下，输入 <code>:set hlsearch</code> 可以启用搜索结果的高亮显示。使用 <code>:nohlsearch</code> 可以取消高亮显示。</li>
</ul>
<h3 id="6-搜索下一个和上一个匹配项："><a href="#6-搜索下一个和上一个匹配项：" class="headerlink" title="6. 搜索下一个和上一个匹配项："></a>6. <strong>搜索下一个和上一个匹配项：</strong></h3><ul>
<li>在正常模式下，按下 <code>n</code> 可以跳转到下一个匹配项。按下 <code>N</code> 可以跳转到上一个匹配项。</li>
</ul>
<h3 id="7-使用标签页显示搜索结果："><a href="#7-使用标签页显示搜索结果：" class="headerlink" title="7. 使用标签页显示搜索结果："></a>7. <strong>使用标签页显示搜索结果：</strong></h3><ul>
<li>使用 <code>:tabnew</code> 打开新标签页，然后执行搜索命令，可以在新标签页中显示搜索结果。</li>
</ul>
<h3 id="8-搜索并替换："><a href="#8-搜索并替换：" class="headerlink" title="8. 搜索并替换："></a>8. <strong>搜索并替换：</strong></h3><ul>
<li><code>:s/old_text/new_text/g</code>：替换当前行中所有的 <code>old_text</code> 为 <code>new_text</code>。</li>
<li><code>:%s/old_text/new_text/g</code>：全局替换文件中所有的 <code>old_text</code> 为 <code>new_text</code>。</li>
</ul>
<h3 id="9-使用搜索历史："><a href="#9-使用搜索历史：" class="headerlink" title="9. 使用搜索历史："></a>9. <strong>使用搜索历史：</strong></h3><ul>
<li>在搜索模式下，按 <code>Ctrl + r</code> 可以进入历史搜索模式，然后选择之前的搜索项。</li>
</ul>
<h3 id="10-在多个文件中搜索："><a href="#10-在多个文件中搜索：" class="headerlink" title="10. 在多个文件中搜索："></a>10. <strong>在多个文件中搜索：</strong></h3><ul>
<li>使用 <code>:grep</code> 在整个项目中搜索，或者使用 <code>:vimgrep</code> 在多个文件中进行搜索。例如，<code>:vimgrep /pattern/ *.txt</code>。</li>
</ul>
<h3 id="11-在当前文件中搜索并定位："><a href="#11-在当前文件中搜索并定位：" class="headerlink" title="11. 在当前文件中搜索并定位："></a>11. <strong>在当前文件中搜索并定位：</strong></h3><ul>
<li>使用 <code>*</code> 在光标下搜索当前单词并跳转到下一个匹配项。使用 <code>#</code> 在光标上搜索当前单词并跳转到上一个匹配项。</li>
</ul>
<h3 id="12-使用搜索匹配项进行操作："><a href="#12-使用搜索匹配项进行操作：" class="headerlink" title="12. 使用搜索匹配项进行操作："></a>12. <strong>使用搜索匹配项进行操作：</strong></h3><ul>
<li>在可视模式下选择文本，然后按 <code>*</code> 或 <code>#</code> 将光标移动到下一个或上一个匹配项。</li>
</ul>
<p>这些技巧可以让你更有效地在Vim中进行搜索操作。通过组合不同的搜索命令和选项，你可以快速定位和处理文本中的特定内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_08_head/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_08_head/" class="post-title-link" itemprop="url">linux_2_08_head</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>head命令笔记</li>
</ul>
<h2 id="linux-head命令-详解"><a href="#linux-head命令-详解" class="headerlink" title="linux head命令 详解"></a>linux head命令 详解</h2><p><code>head</code>命令在Linux和Unix系统中用于显示文件的开头部分，默认情况下显示前10行。以下是<code>head</code>命令的一些常用选项和示例：</p>
<h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>

<h3 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h3><ul>
<li><code>-n, --lines=NUM</code>：指定要显示的行数。例如，<code>-n 20</code>将显示文件的前20行。</li>
<li><code>-c, --bytes=NUM</code>：指定要显示的字节数。</li>
<li><code>-q, --quiet, --silent</code>：不显示文件名头部。</li>
<li><code>-v, --verbose</code>：始终显示文件名头部。</li>
<li><code>--help</code>：显示帮助信息。</li>
<li><code>--version</code>：显示版本信息。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><ol>
<li><p>显示文件的前10行（默认情况）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示文件的前20行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 20 filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示文件的前100字节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -c 100 filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示多个文件的前5行，并显示文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 5 -v file1.txt file2.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>不显示文件名头部：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -q filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示<code>head</code>命令的帮助信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head --help</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>如果未指定文件名，则<code>head</code>将从标准输入读取数据。你可以使用管道符 <code>|</code> 将其他命令的输出传递给<code>head</code>。</li>
</ul>
<p>这些是一些常见的<code>head</code>命令用法和选项。根据你的需求，你可以使用不同的选项来满足查看文件开头部分的要求。</p>
<h2 id="linux-head命令-常用技巧"><a href="#linux-head命令-常用技巧" class="headerlink" title="linux head命令 常用技巧"></a>linux head命令 常用技巧</h2><p>在Linux中，<code>head</code>命令是一个简单而实用的工具，用于查看文件的开头部分。以下是一些使用<code>head</code>命令的常用技巧：</p>
<ol>
<li><p><strong>查看文件的开头几行：</strong><br>默认情况下，<code>head</code>命令显示文件的前10行。你可以通过提供<code>-n</code>选项并指定行数来调整显示的行数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 20 filename  <span class="comment"># 显示文件的前20行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看文件的开头几个字节：</strong><br>使用<code>-c</code>选项可以指定要显示的字节数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -c 100 filename  <span class="comment"># 显示文件的前100个字节</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示多个文件的开头：</strong><br><code>head</code>命令可以同时处理多个文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> file1.txt file2.txt  <span class="comment"># 分别显示file1.txt和file2.txt的开头</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结合其他命令使用：</strong><br>你可以使用管道将其他命令的输出传递给<code>head</code>，以便查看前几行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> somefile.txt | <span class="built_in">head</span> -n 15  <span class="comment"># 显示somefile.txt的前15行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不显示文件名头部：</strong><br>默认情况下，<code>head</code>在显示文件开头时会显示文件名。如果你不希望显示文件名，可以使用<code>-q</code>选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -q filename  <span class="comment"># 不显示文件名</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>始终显示文件名头部：</strong><br>如果你想始终显示文件名，可以使用<code>-v</code>选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -v filename  <span class="comment"># 始终显示文件名</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看目录中的文件：</strong><br>你可以使用通配符来查看目录中所有匹配的文件的开头。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> *.txt  <span class="comment"># 显示所有以.txt结尾的文件的开头</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示特定文件类型的文件开头：</strong><br>通过组合<code>find</code>命令和<code>head</code>命令，你可以查看特定类型的文件的开头。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.log&quot;</span> -<span class="built_in">exec</span> <span class="built_in">head</span> -n 10 &#123;&#125; \;  <span class="comment"># 显示所有.log文件的前10行</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些技巧可以帮助你灵活地使用<code>head</code>命令来查看文件的开头部分，适应不同的需求。</p>
<h2 id="linux-head命令-高级技巧"><a href="#linux-head命令-高级技巧" class="headerlink" title="linux head命令 高级技巧"></a>linux head命令 高级技巧</h2><p>除了基本的用法和常见技巧之外，还有一些更高级的<code>head</code>命令用法，可以更灵活地处理文件内容。以下是一些高级技巧：</p>
<ol>
<li><p><strong>显示行号：</strong><br>使用<code>-n</code>选项可以显示行号，方便你查看文件内容的具体行数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -n filename | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态查看文件变化：</strong><br>结合<code>tail -f</code>命令，可以实时查看文件的变化。这对于监控日志文件非常有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f filename | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示文件的非文本内容：</strong><br>使用<code>xxd</code>命令将文件内容以十六进制形式显示，然后使用<code>head</code>来查看前几行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd filename | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看文件的字符编码：</strong><br>使用<code>file</code>命令查看文件的字符编码，然后使用<code>head</code>查看文件的开头。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file -i filename  <span class="comment"># 显示文件编码信息</span></span><br><span class="line"><span class="built_in">head</span> -n 10 filename  <span class="comment"># 查看文件开头</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看大文件的开头：</strong><br>对于大文件，可以使用<code>zcat</code>结合<code>head</code>命令，以便在查看压缩文件的开头时无需先解压缩。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat filename.gz | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看文件的特定部分：</strong><br>使用<code>sed</code>命令选择文件的特定行范围，然后将其传递给<code>head</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;10,20p&#x27;</span> filename | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示文件中最常见的单词：</strong><br>使用<code>tr</code>、<code>sort</code>、<code>uniq</code>和<code>head</code>命令的组合来查看文件中最常见的单词。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tr</span> -s <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\n&#x27;</span> &lt; filename | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看文件的末尾而不是开头：</strong><br>使用<code>tail</code>命令以反向顺序查看文件的末尾，然后再使用<code>head</code>查看前几行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 20 filename | <span class="built_in">head</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些高级技巧展示了如何结合<code>head</code>命令与其他命令以满足更复杂的需求，使其成为一个更灵活和强大的文件查看工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/24/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/26/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
