<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/25/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/25/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E7%BC%96%E8%AF%91%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E7%BC%96%E8%AF%91%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C++_编译基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p><code>gcc</code>和<code>g++</code>分别是<code>GNU</code>的C和<code>C++</code>编译器。<code>gcc</code>和<code>g++</code>在执行编译工作的时候，总共四步：</p>
<ul>
<li>预处理，生成<code>.i</code>文件{预处理器  –  <code>cpp</code>}</li>
<li>将预处理后的文件转换成汇编语言，生成文件.s{编译器  –  <code>egcs</code>}</li>
<li>由汇编变为目标代码（机器代码）生成.o的文件{汇编器  –  <code>as</code>}</li>
<li>链接目标代码，生成可执行程序{链接器  –  <code>ld</code>}</li>
</ul>
</li>
<li><p>参数：</p>
<ul>
<li><code>-c</code>：只激活预处理、编译和汇编，生成<code>obj</code>文件<code>.o</code></li>
<li><code>-S</code>：只激活预处理和编译，生成汇编代码</li>
<li><code>-I</code>：指定头文件所在路径</li>
<li><code>-L</code>：指定库文件所在路径</li>
<li><code>-l</code>：指定库的名字</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><code>GCC</code>是一个驱动式的程序，它调用其他程序来依次进行编译、汇编和链接</li>
<li><code>GCC</code>分析命令行参数，然后决定该调用哪一个子程序，哪些参数应该传递给子程序。所有这些行为都是由<code>SPEC</code>字符串（<code>spec strings</code>）来控制的。</li>
<li>通常情况下，每一个<code>GCC</code>可以调用的子程序都对应着一个<code>SPEC</code>字符串，不过有少数的子程序需要多个<code>SPEC</code>字符串来控制他们的行为。</li>
</ul>
</li>
<li><p>深入理解计算机操作系统 P109</p>
<ul>
<li>试图最大化一段关键代码性能的程序员,通常会尝试源代码的各种形式,每次编译并检查产生的汇编代码,从而了解程序将要运行的效率如何</li>
<li>此外,有些时候,高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为</li>
</ul>
</li>
</ul>
<h2 id="GCC参数"><a href="#GCC参数" class="headerlink" title="GCC参数"></a>GCC参数</h2><ul>
<li><p><code>-x language filename</code></p>
<ul>
<li>设定文件所使用的语言, 使后缀名无效, 对以后的多个有效。</li>
<li>也就是根据约定 <code>C</code> 语言的后缀名称是 <code>.c</code> 的，而 <code>C++</code> 的后缀名是 <code>.C</code> 或者 <code>.cpp</code></li>
<li>可以使用的参数：<ul>
<li><code>c</code></li>
<li><code>objective-c</code></li>
<li><code>c-header</code></li>
<li><code>c++</code></li>
<li><code>cpp-output</code></li>
<li><code>assembler</code></li>
<li><code>assembler-with-cpp</code></li>
</ul>
</li>
<li>例如：<code>gcc -x c hello.pig</code></li>
</ul>
</li>
<li><p><code>-x none filename</code></p>
<ul>
<li>关掉上一个选项，也就是让gcc根据文件名后缀，自动识别文件类型 。</li>
</ul>
</li>
<li><p><code>-pipe</code></p>
<ul>
<li>使用管道代替编译中临时文件, 在使用非 gnu 汇编工具的时候, 可能有些问题</li>
<li>例如：<code>gcc -pipe -o hello.exe hello.c</code></li>
</ul>
</li>
<li><p><code>-ansi</code></p>
<ul>
<li>关闭 <code>gnu c</code>中与 <code>ansi c</code> 不兼容的特性, 激活 <code>ansi c</code> 的专有特性（包括禁止一些 <code>asm</code> <code>inline</code> <code>typeof</code> 关键字, 以及 <code>UNIX</code>,<code>vax</code> 等预处理宏）</li>
</ul>
</li>
<li><p><code>-fno-asm</code></p>
<ul>
<li>此选项实现 <code>ansi</code> 选项的功能的一部分，它禁止将 <code>asm</code>, <code>inline</code> 和 <code>typeof</code> 用作关键字。</li>
</ul>
</li>
<li><p><code>-fno-strict-prototype</code></p>
<ul>
<li>只对 <code>g++</code> 起作用,</li>
<li>使用这个选项, <code>g++</code> 将对不带参数的函数,都认为是没有显式的对参数的个数和类型说明,而不是没有参数</li>
<li>而 <code>gcc</code> 无论是否使用这个参数, 都将对没有带参数的函数, 认为没有显式说明的类型</li>
</ul>
</li>
<li><p><code>-fthis-is-varialble</code></p>
<ul>
<li>就是向传统 <code>c++</code> 看齐, 可以使用 <code>this</code> 当一般变量使用</li>
</ul>
</li>
<li><p><code>-fcond-mismatch</code></p>
<ul>
<li>允许条件表达式的第二和第三参数类型不匹配, 表达式的值将为 <code>void</code> 类型</li>
</ul>
</li>
<li><p><code>-funsigned-char</code> 、<code>-fno-signed-char</code>、<code>-fsigned-char</code> 、<code>-fno-unsigned-char</code></p>
<ul>
<li>这四个参数是对 <code>char</code> 类型进行设置, 决定将 <code>char</code> 类型设置成 unsigned char(前两个参数)或者 signed char(后两个参数)。</li>
</ul>
</li>
<li><p><code>-include file</code></p>
<ul>
<li>包含某个代码,简单来说,就是便以某个文件,需要另一个文件的时候,就可以用它设定,</li>
<li>功能就相当于在代码中使用 <code>#include&lt;filename&gt;</code></li>
</ul>
</li>
<li><p><code>-imacros file</code></p>
<ul>
<li>将 file 文件的宏, 扩展到 gcc&#x2F;g++ 的输入文件, 宏定义本身并不出现在输入文件中</li>
</ul>
</li>
<li><p><code>-Dmacro</code></p>
<ul>
<li>定义宏<code>macro</code></li>
<li>相当于 <code>C</code> 语言中的 <code>#define macro</code></li>
</ul>
</li>
<li><p><code>-Umacro</code></p>
<ul>
<li>相当于 <code>C</code> 语言中的 <code>#undef macro</code></li>
</ul>
</li>
<li><p><code>-undef</code></p>
<ul>
<li>取消对任何非标准宏的定义</li>
</ul>
</li>
<li><p><code>-Idir</code></p>
<ul>
<li>在你是用 <code>#include &quot;file&quot;</code> 的时候, <code>gcc/g++</code> 会先在当前目录查找你所制定的头文件, 如果没有找到, 他回到默认的头文件目录找, 如果使用 <code>-I</code> 制定了目录,他会先在你所制定的目录查找, 然后再按常规的顺序去找</li>
<li>对于 <code>#include&lt;file&gt;</code>, <code>gcc/g++</code> 会到 <code>-I</code> 制定的目录查找, 查找不到, 然后将到系统的默认的头文件目录查找</li>
</ul>
</li>
<li><p><code>-C</code></p>
<ul>
<li>在预处理的时候, 不删除注释信息, 一般和-E使用, 有时候分析程序，用这个很方便的</li>
</ul>
</li>
<li><p><code>-Wa,option</code></p>
<ul>
<li>此选项传递 <code>option</code> 给汇编程序; 如果 <code>option</code> 中间有逗号, 就将 <code>option</code> 分成多个选项, 然 后传递给会汇编程序</li>
</ul>
</li>
<li><p><code>-Wl.option</code></p>
<ul>
<li>此选项传递 <code>option</code> 给链接程序; 如果 <code>option</code> 中间有逗号, 就将 <code>option</code> 分成多个选项, 然后传递给会链接程序</li>
</ul>
</li>
<li><p><code>-llibrary</code></p>
<ul>
<li>制定编译的时候使用的库</li>
</ul>
</li>
<li><p><code>-Ldir</code></p>
<ul>
<li>制定编译的时候，搜索库的路径。比如你自己的库，可以用它制定目录，不然编译器将只在标准库的目录找。这个<code>dir</code>就是目录的名称</li>
</ul>
</li>
<li><p><code>-O0 、-O1 、-O2 、-O3</code></p>
<ul>
<li>编译器的优化选项的 4 个级别，-O0 表示没有优化, -O1 为默认值，-O3 优化级别最高</li>
</ul>
</li>
<li><p><code>-g</code></p>
<ul>
<li>只是编译器，在编译的时候，产生调试信息</li>
</ul>
</li>
<li><p><code>-ggdb</code></p>
<ul>
<li>此选项将尽可能的生成 <code>gdb</code> 的可以使用的调试信息</li>
</ul>
</li>
<li><p><code>-static</code></p>
<ul>
<li>此选项将禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么动态连接库，就可以运行。</li>
</ul>
</li>
<li><p><code>-share</code></p>
<ul>
<li>此选项将尽量使用动态库，所以生成文件比较小，但是需要系统有动态库。</li>
</ul>
</li>
<li><p><code>-traditional</code></p>
<ul>
<li>试图让编译器支持传统的C语言特性。</li>
<li><code>GCC</code> 是 <code>GNU</code> 的 <code>C</code> 和 <code>C++</code> 编译器。实际上，<code>GCC</code> 能够编译三种语言：<code>C</code>、<code>C++</code> 和 <code>Object C</code>（<code>C</code> 语言的一种面向对象扩展）。</li>
<li>利用 <code>gcc</code> 命令可同时编译并连接 <code>C</code> 和 <code>C++</code> 源程序。</li>
</ul>
</li>
</ul>
<h2 id="编译器的工作过程"><a href="#编译器的工作过程" class="headerlink" title="编译器的工作过程"></a>编译器的工作过程</h2><h3 id="配置-configure"><a href="#配置-configure" class="headerlink" title="配置(configure)"></a>配置(configure)</h3><ul>
<li>编译器在开始工作之前,需要知道当前的系统环境,比如标准库在哪里,软件的安装位置在哪里,需要安装那些组件等等.</li>
<li>这是因为不同计算机的系统环境不一样,通过指定编译参数,编译器就可以灵活适应环境,编译出各种环境都能运行的机器码,<strong>这个确定编译参数的步骤,就叫做”配置(configure)”</strong></li>
<li>这些配置信息保存在一个配置文件中,约定俗成是一个叫做<code>configure</code>的脚本文件.通常它是由<code>autoconf</code>工具生成的.编译器通过运行这个脚本,获得编译参数</li>
</ul>
<h3 id="确定标准库和头文件的位置"><a href="#确定标准库和头文件的位置" class="headerlink" title="确定标准库和头文件的位置"></a>确定标准库和头文件的位置</h3><ul>
<li>源码肯定会用到标准库函数(standard library)和头文件(header).它们可以放在系统的任意目录中,编译器实际上没有办法自动检测它们的位置,只有通过配置文件才能知道</li>
<li>编译的第二步,就是从配置文件中知道标准库和头文件的位置.一般来说,配置文件会给出一个清单,列出几个具体的目录.等到编译时,编译器就按顺序到这几个目录中,寻找目标</li>
</ul>
<h3 id="确定依赖关系"><a href="#确定依赖关系" class="headerlink" title="确定依赖关系"></a>确定依赖关系</h3><ul>
<li>对于大型项目来说,源码之间往往存在依赖关系,编译器需要确定编译的先后顺序.假设A文件依赖于B文件,编译器应该保证做到:<strong>只有在B文件编译完成后,才开始编译A文件;当B文件发生变化时,A文件会被重新编译</strong></li>
<li>编译顺序保存在一个叫做<code>makefile</code>的文件中,里面列出哪个文件先编译,哪个文件后编译.而<code>makefile</code>文件由<code>configure</code>脚本运行生成,这就是<strong>为什么编译时configure必须首先运行的原因</strong></li>
</ul>
<h3 id="头文件的预编译-precompilation"><a href="#头文件的预编译-precompilation" class="headerlink" title="头文件的预编译(precompilation)"></a>头文件的预编译(precompilation)</h3><ul>
<li>不同的源码文件,可能引用同一个头文件,编译的时候,头文件也必须一起编译</li>
<li>为了节省时间,编译器会在编译源码之前,先编译头文件.这保证了头文件只需编译一次,不必每次用到的时候都需要重新编译</li>
<li>不过,并不是头文件的所有内容都会被预编译,用来声明宏的<code>#define</code>命令,就不会被预编译</li>
</ul>
<h3 id="预处理-preprocessing"><a href="#预处理-preprocessing" class="headerlink" title="预处理(preprocessing)"></a>预处理(preprocessing)</h3><ul>
<li>预编译完成后,编译器就开始替换掉源码中bash的头文件和宏,编译器在这一步还会移除注释</li>
</ul>
<h3 id="编译-Compilation"><a href="#编译-Compilation" class="headerlink" title="编译(Compilation)"></a>编译(Compilation)</h3><ul>
<li>预处理之后,编译器就开始生成机器码.</li>
<li>对于某些编译器来说,还存在一个中间步骤,会先把源码转为汇编码(<code>assembly</code>),然后再把汇编码转为机器码</li>
<li>这种转码后的文件称为对象文件(<code>object file</code>)</li>
</ul>
<h3 id="连接-Linking"><a href="#连接-Linking" class="headerlink" title="连接(Linking)"></a>连接(Linking)</h3><ul>
<li>把外部函数的代码(通常是后缀名为<code>.lib</code>和<code>.a</code>的文件),添加到可执行文件中,这就叫做连接(linking).</li>
<li>这种通过拷贝,将外部函数库添加到可执行文件的方式,叫做静态连接(static linking)</li>
<li><code>make</code>命令的作用,就是<strong>从第四步头文件预编译开始,一直到做完这一步.</strong></li>
</ul>
<h3 id="安装-Installation"><a href="#安装-Installation" class="headerlink" title="安装(Installation)"></a>安装(Installation)</h3><ul>
<li>上一步的连接是在<strong>内存</strong>中进行的,即编译器在内存中生成了可执行文件.下一步,必须将可执行文件保存到用户事先指定的安装目录</li>
<li>表面上,这一步就是将可执行文件(连带相关的数据文件)拷贝过去,但是实际上,这一步还必须完成创建目录,保存文件,设置权限等步骤,这整个的过程就称为”安装(Installation)”</li>
</ul>
<h3 id="操作系统连接"><a href="#操作系统连接" class="headerlink" title="操作系统连接"></a>操作系统连接</h3><ul>
<li>可执行文件安装后,必须以某种方式通知操作系统,让其知道可以使用这个程序了</li>
<li>这就要求在操作系统中,登记这个程序的元数据:文件名,文件描述,关联后缀名等等.linux系统中,这些信息通常保存在<code>/usr/share/applications/</code>目录下的<code>.desktop</code>文件中.另外在windows操作系统中,还需要在start启动菜单中,建立一个快捷方式</li>
<li>这些事情就叫做”操作系统连接”.<code>make install</code>命令,就用来完成”安装”和”操作系统连接”这两步</li>
</ul>
<h3 id="生成安装包"><a href="#生成安装包" class="headerlink" title="生成安装包"></a>生成安装包</h3><ul>
<li>到这一步,源码编译的整个过程就基本完成了,但是事实上,如果只有源码可以交给用户,是不可行的,大部分用户要的是一个二进制的可执行程序,立刻就能运行.这就要求开发者,将上一步生成的可执行文件,做成可以分发的安装包</li>
<li>所以,编译器还必须有生成安装包的功能,通常是将可执行文件(连带相关的数据文件),以某种目录结构,保存成压缩文件包,交给用户</li>
</ul>
<h3 id="动态连接-Dynamic-linking"><a href="#动态连接-Dynamic-linking" class="headerlink" title="动态连接(Dynamic linking)"></a>动态连接(Dynamic linking)</h3><ul>
<li>静态连接就是把外部函数库,拷贝到可执行文件中,这样做的好处是:适用范围较广,不用担心用户机器缺少某个库文件;缺点是:安装包会比较大,而且多个应用程序之间,无法共享文件.</li>
<li>动态连接的做法正好相反,外部函数库不进入安装包,只在运行时动态引用.这样做的好处是:安装包比较小,多个应用程序可以共享文件;缺点是:用户必须事先安装好库文件,而且版本和安装位置都必须符合要求,否则就不能正常运行</li>
</ul>
<h2 id="ld-–-GNU-linker（连接器）"><a href="#ld-–-GNU-linker（连接器）" class="headerlink" title="ld – GNU linker（连接器）"></a>ld – GNU linker（连接器）</h2><ul>
<li>概述：<ul>
<li>ld 合并一组目标文件(<code>object</code>)和库文件(<code>archive</code>),重定位数据部分,构建符号引用(<code>symbolreference</code>).</li>
<li>一般说来,编译生成可执行文件的最后步骤就是调用<code>ld</code></li>
</ul>
</li>
</ul>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li><p><code>-rpath directory</code></p>
<ul>
<li>增加一条对运行时(<code>runtime</code>)库的搜索路径. 这个选项用于连接<code>ELF</code>可执行文件和共享目标库</li>
<li>所有<code>-rpath</code>选项的参数被合并,然后一起传递给运行时<code>linker</code>,运行时<code>linker</code>在运行的时候使用这些路径寻找共享目标库. </li>
<li>如果连接<code>ELF</code>可执行文件时没有指定<code>-rpath</code>选项,<code>linker</code>就使用环境变量<code>LD_RUN_PATH</code>的内容,只要这个环境变量存在.</li>
</ul>
</li>
<li><p><code>-Wl</code></p>
<ul>
<li>如果通过编译器驱动程序（例如 <code>gcc</code>）间接调用链接器，则所有链接器命令行选项都应以<code>-Wl</code>为前缀</li>
<li>这很重要，因为否则编译器驱动程序可能会默默地删除链接器选项，从而导致链接错误</li>
</ul>
</li>
<li><p><code>-s</code></p>
<ul>
<li>去掉输出文件中的全部符号信息</li>
</ul>
</li>
<li><p><code>-g</code></p>
<ul>
<li>虚设项;用于兼容其他工具</li>
</ul>
</li>
</ul>
<h2 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h2><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><ul>
<li><p><code>-fPIC</code></p>
<ul>
<li>如果目标机器支持，则发出与位置无关的代码，适用于动态链接并避免对全局偏移表大小的任何限制</li>
<li>与位置无关的代码需要特殊支持，因此仅适用于某些机器</li>
<li>设置此标志时，宏“__pic__”和“__PIC__”被定义为 2</li>
</ul>
</li>
<li><p><code>-Wno-unused-variable</code></p>
<ul>
<li>不显示未使用的变量告警</li>
</ul>
</li>
<li><p><code>-Wno-unused-result</code></p>
<ul>
<li>不要警告标记了属性的函数的调用者是否使用它的返回值<code>warn_unused_result</code>（请参阅函数属性）。默认是<code>-Wunused-</code>结果</li>
</ul>
</li>
<li><p><code>-Wno-deprecated-declarations</code></p>
<ul>
<li>不要警告使用属性标记为弃用的函数（请参阅函数属性），变量（请参阅变量属性）和类型（请参阅类型属性）<code>deprecated</code></li>
</ul>
</li>
<li><p><code>-DMACRO</code></p>
<ul>
<li>以字符串”1”定义 <code>MACRO</code> 宏</li>
</ul>
</li>
<li><p><code>-DMACRO=DEFN</code></p>
<ul>
<li>以字符串”DEFN”定义 <code>MACRO</code> 宏。</li>
</ul>
</li>
<li><p><code>-DVERSION_MAJOR=$&#123;VERSION_MAJOR&#125;</code></p>
<ul>
<li>以变量 <code>VERSION_MAJOR</code> 定义 <code>VERSION_MAJOR</code> 宏</li>
</ul>
</li>
<li><p><code>-funroll-loops</code></p>
<ul>
<li>循环展开，可以减少循环的次数，对程序的性能带了两方面的提高</li>
<li>一是，减少了对循环没有直接贡献的计算，比如循环计数变量的计算，分支跳转指令的执行等</li>
<li>二是，提供了进一步利用机器特性进行的优化的机会</li>
</ul>
</li>
<li><p><code>-march=cpu-type</code></p>
<ul>
<li>优化选项。指定目标架构的名字，以及（可选的）一个或多个功能修饰符。 </li>
<li>此选项的格式为: <code>-march = arch &#123;+ [no] feature&#125; *</code></li>
</ul>
</li>
</ul>
<h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul>
<li><p>从运行时的依赖关系来看 ： </p>
<ul>
<li>对性能有较大影响的组件有 kernel 和 glibc ，虽然这严格说来这不属于本文的话题，但是经过精心选择、精心配置、精心编译的内核与C库将对提高系统的运行速度起着基础性的作用</li>
</ul>
</li>
<li><p>从被编译的软件包来看 ： </p>
<ul>
<li>每个软件包的 configure 脚本都提供了许多配置选项，其中有许多选项是与性能息息相关的。比如，对于 Apache-2.2.6 而言，你可以使用 –enable-MODULE&#x3D;static 将模块静态编译进核心，使用 –disable-MODULE 禁用不需要的模块，使用 –with-mpm&#x3D;MPM 选择一个高效的多路处理模块，在不需要IPv6的情况下使用 –disable-ipv6 禁用IPv6支持，在不使用线程化的MPM时使用 –disable-threads 禁用线程支持，等等……这部分内容显然不可能在本文中进行完整的讲述，本文只能讲述与优化相关的通用选项。针对特定的软件包，请在编译前使用 configure –help 查看所有选项，并精心选择。</li>
</ul>
</li>
<li><p>从编译过程自身来看 ： </p>
<ul>
<li>将源代码编译为二进制文件是在 Makefile 文件的指导下，由 make 程序调用一条条编译命令完成的。而将源代码编译为二进制文件又需要经过以下四个步骤：预处理(cpp) → 编译(gcc或g++) → 汇编(as) → 连接(ld) ；括号中表示每个阶段所使用的程序，它们分别属于 GCC 和 Binutils 软件包。显然的，优化应当从编译工具自身的选择以及控制编译工具的行为入手</li>
</ul>
</li>
</ul>
<h3 id="编译工具的选择"><a href="#编译工具的选择" class="headerlink" title="编译工具的选择"></a>编译工具的选择</h3><ul>
<li>对于编译工具自身的选择，在假定使用 Binutils 和 GCC 以及 Make 的前提下，没什么好说的，基本上新版本都能带来性能提升，同时比老版本对新硬件的支持更好，所以应当尽量选用新版本。不过追新也可能带来系统的不稳定，这 就要针对实际情况进行权衡了</li>
</ul>
<h3 id="CC和CXX"><a href="#CC和CXX" class="headerlink" title="CC和CXX"></a>CC和CXX</h3><ul>
<li>这是 C 与 C++ 编译器命令。默认值一般是 “gcc” 与 “g++”</li>
</ul>
<h3 id="CPPFLAGS"><a href="#CPPFLAGS" class="headerlink" title="CPPFLAGS"></a>CPPFLAGS</h3><ul>
<li><p>这是用于预处理阶段的选项。不过能够用于此变量的选项，看不出有哪个与优化相关。如果你实在想设一个，那就使用下面这两个吧：</p>
</li>
<li><p><code>-DNDEBUG</code></p>
<ul>
<li>“NDEBUG”是一个标准的 ANSI 宏，表示不进行调试编译。</li>
</ul>
</li>
<li><p><code>-D_FILE_OFFSET_BITS=64</code></p>
<ul>
<li>大多数包使用这个来提供大文件(&gt;2G)支持。</li>
</ul>
</li>
</ul>
<h3 id="CFLAGS-与-CXXFLAGS"><a href="#CFLAGS-与-CXXFLAGS" class="headerlink" title="CFLAGS 与 CXXFLAGS"></a>CFLAGS 与 CXXFLAGS</h3><ul>
<li><p>CFLAGS 表示用于 C 编译器的选项；CXXFLAGS 表示用于 C++ 编译器的选项。这两个变量实际上涵盖了编译和汇编两个步骤</p>
</li>
<li><p>大多数程序和库在编译时默认的优化级别是”2”(使用”-O2”选项)并且带有调试符号来编译，也就是 CFLAGS&#x3D;”-O2 -g”, CXXFLAGS&#x3D;$CFLAGS 。</p>
</li>
<li><p>事实上，”-O2”已经启用绝大多数安全的优化选项了。另一方面，由于大部分选项可以同时用于这两个变量，所以仅在最后讲述只能用于其中一个变量的选 项。提醒：下面所列选项皆为非默认选项，你只要按需添加即可。</p>
</li>
<li><p>先说说”-O3”在”-O2”基础上增加的几项：</p>
<ul>
<li><code>-finline-functions</code> : 允许编译器选择某些简单的函数在其被调用处展开，比较安全的选项，特别是在CPU二级缓存较大时建议使用。</li>
<li><code>-funswitch-loops</code> : 将循环体中不改变值的变量移动到循环体之外</li>
<li><code>-fgcse-after-reload</code> : 为了清除多余的溢出，在重载之后执行一个额外的载入消除步骤。</li>
</ul>
</li>
<li><p>参考链接：<code>https://sites.google.com/site/polarisnotme/linux/gcc</code></p>
</li>
</ul>
<h3 id="LDFLAGS"><a href="#LDFLAGS" class="headerlink" title="LDFLAGS"></a>LDFLAGS</h3><ul>
<li><p>LDFLAGS 是传递给连接器的选项。这是一个常被忽视的变量，事实上它对优化的影响也是很明显的。</p>
</li>
<li><p><code>-s</code> : 删除可执行程序中的所有符号表和所有重定位信息。其结果与运行命令 strip 所达到的效果相同，这个选项是比较安全的。</p>
</li>
<li><p><code>-Wl,options</code> : options是由一个或多个逗号分隔的传递给链接器的选项列表。其中的每一个选项均会作为命令行选项提供给链接器。</p>
</li>
<li><p><code>-Wl,-On</code> : 当n&gt;0时将会优化输出，但是会明显增加连接操作的时间，这个选项是比较安全的。</p>
</li>
<li><p><code>-Wl,--exclude-libs=ALL</code> : 不自动导出库中的符号，也就是默认将库中的符号隐藏。</p>
</li>
<li><p><code>-Wl,-m&lt;emulation&gt;</code> : 仿真<code>&lt;emulation&gt;</code>连接器，当前ld所有可用的仿真可以通过”ld -V”命令获取。默认值取决于ld的编译时配置</p>
</li>
<li><p><code>-Wl,--sort-common</code> : 把全局公共符号按照大小排序后放到适当的输出节，以防止符号间因为排布限制而出现间隙。</p>
</li>
<li><p><code>-Wl,-x</code> : 删除所有的本地符号。</p>
</li>
<li><p><code>-Wl,-X</code> : 删除所有的临时本地符号。对于大多数目标平台，就是所有的名字以’L’开头的本地符号。</p>
</li>
<li><p><code>-Wl,-zcomberloc</code> : 组合多个重定位节并重新排布它们，以便让动态符号可以被缓存。</p>
</li>
<li><p><code>-Wl,--enable-new-dtags</code> : 在ELF中创建新式的”dynamic tags”，但在老式的ELF系统上无法识别。</p>
</li>
<li><p><code>-Wl,--as-needed</code> : 移除不必要的符号引用，仅在实际需要的时候才连接，可以生成更高效的代码。</p>
</li>
<li><p><code>-Wl,--no-define-common</code> : 限制对普通符号的地址分配。该选项允许那些从共享库中引用的普通符号只在主程序中被分配地址。这会消除在共享库中的无用的副本的空间，同时也防止了在有多个指定了搜索路径的动态模块在进行运行时符号解析时引起的混乱。</p>
</li>
<li><p><code>-Wl,--hash-style=gnu</code> : 使用gnu风格的符号散列表格式。它的动态链接性能比传统的sysv风格(默认)有较大提升，但是它生成的可执行程序和库与旧的Glibc以及动态链接器不兼容。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">C++_智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>C&#x2F;C++ 语言最为人所诟病的特性之一就是存在内存泄露问题，因此后来的大多数语言都提供了内置内存分配与释放功能，有的甚至干脆对语言的使用者屏蔽了内存指针这一概念。这里不置贬褒，手动分配内存与手动释放内存有利也有弊，自动分配内存和自动释放内存亦如此，这是两种不同的设计哲学。有人认为，内存如此重要的东西怎么能放心交给用户去管理呢？而另外一些人则认为，内存如此重要的东西怎么能放心交给系统去管理呢？在 C&#x2F;C++ 语言中，内存泄露的问题一直困扰着广大的开发者，因此各类库和工具的一直在努力尝试各种方法去检测和避免内存泄露，如 boost，智能指针技术应运而生。</p>
</li>
<li><p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。简要的说，智能指针利用了 C++ 的 RAII 机制，在智能指针对象作用域结束后，会自动做内存释放的相关操作，不需要我们再手动去操作内存。但是智能指针也不只是说的简简单单的自动释放内存这么简单，在使用上有一些坑需要注意，将会在下文中提到</p>
</li>
<li><p>C++ 中有四种智能指针：<code>auto_pt、unique_ptr、shared_ptr、weak_ptr</code> 其中后三个是 C++11 支持，第一个已经被 C++11 弃用且被 unique_prt 代替，不推荐使用。下文将对其逐个说明</p>
</li>
</ul>
<hr>
<h2 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a>std::auto_ptr</h2><ul>
<li><p>在这个年代讨论 std::auto_ptr 不免有点让人怀疑是不是有点过时了，确实如此，随着 C++11 标准的出现（最新标准是 C++20），std::auto_ptr 已经被彻底放弃，取而代之是 std::unique_ptr。然而，之所以还向介绍一下 std::auto_ptr 的用法以及它的设计不足之处是想更多了解 C++ 语言中智能指针的发展过程，一项技术如果我们了解它过去的样子和发展的轨迹，我们就能更好地掌握它</p>
</li>
<li><p>std::auto_ptr 的基本用法如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //初始化方式1</span><br><span class="line">    std::auto_ptr&lt;int&gt; ap1(new int(8));</span><br><span class="line">    //初始化方式2</span><br><span class="line">    std::auto_ptr&lt;int&gt; ap2;</span><br><span class="line">    ap2.reset(new int(8));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>智能指针对象 ap1 和 ap2 均持有一个在堆上分配 int 对象，其值均是 8，这两块堆内存均可以在 ap1 和 ap2 释放时得到释放。这是 std::auto_ptr 的基本用法</p>
</li>
</ul>
<hr>
<ul>
<li><p>std::auto_ptr 真正让人容易误用的地方是其不常用的复制语义，即当复制一个 std::auto_ptr 对象时（拷贝复制或 operator&#x3D; 复制），原对象所持有的堆内存对象也会转移给复制出来的对象</p>
</li>
<li><p>利用拷贝构造（ap1 &#x3D;&gt; ap2）和 赋值构造（ap3 &#x3D;&gt; ap4）来创建新的 std::auto_ptr 对象，因此 ap1 持有的堆对象被转移给 ap2，ap3 持有的堆对象被转移给 ap4。而 ap1 和 ap2 已经指向 NULL，若现在再对 ap1 和 ap2 进行访问并操作，将会出现内存错误问题</p>
</li>
<li><p>由于 std::auto_ptr 这种不常用的复制语义，我们应该避免在 stl 容器中使用 std::auto_ptr，例如我们绝不应该写出如下代码：</p>
<ul>
<li><code>std::vector&lt;std::auto_ptr&lt;int&gt;&gt; myvectors;</code></li>
<li>当用算法对容器操作的时候（如最常见的容器元素遍历），很难避免不对容器中的元素实现赋值传递，这样便会使容器中多个元素被置为空指针，这不是我们想看到的，会造成很多意想不到的错误</li>
</ul>
</li>
<li><p>正因为 std::auto_ptr 的设计存在如此重大缺陷，C++11 标准在充分借鉴和吸收了 boost 库中智能指针的设计思想，引入了三种类型的智能指针，即 std::unique_ptr、std::shared_ptr 和 std::weak_ptr。</p>
</li>
<li><p>boost 还有 scoped_ptr，C++11 并没有全部照搬，而是选择了三个最实用的指针类型。在 C++11 中可以通过 std::unique_ptr 达到与 boost::scoped_ptr 一样的效果。</p>
</li>
<li><p>所有的智能指针类（包括 std::unique_ptr）均包含于头文件 <code>&lt;memory&gt;</code> 中。</p>
</li>
</ul>
<hr>
<h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><ul>
<li><p>作为对 std::auto_ptr 的改进，std::unique_ptr 对其持有的堆内存具有唯一拥有权，也就是 std::unique_ptr 不可以拷贝或赋值给其他对象，其拥有的堆内存仅自己独占，std::unique_ptr 对象销毁时会释放其持有的堆内存</p>
</li>
<li><p>可以使用以下方式初始化一个 std::unique_ptr 对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化方式1</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line">    <span class="comment">//初始化方式2</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up2;</span><br><span class="line">    up<span class="number">2.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">123</span>));</span><br><span class="line">    <span class="comment">//初始化方式3 (-std=c++14)</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up3 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>应该尽量使用初始化方式 3 的方式去创建一个 std::unique_ptr 而不是方式 1 和 2，因为形式 3 更安全，原因 Scott Meyers 在其《Effective Modern C++》中已经解释过了，有兴趣的可以阅读此书相关章节</p>
</li>
<li><p>令很多人对 C++11 规范不满的地方是，C++11 新增了 std::make_shared() 方法创建一个 std::shared_ptr 对象，却没有提供相应的 std::make_unique() 方法创建一个 std::unique_ptr 对象，这个方法直到 C++14 才被添加进来。当然，在 C++11 中你很容易实现出这样一个方法来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename... Ts&gt;</span><br><span class="line">std::unique_ptr&lt;T&gt; make_unique(Ts &amp;&amp;...params)</span><br><span class="line">&#123;</span><br><span class="line">    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>鉴于 std::auto_ptr 的前车之鉴，std::unique_ptr 禁止复制语义，为了达到这个效果，std::unique_ptr 类的拷贝构造函数和赋值运算符（operator &#x3D;）被标记为 delete</p>
</li>
</ul>
<hr>
<ul>
<li><p>禁止复制语义也存在特例，即可以通过一个函数返回一个 std::unique_ptr：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">func</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(val))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> up;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up1 = <span class="built_in">func</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上述代码从 func 函数中得到一个 std::unique_ptr 对象，然后返回给 up1</p>
</li>
<li><p>既然 std::unique_ptr 不能复制，那么如何将一个 std::unique_ptr 对象持有的堆内存转移给另外一个呢？答案是使用移动构造，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up1</span><span class="params">(std::make_unique&lt;<span class="type">int</span>&gt;(<span class="number">123</span>))</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up2</span><span class="params">(std::move(up1))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; ((up<span class="number">1.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span>) ? <span class="string">&quot;up1 is NULL&quot;</span> : <span class="string">&quot;up1 is not NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up3;</span><br><span class="line">    up3 = std::<span class="built_in">move</span>(up2);</span><br><span class="line">    std::cout &lt;&lt; ((up<span class="number">2.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span>) ? <span class="string">&quot;up2 is NULL&quot;</span> : <span class="string">&quot;up2 is not NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以上代码利用 std::move 将 up1 持有的堆内存（值为 123）转移给 up2，再把 up2 转移给 up3。最后，up1 和 up2 不再持有堆内存的引用，变成一个空的智能指针对象</p>
</li>
<li><p>并不是所有的对象的 std::move 操作都有意义，只有实现了移动构造函数或移动赋值运算符的类才行，而 std::unique_ptr 正好实现了这二者</p>
</li>
</ul>
<hr>
<ul>
<li>std::unique_ptr 不仅可以持有一个堆对象，也可以持有一组堆对象，示例如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建10个int类型的堆对象</span></span><br><span class="line">    <span class="comment">//形式1</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">    <span class="comment">//形式2</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>[]&gt; up2;</span><br><span class="line">    up<span class="number">2.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]);</span><br><span class="line">    <span class="comment">//形式3</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up3</span><span class="params">(std::make_unique&lt;<span class="type">int</span>[]&gt;(<span class="number">10</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        up1[i] = i;</span><br><span class="line">        up2[i] = i;</span><br><span class="line">        up3[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; up1[i] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; up2[i] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; up3[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>std::shared_ptr 和 std::weak_ptr 也可以持有一组堆对象，用法与 std::unique_ptr 相同，下文不再赘述</li>
</ul>
<hr>
<ul>
<li>另外，std::unique_ptr 有几个常用函数如下：<ul>
<li><code>void reset(pointer p = pointer())</code><ul>
<li>释放当前由 unique_ptr（如果有）管理的指针并获得参数 p（参数 p 默认为 NULL）的所有权。如果 p 是空指针（例如默认初始化的指针），则 unique_ptr 变为空，调用后不管理任何对象。</li>
</ul>
</li>
<li><code>pointer release()</code><ul>
<li>返回管理的指针并将其替换为空指针， 释放其管理指针的所有权。这个调用并不会销毁托管对象，但是将 unique_ptr 对象管理的指针解脱出来。如果要强制销毁所指向的对象，请调用 reset 函数或对其执行赋值操作</li>
</ul>
</li>
<li><code>element_type* get()</code><ul>
<li>返回存储的指针，不会使 unique_ptr 释放指针的所有权。因此，该函数返回的值不能于构造新的托管指针，如果为了获得存储的指针并释放其所有权，请调用 release。</li>
</ul>
</li>
<li><code>void swap (unique_ptr&amp; x)</code><ul>
<li>将 unique_ptr 对象的内容与对象 x 进行交换，在它们两者之间转移管理指针的所有权而不破坏二者。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>自定义智能指针对象持有的资源的释放函数<ul>
<li>默认情况下，智能指针对象在析构时只会释放其持有的堆内存（调用 delete 或者 delete[]），但是假设这块堆内存代表的对象还对应一种需要回收的资源（如操作系统的套接字句柄、文件句柄等），我们可以通过自定义智能指针的资源释放函数。假设现在有一个 Socket 类，对应着操作系统的套接字句柄，在回收时需要关闭该对象，我们可以如下自定义智能指针对象的资源析构函数，这里以 std::unique_ptr 为例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Socket</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Socket</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源句柄</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> deletor = [](Socket *pSocket)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//关闭句柄</span></span><br><span class="line">        pSocket-&gt;<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 你甚至可以在这里打印一行日志...</span></span><br><span class="line">        <span class="keyword">delete</span> pSocket;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Socket, <span class="title">void</span> <span class="params">(*)</span><span class="params">(Socket * pSocket)</span>&gt; <span class="title">upSocket</span><span class="params">(<span class="keyword">new</span> Socket(), deletor)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>自定义 std::unique_ptr 的资源释放函数其规则是：<ul>
<li><code>std::unique_ptr&lt;T, DeletorFuncPtr&gt;</code> </li>
<li>其中 T 是你要释放的对象类型，DeletorPtr 是一个自定义函数指针。</li>
<li>上述代码 28 行表示 DeletorPtr 有点复杂（是 C++11 中的 Lambda 函数），我们可以使用 decltype(deletor) 让编译器自己推导 deletor 的类型，因此可以将 28 行代码修改为：<ul>
<li><code>std::unique_ptr&lt;Socket, decltype(deletor)&gt; upSocket(new Socket(), deletor);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><ul>
<li>std::unique_ptr 对其持有的资源具有独占性，而 std::shared_ptr 持有的资源可以在多个 std::shared_ptr 之间共享，每多一个 std::shared_ptr 对资源的引用，资源引用计数将增加 1，每一个指向该资源的 std::shared_ptr 对象析构时，资源引用计数减 1，最后一个 std::shared_ptr 对象析构时，发现资源计数为 0，将释放其持有的资源。多个线程之间，递增和减少资源的引用计数是安全的。（注意：这不意味着多个线程同时操作 std::shared_ptr 引用的对象是安全的）。std::shared_ptr 提供了一个 use_count() 方法来获取当前持有资源的引用计数。除了上面描述的，std::shared_ptr 用法和 std::unique_ptr 基本相同</li>
<li>下面是一个初始化 std::shared_ptr 的示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化方式1</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化方式2</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp2;</span><br><span class="line">    sp<span class="number">2.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">123</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化方式3</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp3;</span><br><span class="line">    sp3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>和 std::unique_ptr 一样，你应该优先使用 std::make_shared 去初始化一个 std::shared_ptr 对象</li>
</ul>
<hr>
<ul>
<li>std::shared_ptr 有几个常用函数如下：<ul>
<li><code>void swap (unique_ptr&amp; x)</code><ul>
<li>将 shared_ptr 对象的内容与对象 x 进行交换，在它们两者之间转移管理指针的所有权而不破坏或改变二者的引用计数</li>
</ul>
</li>
<li><code>void reset()</code></li>
<li><code>void reset (ponit p)</code><ul>
<li>没有参数时，先将管理的计数器引用计数减一并将管理的指针和计数器置清零。有参数 p 时，先做面前没有参数的操作，再管理 p 的所有权和设置计数器</li>
</ul>
</li>
<li><code>element_type* get()</code><ul>
<li>得到其管理的指针。</li>
</ul>
</li>
<li><code>long int use_count()</code><ul>
<li>返回与当前智能指针对象在同一指针上共享所有权的 shared_ptr 对象的数量，如果这是一个空的 shared_ptr，则该函数返回 0。如果要用来检查 use_count 是否为 1，可以改用成员函数 unique 会更快。</li>
</ul>
</li>
<li><code>bool unique()</code><ul>
<li>返回当前 shared_ptr 对象是否不和其他智能指针对象共享指针的所有权，如果这是一个空的 shared_ptr，则该函数返回 false</li>
</ul>
</li>
<li><code>element_type&amp; operator\*()</code><ul>
<li>重载指针的 * 运算符，返回管理的指针指向的地址的引用。</li>
</ul>
</li>
<li><code>element_type* operator-&gt;()</code><ul>
<li>重载指针的 -&gt; 运算符，返回管理的指针，可以访问其成员</li>
</ul>
</li>
<li><code>explicit operator bool()</code><ul>
<li>返回存储的指针是否已经是空指针，返回的结果与 get() !&#x3D; 0 相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><code>std::enable_shared_from_this</code><ul>
<li>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个 std::shared_ptr 对象给外部使用，C++ 新标准也为我们考虑到了这一点，有如此需求的类只要继承自 std::enable_shared_from_this 模板对象即可。用法如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;A&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">getSelf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;A&gt; sp2 = sp1-&gt;<span class="built_in">getSelf</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>上述代码中，类 A 的继承 std::enable_shared_from_this 并提供一个 getSelf() 方法返回自身的 std::shared_ptr 对象，在 getSelf() 中调用 shared_from_this() 即可</li>
</ul>
</li>
<li>std::enable_shared_from_this 用起来比较方便，但是也存在很多不易察觉的陷阱<ul>
<li>陷阱一：不应该共享栈对象的 this 给智能指针对象<ul>
<li>假设我们将上面代码 main 函数 25 行生成 A 对象的方式改成一个栈变量，即：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他相同代码省略...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;A&gt; sp2 = a.<span class="built_in">getSelf</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行修改后的代码会发现程序在 std::shared_ptr sp2 &#x3D; a.getSelf() 产生崩溃。这是因为，智能指针管理的是堆对象，栈对象会在函数调用结束后自行销毁，因此不能通过 shared_from_this() 将该对象交由智能指针对象管理。</li>
<li><strong>切记：</strong> 智能指针最初设计的目的就是为了管理堆对象的（即那些不会自动释放的资源）</li>
</ul>
</li>
<li>陷阱二：避免 std::enable_shared_from_this 的循环引用问题<ul>
<li>再来看另外一段代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;A&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_i = <span class="number">9</span>;</span><br><span class="line">        <span class="comment">//注意:</span></span><br><span class="line">        <span class="comment">//比较好的做法是在构造函数里面调用shared_from_this()给m_SelfPtr赋值</span></span><br><span class="line">        <span class="comment">//但是很遗憾不能这么做,如果写在构造函数里面程序会直接崩溃</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_SelfPtr = <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    std::shared_ptr&lt;A&gt; m_SelfPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;A&gt; <span class="title">spa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">        spa-&gt;<span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>乍一看上面的代码好像看不出什么问题，让我们来实际运行一下看看输出结果：<ul>
<li><code>A constructor</code></li>
</ul>
</li>
<li>我们发现在程序的整个生命周期内，只有 A 类构造函数的调用输出，没有 A 类析构函数的调用输出，这意味着 new 出来的 A 对象产生了内存泄漏！</li>
<li>我们来分析一下为什么 new 出来的 A 对象得不到释放。当程序执行到 39 行后，spa 出了其作用域准备析构，在析构时其发现仍然有另外的一个 std::shared_ptr 对象即 A::m_SelfPtr 引用了 A，因此 spa 只会将 A 的引用计数递减为 1，然后就销毁自身了。现在留下一个矛盾的处境：必须销毁 A 才能销毁其成员变量 m_SelfPtr，而销毁 m_SelfPtr 必须先销毁 A。这就是所谓的 std::enable_shared_from_this 的循环引用问题。我们在实际开发中应该避免做出这样的逻辑设计，这种情形下即使使用了智能指针也会造成内存泄漏。</li>
<li>也就是说: <strong>一个资源的生命周期可以交给一个智能指针对象，但是该智能指针的生命周期不可以再交给整个资源来管理</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><ul>
<li>std::weak_ptr 是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助 std::shared_ptr 工作</li>
<li>std::weak_ptr 可以从一个 std::shared_ptr 或另一个 std::weak_ptr 对象构造，std::shared_ptr 可以直接赋值给 std::weak_ptr ，也可以通过 std::weak_ptr 的 lock() 函数来获得 std::shared_ptr。它的构造和析构不会引起引用计数的增加或减少。std::weak_ptr 可用来解决 std::shared_ptr 相互引用时的死锁问题（即两个std::shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0， 资源永远不会释放）</li>
<li>示例代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个std::shared_ptr对象</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造函数得到一个std::weak_ptr对象</span></span><br><span class="line">    <span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过赋值运算符得到一个std::weak_ptr对象</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; sp3 = sp1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过一个std::weak_ptr对象得到另外一个std::weak_ptr对象</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; sp4 = sp2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use count: 1</span><br><span class="line">use count: 1</span><br><span class="line">use count: 1</span><br><span class="line">use count: 1</span><br></pre></td></tr></table></figure></li>
<li>无论通过何种方式创建 std::weak_ptr 都不会增加资源的引用计数，因此每次输出引用计数的值都是 1。</li>
</ul>
<hr>
<ul>
<li>既然，std::weak_ptr 不管理对象的生命周期，那么其引用的对象可能在某个时刻被销毁了，如何得知呢？std::weak_ptr 提供了一个 expired() 方法来做这一项检测，返回 true，说明其引用的资源已经不存在了；返回 false，说明该资源仍然存在，这个时候可以使用 std::weak_ptr 的 lock() 方法得到一个 std::shared_ptr 对象然后继续操作资源，以下代码演示了该用法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tmpConn_ 是一个 std::weak_ptr&lt;TcpConnection&gt; 对象</span></span><br><span class="line"><span class="comment">// tmpConn_ 引用的TcpConnection已经销毁，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (tmpConn_.<span class="built_in">expired</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;TcpConnection&gt; conn = tmpConn_.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (conn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对conn进行操作，省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>有读者可能对上述代码产生疑问，既然使用了 std::weak_ptr 的 expired() 方法判断了对象是否存在，为什么不直接使用 std::weak_ptr 对象对引用资源进行操作呢？实际上这是行不通的，std::weak_ptr 类没有重写 operator-&gt; 和 operator* 方法，因此不能像 std::shared_ptr 或 std::unique_ptr 一样直接操作对象，同时 std::weak_ptr 类也没有重写 operator! 操作，因此也不能通过 std::weak_ptr 对象直接判断其引用的资源是否存在：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::weak_ptr&lt;A&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确代码</span></span><br><span class="line">    <span class="keyword">if</span> (sp1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正确代码</span></span><br><span class="line">        sp1-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">        (*sp1).<span class="built_in">doSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确代码</span></span><br><span class="line">    <span class="keyword">if</span> (!sp1)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误代码，无法编译通过</span></span><br><span class="line">    <span class="comment">//if (sp2)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    //错误代码，无法编译通过</span></span><br><span class="line">    <span class="comment">//    sp2-&gt;doSomething();</span></span><br><span class="line">    <span class="comment">//    (*sp2).doSomething();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误代码，无法编译通过</span></span><br><span class="line">    <span class="comment">//if (!sp2)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>之所以 std::weak_ptr 不增加引用资源的引用计数不管理资源的生命周期，是因为，即使它实现了以上说的几个方法，调用它们也是不安全的，因为在调用期间，引用的资源可能恰好被销毁了，这会造成棘手的错误和麻烦</li>
</ul>
<hr>
<ul>
<li><p>因此，std::weak_ptr 的正确使用场景是那些资源如果可能就使用，如果不可使用则不用的场景，它不参与资源的生命周期管理。例如，网络分层结构中，Session 对象（会话对象）利用 Connection 对象（连接对象）提供的服务工作，但是 Session 对象不管理 Connection 对象的生命周期，Session 管理 Connection 的生命周期是不合理的，因为网络底层出错会导致 Connection 对象被销毁，此时 Session 对象如果强行持有 Connection 对象与事实矛盾</p>
</li>
<li><p>std::weak_ptr 的应用场景，经典的例子是订阅者模式或者观察者模式中。这里以订阅者为例来说明，消息发布器只有在某个订阅者存在的情况下才会向其发布消息，而不能管理订阅者的生命周期</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubscribeManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publish</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;iter : m_subscribers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!iter.<span class="built_in">expired</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//TODO：给订阅者发送消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::weak_ptr&lt;Subscriber&gt;&gt; m_subscribers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>另外，std::weak_ptr 有几个常用函数如下<ul>
<li><code>void swap (weak_ptr&amp; x)</code><ul>
<li>将当前 weak_ptr 对象的内容与 x 的内容交换</li>
</ul>
</li>
<li><code>void reset()</code><ul>
<li>将当前 weak_ptr 对象管理的指针和计数器变成空的，就像默认构造的一样。</li>
</ul>
</li>
<li><code>long int use_count()</code><ul>
<li>返回与当前 weak_ptr 对象在同一指针上共享所有权的 shared_ptr 对象的数量。</li>
</ul>
</li>
<li><code>bool expired()</code><ul>
<li>检查是否过期，返回 weak_ptr 对象管理的指针为空，或者和他所属共享的没有更多 shared_ptr。lock 函数一般需要先调用 expired 判断，如果已经过期，就不能通过 weak_ptr 恢复拥有的 shared_ptr。此函数应返回与（use_count() &#x3D;&#x3D; 0）相同的值，但是它可能以更有效的方式执行此操作。</li>
</ul>
</li>
<li><code>shared_ptr&lt;element_type&gt; lock()</code><ul>
<li>如果它没有过期，则返回一个 shared_ptr，其中包含由 weak_ptr 对象保留的信息。如果 weak_ptr 对象已经过期，则该函数返回一个空的 shared_ptr（默认构造一样）。因为返回的 shared_ptr 对象也算作一个所有者，所以这个函数锁定了拥有的指针，防止它被释放（至少在返回的对象没有释放它的情况下）。 此操作以原子方式执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="智能指针使用注意事项"><a href="#智能指针使用注意事项" class="headerlink" title="智能指针使用注意事项"></a>智能指针使用注意事项</h2><ul>
<li>C++ 新标准提倡的理念之一是不应该再手动调用 delete 或者 free 函数去释放内存了，而应该把它们交给新标准提供的各种智能指针对象。C++ 新标准中的各种智能指针是如此的实用与强大，在现代 C++ 项目开发中，我们应该尽量去使用它们。</li>
<li>智能指针虽然好用，但稍不注意，也可能存在许多难以发现的 bug，这里我根据经验总结了几条</li>
</ul>
<hr>
<ul>
<li><p>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作</p>
</li>
<li><p>一段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subscriber *pSubscriber = <span class="keyword">new</span> <span class="built_in">Subscriber</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Subscriber&gt; <span class="title">spSubscriber</span><span class="params">(pSubscriber)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pSubscriber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这段代码利用创建了一个堆对象 Subscriber，然后利用智能指针 spSubscriber 去管理之，可以却私下利用原始指针销毁了该对象，这让智能指针对象 spSubscriber 情何以堪啊？</p>
</li>
<li><p>记住，一旦智能指针对象接管了你的资源，所有对资源的操作都应该通过智能指针对象进行，不建议再通过原始指针进行操作了。</p>
</li>
<li><p>当然，除了 std::weak_ptr 之外，std::unique_ptr 和 std::shared_ptr 都提供了获取原始指针的方法——get() 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subscriber *pSubscriber = <span class="keyword">new</span> <span class="built_in">Subscriber</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Subscriber&gt; <span class="title">spSubscriber</span><span class="params">(pSubscriber)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pTheSameSubscriber和pSubscriber指向同一个对象</span></span><br><span class="line">    Subscriber *pTheSameSubscriber = spSubscriber.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>分清楚场合应该使用哪种类型的智能指针</li>
<li>通常情况下，如果你的资源不需要在其他地方共享，那么应该优先使用 std::unique_ptr，反之使用 std::shared_ptr，当然这是在该智能指针需要管理资源的生命周期的情况下；如果不需要管理对象的生命周期，请使用 std::weak_ptr</li>
</ul>
<hr>
<ul>
<li>认真考虑，避免操作某个引用资源已经释放的智能指针</li>
<li>前面的例子，一定让你觉得非常容易知道一个智能指针的持有的资源是否还有效，但是还是建议在不同场景谨慎一点，有些场景是很容易造成误判。例如下面的代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T do something...&quot;</span> &lt;&lt; m_i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> T())</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;sp2 = sp1;</span><br><span class="line"></span><br><span class="line">    sp<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于sp2已经不再持有对象的引用，程序会在这里出现意外的行为</span></span><br><span class="line">    sp2-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>上述代码中，sp2 是 sp1 的引用，sp1 被置空后，sp2 也一同为空。这时候调用 sp2-&gt;doSomething()，sp2-&gt;（即 operator-&gt;）在内部会调用 get() 方法获取原始指针对象，这时会得到一个空指针（地址为 0），继续调用 doSomething() 导致程序崩溃</li>
<li>你一定仍然觉得这个例子也能很明显地看出问题，ok，让我们把这个例子放到实际开发中再来看一下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接断开</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MonitorServer::OnClose</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;TcpConnection&gt; &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_sessionMutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = m_sessions.<span class="built_in">begin</span>(); iter != m_sessions.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过比对connection对象找到对应的session</span></span><br><span class="line">        <span class="keyword">if</span> ((*iter)-&gt;<span class="built_in">GetConnectionPtr</span>() == conn)</span><br><span class="line">        &#123;</span><br><span class="line">            m_sessions.<span class="built_in">erase</span>(iter);</span><br><span class="line">            <span class="comment">//注意这里：程序在此处崩溃</span></span><br><span class="line">            <span class="built_in">LOGI</span>(<span class="string">&quot;monitor client disconnected: %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>该段程序会在代码 12 行处崩溃，崩溃原因是调用了 conn-&gt;peerAddress() 方法</li>
<li>崩溃原因是传入的 conn 对象和上一个例子中的 sp2 一样都是另外一个 std::shared_ptr 的引用，当连接断开时，对应的 TcpConnection 对象可能早已被销毁，而 conn 引用就会变成空指针（严格来说是不再拥有一个 TcpConnection 对象），此时调用 TcpConnection 的 peerAddress() 方法就会产生和上一个示例一样的错误</li>
</ul>
<hr>
<ul>
<li>作为类成员变量时，应该优先使用前置声明（forward declarations）</li>
<li>我们知道，为了减小编译依赖加快编译速度和生成二进制文件的大小，C&#x2F;C++ 项目中一般在 *.h 文件对于指针类型尽量使用前置声明，而不是直接包含对应类的头文件</li>
<li>示例<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.h</span></span><br><span class="line"><span class="comment">//在这里使用A的前置声明，而不是直接包含A.h文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    ~<span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A *m_pA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>同样的道理，在头文件中当使用智能指针对象作为类成员变量时，也应该优先使用前置声明去引用智能指针对象的包裹类，而不是直接包含包含类的头文件<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//智能指针包裹类A，这里优先使用A的前置声明，而不是直接包含A.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    ~<span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;A&gt; m_spA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>Modern C&#x2F;C++ 已经变为 C&#x2F;C++ 开发的趋势，希望能善用和熟练这些智能指针对象</li>
</ul>
<hr>
<h2 id="智能指针的简单实现"><a href="#智能指针的简单实现" class="headerlink" title="智能指针的简单实现"></a>智能指针的简单实现</h2><ul>
<li><p>最后，给出智能指针的简单实现，因为 weak_ptr 作为弱引用指针，其实现依赖于 Counter 计数器类和 shared_ptr 的赋值，所以先进行 Counter 计数器类和 share_ptr 的简单实现</p>
</li>
<li><p>Counter的简单实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计数器</span></span><br><span class="line"><span class="comment"> * Counter对象就是用来申请一块内存存储引用计数</span></span><br><span class="line"><span class="comment"> * m_refCount是SharedPtr的引用计数</span></span><br><span class="line"><span class="comment"> * m_weakCount是WeakPtr的引用计数</span></span><br><span class="line"><span class="comment"> * 当m_weakCount为0时删除Counter对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SharedPtr</span>&lt;T&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WeakPtr</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() : <span class="built_in">m_refCount</span>(<span class="number">0</span>), <span class="built_in">m_weakCount</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Counter</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">const</span> Counter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Counter &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Counter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    atomic_uint m_refCount;  <span class="comment">// #shared,原子操作</span></span><br><span class="line">    atomic_uint m_weakCount; <span class="comment">// #weak,原子操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>shared_ptr的简单实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SharedPtr的简单实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WeakPtr</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 构造函数，用原生指针构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>(T *ptr) : <span class="built_in">m_ptr</span>(ptr), <span class="built_in">m_cnt</span>(<span class="keyword">new</span> Counter&lt;T&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            m_cnt-&gt;m_refCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ptr Construct S.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SharedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 拷贝构造函数，用另一个SharedPtr对象构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>(<span class="type">const</span> SharedPtr &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ptr = s.m_ptr;</span><br><span class="line">        s.m_cnt-&gt;m_refCount++;</span><br><span class="line">        m_cnt = s.m_cnt;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;S Copy Construct S.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 拷贝构造函数，用另一个WeakPtr对象构造</span></span><br><span class="line"><span class="comment">     * 为了WeakPtr对象调用自己的lock()方法将自己传进来构造一个SharedPtr返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>(<span class="type">const</span> WeakPtr&lt;T&gt; &amp;w)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ptr = w.m_ptr;</span><br><span class="line">        w.m_cnt-&gt;m_refCount++;</span><br><span class="line">        m_cnt = w.m_cnt;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;W Copy Construct S.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 赋值构造函数，用另一个SharedPtr对象构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SharedPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SharedPtr&lt;T&gt; &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">release</span>();</span><br><span class="line">            m_ptr = s.m_ptr;</span><br><span class="line">            s.m_cnt-&gt;m_refCount++;</span><br><span class="line">            m_cnt = s.m_cnt;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;S Assign Construct S.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_cnt-&gt;m_refCount--;</span><br><span class="line">        <span class="keyword">if</span> (m_cnt-&gt;m_refCount &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_ptr;</span><br><span class="line">            m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;SharedPtr Delete Ptr.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (m_cnt-&gt;m_weakCount &lt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> m_cnt;</span><br><span class="line">                m_cnt = <span class="literal">nullptr</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;SharedPtr Delete Cnt.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;SharedPtr Release.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_ptr;</span><br><span class="line">    Counter&lt;T&gt; *m_cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>weak_ptr的简单实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeakPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 构造函数，用SharedPtr对象构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">WeakPtr</span>(SharedPtr&lt;T&gt; &amp;s) : <span class="built_in">m_ptr</span>(s.m_ptr), <span class="built_in">m_cnt</span>(s.m_cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cnt-&gt;m_weakCount++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;S Construct W.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 构造函数，用WeakPtr对象构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">WeakPtr</span>(WeakPtr&lt;T&gt; &amp;w) : <span class="built_in">m_ptr</span>(w.m_ptr), <span class="built_in">m_cnt</span>(w.m_cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cnt-&gt;m_weakCount++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;W Construct W.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">WeakPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 赋值构造函数，用另一个SharedPtr对象构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WeakPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        m_cnt = s.m_cnt;</span><br><span class="line">        m_cnt-&gt;m_weakCount++;</span><br><span class="line">        m_ptr = s.m_ptr;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;S Assign Construct W.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 赋值构造函数，用另一个WeakPtr对象构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WeakPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(WeakPtr&lt;T&gt; &amp;w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            m_cnt = w.m_cnt;</span><br><span class="line">            m_cnt-&gt;m_weakCount++;</span><br><span class="line">            m_ptr = w-&gt;m_ptr;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;W Assign Construct W.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * WeakPtr通过lock函数获得SharedPtr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SharedPtr&lt;T&gt; &amp;<span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SharedPtr</span>&lt;T&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查SharedPtr是否已过期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">expired</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_cnt-&gt;m_refCount &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">WeakPtr</span>() = <span class="keyword">delete</span>;       WeakPtr禁止默认构造，只能从SharedPtr或者WeakPtr构造</span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() = <span class="keyword">delete</span>;  <span class="comment">//WeakPtr禁止*</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() = <span class="keyword">delete</span>; <span class="comment">//WeakPtr禁止-&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            m_cnt-&gt;m_weakCount--;</span><br><span class="line">            <span class="keyword">if</span> (m_cnt-&gt;m_weakCount &lt; <span class="number">1</span> &amp;&amp; m_cnt-&gt;m_refCount &lt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> m_cnt;</span><br><span class="line">                m_cnt = <span class="literal">nullptr</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Delete Cnt.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;WeakPtr Release.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_ptr;</span><br><span class="line">    Counter&lt;T&gt; *m_cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><code>https://blog.csdn.net/code_peak/article/details/119722167</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E6%83%AF%E7%94%A8%E5%86%99%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E6%83%AF%E7%94%A8%E5%86%99%E6%B3%95/" class="post-title-link" itemprop="url">C++_惯用写法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ 惯用写法</li>
</ul>
<h2 id="以良好的方式编写-C-class"><a href="#以良好的方式编写-C-class" class="headerlink" title="以良好的方式编写 C++ class"></a>以良好的方式编写 C++ class</h2><ul>
<li><p>假设现在我们要实现一个复数类complex，在类的实现过程中探索良好的编程习惯</p>
</li>
<li><p>Header(头文件)中的防卫式声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">complex.h:</span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span>  __COMPLEX__</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>防止头文件的内容被多次包含</p>
</li>
<li><p>把数据放在 private 声明下，提供接口访问数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span>  __COMPLEX__</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        doubel re,im;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不会改变类属性(数据成员)的成员函数，全部加上 const 声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">real</span> <span class="params">()</span> `<span class="type">const</span>` </span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> `<span class="type">const</span>` </span>&#123;<span class="keyword">return</span> im;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>既然函数不会改变对象，那么就如实说明，编译器能帮你确保函数的const属性，阅读代码的人也明确你的意图</p>
</li>
<li><p>而且，const 对象才可以调用这些函数 – const 对象不能调用非const成员函数</p>
</li>
<li><p>使用构造函数初始值列表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i =<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">re</span>(r), <span class="built_in">im</span>(i)  &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        doubel re,im;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在初始值列表中，才是初始化。在构造函数体内的，叫做赋值</p>
</li>
<li><p>如果可以，参数尽量使用 reference to const </p>
</li>
<li><p>为complex类添加一个+&#x3D;操作符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex &amp;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用引用避免类对象构造与析构的开销，使用const确保参数不会被改变。内置类型的值传递与引用传递效率没有多大差别，甚至值传递效率会更高</p>
</li>
<li><p>例如，传递char类型时，值传递只需要传递一个字节；引用实际上是指针实现，需要四个字节(32位机)的传递开销。但是为了一致，不妨统一使用引用。</p>
</li>
<li><p>如果可以，函数返回值也尽量使用引用</p>
</li>
<li><p>以引用方式返回函数局部变量会引发程序为定义行为，离开函数作用域的局部变量被销毁，引用该变量没有意义。但是我要说的是，如果可以，函数应该返回引用。</p>
</li>
<li><p>当然，要放回的变量要有一定限制：改变量必须自进入函数之前，已经被分配了内存。以此条件来考量，很容易决定是否要放回引用。而在函数被调用时才创建出来的对象，一定不能返回引用。</p>
</li>
<li><p>说回 operator+&#x3D;，其返回值就是引用，原因在于，执行a +&#x3D; b时，a已经在内存上存在了。</p>
</li>
<li><p>而 operator+，其返回值不能时引用，因为 a+b 的值，在调用 operator+ 的时候才产生</p>
</li>
<li><p>下面是 operator+&#x3D;与operator+的实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex &amp; complex :: <span class="keyword">operator</span> += (<span class="type">const</span> complex &amp; r)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; re+= r-&gt;re;</span><br><span class="line">        <span class="keyword">this</span> -&gt; im+= r-&gt;im;</span><br><span class="line">        <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> + (<span class="type">const</span> complex &amp; x , <span class="type">const</span> complex &amp; y)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">complex</span> ( <span class="built_in">real</span> (x)+ <span class="built_in">real</span> (y), <span class="comment">//新创建的对象，不能返回引用</span></span><br><span class="line">                         <span class="built_in">imag</span>(x)+ <span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在operator+&#x3D; 中返回引用还是必要的，这样可以使用连续的操作</p>
</li>
<li><p>c3 +&#x3D; c2 +&#x3D; c1;</p>
</li>
<li><p>如果重载了操作符，就考虑是否需要多个重载</p>
</li>
<li><p>就我们的复数来说，+可以有多种使用方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">complex c2;</span><br><span class="line">c2 = c1+ c2;</span><br><span class="line">c2 = c1 + <span class="number">5</span>;</span><br><span class="line">c2 = <span class="number">7</span> + c1;</span><br></pre></td></tr></table></figure></li>
<li><p>为了应付多种加法，+需要有如下三种重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span>+ (<span class="type">const</span> complex &amp; x ,<span class="type">const</span> complex &amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span>(x)+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x+<span class="built_in">imag</span>(y)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> + (<span class="type">const</span> complex &amp; x, <span class="type">double</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span>(x)+y,<span class="built_in">imag</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> + (<span class="type">double</span> x，<span class="type">const</span> complex &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span> (x+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供给外界使用的接口，放在类声明的最前面</p>
<ul>
<li>这是某次面试中，面试官大哥告诉我的。想想确实是有道理，类的用户用起来也舒服，一眼就能看见接口</li>
</ul>
</li>
</ul>
<h2 id="Class-with-pointer-member-s-记得写Big-Tree"><a href="#Class-with-pointer-member-s-记得写Big-Tree" class="headerlink" title="Class with pointer member(s): 记得写Big Tree"></a>Class with pointer member(s): 记得写Big Tree</h2><ul>
<li><p>C++的类可以分为带指针数据成员与不带指针数据成员两类,complex 就属于不带指针成员的。而这里要说的字符串类String，一般的实现会带有一个 char * 指针。带指针数据成员的类需要自己实现class三大件: 拷贝构造函数，拷贝赋值函数，析构函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">String</span> (<span class="type">const</span> <span class="type">char</span> * cstr = <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">String</span> (<span class="type">const</span> String &amp; str);</span><br><span class="line">        String &amp; <span class="keyword">operator</span> = (<span class="type">const</span> String &amp; str);</span><br><span class="line">        ~<span class="built_in">String</span>();</span><br><span class="line">        <span class="function"><span class="type">char</span> * <span class="title">get_c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_data&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span> * m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果没有写拷贝构造函数，赋值构造函数，析构函数，编译器默认会给我们写一套。然而带指针的类不能依赖编译器的默认实现–这涉及到资源的释放，深拷贝与浅拷贝的问题。在实现String类的过程中我们来阐述这些问题。</p>
</li>
<li><p>析构函数释放动态分配的内存资源</p>
</li>
<li><p>如果class里有指针，多半是需要进行内存动态分配(例如String)，析构函数必须负责在对象生命结束时释放掉动态申请来的内存，否则就造成了内存泄漏。</p>
</li>
<li><p>局部对象在离开函数作用域时，对象析构函数被自动调用，而使用new动态分配的对象，也需要显式的使用delete来删除对象。而delete实际上会调用对象的析构函数，我们必须在析构函数中完成释放指针m_data所申请的内存。下面是一个构造函数，体现了m_data的动态内存申请:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*String的构造函数*/</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String ::<span class="built_in">String</span> (<span class="type">const</span> <span class="type">char</span> *cstr = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cstr)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr)<span class="number">+1</span>];   <span class="comment">// 这里，m_data申请了内存</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_data,cstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_data= <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这个构造函数以C风格字符串为参数，当执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String *p = <span class="keyword">new</span> <span class="built_in">String</span> (<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>m_data 向系统申请了一块内存存放字符串hello</p>
</li>
<li><p>析构函数必须负责把这段动态申请来的内存释放掉:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line">String ::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[]m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>赋值构造函数与复制构造函数负责进行深拷贝</p>
</li>
<li><p>来看看如果使用编译器为String默认生成的拷贝构造函数与赋值操作符会发生什么事情。默认的复制构造函数或赋值操作符所做的事情是对类的内存进行按位的拷贝，也成为浅拷贝。他们只是把对象内存上的每一个bit复制到另一个对象上去，在String中就只是复制了指针，而不复制指针所指内容。</p>
</li>
<li><p>来看看我们自己实现的构造函数是如何解决这个问题的，它复制的是指针所指的内存内容，这称为深拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*拷贝赋值函数*/</span></span><br><span class="line"><span class="keyword">inline</span> String &amp;String ::<span class="keyword">operator</span>= (<span class="type">const</span> String &amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)           <span class="comment">//①</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;        <span class="comment">//②</span></span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_data)<span class="number">+1</span>];        <span class="comment">//③</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_data,str.m_data);            <span class="comment">//④</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这是拷贝赋值函数的经典实现，要点在于：</p>
<ul>
<li>处理自我赋值，如果不存在自我赋值问题，继续下列步骤</li>
<li>释放自身已经申请的内存</li>
<li>申请一块大小与目标字符串一样大的内存</li>
<li>进行字符串的拷贝</li>
</ul>
</li>
<li><p>同样的，复制构造函数也是一个深拷贝的过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> String ::<span class="built_in">String</span>(<span class="type">const</span> String &amp; str )</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span> (str) <span class="number">+1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data,str.m_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>另外，一定要在 operator&#x3D; 中检查是否 self assignment 。假设这时候确实执行了对象的自我赋值，左右pointers指向同一个内存块，前面的步骤2 delete 该内存块造成的结果是：当企图对内存进行访问时，结果是未定义的</p>
</li>
</ul>
<h2 id="static-与类"><a href="#static-与类" class="headerlink" title="static 与类"></a>static 与类</h2><ul>
<li><p>不和对象直接相关的数据，声明为 static </p>
<ul>
<li>想象有一个银行账户的类，每个人都可以开银行账户。存在银行利率这个成员变量，它不应该属于对象，而应该属于银行这个类，由所有的用户来共享。</li>
<li>static 修饰成员变量时，该成员变量放在程序的全局区中，整个程序运行过程中只有该成员变量的一个副本。而普通的成员变量存在每个对象的内存中，如果把银行利率放在每个对象中，是浪费了内存。</li>
</ul>
</li>
<li><p>static 成员函数没有this指针</p>
<ul>
<li>static 成员函数与普通函数一样，都是只有一份函数的副本，存储在进程的代码段上。不一样的是staic 成员函数没有this指针，所以它不能够调用普通的成员变量，只能调用static成员变量。普通成员函数的调用需要通过对象来调用，编译器会把对象取地址，作为this指针的实参传递给成员函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="built_in">func</span>() ---&gt; Class :: <span class="built_in">fun</span>(&amp;obj);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>而 static 成员函数即可以通过对象来调用，也可以通过类名称来调用。</p>
</li>
<li><p>在类的外部定义 static 成员变量</p>
<ul>
<li>另一个问题是 static 成员变量的定义。static 成员变量必须在类外部进行定义:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> a; <span class="comment">//①</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> A::a = <span class="number">10</span>;  <span class="comment">//②</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意①是声明，②才是定义，定义为变量分配了内存。</p>
</li>
<li><p>static 与类的一些小应用</p>
<ul>
<li>这些可以用来应付一下面试，在实现单例模式的时候，static 成员函数与 static 成员变量得到了使用，下面是一种称为 饿汉式 的单例模式的实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="built_in">setup</span>()&#123;...&#125;;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">A</span>();</span><br><span class="line">            <span class="built_in">A</span>(<span class="type">const</span> A &amp; rhs);</span><br><span class="line">            <span class="type">static</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这里把class A的构造函数都设置为私有，不允许用户代码创建对象。要获取对象实例需要通过接口getInstance。饿汉式 缺点在于无论有没有代码需要a，a都被创建出来。下面是改进的单例模式，称为懒汉式:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span>  A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="built_in">setup</span>()&#123;....&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">const</span> A&amp; rsh);</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">static</span> A a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>“懒汉式”只有在真正需要a时，调用getInstance才创建出唯一实例。这可以看成一个具有拖延症的单例模式，不到最后关头不干活。很多设计都体现了这种拖延的思想，比如string的写时复制，真正需要的时候才分配内存给string对象管理的字符串。</li>
</ul>
</li>
</ul>
<h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><ul>
<li><p>RAII可能是C++中最常用的编程技法.他的思想是把资源映射到对象,根据这些对象的作用域自动管理它们的生命周期</p>
</li>
<li><p>例如，如果在堆上打开一个文件句柄，那么一旦我们从函数返回（或循环，或任何它在内部声明的作用域）时，它都应该被隐式关闭。</p>
</li>
<li><p>如果类的成员中有动态内存分配，那么当该类实例被销毁时，相关内存应该被隐式释放。</p>
</li>
<li><p>每一种资源-内存分配,文件句柄,数据库连接,套接字和任何其他需要获取和释放的资源  都应该包装在这样一个RAII类中,其声明周期由它的对象所在的作用域决定,和RAII类对象绑定.</p>
</li>
<li><p>C++语言会保证,当对象超出作用域时,析构函数被调用,不管对象如何离开该作用域.即使抛出异常,所有相关对象也将超出作用域,所以他们的相关资源都会被释放.</p>
</li>
<li><p>C++很多地方都用到了RAII特性,例如lock_guard, 智能指针等.</p>
</li>
</ul>
<h2 id="使用enum-class-而非-enum"><a href="#使用enum-class-而非-enum" class="headerlink" title="使用enum class 而非 enum"></a>使用enum class 而非 enum</h2><ul>
<li>enum class 最重要的好处是: 防止隐式转换</li>
</ul>
<h2 id="Copy-and-swap"><a href="#Copy-and-swap" class="headerlink" title="Copy-and-swap"></a>Copy-and-swap</h2><ul>
<li><p>copy-and-swap 技法保证了强异常安全的保证,它可以非常方便的实现operator&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String &amp; <span class="keyword">operator</span> = (String s) <span class="comment">// the pass-by-value parameter serves as a temporary</span></span><br><span class="line">    &#123;</span><br><span class="line">       s.<span class="built_in">swap</span> (*<span class="keyword">this</span>); <span class="comment">// Non-throwing swap</span></span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;<span class="comment">// Old resources released when destructor of s is called.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(String &amp; s)</span> <span class="keyword">noexcept</span> <span class="comment">// Also see non-throwing swap idiom</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;str, s.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>补充知识点,异常安全的四种保证</p>
<ul>
<li>Nothrow(或者nofail)异常保证: 该函数永远不会抛出异常.对于可能在堆栈展开期间被调用的析构函数和其他函数,期望它们不会抛出异常(错误通过其他方式报告或隐藏).析构函数默认情况下是noexcept的(自C++11起).Nofail(函数总是成功执行)的要求适用于交换(swaps),移动构造函数和其他被那些提供强异常保证的函数所使用的函数.</li>
<li>强异常保证: 如果该函数抛出异常,程序的状态将回滚到函数调用之前的状态(例如 std::vector::push_back).即使抛出异常,程序仍然处于有效状态.</li>
<li>基本异常保证: 如果该函数抛出异常,程序仍然处于有效状态,没有资源泄漏,所有对象的不变性仍然保持完整.</li>
<li>无异常保证: 如果该函数抛出异常,程序可能处于无效状态,可能会发生资源泄漏,内存损坏或其他破坏不变性的错误.</li>
</ul>
</li>
</ul>
<h2 id="CRTP-Curiously-Recurring-Template-Pattern"><a href="#CRTP-Curiously-Recurring-Template-Pattern" class="headerlink" title="CRTP: Curiously Recurring Template Pattern"></a>CRTP: Curiously Recurring Template Pattern</h2><ul>
<li><p>CRTP 是指将一个类作为模板参数传递给其基类的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Derived</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BaseCRTP</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Example</span> : BaseCRTP&lt;Example&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在基类中,通过进行类型转换(可以使用static_cast或dynamic_cast)可以获取派生类实例,包括派生类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Derived</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BaseCRTP</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">call_foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived&amp; self = *<span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    self.<span class="built_in">foo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Example</span> : BaseCRTP&lt;Example&gt; &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;foo()\\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="PIMPL-模式"><a href="#PIMPL-模式" class="headerlink" title="PIMPL 模式"></a>PIMPL 模式</h2><ul>
<li><p>简介</p>
<ul>
<li>很实用的一种基础模式</li>
</ul>
</li>
<li><p>PIMPL 解释：</p>
<ul>
<li>PIMPL（Private Implementation 或 Pointer to Implementation）是通过一个私有的成员指针，将指针所指向的类的内部实现数据进行隐藏。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i; <span class="comment">//add int i;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    X x; <span class="comment">//与X的强耦合</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PIMPL做法：</span><br><span class="line"><span class="comment">//c.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>; <span class="comment">//代替#include &lt;x.h&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    X *pImpl; <span class="comment">//pimpl</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>降低模块的耦合。因为隐藏了类的实现，被隐藏的类相当于原类不可见，对隐藏的类进行修改，不需要重新编译原类。</p>
</li>
<li><p>降低编译依赖，提高编译速度。指针的大小为（32位）或8（64位），X发生变化，指针大小却不会改变，文件c.h也不需要重编+ </p>
</li>
<li><p>接口与实现分离，提高接口的稳定性。</p>
<ul>
<li>通过指针封装，当定义“new C”或”C c1”时 ,编译器生成的代码中不会掺杂X的任何信息。</li>
<li>当使用C时，使用的是C的接口（C接口里面操作的类其实是pImpl成员指向的X对象），与X无关，X被通过指针封装彻底的与实现分离。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c.cpp</span></span><br><span class="line">C::<span class="built_in">C</span>()<span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">X</span>())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C::~<span class="built_in">C</span>()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">delete</span> pImpl;</span><br><span class="line">     pImpl = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C::Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pImpl-&gt;<span class="built_in">Fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;c.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c1;</span><br><span class="line">    c<span class="number">1.F</span>un();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">C++_服务器开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++服务器开发相关笔记</li>
</ul>
<h2 id="C-服务器开发-github推荐开源项目"><a href="#C-服务器开发-github推荐开源项目" class="headerlink" title="C++ 服务器开发 github推荐开源项目"></a>C++ 服务器开发 github推荐开源项目</h2><p>以下是一些在 GitHub 上受欢迎且有用的 C++ 服务器开发的开源项目，它们可用于构建各种类型的服务器应用程序。请注意，GitHub 上的项目可能会不断更新，因此建议查看其最新状态和文档：</p>
<ol>
<li><p><strong>Boost.Asio</strong>：<br>Boost.Asio 是一个 C++ 网络库，提供异步事件处理和网络通信的功能。它可以用于构建高性能的网络服务器和客户端应用程序。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/boostorg/asio">https://github.com/boostorg/asio</a></p>
</li>
<li><p><strong>cpp-netlib</strong>：<br>cpp-netlib 是一个现代的 C++ 网络库，提供 HTTP、HTTPS、HTTP client 等功能。它提供了易于使用的 API 来处理网络通信。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/cpp-netlib/cpp-netlib">https://github.com/cpp-netlib/cpp-netlib</a></p>
</li>
<li><p><strong>Crow</strong>：<br>Crow 是一个 C++ 微型 Web 框架，可用于构建高性能的 Web 服务器。它具有简单的 API 和支持 WebSocket 等功能。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/ipkn/crow">https://github.com/ipkn/crow</a></p>
</li>
<li><p><strong>Pistache</strong>：<br>Pistache 是一个 C++ RESTful Web 服务器框架，它具有异步处理和路由功能。它适用于构建 REST API 服务器。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/oktal/pistache">https://github.com/oktal/pistache</a></p>
</li>
<li><p><strong>Civetweb</strong>：<br>Civetweb 是一个轻量级的嵌入式 HTTP&#x2F;WebSocket 服务器，适用于嵌入式系统和小型应用程序。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/civetweb/civetweb">https://github.com/civetweb/civetweb</a></p>
</li>
<li><p><strong>uWebSockets</strong>：<br>uWebSockets 是一个高性能的 WebSocket 库，用于构建 WebSocket 服务器和客户端。它具有低延迟和高吞吐量的特性。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/uNetworking/uWebSockets">https://github.com/uNetworking/uWebSockets</a></p>
</li>
<li><p><strong>Restbed</strong>：<br>Restbed 是一个 C++11 Web 服务框架，支持 HTTP 和 HTTPS，并提供异步事件处理和路由功能。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/corvusoft/restbed">https://github.com/corvusoft/restbed</a></p>
</li>
<li><p><strong>Drogon</strong>：<br>Drogon 是一个高性能的 C++ Web 服务器框架，支持 HTTP&#x2F;1.1 和 HTTP&#x2F;2，提供异步和多线程支持。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/an-tao/drogon">https://github.com/an-tao/drogon</a></p>
</li>
<li><p><strong>Seastar</strong>：<br>Seastar 是一个高性能的 C++ 框架，用于构建分布式系统和高性能的服务器应用程序。它采用异步编程模型。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/scylladb/seastar">https://github.com/scylladb/seastar</a></p>
</li>
</ol>
<p>请注意，选择适合你的项目需求和技术栈的开源项目非常重要。这些项目在不同的场景和用例中具有不同的优势，因此建议根据你的具体需求来评估这些项目。同时，查看每个项目的文档和社区支持，以确保你能够成功地使用它们。</p>
<h2 id="从零设计跨平台C-C-服务器框架"><a href="#从零设计跨平台C-C-服务器框架" class="headerlink" title="从零设计跨平台C&#x2F;C++服务器框架"></a>从零设计跨平台C&#x2F;C++服务器框架</h2><h3 id="1-1-基础"><a href="#1-1-基础" class="headerlink" title="1.1 基础"></a>1.1 基础</h3><ul>
<li><p>技术框架，其实质就是建立一种标准的工作流，让更多的人参与，更低成本地实现目标。</p>
</li>
<li><p>目前我们所规定的标准：</p>
<ul>
<li>使用CMake管理项目，以Linux开源系统为标准，如果在windows上缺少的库，就模仿Linux造一个，实现一份代码跑全部平台</li>
<li>采用utf8字符编码，调用win32接口，需要把unicode转utf8。</li>
<li>采用骆驼峰形式代码风格<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span> <span class="comment">//类名首字母大写，骆驼峰</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> parramArg_;           <span class="comment">// 变量名末尾有_，非静态变量首字母小写</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> ParramArg_;    <span class="comment">// 变量名末尾有_，静态变量首字母大写</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FuncA</span><span class="params">()</span></span>&#123;&#125;     <span class="comment">// 函数名末尾无有_，静态函数首字母大写</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123;&#125;            <span class="comment">// 函数名末尾无有_，非静态函数首字母小写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>设计模式众多，选择人脑比较容易接受的设计模式：面向对象、状态机和组件设计等。模块用组件实现，可达到组件通用化，避免重复造轮子</li>
</ul>
</li>
</ul>
<h4 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h4><ul>
<li>面向对象设计，把业务逻辑封装类似实物世界，以一种人脑熟悉的方式，让人脑更容易接受和使用。制作工具一定要符合用户习惯</li>
<li>我们设计的服务器框架，服务器主要功能是加工数据、提供数据和数据通讯，就像一座数据工厂，里面有各种各样的数据加工机器人。我们用变量记录和描述属性，用函数描述行为</li>
<li>面向对象只是一种逻辑，跟编程语言无关，我们可以用C语言和C++语言各自实现一个对象。但是C++编译器对面向对象提供了更好的语法便利，这就是C++语法的优点，代价就是损失一些性能，好处就是提高写代码效率，代码更少，更容易维护</li>
</ul>
<h4 id="状态机设计"><a href="#状态机设计" class="headerlink" title="状态机设计"></a>状态机设计</h4><ul>
<li>计算机可以算是一种状态机：通过输入设备输入操作，就会改变状态</li>
<li>例如HTTP服务器的状态：<ul>
<li>监听到客户端连接，执行accept，建立链接状态；</li>
<li>解析HTTP头状态；</li>
<li>解析Cookie，处理session状态</li>
<li>验证modify和etag缓存状态</li>
<li>路由到具体url业务状态</li>
<li>获取到数据进行文件渲染状态</li>
<li>向客户端发送数据状态</li>
<li>最后关闭连接状态</li>
</ul>
</li>
<li>上述把HTTP服务器复杂的请求过程，细分成各种具体的状态，大幅降低了问题的复杂度，转换人脑更加容易熟悉的状态。</li>
<li>程序发生bug，可以快速定位；对性能调优，监测每个状态的消耗时间，带来极大便利性</li>
</ul>
<h4 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h4><ul>
<li><p>我们的机器人需要接收消息，接收到消息以后，需要进行加工，然后把加工的数据，通过消息发出去。我们有成千上万种数据加工业务，我们需要设计各种各样的机器人。</p>
</li>
<li><p>如果按照继承的方式，robot作为父类，需要实现各种各样的子类，这种方式虽然也可以做到业务分离，但是复用和共享很困难。</p>
</li>
<li><p>我们希望像汽车一样，标准化各种零部件，想要什么价位和性能的汽车，就选择组装什么样的零件。这个就是组件设计。</p>
</li>
<li><p>设计一个类Com，作为组件基类，把单一功能的逻辑，作为一个组件。Robot作为集合类，需要什么样的Robot，就组装什么样的组件。</p>
</li>
<li><p>我们通过CMake建立跨平台工程，以Linux做标准库，让我们的程序可以移植在任何操作系统上。</p>
</li>
<li><p>我们也希望写的代码可以轻松地移植在任意一个项目中，甚至发到网上，轻松导入即可使用。</p>
</li>
<li><p>我们也希望可视化操作，人脑更容易接受的方式去开发程序</p>
</li>
<li><p>这就是组件设计。我们设计组件的核心目标是可视化操作，通过可视化方式组装我们的业务。</p>
</li>
</ul>
<h2 id="C-高性能服务器网络框架设计细节"><a href="#C-高性能服务器网络框架设计细节" class="headerlink" title="C++ 高性能服务器网络框架设计细节"></a>C++ 高性能服务器网络框架设计细节</h2><h3 id="1-1-基础-1"><a href="#1-1-基础-1" class="headerlink" title="1.1 基础"></a>1.1 基础</h3><ul>
<li>这篇文章我们将介绍服务器的开发，并从多个方面探究如何开发一款高性能高并发的服务器程序。需要注意的是一般大型服务器，其复杂程度在于其业务，而不是在于其代码工程的基本框架。</li>
<li>大型服务器一般有多个服务组成，可能会支持CDN，或者支持所谓的“分布式”等，这篇文章不会介绍这些东西，因为不管结构多么复杂的服务器，都是由单个服务器组成的。所以这篇文章的侧重点是讨论单个服务程序的结构，而且这里的结构指的也是单个服务器的网络通信层结构，如果你能真正地理解了我所说的，那么在这个基础的结构上面开展任何业务都是可以的，也可以将这种结构扩展成复杂的多个服务器组，例如“分布式”服务。</li>
<li>文中的代码示例虽然是以C++为例，但同样适合Java（我本人也是Java开发者），原理都是一样的，只不过Java可能在基本的操作系统网络通信API的基础上用虚拟机包裹了一层接口而已（Java甚至可能基于一些常用的网络通信框架思想提供了一些现成的API，例如NIO）。有鉴于此，这篇文章不讨论那些大而空、泛泛而谈的技术术语，而是讲的是实实在在的能指导读者在实际工作中实践的编码方案或优化已有编码的方法。另外这里讨论的技术同时涉及windows和linux两个平台。</li>
</ul>
<hr>
<ul>
<li>所谓高性能就是服务器能流畅地处理各个客户端的连接并尽量低延迟地应答客户端的请求；</li>
<li>所谓高并发，不仅指的是服务器可以同时支持多的客户端连接，而且这些客户端在连接期间内会不断与服务器有数据来往。</li>
<li>网络上经常有各种网络库号称单个服务能同时支持百万甚至千万的并发，然后我实际去看了下，结果发现只是能同时支持很多的连接而已。如果一个服务器能单纯地接受ｎ个连接（ｎ可能很大），但是不能有条不紊地处理与这些连接之间的数据来往也没有任何意义，这种服务器框架只是“玩具型”的，对实际生产和应用没有任何意义。</li>
<li>这篇文章将从两个方面来介绍：<ul>
<li>一个是服务器中的基础的网络通信部件；</li>
<li>另外一个是，如何利用这些基础通信部件整合成一个完整的高效的服务器框架。</li>
</ul>
</li>
</ul>
<h3 id="1-2-网络通信部件"><a href="#1-2-网络通信部件" class="headerlink" title="1.2 网络通信部件"></a>1.2 网络通信部件</h3><h4 id="1-1-需要解决的问题："><a href="#1-1-需要解决的问题：" class="headerlink" title="1.1 需要解决的问题："></a>1.1 需要解决的问题：</h4><ul>
<li><p>既然是服务器程序肯定会涉及到网络通信部分，那么服务器程序的网络通信模块要解决哪些问题？</p>
</li>
<li><p>目前，网络上有很多网络通信框架，如libevent、boost asio、ACE，但都网络通信的常见的技术手段都大同小异，至少要解决以下问题：</p>
<ul>
<li>如何检测有新客户端连接？</li>
<li>如何接受客户端连接？</li>
<li>如何检测客户端是否有数据发来？</li>
<li>如何收取客户端发来的数据？</li>
<li>如何检测连接异常？发现连接异常之后，如何处理？</li>
<li>如何给客户端发送数据？</li>
<li>如何在给客户端发完数据后关闭连接？</li>
</ul>
</li>
<li><p>稍微有点网络基础的人，都能回答上面说的其中几个问题，比如接收客户端连接用socket API的accept函数，收取客户端数据用recv函数，给客户端发送数据用send函数，检测客户端是否有新连接和客户端是否有新数据可以用IO multiplexing技术（IO复用）的select、poll、epoll等socket API</p>
</li>
<li><p>确实是这样的，这些基础的socket API构成了服务器网络通信的地基，不管网络通信框架设计的如何巧妙，都是在这些基础的socket API的基础上构建的。但是如何巧妙地组织这些基础的socket API，才是问题的关键</p>
</li>
<li><p>我们说服务器很高效，支持高并发，实际上只是一个技术实现手段，不管怎样，从软件开发的角度来讲无非就是一个程序而已，所以，只要程序能最大可能地满足“尽量减少等待或者不等待”这一原则就是高效的，也就是说高效不是“忙的忙死，闲的闲死”，而是大家都可以闲着，但是如果有活要干，大家尽量一起干，而不是一部分忙着依次做事情，另外一部分闲在那里无所事事</p>
</li>
</ul>
<hr>
<ul>
<li>我们来举一些例子具体来说明一下。 例如：<ul>
<li>默认情况下，recv函数如果没有数据的时候，线程就会阻塞在那里；</li>
<li>默认情况下，send函数，如果tcp窗口不是足够大，数据发不出去也会阻塞在那里；</li>
<li>connect函数默认连接另外一端的时候，也会阻塞在那里；</li>
<li>又或者是给对端发送一份数据，需要等待对端回答，如果对方一直不应答，当前线程就阻塞在这里。</li>
</ul>
</li>
<li>以上都不是高效服务器的开发思维方式，因为上面的例子都不满足“尽量减少等待”的原则，为什么一定要等待呢？有没用一种方法，这些过程不需要等待，最好是不仅不需要等待，而且这些事情完成之后能通知我。这样在这些本来用于等待的cpu时间片内，我就可以做一些其他的事情。有，也就是我们下文要讨论的IO Multiplexing技术（IO复用技术）</li>
</ul>
<h4 id="1-2-几种IO服用机制的比较"><a href="#1-2-几种IO服用机制的比较" class="headerlink" title="1.2 几种IO服用机制的比较"></a>1.2 几种IO服用机制的比较</h4><ul>
<li><p>目前：</p>
<ul>
<li>windows系统支持select、WSAAsyncSelect、WSAEventSelect、完成端口（IOCP）</li>
<li>linux系统支持select、poll、epoll。</li>
</ul>
</li>
<li><p>以上列举的API函数可以分为两个层次：</p>
<ul>
<li>层次一 select和poll</li>
<li>层次二 WSAAsyncSelect、WSAEventSelect、完成端口（IOCP）、epoll</li>
</ul>
</li>
<li><p>为什么这么分呢？</p>
</li>
<li><p>先来介绍第一层次</p>
<ul>
<li>select和poll函数本质上还是在一定时间内主动去查询socket句柄（可能是一个也可能是多个）上是否有事件，比如可读事件，可写事件或者出错事件，也就是说我们还是需要每隔一段时间内去主动去做这些检测，如果在这段时间内检测出一些事件来，我们这段时间就算没白花，但是倘若这段时间内没有事件呢？我们只能是做无用功了，说白了，还是在浪费时间，因为假如一个服务器有多个连接，在cpu时间片有限的情况下，我们花费了一定的时间检测了一部分socket连接，却发现它们什么事件都没有，而在这段时间内我们却有一些事情需要处理，那我们为什么要花时间去做这个检测呢？把这个时间用在做我们需要做的事情不好吗？</li>
<li>所以对于服务器程序来说，要想高效，我们应该尽量避免花费时间主动去查询一些socket是否有事件，而是等这些socket有事件的时候告诉我们去处理。</li>
</ul>
</li>
<li><p>这也就是层次二的各个函数做的事情</p>
<ul>
<li>它们实际相当于变主动查询是否有事件为当有事件时，系统会告诉我们，此时我们再去处理，也就是“好钢用在刀刃”上了。只不过层次二的函数通知我们的方式是各不相同，</li>
<li>比如WSAAsyncSelect是利用windows窗口消息队列的事件机制来通知我们设定的窗口过程函数，IOCP是利用GetQueuedCompletionStatus返回正确的状态，epoll是epoll_wait函数返回而已</li>
</ul>
</li>
<li><p>例如，connect函数连接另外一端，如果用于连接socket是非阻塞的，那么connect虽然不能立刻连接完成，但是也是会立刻返回，无需等待，等连接完成之后，WSAAsyncSelect会返回FD_CONNECT事件告诉我们连接成功，epoll会产生EPOLLOUT事件，我们也能知道连接完成。甚至socket有数据可读时，WSAAsyncSelect产生FD_READ事件，epoll产生EPOLLIN事件，等等。所以有了上面的讨论，我们就可以得到网络通信检测可读可写或者出错事件的正确姿势。这是我这里提出的第二个原则：尽量减少做无用功的时间。这个在服务程序资源够用的情况下可能体现不出来什么优势，但是如果有大量的任务要处理，这里就成了性能的一个瓶颈。</p>
</li>
</ul>
<h4 id="1-3-检测网络时间的正确姿势"><a href="#1-3-检测网络时间的正确姿势" class="headerlink" title="1.3 检测网络时间的正确姿势"></a>1.3 检测网络时间的正确姿势</h4><ul>
<li><p>第一，为了避免无意义的等待时间</p>
</li>
<li><p>第二，不采用主动查询各个socket的事件，而是采用等待操作系统通知我们有事件的状态的策略。</p>
</li>
<li><p>我们的socket都要设置成非阻塞的。在此基础上我们回到栏目（一）中提到的七个问题：</p>
<ul>
<li>如何检测有新客户端连接？</li>
<li>如何接受客户端连接？ 默认accept函数会阻塞在那里，如果epoll检测到侦听socket上有EPOLLIN事件，或者WSAAsyncSelect检测到有FD_ACCEPT事件，那么就表明此时有新连接到来，这个时候调用accept函数，就不会阻塞了。当然产生的新socket你应该也设置成非阻塞的。这样我们就能在新socket上收发数据了。</li>
<li>如何检测客户端是否有数据发来？</li>
<li>如何收取客户端发来的数据？ 同理，我们也应该在socket上有可读事件的时候才去收取数据，这样我们调用recv或者read函数时不用等待，至于一次性收多少数据好呢？我们可以根据自己的需求来决定，甚至你可以在一个循环里面反复recv或者read，对于非阻塞模式的socket，如果没有数据了，recv或者read也会立刻返回，错误码EWOULDBLOCK会表明当前已经没有数据了</li>
<li>如何检测连接异常？发现连接异常之后，如何处理？ 同样当我们收到异常事件后例如EPOLLERR或关闭事件FD_CLOSE，我们就知道了有异常产生，我们对异常的处理一般就是关闭对应的socket。另外，如果send&#x2F;recv或者read&#x2F;write函数对一个socket进行操作时，如果返回0，那说明对端已经关闭了socket，此时这路连接也没必要存在了，我们也可以关闭对应的socket。</li>
<li>如何给客户端发送数据？ 这也是一道常见的网络通信面试题，某一年的腾讯后台开发职位就问到过这样的问题。给客户端发送数据，比收数据要稍微麻烦一点，也是需要讲点技巧的。<ul>
<li>首先我们不能像注册检测数据可读事件一样一开始就注册检测数据可写事件，因为如果检测可写的话，一般情况下只要对端正常收取数据，我们的socket就都是可写的，如果我们设置监听可写事件，会导致频繁地触发可写事件，但是我们此时并不一定有数据需要发送。</li>
<li>所以正确的做法是：<ul>
<li>如果有数据要发送，则先尝试着去发送，如果发送不了或者只发送出去部分，剩下的我们需要将其缓存起来，然后再设置检测该socket上可写事件，下次可写事件产生时，再继续发送，如果还是不能完全发出去，则继续设置侦听可写事件，如此往复，一直到所有数据都发出去为止。</li>
<li>一旦所有数据都发出去以后，我们要移除侦听可写事件，避免无用的可写事件通知。</li>
</ul>
</li>
<li>不知道你注意到没有，如果某次只发出去部分数据，剩下的数据应该暂且存起来，这个时候我们就需要一个缓冲区来存放这部分数据，这个缓冲区我们称为“发送缓冲区”。</li>
<li>发送缓冲区不仅存放本次没有发完的数据，还用来存放在发送过程中，上层又传来的新的需要发送的数据。</li>
<li>为了保证顺序，新的数据应该追加在当前剩下的数据的后面，发送的时候从发送缓冲区的头部开始发送。也就是说先来的先发送，后来的后发送。</li>
</ul>
<p> 　　</p>
</li>
<li>如何在给客户端发完数据后关闭连接？ 这个问题比较难处理，因为这里的“发送完”不一定是真正的发送完，我们调用send或者write函数即使成功，也只是向操作系统的协议栈里面成功写入数据，至于能否被发出去、何时被发出去很难判断，发出去对方是否收到就更难判断了。所以，我们目前只能简单地认为send或者write返回我们发出数据的字节数大小，我们就认为“发完数据”了。然后调用close等socket API关闭连接。当然，你也可以调用shutdown函数来实现所谓的“半关闭”。</li>
</ul>
</li>
</ul>
<h4 id="1-4-被动关闭连接和主动关闭连接"><a href="#1-4-被动关闭连接和主动关闭连接" class="headerlink" title="1.4 被动关闭连接和主动关闭连接"></a>1.4 被动关闭连接和主动关闭连接</h4><ul>
<li>在实际的应用中，被动关闭连接是由于我们检测到了连接的异常事件，比如EPOLLERR，或者对端关闭连接，send或recv返回0，这个时候这路连接已经没有存在必要的意义了，我们被迫关闭连接</li>
<li>而主动关闭连接，是我们主动调用close&#x2F;closesocket来关闭连接。比如客户端给我们发送非法的数据，比如一些网络攻击的尝试性数据包。这个时候出于安全考虑，我们关闭socket连接。</li>
</ul>
<h4 id="1-5-发送缓冲区和接收缓冲区"><a href="#1-5-发送缓冲区和接收缓冲区" class="headerlink" title="1.5 发送缓冲区和接收缓冲区"></a>1.5 发送缓冲区和接收缓冲区</h4><ul>
<li><p>接收缓冲区也是一样的道理，当收到数据以后，我们可以直接进行解包，但是这样并不好，</p>
<ul>
<li>理由一：除非一些约定俗称的协议格式，比如http协议，大多数服务器的业务的协议都是不同的，也就是说一个数据包里面的数据格式的解读应该是业务层的事情，和网络通信层应该解耦，为了网络层更加通用，我们无法知道上层协议长成什么样子，因为不同的协议格式是不一样的，它们与具体的业务有关。</li>
<li>理由二：即使知道协议格式，我们在网络层进行解包处理对应的业务，如果这个业务处理比较耗时，比如需要进行复杂的运算，或者连接数据库进行账号密码验证，那么我们的网络线程会需要大量时间来处理这些任务，这样其它网络事件可能没法及时处理。</li>
</ul>
</li>
<li><p>鉴于以上二点，我们确实需要一个接收缓冲区，将收取到的数据放到该缓冲区里面去，并由专门的业务线程或者业务逻辑去从接收缓冲区中取出数据，并解包处理业务。</p>
</li>
<li><p>说了这么多，那发送缓冲区和接收缓冲区该设计成多大的容量？这是一个老生常谈的问题了，因为我们经常遇到这样的问题：预分配的内存太小不够用，太大的话可能会造成浪费。怎么办呢？答案就是像string、vector一样，设计出一个可以动态增长的缓冲区，按需分配，不够还可以扩展。</p>
</li>
<li><p>需要特别注意的是，这里说的发送缓冲区和接收缓冲区是每一个socket连接都存在一个。这是我们最常见的设计方案。</p>
</li>
</ul>
<h4 id="1-6-协议的设计"><a href="#1-6-协议的设计" class="headerlink" title="1.6 协议的设计"></a>1.6 协议的设计</h4><ul>
<li><p>除了一些通用的协议，如http、ftp协议以外，大多数服务器协议都是根据业务制定的。协议设计好了，数据包的格式就根据协议来设置。</p>
</li>
<li><p>我们知道tcp&#x2F;ip协议是流式数据，所以流式数据就是像流水一样，数据包与数据包之间没有明显的界限</p>
</li>
<li><p>比如A端给B端连续发了三个数据包，每个数据包都是50个字节，</p>
<ul>
<li>B端可能先收到10个字节，再收到140个字节；</li>
<li>或者先收到20个字节，再收到20个字节，再收到110个字节；</li>
<li>也可能一次性收到150个字节。</li>
<li>这150个字节可以以任何字节数目组合和次数被B收到。</li>
</ul>
</li>
<li><p>所以我们讨论协议的设计第一个问题就是如何界定包的界限，也就是接收端如何知道每个包数据的大小</p>
</li>
<li><p>目前常用有如下三种方法</p>
<ul>
<li>固定大小，这种方法就是假定每一个包的大小都是固定字节数目，例如上文中讨论的每个包大小都是50个字节，接收端每收气50个字节就当成一个包</li>
<li>指定包结束符，例如以一个\r\n(换行符和回车符)结束，这样对端只要收到这样的结束符，就可以认为收到了一个包，接下来的数据是下一个包的内容。</li>
<li>指定包的大小，这种方法结合了上述两种方法，一般包头是固定大小，包头中有一个字段指定包体或者整个大的大小，对端收到数据以后先解析包头中的字段得到包体或者整个包的大小，然后根据这个大小去界定数据的界线。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>协议要讨论的第二个问题是，设计协议的时候要尽量方便解包，也就是说协议的格式字段应该尽量清晰明了。</li>
<li>协议要讨论的第三个问题是，根据协议组装的单个数据包应该尽量小，注意这里指的是单个数据包，这样有如下好处<ul>
<li>第一、对于一些移动端设备来说，其数据处理能力和带宽能力有限，小的数据不仅能加快处理速度，同时节省大量流量费用；</li>
<li>第二、如果单个数据包足够小的话，对频繁进行网络通信的服务器端来说，可以大大减小其带宽压力，其所在的系统也能使用更少的内存。</li>
</ul>
</li>
<li>协议要讨论的第四个问题是，对于数值类型，我们应该显式地指定数值的长度<ul>
<li>比如long型，在32位机器上是32位4个字节，但是如果在64位机器上，就变成了64位8个字节了。</li>
<li>这样同样是一个long型，发送方和接收方可能因为机器位数的不同会用不同的长度去解码。所以建议最好，在涉及到跨平台使用的协议最好显式地指定协议中整型字段的长度，比如int32、int64等等。</li>
</ul>
</li>
</ul>
<h3 id="1-3-服务器程序结构的组织"><a href="#1-3-服务器程序结构的组织" class="headerlink" title="1.3 服务器程序结构的组织"></a>1.3 服务器程序结构的组织</h3><ul>
<li>上面的六个标题，我们讨论了很多具体的细节问题，现在是时候讨论将这些细节组织起来了。</li>
<li>根据我的个人经验，目前主流的思想是<code>one thread one loop+reactor</code>模式（也有proactor模式）的策略。通俗点说就是一个线程一个循环，即在一个线程的函数里面不断地循环依次做一些事情，这些事情包括检测网络事件、解包数据产生业务逻辑</li>
<li>我们先从最简单地来说，设定一些线程在一个循环里面做网络通信相关的事情。另外设定一些线程去处理接收到的数据，并解包处理业务逻辑，这些线程可以认为是业务线程了，</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E6%9C%AA%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E6%9C%AA%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C++未整理笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>记录一些C++零乱的知识点</li>
</ul>
<h2 id="微信文章-–"><a href="#微信文章-–" class="headerlink" title="微信文章 –"></a>微信文章 –</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><ul>
<li>与进程相关的两个指标：VIRT Virtual Memory, 虚拟内存 和 RES Resident Memory，常驻内存，通常称为物理内存<ul>
<li>虚拟内存，是指整个进程申请的内存，包括程序本身占用的内存，new或者malloc分配的内存等</li>
<li>物理内存，就是这个进程在主板上内存条中占用的内存</li>
</ul>
</li>
<li>所以，通过top查看进程内存时，如果发现VIRT占用很大，说明这个程序用new或者malloc等分配了很多内存，但如果RES不是很大，那就不要慌，可能这只是程序的一个缓存优化，实际程序占用的物理内存并不大，但如果RES也很高，那可能就有点慌了</li>
</ul>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul>
<li><p>内存泄漏是导致进程内存持续上涨最常见的原因，而这是C++中常见但不好处理的问题。</p>
</li>
<li><p>解决这个问题没有什么通用的快捷的办法，只能根据实际业务处理</p>
</li>
<li><p>第一，从业务上，能不能重现内存泄漏。</p>
<ul>
<li>例如，做游戏，加入玩家不停地登录，就会导致内存不断上涨，那就说明问题就在登录游戏，把整个流程拆分，一个个屏蔽测试，最终找出问题</li>
</ul>
</li>
<li><p>第二，从部署上，能不能定位内存泄漏。</p>
<ul>
<li>例如，最近更新了一个版本，发现内存占用变得很高，那就可以确定，是这个版本的修改出现了问题，一个版本的代码量终究是有限的，查找起来也比较容易</li>
</ul>
</li>
<li><p>第三，使用valgrind memcheck。如果能够复现内存泄漏，但无法定位是哪个逻辑，那就可以用valgrind memcheck。复现内存泄漏，这个通常比较难实现，一般是线下测试无法复现，线上用户量大，运行久了才会复现，而valgrind会导致程序运行很慢，无法支撑线上测试，因此这个选项不太适用于线上</p>
</li>
<li><p>第四，使用Visual Leak Detector.valgrind使linux下的，如果程序可以跨平台，或者只在windows下，可以试试这个</p>
</li>
<li><p>第五，重载new,delete。</p>
<ul>
<li>可以简单加个计数，用于平时预防泄漏，也可更深入一些，记录内存的分配，得到内存泄漏的堆栈，但是这个是否能够支撑线上debug，不一定</li>
</ul>
</li>
<li><p>第六，使用自己的内存分配函数，每一个内存分配，都是用自己的函数，每一个STL的容器，都传入自己的分配器，然后分别记录这些内存分配的大小。</p>
<ul>
<li>这个方法看起来很不现实，但如果能够使用并实现，对内存统计，查找有很大的帮助，而且支持线上debug。</li>
<li>查找内存，只需要打印每个分配器分配的内存大小基本上可以得到结论是哪个分配器除了问题。</li>
<li>唯一的问题是它增加了开发难度，而且不能像valgrind那样不需要修改程序即可使用</li>
</ul>
</li>
<li><p>第七，使用valgrind massif。valgrind memcheck需要复现内存泄漏，所以不容易找出问题。它会定时记录分配内存的各个堆栈以及分配内存的量，当出现内存泄漏时，根据分配内存的量检查各个堆栈，应该可以找到问题的。</p>
<ul>
<li>massif也会导致程序运行满，但比memcheck要快，能不能线上debug，这个依然需要看具体情况</li>
</ul>
</li>
<li><p>第八，使用第三方内存分配器，例如jemalloc。并不是说使用第三方内存分配器就解决问题了，而是jemalloc自带了一大堆工具，其中jeprof可以得到内存的大小以及堆栈等信息，对查找内存泄漏有很大帮助</p>
<ul>
<li>不过开启prof后，效率如何，能不能在线上使用，不一定</li>
</ul>
</li>
</ul>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><ul>
<li>加入找不到内存泄漏，也许本来就没有内存泄漏，这时不妨考虑内存碎片的问题</li>
<li>以linux下的ptmalloc为例</li>
</ul>
<h3 id="内存利用率"><a href="#内存利用率" class="headerlink" title="内存利用率"></a>内存利用率</h3><ul>
<li>如果一个进程占用的内存远高于预期，但没有持续上涨，还需要考虑下是不是内存使用率的问题。</li>
<li>当使用new分配一块内存时，系统需要为这次分配记录大小，地址，分配的内存也需要对其。</li>
<li>加入分配的内存很小，例如1b，那系统最终需要消耗的内存是远大于1b的</li>
</ul>
<h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++编译器</li>
</ul>
<h2 id="g-Werror-type-limits是什么"><a href="#g-Werror-type-limits是什么" class="headerlink" title="g++ -Werror&#x3D;type-limits是什么"></a>g++ -Werror&#x3D;type-limits是什么</h2><p><code>g++ -Werror=type-limits</code> 是 GCC 编译器的一个编译选项，用于将与类型限制相关的警告转换为错误。这个选项告诉编译器将类型限制的警告视为编译错误，即在出现此类警告时，编译过程将中断，并生成一个错误，而不是继续生成可执行文件。</p>
<p>具体而言，<code>-Werror=type-limits</code> 用于处理与类型限制（type limits）相关的警告。例如，在比较有符号和无符号整数时，或者在进行其他可能导致溢出或意外行为的操作时，编译器可能会发出此类警告。通过将这些警告视为错误，开发者可以更加强制执行对于类型安全性的规则，从而避免一些潜在的运行时错误。</p>
<p>在实际的编译过程中，使用 <code>-Werror=type-limits</code> 可能会使得编译时更加严格，但也需要确保代码中不存在不希望的类型限制问题，否则编译将失败。</p>
<p>以下是使用这个编译选项的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -Werror=type-limits -o my_program my_program.cpp</span><br></pre></td></tr></table></figure>

<p>这将编译名为 <code>my_program.cpp</code> 的源文件，并在编译时将类型限制的警告转换为错误。</p>
<h2 id="为什么要用内存池？"><a href="#为什么要用内存池？" class="headerlink" title="为什么要用内存池？"></a>为什么要用内存池？</h2><ul>
<li>首先,在7 * 24h的服务器中如果不使用内存池,而使用malloc和free,那么就非常容易产生内存碎片,早晚都会申请内存失败,并且在比较复杂的代码中,非常容易出现内存泄漏</li>
<li>为了解决这两个问题,内存池就应运而生了.内存池预先分配一大块内存用来做一个内存池,业务中的内存分配和释放都由这个内存池来管理,内存池内的内存不足时其内部会自己申请.所以,内存碎片的问题就交由内存池的算法来优化,而内存泄漏的问题只需要遵守内存池提供的api,就非常容易避免内存泄漏了.</li>
<li>而且即使出现了内存泄漏,排查的思路也很清晰:<ul>
<li>检查是不是内存池的问题</li>
<li>如果不是内存池的问题,就检查是不是第三方库的内存泄漏</li>
</ul>
</li>
</ul>
<h2 id="内存池的使用场景"><a href="#内存池的使用场景" class="headerlink" title="内存池的使用场景:"></a>内存池的使用场景:</h2><ul>
<li>全局内存池,</li>
<li>一个连接一个内存池</li>
</ul>
<h2 id="设计一个内存池"><a href="#设计一个内存池" class="headerlink" title="设计一个内存池"></a>设计一个内存池</h2><ul>
<li>以4k为分界线,大于4k的认为是大块内存;小于4k的认为是小块内存;并且这里的4k,并不是严格遵照4096,而是在描述上,用4k比较好描述</li>
<li>在真正使用内存之前,内存池提前分配一定数量且大小相等的内存块以作备用,当真正被用户调用api分配内存的时候,直接从内存块中获取内存(指小块内存),当内存块不够用了,再由内存池去申请新的内存块;而如果是需要大块内存,则内存池直接申请大块内存再返回给用户.</li>
<li><strong>内存池</strong>:就是将这些提前申请的内存块组织管理起来的数据结构. 内存池实现原理主要分为:分配,回收,扩容三个部分.</li>
<li>内存池原理之小块内存:<ul>
<li>分配:<ul>
<li>内存池预申请一块4k的内存块,这里称为<strong>block</strong>,即block&#x3D;4k内存块.当用户向内存池申请内存的size小于4k时,内存池从block的空间中划分出去size空间,当再有新的申请时,再划分出去</li>
</ul>
</li>
<li>扩容:<ul>
<li>直到block中的剩余空间不足以分配size大小,那么此时内存池会再次申请一块block,再从新的block中划分size空间给用户</li>
</ul>
</li>
<li>回收:<ul>
<li>每一次申请小块内存,都会在对应的block中引用计数加1,每一次释放小块内存时,都会在block中引用计数减1,只有当引用计数为0的时候,才会回收block使他重新成为空闲空间,以便重复利用空间资源.</li>
</ul>
</li>
<li>这样,内存池避免频繁向内核申请&#x2F;释放内存,从而提高系统性能</li>
</ul>
</li>
<li>内存池原理之大块内存:<ul>
<li>分配:<ul>
<li>因为大块内存是大于4k的,所以内存池不预先申请内存,也就是用户申请的时候,内存池再申请内存,然后响应用户申请的时候,将申请的内存资源返回给用户</li>
</ul>
</li>
<li>扩容:<ul>
<li>大块内存不存在扩容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++适用的应用领域</li>
</ul>
<h2 id="实时数据处理"><a href="#实时数据处理" class="headerlink" title="实时数据处理"></a>实时数据处理</h2><ul>
<li>实时数据处理是指在数据流入时对其进行处理的数据处理方法。实时数据处理通常用于处理高速、大量数据，例如实时监控、社交媒体分析等。实时数据处理的主要优点是低延迟、高吞吐量，但缺点是系统复杂度较高。</li>
</ul>
<h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><ul>
<li>整理自己的技术栈</li>
<li>C++是一门讲究深度的语言，其深度不是体现在会多少C++语法，而是能够洞察所写的C++代码背后的系统原理，这是需要长期不断的积累的，没有</li>
</ul>
<h2 id="常见知识点"><a href="#常见知识点" class="headerlink" title="常见知识点"></a>常见知识点</h2><ul>
<li>auto 关键字</li>
<li>for-each 循环</li>
<li>右值及移动构造函数，std::forward,std::move,stl容器</li>
<li>std::thread库</li>
<li>std::chrono库</li>
<li>智能指针系列(std::shared_ptr&#x2F;std::unique_ptr&#x2F;std::weak_ptr)，智能指针的实现原理</li>
<li>线程库std::thread + 线程同步技术库std::mutex&#x2F;std::condition_variable&#x2F;std::lock_guard等</li>
<li>Lambda表达式</li>
<li>std::bind&#x2F;std::function库</li>
<li>关键字的用法(override, final, delete)</li>
</ul>
<h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ 机器人控制系统相关笔记</li>
</ul>
<h2 id="C-机器人控制系统相关的C-库和框架"><a href="#C-机器人控制系统相关的C-库和框架" class="headerlink" title="C++ 机器人控制系统相关的C++库和框架"></a>C++ 机器人控制系统相关的C++库和框架</h2><p>C++ 是一种通用编程语言，可以用于编写各种类型的应用程序，包括机器人控制系统。</p>
<p>机器人控制系统通常涉及硬件控制和数据处理两个方面。在 C++ 中，您可以使用特定的库和框架来实现这些功能。</p>
<p>以下是一些与机器人控制相关的 C++ 库和框架：</p>
<p>Robot Operating System (ROS)：ROS 是一个用于构建机器人软件的开源框架。它提供了用于硬件抽象、设备驱动程序、库、可视化工具、消息传递和软件包管理的工具。</p>
<p>Robotics Library (RL)：RL 是一个用于机器人控制和仿真的 C++ 库。它提供了用于运动规划、动力学仿真、机器人建模和感知的工具。</p>
<p>OpenCV：OpenCV 是一个开源的计算机视觉库，可用于机器人的视觉感知和图像处理。</p>
<p>Boost C++ 库：Boost 是一个 C++ 库集合，其中包括许多常用的数据结构、算法和工具，可用于机器人控制系统中的各种任务。</p>
<p>如果您想开始使用 C++ 开发机器人控制系统，建议您首先了解 C++ 的基础知识，然后学习上述库和框架的用法。这些库和框架都有详细的文档和示例代码可供参考。通过练习和实践，您可以逐步提高您的技能，并开发出更高级的机器人控制系统。</p>
<h2 id="C-机器人控制系统相关的C-库和框架-详解"><a href="#C-机器人控制系统相关的C-库和框架-详解" class="headerlink" title="C++ 机器人控制系统相关的C++库和框架 详解"></a>C++ 机器人控制系统相关的C++库和框架 详解</h2><p>在机器人控制系统中，有许多C++库和框架可用于不同的任务，包括运动规划、传感器融合、模拟和仿真等。以下是一些常见的C++库和框架，它们在机器人控制领域具有广泛的应用：</p>
<ol>
<li><p><strong>ROS (Robot Operating System)</strong>:</p>
<ul>
<li><strong>简介</strong>: ROS是一个用于构建机器人软件的开源框架。它提供了一系列工具和库，用于传感器数据的处理、运动规划、通信和控制等方面。</li>
<li><strong>特点</strong>: 灵活、模块化，支持多语言（包括C++）。</li>
</ul>
</li>
<li><p><strong>Robotics Library (RL) - formerly known as SL</strong>:</p>
<ul>
<li><strong>简介</strong>: Robotics Library是一个用于机器人控制和仿真的C++库。它包括运动学、动力学、传感器处理和运动规划等功能。</li>
<li><strong>特点</strong>: 面向多关节机器人，提供强大的建模和仿真工具。</li>
</ul>
</li>
<li><p><strong>Orocos (Open Robot Control Software)</strong>:</p>
<ul>
<li><strong>简介</strong>: Orocos是一个用于实时控制系统的框架，支持多种硬件平台。它包括组件化的体系结构，适用于工业和研究用途。</li>
<li><strong>特点</strong>: 实时性能好，支持硬实时和软实时操作系统。</li>
</ul>
</li>
<li><p><strong>MoveIt!</strong>:</p>
<ul>
<li><strong>简介</strong>: MoveIt!是一个用于运动规划的库，特别适用于机器人操作系统（ROS）环境。它支持各种运动规划算法和机器人硬件。</li>
<li><strong>特点</strong>: 高度集成于ROS，易于使用，支持运动学和动力学规划。</li>
</ul>
</li>
<li><p><strong>Eigen</strong>:</p>
<ul>
<li><strong>简介</strong>: Eigen是一个C++模板库，用于线性代数运算。在机器人控制中，它经常用于进行矩阵和向量运算，例如在运动学和动力学计算中。</li>
<li><strong>特点</strong>: 高性能，使用模板元编程提高运行时性能。</li>
</ul>
</li>
<li><p><strong>Gazebo</strong>:</p>
<ul>
<li><strong>简介</strong>: Gazebo是一个开源的机器人仿真器，用于模拟机器人在不同环境中的行为。它可以与ROS集成，提供真实感的物理仿真。</li>
<li><strong>特点</strong>: 适用于仿真和测试，支持多种机器人模型。</li>
</ul>
</li>
</ol>
<p>这些库和框架在不同的方面提供了丰富的功能，选择取决于你的具体需求和项目要求。在使用这些工具时，请务必查看它们的文档以获取详细的信息和使用说明。</p>
<h2 id="C-机器人仿真"><a href="#C-机器人仿真" class="headerlink" title="C++ 机器人仿真"></a>C++ 机器人仿真</h2><p>在C++中进行机器人仿真涉及到使用适当的库和工具，以模拟机器人在虚拟环境中的行为。以下是一些用于C++机器人仿真的常见库和框架：</p>
<ol>
<li><p><strong>Gazebo</strong>:</p>
<ul>
<li><strong>简介</strong>: Gazebo是一个功能强大的开源机器人仿真器，它可以用于模拟机器人的行为、传感器和环境。它提供了高度可定制的物理引擎，支持ROS集成。</li>
<li><strong>特点</strong>: 物理精确度高，支持多机器人模型，提供多种传感器模拟。</li>
</ul>
</li>
<li><p><strong>Webots</strong>:</p>
<ul>
<li><strong>简介</strong>: Webots是一个通用的机器人仿真平台，支持C++编程语言。它可以用于模拟各种机器人，包括地面和飞行器。</li>
<li><strong>特点</strong>: 提供易于使用的用户界面，支持多种编程语言，有广泛的机器人模型和环境。</li>
</ul>
</li>
<li><p><strong>V-REP (CoppeliaSim)</strong>:</p>
<ul>
<li><strong>简介</strong>: V-REP（现在称为CoppeliaSim）是一个跨平台的仿真工具，支持C++编程。它提供了丰富的机器人模型、物理引擎和传感器模拟。</li>
<li><strong>特点</strong>: 易于集成到自动化系统中，支持远程API调用，适用于各种机器人应用。</li>
</ul>
</li>
<li><p><strong>Stage</strong>:</p>
<ul>
<li><strong>简介</strong>: Stage是ROS的一部分，是一个轻量级的2D机器人仿真器。它使用C++进行开发，适用于模拟地面机器人。</li>
<li><strong>特点</strong>: 简单易用，适用于快速原型设计，支持多机器人仿真。</li>
</ul>
</li>
<li><p><strong>Microsoft AirSim</strong>:</p>
<ul>
<li><strong>简介</strong>: AirSim是一个由Microsoft开发的开源机器人仿真工具，支持C++和其他编程语言。它专注于模拟无人机和汽车的行为。</li>
<li><strong>特点</strong>: 高度可定制，支持多种传感器，包括RGB相机和深度相机。</li>
</ul>
</li>
</ol>
<p>在选择机器人仿真工具时，需要考虑仿真的准确性、易用性、物理引擎质量以及与其他工具和库的集成能力。具体的选择将取决于项目的需求和目标。</p>
<h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ 线程池的应用</li>
</ul>
<h2 id="boost-asio"><a href="#boost-asio" class="headerlink" title="boost.asio"></a>boost.asio</h2><ul>
<li>boost::asio::thread_pool类</li>
<li>结合mongoose，搭建异步http服务器，示例代码如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">http_server_with_mongoose</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">HttpMessage</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::string path;</span><br><span class="line">        std::string method;</span><br><span class="line">        std::string body;</span><br><span class="line"></span><br><span class="line">        std::string response_type;</span><br><span class="line">        std::string response_body;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">HttpWithMongoose</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">mg_mgr</span> mgr;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">mg_connection</span> *connect;</span><br><span class="line">        boost::asio::thread_pool tp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">HttpWithMongoose</span>() : <span class="built_in">tp</span>(<span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">mg_mgr_init</span>(&amp;mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">HttpWithMongoose</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">mg_mgr_free</span>(&amp;mgr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            connect = <span class="built_in">mg_http_listen</span>(&amp;mgr, <span class="string">&quot;0.0.0.0:9999&quot;</span>, handle_event, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">mg_mgr_poll</span>(&amp;mgr, <span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Dispath</span><span class="params">(HttpMessage&amp; http_message)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;path: &quot;</span> &lt;&lt; http_message.path &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                      &lt;&lt; <span class="string">&quot;method: &quot;</span> &lt;&lt; http_message.method &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                      &lt;&lt; <span class="string">&quot;body: &quot;</span> &lt;&lt; http_message.body &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            http_message.response_type = <span class="string">&quot;Content-type: application/json&quot;</span>;</span><br><span class="line"></span><br><span class="line">            nlohmann::json reply_data;</span><br><span class="line">            reply_data[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;http with mongoose!&quot;</span>;</span><br><span class="line">            http_message.response_body = reply_data.<span class="built_in">dump</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_event</span><span class="params">(mg_connection *connect, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            HttpWithMongoose* this_ptr = <span class="built_in">static_cast</span>&lt;HttpWithMongoose *&gt;(fn_data);</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">mg_http_message</span>* hm = <span class="built_in">static_cast</span>&lt;<span class="keyword">struct</span> mg_http_message*&gt;(ev_data);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (ev)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> MG_EV_HTTP_MSG:</span><br><span class="line">                &#123;</span><br><span class="line">                    HttpMessage http_message;</span><br><span class="line"></span><br><span class="line">                    http_message.path = std::<span class="built_in">string</span>(hm-&gt;uri.ptr, hm-&gt;uri.len);</span><br><span class="line">                    http_message.method = std::<span class="built_in">string</span>(hm-&gt;method.ptr, hm-&gt;method.len);</span><br><span class="line">                    http_message.body = std::<span class="built_in">string</span>(hm-&gt;body.ptr, hm-&gt;body.len);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// std::thread tmp_thread = std::thread([](HttpMessage http_message, HttpWithMongoose* this_ptr, struct mg_connection* connect)</span></span><br><span class="line">                    <span class="comment">// &#123;</span></span><br><span class="line">                    <span class="comment">//     this_ptr-&gt;Dispath(http_message);</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//     mg_http_reply(connect, 200, http_message.response_type.c_str(), http_message.response_body.c_str());</span></span><br><span class="line">                    <span class="comment">//     connect-&gt;is_draining = 1;</span></span><br><span class="line">                    <span class="comment">// &#125;, http_message, this_ptr, connect);</span></span><br><span class="line">                    <span class="comment">// tmp_thread.detach();</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">auto</span> dpcp = [](HttpMessage http_message, HttpWithMongoose* this_ptr, <span class="keyword">struct</span> mg_connection* connect)</span><br><span class="line">                    &#123;</span><br><span class="line">                        this_ptr-&gt;<span class="built_in">Dispath</span>(http_message);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">mg_http_reply</span>(connect, <span class="number">200</span>, http_message.response_type.<span class="built_in">c_str</span>(), http_message.response_body.<span class="built_in">c_str</span>());</span><br><span class="line">                        connect-&gt;is_draining = <span class="number">1</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    boost::asio::<span class="built_in">post</span>(this_ptr-&gt;tp, std::<span class="built_in">bind</span>(dpcp, http_message, this_ptr, connect));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    HttpWithMongoose http_server;</span><br><span class="line"></span><br><span class="line">    http_server.<span class="built_in">Start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">C++抽象机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-16 13:07:18" itemprop="dateModified" datetime="2025-06-16T13:07:18+08:00">2025-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>C++类是创建新类型的工具，创建出的新类型可以像内置类型一样方便地使用。而且派生类和模板允许程序员表达类之间的（层次和参数化）关系并且利用这种关系。</p>
</li>
<li><p>一个类型就是一个概念（一个思想，一个观念等）的具体表示。</p>
</li>
<li><p><strong>类是用户自定义类型。如果一个概念没有与之直接对应的内置类型，我们就定义一个新类型来表示它。</strong></p>
</li>
<li><p>定义新类型的基本思想是将实现的细节（例如，某种类型对象的数据存储布局）与正确使用它的必要属性（例如，可访问数据的函数的完整列表）分离。这种分离的最佳表达方式是：通过一个专用接口引导数据结构及其内部辅助例程的使用</p>
</li>
</ul>
<h3 id="类基础"><a href="#类基础" class="headerlink" title="类基础"></a>类基础</h3><ul>
<li><p>类的简要概括：</p>
<ul>
<li>一个类就是一个用户自定义类型</li>
<li>一个类由一组成员构成。最常见的成员类别是数据成员和成员函数</li>
<li>成员函数可定义初始化（创建），拷贝，移动和清理（析构）等语义</li>
<li>可以为类定义运算符，如+， ！和[]</li>
<li>一个类就是一个包含其成员的名字空间</li>
<li>对对象使用<code>.（点）</code>访问成员，对指针使用<code>-&gt;（箭头）</code>访问成员</li>
<li><strong>public成员提供类的接口，private成员提供实现细节。</strong></li>
<li>struct是成员默认为public的class</li>
</ul>
</li>
<li><p>声明于类定义内的函数称为成员函数(member function)，对恰当类型的特定变量使用结构成员访问语法才能调用这种函数。</p>
</li>
<li><p>由于不同结构可能有同名成员函数，在定义成员函数时必须指定结构名。</p>
</li>
</ul>
<h3 id="类内函数定义"><a href="#类内函数定义" class="headerlink" title="类内函数定义"></a>类内函数定义</h3><ul>
<li>如果一个函数不仅在类中声明，还在类中定义，那么它就被当作内联函数处理，即很少修改且频繁使用的小函数适合类内定义。</li>
</ul>
<h3 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h3><ul>
<li>在非static成员函数中，关键字this是指向调用它的对象的指针</li>
</ul>
<h3 id="成员和基类初始化"><a href="#成员和基类初始化" class="headerlink" title="成员和基类初始化"></a>成员和基类初始化</h3><ul>
<li>类自身的构造函数在其函数体执行之前会先调用成员的构造函数</li>
<li>成员的构造函数按成员在类中声明的顺序调用，而不是按成员在初始化器列表中出现的顺序。</li>
</ul>
<h3 id="不变式"><a href="#不变式" class="headerlink" title="不变式"></a>不变式</h3><ul>
<li><p>一个类通常都会有一个不变式。如果是这样，我们希望拷贝和移动操作能够保持此不变式，而析构函数能释放任何用到的资源。</p>
</li>
<li><p>不幸的是，编译器不可能在任何情况下都能了解程序员所考虑的不变式是什么。只要可能，我们就应该：</p>
<ul>
<li>在构造函数中建立不变式（包括可能的资源获取）</li>
<li>在拷贝和移动操作中保持不变式（利用常用名字和类型）</li>
<li>在析构函数中做任何需要的清理工作（包括可能的资源释放）</li>
</ul>
</li>
<li><p>不变式很多最关键，最明显的应用都与资源管理相关。</p>
</li>
<li><p>简单的句柄Handle，其思想是，给定一个用new分配的对象的指针，创建一个Handle。这个Handle提供对象访问功能，并负责最终delete对象</p>
</li>
</ul>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ul>
<li>应该将构造函数，赋值操作以及析构函数设计为一组匹配的操作</li>
<li>使用构造函数为类建立不变式</li>
<li>如果一个构造函数获取了资源，那么这个类就需要一个析构函数释放该资源</li>
<li><strong>如果一个类有虚函数，它就需要一个虚析构函数。</strong></li>
<li>如果一个类没有构造函数，它可以进行逐成员初始化</li>
<li>优先选择使用<code>&#123;&#125;</code>初始化而不是<code>=</code>和<code>()</code>初始化</li>
<li>如果一个类是一个容器，为它定义一个初始化器列表构造函数</li>
<li>按声明顺序初始化成员和基类</li>
<li>在构造函数中优先选择成员初始化而不是赋值操作</li>
<li>使用类内初始化器来提供默认值</li>
<li>如果一个类是一个资源句柄，它可能需要拷贝和移动操作</li>
<li>一个拷贝操作应该提供等价性和独立性</li>
<li>如果一个类被用作基类，防止切片现象</li>
<li>如果一个类需要一个拷贝操作或者一个析构函数，它可能需要一个构造函数，一个析构函数，一个拷贝赋值操作以及一个拷贝构造函数。</li>
<li>如果一个类是一个资源句柄，它需要一个构造函数，一个析构函数和非默认拷贝操作</li>
<li>显式说明你的不变式；用构造函数建立不变式，用赋值操作保持不变式</li>
</ul>
<h2 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h2><ul>
<li><p>C++从Simula借鉴了类和类层次的思想。而且，C++还借鉴了一个重要的设计思想：<strong>类应该用来建模程序员和应用程序世界中的思想</strong></p>
</li>
<li><p>任何一个概念都不是孤立存在的，都有与之共存的相关概念，而且其强大能力中的大部分都源于与其它概念的关联。</p>
</li>
<li><p>C++提供了派生类的概念及相关的语言机制来表达层次关系，即，<strong>表达类之间的共性</strong></p>
</li>
<li><p>C++语言特性支持从已有类构建新的类：</p>
<ul>
<li>实现继承(implementation inheritance):通过共享基类所提供的特性来减少实现工作量</li>
<li>接口继承(interface inheritance):通过一个公共基类提供的接口允许不同派生类互换使用。</li>
</ul>
</li>
<li><p>接口继承常被称为<strong>运行时多态(run-time polymorphism, 或动态多态, dynamic polymorphism)</strong></p>
</li>
<li><p>相反，模板所提供的类的通用性与继承无关，常被称为<strong>编译时多态(compile-time polymorphism， 或静态多态, static polymorphism)</strong></p>
</li>
<li><p>我们常常称一个派生类继承了来自基类的属性，因此这种关系也称为继承(inheritance)</p>
</li>
<li><p>派生类的成员可以使用基类的公有和保护成员，就好像它们声明在派生类中一样，但是派生类不能访问基类的私有成员</p>
</li>
</ul>
<h2 id="类层次"><a href="#类层次" class="headerlink" title="类层次"></a>类层次</h2><ul>
<li>一个派生类自身也可以作为其他类的基类，我们习惯称这样的一组相关的类为类层次(class hierarchy)。</li>
<li>这种层次结构大多数情况下是一棵树，但也可能是更一般的图结构</li>
</ul>
<h3 id="类型域"><a href="#类型域" class="headerlink" title="类型域"></a>类型域</h3><ul>
<li>为了使派生类不至于成为仅仅是一种方便的声明简写方式，我们必须解决一个问题：给定一个Base* 类型的指针，它指向的对象的真正派生类型是什么?</li>
<li>C++提供了四种基本解决方法：<ol>
<li>保证指针只能指向单一类型的对象</li>
<li>在基类中放置一个类型域，供函数查看</li>
<li>使用dynamic_cast</li>
<li>使用虚函数</li>
</ol>
</li>
<li>除非使用final，否则方法1依赖于所使用类型的很多值是，比编译器所能掌握的更多。一般而言，不要试图比类型系统更聪明。但是方法1可用来（特别是与模板组合使用）实现同构容器（如标准库vector和map），以获得非常好的性能</li>
<li>方法2，3和4可用来实现异构列表，即，多种不同类型对象（指针）的列表。</li>
<li>方法3是方法2的一种语言支持的变体，</li>
<li>方法4是方法2的一种特殊的类型安全的变体</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li><p><strong>虚函数机制允许程序员在基类中声明函数，然后在每个派生类中重新的定义这些函数，从而解决了类型域方法的固有问题</strong>。编译器和链接器会保证对象和施用于对象之上的函数之间的正确关联。</p>
</li>
<li><p>为了允许一个虚函数声明能作为派生类中定义的函数的接口，派生类中函数的参数类型必须与基类中声明的参数类型完全一致，返回类型也只允许细微改变。虚成员函数有时也称为方法(method)</p>
</li>
<li><p>如果派生类中的一个函数的<strong>名字</strong>和<strong>参数类型</strong>与基类中的一个虚函数完全相同，则称它**覆盖(override)**了虚函数的基类版本。此外，我们也可以用一个派生层次更深的返回类型覆盖基类中的虚函数</p>
</li>
<li><p>除了我们显式说明调用虚函数的哪个版本之外，覆盖版本会作为最恰当的选择应用于调用它的对象。无论用哪个基类（接口）访问对象，虚函数调用机制都会保证我们总是得到相同的函数</p>
</li>
<li><p>无论真正使用的确切<code>Employee</code>类型是什么，都能令<code>Employee</code>的函数表现出“正确的”行为，这称为<strong>多态性(polymorphism)<strong>。具有虚函数的类型称为</strong>多态类型(polymorphic type)<strong>或（更精确的）</strong>运行时多态类型(run-time polymorphic type)</strong></p>
</li>
<li><p><strong>在C++中为了获得运行时多态行为，必须调用virtual成员函数，对象必须通过指针或引用进行访问</strong>。当直接操作一个对象时（而不是通过指针或引用）编译器了解其确切类型，从而就不需要运行时多态了。</p>
</li>
<li><p>默认情况下，覆盖虚函数的函数自身也变为virtual的。我们在派生类宗可以重复关键字virtual，但是这不是必需的。建议不重复virtual。如果希望明确标记覆盖版本，可以使用<code>override</code>。</p>
</li>
<li><p>显然，为了实现多态性，编译器必须在每个Employee类的对象中保存某种类型信息，并利用它选择虚函数的正确版本。在一个典型的C++实现中，这只会占用一个指针大小的空间：常用的编译器实现技术是将虚函数名转换为函数指针表中的一个索引。这个表通常称为**虚函数表(the virtual function table)**或者简称为vbtl。每个具有虚函数的类都有自己的vbtl,用来标识它的虚函数。</p>
</li>
<li><p><strong>显式限定</strong>，使用作用域解析运算符<code>::</code>调用函数<code>(Manager::print())</code>能够保证不是用virtual机制</p>
</li>
<li><p>如果一个虚函数也是一个inline，对于使用<code>::</code>限定的调用就可以进行内联替换。这给程序员提供了一种方法高效处理某些重要的特殊情形：一个虚函数对相同对象调用另一个虚函数。</p>
</li>
</ul>
<h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><ul>
<li>override不是一个关键字，它是所谓的上下文关键字(contextual keyword)。即，override在某些上下文中有特殊含义，但是在其他地方可用作标识符</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li><p>具有一个或者多个纯虚函数的类称为抽象类(abstract class)，我们无法创建抽象类的对象</p>
</li>
<li><p>抽象类就是要作为<strong>通用指针</strong>和<strong>引用访问</strong>的对象的接口（为了保持多态行为）</p>
</li>
<li><p>因此，对于一个抽象类来说，定义一个虚析构函数通常很重要。由于抽象类提供的接口不能用来创建对象，因此抽象类通常没有构造函数。</p>
</li>
<li><p>如果纯虚函数在派生类中未被定义，那么它仍保持是纯虚函数，因此派生类也是一个抽象类。这令我们可以阶段性地构建具体实现</p>
</li>
<li><p>抽象类提供接口，但是不暴露实现细节。</p>
</li>
<li><p>抽象类所支持的设计风格称为接口继承(interface inheritance)，它与实现继承(implementation inheritance)相对，后者是由带状态或定义了成员函数的基类所支撑的。两种风格组合使用是有可能的。即，我们可以定义并使用即带状态又有纯虚函数的基类。但是，这种混合风格会令人迷惑，也需要特别小心。</p>
</li>
</ul>
<h2 id="基类和派生类成员"><a href="#基类和派生类成员" class="headerlink" title="基类和派生类成员"></a>基类和派生类成员</h2><ul>
<li>一个派生类至少包含从基类那里继承来的成员，通常还包含其他成员。这意味着我们可以安全地将一个基类成员指针赋予一个派生类成员指针，但是反方向赋值则不行，这一特性常被称为逆变性(contravariance)</li>
<li>这一逆变规则看起来与另一规则是相反的：我们可以将一个派生类指针赋予其基类的指针。</li>
<li>实际上，两个规则都是为了提供基本保障：<strong>一个指针永远不应该指向这样的对象–不能提供指针所承诺的最基本的属性。</strong></li>
</ul>
<h2 id="类层次-1"><a href="#类层次-1" class="headerlink" title="类层次"></a>类层次</h2><ul>
<li>一个系统应该用抽象类层次表示，而用传统的层次体系实现。换句话说：<ul>
<li>用抽象类支持接口继承</li>
<li>用带有虚函数实现的基类支持实现继承</li>
</ul>
</li>
</ul>
<h3 id="多重继承-multiple-inheritance"><a href="#多重继承-multiple-inheritance" class="headerlink" title="多重继承(multiple inheritance)"></a>多重继承(multiple inheritance)</h3><ul>
<li><p>直接从多个类中派生称为多重继承</p>
</li>
<li><p>用一个基类表示实现细节，用另一个基类表示接口（抽象类）的做法对于所有支持继承和编译时接口检查的编程语言来说都是非常常见的。</p>
</li>
<li><p>“我个人习惯于使用一个实现层次体系，再（在必要时）辅以几个提供接口的抽象类。这种方式比较灵活，也易于系统的演化。但是我们未必总能如愿，尤其是当需要使用现有的类，有不想对它作出任何修改时更时如此（比如，这些类属于别人的库）”</p>
</li>
</ul>
<h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><ul>
<li>两个基类的成员函数可能具有相同的名字，产生歧义。具体做法是为成员名字加一个类限定符。</li>
<li>然而，显式消除二义性比较繁琐，解决此类问题的最佳方式是在派生类中定义一个新函数。在派生类中声明的函数会覆盖基类中所有同名及同类型的函数。通常情况下，这种效果就是我们需要的，因为在同一个类中的同一个名字不宜有多重含义。<strong>virtual的目标是对于一个调用来说，不管我们是通过哪个接口找到函数的，它的执行效果都应该保持一致。</strong></li>
</ul>
<h2 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h2><ul>
<li><p>如果每个类只有一个直接基类，则类层次表现为一棵树，并且每个类在树中只能出现一次。如果每个类可以有多个基类，则在层次体系中每个类可能出现多次。</p>
</li>
<li><p>重复基类的虚函数可以在派生类中被一个（单独的）函数覆盖。通常情况下，这个覆盖的函数先调用其基类的版本，然后执行派生类自己的操作。</p>
</li>
<li><p>每个被指定为virtual的基类只用该类的一个单独的对象表示。另一个方面，非virtual基类由其子对象表示。</p>
</li>
<li><p><strong>派生类可以覆盖其直接或者间接虚基类的虚函数。尤其是，两个不同的类可能会覆盖虚基类的不同的虚函数。通过这种方式，几个派生类就能共同为一个虚基类表示的接口提供实现了。</strong></p>
</li>
</ul>
<h3 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h3><ul>
<li>不要在作为接口的基类中放置数据成员</li>
<li>用抽象类表示接口</li>
<li>为抽象基类定义一个虚析构函数确保其正确地清理资源</li>
<li>用抽象类支持接口继承</li>
<li>用含有数据成员的基类支持实现继承</li>
<li>用普通的多重继承表示特征的组合</li>
<li>用多重继承把实现的接口分离开来</li>
<li>用虚基类表示层次中一部分（而非全部）类公有的内容</li>
</ul>
<h2 id="运行时类型信息"><a href="#运行时类型信息" class="headerlink" title="运行时类型信息"></a>运行时类型信息</h2><ul>
<li>一般来说，类是从基类的框架中构造出来的。这种类框架(class lattice)通常被称为类层次(class hierarchy)</li>
<li>在运行时使用类型信息通常被称为“运行时类型信息”，简写为RTTI(Run-Time Type Information)</li>
<li>从基类到派生类的转换通常称为向下转换(downcast),从派生类到基类的转换称为向上转换(upcast),从基类到兄弟类的转换，称为交叉转换(crosscast)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/" class="post-title-link" itemprop="url">C++常见错误</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C&#x2F;C++程序编译或者运行常见错误</li>
</ul>
<h2 id="error-C2061-语法错误-标识符"><a href="#error-C2061-语法错误-标识符" class="headerlink" title="error C2061: 语法错误 标识符"></a>error C2061: 语法错误 标识符</h2><ul>
<li>错误原因： 重复包含，即A包含了B，B又包含了A</li>
<li>解决办法：头文件class cpp文件include。就是在A.h中，声明B类；在A.cpp中 #include”B.h”</li>
</ul>
<h2 id="windows下C-程序运行出错-Access-violation-reading-location"><a href="#windows下C-程序运行出错-Access-violation-reading-location" class="headerlink" title="windows下C++程序运行出错: Access violation reading location"></a>windows下C++程序运行出错: Access violation reading location</h2><ul>
<li><p>在Visual Studio 2019的Ｃ++工程，编译是没有问题的，但是在程序调试运行时经常会出现’Access violation reading location’的问题，经过调试跟踪后，发现是由于变量被多个代码段访问到，可能出现了空指针的情况。这种错误也不是每次都发生，所以比较难找到原因和追踪到。具体原因可能是所访问的变量已经被其它部分代码改动了，具体建议如下：<br>Then verify that the values are not being unintentionally changed somewhere in the program by creating a Data Breakpoint for the pointer in question to make sure it isn’t being modified elsewhere in the program.</p>
</li>
<li><p>使用以下两个办法可以大大减少此类问题的发生。  </p>
<ul>
<li>在有可能发生变量使用冲突的地方加上 try {…} catch (std::exception ex) {} 来捕捉这个异常，异常被捕捉到后程序时可以接着运行的</li>
<li>减少多段代码访问同一个变量的情况。</li>
</ul>
</li>
</ul>
<h2 id="warning-C4819-该文件包含不能在当前代码页-936-中表示的字符。请将该文件保存为-Unicode-格式以防止数据丢失"><a href="#warning-C4819-该文件包含不能在当前代码页-936-中表示的字符。请将该文件保存为-Unicode-格式以防止数据丢失" class="headerlink" title="warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失"></a>warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失</h2><ul>
<li>使用vs编译时遇到这个错误,正常情况下写的文件是没有问题的，只要用其它编辑器修改过后再保存,再用vs编译就会出现这个问题。</li>
<li>解决方法<ul>
<li>在VS IDE中将文件另存为，在保存中选择高级保存选项，选择 Unicode (UTF-8 带签名) - 代码页65001</li>
</ul>
</li>
</ul>
<h2 id="C-to-‘const-std-mutex’-discards-qualifiers-错误"><a href="#C-to-‘const-std-mutex’-discards-qualifiers-错误" class="headerlink" title="C++ to ‘const std::mutex’ discards qualifiers 错误"></a>C++ to ‘const std::mutex’ discards qualifiers 错误</h2><p>这个错误通常是因为你在尝试将一个非 const 的 <code>std::mutex</code> 对象赋值给一个 <code>const std::mutex</code> 对象，或者你在一个 const 成员函数中尝试对一个非 const 的 <code>std::mutex</code> 对象进行操作。这违反了 C++ 的 const-correctness 原则，即 const 对象只能调用 const 成员函数，并且不能被修改。</p>
<p>以下是一个示例，展示了可能导致这个错误的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 错误！const 成员函数中尝试对非 const 的 mutex 进行操作</span></span><br><span class="line">        mutex.<span class="built_in">lock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mutex; <span class="comment">// 使用 mutable 关键字标记 mutex 可以在 const 成员函数中修改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> MyClass obj;</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，你需要确保在 const 成员函数中只能对 <code>std::mutex</code> 对象调用 <code>const</code> 成员函数，或者使用 <code>mutable</code> 关键字标记 <code>std::mutex</code>，以便在 const 成员函数中修改它。</p>
<h2 id="C-as-‘this’-argument-discards-qualifiers-fpermissive-错误"><a href="#C-as-‘this’-argument-discards-qualifiers-fpermissive-错误" class="headerlink" title="C++ as ‘this’ argument discards qualifiers [-fpermissive] 错误"></a>C++ as ‘this’ argument discards qualifiers [-fpermissive] 错误</h2><p>这个错误通常是由于在常量成员函数中试图修改成员变量引起的。C++ 中的常量成员函数是指在函数声明和定义中使用 <code>const</code> 修饰的成员函数，表示该函数不会修改调用对象的成员变量。</p>
<p>错误信息 “‘this’ argument discards qualifiers” 意味着你在常量成员函数中试图修改 <code>this</code> 指针所指向的对象。这是不允许的，因为常量成员函数被设计为不修改对象的状态。</p>
<p>以下是一个简单的例子，展示了可能导致这个错误的情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量成员函数，试图修改成员变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 错误：试图在常量成员函数中修改成员变量</span></span><br><span class="line">        <span class="comment">// data = 42;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> MyClass obj;</span><br><span class="line">    obj.<span class="built_in">modifyData</span>();  <span class="comment">// 调用常量成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>modifyData</code> 是一个常量成员函数，但它试图修改 <code>data</code> 成员变量，这将导致上述错误。</p>
<p>要解决这个问题，你应该确保在常量成员函数中不修改成员变量。如果你需要在常量对象上调用一个能够修改成员变量的函数，该函数应该被声明为非常量成员函数。如果你确实需要在常量对象上进行某些修改，你可能需要使用 <code>mutable</code> 关键字来声明一个可变的成员变量。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> data; <span class="comment">// 使用 mutable 关键字声明可变成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        data = <span class="number">42</span>; <span class="comment">// 合法：在常量成员函数中修改可变成员变量</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>请根据你的需求选择适当的解决方案。</p>
<h2 id="C-编译错误-error-prototype-for"><a href="#C-编译错误-error-prototype-for" class="headerlink" title="C++ 编译错误 error: prototype for"></a>C++ 编译错误 error: prototype for</h2><p>看起来你遇到了一个编译错误，错误信息中包含了 “error: prototype for”。这通常是因为函数的声明和定义之间存在不一致，导致编译器无法匹配它们。</p>
<p>常见的情况包括：</p>
<ol>
<li>函数声明和函数定义之间的参数不匹配。</li>
<li>函数声明和函数定义之间的返回类型不匹配。</li>
</ol>
<p>要解决这个问题，你需要确保函数的声明和定义在参数和返回类型等方面保持一致。以下是一些可能导致这个错误的情况以及解决方法：</p>
<p><strong>情况1：参数不匹配</strong></p>
<p>假设你有以下的函数声明和定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，声明和定义中的参数名称不一致（x、y 和 a、b）。编译器会认为这是两个不同的函数，因此会产生错误。解决方法是保持参数名称一致：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明和定义都使用相同的参数名称</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>情况2：返回类型不匹配</strong></p>
<p>另一个可能的情况是函数的声明和定义之间的返回类型不匹配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，声明指定了函数返回类型为 <code>int</code>，但定义实际上是一个无返回值的函数（返回类型为 <code>void</code>）。要解决这个问题，保持返回类型一致：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明和定义都使用相同的返回类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请检查你的代码，确保函数的声明和定义在参数和返回类型等方面保持一致，这样编译器就不会报 “error: prototype for” 错误了。如果问题仍然存在，你可以提供更多的代码片段和错误信息，我将尽力帮助你找到解决方案。</p>
<h2 id="C-编译错误-error-candidate-is"><a href="#C-编译错误-error-candidate-is" class="headerlink" title="C++ 编译错误 error: candidate is"></a>C++ 编译错误 error: candidate is</h2><p>你好！你提供的信息有点有限，我需要更多的上下文来帮助你解决这个问题。”error: candidate is” 是一个编译错误的提示信息，通常出现在 C++ 代码中。这个错误提示通常是由于在某个上下文中找到了多个可能匹配的候选项，编译器无法确定要选择哪个。</p>
<p>为了更好地帮助你，可以提供以下信息：</p>
<ol>
<li>完整的错误提示信息，包括错误的文件路径、行号和列号。</li>
<li>引发错误的代码片段，尤其是错误所在的代码行附近的代码。</li>
<li>你正在尝试进行的操作，以及你的预期结果。</li>
</ol>
<p>这些信息将有助于我更准确地理解问题，并为你提供更具体的帮助。</p>
<h2 id="没有命名类型-declare-class-does-not-name-type"><a href="#没有命名类型-declare-class-does-not-name-type" class="headerlink" title="没有命名类型: declare class does not name type"></a>没有命名类型: <code>declare class does not name type</code></h2><ul>
<li><p>出现这个编译错误主要有四个可能原因，现总结如下：</p>
<ul>
<li>引用的类命名空间未包含</li>
<li>引用的类头文件未包含</li>
<li>包含了头文件，或者已经前置声明了，则说明所引用的类名写错了</li>
<li><strong>循环引用头文件</strong></li>
<li>定义或声明的语句，第一个词一定是类型</li>
</ul>
</li>
<li><p>前置声明要素：</p>
<ul>
<li>前置声明需要注意以上提到的几点</li>
<li>尽可能的采用前置声明，做到只有包含继承类的头文件</li>
<li>使用前置声明时，CPP文件中include头文件次序必须先包含前置声明的类定义头文件，再包含本类头文件。否则会出现错误：<ul>
<li><code>(expected constructor, destructor, or type conversion before ‘typedef&#39;)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>前置声明</p>
<ul>
<li><code>XXX</code>应该是一种用户定义的数据类型，而由于没有声明或者拼写错误或者与关键词重名，导致编译有错，出现类型错误</li>
<li>在一个源文件中，要声明或定义一个类的指针时，必须在使用前声明或定义该类</li>
</ul>
</li>
<li><p>使用前置声明：</p>
<ul>
<li><code>class Base;</code></li>
</ul>
</li>
</ul>
<h2 id="未声明的引用"><a href="#未声明的引用" class="headerlink" title="未声明的引用"></a>未声明的引用</h2><ul>
<li><p>如果错误是未声明的引用，那就是找不到函数的原型</p>
</li>
<li><p>解决办法，通常是相关的头文件未包含</p>
</li>
</ul>
<h2 id="未定义引用-undefined-reference-to-xxx"><a href="#未定义引用-undefined-reference-to-xxx" class="headerlink" title="未定义引用:undefined reference to &#39;xxx&#39;"></a>未定义引用:<code>undefined reference to &#39;xxx&#39;</code></h2><ul>
<li><p>未定义引用的问题是：编译之后，链接阶段出现的</p>
</li>
<li><p>未定义引用产生的原因：</p>
<ul>
<li>一个是，生成库文件的时候，某个源文件(cpp)路径不正确</li>
<li>另一个是，有函数声明，但是没有函数定义</li>
</ul>
</li>
<li><p>出现未定义引用的错误原因，主要是C&#x2F;C++编译为object文件的时候，并不需要函数的具体实现，只要有函数的原型即可，但是在链接可执行文件的时候就必须要具体的实现了。</p>
</li>
<li><p>一般的原因：</p>
<ul>
<li>gcc依赖顺序问题</li>
<li>库文件找不到</li>
<li>库文件损坏</li>
<li>C++编译时会修改函数名，CPP文件引用C文件中的函数，混编时很可能报未定义的错误，需要使用<code>extern &quot;C&quot;</code>包裹起来</li>
</ul>
</li>
</ul>
<h2 id="段错误-Segmentation-fault"><a href="#段错误-Segmentation-fault" class="headerlink" title="段错误:Segmentation fault"></a>段错误:<code>Segmentation fault</code></h2><ul>
<li><p>段错误是什么？</p>
<ul>
<li>段错误是指访问的内存超出了系统给这个程序所设定的内存空间。</li>
</ul>
</li>
<li><p>段错误产生的原因</p>
<ol>
<li>访问不存在的内存地址</li>
<li>访问系统保护的内存地址</li>
<li>访问制度的内存地址</li>
<li>栈溢出</li>
<li>delete使用错误</li>
</ol>
</li>
</ul>
<h2 id="corrupted-size-vs-prev-size-问题-内存越界"><a href="#corrupted-size-vs-prev-size-问题-内存越界" class="headerlink" title="corrupted size vs. prev_size 问题 内存越界"></a><code>corrupted size vs. prev_size</code> 问题 内存越界</h2><ul>
<li><p>在C++中我们时常会遇见<code>corrupted size vs. prev_size</code>的报错，它的原因在于<strong>内存越界</strong></p>
</li>
<li><p>其实解决这个问题的办法在于使用<code>vector</code>来代替自己申请内存，并且使用以下两种方法来访问元素：</p>
<ul>
<li>使用迭代器</li>
<li>使用<code>at</code></li>
</ul>
</li>
<li><p>尽量要避免使用<code>[]</code>来访问<code>vector</code>，越界的时候很难找到错误的地方，使用<code>at</code>带有越界的检查，更为安全。</p>
</li>
</ul>
<h2 id="memory-corruption-内存泄漏"><a href="#memory-corruption-内存泄漏" class="headerlink" title="memory corruption  内存泄漏"></a><code>memory corruption</code>  内存泄漏</h2><h2 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h2><ul>
<li><p>内存问题始终是C++程序员需要去面对的问题，这也是C++语言门槛高的原因之一</p>
</li>
<li><p>常见的内存问题：</p>
<ol>
<li>内存重复释放，出现<code>double free</code>时，通常是由于这种情况导致的</li>
<li>内存泄漏，分配的内存忘记释放</li>
<li>内存越界使用，使用了不该使用的内存</li>
<li>使用了无效指针</li>
<li>空指针，对一个空指针进行操作</li>
</ol>
</li>
<li><p>内存越界，引起的问题有极大的不确定性，有时大，有时小，有时可能不会对程序的运行产生影响，正是这种不易复现的错误，才是最致命的。</p>
</li>
<li><p>内存越界，通常可能会造成如下几种情况：</p>
<ol>
<li>破坏了堆中的内存分配信息数据，特别是动态分配的内存块的内存信息数据。因为操作系统在分配和释放内存块时需要访问该数据，一旦该数据被破坏，可能会出现一下几种情况：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">        *** glibcdetected *** free(): invalid pointer:</span><br><span class="line">        *** glibcdetected *** malloc(): memory corruption:</span><br><span class="line">        *** glibcdetected *** double free or corruption (out): 0x00000000005c18a0 ***</span><br><span class="line">        *** glibcdetected *** corrupted double-linked list: 0x00000000005ab150***</span><br><span class="line">        ```    </span><br><span class="line">  2. 破坏了程序自己的其他对象的内存空间，这种破坏会影响程序执行的不正确性，当然也会诱发`coredump`，如破坏了指针数据</span><br><span class="line">  3. 破坏了空闲内存块</span><br><span class="line">  4. 通常，代码错误被激发是偶然的，也就是说之前的程序一切正常，可能由于为类增加了两个成员变量，或者改变了某一部分代码，`coredump`就频繁发生，而增加的代码绝不会有任何问题，这时应该考虑**是否是某些内存被破坏了**。</span><br><span class="line"></span><br><span class="line">+ 注意事项：</span><br><span class="line">  1. **出现段错误时**，首先应该想到段错误的定义，从它出发考虑引发错误的原因</span><br><span class="line">  2. **在使用指针时**，定义了指针后记得初始化指针，在使用的时候记得判断是否为NULL</span><br><span class="line">  3. **在使用数组时**，注意数组是否被初始化，数组下标是否越界，数组元素是否存在等</span><br><span class="line">  4. **在访问变量时**，注意变量所占地址空间是否已经被程序释放</span><br><span class="line">  5. **在处理变量时**，注意变量的格式控制是否合理等</span><br><span class="line"></span><br><span class="line">## 核心转储:`core dumped`</span><br><span class="line"></span><br><span class="line">+ 当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的**内存状态**记录下来，保存在一个文件中，这种行为就叫做`Core Dump`（中文有的翻译成 核心转储）</span><br><span class="line">+ 可以认为`core dump`是内存快照，但实际上，除了内存信息之外，还有一些关键的程序运行状态也会同时`dump`下来，例如寄存器信息（包括程序指针，栈指针），内存管理信息，其他处理器和操作系统状态和信息。</span><br><span class="line">+ `Segmentation fault (core dumped)`通常是内存未正常操作造成。空指针，野指针的读写操作，数组越界访问，破坏常量等。</span><br><span class="line"></span><br><span class="line">+ 打开`core dump`功能</span><br><span class="line">  1. 在终端输入命令`ulimit -c`，输出结果为0，表示关闭`core dump`，即当程序异常终止时，也不会生成`core dump`文件</span><br><span class="line">  2. 可以使用命令`ulimit -c unlimited`来开启`core dump`功能，并且不限制`core dump`文件的大小；如果需要限制文件的大小，将`unlimited`换成想生成文件的存储上限，单位为blocks(KB)</span><br><span class="line">  3. 用上面命令只会对当前终端环境有效，如果想要永久生效，需要设置文件`/etc/security/limits.conf`文件</span><br><span class="line">  4. 默认生成的`core`文件保存在可执行文件所在的目录下，文件名就为`core`</span><br><span class="line">  5. 修改文件`/proc/sys/kernel/core_uses_pid`文件可以让生成`core`文件名自动加上pid号</span><br><span class="line">  6. 修改文件`/proc/sys/kernel/core_pattern`控制生成`core`文件保存的位置以及文件名格式</span><br><span class="line"></span><br><span class="line">## Linux下C/C++程序内存泄露检查工具</span><br><span class="line"></span><br><span class="line">+ valgrind:强大开源的程序检测工具</span><br><span class="line">+ mtrace:GNU扩展,用来跟踪malloc</span><br><span class="line">+ dmalloc:用于检查C/C++内存泄露的工具,即是检查是否在程序运行结束还没有释放的内存,以一个运行库发布</span><br><span class="line">+ memwatch:和dmalloc一样,能够检测未释放的内存,同一段内存被释放多次,位地址取错误及不当使用未分配的内存区域</span><br><span class="line">+ mpatrol:一个跨平台的C++内存泄露检测器</span><br><span class="line">+ dbgmem:是一个动态库发布的形式,有点类似于dmalloc</span><br><span class="line"></span><br><span class="line">### Valgrind详解</span><br><span class="line"></span><br><span class="line">+ `Valgrind`包含以下一些工具:</span><br><span class="line">  1. `Memcheck`:这是`valgrind`应用最广泛的工具,一个重量级的内存检查器,能够发现 开发中绝大不多述的内存错误使用的情况,比如:使用未初始化</span><br><span class="line">  2. `callgrind`:主要用来检查程序中函数调用过程中出现的问题</span><br><span class="line">  3. `cachegrind`:主要用来检查程序中缓存使用出现的问题</span><br><span class="line">  4. `Helgrind`:主要用来检查多线程中出现的竞争问题</span><br><span class="line">  5. `Massif`:主要用来检查程序中堆栈使用中出现的问题</span><br><span class="line">  6. `Extension`:可以使用core提供的功能,自己编写特定的内存调试工具</span><br><span class="line"></span><br><span class="line">+ 内存检查原理:</span><br><span class="line">  1. `Valid-value`表:对于进程的整个地址空间中的每一个字节(byte),都有与之对应的8个bits,对于CPU的每个寄存器,也有一个与之对应的bit向量,这些bits负责记录该字节或者寄存器值是否具有有效的,已经初始化的值</span><br><span class="line">  2. `Valid-Address`表:对于进程整个地址空间中的一个字节(byte),还有与之对应的1bit,负责记录改地址是否能够被读写</span><br><span class="line">  3. 检测原理:</span><br><span class="line">     + 当要读写内存中的某个字节时,首先检查这个字节对应的A bit, 如果该A bit显示该位置是无效位置,memcheck则报告读写错误</span><br><span class="line">     + 内核(core)类似于一个虚拟的CPU环境,这样当内存中的某个字节被加载到真实的CPU中时,该字节对应的V bit也被加载到虚拟的CPU环境中,一旦寄存器中的值,被用来产生内存地址,或者该值能够影响程序的输出,则memcheck会检查对应的vbits,如果该值尚未初始化,则会报告使用未初始化内存错误</span><br><span class="line"></span><br><span class="line">+ `Valgrind`的安装</span><br><span class="line">  1. 解压安装包:`tar -jxvf valgrind-3.11.0.tar.bz2 -C /usr/local/src`</span><br><span class="line">  2. 进入目录安装:`cd /usr/local/src/valgrind-3.11.0`</span><br><span class="line">  3. 运行 `./autogen.sh` 设置环境(需要标准的`autoconf`工具):`./autogen.sh`</span><br><span class="line">  4. 配置`Valgrind`,生成Makefile文件:`./configure --prefix=/usr/local`</span><br><span class="line">  5. 编译和安装`valgrind`:`make &amp;&amp; make install`</span><br><span class="line"></span><br><span class="line">+ `Valgrind`的使用 </span><br><span class="line">  + 为了`valgrind`发现的错误更精确,如能够定位到源代码的行,建议在编译时加上-g参数,编译优化选项选择O0(不要优化)</span><br><span class="line">  + 利用`valgrind`调试内存问题,不需要重新编译源程序,它的输入就是二进制的可执行程序</span><br><span class="line">  + 调用`valgrind`的通用格式:valgrind [valgrind-options] your-program [your-program-options]</span><br><span class="line">  + `Valgrind`的参数分为两类</span><br><span class="line">      + 一类是core的参数,它对所有的工具都适用</span><br><span class="line">      + 另一类就是具体某个工具,如memcheck的参数.</span><br><span class="line">  + `Valgrind`默认的工具就是memcheck,也可以通过 `-tool=toolname` 指定其他的工具</span><br><span class="line"></span><br><span class="line">+ `Memcheck`将内存泄露分为两种:</span><br><span class="line">  1. `Possibly lost`:可能的内存泄露</span><br><span class="line">        + `Possibly lost`是指仍然存在某个指针能够访问某块内存,但是该指针指向的已经不是该内存的首地址</span><br><span class="line">  2. `Definitely lost`:确定的内存泄漏</span><br><span class="line">        + 确定的内存泄露是指已经不能够访问这块内存</span><br><span class="line">        + `Definitely lost`又分为两种:</span><br><span class="line">            1. `direct`:直接,直接是没有任何指针指向该内存</span><br><span class="line">            2. `indirect`:间接,指向该内存的指针都位于内存泄露处</span><br><span class="line"></span><br><span class="line">+ `Valgrind`常用命令</span><br><span class="line">  + `-log-file=valReport` :指定生成分析日志文件到当前执行目录,文件名为 `valReport`</span><br><span class="line">  + `-leak-check=full` :显示每个泄露的详细信息</span><br><span class="line">  + `-show-reachable=yes` :是否检测控制范围之外的泄露,比如全局指针,`static`指针等,显示所有的内存泄露类型</span><br><span class="line">  + `-leak-resolution=low` :内存泄露报告合并等级</span><br><span class="line"></span><br><span class="line">+ `Valgrind`输出内容:</span><br><span class="line">  + `==98725==` :进程号,如果程序使用了多进程的方式来执行,就会显示多个进程的内容</span><br><span class="line">  + 第一段是`valgrind`的基本信息</span><br><span class="line">  + 第二段是对堆内存分配的总结信息,</span><br><span class="line">  + 第三段的内容描述了内存泄露的具体信息</span><br><span class="line">  + 最后一段是总结,4字节为一块的内存泄露</span><br><span class="line"></span><br><span class="line">## C++ 编译： crosses initialization of ...</span><br><span class="line"></span><br><span class="line">+ 在switch-case中定义变量，编译时出现异常：crosses initialization of......，</span><br><span class="line">+ 异常代码如下:</span><br><span class="line">```cpp</span><br><span class="line">switch (ev)</span><br><span class="line">&#123;</span><br><span class="line">    case MG_EV_HTTP_MSG:</span><br><span class="line">        std::thread tmp(EventHandler, connect, hm);</span><br><span class="line">        tmp.detach();</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>出现异常的原因是：</p>
<ul>
<li>C&#x2F;C++中变量的生命周期问题，在case MG_EV_HTTP_MSG中定义了变量tmp，在default中也能够使用，但是如果在程序运行中直接跳入default分支，就会出现没有初始化的异常。</li>
<li>程序编译时为了防止出现上述情况，就会报编译失败，不是证明程序有异常，只是编译器担心程序有异常。</li>
</ul>
</li>
<li><p>解决方法有两个</p>
<ul>
<li>在switch-case外进行定义:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">tmp</span><span class="params">(EventHandler, connect, hm)</span></span>;</span><br><span class="line"><span class="keyword">switch</span> (ev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> MG_EV_HTTP_MSG:</span><br><span class="line">        tmp.<span class="built_in">detach</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在case中加花括号<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> MG_EV_HTTP_MSG:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">tmp</span><span class="params">(EventHandler, connect, hm)</span></span>;</span><br><span class="line">        tmp.<span class="built_in">detach</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/" class="post-title-link" itemprop="url">C++极客时间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>内存管理的基本概念，大致的学习路径是：<ul>
<li>先讲堆和栈，</li>
<li>然后讨论C++的特色功能RAII</li>
</ul>
</li>
</ul>
<h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul>
<li><p>堆，英文是heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手动释放，否则就会造成内存泄漏。</p>
</li>
<li><p>C++标准里有一个相关概念是自由存储区，英文是 free store，特指使用 new 和 delete 来分配和释放内存的区域。一般而言，这是堆的一个子集：</p>
<ul>
<li>new 和 delete 操作的区域是 free store</li>
<li>malloc 和 free 操作的区域是 heap</li>
</ul>
</li>
<li><p>但 new 和 delete通常底层使用malloc和free来实现，所以free store也是heap。</p>
</li>
<li><p>栈，英文是stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”(last-in-first-out 或 LIFO)</p>
</li>
<li><p>RAII, 完整的英文是 Resource Acquisition Is Initialization，是C++所特有的资源管理方式。由少量其他语言，例如D，Ada和Rust也采纳了RAII，但主流的编程语言中，C++是唯一一个依赖RAII来做资源管理的</p>
</li>
<li><p>RAII依托栈和析构函数，来对所有的资源–包括堆内存在内–进行管理。对RAII的使用，使得C++不需要类似于Java那样的垃圾收集方法，也能有效地对内存进行管理。RAII的存在，也是垃圾收集虽然理论上可以在C++使用，但从来没有真正流行过的主要原因。</p>
</li>
</ul>
<h3 id="1-2-深入探讨-–-堆"><a href="#1-2-深入探讨-–-堆" class="headerlink" title="1.2 深入探讨 – 堆"></a>1.2 深入探讨 – 堆</h3><ul>
<li><p>从现代编程的角度来看，使用堆，或者说使用动态内存分配，是一件再自然不过的事情。</p>
</li>
<li><p>从历史的角度，动态内存分配实际上是较晚出现的。由于动态内存带来的不确定性 –  内存分配耗时需要多久？失败了怎么办？等等。至今仍有很多场合会禁用动态内存，尤其是在实时性要求比较高的场合，例如飞行控制器和电信设备。</p>
</li>
<li><p>在堆上分配内存，有些语言可能使用new这样的关键字，有些语言则是在对象的构造时隐式分配，不需要特殊关键字。</p>
</li>
<li><p>不管哪种情况，程序通常需要牵涉到三个可能的内存管理器的操作</p>
<ul>
<li>让内存管理器分配一个某个大小的内存块</li>
<li>让内存管理器释放一个之前分配的内存款</li>
<li>让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放</li>
</ul>
</li>
<li><p>C++通常会做上面的操作1和2</p>
</li>
<li><p>Java会做上面的操作1和3</p>
</li>
<li><p>Python会做上面的操作1，2，3</p>
</li>
<li><p>这是语言的特性和实现方式决定的。</p>
</li>
<li><p>需要略加说明的是，上面的三个操作都不简单，并且彼此之间是相关的。</p>
</li>
<li><p>幸运的是，内存分配和释放的管理，是内存管理器的任务。一般情况下我们不需要介入。我们只需要正确地使用new和delete。每个new出来的对象都应该用delete来释放。</p>
</li>
</ul>
<h3 id="1-3-深入探讨-–-栈"><a href="#1-3-深入探讨-–-栈" class="headerlink" title="1.3 深入探讨 – 栈"></a>1.3 深入探讨 – 栈</h3><ul>
<li><p>函数调用，本地变量使用栈。这一过程取决于计算机的实际架构，具体细节可能有所不同，但原理上都是相通的，都会使用一个后进先出的结构。</p>
</li>
<li><p>栈是向上增长的。在包括x86在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。任何一个函数，根据架构的约定，只能使用进入函数时栈指针向上部分的栈空间。</p>
</li>
<li><p>当函数调用另外一个函数时，会把参数也压入栈里（我们此处忽略使用寄存器传递参数的情况），然后把下一行汇编指令的地址压入栈，并跳转到新的函数。新的函数进入后，首先做一些必须的保存功能，然后会调用栈指针，分配出本地变量所需要的空间，随后执行函数中的代码，并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。</p>
</li>
<li><p>注意到了吗：本地变量所需要的内存就在栈上，跟函数执行所需要的其他数据在一起。当函数执行完成之后，这些内存也就自然而然释放掉了。</p>
</li>
<li><p>我们可以看到：</p>
<ul>
<li>栈上的分配极为简单，移动一下栈指针而已</li>
<li>栈上的释放也极为简单，函数执行结束时移动一下栈指针即可</li>
<li>由于后进先出的执行过程，不可能出现内存碎片。</li>
</ul>
</li>
<li><p>顺便说一句，（图2）每种颜色都表示某个函数占用的栈空间。这部分空间有个特定的术语，叫做栈帧(stack frame)。</p>
</li>
<li><p>GCC 和 Clang 的命令行参数中提到 frame 的，例如<code>-fomit-frame-pointer</code>，一般就是指栈帧。</p>
</li>
</ul>
<hr>
<ul>
<li><p>前面例子的本地变量是简单类型，C++里称之为POD类型(Plain Old Data)。</p>
</li>
<li><p>对于有构造和析构函数的非POD类型，栈上的内存分配也同样有效，只不过C++编译器会在生成代码的合适位置，插入对构造和析构函数的调用。</p>
</li>
<li><p>这里尤其重要的是：编译器会自动调用析构函数，包括在函数执行发生异常的情况。</p>
</li>
<li><p>在发生异常时对析构函数的调用，还有一个专门的术语，叫做栈展开(stack unwinding)。</p>
</li>
<li><p>在C++里，所有的变量缺省都是值语义 –  如果不使用 * 和 &amp; 的话，变量不会像Java或Python一样引用一个堆上的对象。对于像智能指针这样的类型，写<code>ptr-&gt;call()</code>和<code>ptr.get()</code>，语法上都是对的，并且<code>-&gt;</code>和<code>.</code>有着不同的语法作用。而在大部分其他语言中，访问成员只有<code>.</code>，但在作用上实际等价于C++的<code>-&gt;</code>。</p>
</li>
<li><p>这种值语义和引用语义的区别，是C++的特点，也是它的复杂性的一个来源。要用好C++，就需要理解它的值语义的特点。</p>
</li>
</ul>
<h3 id="1-4-深入探讨-–-RAII"><a href="#1-4-深入探讨-–-RAII" class="headerlink" title="1.4 深入探讨 – RAII"></a>1.4 深入探讨 – RAII</h3><ul>
<li><p>C++支持将对象存储在栈上面。但是，在很多情况下，对象不能，或者不应该，存储在栈上。例如：</p>
<ul>
<li>对象很大</li>
<li>对象的大小在编译时不能确定</li>
<li>对象是函数的返回值，但由于特殊的原因，不应该使用对象的值返回。</li>
</ul>
</li>
<li><p>常见情况之一是：在工厂方法或其他面向对象编程的情况下，返回值类型是基类（的指针或引用）。</p>
</li>
<li><p>举例：—。 这个create_shape方法会返回一个shape对象，对象的实际类型是某个shape的子类。这种情况下，函数的返回值只能是指针或其变体形式。如果返回类型是shape，实际却返回一个circle，编译器不会报错，但结果多半是错的。这种现象叫做对象切片(object slicing)，是C++特有的一种编码错误。这种错误不是语法错误，而是一个对象复制相关的语义错误，也算是C++的一个陷阱</p>
</li>
<li><p>那么，我们怎样才能确保，在使用create_shape的返回值时不会发生内存泄漏呢？</p>
</li>
<li><p>答案就是：在析构函数和它的栈展开行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。</p>
</li>
<li><p>如果好奇delete空指针会发生什么的话，那答案是，这是一个合法的空操作。在new一个对象和delete一个指针时编译器需要干不少活的</p>
<ul>
<li>也就是说，new的时候先分配内存（失败时整个操作失败并向外抛出异常，通常使bad_alloc），然后在这个结果指针上构造对象；</li>
<li>构造成功则new操作整体完成，否则释放刚分配的内存并继续向外抛构造函数产生的异常。</li>
<li>delete时则判断指针是否为空，在指针不为空时调用析构函数并释放之前分配的内存</li>
</ul>
</li>
<li><p>在析构函数里做必要的清理工作，这就是RAII的基本用法。</p>
</li>
<li><p>这种清理并不限于释放内存，也可以是：</p>
<ul>
<li>关闭文件（fstream的析构就会这么做）</li>
<li>释放同步锁</li>
<li>释放其他重要的系统资源</li>
</ul>
</li>
</ul>
<h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><ul>
<li>讨论了C++里内存管理的一些基本概念，强调栈是C++里最自然的内存使用方式，并且，使用基于栈和析构函数的RAII，可以有效地对包括内存在内的系统资源进行统一管理。</li>
</ul>
<h2 id="C-的智能指针"><a href="#C-的智能指针" class="headerlink" title="C++的智能指针"></a>C++的智能指针</h2><ul>
<li>使用智能指针，可以简化资源的管理，从根本上消除资源（包括内存）泄漏的可能性。</li>
<li>智能指针本质上并不神秘，其实就是RAII资源管理功能的自然展现而已。</li>
</ul>
<h3 id="1-1-模板化和易用性"><a href="#1-1-模板化和易用性" class="headerlink" title="1.1 模板化和易用性"></a>1.1 模板化和易用性</h3><ul>
<li>要让某一个类能够包装任意类型的指针，我们需要把它变成一个类模板。</li>
<li>在示例中，和shape_wrapper比较一下，我们就是在开头增加模板声明<code>template &lt;typename T&gt;</code>，然后把代码中的shape替换成模板参数T而已。</li>
</ul>
<h3 id="1-2-拷贝构造和赋值"><a href="#1-2-拷贝构造和赋值" class="headerlink" title="1.2 拷贝构造和赋值"></a>1.2 拷贝构造和赋值</h3><ul>
<li><p>拷贝构造和赋值，我们暂且简称为拷贝，这是个比较复杂的问题了。关键它还不是实现问题，而是我们该如何定义其行为。</p>
</li>
<li><p>使用智能指针的目的就是要减少对象的拷贝。</p>
</li>
<li><p>一般而言，并没有通用的方法可以通过基类的指针来构造出一个子类的对象来。</p>
</li>
<li><p>方法一：</p>
<ul>
<li>在拷贝时转移指针的所有权。在赋值函数中，通过拷贝构造产生一个临时对象并调用swap来交换指针的所有权。这种惯用法保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能在第一步发生；二第一步如果发生异常的话，this对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。</li>
<li>这个语义本质上就是C++98的auto_ptr的定义。但是auto_ptr在C++17时已经被正式从C++标准中删除了</li>
</ul>
</li>
</ul>
<h3 id="1-3-移动指针"><a href="#1-3-移动指针" class="headerlink" title="1.3 移动指针"></a>1.3 移动指针</h3><ul>
<li><p>把拷贝构造函数中的参数类型<code>smart_ptr*</code>改成了<code>smart_ptr&amp;&amp;</code>，现在它成了移动构造函数</p>
</li>
<li><p>把赋值函数中的参数类型<code>smart_ptr&amp;</code>改成了<code>smart_ptr</code>，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为时移动还是拷贝，完全依赖于构造函数时走的是移动构造还是拷贝构造。</p>
</li>
<li><p>根据C++的规则，如果我们提供了移动构造函数，而没有手动提供拷贝构造函数，那么后者自动被禁用</p>
</li>
<li><p>记住，C++里哪些复杂的规则也是为方便编程而设立的。</p>
</li>
<li><p>这也是C++11的unique_ptr的基本行为。</p>
</li>
</ul>
<h3 id="1-4-子类指针向基类指针的转换"><a href="#1-4-子类指针向基类指针的转换" class="headerlink" title="1.4 子类指针向基类指针的转换"></a>1.4 子类指针向基类指针的转换</h3><h3 id="1-5-引用计数"><a href="#1-5-引用计数" class="headerlink" title="1.5 引用计数"></a>1.5 引用计数</h3><ul>
<li><p>unique_ptr 算是一种较为安全的智能指针了。但是，一个对象只能被单个 unique_ptr 所拥有，这显然不能满足所有使用场合的需求。</p>
</li>
<li><p>一种常见的情况是：多个智能指针同时拥有一个对象；当他们全部都失效时，这个对象也同时会被删除。这也就是<code>shared_ptr</code>了</p>
</li>
<li><p>多个不同的<code>shared_ptr</code>不仅可以共享一个对象，在共享同一对象时也需要同时共享一个计数。</p>
</li>
<li><p>当最后一个指向对象（和共享计数）的shared_ptr析构时，它需要删除对象和共享计数。</p>
</li>
</ul>
<h3 id="1-6-指针类型转换"><a href="#1-6-指针类型转换" class="headerlink" title="1.6 指针类型转换"></a>1.6 指针类型转换</h3><ul>
<li><p>对应于C++里的不同的类型强制转换：</p>
<ul>
<li><code>static_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li><code>const_cast</code></li>
<li><code>dynamic_cast</code></li>
</ul>
</li>
<li><p>只能指针需要实现类似的函数模板。实现本身并不复杂，但为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。</p>
</li>
</ul>
<h2 id="右值和移动-究竟解决了什么问题？"><a href="#右值和移动-究竟解决了什么问题？" class="headerlink" title="右值和移动 究竟解决了什么问题？"></a>右值和移动 究竟解决了什么问题？</h2><ul>
<li>移动语义是C++11里引入的一个重要概念；理解这个概念，是理解很多现代C++里的优化的基础。</li>
</ul>
<h3 id="1-1-值分左右"><a href="#1-1-值分左右" class="headerlink" title="1.1 值分左右"></a>1.1 值分左右</h3><ul>
<li><p>我们常常会说，C++里有左值和右值。标准里的定义实际更加复杂，规定了下面这些值类别(value categories)</p>
<ul>
<li>一个 lvalue 是通常可以放在等号左边的表达式，左值</li>
<li>一个 rvalue 是通常只能放在等号右边的表达式，右值</li>
<li>一个 glvalue 是 generalized lvalue， 广义左值</li>
<li>一个 xvalue 是 expiring value， 将亡值</li>
<li>一个 prvalue 是 pure rvalue， 纯右值</li>
</ul>
</li>
<li><p>我们暂且抛开这些概念，只看其中两个：lvalue 和 prvalue</p>
</li>
<li><p>左值 lvalue 是有标识符，可以取地址的表达式，最常见的情况有：</p>
<ul>
<li>变量，函数或数据成员的名字</li>
<li>返回左值引用的表达式，例如<code>++x, x = 1, cout &lt;&lt; &#39; &#39;</code></li>
<li>字符串字面量，例如<code>&quot;hello world&quot;</code></li>
</ul>
</li>
<li><p>在函数调用时，左值可以绑定到左值引用的参数，例如<code>T&amp;</code>。一个常量只能绑定到常左值引用，例如<code>const T&amp;</code></p>
</li>
<li><p>反之，纯右值 prvalue 是没有标识符，不可以取地址的表达式，一般也称之为 临时对象。最常见的情况有：</p>
<ul>
<li>返回非引用类型的表达式，例如<code>x++</code>, <code>x+1</code>, <code>make_shared&lt;int&gt;(42)</code></li>
<li>除字符串字面量之外的字面量，例如<code>42</code>, <code>true</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>在C++11之前，右值可以绑定到常左值引用(const lvalue reference)的参数，例如<code>const T&amp;</code>，但不可以绑定到非常左值引用(non-const lvalue reference)，例如<code>T&amp;</code></p>
</li>
<li><p>从C++11开始，C++语言里多了一种引用类型 –  右值引用。右值引用的形式是<code>T&amp;&amp;</code>，比左值引用多了一个<code>&amp;</code>符号。跟左值引用一样，我们可以使用 const 和 volatile 来修饰，但最常见的情况是，我们不会用 const 和 volatile 来修饰右值。</p>
</li>
<li><p>引入一种额外的引用类型当然增加了语言的复杂性，但也带来了很多优化的可能。</p>
</li>
<li><p>由于C++有重载，我们就可以根据不同的引用类型，来选择不同的重载函数，来完成不同的行为。</p>
</li>
<li><p>对于指针，我们通常使用值传递，并不关心它是左值还是右值</p>
</li>
<li><p><code>std::move(ptr)</code>，它的作用是把一个左值引用强制转换成一个右值引用，而并不改变其内容。从实用的角度，在这里<code>std::move(ptr1)</code>等价于<code>static_cast&lt;smart_ptr&lt;shape&gt;&amp;&amp;&gt;(ptr1)</code>。因此，<code>std::move(ptr1)</code>的结果是指向ptr1的一个右值引用，这样构造ptr2时就会选择上面第二个重载。</p>
</li>
<li><p>我们可以把<code>std::move(ptr1)</code>看作是一个有名字的右值。为了跟无名的纯右值prvalue相区别，C++里目前就把这种表达式叫做xvalue。跟左值lvalue不同，xvalue仍然是不能取地址的–这点上，xvalue和prvalue相同。所以，xvalue和prvalue都被归为右值rvalue。</p>
</li>
</ul>
<hr>
<ul>
<li>另外，需要注意的是：值类别(value category) 和 值类型(value type)， 是两个看似相似，却毫不相干的术语。<ul>
<li>前者指的是上面这些左值，右值相关的概念</li>
<li>后者则是与引用类型(reference type)相对而言，表明一个变量是代表实际数值，还是引用另外一个数值。</li>
</ul>
</li>
<li>在C++里，所有的原生类型，枚举，结构，联合，类都代表值类型，只有引用<code>&amp;</code>和指针<code>*</code>才是引用类型。（在Java里，数字等原生类型是值类型，类则属于引用类型。在Python里，一切类型都是引用类型。）</li>
</ul>
<h3 id="1-2-生命周期和表达式类型"><a href="#1-2-生命周期和表达式类型" class="headerlink" title="1.2 生命周期和表达式类型"></a>1.2 生命周期和表达式类型</h3><ul>
<li><p>一个变量的生命周期在超出作用域时结束。如果一个变量代表一个对象，当然这个对象的生命周期也在那时结束。</p>
</li>
<li><p>那么临时对象(prvalue)呢？</p>
</li>
<li><p>在这儿，C++的规则是：</p>
<ul>
<li>一个临时对象会在包含这个临时对象的完整表达式估值完成后，按生成顺序的逆序被销毁，除非有生命周期延长发生。</li>
</ul>
</li>
<li><p>临时对象最后生成，最先析构</p>
</li>
<li><p>为了方便对临时对象的使用，C++对临时对象有特殊的生命周期延长规则，这条规则是：</p>
<ul>
<li>如果一个prvalue被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长</li>
</ul>
</li>
</ul>
<h3 id="1-3-移动的意义"><a href="#1-3-移动的意义" class="headerlink" title="1.3 移动的意义"></a>1.3 移动的意义</h3><ul>
<li><p>上面谈了一些语法知识。就跟学外语的语法一样，这些内容是比较枯燥的。虽然这些知识有时有用，但往往要回过头来看的时候才觉得。初学之时，更重要的是理解为什么，和熟练掌握基本的用法。</p>
</li>
<li><p>对于smart_ptr，我们使用右值引用的目的是实现移动，而实现移动的意义是减少运行的开销：在引用计数指针的场景下，这个开销并不大。</p>
</li>
<li><p>移动构造和拷贝构造的差异仅在于：</p>
<ul>
<li>少了一次<code>other.shared_count_-&gt;add_count()</code>的调用</li>
<li>被移动的指针被清空，因而析构时也少了一次<code>shared_count_-&gt;reduce_count()</code>的调用</li>
</ul>
</li>
<li><p>在使用容器类的情况下，移动更有意义。</p>
</li>
<li><p><code>string result = string(&quot;Hello, &quot;) + name + &quot;.&quot;;</code></p>
<ul>
<li>在C++11之前的年代里，这种写法是绝对不推荐的。因为它会引入很多额外的开销</li>
<li>既然C++是一门追求性能的语言，一个合格的C++程序员会写：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string result = &quot;Hello, &quot;;</span><br><span class="line">result += name;</span><br><span class="line">result += &quot;.&quot;;</span><br></pre></td></tr></table></figure></li>
<li>这样的话，只会调用构造函数一次和<code>string::operator+=</code>两次，没有任何临时对象需要生成和析构，所有的字符串都只复制了一次。</li>
<li>但是，从C++11开始，这就不再是必须的。同样上面那个单行的语句，性能上，所有的字符串只复制了一次；虽然比啰嗦的写法仍然要增加临时对象的构造和析构，但由于这些操作不牵涉到额外的内存分配和释放，是相当廉价的。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>此外，很关键的额一点是，C++里的对象缺省都是值语义。在下面这样的代码里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  B b_;</span><br><span class="line">  C c_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>从实际内存布局的角度，很多语言：例如Java和Python，会在A对象里放B和C的指针（虽然这些语言里本身没有指针的概念）。而C++则会直接把B和C对象放在A的内存空间里。</p>
</li>
<li><p>这种行为既是优点也是缺点：</p>
<ul>
<li>优点：是因为它保证了内存访问的局域性，而局域型在现在处理器架构上是聚堆具有性能优势的</li>
<li>缺点：是因为复制对象的开销大大增加，在Java类语言里复制的是指针，在C++里是完整的对象。这就是为什么C++需要移动语义这一优化，而Java类语言里则根本不需要这个概念。</li>
</ul>
</li>
<li><p>一句话总结：</p>
<ul>
<li>移动语义使得在C++里返回大对象（如容器）的函数和运算符称为现实，因而可以提高代码的简洁性和可读性，提高程序员的生产率。</li>
<li>所有的现代C++的标准容器都针对移动进行了优化。</li>
</ul>
</li>
</ul>
<h3 id="1-4-如何实现移动"><a href="#1-4-如何实现移动" class="headerlink" title="1.4 如何实现移动"></a>1.4 如何实现移动</h3><ul>
<li>要让你设计的对象支持移动的话，通常需要下面几步：<ul>
<li>你的对象应该有分开的拷贝构造和移动构造函数（除非你只打算支持移动，不支持拷贝，例如unique_ptr）</li>
<li>你的对象应该有swap成员函数，支持和另外一个对象快速交换成员</li>
<li>在你的对象的名空间下，应当有一个全局的swap函数，调用成员函数swap来实现交换。支持这种用法会方便别人（包括你自己在将来）在其他对象里包含你的对象，并快速实现它们的swap函数</li>
<li>实现通用的<code>operator=</code></li>
<li>上面各个函数如果不抛异常的化，应当标为<code>noexcept</code>。这对移动构造函数尤为重要。</li>
</ul>
</li>
</ul>
<h3 id="1-5-不要返回本地变量的引用"><a href="#1-5-不要返回本地变量的引用" class="headerlink" title="1.5 不要返回本地变量的引用"></a>1.5 不要返回本地变量的引用</h3><ul>
<li><p>有一种常见的C++编程错误，是在函数里返回一个本地对象的引用。由于在函数结束时本地对象即被销毁，返回一个指向本地对象的引用属于未定义行为。理论上来说，程序出现任何奇怪的行为都是正常的。</p>
</li>
<li><p>在C++11之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化(named return value optimization, 或NRVO)能把对象直接构造到调用者的栈上。</p>
</li>
<li><p>从C++11开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用<code>std::move</code>进行干预：使用<code>std::move</code>对于移动行为没有帮助，反而会影响返回值优化</p>
</li>
</ul>
<h3 id="1-6-引用坍缩和完美转发"><a href="#1-6-引用坍缩和完美转发" class="headerlink" title="1.6 引用坍缩和完美转发"></a>1.6 引用坍缩和完美转发</h3><ul>
<li><p>引用坍缩（又称 引用折叠）。这个概念在泛型编程中是一定会碰到的</p>
</li>
<li><p>对于一个实际的类型T，它的左值引用是<code>T&amp;</code>，右值引用是<code>T&amp;&amp;</code>，那么</p>
<ul>
<li>是不是看到<code>T&amp;</code>，就一定是一个左值引用？</li>
<li>是不是看到<code>T&amp;&amp;</code>，就一定是一个右值引用？</li>
</ul>
</li>
<li><p>对于前者的回答为：是；对于后者的回答为：否</p>
</li>
<li><p>关键在于，在有模板的代码里，对于类型参数的推到结果可能是引用。我们可以略过一些繁复的语法规则，要点是：</p>
<ul>
<li>对于<code>template &lt;typename T&gt; foo(T&amp;&amp;)</code>这样的代码，如果传递过去的参数是左值，T的推到结果是左值引用；如果传递过去的参数是右值，T的推到结果是参数的类型本身</li>
<li>如果T是左值引用，那T&amp;&amp;的结果仍然是左值引用：即<code>type&amp; &amp;&amp;</code>坍缩成了<code>type&amp;</code></li>
<li>如果T是一个实际类型，那<code>T&amp;&amp;</code>的结果自然就是一个右值引用</li>
</ul>
</li>
<li><p>我们之前提到过，右值引用变量仍然会匹配到左值引用上去</p>
</li>
<li><p>事实上，很多标准库里的函数，连目标的参数类型都不知道，但我们仍然需要能够保持参数的值类别：左值的仍然是左值，右值的仍然是右值。</p>
</li>
<li><p>这个功能在C++标准库中已经提供了，叫<code>std::forward</code>。它和<code>std::move</code>一样都是利用引用坍缩机制来实现。</p>
</li>
<li><p>此处，我们不介绍其实现细节，而是重点展示其用法。我们可以把我们的两个bar函数简化成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void var(T&amp;&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">  foo(std::forward&lt;T&gt;(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于下面这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">circle temp;</span><br><span class="line">bar(temp);</span><br><span class="line">bar(circle());</span><br></pre></td></tr></table></figure></li>
<li><p>现在的输出是：</p>
<ul>
<li><code>foo(const shape&amp;)</code></li>
<li><code>foo(shape&amp;&amp;)</code></li>
</ul>
</li>
<li><p>因为在T是模板参数时，<code>T&amp;&amp;</code>的作用主要是保持值类别进行转换，它有个名字就叫做 转发引用(forwarding reference)。因为既可以是左值引用，也可以是右值引用，它也曾经被称为 万能引用(universal reference)</p>
</li>
</ul>
<h3 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h3><ul>
<li>介绍了C++里的值类别，重点介绍了临时变量，右值引用，移动语义和实际的编程用法</li>
<li>由于这是C++11里的重点功能，对于其基本用法需要牢牢掌握</li>
</ul>
<h2 id="容器汇编一：比较简单的若干容器"><a href="#容器汇编一：比较简单的若干容器" class="headerlink" title="容器汇编一：比较简单的若干容器"></a>容器汇编一：比较简单的若干容器</h2><ul>
<li>对于容器，学习上的一个麻烦点是你无法直接输出容器的内容<ul>
<li>如果定义了一个<code>vector&lt;int&gt; v</code>，是没有办法简单输出v的内容的</li>
</ul>
</li>
<li>我们需要一个更好用的工具。在此，我向你大力推荐 <code>xeus-cling</code>。它的便利性无与伦比——你可以直接在浏览器里以交互的方式运行代码，不需要本机安装任何编译器</li>
</ul>
<h3 id="1-1-string"><a href="#1-1-string" class="headerlink" title="1.1 string"></a>1.1 string</h3><ul>
<li><p>string 一般并不被认为是一个 C++ 的容器。但鉴于其和容器有很多共同点，我们先拿 string 类来开说</p>
</li>
<li><p>string 是模板 basic_string 对于 char 类型的特化，可以认为是一个只存放字符 char 类型数据的容器。“真正”的容器类与 string 的最大不同点是里面可以存放任意类型的对象。</p>
</li>
<li><p>跟其他大部分容器一样， string 具有下列成员函数：</p>
<ul>
<li>begin 可以得到对象起始点</li>
<li>end 可以得到对象的结束点</li>
<li>empty 可以得到容器是否为空</li>
<li>size 可以得到容器的大小</li>
<li>swap 可以和另外一个容器交换其内容</li>
</ul>
</li>
<li><p>对于不那么熟悉容器的人，需要知道 C++ 的 begin 和 end 是半开半闭区间：</p>
<ul>
<li>在容器非空时，begin 指向第一个元素，而 end 指向最后一个元素后面的位置</li>
<li>在容器为空时，begin 等于 end。</li>
</ul>
</li>
<li><p>在 string 的情况下，由于考虑到和 C 字符串的兼容，end 指向代表字符串结尾的 \0 字符。</p>
</li>
<li><p>上面就几乎是所有容器的共同点了。也就是说：</p>
<ul>
<li>容器都有开始和结束点</li>
<li>容器会记录其状态是否非空</li>
<li>容器有大小</li>
<li>容器支持交换</li>
</ul>
</li>
<li><p>当然，这只是容器的“共同点”而已。每个容器都有其特殊的用途。</p>
</li>
<li><p>下面你会看到，不管是内存布局，还是成员函数，string 和 vector 是非常相似的。</p>
</li>
<li><p>string 当然是为了存放字符串。和简单的 C 字符串不同：</p>
<ul>
<li>string 负责自动维护字符串的生命周期</li>
<li>string 支持字符串的拼接操作（如之前说过的 + 和 +&#x3D;）</li>
<li>string 支持字符串的查找操作（如 find 和 rfind）</li>
<li>string 支持从 istream 安全地读入字符串（使用 getline）</li>
<li>string 支持给期待 const char* 的接口传递字符串内容（使用 c_str）</li>
<li>string 支持到数字的互转（stoi 系列函数和 to_string）</li>
<li>等等</li>
</ul>
</li>
<li><p>推荐你在代码中尽量使用 string 来管理字符串</p>
</li>
<li><p>不过，对于对外暴露的接口，情况有一点复杂。我一般不建议在接口中使用 const string&amp;，除非确知调用者已经持有 string：</p>
<ul>
<li>如果函数里不对字符串做复杂处理的话，使用 const char* 可以避免在调用者只有 C 字符串时编译器自动构造 string，这种额外的构造和析构代价并不低</li>
</ul>
</li>
<li><p>反过来，如果实现较为复杂、希望使用 string 的成员函数的话，那就应该考虑下面的策略：</p>
<ul>
<li>如果不修改字符串的内容，使用 const string&amp; 或 C++17 的 string_view 作为参数类型。后者是最理想的情况，因为即使在只有 C 字符串的情况，也不会引发不必要的内存复制。</li>
<li>如果需要在函数内修改字符串内容、但不影响调用者的该字符串，使用 string 作为参数类型（自动拷贝）。</li>
<li>如果需要改变调用者的字符串内容，使用 string&amp; 作为参数类型（通常不推荐）</li>
</ul>
</li>
</ul>
<h3 id="1-2-vector"><a href="#1-2-vector" class="headerlink" title="1.2 vector"></a>1.2 vector</h3><ul>
<li><p>vector 应该是最常用的容器了。它的名字“向量”来源于数学术语，但在实际应用中，我们把它当成动态数组更为合适。它基本相当于 Java 的 ArrayList 和 Python 的 list。</p>
</li>
<li><p>和 string 相似，vector 的成员在内存里连续存放，同时 begin、end、front、back 成员函数指向的位置也和 string 一样</p>
</li>
<li><p>除了容器类的共同点，vector 允许下面的操作（不完全列表）：</p>
<ul>
<li>可以使用中括号的下标来访问其成员（同 string）</li>
<li>可以使用 data 来获得指向其内容的裸指针（同 string）</li>
<li>可以使用 capacity 来获得当前分配的存储空间的大小，以元素数量计（同 string）</li>
<li>可以使用 reserve 来改变所需的存储空间的大小，成功后 capacity() 会改变（同 string）</li>
<li>可以使用 resize 来改变其大小，成功后 size() 会改变（同 string）</li>
<li>可以使用 pop_back 来删除最后一个元素（同 string）</li>
<li>可以使用 push_back 在尾部插入一个元素（同 string）</li>
<li>可以使用 insert 在指定位置前插入一个元素（同 string）</li>
<li>可以使用 erase 在指定位置删除一个元素（同 string）</li>
<li>可以使用 emplace 在指定位置构造一个元素</li>
<li>可以使用 emplace_back 在尾部新构造一个元素</li>
</ul>
</li>
<li><p>大家可以留意一下 push_… 和 pop_… 成员函数。它们存在时，说明容器对指定位置的删除和插入性能较高。</p>
</li>
<li><p>vector 适合在尾部操作，这是它的内存布局决定的。只有在尾部插入和删除时，其他元素才会不需要移动，除非内存空间不足导致需要重新分配内存空间。</p>
</li>
<li><p>当 push_back、insert、reserve、resize 等函数导致内存重分配时，或当 insert、erase 导致元素位置移动时，vector 会试图把元素“移动”到新的内存区域。vector 通常保证强异常安全性，如果元素类型没有提供一个保证不抛异常的移动构造函数，vector 通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为 noexcept，或只在容器中放置对象的智能指针。这就是为什么我之前需要在 smart_ptr 的实现中标上 noexcept 的原因。</p>
</li>
<li><p>C++11 开始提供的 emplace… 系列函数是为了提升容器的性能而设计的。你可以试试把 v1.emplace_back() 改成 v1.push_back(Obj1())。对于 vector 里的内容，结果是一样的；但使用 push_back 会额外生成临时对象，多一次（移动或拷贝）构造和析构。如果是移动的情况，那会有小幅性能损失；如果对象没有实现移动的话，那性能差异就可能比较大了。</p>
</li>
<li><p>现代处理器的体系架构使得对连续内存访问的速度比不连续的内存要快得多。因而，vector 的连续内存使用是它的一大优势所在。当你不知道该用什么容器时，缺省就使用 vector 吧。</p>
</li>
<li><p>vector 的一个主要缺陷是大小增长时导致的元素移动。如果可能，尽早使用 reserve 函数为 vector 保留所需的内存，这在 vector 预期会增长很大时能带来很大的性能提升。</p>
</li>
</ul>
<h3 id="1-3-deque"><a href="#1-3-deque" class="headerlink" title="1.3 deque"></a>1.3 deque</h3><ul>
<li><p>deque 的意思是 double-ended queue，双端队列。它主要是用来满足下面这个需求：</p>
<ul>
<li>容器不仅可以从尾部自由地添加和删除元素，也可以从头部自由地添加和删除。</li>
</ul>
</li>
<li><p>deque 的接口和 vector 相比，有如下的区别：</p>
<ul>
<li>deque 提供 push_front、emplace_front 和 pop_front 成员函数。</li>
<li>deque 不提供 data、capacity 和 reserve 成员函数。</li>
</ul>
</li>
<li><p>deque 的内存布局，可以看到：</p>
<ul>
<li>如果只从头、尾两个位置对 deque 进行增删操作的话，容器里的对象永远不需要移动。</li>
<li>容器里的元素只是部分连续的（因而没法提供 data 成员函数）。</li>
<li>由于元素的存储大部分仍然连续，它的遍历性能是比较高的。</li>
<li>由于每一段存储大小相等，deque 支持使用下标访问容器元素，大致相当于 <code>index[i / chunk_size][i % chunk_size]</code>，也保持高效。</li>
</ul>
</li>
<li><p>如果你需要一个经常在头尾增删元素的容器，那 deque 会是个合适的选择。</p>
</li>
</ul>
<h3 id="1-4-list"><a href="#1-4-list" class="headerlink" title="1.4 list"></a>1.4 list</h3><ul>
<li><p>list 在 C++ 里代表双向链表。和 vector 相比，它优化了在容器中间的插入和删除：</p>
<ul>
<li>list 提供高效的、O(1) 复杂度的任意位置的插入和删除操作。</li>
<li>list 不提供使用下标访问其元素。</li>
<li>list 提供 push_front、emplace_front 和 pop_front 成员函数（和 deque 相同）。</li>
<li>list 不提供 data、capacity 和 reserve 成员函数（和 deque 相同）。</li>
</ul>
</li>
<li><p>需要指出的是，虽然 list 提供了任意位置插入新元素的灵活性，但由于每个元素的内存空间都是单独分配、不连续，它的遍历性能比 vector 和 deque 都要低</p>
</li>
<li><p>这在很大程度上抵消了它在插入和删除操作时不需要移动元素的理论性能优势。如果你不太需要遍历容器、又需要在中间频繁插入或删除元素，可以考虑使用 list。</p>
</li>
<li><p>另外一个需要注意的地方是，因为某些标准算法在 list 上会导致问题，list 提供了成员函数作为替代，包括下面几个：</p>
<ul>
<li>merge</li>
<li>remove</li>
<li>remove_if</li>
<li>reverse</li>
<li>sort</li>
<li>unique</li>
</ul>
</li>
</ul>
<h3 id="1-5-forward-list"><a href="#1-5-forward-list" class="headerlink" title="1.5 forward_list"></a>1.5 forward_list</h3><ul>
<li><p>既然 list 是双向链表，那么 C++ 里有没有单向链表呢？答案是肯定的。从 C++11 开始，前向列表 forward_list 成了标准的一部分。</p>
</li>
<li><p>大部分 C++ 容器都支持 insert 成员函数，语义是从指定的位置之前插入一个元素。对于 forward_list，这不是一件容易做到的事情（想一想，为什么？）。标准库提供了一个 insert_after 作为替代。此外，它跟 list 相比还缺了下面这些成员函数：</p>
<ul>
<li>back</li>
<li>size</li>
<li>push_back</li>
<li>emplace_back</li>
<li>pop_back</li>
</ul>
</li>
<li><p>为什么会需要这么一个阉割版的 list 呢？</p>
</li>
<li><p>原因是，在元素大小较小的情况下，forward_list 能节约的内存是非常可观的；在列表不长的情况下，不能反向查找也不是个大问题。提高内存利用率，往往就能提高程序性能，更不用说在内存可能不足时的情况了。</p>
</li>
<li><p>目前你只需要知道这个东西的存在就可以了。如果你觉得不需要用到它的话，也许你真的不需要它。</p>
</li>
</ul>
<h3 id="1-6-queue"><a href="#1-6-queue" class="headerlink" title="1.6 queue"></a>1.6 queue</h3><ul>
<li><p>在结束本讲之前，我们再快速讲两个类容器。它们的特别点在于它们都不是完整的实现，而是依赖于某个现有的容器，因而被称为容器适配器（container adaptor）。</p>
</li>
<li><p>我们先看一下队列 queue，先进先出（FIFO）的数据结构。</p>
</li>
<li><p>queue 缺省用 deque 来实现。它的接口跟 deque 比，有如下改变：</p>
<ul>
<li>不能按下标访问元素</li>
<li>没有 begin、end 成员函数</li>
<li>用 emplace 替代了 emplace_back，用 push 替代了 push_back，用 pop 替代了 pop_front；没有其他的 push_…、pop_…、emplace…、insert、erase 函数</li>
</ul>
</li>
<li><p>它的实际内存布局当然是随底层的容器而定的。</p>
</li>
</ul>
<h3 id="1-7-stack"><a href="#1-7-stack" class="headerlink" title="1.7 stack"></a>1.7 stack</h3><ul>
<li><p>类似地，栈 stack 是后进先出（LIFO）的数据结构。</p>
</li>
<li><p>stack 缺省也是用 deque 来实现，但它的概念和 vector 更相似。它的接口跟 vector 比，有如下改变：</p>
<ul>
<li>不能按下标访问元素</li>
<li>没有 begin、end 成员函数</li>
<li>back 成了 top，没有 front</li>
<li>用 emplace 替代了 emplace_back，用 push 替代了 push_back，用 pop 替代了 pop_back；没有其他的 push_…、pop_…、emplace…、insert、erase 函数</li>
</ul>
</li>
<li><p>一般图形表示法会把 stack 表示成一个竖起的 vector：</p>
</li>
<li><p>这里有一个小细节需要注意。stack 跟我们前面讨论内存管理时的栈有一个区别：</p>
<ul>
<li>在这里下面是低地址，向上则地址增大；而我们讨论内存管理时，高地址在下面，向上则地址减小，方向正好相反</li>
</ul>
</li>
<li><p>提这一点，是希望你在有需要检查栈结构时不会因此而发生混淆；在使用 stack 时，这个区别通常无关紧要。</p>
</li>
</ul>
<h2 id="容器汇编二：需要函数对象的容器"><a href="#容器汇编二：需要函数对象的容器" class="headerlink" title="容器汇编二：需要函数对象的容器"></a>容器汇编二：需要函数对象的容器</h2><h3 id="1-1-函数对象及其特化"><a href="#1-1-函数对象及其特化" class="headerlink" title="1.1 函数对象及其特化"></a>1.1 函数对象及其特化</h3><ul>
<li><p>在讲容器之前，我们需要首先来讨论一下两个重要的函数对象，less 和 hash。</p>
</li>
<li><p>我们先看一下 less，小于关系。在标准库里，通用的 less 大致是这样定义的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">struct less</span><br><span class="line">  : binary_function&lt;T, T, bool&gt; &#123;</span><br><span class="line">  bool operator()(const T&amp; x,</span><br><span class="line">                  const T&amp; y) const</span><br><span class="line">  &#123;</span><br><span class="line">    return x &lt; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>也就是说，less 是一个函数对象，并且是个二元函数，执行对任意类型的值的比较，返回布尔类型。</p>
</li>
<li><p>作为函数对象，它定义了函数调用运算符（operator()），并且缺省行为是对指定类型的对象进行 &lt; 的比较操作。</p>
</li>
<li><p>有点平淡无奇，是吧？原因是因为这个缺省实现在大部分情况下已经够用，我们不太需要去碰它。在需要大小比较的场合，C++ 通常默认会使用 less，包括我们今天会讲到的若干容器和排序算法 sort。如果我们需要产生相反的顺序的话，则可以使用 greater，大于关系。</p>
</li>
<li><p>计算哈希值的函数对象 hash 就不一样了。它的目的是把一个某种类型的值转换成一个无符号整数哈希值，类型为 size_t。它没有一个可用的默认实现。对于常用的类型，系统提供了需要的特化</p>
</li>
<li><p>这当然是一个极其简单的例子。更复杂的类型，如指针或者 string 的特化，都会更复杂。要点是，对于每个类，类的作者都可以提供 hash 的特化，使得对于不同的对象值，函数调用运算符都能得到尽可能均匀分布的不同数值。</p>
</li>
<li><p>对于容器也是如此，函数对象的类型确定了容器的行为。</p>
</li>
</ul>
<h3 id="1-2-priority-queue"><a href="#1-2-priority-queue" class="headerlink" title="1.2 priority_queue"></a>1.2 priority_queue</h3><ul>
<li>priority_queue 也是一个容器适配器。上一讲没有和其他容器适配器一起讲的原因就在于它用到了比较函数对象（默认是 less）。</li>
<li>和 stack 相似，支持 push、pop、top 等有限的操作，但容器内的顺序既不是后进先出，也不是先进先出，而是（部分）排序的结果。</li>
<li>在使用缺省的 less 作为其 Compare 模板参数时，最大的数值会出现在容器的“顶部”。如果需要最小的数值出现在容器顶部，则可以传递 greater 作为其 Compare 模板参数。</li>
</ul>
<h3 id="1-3-关联容器"><a href="#1-3-关联容器" class="headerlink" title="1.3 关联容器"></a>1.3 关联容器</h3><ul>
<li><p>关联容器有 set（集合）、map（映射）、multiset（多重集）和 multimap（多重映射）。</p>
</li>
<li><p>跳出 C++ 的语境，map（映射）的更常见的名字是关联数组和字典，而在 JSON 里直接被称为对象（object）。</p>
</li>
<li><p>在 C++ 外这些容器常常是无序的；在 C++ 里关联容器则被认为是有序的。</p>
</li>
<li><p>关联容器是一种有序的容器。名字带“multi”的允许键重复，不带的不允许键重复。set 和 multiset 只能用来存放键，而 map 和 multimap 则存放一个个键值对</p>
</li>
<li><p>与序列容器相比，关联容器没有前、后的概念及相关的成员函数，但同样提供 insert、emplace 等成员函数。此外，关联容器都有 find、lower_bound、upper_bound 等查找函数，结果是一个迭代器：</p>
<ul>
<li>find(k) 可以找到任何一个等价于查找键 k 的元素（!(x &lt; k || k &lt; x)）</li>
<li>lower_bound(k) 找到第一个不小于查找键 k 的元素（!(x &lt; k)）</li>
<li>upper_bound(k) 找到第一个大于查找键 k 的元素（k &lt; x）</li>
</ul>
</li>
<li><p>如果你需要在 multimap 里精确查找满足某个键的区间的话，建议使用 equal_range，可以一次性取得上下界（半开半闭）</p>
</li>
<li><p>如果在声明关联容器时没有提供比较类型的参数，缺省使用 less 来进行排序。如果键的类型提供了比较算符 &lt; 的重载，我们不需要做任何额外的工作。否则，我们就需要对键类型进行 less 的特化，或者提供一个其他的函数对象类型。</p>
</li>
<li><p>对于自定义类型，我推荐尽量使用标准的 less 实现，通过重载 &lt;（及其他标准比较运算符）对该类型的对象进行排序。存储在关联容器中的键一般应满足严格弱序关系（strict weak ordering；）即：</p>
<ul>
<li>对于任何该类型的对象 x：!(x &lt; x)（非自反）</li>
<li>对于任何该类型的对象 x 和 y：如果 x &lt; y，则 !(y &lt; x)（非对称）</li>
<li>对于任何该类型的对象 x、y 和 z：如果 x &lt; y 并且 y &lt; z，则 x &lt; z（传递性）</li>
<li>对于任何该类型的对象 x、y 和 z：如果 x 和 y 不可比（!(x &lt; y) 并且 !(y &lt; x)）并且 y 和 z 不可比，则 x 和 z 不可比（不可比的传递性）</li>
</ul>
</li>
<li><p>大部分情况下，类型是可以满足这些条件的，不过：</p>
<ul>
<li>如果类型没有一般意义上的大小关系（如复数），我们一定要别扭地定义一个大小关系吗？</li>
<li>通过比较来进行查找、插入和删除，复杂度为对数 O(log(n))，有没有达到更好的性能的方法？</li>
</ul>
</li>
</ul>
<h3 id="1-4-无序关联容器"><a href="#1-4-无序关联容器" class="headerlink" title="1.4 无序关联容器"></a>1.4 无序关联容器</h3><ul>
<li><p>从 C++11 开始，每一个关联容器都有一个对应的无序关联容器，它们是：</p>
<ul>
<li>unordered_set</li>
<li>unordered_map</li>
<li>unordered_multiset</li>
<li>unordered_multimap</li>
</ul>
</li>
<li><p>这些容器和关联容器非常相似，主要的区别就在于它们是“无序”的。这些容器不要求提供一个排序的函数对象，而要求一个可以计算哈希值的函数对象。</p>
</li>
<li><p>你当然可以在声明容器对象时手动提供这样一个函数对象类型，但更常见的情况是，我们使用标准的 hash 函数对象及其特化。</p>
</li>
<li><p>正常情况下，向 std 名空间添加声明或定义是禁止的，属于未定义行为。</p>
</li>
<li><p>从实际的工程角度，无序关联容器的主要优点在于其性能。</p>
<ul>
<li>关联容器和 priority_queue 的插入和删除操作，以及关联容器的查找操作，其复杂度都是 O(log(n))，而无序关联容器的实现使用哈希表 ，可以达到平均 O(1)！</li>
<li>但这取决于我们是否使用了一个好的哈希函数：在哈希函数选择不当的情况下，无序关联容器的插入、删除、查找性能可能成为最差情况的 O(n)，那就比关联容器糟糕得多了。</li>
</ul>
</li>
</ul>
<h3 id="1-5-array"><a href="#1-5-array" class="headerlink" title="1.5 array"></a>1.5 array</h3><ul>
<li><p>我们讲的最后一个容器是 C 数组的替代品。C 数组在 C++ 里继续存在，主要是为了保留和 C 的向后兼容性。C 数组本身和 C++ 的容器相差是非常大的：</p>
<ul>
<li>C 数组没有 begin 和 end 成员函数（虽然可以使用全局的 begin 和 end 函数）</li>
<li>C 数组没有 size 成员函数（得用一些模板技巧来获取其长度）</li>
<li>C 数组作为参数有退化行为，传递给另外一个函数后那个函数不再能获得 C 数组的长度和结束位置</li>
</ul>
</li>
<li><p>在 C 的年代，大家有时候会定义这样一个宏来获得数组的长度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ARRAY_LEN(a) \</span><br><span class="line">  (sizeof(a) / sizeof((a)[0]))</span><br></pre></td></tr></table></figure></li>
<li><p>如果在一个函数内部对数组参数使用这个宏，结果肯定是错的。</p>
</li>
<li><p>C++17 直接提供了一个 size 方法，可以用于提供数组长度，并且在数组退化成指针的情况下会直接失败：</p>
</li>
<li><p>此外，C 数组也没有良好的复制行为。你无法用 C 数组作为 map 或 unordered_map 的键类型</p>
</li>
</ul>
<hr>
<ul>
<li>如果不用 C 数组的话，我们该用什么来替代呢？我们有三个可以考虑的选项：<ul>
<li>如果数组较大的话，应该考虑 vector。vector 有最大的灵活性和不错的性能。</li>
<li>对于字符串数组，当然应该考虑 string。</li>
<li>如果数组大小固定（C 的数组在 C++ 里本来就是大小固定的）并且较小的话，应该考虑 array。array 保留了 C 数组在栈上分配的特点，同时，提供了 begin、end、size 等通用成员函数。</li>
</ul>
</li>
<li>array 可以避免 C 数组的种种怪异行径</li>
</ul>
<h2 id="异常：用还是不用，这是个问题"><a href="#异常：用还是不用，这是个问题" class="headerlink" title="异常：用还是不用，这是个问题"></a>异常：用还是不用，这是个问题</h2><ul>
<li>首先，开宗明义，如果你不知道到底该不该用异常的话，那答案就是该用。如果你需要避免使用异常，原因必须是你有明确的需要避免使用异常的理由。</li>
</ul>
<h3 id="1-1-没有异常的世界"><a href="#1-1-没有异常的世界" class="headerlink" title="1.1 没有异常的世界"></a>1.1 没有异常的世界</h3><ul>
<li>我们先来看看没有异常的世界是什么样子的。最典型的情况就是 C 了。</li>
<li>我们有大量需要判断错误的代码，零散分布在代码各处。可这是 C 啊。我们用 C++、不用异常可以吗？</li>
<li>当然可以，但你会发现结果好不了多少。毕竟，C++ 的构造函数是不能返回错误码的，所以你根本不能用构造函数来做可能出错的事情。你不得不定义一个只能清零的构造函数，再使用一个 init 函数来做真正的构造操作。C++ 虽然支持运算符重载，可你也不能使用，因为你没法返回一个新矩阵……</li>
<li>我上面还只展示了单层的函数调用。事实上，如果出错位置离处理错误的位置相差很远的话，每一层的函数调用里都得有判断错误码的代码，这就既对写代码的人提出了严格要求，也对读代码的人造成了视觉上的干扰……</li>
</ul>
<h3 id="1-2-使用异常"><a href="#1-2-使用异常" class="headerlink" title="1.2 使用异常"></a>1.2 使用异常</h3><ul>
<li><p>如果使用异常的话，我们就可以在构造函数里做真正的初始化工作了。</p>
</li>
<li><p>假设我们的矩阵类有下列的数据成员：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class matrix &#123;</span><br><span class="line">  …</span><br><span class="line">private:</span><br><span class="line">  float* data_;</span><br><span class="line">  size_t nrows_;</span><br><span class="line">  size_t ncols_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数我们可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">matrix::matrix(size_t nrows,</span><br><span class="line">               size_t ncols)</span><br><span class="line">&#123;</span><br><span class="line">  data_  = new float[nrows * ncols];</span><br><span class="line">  nrows_ = nrows;</span><br><span class="line">  ncols_ = ncols;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>析构非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix::~matrix()</span><br><span class="line">&#123;</span><br><span class="line">  delete[] data_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>乘法函数可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class matrix &#123;</span><br><span class="line">  …</span><br><span class="line">  friend matrix</span><br><span class="line">  operator*(const matrix&amp;,</span><br><span class="line">            const matrix&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">matrix operator*(const matrix&amp; lhs,</span><br><span class="line">                 const matrix&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  if (lhs.ncols != rhs.nrows) &#123;</span><br><span class="line">    throw std::runtime_error(</span><br><span class="line">      &quot;matrix sizes mismatch&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  matrix result(lhs.nrows, rhs.ncols);</span><br><span class="line">  // 进行矩阵乘法运算</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用乘法的代码则更是简单：</p>
<ul>
<li><code>matrix c = a * b;</code></li>
</ul>
</li>
<li><p>你可能已经非常疑惑了：错误处理在哪儿呢？只有一个 throw，跟前面的 C 代码能等价吗？</p>
</li>
<li><p>异常处理并不意味着需要写显式的 try 和 catch。异常安全的代码，可以没有任何 try 和 catch。</p>
</li>
<li><p>如果你不确定什么是“异常安全”，我们先来温习一下概念：</p>
<ul>
<li><strong>异常安全是指当异常发生时，既不会发生资源泄漏，系统也不会处于一个不一致的状态。</strong></li>
</ul>
</li>
<li><p>我们看看可能会出现错误 &#x2F; 异常的地方：</p>
<ul>
<li>首先是内存分配。如果 new 出错，按照 C++ 的规则，一般会得到异常 bad_alloc，对象的构造也就失败了。这种情况下，在 catch 捕捉到这个异常之前，所有的栈上对象会全部被析构，资源全部被自动清理。</li>
<li>如果是矩阵的长宽不合适不能做乘法呢？我们同样会得到一个异常，这样，在使用乘法的地方，对象 c 根本不会被构造出来。</li>
<li>如果在乘法函数里内存分配失败呢？一样，result 对象根本没有构造出来，也就没有 c 对象了。还是一切正常。</li>
<li>如果 a、b 是本地变量，然后乘法失败了呢？析构函数会自动释放其空间，我们同样不会有任何资源泄漏。</li>
</ul>
</li>
<li><p>总而言之，只要我们适当地组织好代码、利用好 RAII，实现矩阵的代码和使用矩阵的代码都可以更短、更清晰。我们可以统一在外层某个地方处理异常——通常会记日志、或在界面上向用户报告错误了。</p>
</li>
</ul>
<h3 id="1-3-避免异常的风格指南？"><a href="#1-3-避免异常的风格指南？" class="headerlink" title="1.3 避免异常的风格指南？"></a>1.3 避免异常的风格指南？</h3><ul>
<li>一些游戏项目为了追求高性能，也禁用异常。这个实际上也有一定的历史原因，因为今天的主流 C++ 编译器，在异常关闭和开启时应该已经能够产生性能差不多的代码（在异常未抛出时）。</li>
<li>代价是产生的二进制文件大小的增加，因为异常产生的位置决定了需要如何做栈展开，这些数据需要存储在表里。典型情况，使用异常和不使用异常比，二进制文件大小会有约百分之十到二十的上升。LLVM 项目的编码规范里就明确指出这是不使用 RTTI 和异常的原因</li>
</ul>
<h3 id="1-4-异常的问题"><a href="#1-4-异常的问题" class="headerlink" title="1.4 异常的问题"></a>1.4 异常的问题</h3><ul>
<li><p>异常当然不是一个完美的特性，否则也不会招来这些批评和禁用了。对它的批评主要有两条：</p>
<ul>
<li>异常违反了“你不用就不需要付出代价”的 C++ 原则。只要开启了异常，即使不使用异常你编译出的二进制代码通常也会膨胀。</li>
<li>异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常。</li>
</ul>
</li>
<li><p>对于第一条，开发者没有什么可做的。事实上，这也算是 C++ 实现的一个折中了。目前的主流异常实现中，都倾向于牺牲可执行文件大小、提高主流程（happy path）的性能。只要程序不抛异常，C++ 代码的性能比起完全不做错误检查的代码，都只有几个百分点的性能损失。除了非常有限的一些场景，可执行文件大小通常不会是个问题。</p>
</li>
<li><p>第二条可以算作是一个真正有效的批评。和 Java 不同，C++ 里不会对异常规约进行编译时的检查。从 C++17 开始，C++ 甚至完全禁止了以往的动态异常规约，你不再能在函数声明里写你可能会抛出某某异常。你唯一能声明的，就是某函数不会抛出异常——noexcept、noexcept(true) 或 throw()。这也是 C++ 的运行时唯一会检查的东西了。如果一个函数声明了不会抛出异常、结果却抛出了异常，C++ 运行时会调用 std::terminate 来终止应用程序。不管是程序员的声明，还是编译器的检查，都不会告诉你哪些函数会抛出哪些异常。</p>
</li>
<li><p>当然，不声明异常是有理由的。特别是在泛型编程的代码里，几乎不可能预知会发生些什么异常。我个人对避免异常带来的问题有几点建议：</p>
<ul>
<li>写异常安全的代码，尤其在模板里。可能的话，提供强异常安全保证，在任何第三方代码发生异常的情况下，不改变对象的内容，也不产生任何资源泄漏。</li>
<li>如果你的代码可能抛出异常的话，在文档里明确声明可能发生的异常类型和发生条件。确保使用你的代码的人，能在不检查你的实现的情况下，了解需要准备处理哪些异常。</li>
<li>对于肯定不会抛出异常的代码，将其标为 noexcept。尤其是，移动构造函数、移动赋值运算符和 swap 函数一般需要保证不抛异常并标为 noexcept（析构函数通常不抛异常且自动默认为 noexcept，不需要标）。</li>
</ul>
</li>
</ul>
<h3 id="1-5-使用异常的理由"><a href="#1-5-使用异常的理由" class="headerlink" title="1.5 使用异常的理由"></a>1.5 使用异常的理由</h3><ul>
<li><p>虽然后面我们会描述到一些不使用异常、也不使用错误返回码的错误处理方式，但异常是渗透在 C++ 中的标准错误处理方式。标准库的错误处理方式就是异常。其中不仅包括运行时错误，甚至包括一些逻辑错误</p>
</li>
<li><p>比如，在说容器的时候，有一个我没提的地方是，在能使用 [] 运算符的地方，C++ 的标准容器也提供了 at 成员函数，能够在下标不存在的时候抛出异常，作为一种额外的帮助调试的手段。</p>
</li>
<li><p>C++ 的标准容器在大部分情况下提供了强异常保证，即，一旦异常发生，现场会恢复到调用函数之前的状态，容器的内容不会发生改变，也没有任何资源泄漏。前面提到过，vector 会在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数。这是因为一旦某个操作发生了异常，被移动的元素已经被破坏，处于只能析构的状态，异常安全性就不能得到保证了。</p>
</li>
<li><p>只要你使用了标准容器，不管你自己用不用异常，你都得处理标准容器可能引发的异常——至少有 bad_alloc，除非你明确知道你的目标运行环境不会产生这个异常。这对普通配置的 Linux 环境而言，倒确实是对的……这也算是 Google 这么规定的一个底气吧。</p>
</li>
<li><p>虽然对于运行时错误，开发者并没有什么选择余地；但对于代码中的逻辑错误，开发者则是可以选择不同的处理方式的：你可以使用异常，也可以使用 assert，在调试环境中报告错误并中断程序运行。由于测试通常不能覆盖所有的代码和分支，assert 在发布模式下一般被禁用，两者并不是完全的替代关系。在允许异常的情况下，使用异常可以获得在调试和发布模式下都良好、一致的效果。</p>
</li>
</ul>
<h2 id="迭代器和好用的新for循环"><a href="#迭代器和好用的新for循环" class="headerlink" title="迭代器和好用的新for循环"></a>迭代器和好用的新for循环</h2><h3 id="1-1-什么是迭代器？"><a href="#1-1-什么是迭代器？" class="headerlink" title="1.1 什么是迭代器？"></a>1.1 什么是迭代器？</h3><ul>
<li><p>迭代器是一个很通用的概念，并不是一个特定的类型。它实际上是一组对类型的要求</p>
</li>
<li><p>它的最基本要求就是从一个端点出发，下一步、下一步地到达另一个端点。按照一般的中文习惯，也许“遍历”是比“迭代”更好的用词。我们可以遍历一个字符串的字符，遍历一个文件的内容，遍历目录里的所有文件，等等。这些都可以用迭代器来表达</p>
</li>
<li><p>输入迭代器不要求对同一迭代器可以多次使用 * 运算符，也不要求可以保存迭代器来重新遍历对象，换句话说，只要求可以单次访问。如果取消这些限制、允许多次访问的话，那迭代器同时满足了前向迭代器（forward iterator）。</p>
</li>
<li><p>一个前向迭代器的类型，如果同时支持 –（前置及后置），回到前一个对象，那它就是个双向迭代器（bidirectional iterator）。也就是说，可以正向遍历，也可以反向遍历。</p>
</li>
<li><p>一个双向迭代器，如果额外支持在整数类型上的 +、-、+&#x3D;、-&#x3D;，跳跃式地移动迭代器；支持 []，数组式的下标访问；支持迭代器的大小比较（之前只要求相等比较）；那它就是个随机访问迭代器（random-access iterator）。</p>
</li>
<li><p>一个随机访问迭代器 i 和一个整数 n，在 <code>*i</code> 可解引用且 <code>i + n</code> 是合法迭代器的前提下，如果额外还满足 <code>*(addressdof(*i) + n)</code> 等价于 <code>*(i + n)</code>，即保证迭代器指向的对象在内存里是连续存放的，那它（在 C++20 里）就是个连续迭代器（contiguous iterator）。</p>
</li>
<li><p>以上这些迭代器只考虑了读取。如果一个类型像输入迭代器，但 *i 只能作为左值来写而不能读，那它就是个输出迭代器（output iterator）。</p>
</li>
<li><p>而比输入迭代器和输出迭代器更底层的概念，就是迭代器了。基本要求是：</p>
<ul>
<li>对象可以被拷贝构造、拷贝赋值和析构。</li>
<li>对象支持 * 运算符。</li>
<li>对象支持前置 ++ 运算符。</li>
</ul>
</li>
<li><p>迭代器通常是对象。但需要注意的是，指针可以满足上面所有的迭代器要求，因而也是迭代器。这应该并不让人惊讶，因为本来迭代器就是根据指针的特性，对其进行抽象的结果。事实上，vector 的迭代器，在很多实现里就直接是使用指针的。</p>
</li>
</ul>
<h3 id="1-2-常用迭代器"><a href="#1-2-常用迭代器" class="headerlink" title="1.2 常用迭代器"></a>1.2 常用迭代器</h3><ul>
<li><p>最常用的迭代器就是容器的 iterator 类型了</p>
</li>
<li><p>以我们学过的顺序容器为例，它们都定义了嵌套的 iterator 类型和 const_iterator 类型。</p>
</li>
<li><p>一般而言，iterator 可写入，const_iterator 类型不可写入，但这些迭代器都被定义为输入迭代器或其派生类型：</p>
<ul>
<li>vector::iterator 和 array::iterator 可以满足到连续迭代器。</li>
<li>deque::iterator 可以满足到随机访问迭代器（记得它的内存只有部分连续）</li>
<li>list::iterator 可以满足到双向迭代器（链表不能快速跳转）。</li>
<li>forward_list::iterator 可以满足到前向迭代器（单向链表不能反向遍历）。</li>
</ul>
</li>
<li><p>很常见的一个输出迭代器是 back_inserter 返回的类型 back_inserter_iterator 了；用它我们可以很方便地在容器的尾部进行插入操作</p>
</li>
<li><p>另外一个常见的输出迭代器是 ostream_iterator，方便我们把容器内容“拷贝”到一个输出流</p>
</li>
</ul>
<h3 id="1-3-使用输入行迭代器"><a href="#1-3-使用输入行迭代器" class="headerlink" title="1.3 使用输入行迭代器"></a>1.3 使用输入行迭代器</h3><ul>
<li><p>在此之前，我先解说一下基于范围的 for 循环这个语法。虽然这可以说是个语法糖，但它对提高代码的可读性真的非常重要。如果不用这个语法糖的话，简洁性上的优势就小多了。我们直接把这个循环改写成等价的普通 for 循环的样子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  auto&amp;&amp; r = istream_line_reader(is);</span><br><span class="line">  auto it = r.begin();</span><br><span class="line">  auto end = r.end();</span><br><span class="line">  for (; it != end; ++it) &#123;</span><br><span class="line">    const string&amp; line = *it;</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可以看到，它做的事情也不复杂，就是：</p>
<ul>
<li>获取冒号后边的范围表达式的结果，并隐式产生一个引用，在整个循环期间都有效。注意根据生命期延长规则，表达式结果如果是临时对象的话，这个对象要在循环结束后才被销毁。</li>
<li>自动生成遍历这个范围的迭代器。</li>
<li>循环内自动生成根据冒号左边的声明和 *it 来进行初始化的语句。</li>
<li>下面就是完全正常的循环体。</li>
</ul>
</li>
<li><p>生成迭代器这一步有可能是——但不一定是——调用 r 的 begin 和 end 成员函数。具体规则是：</p>
<ul>
<li>对于 C 数组（必须是没有退化为指针的情况），编译器会自动生成指向数组头尾的指针（相当于自动应用可用于数组的 std::begin 和 std::end 函数）。</li>
<li>对于有 begin 和 end 成员的对象，编译器会调用其 begin 和 end 成员函数（我们目前的情况）。</li>
<li>否则，编译器会尝试在 r 对象所在的名空间寻找可以用于 r 的 begin 和 end 函数，并调用 begin(r) 和 end(r)；找不到的话则失败报错。</li>
</ul>
</li>
</ul>
<h2 id="易用性改进一：自动类型推断和初始化"><a href="#易用性改进一：自动类型推断和初始化" class="headerlink" title="易用性改进一：自动类型推断和初始化"></a>易用性改进一：自动类型推断和初始化</h2><ul>
<li>我们主要是介绍 C++ 里好用的特性，而非让你死记规则</li>
<li>因此，这里讲到的内容，有时是一种简化的说法。对于日常使用，本讲介绍的应该能满足大部分的需求。对于复杂用法和边角情况，你可能还是需要查阅参考资料里的明细规则</li>
</ul>
<h3 id="1-1-自动类型推断"><a href="#1-1-自动类型推断" class="headerlink" title="1.1 自动类型推断"></a>1.1 自动类型推断</h3><ul>
<li><p>如果要挑选 C++11 带来的最重大改变的话，自动类型推断肯定排名前三</p>
</li>
<li><p>auto， 自动类型推断，顾名思义，就是编译器能够根据表达式的类型，自动决定变量的类型（从 C++14 开始，还有函数的返回类型），不再需要程序员手工声明</p>
</li>
<li><p>但需要说明的是，auto 并没有改变 C++ 是静态类型语言这一事实——使用 auto 的变量（或函数返回值）的类型仍然是编译时就确定了，只不过编译器能自动帮你填充而已</p>
</li>
<li><p>auto 实际使用的规则类似于函数模板参数的推导规则。当你写了一个含 auto 的表达式时，相当于把 auto 替换为模板参数的结果。举具体的例子：</p>
<ul>
<li>auto a &#x3D; expr; 意味着用 expr 去匹配一个假想的 template f(T) 函数模板，结果为值类型。</li>
<li>const auto&amp; a &#x3D; expr; 意味着用 expr 去匹配一个假想的 template f(const T&amp;) 函数模板，结果为常左值引用类型。</li>
<li>auto&amp;&amp; a &#x3D; expr; 意味着用 expr 去匹配一个假想的 template f(T&amp;&amp;) 函数模板，根据[第 3 讲] 中我们讨论过的转发引用和引用坍缩规则，结果是一个跟 expr 值类别相同的引用类型。</li>
</ul>
</li>
<li><p>decltype 的用途是获得一个表达式的类型，结果可以跟类型一样使用。它有两个基本用法：</p>
<ul>
<li>decltype(变量名) 可以获得变量的精确类型。</li>
<li>decltype(表达式) （表达式不是变量名，但包括 decltype((变量名)) 的情况）可以获得表达式的引用类型；除非表达式的结果是个纯右值（prvalue），此时结果仍然是值类型。</li>
<li>如果我们有 int a;，那么：<ul>
<li>decltype(a) 会获得 int（因为 a 是 int）。</li>
<li>decltype((a)) 会获得 int&amp;（因为 a 是 lvalue）。</li>
<li>decltype(a + a) 会获得 int（因为 a + a 是 prvalue）。</li>
</ul>
</li>
</ul>
</li>
<li><p>通常情况下，能写 auto 来声明变量肯定是件比较轻松的事。但这儿有个限制，你需要在写下 auto 时就决定你写下的是个引用类型还是值类型</p>
</li>
<li><p>根据类型推导规则，auto 是值类型，auto&amp; 是左值引用类型，auto&amp;&amp; 是转发引用（可以是左值引用，也可以是右值引用）。使用 auto 不能通用地根据表达式类型来决定返回值的类型。不过，decltype(expr) 既可以是值类型，也可以是引用类型。因此，我们可以这么写：</p>
<ul>
<li><code>decltype(expr) a = expr;</code></li>
</ul>
</li>
<li><p>这种写法明显不能让人满意，特别是表达式很长的情况（而且，任何代码重复都是潜在的问题）。为此，C++14 引入了 decltype(auto) 语法。对于上面的情况，我们只需要像下面这样写就行了。</p>
<ul>
<li><code>decltype(auto) a = expr;</code></li>
</ul>
</li>
<li><p>这种代码主要用在通用的转发函数模板中：你可能根本不知道你调用的函数是不是会返回一个引用。这时使用这种语法就会方便很多。</p>
</li>
</ul>
<h3 id="1-2-函数返回值类型推断"><a href="#1-2-函数返回值类型推断" class="headerlink" title="1.2 函数返回值类型推断"></a>1.2 函数返回值类型推断</h3><ul>
<li>从 C++14 开始，函数的返回值也可以用 auto 或 decltype(auto) 来声明了。同样的，用 auto 可以得到值类型，用 auto&amp; 或 auto&amp;&amp; 可以得到引用类型；</li>
<li>而用 decltype(auto) 可以根据返回表达式通用地决定返回的是值类型还是引用类型</li>
<li>和这个形式相关的有另外一个语法，后置返回值类型声明。严格来说，这不算“类型推断”，不过我们也放在一起讲吧。它的形式是这个样子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto foo(参数) -&gt; 返回值类型声明</span><br><span class="line">&#123;</span><br><span class="line">  // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>通常，在返回类型比较复杂、特别是返回类型跟参数类型有某种推导关系时会使用这种语法</li>
</ul>
<h3 id="1-3-类模板的模板参数推导"><a href="#1-3-类模板的模板参数推导" class="headerlink" title="1.3 类模板的模板参数推导"></a>1.3 类模板的模板参数推导</h3><ul>
<li><p>如果你用过 pair 的话，一般都不会使用下面这种形式：<code>pair&lt;int, int&gt; pr&#123;1, 42&#125;;</code></p>
</li>
<li><p>使用 make_pair 显然更容易一些：<code>auto pr = make_pair(1, 42);</code></p>
</li>
<li><p>这是因为函数模板有模板参数推导，使得调用者不必手工指定参数类型；但 C++17 之前的类模板却没有这个功能，也因而催生了像 make_pair 这样的工具函数。</p>
</li>
<li><p>在进入了 C++17 的世界后，这类函数变得不必要了。现在我们可以直接写：<code>pair pr&#123;1, 42&#125;;</code></p>
</li>
<li><p>在初次见到 array 时，我觉得它的主要缺点就是不能像 C 数组一样自动从初始化列表来推断数组的大小了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a1[] = &#123;1, 2, 3&#125;;</span><br><span class="line">array&lt;int, 3&gt; a2&#123;1, 2, 3&#125;; // 啰嗦</span><br><span class="line">// array&lt;int&gt; a3&#123;1, 2, 3&#125;; 不行</span><br></pre></td></tr></table></figure></li>
<li><p>这个问题在 C++17 里也是基本不存在的。虽然不能只提供一个模板参数，但你可以两个参数全都不写</p>
<ul>
<li><code>array a&#123;1, 2, 3&#125;;  // 得到 array&lt;int, 3&gt;</code></li>
</ul>
</li>
<li><p>这种自动推导机制，可以是编译器根据构造函数来自动生成：</p>
</li>
<li><p>也可以是手工提供一个推导向导，达到自己需要的效果：</p>
</li>
</ul>
<h3 id="1-4-结构化绑定"><a href="#1-4-结构化绑定" class="headerlink" title="1.4 结构化绑定"></a>1.4 结构化绑定</h3><ul>
<li>在讲关联容器的时候我们有过这样一个例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, int&gt;::iterator</span><br><span class="line">  lower, upper;</span><br><span class="line">std::tie(lower, upper) =</span><br><span class="line">  mmp.equal_range(&quot;four&quot;);</span><br></pre></td></tr></table></figure></li>
<li>这个例子里，返回值是个 pair，我们希望用两个变量来接收数值，就不得不声明了两个变量，然后使用 tie 来接收结果。</li>
<li>在 C++11&#x2F;14 里，这里是没法使用 auto 的。好在 C++17 引入了一个新语法，解决了这个问题。目前，我们可以把上面的代码简化为:<code>auto [lower, upper] = mmp.equal_range(&quot;four&quot;);</code></li>
<li>这个语法使得我们可以用 auto 声明变量来分别获取 pair 或 tuple 返回值里各个子项，可以让代码的可读性更好。</li>
</ul>
<h3 id="1-5-列表初始化"><a href="#1-5-列表初始化" class="headerlink" title="1.5 列表初始化"></a>1.5 列表初始化</h3><ul>
<li><p>在 C++98 里，标准容器比起 C 风格数组至少有一个明显的劣势：不能在代码里方便地初始化容器的内容。比如，对于数组你可以写：</p>
<ul>
<li><code>int a[] = &#123;1, 2, 3, 4, 5&#125;;</code></li>
</ul>
</li>
<li><p>而对于 vector 你却得写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v.push(1);</span><br><span class="line">v.push(2);</span><br><span class="line">v.push(3);</span><br><span class="line">v.push(4);</span><br><span class="line">v.push(5);</span><br></pre></td></tr></table></figure></li>
<li><p>这样真是又啰嗦，性能又差，显然无法让人满意。于是，C++ 标准委员会引入了列表初始化，允许以更简单的方式来初始化对象。现在我们初始化容器也可以和初始化数组一样简单了：</p>
<ul>
<li><code>vector v&#123;1, 2, 3, 4, 5&#125;;</code></li>
</ul>
</li>
<li><p>同样重要的是，这不是对标准库容器的特殊魔法，而是一个通用的、可以用于各种类的方法。</p>
</li>
<li><p>从技术角度，编译器的魔法只是对 {1, 2, 3} 这样的表达式自动生成一个初始化列表，在这个例子里其类型是 initializer_list。程序员只需要声明一个接受 initializer_list 的构造函数即可使用。从效率的角度，至少在动态对象的情况下，容器和数组也并无二致，都是通过拷贝（构造）进行初始化</p>
</li>
</ul>
<h3 id="1-6-统一初始化"><a href="#1-6-统一初始化" class="headerlink" title="1.6 统一初始化"></a>1.6 统一初始化</h3><ul>
<li><p>你可能已经注意到了，我在代码里使用了大括号 {} 来进行对象的初始化。这当然也是 C++11 引入的新语法，能够代替很多小括号 () 在变量初始化时使用。这被称为统一初始化（uniform initialization）。</p>
</li>
<li><p>大括号对于构造一个对象而言，最大的好处是避免了 C++ 里“最令人恼火的语法分析”（the most vexing parse）</p>
</li>
<li><p>你几乎可以在所有初始化对象的地方使用大括号而不是小括号。它还有一个附带的特点：当一个构造函数没有标成 explicit 时，你可以使用大括号不写类名来进行构造，如果调用上下文要求那类对象的话</p>
</li>
<li><p>这个语法主要的限制是，如果一个类既有使用初始化列表的构造函数，又有不使用初始化列表的构造函数，那编译器会千方百计地试图调用使用初始化列表的构造函数，导致各种意外。所以，如果给一个推荐的话，那就是：</p>
<ul>
<li>如果一个类没有使用初始化列表的构造函数时，初始化该类对象可全部使用统一初始化语法。</li>
<li>如果一个类有使用初始化列表的构造函数时，则只应用在初始化列表构造的情况。</li>
</ul>
</li>
</ul>
<h3 id="1-7-类数据成员的默认初始化"><a href="#1-7-类数据成员的默认初始化" class="headerlink" title="1.7 类数据成员的默认初始化"></a>1.7 类数据成员的默认初始化</h3><ul>
<li>按照 C++98 的语法，数据成员可以在构造函数里进行初始化。</li>
<li>这本身不是问题，但实践中，如果数据成员比较多、构造函数又有多个的话，逐个去初始化是个累赘，并且很容易在增加数据成员时漏掉在某个构造函数中进行初始化</li>
<li>为此，C++11 增加了一个语法，允许在声明数据成员时直接给予一个初始化表达式。这样，当且仅当构造函数的初始化列表中不包含该数据成员时，这个数据成员就会自动使用初始化表达式进行初始化。</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Complex &#123;</span><br><span class="line">public:</span><br><span class="line">  Complex()</span><br><span class="line">    : re_(0) , im_(0) &#123;&#125;</span><br><span class="line">  Complex(float re)</span><br><span class="line">    : re_(re), im_(0) &#123;&#125;</span><br><span class="line">  Complex(float re, float im)</span><br><span class="line">    : re_(re) , im_(im) &#123;&#125;</span><br><span class="line">  …</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  float re_;</span><br><span class="line">  float im_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>假设由于某种原因，我们不能使用缺省参数来简化构造函数，我们可以用什么方式来优化上面这个代码呢？</li>
<li>使用数据成员的默认初始化的话，我们就可以这么写：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Complex &#123;</span><br><span class="line">public:</span><br><span class="line">  Complex() &#123;&#125;</span><br><span class="line">  Complex(float re) : re_(re) &#123;&#125;</span><br><span class="line">  Complex(float re, float im)</span><br><span class="line">    : re_(re) , im_(im) &#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  float re_&#123;0&#125;;</span><br><span class="line">  float im_&#123;0&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>第一个构造函数没有任何初始化列表，所以类数据成员的初始化全部由默认初始化完成，re_ 和 im_ 都是 0。</li>
<li>第二个构造函数提供了 re_ 的初始化，im_ 仍由默认初始化完成。</li>
<li>第三个构造函数则完全不使用默认初始化。</li>
</ul>
<h2 id="易用性改进二：字面量，静态断言和成员函数说明符"><a href="#易用性改进二：字面量，静态断言和成员函数说明符" class="headerlink" title="易用性改进二：字面量，静态断言和成员函数说明符"></a>易用性改进二：字面量，静态断言和成员函数说明符</h2><h3 id="1-1-自定义字面量"><a href="#1-1-自定义字面量" class="headerlink" title="1.1 自定义字面量"></a>1.1 自定义字面量</h3><ul>
<li><p>字面量（literal）是指在源代码中写出的固定常量，它们在 C++98 里只能是原生类型，如：</p>
<ul>
<li>“hello”，字符串字面量，类型是 <code>const char[6]</code></li>
<li>1，整数字面量，类型是 int</li>
<li>0.0，浮点数字面量，类型是 double</li>
<li>3.14f，浮点数字面量，类型是 float</li>
<li>123456789ul，无符号长整数字面量，类型是 unsigned long</li>
</ul>
</li>
<li><p>C++11 引入了自定义字面量，可以使用 operator”” 后缀 来将用户提供的字面量转换成实际的类型。C++14 则在标准库中加入了不少标准字面量。下面这个程序展示了它们的用法：</p>
</li>
</ul>
<h3 id="1-2-二进制字面量"><a href="#1-2-二进制字面量" class="headerlink" title="1.2 二进制字面量"></a>1.2 二进制字面量</h3><ul>
<li><p>你一定知道 C++ 里有 0x 前缀，可以让开发人员直接写出像 0xFF 这样的十六进制字面量</p>
</li>
<li><p>另外一个目前使用得稍少的前缀就是 0 后面直接跟 0–7 的数字，表示八进制的字面量，</p>
</li>
<li><p>在跟文件系统打交道的时候还会经常用到：有经验的 Unix 程序员可能会觉得<code>chmod(path, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)</code> 并不比 <code>chmod(path,0644)</code> 更为直观</p>
</li>
<li><p>从 C++14 开始，我们对于二进制也有了直接的字面量：</p>
<ul>
<li><code>unsigned mask = 0b111000000;</code></li>
</ul>
</li>
<li><p>这在需要比特级操作等场合还是非常有用的。</p>
</li>
<li><p>不过，遗憾的是， I&#x2F;O streams 里只有 dec、hex、oct 三个操纵器（manipulator），而没有 bin，因而输出一个二进制数不能像十进制、十六进制、八进制那么直接。一个间接方式是使用 bitset，但调用者需要手工指定二进制位数：</p>
<ul>
<li><code>#include &lt;bitset&gt;  cout &lt;&lt; bitset&lt;9&gt;(mask) &lt;&lt; endl;</code></li>
</ul>
</li>
</ul>
<h3 id="1-3-数字分隔符"><a href="#1-3-数字分隔符" class="headerlink" title="1.3 数字分隔符"></a>1.3 数字分隔符</h3><ul>
<li>数字长了之后，看清位数就变得麻烦了。有了二进制字面量，这个问题变得分外明显。</li>
<li>C++14 开始，允许在数字型字面量中任意添加 <code>&#39;</code> 来使其更可读。</li>
<li>具体怎么添加，完全由程序员根据实际情况进行约定。某些常见的情况可能会是：<ul>
<li>十进制数字使用三位的分隔，对应英文习惯的 thousand、million 等单位。</li>
<li>十进制数字使用四位的分隔，对应中文习惯的万、亿等单位。</li>
<li>十六进制数字使用两位或四位的分隔，对应字节或双字节。</li>
<li>二进制数字使用三位的分隔，对应文件系统的权限分组。</li>
</ul>
</li>
<li>一些实际例子如下：<pre><code>  unsigned mask = 0b111&#39;000&#39;000;
  long r_earth_equatorial = 6&#39;378&#39;137;
  double pi = 3.14159&#39;26535&#39;89793;
  const unsigned magic = 0x44&#39;42&#39;47&#39;4E;
</code></pre>
</li>
</ul>
<h3 id="1-4-静态断言"><a href="#1-4-静态断言" class="headerlink" title="1.4 静态断言"></a>1.4 静态断言</h3><ul>
<li><p>C++98 的 assert 允许在运行时检查一个函数的前置条件是否成立。</p>
</li>
<li><p>没有一种方法允许开发人员在编译的时候检查假设是否成立。比如，如果模板有个参数 alignment，表示对齐，那我们最好在编译时就检查 alignment 是不是二的整数次幂。之前人们用了一些模板技巧来达到这个目的，但输出的信息并不那么友善。</p>
</li>
<li><p>C++11 直接从语言层面提供了静态断言机制，不仅能输出更好的信息，而且适用性也更好，可以直接放在类的定义中，而不像之前用的特殊技巧只能放在函数体里</p>
</li>
<li><p>静态断言语法上非常简单，就是：</p>
<ul>
<li><code>static_assert(编译期条件表达式， 可选输出信息);</code></li>
</ul>
</li>
<li><p>产生上面的示例错误信息的代码是：</p>
<ul>
<li><code>static_assert((alignment &amp; (alignment - 1)) == 0,&quot;Alignment must be power of two&quot;);</code></li>
</ul>
</li>
</ul>
<h3 id="1-5-default-和-delete-成员函数"><a href="#1-5-default-和-delete-成员函数" class="headerlink" title="1.5 default 和 delete 成员函数"></a>1.5 default 和 delete 成员函数</h3><ul>
<li><p>在类的定义时，C++ 有一些规则决定是否生成默认的特殊成员函数。这些特殊成员函数可能包括：</p>
<ul>
<li>默认构造函数</li>
<li>析构函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值函数</li>
<li>移动构造函数</li>
<li>移动赋值函数</li>
</ul>
</li>
<li><p>生成这些特殊成员函数（或不生成）的规则比较复杂，每个特殊成员函数有几种不同的状态：</p>
<ul>
<li>隐式声明还是用户声明</li>
<li>默认提供还是用户提供</li>
<li>正常状态还是删除状态</li>
</ul>
</li>
<li><p>这三个状态是可组合的，虽然不是所有的组合都有效。隐式声明的必然是默认提供的；默认提供的才可能被删除；用户提供的也必然是用户声明的。</p>
</li>
<li><p>如果成员和父类没有特殊原因导致对象不可拷贝或移动，在用户不声明这些成员函数的情况下，编译器会自动产生这些成员函数，即隐式声明、默认提供、正常状态。有特殊成员、用户声明的话，情况就非常复杂了：</p>
<ul>
<li>没有初始化的非静态 const 数据成员和引用类型数据成员会导致默认提供的默认构造函数被删除。</li>
<li>非静态的 const 数据成员和引用类型数据成员会导致默认提供的拷贝构造函数、拷贝赋值函数、移动构造函数和移动赋值函数被删除。</li>
<li>用户如果没有自己提供一个拷贝构造函数（必须形如 Obj(Obj&amp;) 或 Obj(constObj&amp;)；不是模板），编译器会隐式声明一个</li>
<li>用户如果没有自己提供一个拷贝赋值函数（必须形如 Obj&amp; operator&#x3D;(Obj&amp;) 或Obj&amp; operator&#x3D;(const Obj&amp;)；不是模板），编译器会隐式声明一个。</li>
<li>用户如果自己声明了一个移动构造函数或移动赋值函数，则默认提供的拷贝构造函数和拷贝赋值函数被删除。</li>
<li>用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数</li>
<li>用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动构造函数和析构函数，编译器会隐式声明一个移动赋值函数。</li>
</ul>
</li>
<li><p>我不鼓励你去死记硬背这些规则，而是希望你在项目和测试中体会其缘由。我认为这些规则还相当合理，虽然有略偏保守之嫌。尤其是关于移动构造和赋值：只要用户声明了另外的特殊成员函数中的任何一个，编译器就不默认提供了。不过嘛，缺省慢点总比缺省不安全要好……</p>
</li>
<li><p>我们这儿主要要说的是：</p>
<ul>
<li>我们可以改变缺省行为，在编译器能默认提供特殊成员函数时将其删除，或在编译器不默认提供特殊成员函数时明确声明其需要默认提供</li>
<li>（不过，要注意，即使用户要求默认提供，编译器也可能根据其他规则将特殊成员函数标为删除）。</li>
</ul>
</li>
</ul>
<h3 id="1-6-override-和-final-说明符"><a href="#1-6-override-和-final-说明符" class="headerlink" title="1.6 override 和 final 说明符"></a>1.6 override 和 final 说明符</h3><ul>
<li><p>override 和 final 是两个 C++11 引入的新说明符。</p>
</li>
<li><p>它们不是关键词，仅在出现在函数声明尾部时起作用，不影响我们使用这两个词作变量名等其他用途。这两个说明符可以单个或组合使用，都是加在类成员函数声明的尾部。</p>
</li>
<li><p>override 显式声明了成员函数是一个虚函数且覆盖了基类中的该函数。如果有override 声明的函数不是虚函数，或基类中不存在这个虚函数，编译器会报告错误。</p>
</li>
<li><p>这个说明符的主要作用有两个：</p>
<ul>
<li>给开发人员更明确的提示，这个函数覆写了基类的成员函数；</li>
<li>让编译器进行额外的检查，防止程序员由于拼写错误或代码改动没有让基类和派生类中的成员函数名称完全一致。</li>
</ul>
</li>
<li><p>final 则声明了成员函数是一个虚函数，且该虚函数不可在派生类中被覆盖。如果有一点没有得到满足的话，编译器就会报错。</p>
</li>
<li><p>final 还有一个作用是标志某个类或结构不可被派生。同样，这时应将其放在被定义的类或结构名后面。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_09_%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/2024-05-22-C++_09_%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_09_%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/2024-05-22-C++_09_%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C++_09_后台开发理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++服务器开发，后台开发基本理论知识</li>
</ul>
<h2 id="静态文件托管-是什么"><a href="#静态文件托管-是什么" class="headerlink" title="静态文件托管 是什么"></a>静态文件托管 是什么</h2><p>在服务器环境中，静态文件托管指的是将静态文件（例如HTML、CSS、JavaScript、图像、视频等）通过HTTP协议提供给客户端。这意味着服务器会接收来自客户端的请求，并将请求的静态文件发送回客户端，使其能够在浏览器中进行显示或使用。</p>
<p>静态文件托管是一种简单有效的方式来提供网站或应用程序的静态内容，因为这些文件通常不需要在每次请求时进行处理或生成动态内容。</p>
<p>通常情况下，服务器会配置一个目录，称为静态文件目录（或文档根目录），该目录包含要提供给客户端的静态文件。当收到针对这些静态文件的HTTP请求时，服务器会检查请求的文件路径，并将相应的文件内容发送回客户端。</p>
<p>例如，如果您的服务器上的静态文件目录是<code>/var/www/html</code>，并且有一个名为<code>index.html</code>的文件，当用户在浏览器中访问您的服务器时，可以通过URL <code>http://yourdomain.com/index.html</code> 来请求该文件。服务器会将<code>/var/www/html/index.html</code>的内容发送回浏览器，使其能够显示该网页。</p>
<p>静态文件托管常用于简单的网站、单页应用程序（SPA）和服务端渲染的应用程序等场景。相比于动态内容生成，静态文件托管可以提供更快的响应速度，减轻服务器的负载，并且不需要在每个请求上进行处理。</p>
<p>对于静态文件托管，您可以使用各种服务器软件，如Apache、Nginx等，通过配置服务器软件的相关选项来指定静态文件目录和其他细节。</p>
<h2 id="C-传输二进制数据"><a href="#C-传输二进制数据" class="headerlink" title="C++ 传输二进制数据"></a>C++ 传输二进制数据</h2><ul>
<li><p>二进制数据传输的本质</p>
<ul>
<li>首先明确，数据在计算机内存中的存储方式是二进制的，在进行数据传输的时候，从内存中读取出来的数据就是二进制的数据。</li>
<li>因此，如果能够保证数据存储上的连续性的话，我们只需要告诉httplib，传输数据的指针地址是什么，传输数据的长度是多少即可。</li>
</ul>
</li>
<li><p>指针相关概念</p>
<ul>
<li>C里面关于内存数据的操作需要两个条件，一个是指针，一个是长度</li>
<li>针对连续的内存，可以通过指针+长度的方式来操作内存</li>
</ul>
</li>
<li><p>float* 和 char* 类型的指针有什么区别</p>
<ul>
<li>本质上都是指向数据的存储地址，区别在于指针类型，以及读出数据时候的格式转换</li>
<li>float* 类型的指针，指针运算的时候，因为float是4个字节，需要转换成1个字节，因此需要size * 4</li>
<li>char* 类型的指针，指针运算的时候，因为char是1个字节，因此直接获取size即可</li>
</ul>
</li>
</ul>
<h2 id="理解字节本质和二进制"><a href="#理解字节本质和二进制" class="headerlink" title="理解字节本质和二进制"></a>理解字节本质和二进制</h2><ul>
<li><p>无论是互联网应用还是物联网应用，在网络传输层传输的其是都是二进制数据。因为现代通讯设备对信号处理都是用的数字电路，数字电路的输入输出只有两种状态，那就是高电平或者低电平，也就是对应二进制数据的1和0。</p>
</li>
<li><p>按照一定的时序和时钟基准，就可以代表了不同的信息。</p>
</li>
<li><p>网络传输中是按照字节传输的，而每个字节通常是按照8位二进制组成的。</p>
</li>
<li><p>一个字节由8个二进制位组成，通常标准是高位在前，最低位序号是0，最高位序号是7。</p>
</li>
<li><p>为什么叫二进制？</p>
<ul>
<li>生活中使用的数字计数是10进制的，因逢10进1而得名。那二进制也是因为逢2进1而得名的。</li>
<li>一个字节的8位二进制实际就是一个计数标记，由8个位组合在一起表示。因为每个位只能有0和1两种变化，所以要计数到2的时候就得进位了。</li>
</ul>
</li>
</ul>
<h2 id="理解十六进制"><a href="#理解十六进制" class="headerlink" title="理解十六进制"></a>理解十六进制</h2><ul>
<li><p>二进制的写法，一个字节要写8次，显然很不方便，也不好读，口算成十进制数有很大难度。那么十六进制标准书写是两个字符表示一个字节，等宽制的，便于编辑和浏览。</p>
</li>
<li><p>更重要的是与二进制的换算刚好将8位分成两部分，每四位对应一个字符，两个字符拼在一起代表了完整的8位</p>
</li>
<li><p>十六进制，顾名思义应该是逢十六进一，但是阿拉伯数字只有0-9，那么逢十六进一至少要能表示到15才可以。因此十六进制在0-9的基础上又增加了A-F六个字母分别代表10-15。对应十进制值</p>
<ul>
<li>00 表示 0</li>
<li>0A 表示 10</li>
<li>0F 表示 15</li>
<li>10 表示 16(因为满16就进位了)</li>
</ul>
</li>
<li><p>一个字节的8个位四四分开，分别对应前后两个16进制字符，就很快可以换算出来</p>
</li>
</ul>
<h2 id="HTTP-文件上传"><a href="#HTTP-文件上传" class="headerlink" title="HTTP 文件上传"></a>HTTP 文件上传</h2><ul>
<li>在HTTP中，我们要上传文件的时候一般都是通过Form实现的，对于Form有个属性可以用于定义提交的编码方式: enctype，它的可选值有<ul>
<li>application&#x2F;x-www-form-urlencoded： 默认的类型</li>
<li>multipart&#x2F;form-data : 允许通过file类型的<input>用于上传文件</li>
<li>text&#x2F;plain : 不常用的方式，直接将数据传输到后端</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_11_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2024-05-22-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_11_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2024-05-22-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">装饰者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>Decorator(装饰者)模式</li>
</ul>
<h2 id="C-Decorator-模式-详解"><a href="#C-Decorator-模式-详解" class="headerlink" title="C++ Decorator 模式 详解"></a>C++ Decorator 模式 详解</h2><p>Decorator（装饰者）模式是一种结构型设计模式，它允许向一个对象动态地添加功能，而无需通过子类继承的方式。这种模式是通过将对象包装在一个装饰器类的实例中来实现的，这样就可以动态地添加新的行为和责任。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>Decorator模式包含以下几个关键角色：</p>
<ol>
<li><p><strong>Component（组件）</strong>：是一个抽象类或接口，定义了被装饰的对象的接口。它可以是一个具体的类或接口，定义了一些基本的行为。</p>
</li>
<li><p><strong>ConcreteComponent（具体组件）</strong>：是实现Component接口的具体类，它是被装饰的对象。</p>
</li>
<li><p><strong>Decorator（装饰器）</strong>：也是一个抽象类或接口，它继承了Component，并持有一个Component对象的引用。这个类的主要作用是为了动态地添加额外的功能。</p>
</li>
<li><p><strong>ConcreteDecorator（具体装饰器）</strong>：是实现Decorator接口的具体类，它包含了要添加的额外功能。它可以包装具体组件对象并调用其原始的操作，然后再添加额外的功能。</p>
</li>
</ol>
<h3 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h3><p>下面是一个简单的Decorator模式的实现示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">serve</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteComponent</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCoffee</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serve</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Simple coffee&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Coffee* coffee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CoffeeDecorator</span>(Coffee* coffee) : <span class="built_in">coffee</span>(coffee) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serve</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        coffee-&gt;<span class="built_in">serve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteDecorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MilkDecorator</span> : <span class="keyword">public</span> CoffeeDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MilkDecorator</span>(Coffee* coffee) : <span class="built_in">CoffeeDecorator</span>(coffee) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serve</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        CoffeeDecorator::<span class="built_in">serve</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; + milk&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Coffee* coffee = <span class="keyword">new</span> <span class="built_in">SimpleCoffee</span>();</span><br><span class="line">    coffee-&gt;<span class="built_in">serve</span>();  <span class="comment">// Output: Simple coffee</span></span><br><span class="line"></span><br><span class="line">    Coffee* coffeeWithMilk = <span class="keyword">new</span> <span class="built_in">MilkDecorator</span>(coffee);</span><br><span class="line">    coffeeWithMilk-&gt;<span class="built_in">serve</span>();  <span class="comment">// Output: Simple coffee + milk</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> coffee;</span><br><span class="line">    <span class="keyword">delete</span> coffeeWithMilk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>Coffee</code>是组件，<code>SimpleCoffee</code>是具体组件。<code>CoffeeDecorator</code>是装饰器，<code>MilkDecorator</code>是具体装饰器。</p>
<p>使用装饰器模式，我们可以在运行时动态地向<code>SimpleCoffee</code>对象添加额外的功能，而无需修改其原始类的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_11_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2024-05-22-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_11_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2024-05-22-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" class="post-title-link" itemprop="url">抽象工厂</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>抽象工厂模式</li>
</ul>
<h2 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h2><ul>
<li>抽象工厂模式(Abstract factory pattern)是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。抽象工厂模式将一组对象的实现细节与它们的一般使用分离开来。</li>
<li>一个工厂中创建的每个对象都是同一个主题(fancy | modern)</li>
<li>工厂，是创建产品(对象)的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能够在增加新的具体工厂的时候，不用修改抽象工厂的客户端代码。</li>
<li>使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够低效这样的额外工作。</li>
</ul>
<h2 id="抽象工厂模式的定义"><a href="#抽象工厂模式的定义" class="headerlink" title="抽象工厂模式的定义"></a>抽象工厂模式的定义</h2><ul>
<li>抽象工厂模式的实质是提供接口，创建一系列相关或者独立的对象，而不指定这些对象的具体类。</li>
</ul>
<h2 id="抽象工厂模式的使用"><a href="#抽象工厂模式的使用" class="headerlink" title="抽象工厂模式的使用"></a>抽象工厂模式的使用</h2><ul>
<li>具体的工厂决定了创建对象的具体类型，而且工厂就是对象实际创建的地方(例如在C++中，用new操作符创建对象)。然而，抽象工厂只返回一个指向创建的对象的抽象引用(或指针)</li>
<li>这样，客户端程序调用抽象工厂引用的方法，由具体工厂完成对象创建，然后客户端程序得到的是抽象产品的引用。如此使客户端代码与对象的创建分离开来</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_08_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-05-22-C++_08_%E5%B8%B8%E7%94%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_08_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-05-22-C++_08_%E5%B8%B8%E7%94%A8%E7%B1%BB/" class="post-title-link" itemprop="url">C++_08_常用类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++中常用到的类</li>
</ul>
<h3 id="std-enable-shared-from-this"><a href="#std-enable-shared-from-this" class="headerlink" title="std::enable_shared_from_this"></a>std::enable_shared_from_this</h3><p>在 C++ 中，<code>std::enable_shared_from_this</code> 是一个模板类，位于 <code>&lt;memory&gt;</code> 头文件中，它用于在共享所有权的智能指针（<code>std::shared_ptr</code>）对象中获取指向该对象的 <code>std::shared_ptr</code>。</p>
<p>当一个类继承自 <code>std::enable_shared_from_this</code> 并且其对象被一个 <code>std::shared_ptr</code> 管理时，可以使用 <code>shared_from_this()</code> 成员函数来获取一个指向当前对象的 <code>std::shared_ptr</code>。</p>
<p>以下是 <code>std::enable_shared_from_this</code> 的一些重要特点和使用方法：</p>
<ol>
<li><p><strong>必须使用 <code>std::shared_ptr</code> 管理对象</strong>：<code>std::enable_shared_from_this</code> 只能与 <code>std::shared_ptr</code> 一起使用。使用其他类型的智能指针或裸指针将导致未定义行为。</p>
</li>
<li><p>**继承 <code>std::enable_shared_from_this</code>**：要使用 <code>std::enable_shared_from_this</code>，你的类必须继承自它，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取 <code>std::shared_ptr</code> 的方法</strong>：通过调用 <code>shared_from_this()</code> 成员函数，可以获取指向当前对象的 <code>std::shared_ptr</code>，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;MyClass&gt; ptr = obj.<span class="built_in">shared_from_this</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li><code>shared_from_this()</code> 只能在由 <code>std::shared_ptr</code> 管理的对象中调用。在构造函数期间或通过裸指针调用会导致未定义行为。</li>
<li>必须先创建 <code>std::shared_ptr</code> 对象，然后才能调用 <code>shared_from_this()</code>。否则，将返回一个空的 <code>std::shared_ptr</code>。</li>
</ul>
</li>
</ol>
<p>使用 <code>std::enable_shared_from_this</code> 可以方便地获取指向当前对象的 <code>std::shared_ptr</code>，以便与其他共享该对象所有权的智能指针一起使用。这在实现资源共享和对象生命周期管理时非常有用，特别是在涉及对象自引用的情况下。</p>
<h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><p><code>std::thread</code>是C++标准库提供的用于创建和管理线程的类。它位于<code>&lt;thread&gt;</code>头文件中，并定义在<code>std</code>命名空间中。</p>
<p><code>std::thread</code>类提供了以下主要功能和成员函数：</p>
<ol>
<li><p>构造函数：</p>
<ul>
<li><code>explicit thread() noexcept;</code></li>
<li><code>template &lt;class Function, class... Args&gt; explicit thread(Function&amp;&amp; f, Args&amp;&amp;... args);</code></li>
<li><code>thread(const thread&amp;) = delete;</code>（复制构造函数被禁用）</li>
<li><code>thread(thread&amp;&amp; other) noexcept;</code>（移动构造函数）</li>
</ul>
</li>
<li><p>成员函数：</p>
<ul>
<li><code>operator=</code>: 赋值运算符，用于将一个线程对象赋值给另一个线程对象。</li>
<li><code>join()</code>: 阻塞调用线程，直到该线程执行完成。</li>
<li><code>detach()</code>: 将线程分离，使其在后台运行，不再与调用线程同步。</li>
<li><code>swap()</code>: 交换两个线程对象的内容。</li>
<li><code>get_id()</code>: 返回线程的唯一标识符。</li>
<li><code>joinable()</code>: 检查线程是否可加入或分离。</li>
<li><code>native_handle()</code>: 返回底层操作系统的线程句柄。</li>
<li><code>hardware_concurrency()</code>: 返回支持并发执行的线程数量。</li>
</ul>
</li>
<li><p>静态成员函数：</p>
<ul>
<li><code>std::thread::id</code>: 表示线程的唯一标识符的类型。</li>
<li><code>std::thread::native_handle_type</code>: 表示底层操作系统线程句柄的类型。</li>
<li><code>std::thread::hardware_concurrency()</code>: 返回支持并发执行的线程数量。</li>
</ul>
</li>
</ol>
<p>使用<code>std::thread</code>类创建线程的一般步骤如下：</p>
<ol>
<li>定义一个可调用的函数或函数对象，作为线程的执行逻辑。</li>
<li>创建<code>std::thread</code>对象，并将可调用的函数或函数对象作为参数传递给构造函数。</li>
<li>通过调用<code>join()</code>等待线程执行完成，或使用<code>detach()</code>分离线程并允许其在后台运行。</li>
</ol>
<p>以下是一个简单的示例，演示如何使用<code>std::thread</code>类创建和管理线程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可调用的函数作为线程执行逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 执行一些任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程对象，并指定可调用的函数及其参数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunction, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadFunction, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完成</span></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，使用<code>std::thread</code>类创建线程时，需要确保线程的执行完成或分离，否则会导致程序异常退出或资源泄漏。</p>
<p>这是对<code>std::thread</code>类的简要解释，您可以查阅C++标准库的文档以获取更详细的信息和用法示例。</p>
<hr>
<h2 id="std-fstream"><a href="#std-fstream" class="headerlink" title="std::fstream"></a>std::fstream</h2><p><code>std::fstream</code> 是 C++ 标准库中用于文件输入输出的类，它是 <code>std::ifstream</code>（文件输入流）和 <code>std::ofstream</code>（文件输出流）的基类，并结合了它们的功能，使得在同一个对象中可以实现文件的读取和写入。</p>
<p>要使用 <code>std::fstream</code> 类，需要包含 <code>&lt;fstream&gt;</code> 头文件。</p>
<p>下面是 <code>std::fstream</code> 类的详细解释：</p>
<h2 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h2><ul>
<li><code>explicit fstream(const char* filename, ios_base::openmode mode = ios_base::in | ios_base::out);</code></li>
<li><code>explicit fstream(const std::string&amp; filename, ios_base::openmode mode = ios_base::in | ios_base::out);</code></li>
</ul>
<p>构造函数用于创建 <code>std::fstream</code> 对象并打开文件。参数 <code>filename</code> 是要打开的文件名，参数 <code>mode</code> 是打开文件的模式，可以使用 <code>ios_base::in</code> 表示读取模式，<code>ios_base::out</code> 表示写入模式，<code>ios_base::app</code> 表示追加写入模式等等。</p>
<h2 id="成员函数："><a href="#成员函数：" class="headerlink" title="成员函数："></a>成员函数：</h2><ul>
<li><code>void open(const char* filename, ios_base::openmode mode = ios_base::in | ios_base::out);</code></li>
<li><code>void open(const std::string&amp; filename, ios_base::openmode mode = ios_base::in | ios_base::out);</code></li>
</ul>
<p><code>open</code> 函数用于打开一个新的文件，并可以指定打开模式。</p>
<ul>
<li><code>void close();</code></li>
</ul>
<p><code>close</code> 函数用于关闭文件。</p>
<ul>
<li><code>bool is_open() const;</code></li>
</ul>
<p><code>is_open</code> 函数用于检查文件是否成功打开，返回 true 表示文件已经成功打开，false 表示文件未打开或者打开失败。</p>
<ul>
<li><code>void clear();</code></li>
</ul>
<p><code>clear</code> 函数用于清除错误状态和结束-of-file标志。</p>
<ul>
<li><code>void seekg(std::streampos pos);</code></li>
<li><code>void seekg(std::streamoff off, std::ios_base::seekdir way);</code></li>
</ul>
<p><code>seekg</code> 函数用于设置输入位置指针的位置。第一种重载接受一个绝对位置 <code>pos</code>，第二种重载接受一个相对位置 <code>off</code> 和一个方向 <code>way</code>，方向可以是 <code>std::ios_base::beg</code>（从开头计算位置），<code>std::ios_base::cur</code>（从当前位置计算位置），或者 <code>std::ios_base::end</code>（从文件末尾计算位置）。</p>
<ul>
<li><code>std::streampos tellg();</code></li>
</ul>
<p><code>tellg</code> 函数用于获取当前输入位置指针的位置。</p>
<ul>
<li><code>void seekp(std::streampos pos);</code></li>
<li><code>void seekp(std::streamoff off, std::ios_base::seekdir way);</code></li>
</ul>
<p><code>seekp</code> 函数用于设置输出位置指针的位置，用法与 <code>seekg</code> 类似。</p>
<ul>
<li><code>std::streampos tellp();</code></li>
</ul>
<p><code>tellp</code> 函数用于获取当前输出位置指针的位置。</p>
<ul>
<li><code>std::fstream&amp; operator&lt;&lt;(T val);</code></li>
<li><code>std::fstream&amp; operator&gt;&gt;(T&amp; val);</code></li>
</ul>
<p>这些重载的运算符用于将数据写入文件（<code>operator&lt;&lt;</code>）或从文件读取数据（<code>operator&gt;&gt;</code>）。T 是要写入或读取的数据类型。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::fstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>, std::ios::out | std::ios::in)</span></span>; <span class="comment">// 打开文件用于读写</span></span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        file &lt;&lt; <span class="string">&quot;Hello, World!\n&quot;</span>; <span class="comment">// 写入数据到文件</span></span><br><span class="line">        file.<span class="built_in">seekg</span>(<span class="number">0</span>); <span class="comment">// 定位输入位置指针到文件开头</span></span><br><span class="line">        std::string line;</span><br><span class="line">        std::<span class="built_in">getline</span>(file, line); <span class="comment">// 从文件读取一行数据</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data read from file: &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to open file!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::fstream</code> 类提供了一个灵活而强大的接口来处理文件的读写操作。通过合理使用其成员函数和运算符重载，可以方便地在 C++ 程序中进行文件输入输出的操作。</p>
<hr>
<h2 id="std-ifstream"><a href="#std-ifstream" class="headerlink" title="std::ifstream"></a>std::ifstream</h2><p><code>std::ifstream</code> 是 C++ 标准库中用于文件输入的类，用于从文件中读取数据。它是基于流的输入操作符 <code>&gt;&gt;</code> 实现的，可以通过打开文件并使用 <code>&gt;&gt;</code> 运算符将文件中的数据读取到不同类型的变量中。</p>
<p>以下是 <code>std::ifstream</code> 类的一些常用方法和功能：</p>
<ol>
<li><p>打开文件：可以使用 <code>open()</code> 方法打开文件，指定要读取的文件路径和打开模式。打开模式可以是 <code>std::ios::in</code>（默认）或其他可选模式，如 <code>std::ios::binary</code>、<code>std::ios::ate</code> 等。</p>
</li>
<li><p>关闭文件：使用 <code>close()</code> 方法关闭打开的文件。在读取完文件内容后，应该显式地关闭文件。</p>
</li>
<li><p>读取数据：使用 <code>&gt;&gt;</code> 运算符可以将文件中的数据读取到不同类型的变量中。例如，可以使用 <code>&gt;&gt;</code> 运算符读取整数、浮点数、字符串等数据。</p>
</li>
<li><p>检查文件状态：可以使用 <code>good()</code>、<code>eof()</code>、<code>fail()</code>、<code>bad()</code> 等方法检查文件的状态。例如，<code>good()</code> 方法用于检查文件是否处于可读取状态，<code>eof()</code> 方法用于检查是否已到达文件末尾，<code>fail()</code> 方法用于检查读取操作是否失败。</p>
</li>
<li><p>定位文件指针：可以使用 <code>seekg()</code> 方法定位文件指针到指定位置，从而实现随机读取文件内容。</p>
</li>
<li><p>获取文件大小：可以结合文件指针定位和 <code>tellg()</code> 方法获取文件的大小。</p>
</li>
<li><p>检查文件是否打开：使用 <code>is_open()</code> 方法可以检查文件是否成功打开。</p>
</li>
<li><p>逐行读取文件：可以使用 <code>getline()</code> 方法逐行读取文件内容。</p>
</li>
</ol>
<p>使用 <code>std::ifstream</code> 类可以方便地打开、读取和处理文件内容。在使用完毕后，应该关闭文件以释放资源。</p>
<hr>
<h2 id="std-ofstream"><a href="#std-ofstream" class="headerlink" title="std::ofstream"></a>std::ofstream</h2><p><code>std::ofstream</code> 是 C++ 标准库中用于文件输出的类，用于将数据写入文件中。它是基于流的输出操作符 <code>&lt;&lt;</code> 实现的，可以通过打开文件并使用 <code>&lt;&lt;</code> 运算符将数据写入文件。</p>
<p>以下是 <code>std::ofstream</code> 类的一些常用方法和功能：</p>
<ol>
<li><p>打开文件：可以使用 <code>open()</code> 方法打开文件，指定要写入的文件路径和打开模式。打开模式可以是 <code>std::ios::out</code>（默认）或其他可选模式，如 <code>std::ios::binary</code>、<code>std::ios::app</code> 等。</p>
</li>
<li><p>关闭文件：使用 <code>close()</code> 方法关闭打开的文件。在写入完文件内容后，应该显式地关闭文件。</p>
</li>
<li><p>写入数据：使用 <code>&lt;&lt;</code> 运算符可以将数据写入文件。例如，可以使用 <code>&lt;&lt;</code> 运算符将整数、浮点数、字符串等数据写入文件。</p>
</li>
<li><p>检查文件状态：可以使用 <code>good()</code>、<code>fail()</code>、<code>bad()</code> 方法检查文件的状态。例如，<code>good()</code> 方法用于检查文件是否处于可写入状态，<code>fail()</code> 方法用于检查写入操作是否失败。</p>
</li>
<li><p>定位文件指针：可以使用 <code>seekp()</code> 方法定位文件指针到指定位置，从而实现随机写入文件内容。</p>
</li>
<li><p>检查文件是否打开：使用 <code>is_open()</code> 方法可以检查文件是否成功打开。</p>
</li>
</ol>
<hr>
<p>使用 <code>std::ofstream</code> 类可以方便地打开文件并将数据写入文件。在使用完毕后，应该关闭文件以释放资源。</p>
<ul>
<li><p><code>std::ofstream</code>是C++标准库提供的一个输出文件流类，用于将数据写入到文件中。它是<code>std::ostream</code>的派生类，继承了<code>std::ostream</code>中的输出操作符<code>&lt;&lt;</code>，可以方便地向文件写入各种类型的数据。</p>
</li>
<li><p>使用<code>std::ofstream</code>需要包含头文件<code>&lt;fstream&gt;</code>，并通过构造函数创建一个输出文件流对象，可以指定要打开的文件名和打开模式。常用的打开模式包括：</p>
<ul>
<li><code>std::ios::out</code>：以写入模式打开文件。</li>
<li><code>std::ios::app</code>：在文件末尾追加内容。</li>
<li><code>std::ios::trunc</code>：如果文件存在，删除文件内容并重新创建。</li>
<li><code>std::ios::binary</code>：以二进制模式打开文件。</li>
</ul>
</li>
<li><p>下面是一个示例代码，演示如何使用<code>std::ofstream</code>写入数据到文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string filename = <span class="string">&quot;example.txt&quot;</span>; <span class="comment">// 文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出文件流对象并打开文件</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(filename, std::ios::out)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 向文件写入数据</span></span><br><span class="line">        outputFile &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        outputFile &lt;&lt; <span class="number">42</span> &lt;&lt; std::endl;</span><br><span class="line">        outputFile &lt;&lt; <span class="number">3.14159</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        outputFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;数据已写入文件&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在上述代码中，首先创建一个<code>std::ofstream</code>对象并指定要打开的文件名和打开模式。然后，使用<code>&lt;&lt;</code>操作符向文件中写入数据。最后，使用<code>close</code>方法关闭文件。如果文件无法打开，则输出相应的错误信息。</p>
</li>
<li><p>需要注意的是，<code>std::ofstream</code>对象在销毁时会自动关闭文件，但最好显式调用<code>close</code>方法以确保及时关闭文件。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/test/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/test/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>BOOST库中单元测试模块</li>
</ul>
<h2 id="boost-单元测试"><a href="#boost-单元测试" class="headerlink" title="boost 单元测试"></a>boost 单元测试</h2><p>Boost 是一个功能强大的 C++ 库集合，其中包括了许多模块，其中 Boost.Test 是用于单元测试的一个模块。下面是使用 Boost.Test 进行单元测试的一般步骤：</p>
<ol>
<li><p><strong>包含 Boost.Test 头文件</strong>：<br>在你的测试文件中包含 Boost.Test 的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/test/unit_test.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编写测试用例</strong>：<br>使用 BOOST_AUTO_TEST_SUITE 和 BOOST_AUTO_TEST_CASE 宏来定义测试套件和测试用例。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOST_AUTO_TEST_SUITE</span>(MyTestSuite)</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOST_AUTO_TEST_CASE</span>(TestCase1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">    <span class="built_in">BOOST_CHECK_EQUAL</span>(<span class="number">1</span> + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOST_AUTO_TEST_SUITE_END</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行测试</strong>：<br>你可以使用 Boost.Test 提供的主函数来运行测试，也可以将测试代码添加到你的项目中并通过你的构建系统运行。如果你使用 CMake，则可以使用 add_executable 来添加测试代码，并且使用 target_link_libraries 来链接 Boost.Test 库。</p>
</li>
<li><p><strong>编写更多的测试用例</strong>：<br>编写多个测试用例来覆盖你的代码的不同情况和边界条件。</p>
</li>
<li><p><strong>检查测试结果</strong>：<br>运行测试并检查测试结果。Boost.Test 会输出详细的测试结果，包括测试通过的用例数、失败的用例数、用时等信息。</p>
</li>
<li><p><strong>高级特性</strong>：<br>Boost.Test 还支持许多高级特性，如测试夹具、参数化测试、自定义测试输出格式等。你可以根据需要使用这些特性来进一步增强你的测试。</p>
</li>
</ol>
<p>总的来说，使用 Boost.Test 进行单元测试与其他单元测试框架类似，但它提供了更多的灵活性和功能，可以满足各种复杂的测试需求。</p>
<h2 id="Boost-Test库-详解"><a href="#Boost-Test库-详解" class="headerlink" title="Boost.Test库 详解"></a>Boost.Test库 详解</h2><p>Boost.Test 是 Boost 库集合中的一个模块，用于 C++ 程序的单元测试。它提供了丰富的功能和工具来编写、组织和运行测试用例，以确保代码的质量和可靠性。</p>
<p>以下是 Boost.Test 的一些主要特性和功能：</p>
<ol>
<li><p><strong>自动化测试</strong>：Boost.Test 提供了一套自动化测试框架，使得可以编写测试用例来验证程序的不同部分的行为是否符合预期。</p>
</li>
<li><p><strong>测试用例和测试套件</strong>：可以使用 BOOST_AUTO_TEST_CASE 和 BOOST_AUTO_TEST_SUITE 宏来定义测试用例和测试套件，以便组织和管理你的测试代码。</p>
</li>
<li><p><strong>丰富的断言</strong>：Boost.Test 提供了丰富的断言宏，用于检查测试结果是否符合预期，如 BOOST_CHECK、BOOST_REQUIRE、BOOST_CHECK_EQUAL、BOOST_CHECK_CLOSE 等。</p>
</li>
<li><p><strong>参数化测试</strong>：支持参数化测试，可以使用 BOOST_DATA_TEST_CASE 宏来定义参数化测试用例，以便在同一个测试用例中使用不同的参数运行多次测试。</p>
</li>
<li><p><strong>测试夹具</strong>：支持测试夹具，可以使用 BOOST_FIXTURE_TEST_CASE 宏定义测试夹具，以在多个测试用例之间共享测试环境的设置和清理代码。</p>
</li>
<li><p><strong>丰富的输出信息</strong>：Boost.Test 输出详细的测试结果信息，包括测试通过的用例数、失败的用例数、用时等，以便于分析和调试测试结果。</p>
</li>
<li><p><strong>异常处理</strong>：可以使用 BOOST_CHECK_THROW 和 BOOST_CHECK_NO_THROW 等宏来测试代码是否产生了预期的异常。</p>
</li>
<li><p><strong>超时测试</strong>：支持超时测试，可以使用 BOOST_TEST_TIMEOUT 宏来指定测试用例的最大执行时间，以确保测试不会无限等待。</p>
</li>
<li><p><strong>测试装置</strong>：提供了测试装置（test tools）来支持高级测试需求，如模拟对象、mocking、性能测试等。</p>
</li>
<li><p><strong>适用性</strong>：Boost.Test 可以用于任何 C++ 项目，无论是使用 Boost 库还是其他库。</p>
</li>
</ol>
<p>总的来说，Boost.Test 是一个功能丰富、灵活易用的 C++ 单元测试框架，适用于各种规模和类型的项目，能够帮助开发者编写高质量、可靠性强的测试代码。</p>
<h2 id="Boost-Test库-cmake配置"><a href="#Boost-Test库-cmake配置" class="headerlink" title="Boost.Test库 cmake配置"></a>Boost.Test库 cmake配置</h2><p>要在 CMake 中配置 Boost.Test 库，你需要遵循以下步骤：</p>
<ol>
<li><p><strong>安装 Boost 库</strong>：首先确保你已经正确地安装了 Boost 库。你可以从 Boost 官方网站下载并安装 Boost 库，或者使用系统包管理器（如 apt、brew、yum 等）来安装 Boost 库。</p>
</li>
<li><p><strong>设置 CMakeLists.txt 文件</strong>：在你的项目根目录下创建一个 <code>CMakeLists.txt</code> 文件，并添加如下内容：</p>
</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(your_project_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找 Boost 库</span></span><br><span class="line"><span class="keyword">find_package</span>(Boost REQUIRED COMPONENTS unit_test_framework)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加你的项目源文件和头文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(your_executable_name your_source_files.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 Boost.Test 库和你的项目</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(your_executable_name PRIVATE <span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(your_executable_name PRIVATE <span class="variable">$&#123;Boost_UNIT_TEST_FRAMEWORK_LIBRARY&#125;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>配置 CMake 变量</strong>：在配置 CMake 时，你可以指定 Boost 库的安装路径，以便 CMake 能够找到 Boost 库。你可以通过以下方式指定 Boost 库的安装路径：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DBOOST_ROOT=/path/to/boost ..</span><br></pre></td></tr></table></figure>

<p>其中 <code>/path/to/boost</code> 是 Boost 库的安装路径。</p>
<ol start="4">
<li><strong>构建项目</strong>：在你的项目目录下创建一个 build 目录，然后在该目录下运行 CMake 命令进行项目构建：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>编写和运行测试</strong>：编写你的测试代码，并在 <code>your_source_files.cpp</code> 中包含 Boost.Test 的头文件。然后编写测试用例，并运行你的可执行文件进行测试。</li>
</ol>
<p>通过以上步骤，你就可以在你的 CMake 项目中成功配置和使用 Boost.Test 了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/CMake/cmake_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-cmake_1_01_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/CMake/cmake_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-cmake_1_01_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">cmake_1_01_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cmake 理论基础</li>
</ul>
<h2 id="cmake-timing-tools-是什么"><a href="#cmake-timing-tools-是什么" class="headerlink" title="cmake timing tools 是什么"></a>cmake timing tools 是什么</h2><p>CMake Timing Tools 是一组 CMake 工具和选项，用于分析 CMake 配置和构建过程中的时间消耗。这些工具帮助开发者定位构建过程中的瓶颈，进而优化构建时间。主要功能包括记录和显示 CMake 配置过程、构建过程以及不同构建步骤所花费的时间。</p>
<h3 id="CMake-Timing-Tools-主要包含以下几个部分："><a href="#CMake-Timing-Tools-主要包含以下几个部分：" class="headerlink" title="CMake Timing Tools 主要包含以下几个部分："></a>CMake Timing Tools 主要包含以下几个部分：</h3><hr>
<h3 id="1-CMake-Trace-选项"><a href="#1-CMake-Trace-选项" class="headerlink" title="1. CMake Trace 选项"></a>1. <strong>CMake Trace 选项</strong></h3><ul>
<li><p><strong><code>CMake --trace</code></strong><br><code>--trace</code> 选项用于在 CMake 配置过程中输出详细的日志信息，记录每个 CMake 脚本文件的执行情况。通过分析这些信息，可以了解每一步的执行顺序和所花费的时间。</p>
<ul>
<li>使用方式:  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --trace &lt;path-to-your-project&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>CMake --trace-expand</code></strong><br><code>--trace-expand</code> 选项是 <code>--trace</code> 的增强版本，除了输出每个 CMake 脚本的执行过程，还会展开每个变量的值。通过这个选项，你可以更详细地看到变量的变化，帮助分析哪些部分的 CMake 脚本影响了构建时间。</p>
<ul>
<li>使用方式:  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --trace-expand &lt;path-to-your-project&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-CMake-的-build-和-log-level"><a href="#2-CMake-的-build-和-log-level" class="headerlink" title="2. CMake 的 --build 和 --log-level"></a>2. <strong>CMake 的 <code>--build</code> 和 <code>--log-level</code></strong></h3><ul>
<li><p><strong><code>CMake --build</code></strong><br>这个选项允许你使用 CMake 来触发构建。虽然它本身不提供时间分析功能，但它可以与其他工具（如 Ninja）一起使用，配合时间监控。</p>
<ul>
<li>使用方式:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build &lt;path-to-your-project&gt; --verbose</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>CMake --log-level</code></strong><br>这个选项可以让你设置 CMake 输出的日志级别，控制日志的详细程度。通过不同的日志级别，开发者可以更容易定位构建过程中时间消耗较大的部分。</p>
<ul>
<li>使用方式:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --log-level=TRACE</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-使用-Ninja-和-CMake"><a href="#3-使用-Ninja-和-CMake" class="headerlink" title="3. 使用 Ninja 和 CMake"></a>3. <strong>使用 <code>Ninja</code> 和 <code>CMake</code></strong></h3><ul>
<li><p><strong>Ninja 构建系统</strong><br><code>Ninja</code> 是一个高效的构建系统，它与 CMake 配合使用时，能够输出每个构建步骤的详细时间。你可以结合 <code>Ninja</code> 和 CMake 来查看每个构建任务的执行时间，找出耗时长的任务。</p>
<ul>
<li><p>使用方式:</p>
<ol>
<li>首先生成 Ninja 构建文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G Ninja &lt;path-to-your-project&gt;</span><br></pre></td></tr></table></figure></li>
<li>然后进行构建，查看每个构建步骤的时间：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -v</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过查看 Ninja 输出的构建日志，你可以找到哪些步骤导致了编译时间的增加。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-CMake-和构建时间统计"><a href="#4-CMake-和构建时间统计" class="headerlink" title="4. CMake 和构建时间统计"></a>4. <strong>CMake 和构建时间统计</strong></h3><ul>
<li><p><strong><code>CMake --build &lt;path-to-your-project&gt; --target &lt;target-name&gt; -- -j</code></strong><br>如果使用的是支持并行构建的构建工具（如 Ninja），可以通过 <code>-j</code> 参数指定并行的线程数。通过查看每个线程的执行时间，你可以判断哪些任务是时间上的瓶颈。</p>
</li>
<li><p><strong>CMake 的 <code>CMAKE_VERBOSE_MAKEFILE</code></strong><br>通过设置 <code>CMAKE_VERBOSE_MAKEFILE</code> 变量为 <code>ON</code>，你可以查看每个 Makefile 生成的详细信息，并监控其执行时间。</p>
</li>
</ul>
<hr>
<h3 id="5-CMake-其他有用的分析工具"><a href="#5-CMake-其他有用的分析工具" class="headerlink" title="5. CMake 其他有用的分析工具"></a>5. <strong>CMake 其他有用的分析工具</strong></h3><ul>
<li>**<code>CMake Analyze</code>**（实验性功能）<br>这是一个实验性的 CMake 功能，旨在提供更高级的构建性能分析。它允许开发者分析项目中的每个目标和构建步骤的时间消耗。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CMake Timing Tools 提供的 <code>--trace</code> 和 <code>--trace-expand</code> 等选项，可以帮助开发者分析 CMake 配置过程中的耗时问题。配合 Ninja 等构建工具使用，还能进一步分析和优化构建过程中的每一步，帮助提升整个构建过程的效率。</p>
<h2 id="cmake-find-package-找到库文件之后-头文件目录和库文件目录存放的变量是什么"><a href="#cmake-find-package-找到库文件之后-头文件目录和库文件目录存放的变量是什么" class="headerlink" title="cmake find_package 找到库文件之后 头文件目录和库文件目录存放的变量是什么"></a>cmake find_package 找到库文件之后 头文件目录和库文件目录存放的变量是什么</h2><p>当使用 <code>find_package</code> 找到库文件之后，CMake 会设置一系列的变量来提供有关找到的库的信息，包括头文件目录和库文件目录。这些变量的具体名称取决于库的名称，因为 <code>find_package</code> 是由各个库的 CMake 模块来实现的。</p>
<p>对于大多数库，通常有以下两个变量：</p>
<ol>
<li><p><strong>变量名：<code>&lt;PackageName&gt;_INCLUDE_DIRS</code></strong></p>
<ul>
<li>描述：包含了找到的库的头文件目录。</li>
<li>示例：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PackageName_INCLUDE_DIRS&#125;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>变量名：<code>&lt;PackageName&gt;_LIBRARIES</code></strong></p>
<ul>
<li>描述：包含了找到的库的链接库的名称。</li>
<li>示例：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE <span class="variable">$&#123;PackageName_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>在这里，<code>&lt;PackageName&gt;</code> 是通过 <code>find_package</code> 指定的库的名称。例如，如果你使用 <code>find_package(gflags REQUIRED)</code>，那么变量名称就是 <code>GFLAGS_INCLUDE_DIRS</code> 和 <code>GFLAGS_LIBRARIES</code>。</p>
<p>另外，一些库还可能设置其他相关的变量，具体取决于库的 CMake 模块是如何实现的。查看相应库的文档或 CMake 模块的源代码以获取详细信息是一个好的实践。</p>
<h2 id="请问你能简单描述一下CMake是什么，以及它通常用来做什么吗？"><a href="#请问你能简单描述一下CMake是什么，以及它通常用来做什么吗？" class="headerlink" title="请问你能简单描述一下CMake是什么，以及它通常用来做什么吗？"></a>请问你能简单描述一下CMake是什么，以及它通常用来做什么吗？</h2><ul>
<li>CMake是一个跨平台的自动化构建系统，主要用来管理软件构建的过程，它使用一个名为CMakeLists.txt的配置文件来指导编译和链接的过程。CMake支持多种编译器和开发环境，可以生成标准的构建文件，如Makefile或者Visual Studio的项目文件。它不仅能够管理C&#x2F;C++项目的构建，还支持多种编程语言和库的集成。</li>
</ul>
<h2 id="CMakeLists-txt文件的基本结构是什么？"><a href="#CMakeLists-txt文件的基本结构是什么？" class="headerlink" title="CMakeLists.txt文件的基本结构是什么？"></a>CMakeLists.txt文件的基本结构是什么？</h2><ul>
<li>cmake_minimum_required(VERSION x.x): 指定项目需要的最低CMake版本。</li>
<li>project(ProjectName): 定义项目的名称和使用的语言。</li>
<li>add_executable(TargetName source1 source2 …): 添加一个可执行目标，并指定其源文件。</li>
<li>add_library(TargetName type source1 source2 …): 添加一个库目标，并指定其类型（静态或动态）和源文件。</li>
<li>find_package(PackageName): 查找并加载外部依赖包。</li>
<li>target_link_libraries(TargetName library1 library2 …): 指定目标链接的库。</li>
<li>这些是最基础和最常用的指令，当然还有更多高级功能和指令可以使用。</li>
</ul>
<h2 id="在C-C-项目中经常会有很多依赖库，你通常是如何使用CMake来管理这些依赖的？"><a href="#在C-C-项目中经常会有很多依赖库，你通常是如何使用CMake来管理这些依赖的？" class="headerlink" title="在C&#x2F;C++项目中经常会有很多依赖库，你通常是如何使用CMake来管理这些依赖的？"></a>在C&#x2F;C++项目中经常会有很多依赖库，你通常是如何使用CMake来管理这些依赖的？</h2><ul>
<li>我通常会使用find_package命令来查找并加载外部依赖包。如果依赖的库是通过CMake构建的，那么它通常会提供CMake的配置文件，使得find_package可以直接找到并加载库。如果库没有提供CMake支持，我可能需要手动设置库的路径和链接库。一旦找到依赖库，我会使用target_link_libraries来链接库，并使用target_include_directories来添加头文件的搜索路径。</li>
</ul>
<h2 id="CMake的一个主要优势是能够生成跨平台的构建文件，你通常是如何确保你的CMake项目在不同平台上都能正确构建的？"><a href="#CMake的一个主要优势是能够生成跨平台的构建文件，你通常是如何确保你的CMake项目在不同平台上都能正确构建的？" class="headerlink" title="CMake的一个主要优势是能够生成跨平台的构建文件，你通常是如何确保你的CMake项目在不同平台上都能正确构建的？"></a>CMake的一个主要优势是能够生成跨平台的构建文件，你通常是如何确保你的CMake项目在不同平台上都能正确构建的？</h2><ul>
<li>为了确保构建的可移植性，我会避免使用平台特定的代码和构建设置。我会使用CMake提供的检查和配置功能来查询平台特性，并根据查询的结果来调整构建设置。例如，我可以使用check_function_exists来检查某个函数是否存在，然后根据结果定义宏来启用或禁用相关的代码。我还会确保使用CMake提供的命令来设置编译器标志和定义，而不是直接写死在CMakeLists.txt文件中</li>
</ul>
<h2 id="对于大型的C-C-项目，构建系统可能会变得非常复杂。你通常是如何组织和管理CMake构建系统的，以保持其可维护性？"><a href="#对于大型的C-C-项目，构建系统可能会变得非常复杂。你通常是如何组织和管理CMake构建系统的，以保持其可维护性？" class="headerlink" title="对于大型的C&#x2F;C++项目，构建系统可能会变得非常复杂。你通常是如何组织和管理CMake构建系统的，以保持其可维护性？"></a>对于大型的C&#x2F;C++项目，构建系统可能会变得非常复杂。你通常是如何组织和管理CMake构建系统的，以保持其可维护性？</h2><ul>
<li>对于大型项目，我会将构建系统分解为多个CMakeLists.txt文件，每个目录一个，以保持组织结构的清晰。我会利用add_subdirectory命令来包含子目录，这样每个子目录可以有其自己的CMakeLists.txt文件来管理其源文件和依赖关系。我还会使用CMake的函数和宏来封装重复的逻辑，以减少重复代码并提高可维护性。通过这种方式，我可以保持构建系统的清晰和可管理，即使项目规模很大。</li>
</ul>
<h2 id="在不同的开发阶段，我们可能需要使用不同的编译选项，比如在开发阶段开启调试信息，在发布阶段进行优化。请问你是如何使用CMake来管理这些编译选项的？"><a href="#在不同的开发阶段，我们可能需要使用不同的编译选项，比如在开发阶段开启调试信息，在发布阶段进行优化。请问你是如何使用CMake来管理这些编译选项的？" class="headerlink" title="在不同的开发阶段，我们可能需要使用不同的编译选项，比如在开发阶段开启调试信息，在发布阶段进行优化。请问你是如何使用CMake来管理这些编译选项的？"></a>在不同的开发阶段，我们可能需要使用不同的编译选项，比如在开发阶段开启调试信息，在发布阶段进行优化。请问你是如何使用CMake来管理这些编译选项的？</h2><ul>
<li>我通常会使用CMake的set命令来设置编译器标志，以及add_compile_options来添加编译选项。为了区分不同的构建类型（如Debug和Release），我会使用CMAKE_BUILD_TYPE变量，并根据这个变量的值来设置不同的编译选项。例如：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;-g&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;-O3&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>这样，在Debug构建中，-g选项会被添加到编译命令中，而在Release构建中，-O3选项会被添加。</li>
</ul>
<h2 id="在项目中，我们经常需要使用第三方库。请问你是如何在CMake中集成第三方库的？"><a href="#在项目中，我们经常需要使用第三方库。请问你是如何在CMake中集成第三方库的？" class="headerlink" title="在项目中，我们经常需要使用第三方库。请问你是如何在CMake中集成第三方库的？"></a>在项目中，我们经常需要使用第三方库。请问你是如何在CMake中集成第三方库的？</h2><ul>
<li>为了集成第三方库，我通常会首先使用find_package命令来查找库是否已经安装在系统中。</li>
<li>如果库提供了CMake配置文件，那么find_package会自动设置所有必要的变量和目标。</li>
<li>如果库没有提供CMake支持，我可能需要手动设置库的路径和链接选项。一旦找到库，我会使用target_link_libraries来链接库，并使用target_include_directories来添加头文件的搜索路径。</li>
<li>如果第三方库没有预先安装，或者我需要使用特定版本的库，我可能会将库的源代码包含在我的项目中，并使用add_subdirectory或ExternalProject_Add来构建和链接库。</li>
</ul>
<h2 id="随着项目规模的增加，构建速度可能会成为一个问题。你通常是如何优化CMake项目的构建速度的？"><a href="#随着项目规模的增加，构建速度可能会成为一个问题。你通常是如何优化CMake项目的构建速度的？" class="headerlink" title="随着项目规模的增加，构建速度可能会成为一个问题。你通常是如何优化CMake项目的构建速度的？"></a>随着项目规模的增加，构建速度可能会成为一个问题。你通常是如何优化CMake项目的构建速度的？</h2><ul>
<li>为了优化构建速度，我会使用一系列的策略：<ul>
<li>分离代码: 将项目分解为多个库和可执行文件，这样只有发生变化的部分需要被重新构建。</li>
<li>预编译头文件: 对于C++项目，使用预编译头文件可以显著减少编译时间。</li>
<li>并行构建: 使用make -j或其他构建工具的并行构建选项来利用多核CPU。</li>
<li>ccache: 使用ccache来缓存编译结果，避免重复编译。</li>
<li>优化编译选项: 谨慎使用编译优化选项，避免使用过度的优化，因为它们可能会增加编译时间。</li>
</ul>
</li>
</ul>
<h2 id="CMake支持跨平台构建，但不同平台上可能有不同的依赖和编译选项。你通常是如何管理这些差异的？"><a href="#CMake支持跨平台构建，但不同平台上可能有不同的依赖和编译选项。你通常是如何管理这些差异的？" class="headerlink" title="CMake支持跨平台构建，但不同平台上可能有不同的依赖和编译选项。你通常是如何管理这些差异的？"></a>CMake支持跨平台构建，但不同平台上可能有不同的依赖和编译选项。你通常是如何管理这些差异的？</h2><ul>
<li>为了管理不同平台上的差异，我会使用CMake的平台检查功能和条件语句。例如，我可以使用if(WIN32)来检查是否在Windows平台上构建，然后根据需要设置不同的编译选项或链接选项。我还可以使用CMAKE_SYSTEM_NAME变量来获取更具体的平台信息，并根据这些信息进行条件判断和配置。</li>
</ul>
<h2 id="在现代软件开发中，测试是非常重要的一部分。请问你是如何使用CMake来构建和运行测试的？"><a href="#在现代软件开发中，测试是非常重要的一部分。请问你是如何使用CMake来构建和运行测试的？" class="headerlink" title="在现代软件开发中，测试是非常重要的一部分。请问你是如何使用CMake来构建和运行测试的？"></a>在现代软件开发中，测试是非常重要的一部分。请问你是如何使用CMake来构建和运行测试的？</h2><ul>
<li>为了确保项目的可测试性，我会使用CMake的enable_testing和add_test命令来添加和管理测试。我会为项目中的每个测试用例创建一个可执行文件，并使用add_test来注册测试。然后，我可以使用ctest命令来运行所有的测试，并获取测试结果。</li>
<li>除了基本的测试注册和运行外，我还可以使用set_tests_properties来设置测试属性，如超时时间、所需的环境变量等。如果我的项目使用了Google Test或者其他测试框架，我还可以集成这些框架的CMake模块，以更方便地添加和运行测试。</li>
</ul>
<h2 id="Modern-CMake推荐使用目标和属性来管理构建设置。请问你是如何在你的项目中使用这些特性的？"><a href="#Modern-CMake推荐使用目标和属性来管理构建设置。请问你是如何在你的项目中使用这些特性的？" class="headerlink" title="Modern CMake推荐使用目标和属性来管理构建设置。请问你是如何在你的项目中使用这些特性的？"></a>Modern CMake推荐使用目标和属性来管理构建设置。请问你是如何在你的项目中使用这些特性的？</h2><ul>
<li>在Modern CMake中，我会尽量使用目标和属性来代替全局变量和目录级的设置。这样可以使构建设置更加清晰和可维护。我会使用add_executable和add_library来创建目标，然后使用target_include_directories, target_compile_definitions, target_compile_options, 和 target_link_libraries来设置目标的包含目录、编译定义、编译选项和链接库。</li>
<li>我还会利用接口库来创建可复用的编译设置和编译定义，这样我就可以通过target_link_libraries来应用这些设置。</li>
</ul>
<h2 id="代码格式化是保持代码一致性和可读性的重要手段。请问你是如何在CMake项目中集成代码格式化工具，如ClangFormat，的？"><a href="#代码格式化是保持代码一致性和可读性的重要手段。请问你是如何在CMake项目中集成代码格式化工具，如ClangFormat，的？" class="headerlink" title="代码格式化是保持代码一致性和可读性的重要手段。请问你是如何在CMake项目中集成代码格式化工具，如ClangFormat，的？"></a>代码格式化是保持代码一致性和可读性的重要手段。请问你是如何在CMake项目中集成代码格式化工具，如ClangFormat，的？</h2><ul>
<li>我通常会使用find_program来查找ClangFormat可执行文件的路径，然后使用add_custom_target或add_custom_command来定义一个自定义目标或命令，用于运行ClangFormat来格式化源代码。例如：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_program</span>(CLANG_FORMAT <span class="string">&quot;clang-format&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(CLANG_FORMAT)</span><br><span class="line">    <span class="keyword">add_custom_target</span>(</span><br><span class="line">        format</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">$&#123;CLANG_FORMAT&#125;</span></span><br><span class="line">        -i</span><br><span class="line">        <span class="variable">$&#123;SOURCE_FILES&#125;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li>
<li>这样，我就可以通过运行make format或者cmake –build . –target format来格式化项目中的源代码</li>
</ul>
<h2 id="静态代码分析可以帮助我们发现代码中的潜在问题。请问你是如何在CMake项目中集成静态代码分析工具的？"><a href="#静态代码分析可以帮助我们发现代码中的潜在问题。请问你是如何在CMake项目中集成静态代码分析工具的？" class="headerlink" title="静态代码分析可以帮助我们发现代码中的潜在问题。请问你是如何在CMake项目中集成静态代码分析工具的？"></a>静态代码分析可以帮助我们发现代码中的潜在问题。请问你是如何在CMake项目中集成静态代码分析工具的？</h2><ul>
<li>我通常会使用类似于格式化工具的方法来集成静态代码分析工具。例如，对于Clang Static Analyzer，我可以使用scan-build命令来运行分析器。我会创建一个自定义目标或命令来运行scan-build，并将其配置为在构建过程中运行</li>
<li>对于其他静态代码分析工具，我可能还会设置相应的CMake变量来启用编译器的静态分析功能，或者使用工具提供的CMake模块（如果有的话）。</li>
</ul>
<h2 id="测试覆盖率是衡量测试完整性的一个重要指标。请问你是如何在CMake项目中集成测试覆盖率工具的？"><a href="#测试覆盖率是衡量测试完整性的一个重要指标。请问你是如何在CMake项目中集成测试覆盖率工具的？" class="headerlink" title="测试覆盖率是衡量测试完整性的一个重要指标。请问你是如何在CMake项目中集成测试覆盖率工具的？"></a>测试覆盖率是衡量测试完整性的一个重要指标。请问你是如何在CMake项目中集成测试覆盖率工具的？</h2><ul>
<li>为了集成测试覆盖率工具，我通常会在CMake中设置相应的编译器标志来启用覆盖率数据的生成。对于GCC和Clang，我可以使用–coverage选项。然后，我会创建一个自定义目标或命令来运行测试覆盖率工具，如gcov或llvm-cov，并生成覆盖率报告<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(COVERAGE)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; --coverage&quot;</span>)</span><br><span class="line">    <span class="keyword">add_custom_target</span>(coverage</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E env <span class="string">&quot;COVERAGE_FILE=$&#123;PROJECT_BINARY_DIR&#125;/coverage.info&quot;</span></span><br><span class="line">        <span class="variable">$&#123;CMAKE_CTEST_COMMAND&#125;</span> --force-new-ctest-process</span><br><span class="line">        <span class="keyword">COMMAND</span> lcov --capture --directory . --output-<span class="keyword">file</span> coverage.info</span><br><span class="line">        <span class="keyword">COMMAND</span> genhtml coverage.info --output-directory out</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li>
<li>这样，我就可以通过运行make coverage来运行测试并生成测试覆盖率报告</li>
</ul>
<h2 id="文档是任何项目不可或缺的一部分。请问你是如何在CMake项目中集成文档生成工具，如Doxygen，的？"><a href="#文档是任何项目不可或缺的一部分。请问你是如何在CMake项目中集成文档生成工具，如Doxygen，的？" class="headerlink" title="文档是任何项目不可或缺的一部分。请问你是如何在CMake项目中集成文档生成工具，如Doxygen，的？"></a>文档是任何项目不可或缺的一部分。请问你是如何在CMake项目中集成文档生成工具，如Doxygen，的？</h2><ul>
<li>我会使用find_package来查找Doxygen，并使用doxygen_add_docs来添加一个目标，用于生成文档。例如<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Doxygen)</span><br><span class="line"><span class="keyword">if</span>(DOXYGEN_FOUND)</span><br><span class="line">    doxygen_add_docs(</span><br><span class="line">        docs</span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src</span><br><span class="line">        COMMENT <span class="string">&quot;Generate documentation&quot;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li>
<li>这样，我就可以通过运行make docs来生成项目的文档。</li>
</ul>
<h2 id="在使用CMake进行项目构建时，我们有时会遇到各种构建错误。请问你通常是如何调试这些构建错误的？"><a href="#在使用CMake进行项目构建时，我们有时会遇到各种构建错误。请问你通常是如何调试这些构建错误的？" class="headerlink" title="在使用CMake进行项目构建时，我们有时会遇到各种构建错误。请问你通常是如何调试这些构建错误的？"></a>在使用CMake进行项目构建时，我们有时会遇到各种构建错误。请问你通常是如何调试这些构建错误的？</h2><ul>
<li>当我遇到CMake构建错误时，我通常会遵循以下步骤进行调试：<ul>
<li>查看错误信息：仔细阅读CMake或编译器提供的错误信息和警告，这通常会指向问题的根源。</li>
<li>增加消息输出：使用message()函数在CMakeLists.txt文件中添加打印语句，以输出变量的值或显示代码执行的流程，帮助定位问题。</li>
<li>检查路径和变量：确保所有的路径、文件名和变量设置都是正确的，特别是在使用相对路径或者环境变量时。</li>
<li>分阶段构建：逐步执行CMake配置和构建过程，尝试定位问题发生的具体阶段。</li>
<li>查阅文档和社区帮助：查阅CMake的官方文档，或者在Stack Overflow等社区寻找类似问题的解决方案。</li>
<li>简化CMakeLists.txt：临时删除或注释掉一部分代码，逐步缩小问题范围，直到找到问题的根源。</li>
</ul>
</li>
<li>通过这些方法，我通常能够有效地定位并解决CMake构建过程中的问题。</li>
</ul>
<h2 id="CMake经常更新，引入新的特性和改进。请问你是如何确保你的CMake项目能够在不同版本的CMake上都能正常工作的？"><a href="#CMake经常更新，引入新的特性和改进。请问你是如何确保你的CMake项目能够在不同版本的CMake上都能正常工作的？" class="headerlink" title="CMake经常更新，引入新的特性和改进。请问你是如何确保你的CMake项目能够在不同版本的CMake上都能正常工作的？"></a>CMake经常更新，引入新的特性和改进。请问你是如何确保你的CMake项目能够在不同版本的CMake上都能正常工作的？</h2><ul>
<li>为了确保CMake项目的跨版本兼容性，我会遵循以下几个原则：<ul>
<li>使用版本检查：在CMakeLists.txt文件的开始使用cmake_minimum_required指令来指定项目所需的最低CMake版本。</li>
<li>避免使用废弃的特性：避免使用在新版本中已被废弃的函数和变量，以防它们在未来版本中被移除。</li>
<li>测试多个CMake版本：在不同版本的CMake上测试项目的构建过程，确保兼容性。</li>
<li>文档说明：在项目文档中明确说明支持的CMake版本范围。</li>
</ul>
</li>
<li>通过这些方法，我可以最大程度地确保项目在不同版本的CMake上都能正常工作。</li>
</ul>
<h2 id="在大型项目中，CMake代码可能会变得非常复杂。请问你是如何管理这些复杂的CMake代码，确保其可维护性的？"><a href="#在大型项目中，CMake代码可能会变得非常复杂。请问你是如何管理这些复杂的CMake代码，确保其可维护性的？" class="headerlink" title="在大型项目中，CMake代码可能会变得非常复杂。请问你是如何管理这些复杂的CMake代码，确保其可维护性的？"></a>在大型项目中，CMake代码可能会变得非常复杂。请问你是如何管理这些复杂的CMake代码，确保其可维护性的？</h2><ul>
<li>为了管理大型项目中的复杂CMake代码并确保其可维护性，我会采取以下策略：<ul>
<li>模块化设计：将CMake代码分解为多个模块，每个模块负责一个特定的功能或组件。</li>
<li>使用函数和宏：将重复的代码封装到函数或宏中，减少代码冗余。</li>
<li>代码注释：在CMake代码中添加充足的注释，解释复杂的逻辑和重要的决策。</li>
<li>遵循编码规范：制定并遵循一套CMake代码的编码规范，确保代码风格的一致性。</li>
<li>定期代码审查：定期进行代码审查，确保代码质量并分享最佳实践。</li>
<li>文档化：创建详细的文档，描述CMake代码的结构、功能和使用方法。</li>
</ul>
</li>
<li>通过这些方法，我可以确保即使在大型项目中，CMake代码也能保持清晰、可维护和易于理解。</li>
</ul>
<h2 id="在软件开发中，确保项目的安全性是非常重要的。请问你是如何确保你的CMake项目的安全性的？"><a href="#在软件开发中，确保项目的安全性是非常重要的。请问你是如何确保你的CMake项目的安全性的？" class="headerlink" title="在软件开发中，确保项目的安全性是非常重要的。请问你是如何确保你的CMake项目的安全性的？"></a>在软件开发中，确保项目的安全性是非常重要的。请问你是如何确保你的CMake项目的安全性的？</h2><ul>
<li>为了确保CMake项目的安全性，我会注意以下几点：<ul>
<li><strong>避免使用不安全的函数和命令</strong>：避免使用可能引入安全漏洞的CMake命令和函数。</li>
<li>检查依赖库的安全性：定期检查项目依赖的第三方库，确保它们是最新的，并且没有已知的安全漏洞。</li>
<li>使用安全的编译选项：使用编译器提供的安全相关编译选项，如栈保护等。</li>
<li>代码审计：定期进行代码审计，检查可能的安全漏洞。</li>
</ul>
</li>
<li>通过这些方法，我可以提高CMake项目的安全性，防范可能的安全威胁。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/CMake/cmake_99_%E5%85%B6%E4%BB%96/2024-05-22-cmake_3_%E6%9D%82%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/CMake/cmake_99_%E5%85%B6%E4%BB%96/2024-05-22-cmake_3_%E6%9D%82%E9%A1%B9/" class="post-title-link" itemprop="url">cmake_3_杂项</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="cmake自定义模块-Module"><a href="#cmake自定义模块-Module" class="headerlink" title="cmake自定义模块(Module)"></a>cmake自定义模块(Module)</h3><ul>
<li>项目一般从CMakelists.txt开始编写，但是随着时间的推移，CMakeLists.txt文件会变得越来越大，这个时候我们就需要将CMakeLists.txt文件拆开分成几个小的模块，这样做的好处是<ul>
<li>主文件CMakeList.txt易读性强</li>
<li>CMake模块能够在其他项目中重复使用</li>
<li>和CMake的函数相比，模块能够帮助我们限制变量的作用域</li>
</ul>
</li>
</ul>
<h3 id="cmake-指定C-版本"><a href="#cmake-指定C-版本" class="headerlink" title="cmake 指定C++版本"></a>cmake 指定C++版本</h3><ul>
<li><p>在 CmakeLists.txt 中增加对 C++ 版本的定义。方法如下：</p>
<ul>
<li><code>SET(CMAKE_CXX_STANDARD 11)</code></li>
</ul>
</li>
<li><p>生成 Makefile 的时候指定,方法如下:</p>
<ul>
<li><code>cmake -DCMAKE_CXX_STANDARD=11 ..</code></li>
</ul>
</li>
</ul>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul>
<li>foreach:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set(VAR a b c)</span><br><span class="line"> </span><br><span class="line">foreach(f $&#123;VAR&#125;)</span><br><span class="line">  message($&#123;f&#125;)</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="cmake-加入调试信息"><a href="#cmake-加入调试信息" class="headerlink" title="cmake 加入调试信息"></a>cmake 加入调试信息</h3><ul>
<li>首先，加入：<code>SET(CMAKE_BUILD_TYPE &quot;Debug&quot;)</code></li>
<li>然后在下面加入：<ul>
<li><code>SET(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb&quot;)</code></li>
<li><code>SET(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;)</code></li>
</ul>
</li>
</ul>
<h3 id="execute-process"><a href="#execute-process" class="headerlink" title="execute_process()"></a>execute_process()</h3><ul>
<li><p>execute_process 命令将从当前正在执行的CMake进程中派生一个或多个子进程，从而提供了在配置项目时运行任意命令的方法。可以在一次调用 execute_process 时执行多个命令。但请注意，每个命令的输出将通过管道传输到下一个命令中。该命令接受多个参数：</p>
<ul>
<li><code>COMMAND</code>：子进程命令行。</li>
<li><code>WORKING_DIRECTORY</code>：指定应该在哪个目录中执行命令。</li>
<li><code>TIMEOUT</code>：如果在指定的时间内（以秒为单位计算，允许有小数位）子进程执行仍未完成，则将会被中断。</li>
<li><code>RESULT_VARIABLE</code>：包含进程运行的结果。这要么是一个整数表示执行成功，要么是一个带有错误条件的字符串。</li>
<li><code>RESULTS_VARIABLE</code>：变量将被设置为以分号分隔的列表形式包含所有进程的结果，按给定命令参数的顺序排列。每个条目都是对应子项的整数返回码或描述错误条件的字符串。</li>
<li><code>OUTPUT_VARIABLE</code>和<code>ERROR_VARIABLE</code>将包含执行命令的标准输出和标准错误。由于命令的输出是通过管道传输的，因此只有最后一个命令的标准输出才会保存到OUTPUT_VARIABLE中。</li>
<li><code>INPUT_FILE</code> 指定标准输入重定向的文件名。</li>
<li><code>OUTPUT_FILE</code> 指定标准输出重定向的文件名。</li>
<li><code>ERROR_FILE</code> 指定标准错误输出重定向的文件名</li>
<li><code>设置OUTPUT_QUIET和ERROR_QUIET</code>后，CMake将静默地忽略标准输出和标准错误。</li>
<li><code>COMMAND_ECHO &lt;where&gt;</code>：正在运行的命令将被回送到<code>&lt;where&gt;</code>，而<code>&lt;where&gt;</code>将被设置为STDERR、STDOUT或NONE中的一个。</li>
<li><code>设置OUTPUT_STRIP_TRAILING_WHITESPACE</code>，可以删除运行命令的标准输出中的任何尾随空 格。</li>
<li><code>设置ERROR_STRIP_TRAILING_WHITESPACE</code>，可以删除运行命令的错误输出中的任何尾随空格。</li>
<li><code>ENCODING &lt;name&gt;</code>：适用于windows平台，编码名称有NONE、AUTO、ANSI、OEM、UTF8或UTF-8。</li>
<li><code>ECHO_OUTPUT_VARIABLE, ECHO_ERROR_VARIABLE</code>：标准输出或标准错误不会被专门重定向到配置的变量。</li>
<li><code>COMMAND_ERROR_IS_FATAL &lt;ANY|LAST&gt;</code>：<ul>
<li><code>ANY</code>：如果命令列表中的任何命令失败，<code>execute_process（）</code>命令将因错误而停止。</li>
<li><code>LAST</code>：如果命令列表中的最后一个命令失败，则<code>execute_process（）</code>命令会因错误而停止。列表中前面的命令不会导致致命错误。</li>
</ul>
</li>
<li>如果在同一管道中同时指定了多个<code>OUTPUT_*</code>或<code>ERROR_*</code>选项，则优先级顺序是未知的（应避免这种情况）。</li>
<li>如果未指定任何<code>OUTPUT_*</code>或<code>ERROR_*</code>选项，则命令CMake所在进程共享输出管道。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">execute_process(</span><br><span class="line">  COMMAND</span><br><span class="line">    $&#123;PYTHON_EXECUTABLE&#125; &quot;-c&quot; &quot;import $&#123;_module_name&#125;; print($&#123;_module_name&#125;.__version__)&quot;</span><br><span class="line">  OUTPUT_VARIABLE _stdout</span><br><span class="line">  ERROR_VARIABLE _stderr</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  ERROR_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="CMake-定义宏"><a href="#CMake-定义宏" class="headerlink" title="CMake 定义宏"></a>CMake 定义宏</h3><h4 id="add-definitions"><a href="#add-definitions" class="headerlink" title="add_definitions()"></a><code>add_definitions()</code></h4><ul>
<li><p>采用<code>add_definitions</code>定义宏，对于无值宏：</p>
<ul>
<li><code>add_definitions(-DMG_ENABLE_OPENSSL)</code></li>
</ul>
</li>
<li><p>对应于C语言中的</p>
<ul>
<li><code>#define MG_ENABLE_OPENSSL</code></li>
</ul>
</li>
<li><p>而对于有值宏：</p>
<ul>
<li><code>add_definitions(-DLIBEVENT_VERSION_NUMBER=0x02010800)</code></li>
</ul>
</li>
<li><p>对应于C语言：</p>
<ul>
<li><code>#define LIBEVENT_VERSION_NUMBER 0x02010800</code></li>
</ul>
</li>
</ul>
<h4 id="add-compile-definitions"><a href="#add-compile-definitions" class="headerlink" title="add_compile_definitions()"></a><code>add_compile_definitions()</code></h4><ul>
<li><code>add_compile_definitions</code>定义宏，但是这个指令只要高版本的cmake支持，所以推荐使用第1种，比如：<ul>
<li><code>add_compile_definitions(MG_ENABLE_OPENSSL=1)</code></li>
</ul>
</li>
<li>对应于C语言中的<ul>
<li><code>#define MG_ENABLE_OPENSSL 1</code></li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>CMakeLists.txt 文件中定义的宏在后面C&#x2F;C++程序中是可以直接使用的</li>
</ul>
<h3 id="CMake-调试"><a href="#CMake-调试" class="headerlink" title="CMake 调试"></a>CMake 调试</h3><ul>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">include(CMakePrintHelpers)</span><br><span class="line"># 打印变量 PROJECT_SOURCE_DIR</span><br><span class="line">cmake_print_variables(PROJECT_SOURCE_DIR)</span><br><span class="line"></span><br><span class="line">cmake_print_properties(TARGETS arwen-webserver PROPERTIES POSITION_INDEPENDENT_CODE)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="CMake-常用命令"><a href="#CMake-常用命令" class="headerlink" title="CMake 常用命令"></a>CMake 常用命令</h2><h3 id="aux-source-directory"><a href="#aux-source-directory" class="headerlink" title="aux_source_directory()"></a>aux_source_directory()</h3><ul>
<li>简介：查找在某个路径下的所有源文件。<ul>
<li>搜集所有在指定路径下的源文件的文件名，将输出结果列表储存在指定的变量中。</li>
<li>该命令主要用在那些使用显式模板实例化的工程上。模板实例化文件可以存储在Templates子目录下，然后可以使用这条命令自动收集起来；这样可以避免手工罗列所有的实例。</li>
</ul>
</li>
<li>语法：<code>aux_source_directory(&lt; dir &gt; &lt; variable &gt;)</code></li>
</ul>
<h3 id="add-executable"><a href="#add-executable" class="headerlink" title="add_executable()"></a>add_executable()</h3><ul>
<li>简介：使用指定的源文件来生成目标可执行文件。这里的目标可执行文件分为三类：普通可执行目标文件、导入可执行目标文件、别名可执行目标文件。分别对应下面的三种命令格式。</li>
<li>语法：<ul>
<li><code>add_executable (&lt;name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [source1] [source2 ...])</code></li>
<li><code>add_executable (&lt;name&gt; IMPORTED [GLOBAL])</code></li>
<li><code>add_executable (&lt;name&gt; ALIAS &lt;target&gt;)</code></li>
</ul>
</li>
</ul>
<h2 id="CMake-常用操作"><a href="#CMake-常用操作" class="headerlink" title="CMake 常用操作"></a>CMake 常用操作</h2><h3 id="生成动态库或静态库"><a href="#生成动态库或静态库" class="headerlink" title="生成动态库或静态库"></a>生成动态库或静态库</h3><p>+ </p>
<h3 id="添加动态链接库"><a href="#添加动态链接库" class="headerlink" title="添加动态链接库"></a>添加动态链接库</h3><ul>
<li><p>如果使用gcc进行单个c文件编译的时候，有时候后面会需要添加如-L -l之类的参数，如下</p>
<ul>
<li><code>gcc -o test test.c -L/usr/local/lib/ -lopencv</code></li>
</ul>
</li>
<li><p>在这里</p>
<ul>
<li><code>-L</code>是制定动态库的位置，</li>
<li><code>-l</code>则是指定打算连接的动态库名字</li>
</ul>
</li>
<li><p>那么在进行项目编译的时候就需要通过cmake来通过Cmakelist.txt引导make进行项目编译。</p>
</li>
<li><p>那么就需要在cmakelists.txt文件内添加动态链接库的配置，具体参数如下</p>
<ul>
<li>首先申明动态库的位置,<code>LINK_DIRECTORIES(&#123;your_library_path&#125;)</code>，例如：<ul>
<li><code>LINK_DIRECTORIES(/usr/local/lib)</code></li>
</ul>
</li>
<li>然后制定具体的动态库的名称, <code>target_link_libraries($&#123;PROJECT_NAME&#125; -l&#123;library_name&#125;)</code>，例如：<ul>
<li>指定hiredis的动态链接文件 libhiredis.dylib ： <code>target_link_libraries($&#123;PROJECT_NAME&#125; -lhiredis)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="引入外部静态库"><a href="#引入外部静态库" class="headerlink" title="引入外部静态库"></a>引入外部静态库</h3><ul>
<li><p><code>include_directories($&#123;ROOT_DIR&#125;/3party/include)</code></p>
<ul>
<li>用于指定头文件的搜索路径</li>
</ul>
</li>
<li><p><code>link_directories($&#123;ROOT_DIR&#125;/3party/lib)</code></p>
<ul>
<li>指定静态库或者动态库的搜索路径</li>
</ul>
</li>
<li><p><code>target_link_libraries(sample libmath.a)</code></p>
<ul>
<li>指定要连接的静态库，必须要有，第二个参数也可以换成math，那么将自动去搜索libmath.a或者libmath.so或者libmath.dyld动态库</li>
</ul>
</li>
</ul>
<h2 id="arwen-机械臂项目-CMakeLists-txt-笔记"><a href="#arwen-机械臂项目-CMakeLists-txt-笔记" class="headerlink" title="arwen 机械臂项目 CMakeLists.txt 笔记"></a>arwen 机械臂项目 CMakeLists.txt 笔记</h2><h3 id="cmake-minimum-required"><a href="#cmake-minimum-required" class="headerlink" title="cmake_minimum_required()"></a>cmake_minimum_required()</h3><ul>
<li>为项目设置cmake的最低要求版本</li>
<li>示例：<ul>
<li><code>cmake_minimum_required(VERSION 3.10)</code></li>
</ul>
</li>
</ul>
<h3 id="project"><a href="#project" class="headerlink" title="project()"></a>project()</h3><ul>
<li>为整个项目设置名称、版本并启用语言</li>
<li>示例：<ul>
<li><code>project(arwen)</code></li>
</ul>
</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><ul>
<li>将常规变量、缓存变量或环境变量设置为给定值。</li>
<li>示例：<ul>
<li><code>set(CMAKE_CXX_STANDARD 17)</code></li>
</ul>
</li>
</ul>
<h3 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories()"></a>include_directories()</h3><ul>
<li>向构建中添加包含目录</li>
<li>示例：<ul>
<li><code>include_directories(./include)</code></li>
</ul>
</li>
</ul>
<h3 id="PROJECT-SOURCE-DIR"><a href="#PROJECT-SOURCE-DIR" class="headerlink" title="${PROJECT_SOURCE_DIR}"></a>${PROJECT_SOURCE_DIR}</h3><ul>
<li>内置变量，当前项目的顶级源目录。</li>
</ul>
<h3 id="PROJECT-BINARY-DIR"><a href="#PROJECT-BINARY-DIR" class="headerlink" title="${PROJECT_BINARY_DIR}"></a>${PROJECT_BINARY_DIR}</h3><ul>
<li>内置变量，为项目构建目录的完整路径(Full path to build directory for project.)</li>
</ul>
<h3 id="execute-process-1"><a href="#execute-process-1" class="headerlink" title="execute_process()"></a>execute_process()</h3><ul>
<li>执行一个或多个子进程</li>
<li>示例：<ul>
<li><code>execute_process( COMMAND $&#123;CMAKE_COMMAND&#125; -E make_directory $&#123;LOG_DIR&#125;)</code></li>
</ul>
</li>
</ul>
<h3 id="CMAKE-COMMAND"><a href="#CMAKE-COMMAND" class="headerlink" title="${CMAKE_COMMAND}"></a>${CMAKE_COMMAND}</h3><ul>
<li>可执行文件“cmake(1)”的完整路径</li>
</ul>
<h3 id="add-subdirectory"><a href="#add-subdirectory" class="headerlink" title="add_subdirectory()"></a>add_subdirectory()</h3><ul>
<li>向构建中添加子目录。</li>
<li>示例：<ul>
<li><code>add_subdirectory(src)</code></li>
</ul>
</li>
</ul>
<h3 id="file"><a href="#file" class="headerlink" title="file()"></a>file()</h3><ul>
<li>文件操作命令</li>
<li>规则：<ul>
<li><code>file(WRITE &lt;filename&gt; &lt;content&gt;...)</code></li>
<li><code>file(APPEND &lt;filename&gt; &lt;content&gt;...)</code></li>
</ul>
</li>
<li>详解：<ul>
<li>将<code>&lt;content&gt;</code>写入名为<code>&lt;filename&gt;</code>的文件中。如果这个文件不存在，则创建该文件。如果该文件已经存在，则<code>WRITE</code>模式下将会覆盖该文件，<code>APPEND</code>模式下将会追加到该文件的末尾.由<code>&lt;filename&gt;</code>指定的路径中任何不存在的目录将被创建</li>
<li>如果文件是一个构建输入，使用<code>configure_file()</code>命令仅在其内容更改时更新文件。</li>
</ul>
</li>
</ul>
<h3 id="add-library"><a href="#add-library" class="headerlink" title="add_library()"></a>add_library()</h3><ul>
<li>该指令的主要作用就是将指定的源文件生成链接文件，然后添加到工程中去。该指令常用的语法如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_library(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">            [EXCLUDE_FROM_ALL]</span><br><span class="line">            [source1] [source2] [...])</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>其中<code>&lt;name&gt;</code>表示库文件的名字，该库文件会根据命令里列出的源文件来创建。</li>
<li>而<code>STATIC</code>、<code>SHARED</code>和<code>MODULE</code>的作用是指定生成的库文件的类型。<ul>
<li><code>STATIC</code>库是目标文件的归档文件，在链接其它目标的时候使用。</li>
<li><code>SHARED</code>库会被动态链接（动态链接库），在运行时会被加载。</li>
<li><code>MODULE</code>库是一种不会被链接到其它目标中的插件，但是可能会在运行时使用dlopen-系列的函数。</li>
<li>默认状态下，库文件将会在于源文件目录树的构建目录树的位置被创建，该命令也会在这里被调用</li>
</ul>
</li>
<li>而语法中的<code>source1</code> <code>source2</code>分别表示各个源文件。</li>
</ul>
</li>
<li>使用指定的源文件向项目添加库</li>
<li>示例：<ul>
<li><code>add_library($&#123;PROJECT_NAME&#125; STATIC  $&#123;SOURCE_FILES&#125;)</code></li>
</ul>
</li>
</ul>
<h3 id="link-directories"><a href="#link-directories" class="headerlink" title="link_directories()"></a>link_directories()</h3><ul>
<li>该指令的作用主要是指定要链接的库文件的路径，该指令有时候不一定需要。因为find_package和find_library指令可以得到库文件的绝对路径。该指令的常用语法如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">link_directories(</span><br><span class="line">    lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>不过你自己写的动态库文件放在自己新建的目录下时，可以用该指令指定该目录的路径以便工程能够找到。</li>
<li>指定链接器将在其中查找库的目录</li>
<li>示例：<ul>
<li><code>link_directories($&#123;PROJECT_BINARY_DIR&#125;/lib)</code></li>
</ul>
</li>
</ul>
<h3 id="target-link-libraries"><a href="#target-link-libraries" class="headerlink" title="target_link_libraries()"></a>target_link_libraries()</h3><ul>
<li>该指令的作用为将目标文件与库文件进行链接。该指令的语法如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(&lt;target&gt; [item1] [item2] [...]</span><br><span class="line">                      [[debug|optimized|general] &lt;item&gt;] ...)</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>指令中的<code>&lt;target&gt;</code>是指通过<code>add_executable()</code>和<code>add_library()</code>指令生成已经创建的目标文件。</li>
<li>而<code>[item]</code>表示库文件没有后缀的名字。默认情况下，库依赖项是传递的。当这个目标链接到另一个目标时，链接到这个目标的库也会出现在另一个目标的连接线上。</li>
<li>这个传递的接口存储在<code>interface_link_libraries</code>的目标属性中，可以通过设置该属性直接重写传递接口。</li>
</ul>
</li>
<li>指定链接给定目标和&#x2F;或其依赖项时要使用的库或标志</li>
<li>示例：<ul>
<li><code>target_link_libraries($&#123;PROJECT_NAME&#125; PUBLIC $&#123;Etherlab_LIBRARIES&#125;)</code></li>
</ul>
</li>
</ul>
<h3 id="target-include-directories"><a href="#target-include-directories" class="headerlink" title="target_include_directories()"></a>target_include_directories()</h3><ul>
<li>向目标添加包含目录</li>
<li>示例：<ul>
<li><code>target_include_directories( $&#123;PROJECT_NAME&#125; PUBLIC $&#123;PRJECT_SOURCE_DIR&#125;)</code></li>
</ul>
</li>
</ul>
<h3 id="find-package"><a href="#find-package" class="headerlink" title="find_package()"></a>find_package()</h3><ul>
<li>加载外部项目的设置。</li>
<li>示例：<ul>
<li><code>find_package(Etherlab REQUIRED)</code></li>
</ul>
</li>
</ul>
<h3 id="set-target-properties"><a href="#set-target-properties" class="headerlink" title="set_target_properties()"></a>set_target_properties()</h3><ul>
<li>目标可以具有影响如何构建它们的属性。</li>
<li>示例：<ul>
<li><code>set_target_properties(arwen-planning PROPERTIES LINKER_LANGUAGE CXX)</code></li>
</ul>
</li>
</ul>
<h1 id="modern-cmake-3-11"><a href="#modern-cmake-3-11" class="headerlink" title="modern cmake &gt;&#x3D; 3.11"></a>modern cmake &gt;&#x3D; 3.11</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul>
<li>CMake可以编译源代码,制作程序库,产生适配器(wrapper),可以用任意的顺序构建执行档</li>
<li>CMake支持in-place建构(二进档和源代码在同一个目录树中)和out-of-place构建(二进档在别的目录里),因此可以很容易从一个源代码目录树中建构出多个二进档.</li>
<li>CMake也支持静态与动态程式库的建构</li>
<li>CMake是一种工具,它读入用于描述软件如何构建的脚本,CMake将评估这些脚本并构建出表达软件项目的内部结构,如果它处理完这些脚本并没有发现错误,CMake将生成用于实际构建项目的构建文件(可能是脚本或者IDE工程文件)</li>
<li>CMake支持多种构建工具,包括一系列命令行构建工具和主流IDE,运行cmake –help可以看到在当前平台下CMake所支持的构建工具.</li>
<li>CMake中将这些构建系统称作generator.<strong>因此,CMake不是构建系统,而是构建系统生成器,具体的构建工作还是要交给Make, Ninja等构建系统去做</strong></li>
<li>运行CMake时,它会运行多项检查,在检查和评估构建脚本期间,它会将一些值缓存到CMakeCache.txt当中,这让我们在增量式开发中,可以跳过长时间的检查过程,但是CMake的缓存也会带来一些问题,比如:修改了某些配置没有办法及时的反映在下次构建中,所以有时构建出问题可以尝试删除CMake缓存文件后重新构建</li>
</ul>
<p>什么是CMakeList.txt文件?</p>
<ul>
<li>放置所有CMake命令的文件,当cmake在某个文件夹下运行时,会寻找该文件,如果找不到则报错</li>
</ul>
<p>为什么要使用cmake?</p>
<ul>
<li>跨平台</li>
<li>可配置</li>
<li>众多开源项目都只支持(或仅支持)CMake构建</li>
</ul>
<h2 id="构建CMake项目"><a href="#构建CMake项目" class="headerlink" title="构建CMake项目"></a>构建CMake项目</h2><p>CMake构建的两种形式:就地构建(in-source)和源码外构建(out-of-source)</p>
<ul>
<li>就地构建:在源文件目录下构建,产生的二进制文件将于源文件生成在一个文件夹里</li>
<li>源码外构建:单独创建一个build文件夹,在该文件夹下构建二进制文件,与源代码文件分开</li>
</ul>
<p>源码树和构建树</p>
<ul>
<li>源码树是源代码目录,里面放着源代码文件和CMakeLists.txt文件</li>
<li>构建树就是存放构建系统文件和输出文件的目录</li>
<li>通过变量<code>CMAKE_BINARY_DIR</code>访问到构建树的顶层文件夹(执行cmake命令的目录)</li>
<li>通过变量<code>CMAKE_SOURCE_DIR</code>访问到源码树的顶层文件夹(根CMakeLists.txt文件所在的目录).</li>
<li>注:对于就地构建,源码树和构建树是等价的</li>
</ul>
<p>CMake的执行过程分为三个阶段:<br>英文:</p>
<ol>
<li><strong>Configure</strong>:  <ul>
<li>Parse top level CMakeLists.txt, </li>
<li>Generates cache variables, </li>
<li>Only relevant in GUI builds</li>
</ul>
</li>
<li><strong>Generate</strong>:<ul>
<li>Generate native build tool files, </li>
<li>Can do cross compilation passing toolchain files</li>
</ul>
</li>
<li><strong>Build</strong>:<ul>
<li>Uses native build tools to compile the sources, </li>
<li>All it takes is cmake –build<br>中文:</li>
</ul>
</li>
<li>配置阶段:<ul>
<li>CMake将解析源码树顶层的<code>CMakeLists.txt</code>,并生成一个<code>CMakeCache.txt</code>以存储cache变量</li>
<li>对于CMake-GUI,该阶段由点击Configure出发,</li>
<li>对于命令版本的CMake,该阶段与生成阶段结合在一起</li>
<li>CMake打印消息:<code>Configuring done</code>以表示配置阶段结束</li>
</ul>
</li>
<li>生成阶段:<ul>
<li>CMake将根据<code>CMakeLists.txt</code>和<code>CMakeCache.txt</code>生成构建系统文件</li>
<li>在CMake-GUI中,该阶段由点击Generate出发</li>
<li>CMake打印消息<code>Generating done</code>以表示生成阶段结束</li>
</ul>
</li>
<li>构建阶段:<ul>
<li>这一阶段由构建系统负责,在这个阶段中将生成项目的目标</li>
</ul>
</li>
</ol>
<h2 id="CMake-基础"><a href="#CMake-基础" class="headerlink" title="CMake 基础"></a>CMake 基础</h2><ul>
<li>在经过一番搜索和学习，我开始了解 Modern CMake 的一些用法与理念，它主张放弃传统的基于变量的方法，而采用基于 target 的结构化模式，使其成为一个更可维护、更直观、更易集成、更具意义的方案。</li>
</ul>
<h3 id="1-1-Modern-CMake-介绍"><a href="#1-1-Modern-CMake-介绍" class="headerlink" title="1.1 Modern CMake 介绍"></a>1.1 Modern CMake 介绍</h3><ul>
<li><p>这部分内容是 <code>An Introduction to Modern CMake</code> 的总结，并不会讲的非常详细，希望通过几句话来高度总结各个用法，旨在了解 CMake 有哪能力，如果对某些部分感兴趣请大家自行查阅具体内容。</p>
</li>
<li><p>为什么需要一个好的构建系统？如果你有以下需求，那么使用 CMake 可以从中获益</p>
<ul>
<li>你想避免硬编码路径</li>
<li>你需要在多台电脑上建立一个软件包</li>
<li>你想使用CI（持续集成）</li>
<li>你需要支持不同的操作系统（甚至可能只是Unix的不同版本）</li>
<li>你想支持多个编译器</li>
<li>你想使用IDE，但也许并不是所有时间都想使用</li>
<li>你想要更好地组织程序的结构</li>
<li>你想使用别人的库</li>
<li>你想使用工具，比如Clang-Tidy，来帮助你编写代码</li>
<li>你想使用调试器</li>
</ul>
</li>
<li><p>为什么一定是 CMake？其他工具不行吗？</p>
<ul>
<li>各个 IDE 都支持 CMake，使用 CMake 可以有更大程度的方便, save you life</li>
<li>目前很多 C&#x2F;C++ 开源项目都在使用 CMake，通过 find CMake 或者 CMake config 很容易将它们集成至你的项目中</li>
<li>使用 CMake 来管理发布，让别人更容易使用你的库</li>
</ul>
</li>
<li><p>为什么要用现代 CMake？</p>
<ul>
<li>通常认为 3.1+ 版本是现代 CMake。CMake 是向下兼容的，可以放心使用</li>
<li>至少应该使用你的编译器出来之后的 CMake 版本，因为它需要知道该版本的编译标志等等</li>
<li>高版本 CMake 有更多特性，可以节省数百行和数小时的 CMakeLists.txt 编写工作，长运来看更容易维护</li>
</ul>
</li>
</ul>
<h3 id="1-2-运行CMake"><a href="#1-2-运行CMake" class="headerlink" title="1.2 运行CMake"></a>1.2 运行CMake</h3><ul>
<li><p>经典用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/package $ mkdir build</span><br><span class="line">~/package $ cd build</span><br><span class="line">~/package/build $ cmake ..</span><br><span class="line">~/package/build $ make</span><br></pre></td></tr></table></figure>
</li>
<li><p>新版本可以简单一点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/package $ cmake -S . -B build</span><br><span class="line">~/package $ cmake --build build</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#From the build directory (pick one)</span><br><span class="line">~/package/build $ make install</span><br><span class="line">~/package/build $ cmake --build . --target install</span><br><span class="line">~/package/build $ cmake --install . # CMake 3.15+ only</span><br><span class="line"></span><br><span class="line">#From the source directory (pick one)</span><br><span class="line">~/package $ cmake --build build --target install</span><br><span class="line">~/package $ cmake --install build # CMake 3.15+ only</span><br></pre></td></tr></table></figure>
</li>
<li><p>推荐使用 <code>--build</code> 用法</p>
<ul>
<li>通过 <code>-v</code> 显示执行的构建命令: <code>cmake --build build -v</code></li>
<li>通过 <code>--target</code> 来选择目标：<code>cmake --build --target install</code></li>
</ul>
</li>
<li><p>设置 CC 和 CXX 环境变量来选择 C&#x2F;C++ 编译器</p>
<ul>
<li><code>~/package/build $ CC=clang CXX=clang++ cmake ..</code></li>
</ul>
</li>
<li><p>选择不同的工具进行构建</p>
<ul>
<li>make 通常是默认的，通过 cmake –help 查看支持的构建器</li>
<li><code>cmake -G&quot;My Tool&quot;</code> 设置构建器，例如 <code>cmake -S . -B buildXcode -G&quot;Xcode&quot;</code></li>
</ul>
</li>
<li><p>通过 <code>-D</code> 来设置选项，例如 <code>cmake -S . -B build -DCMAKE_INSTALL_PREFIX=dist</code></p>
</li>
<li><p><code>--trace</code> 打印 <code>CMake configure</code> 阶段的输出，例如 <code>cmake -S . -B build --trace</code></p>
</li>
<li><p>不好的 CMake 的用法</p>
<ul>
<li>不要使用全局函数，例如 <code>link_directories</code>，<code>include_libraries</code>，<code>add_definitions</code> 等，请你忘记它们</li>
<li>不要滥用 <code>PUBLIC</code>，除非有依赖传递，否则请你使用 <code>PRIVATE</code> 替换 <code>PUBLIC</code></li>
<li>不要使用 <code>GLOB</code> 来添加文件</li>
<li>不要直接链接文件，而是链接目标</li>
<li>链接时千万不要跳过 <code>PUBLIC/PRIVATE</code>，这会导致未来的链接都没有关键字</li>
</ul>
</li>
<li><p>良好的 CMake 用法</p>
<ul>
<li>把 CMake 视作代码，保持它的整洁和可读性</li>
<li>围绕 target 构建你的 CMake。将需要的信息打包在 target 里，然后链接那个目标</li>
<li>导出你的接口</li>
<li>写 Config.cmake 文件，这是一个库作者应该做的，可以方便别人使用你的库</li>
<li>使用 ALAS 目标，以保持使用一致性</li>
<li>将常用的功能提取成函数或者宏，通常函数更好</li>
<li>使用小写的函数名，全大写是变量</li>
<li>使用 cmake_policy 或者 range of versions</li>
</ul>
</li>
</ul>
<h3 id="1-3-基础语法"><a href="#1-3-基础语法" class="headerlink" title="1.3 基础语法"></a>1.3 基础语法</h3><ul>
<li><p>最低版本</p>
<ul>
<li><code>cmake_minimum_required(VERSION 3.1)</code> 指定最低版本</li>
<li><code>cmake_minimum_required(VERSION 3.7...3.18)</code> CMake 3.12+ 后，可以指定版本范围</li>
</ul>
</li>
<li><p>Project</p>
<ul>
<li><code>VERSION</code> 指定版本，并设置一系列变量，例如<code>MyProject_VERSION</code> 等</li>
<li><code>DESCRIPTION</code> 项目的描述</li>
<li><code>LANGUAGES</code> 支持 <code>C/CXX/Fortran/ASM/CUDA(3.8+)/CSharp(3.8+)/SWIFT(3.15+)</code>, C&#x2F;C++ 为默认值</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">project(MyProject VERSION 1.0</span><br><span class="line">                  DESCRIPTION &quot;Very nice project&quot;</span><br><span class="line">                  LANGUAGES CXX)</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成可执行文件</p>
<ul>
<li><code>add_executable(one two.cpp three.h)</code></li>
</ul>
</li>
<li><p>生成库</p>
<ul>
<li>库类型包括 <code>STATIC</code>、<code>SHARED</code>、<code>MODULE</code>、<code>OBJECT</code> 等。如果没有指定库类型，那么 <code>BUILD_SHARED_LIBS</code> 的值将决定编译 <code>STATIC</code> 或者 <code>SHARED</code></li>
<li>有些库并不需要编译，例如 <code>header only</code> 库。基于 <code>target</code> 的思想，我们可以将它们打包在一种叫 <code>INTERFACE</code> 的库中。</li>
</ul>
</li>
<li><p>示例</p>
<ul>
<li><code>add_library(one STATIC two.cpp three.h)</code></li>
</ul>
</li>
<li><p>给 target 添加属性</p>
<ul>
<li><code>target_include_directories</code> 为 target 添加 <code>include</code> 路径</li>
<li><code>PUBLIC</code> 对于可执行文件而言意义不大，对于库来说，它让 CMake 知道链接这个目标的目标也需要这个 include 目录。也就是 “我自己要用，其他链接我的也要用”，具有传递性</li>
<li><code>PRIVATE</code> 表示 “我自己用，其他人不用”</li>
<li><code>INTERFACE</code> 表示 “我自己不用，其他链接我的要用”</li>
<li>target 的属性包括 include 文件夹、需要链接的库、编译选项、宏定义等，这些都可以通过 <code>target_link_libraries</code> 进行传递</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># PUBLIC 表示外部也需要这个 include 目录</span><br><span class="line">target_include_directories(one PUBLIC include)</span><br><span class="line">add_library(another STATIC another.cpp another.h)</span><br><span class="line"># 由于具有传递性，another 可以连接 one 的 include 目录</span><br><span class="line">target_link_libraries(another PUBLIC one)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-4-变量与缓存"><a href="#1-4-变量与缓存" class="headerlink" title="1.4 变量与缓存"></a>1.4 变量与缓存</h3><ul>
<li><p>局部变量</p>
<ul>
<li><code>set(MY_VARIABLE &quot;value&quot;)</code> 设置局部变量，其作用域为当前文件夹，以及 <code>add_subdirectory</code> 进入的文件夹</li>
<li><code>set(MY_VARIABLE &quot;value&quot; PARENT_SCOPE)</code> 将作用域设置为父目录，通常用在子目录向父目录传递信息</li>
<li><code>set(MY_LIST &quot;one&quot; &quot;two&quot;)</code> 会在变量值中间加入 <code>“;”</code>，等价于 <code>set(MY_LIST &quot;one;two&quot;)</code></li>
</ul>
</li>
<li><p>缓存变量</p>
<ul>
<li>通过 <code>set(MY_CACHE_VARIABLE &quot;VALUE&quot; CACHE STRING &quot;Description&quot;)</code> 设置缓存变量</li>
<li>缓存变量将持久存在于 CMakeCache.txt 中</li>
<li>通过 <code>cmake -DXXX</code> 命令传递的参数为缓存变量</li>
</ul>
</li>
<li><p>环境变量</p>
<ul>
<li><code>set(ENV&#123;variable_name&#125; value)</code> 设置环境变量</li>
<li><code>$ENV&#123;variable_name&#125;</code> 获取环境变量</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>属性有点像变量，但它依附在某个 target 或者文件、目录上。许多属性的初始值来自于 <code>CMAKE_</code> 开头的变量，例如设置 <code>CMAKE_CXX_STANDARD</code>，将会设置 target 的 <code>CXX_STANDARD</code> 属性初始值。</li>
<li><code>set_property</code> 用于设置属性，<code>get_property</code> 用于获取属性</li>
</ul>
</li>
</ul>
<h3 id="1-5-用CMake编程"><a href="#1-5-用CMake编程" class="headerlink" title="1.5 用CMake编程"></a>1.5 用CMake编程</h3><ul>
<li><p>控制流</p>
<ul>
<li>利用 if 语句来控制程序流</li>
<li>if 语句中支持的关键字包括：<ul>
<li>一元判断：<code>NOT、‘TARGET’、EXISTS、DEFINED</code> 等</li>
<li>二元判断：<code>STRQUAL，AND，OR，MATCH，VERSION_LESS，VERSION_LESS_EQUAL</code></li>
</ul>
</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(variable)</span><br><span class="line">    # If variable is `ON`, `YES`, `TRUE`, `Y`, or non zero number</span><br><span class="line">else()</span><br><span class="line">    # If variable is `0`, `OFF`, `NO`, `FALSE`, `N`, `IGNORE`, `NOTFOUND`, `&quot;&quot;`, or ends in `-      NOTFOUND`</span><br><span class="line">endif()</span><br><span class="line"># If variable does not expand to one of the above, CMake will expand it then try again</span><br><span class="line"></span><br><span class="line">if(NOT TARGET libA OR EXISTS &quot;test.xml&quot;)</span><br><span class="line"> # If libA or test.xml exist </span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成器表达式, generator-expressions</p>
<ul>
<li>CMake 大多数命令在 configure 阶段就被执行了，而生成器表达可以在 build 阶段，或者 install 阶段被执行</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target_include_directories(MyTarget </span><br><span class="line">    PUBLIC</span><br><span class="line">    $&lt;BUILD_INTERFACE:$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include&gt;</span><br><span class="line">    $&lt;INSTALL_INTERFACE:include&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏与函数</p>
<ul>
<li>它们的区别：函数里头的变量作用域为该函数，而宏没有作用域</li>
<li>推荐用函数，因为它不会 “泄露” 变量。即使想要从函数中传递某些变量给外面，可以主动通过 PARENT_SCOPE 来设置</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li>可以通过 <code>cmake_parse_arguments</code> 来解析函数参数</li>
</ul>
</li>
</ul>
<h3 id="1-6-与你的代码进行交互"><a href="#1-6-与你的代码进行交互" class="headerlink" title="1.6 与你的代码进行交互"></a>1.6 与你的代码进行交互</h3><ul>
<li>从 CMake 中获取信息，并生成代码。configure_file 命令可以实现这个。</li>
<li>读取文件，例如从 version.h 中获取版本信息。file 命令可以实现这个。</li>
</ul>
<h3 id="1-7-如何组织你的工程"><a href="#1-7-如何组织你的工程" class="headerlink" title="1.7 如何组织你的工程"></a>1.7 如何组织你的工程</h3><ul>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- project</span><br><span class="line">  - .gitignore</span><br><span class="line">  - README.md</span><br><span class="line">  - LICENCE.md</span><br><span class="line">  - CMakeLists.txt</span><br><span class="line">  - cmake</span><br><span class="line">    - FindSomeLib.cmake</span><br><span class="line">    - something_else.cmake</span><br><span class="line">  - include</span><br><span class="line">    - project</span><br><span class="line">      - lib.hpp</span><br><span class="line">  - src</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">    - lib.cpp</span><br><span class="line">  - apps</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">    - app.cpp</span><br><span class="line">  - tests</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">    - testlib.cpp</span><br><span class="line">  - docs</span><br><span class="line">    - CMakeLists.txt</span><br><span class="line">  - extern</span><br><span class="line">    - googletest</span><br><span class="line">  - scripts</span><br><span class="line">    - helper.py</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 configure 阶段运行命令</p>
<ul>
<li><code>execute_process</code> 在 configure 阶段运行命令</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find_package(Git QUIET)</span><br><span class="line"></span><br><span class="line">if(GIT_FOUND AND EXISTS &quot;$&#123;PROJECT_SOURCE_DIR&#125;/.git&quot;)</span><br><span class="line">    execute_process(COMMAND $&#123;GIT_EXECUTABLE&#125; submodule update --init --recursive</span><br><span class="line">                    WORKING_DIRECTORY $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">                    RESULT_VARIABLE GIT_SUBMOD_RESULT)</span><br><span class="line">    if(NOT GIT_SUBMOD_RESULT EQUAL &quot;0&quot;)</span><br><span class="line">        message(FATAL_ERROR &quot;git submodule update --init failed with $&#123;GIT_SUBMOD_RESULT&#125;, please checkout submodules&quot;)</span><br><span class="line">    endif()</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 build 阶段运行命令</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">find_package(PythonInterp REQUIRED)</span><br><span class="line">add_custom_command(OUTPUT &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/include/Generated.hpp&quot;</span><br><span class="line">    COMMAND &quot;$&#123;PYTHON_EXECUTABLE&#125;&quot; &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/scripts/GenerateHeader.py&quot; --argument</span><br><span class="line">    DEPENDS some_target)</span><br><span class="line"></span><br><span class="line">add_custom_target(generate_header ALL</span><br><span class="line">    DEPENDS &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/include/Generated.hpp&quot;)</span><br><span class="line"></span><br><span class="line">install(FILES $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/include/Generated.hpp DESTINATION include)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cmake -E &lt;mode&gt;</code> 运行内置的一些命令，例如解压、复制等</p>
</li>
</ul>
<h2 id="添加特性"><a href="#添加特性" class="headerlink" title="添加特性"></a>添加特性</h2><h3 id="1-1-C-11及以后"><a href="#1-1-C-11及以后" class="headerlink" title="1.1 C++11及以后"></a>1.1 C++11及以后</h3><ul>
<li><p>CMake 3.8+: Meta compiler features</p>
<ul>
<li>target_compile_features(myTarget PUBLIC cxx_std_11) 开启 c++11 特性，当然你也可以选择 cxx_std_14 和 cxx_std_17</li>
<li>set_target_properties(myTarget PROPERTIES CXX_EXTENSIONS OFF)，关闭扩展特性</li>
</ul>
</li>
<li><p>CMake 3.1+: 全局和属性设置</p>
<ul>
<li>全局变量设置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="line">set(CMAKE_CXX_EXTENSIONS OFF)</span><br></pre></td></tr></table></figure></li>
<li>属性设置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(myTarget PROPERTIES</span><br><span class="line">    CXX_STANDARD 11</span><br><span class="line">    CXX_STANDARD_REQUIRED YES</span><br><span class="line">    CXX_EXTENSIONS NO</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>地址无关代码（Position independent code; PIC），CMake 会自动将 -fPIC 添加到 SHARED 和 MODULE 库中，当然你也可以显示指定</p>
<ul>
<li>作用于全局变量，<code>set(CMAKE_POSITION_INDEPENDENT_CODE ON)</code></li>
<li>或者作用于 target，<code>set_target_properties(lib1 PROPERTIES POSITION_INDEPENDENT_CODE ON)</code></li>
</ul>
</li>
<li><p>小型库</p>
<ul>
<li>如果你需要 dl 库，那么这么写最简单 <code>target_link_libraries(libA PRIVATE $&#123;CMAKE_DL_LIBS&#125;)</code></li>
</ul>
</li>
<li><p>有些库就没有这么方便了，例如 m, pthread 等，但你可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find_library(MATH_LIBRARY m)</span><br><span class="line">if(MATH_LIBRARY)</span><br><span class="line">    target_link_libraries(MyTarget PUBLIC $&#123;MATH_LIBRARY&#125;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>Interprocedural optimization，运行时优化（link time optimization），即 -flto</p>
<ul>
<li>CMake 3.9+ 支持设置全局变量开启 set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON)</li>
<li>CMake 3.8+ 支持设置属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(myTarget PROPERTIES </span><br><span class="line">                    INTERPROCEDURAL_OPTIMIZATION ON)</span><br></pre></td></tr></table></figure></li>
<li>通过 check_ipo_supported 来检查当前版本是否支持 LTO<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include(CheckIPOSupported)</span><br><span class="line">check_ipo_supported(RESULT result)</span><br><span class="line">if(result)</span><br><span class="line">  set_target_properties(foo PROPERTIES </span><br><span class="line">                INTERPROCEDURAL_OPTIMIZATION TRUE)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在 CMake 中可以配合其他工具</p>
<ul>
<li>CCache，使用它来加快编译速度</li>
<li>Clang tidy，对你的代码做静态扫描</li>
<li>Include what you use, 检查冗余头文件</li>
</ul>
</li>
<li><p>CMake Modules 非常有用，简单介绍一些常用的</p>
<ul>
<li>CMakeDependentOption，根据一组变量来设置选项，例如 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include(CMakeDependentOption)</span><br><span class="line">cmake_dependent_option(BUILD_TESTS &quot;Build your tests&quot; ON &quot;VAL1;VAL2&quot; OFF)</span><br></pre></td></tr></table></figure></li>
<li>CMakePrintHelpers，用于打印属性或变量</li>
<li>CheckCXXCompilerFlag，用于判断是否支持某个编译选项</li>
<li>WriteCompilerDetectionHeader，与 CheckCXXCompilerFlag 类似，但它更强大。它可以找到编译器支持的特性列表，并生成 C++ 头文件，让你知道哪些特性可用</li>
<li>try_compile&#x2F;try_run，可以让尝试编译（运行）一些代码，这可以让你获得系统能力的信息</li>
</ul>
</li>
<li><p>调试CMake代码</p>
<ul>
<li>打印永远是调试的最简单的办法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message(STATUS &quot;MY_VARIABLE=$&#123;MY_VARIABLE&#125;&quot;)</span><br><span class="line"></span><br><span class="line">include(CMakePrintHelpers)</span><br><span class="line">cmake_print_variables(MY_VARIABLE)</span><br><span class="line"></span><br><span class="line">cmake_print_properties(</span><br><span class="line">  TARGETS my_target</span><br><span class="line">  PROPERTIES POSITION_INDEPENDENT_CODE)</span><br></pre></td></tr></table></figure></li>
<li>–trace-source&#x3D;”filename” 让你观察 CMake 文件到底发生了什么，例如<ul>
<li><code>cmake -S . -B build --trace-source=CMakeLists.txt</code></li>
</ul>
</li>
</ul>
</li>
<li><p>引入其他项目</p>
<ul>
<li>Submodule<ul>
<li>通过 <code>git submodule add ../../owner/repo.git extern/repo</code> 将 <code>extern</code> 添加为子仓库</li>
<li>可以在 CMake 中内置子仓库更新命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">find_package(Git QUIET)</span><br><span class="line">if(GIT_FOUND AND EXISTS &quot;$&#123;PROJECT_SOURCE_DIR&#125;/.git&quot;)</span><br><span class="line"># Update submodules as needed</span><br><span class="line">    option(GIT_SUBMODULE &quot;Check submodules during build&quot; ON)</span><br><span class="line">    if(GIT_SUBMODULE)</span><br><span class="line">        message(STATUS &quot;Submodule update&quot;)</span><br><span class="line">        execute_process(COMMAND $&#123;GIT_EXECUTABLE&#125; submodule update --init --recursive</span><br><span class="line">                        WORKING_DIRECTORY $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">                        RESULT_VARIABLE GIT_SUBMOD_RESULT)</span><br><span class="line">        if(NOT GIT_SUBMOD_RESULT EQUAL &quot;0&quot;)</span><br><span class="line">            message(FATAL_ERROR &quot;git submodule update --init failed with $&#123;GIT_SUBMOD_RESULT&#125;, please checkout submodules&quot;)</span><br><span class="line">        endif()</span><br><span class="line">    endif()</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">if(NOT EXISTS &quot;$&#123;PROJECT_SOURCE_DIR&#125;/extern/repo/CMakeLists.txt&quot;)</span><br><span class="line">    message(FATAL_ERROR &quot;The submodules were not downloaded! GIT_SUBMODULE was turned off or failed. Please update submodules and try again.&quot;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>DownloadProject</p>
<ul>
<li>在 CMake 3.11 以前，主要下载命令都是在 build 阶段完成的（例如 ExternalProject_Add）。这就导致你无法使用 add_subdirectory。</li>
<li>CMake 3.11之前，如果想要在 configure 阶段下载，参考 Crascit&#x2F;DownloadProject</li>
</ul>
</li>
<li><p>Fetch(CMake 3.11+)</p>
<ul>
<li>CMake 3.11 后，你可以使用 FetchContent 在 configure 阶段下载文件或者项目</li>
</ul>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="1-1-1"><a href="#1-1-1" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>通常不在子目录时编译测试代码</p>
</li>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME AND BUILD_TESTING)</span><br><span class="line">  add_subdirectory(tests)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></li>
<li><p>通过 <code>add_test(NAME TestName COMMAND TargetName)</code> 注册测试</p>
</li>
<li><p>GoogleTest</p>
<ul>
<li>推荐通过以 git submodule 的形式引入 GoogleTest</li>
<li>可以通过作者提供的 AddGoogleTest 工具引入 GoogleTest</li>
<li>通过 FetchContent 引入 GoogleTest</li>
</ul>
</li>
<li><p>Catch</p>
<ul>
<li>Catch 是个 header only 库，如果直接将它的 include 引入你的仓库中，你需要做一些准备，以便使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Prepare &quot;Catch&quot; library for other executables</span><br><span class="line">set(CATCH_INCLUDE_DIR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/extern/catch)</span><br><span class="line">add_library(Catch2::Catch IMPORTED INTERFACE)</span><br><span class="line">set_property(Catch2::Catch PROPERTY INTERFACE_INCLUDE_DIRECTORIES &quot;$&#123;CATCH_INCLUDE_DIR&#125;&quot;)</span><br></pre></td></tr></table></figure></li>
<li>通过 ExternalProject、FetchContent 或者 git submodule 引入 Catch，那么直接 add_subdirectory 即可</li>
</ul>
</li>
</ul>
<h2 id="Exporting-and-Installing"><a href="#Exporting-and-Installing" class="headerlink" title="Exporting and Installing"></a>Exporting and Installing</h2><h3 id="1-1-2"><a href="#1-1-2" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li>关于 Installing，参考 CMake之install方法的使用</li>
<li>关于 Exporting，可以将 build directories 信息导出，以供其他工程使用（注意与 Installing 的区别：Installing 导出的是安装目录的信息）</li>
<li>关于 Package ，没怎么用过，似乎是将你需要的内容进行打包</li>
</ul>
<h2 id="寻找库"><a href="#寻找库" class="headerlink" title="寻找库"></a>寻找库</h2><h3 id="1-1-3"><a href="#1-1-3" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li>介绍了引入 CUDA、OpenMP、Boost、MPI、ROOT、Minuit2 等库的标准姿势</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/CMake/cmake_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-cmake_2_01_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/CMake/cmake_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-cmake_2_01_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">cmake_2_01_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cmake 常用函数</li>
</ul>
<h2 id="cmake-check-one-config-函数-详解"><a href="#cmake-check-one-config-函数-详解" class="headerlink" title="cmake check_one_config() 函数 详解"></a>cmake check_one_config() 函数 详解</h2><p><code>check_one_config()</code> 函数是 CMake 中的一个函数，通常用于在配置过程中检查和验证某些条件或选项是否正确设置。它常见于 CMake 模块或工具链文件中，尤其是在进行跨平台构建配置时。具体来说，它用于检查单个配置或条件是否满足，并输出相关信息。</p>
<h3 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a><strong>功能概述</strong></h3><p><code>check_one_config()</code> 函数主要用于验证一个特定的配置或条件，并根据验证的结果采取相应的行动。通常，这些条件可能涉及到 CMake 配置变量的值、环境设置或库的可用性等。</p>
<p>这个函数并不是 CMake 的标准库函数，而是一些 CMake 模块中自定义的辅助函数。在 OpenCV 或其他大型 CMake 项目的配置中，<code>check_one_config()</code> 可能用于检查工具链、编译器、依赖库或其他配置是否符合要求。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ul>
<li><strong>验证工具链配置</strong>：检查是否指定了正确的编译器或编译选项。</li>
<li><strong>检查依赖库</strong>：确认所需的库是否存在。</li>
<li><strong>输出配置状态</strong>：根据条件输出构建信息或错误信息。</li>
</ul>
<h3 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a><strong>典型用法</strong></h3><p><code>check_one_config()</code> 的实际实现和用法通常依赖于所使用的 CMake 模块和构建脚本。假设在一个项目中，<code>check_one_config()</code> 被用于检查一个必需的配置选项是否已设置，可以像这样使用：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(check_one_config option_name option_value)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> <span class="variable">$&#123;option_name&#125;</span>)</span><br><span class="line">        <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Configuration error: $&#123;option_name&#125; is not defined.&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$&#123;option_name&#125;</span> <span class="keyword">STREQUAL</span> <span class="variable">$&#123;option_value&#125;</span>)</span><br><span class="line">        <span class="keyword">message</span>(STATUS <span class="string">&quot;Configuration: $&#123;option_name&#125; is set to $&#123;option_value&#125;.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line">        <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Configuration error: $&#123;option_name&#125; is not set to $&#123;option_value&#125;.&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 check_one_config 来检查某个选项</span></span><br><span class="line">check_one_config(MY_OPTION <span class="string">&quot;SomeValue&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>check_one_config</code> 用于检查名为 <code>MY_OPTION</code> 的选项是否定义，并且其值是否等于 <code>&quot;SomeValue&quot;</code>。如果不符合条件，CMake 将输出致命错误并终止配置过程。</p>
<h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a><strong>参数解释</strong></h3><p><code>check_one_config()</code> 的函数定义通常包含以下几个参数：</p>
<ul>
<li><strong>option_name</strong>：待检查的配置选项名称。它通常是一个 CMake 变量的名称，用于表示某个设置或选项。</li>
<li><strong>option_value</strong>：期望的选项值，用于比较。如果配置选项的值与期望值不匹配，则执行相应的操作。</li>
</ul>
<h3 id="CMake-版本及实现差异"><a href="#CMake-版本及实现差异" class="headerlink" title="CMake 版本及实现差异"></a><strong>CMake 版本及实现差异</strong></h3><p>由于 <code>check_one_config()</code> 不是 CMake 的标准内建函数，而是特定 CMake 模块中的自定义函数，其具体实现可能会根据不同的项目或模块有所不同。上述示例是一个常见的自定义实现，但某些项目（如 OpenCV）可能会根据其构建需求对 <code>check_one_config()</code> 进行扩展和修改。</p>
<h3 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a><strong>示例场景</strong></h3><ul>
<li><p><strong>检查是否找到某个库</strong>：在项目中，可能需要检查某个依赖库（如 OpenCV、Boost 或其他）是否被正确发现。如果没有找到该库，<code>check_one_config()</code> 可以输出错误并终止构建。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line">check_one_config(OpenCV_FOUND <span class="keyword">TRUE</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查编译器支持的选项</strong>：某些构建选项可能仅在特定的编译器或工具链下有效。使用 <code>check_one_config()</code> 可以确保编译器支持所需的选项。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_one_config(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>check_one_config()</code> 是一个 CMake 中用于检查和验证特定配置的函数。</li>
<li>它通常用于确保某个选项、工具链、库或环境变量符合预期。</li>
<li>它并不是 CMake 的内建标准函数，而是项目自定义的帮助函数，可能用于构建配置的验证。</li>
<li><code>check_one_config()</code> 常用于输出配置状态、验证选项值，或在配置失败时输出错误并终止构建过程。</li>
</ul>
<p>如果你在使用某个项目时遇到 <code>check_one_config()</code>，通常需要查阅项目的 CMake 文件以了解该函数的具体实现和使用方式。</p>
<h2 id="cmake-get-target-property-详解"><a href="#cmake-get-target-property-详解" class="headerlink" title="cmake get_target_property() 详解"></a>cmake get_target_property() 详解</h2><p><code>get_target_property()</code> 是 CMake 中用于获取目标（target）属性的命令。它可以从指定的目标中检索特定的属性值，并将其存储在变量中。其常见语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_target_property</span>(&lt;variable&gt; &lt;<span class="keyword">target</span>&gt; &lt;property&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li><p><code>&lt;variable&gt;</code>：这是存储属性值的变量名。如果属性存在，其值将存储在此变量中。如果属性不存在，变量将设置为特殊值 <code>NOTFOUND</code>。</p>
</li>
<li><p><code>&lt;target&gt;</code>：这是你希望查询属性的目标（通常是通过 <code>add_executable()</code>、<code>add_library()</code> 或 <code>add_custom_target()</code> 创建的目标）。</p>
</li>
<li><p><code>&lt;property&gt;</code>：这是要查询的属性名称。CMake 中有许多内置的属性，比如 <code>INTERFACE_INCLUDE_DIRECTORIES</code>、<code>LOCATION</code>、<code>LINK_LIBRARIES</code> 等。</p>
</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设有以下 CMake 配置：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_executable main.cpp)</span><br><span class="line"><span class="keyword">set_target_properties</span>(my_executable PROPERTIES VERSION <span class="number">1.0</span> SOVERSION <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>get_target_property()</code> 获取属性值：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_target_property</span>(version my_executable VERSION)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;my_executable version is: $&#123;version&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出可能为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_executable version is: 1.0</span><br></pre></td></tr></table></figure>

<h3 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h3><ul>
<li><code>LOCATION</code>：目标生成的二进制文件路径。</li>
<li><code>INTERFACE_INCLUDE_DIRECTORIES</code>：指定此目标暴露给依赖它的目标的包含目录列表。</li>
<li><code>LINK_LIBRARIES</code>：链接到该目标的库列表。</li>
<li><code>COMPILE_DEFINITIONS</code>：目标的编译定义列表。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>如果指定的属性不存在，结果变量会被设置为 <code>NOTFOUND</code>，这在处理未定义属性时要特别注意。</li>
<li>使用 <code>get_target_property()</code> 时，目标必须已经定义，否则会报错。</li>
</ul>
<h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><p>可以结合 <code>get_target_property()</code> 和条件判断来实现动态配置，例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_target_property</span>(is_shared my_library TYPE)</span><br><span class="line"><span class="keyword">if</span>(is_shared <span class="keyword">STREQUAL</span> <span class="string">&quot;SHARED_LIBRARY&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;my_library is a shared library&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>这种用法对于复杂的 CMake 构建系统非常有用，能够动态获取目标的属性并做进一步操作。</p>
<h2 id="cmake-add-custom-command"><a href="#cmake-add-custom-command" class="headerlink" title="cmake add_custom_command()"></a>cmake add_custom_command()</h2><p><code>add_custom_command()</code> 是 CMake 中的一个常用函数，用于为目标（target）添加自定义命令。这个函数可以配置在构建过程中生成文件、执行脚本、生成资源等操作。<code>add_custom_command()</code> 有两种主要的使用方式：一种是作为生成文件的一部分（<code>OUTPUT</code>），另一种是作为构建目标的依赖项（<code>TARGET</code>）。</p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    OUTPUT output1 [output2 ...]</span><br><span class="line">    <span class="keyword">COMMAND</span> command1 [ARGS [arg1 [arg2 ...]]] [command2 ...]</span><br><span class="line">    [MAIN_DEPENDENCY depend]</span><br><span class="line">    [DEPENDS [depend1 [depend2 ...]]]</span><br><span class="line">    [BYPRODUCTS [files ...]]</span><br><span class="line">    [IMPLICIT_DEPENDS &lt;lang1&gt; depend1 [&lt;lang2&gt; depend2] ...]</span><br><span class="line">    [WORKING_DIRECTORY dir]</span><br><span class="line">    [COMMENT comment]</span><br><span class="line">    [VERBATIM] [APPEND] [USES_TERMINAL]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    <span class="keyword">TARGET</span> <span class="keyword">target</span></span><br><span class="line">    PRE_BUILD | PRE_LINK | POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> command1 [ARGS [arg1 [arg2 ...]]] [command2 ...]</span><br><span class="line">    [BYPRODUCTS [files ...]]</span><br><span class="line">    [WORKING_DIRECTORY dir]</span><br><span class="line">    [COMMENT comment]</span><br><span class="line">    [VERBATIM] [USES_TERMINAL]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="2-参数说明"><a href="#2-参数说明" class="headerlink" title="2. 参数说明"></a>2. 参数说明</h3><h4 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h4><ul>
<li><p><strong>OUTPUT</strong>: 指定自定义命令生成的文件列表。这些文件将被 CMake 认为是构建过程中的产物，因此可以在后续的构建步骤中使用。通常与 <code>DEPENDS</code> 配合使用。</p>
</li>
<li><p><strong>COMMAND</strong>: 这是最重要的部分，指定要运行的命令。可以有多个 <code>COMMAND</code>，它们会按顺序执行。可以使用 <code>ARGS</code> 指定命令的参数。</p>
</li>
<li><p><strong>DEPENDS</strong>: 指定该命令依赖的文件或目标。在这些依赖项发生变化时，自定义命令会重新运行。</p>
</li>
<li><p><strong>MAIN_DEPENDENCY</strong>: 为某些工具链优化时指定主依赖文件，通常与编译相关。</p>
</li>
<li><p><strong>BYPRODUCTS</strong>: 指定命令生成的副产物文件。特别是在多线程构建中有用，帮助 CMake 正确处理文件的生成顺序。</p>
</li>
<li><p><strong>WORKING_DIRECTORY</strong>: 指定命令运行的工作目录。</p>
</li>
<li><p><strong>COMMENT</strong>: 在执行命令时，显示的注释信息。</p>
</li>
<li><p><strong>VERBATIM</strong>: 确保命令行是精确传递的，防止 CMake 对命令进行不必要的转义。通常建议使用。</p>
</li>
<li><p><strong>USES_TERMINAL</strong>: 指示该命令需要一个终端运行，适用于需要用户交互的命令。</p>
</li>
</ul>
<h4 id="针对目标的参数"><a href="#针对目标的参数" class="headerlink" title="针对目标的参数"></a>针对目标的参数</h4><ul>
<li><p><strong>TARGET</strong>: 指定一个目标（例如可执行文件或库）。</p>
</li>
<li><p><strong>PRE_BUILD</strong>: 命令在目标构建之前执行。</p>
</li>
<li><p><strong>PRE_LINK</strong>: 命令在目标链接之前执行。</p>
</li>
<li><p><strong>POST_BUILD</strong>: 命令在目标构建完成后执行。</p>
</li>
</ul>
<h3 id="3-常见用法示例"><a href="#3-常见用法示例" class="headerlink" title="3. 常见用法示例"></a>3. 常见用法示例</h3><h4 id="生成文件的自定义命令"><a href="#生成文件的自定义命令" class="headerlink" title="生成文件的自定义命令"></a>生成文件的自定义命令</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    OUTPUT <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/generated_file.cpp</span><br><span class="line">    <span class="keyword">COMMAND</span> python <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/generate_script.py <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/generated_file.cpp</span><br><span class="line">    DEPENDS <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/generate_script.py</span><br><span class="line">    COMMENT <span class="string">&quot;Generating source file&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个例子展示了如何在构建过程中调用一个 Python 脚本生成源文件，并将其作为后续构建步骤的一部分。</p>
<h4 id="为目标添加构建步骤"><a href="#为目标添加构建步骤" class="headerlink" title="为目标添加构建步骤"></a>为目标添加构建步骤</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    <span class="keyword">TARGET</span> MyExecutable</span><br><span class="line">    POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E echo <span class="string">&quot;Build finished!&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个命令将在 <code>MyExecutable</code> 构建完成后，打印一条信息。</p>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul>
<li>如果你使用 <code>OUTPUT</code> 参数，必须确保这些输出文件在命令成功执行后生成，否则 CMake 可能会重复运行命令。</li>
<li>使用 <code>VERBATIM</code> 参数通常是最佳实践，因为它可以确保命令行正确传递，无需担心平台相关的转义问题。</li>
<li>在复杂项目中，自定义命令应合理使用依赖关系，确保构建顺序的正确性。</li>
</ul>
<p><code>add_custom_command()</code> 在处理自定义构建步骤时非常强大，合理利用可以显著提高项目构建的灵活性。</p>
<h2 id="cmake-add-subdirectory-函数-详解"><a href="#cmake-add-subdirectory-函数-详解" class="headerlink" title="cmake add_subdirectory() 函数 详解"></a>cmake add_subdirectory() 函数 详解</h2><p><code>add_subdirectory()</code> 是 CMake 中的一个函数，用于向 CMake 构建系统添加一个子目录。当你的项目结构比较复杂，需要将代码分割成多个目录时，<code>add_subdirectory()</code> 可以很方便地帮助你组织代码和构建系统。</p>
<p>这个函数的语法是：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>source_dir</code>：要添加的子目录的路径。</li>
<li><code>binary_dir</code>：可选参数，用于指定存放构建输出的目录。如果省略，则默认为 <code>source_dir</code> 下的 <code>bin</code> 目录。</li>
<li><code>EXCLUDE_FROM_ALL</code>：可选参数，如果设置了这个选项，则生成的构建目标将不会被默认构建。</li>
</ul>
<p>使用 <code>add_subdirectory()</code> 的典型场景是，你的项目主目录下有多个子目录，每个子目录都包含了一个独立的 CMakeLists.txt 文件来描述这个子目录的构建过程。例如，一个简单的项目结构可能是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">project_root/</span><br><span class="line">    CMakeLists.txt</span><br><span class="line">    src/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        file1.cpp</span><br><span class="line">        file2.cpp</span><br><span class="line">    test/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        test1.cpp</span><br><span class="line">        test2.cpp</span><br></pre></td></tr></table></figure>

<p><code>project_root/CMakeLists.txt</code> 中可以通过 <code>add_subdirectory()</code> 来引入 <code>src/</code> 和 <code>test/</code> 目录的构建规则：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">test</span>)</span><br></pre></td></tr></table></figure>

<p>然后在 <code>src/CMakeLists.txt</code> 和 <code>test/CMakeLists.txt</code> 中分别描述 <code>src/</code> 和 <code>test/</code> 目录下的构建规则。</p>
<p>通过这种方式，可以将项目的各个部分分开管理，每个部分有独立的构建规则，便于项目的组织和维护。</p>
<h2 id="cmake-target-link-directories-函数-详解"><a href="#cmake-target-link-directories-函数-详解" class="headerlink" title="cmake target_link_directories() 函数 详解"></a>cmake target_link_directories() 函数 详解</h2><p>在 CMake 中，<code>target_link_directories()</code> 函数用于为一个目标（target）指定要搜索链接库的目录。这允许你为特定目标指定链接库的搜索路径，而不是全局设置。</p>
<h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_directories</span>(<span class="keyword">target</span></span><br><span class="line">    [BEFORE]</span><br><span class="line">    directory1 [directory2 ...]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>target</code>：要指定链接库搜索路径的目标名称。</p>
</li>
<li><p><code>directory1 [directory2 ...]</code>：一个或多个链接库搜索路径。</p>
</li>
<li><p><code>BEFORE</code>：可选参数，用于指定搜索路径的添加位置。如果使用 <code>BEFORE</code>，则新的搜索路径将插入到当前搜索路径列表的最前面；否则，它们将添加到列表的末尾。</p>
</li>
</ul>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_executable main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定链接库搜索路径</span></span><br><span class="line"><span class="keyword">target_link_directories</span>(my_executable PRIVATE</span><br><span class="line">    /path/to/library/directory</span><br><span class="line">    /another/path/to/library</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>target_link_directories()</code> 函数为目标 <code>my_executable</code> 指定了两个链接库搜索路径。这意味着在构建 <code>my_executable</code> 时，CMake 将会在这两个目录中查找链接库。</p>
<p>需要注意的是，推荐使用 <code>target_link_directories()</code> 函数是因为它允许你为每个目标指定不同的链接库搜索路径。如果你只想全局指定链接库搜索路径，可以使用 <code>link_directories()</code> 函数。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局指定链接库搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(</span><br><span class="line">    /path/to/library/directory</span><br><span class="line">    /another/path/to/library</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>虽然 <code>link_directories()</code> 也可以用于指定链接库搜索路径，但在现代 CMake 中，更推荐使用 <code>target_link_directories()</code> 以提供更好的目标特定性。</p>
<h2 id="cmake-message-函数-详解"><a href="#cmake-message-函数-详解" class="headerlink" title="cmake message()函数 详解"></a>cmake message()函数 详解</h2><p>在CMake中，<code>message()</code> 函数用于在构建过程中输出消息。这对于调试CMake脚本或者提供一些提示信息非常有用。<code>message()</code>函数的基本语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([&lt;mode&gt;] <span class="string">&quot;message string&quot;</span> ...)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>&lt;mode&gt;</code> 是可选的，用于指定消息的模式，包括 <code>STATUS</code>、<code>WARNING</code>、<code>AUTHOR_WARNING</code>、<code>SEND_ERROR</code> 和 <code>FATAL_ERROR</code> 等。如果省略 <code>&lt;mode&gt;</code>，则默认是 <code>STATUS</code> 模式。</li>
<li><code>&quot;message string&quot;</code> 是要输出的消息字符串。</li>
</ul>
<p>以下是一些使用<code>message()</code>函数的示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出一般消息</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;This is a general message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出带有 STATUS 模式的消息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;This is a status message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出带有 WARNING 模式的消息</span></span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;This is a warning message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出带有 AUTHOR_WARNING 模式的消息</span></span><br><span class="line"><span class="keyword">message</span>(AUTHOR_WARNING <span class="string">&quot;This is an author warning message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出带有 SEND_ERROR 模式的消息</span></span><br><span class="line"><span class="keyword">message</span>(SEND_ERROR <span class="string">&quot;This is a send error message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出带有 FATAL_ERROR 模式的消息</span></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;This is a fatal error message&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在输出消息时，<code>message()</code>函数会根据指定的模式在终端上显示不同的颜色和标识。例如，<code>STATUS</code>模式通常是蓝色的，而<code>WARNING</code>模式是黄色的。<code>SEND_ERROR</code>和<code>FATAL_ERROR</code>模式将导致构建过程中的错误，<code>FATAL_ERROR</code>还会停止构建过程。</p>
<p><code>message()</code>函数对于在构建过程中提供有用的信息以及与开发者和用户进行交互非常有用。</p>
<h2 id="cmake-target-link-include-详解"><a href="#cmake-target-link-include-详解" class="headerlink" title="cmake target_link_include() 详解"></a>cmake target_link_include() 详解</h2><p>在CMake中，<code>target_link_libraries()</code> 和 <code>target_include_directories()</code> 是两个常用的命令，它们用于配置构建目标（通常是可执行文件或库）的依赖关系和包含目录。以下是对这两个命令的详解：</p>
<h3 id="1-target-link-libraries"><a href="#1-target-link-libraries" class="headerlink" title="1. target_link_libraries()"></a>1. <code>target_link_libraries()</code></h3><p><code>target_link_libraries()</code> 命令用于指定一个目标（可执行文件、库等）所依赖的库。它的基本语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">target</span>-name</span><br><span class="line">                      library1</span><br><span class="line">                      library2</span><br><span class="line">                      ...</span><br><span class="line">                      libraryN)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>target-name</code> 是你要链接的目标的名称。</li>
<li><code>library1</code>, <code>library2</code>, …, <code>libraryN</code> 是要链接到目标的库的名称。</li>
</ul>
<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_app main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_app</span><br><span class="line">                      my_lib1</span><br><span class="line">                      my_lib2</span><br><span class="line">                      )</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>my_app</code> 可执行文件依赖于 <code>my_lib1</code> 和 <code>my_lib2</code> 库。</p>
<h3 id="2-target-include-directories"><a href="#2-target-include-directories" class="headerlink" title="2. target_include_directories()"></a>2. <code>target_include_directories()</code></h3><p><code>target_include_directories()</code> 命令用于为目标指定包含目录。它的基本语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">target</span>-name</span><br><span class="line">                           PRIVATE|PUBLIC|INTERFACE</span><br><span class="line">                           directory1</span><br><span class="line">                           directory2</span><br><span class="line">                           ...</span><br><span class="line">                           directoryN)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>target-name</code> 是你要配置的目标的名称。</li>
<li><code>PRIVATE</code>, <code>PUBLIC</code>, 或 <code>INTERFACE</code> 用于指定目录的使用范围。</li>
<li><code>directory1</code>, <code>directory2</code>, …, <code>directoryN</code> 是要包含的目录路径。</li>
</ul>
<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(my_lib my_source.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(my_lib</span><br><span class="line">                           PUBLIC</span><br><span class="line">                           <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">                           )</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>my_lib</code> 库将公开包含目录 <code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include</code>，这意味着在使用该库的目标中，这个目录将被添加到编译器的包含路径中。</p>
<p>总体而言，<code>target_link_libraries()</code> 用于指定目标依赖的库，而 <code>target_include_directories()</code> 用于指定目标的包含目录。这两个命令允许你在 CMake 中有效地管理项目的依赖关系和包含路径。</p>
<h2 id="cmake-find-package-函数-详解"><a href="#cmake-find-package-函数-详解" class="headerlink" title="cmake find_package() 函数 详解"></a>cmake find_package() 函数 详解</h2><p><code>find_package()</code> 函数是 CMake 中用于查找和引入外部软件包（例如库）的关键函数。它被用于在 CMake 项目中引入依赖项，让 CMake 知道如何定位并使用外部库或工具。</p>
<p>该函数的一般形式如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(&lt;PackageName&gt; [version] [EXACT] [QUIET] [MODULE] [REQUIRED] [[COMPONENTS] [components...]] [OPTIONAL_COMPONENTS components...])</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>&lt;PackageName&gt;</code>：指定要查找的软件包的名称，可以是已知的软件包，也可以是自定义的软件包。</li>
<li><code>[version]</code>：可选，用于指定软件包的版本号要求。</li>
<li><code>[EXACT]</code>：可选，如果指定了版本号要求，使用 EXACT 表示需要精确匹配指定版本。</li>
<li><code>[QUIET]</code>：可选，不显示查找过程中的详细信息。</li>
<li><code>[MODULE]</code>：可选，明确指定要查找的是 CMake 模块文件。</li>
<li><code>[REQUIRED]</code>：可选，如果软件包未找到，则停止 CMake 过程，报错。</li>
<li><code>[[COMPONENTS] [components...]]</code>：可选，指定软件包的组件（如果软件包有多个组件）。</li>
<li><code>[OPTIONAL_COMPONENTS components...]</code>：可选，指定可选的软件包组件。</li>
</ul>
<p>下面是一个例子，演示如何使用 <code>find_package()</code> 查找并引入 Boost 库：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 Boost 库</span></span><br><span class="line"><span class="keyword">find_package</span>(Boost <span class="number">1.65</span>.<span class="number">0</span> REQUIRED COMPONENTS filesystem system)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果找到 Boost 库，则输出信息</span></span><br><span class="line"><span class="keyword">if</span> (Boost_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Boost found. Include dirs: $&#123;Boost_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Boost libraries: $&#123;Boost_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Boost not found.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>find_package(Boost 1.65.0 REQUIRED COMPONENTS filesystem system)</code> 表示查找 Boost 库的版本号至少为 1.65.0，必须包含 <code>filesystem</code> 和 <code>system</code> 两个组件。如果找到了 Boost 库，则输出相应的信息，否则停止 CMake 过程并报错。</p>
<p>总体而言，<code>find_package()</code> 函数使得在 CMake 项目中集成外部依赖项变得更加灵活和方便。</p>
<h2 id="CMakeLists-add-definitions-详解"><a href="#CMakeLists-add-definitions-详解" class="headerlink" title="CMakeLists add_definitions() 详解"></a>CMakeLists add_definitions() 详解</h2><p><code>add_definitions()</code> 是 CMake 中用于添加编译器宏定义的命令。它允许您在整个项目中为源代码文件添加全局宏定义，以实现条件编译或其他编译时配置。以下是有关 <code>add_definitions()</code> 的详解：</p>
<p><strong>语法：</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-D&lt;DEFINE_1&gt; -D&lt;DEFINE_2&gt; ... -D&lt;DEFINE_N&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-D&lt;DEFINE&gt;</code>: 指定一个宏定义，<code>-D</code> 后跟宏的名称。您可以使用多个 <code>-D</code> 来指定多个宏定义。</li>
</ul>
<p><strong>示例：</strong></p>
<p>假设您希望在整个项目中定义一个宏，例如 <code>ENABLE_FEATURE_X</code>，以便在源代码文件中进行条件编译。您可以在项目的 CMakeLists.txt 文件中使用 <code>add_definitions()</code> 来定义宏：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-DENABLE_FEATURE_X)</span><br></pre></td></tr></table></figure>

<p>这将使 <code>-DENABLE_FEATURE_X</code> 添加到编译器命令行，以便在编译源文件时启用该宏。您可以在源代码文件中使用 <code>#ifdef</code> 或 <code>#ifndef</code> 指令来检查该宏的存在，然后根据需要执行不同的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENABLE_FEATURE_X</span></span><br><span class="line"><span class="comment">// 这部分代码只在 ENABLE_FEATURE_X 定义时编译</span></span><br><span class="line"><span class="comment">// 执行 Feature X 相关的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 这部分代码在 ENABLE_FEATURE_X 未定义时编译</span></span><br><span class="line"><span class="comment">// 执行其他操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li><code>add_definitions()</code> 命令将全局宏定义应用于整个项目，因此请确保不会意外地影响其他目标或源文件。如果需要更精确的控制，可以考虑使用 <code>target_compile_definitions()</code> 命令来为特定目标添加宏定义。</li>
<li>如果您需要定义带有值的宏，例如 <code>-DVERSION_NUMBER=42</code>，只需在 <code>-D</code> 后添加宏的名称和值即可。</li>
<li>使用 <code>add_definitions()</code> 命令会为所有目标和源文件添加宏定义，这可能会导致不必要的宏定义冲突。因此，在 CMake 3.12 及更高版本中，推荐使用 <code>target_compile_definitions()</code> 来更精确地控制宏定义的作用范围。</li>
</ul>
<p>总之，<code>add_definitions()</code> 是用于添加全局宏定义的 CMake 命令，它可以帮助您在整个项目中进行条件编译和其他编译时配置。</p>
<h2 id="cmake-CMakeLists-txt-include-directories-函数-详解"><a href="#cmake-CMakeLists-txt-include-directories-函数-详解" class="headerlink" title="cmake CMakeLists.txt include_directories()函数 详解"></a>cmake CMakeLists.txt include_directories()函数 详解</h2><p><code>include_directories()</code>函数是CMake中的一个用于指定头文件包含路径的函数。它用于告诉CMake编译器在哪里查找头文件。在CMakeLists.txt文件中使用<code>include_directories()</code>函数非常有用，因为它允许您配置项目以便正确找到所有所需的头文件。</p>
<p>下面是关于<code>include_directories()</code>函数的详细解释：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(directory1 [directory2 ...])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>directory1</code>, <code>directory2</code>, …：这些参数是包含头文件的目录路径。您可以指定一个或多个目录，用于告诉CMake查找头文件的位置。通常，这些目录路径是相对于<code>CMakeLists.txt</code>文件的。</li>
</ul>
<p><code>include_directories()</code>函数的作用是将指定的目录路径添加到CMake项目的头文件包含路径中，以使编译器能够找到所需的头文件。当您使用<code>#include</code>指令包含头文件时，编译器将在这些目录中查找头文件。</p>
<p>示例用法：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)  <span class="comment"># 添加一个名为&quot;include&quot;的头文件目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者指定多个头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">    <span class="keyword">include</span></span><br><span class="line">    common</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>include_directories()</code>函数用于指定项目的头文件搜索路径，通常这些路径包括项目中的<code>include</code>目录和<code>common</code>目录。这使得您可以在CMake项目中使用相对路径来包含头文件，而无需手动指定完整的文件路径。</p>
<p>请注意，从CMake 3.15开始，更推荐使用<code>target_include_directories()</code>函数，它允许更好的目标级别控制，以及更容易实现接口库的目录传递。这是一个更现代和更具有可维护性的做法。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(target_name</span><br><span class="line">    PUBLIC</span><br><span class="line">        <span class="keyword">include</span></span><br><span class="line">    PRIVATE</span><br><span class="line">        private_include</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上述示例中，<code>target_include_directories()</code>函数将头文件目录添加到名为<code>target_name</code>的目标（可执行文件或库）中，可以使用<code>PUBLIC</code>和<code>PRIVATE</code>修饰符来指定头文件目录的可见性。这提供了更灵活的控制选项。</p>
<h2 id="cmake-CMakeLists-txt-内置变量"><a href="#cmake-CMakeLists-txt-内置变量" class="headerlink" title="cmake CMakeLists.txt 内置变量"></a>cmake CMakeLists.txt 内置变量</h2><p>CMake提供了一些内置变量，用于获取有关项目和构建环境的信息，您可以在CMakeLists.txt文件中使用这些变量来进行配置和生成目标。以下是一些常用的内置变量：</p>
<ol>
<li><p><code>CMAKE_SOURCE_DIR</code>：指向CMakeLists.txt文件所在的源代码根目录的路径。</p>
</li>
<li><p><code>CMAKE_BINARY_DIR</code>：指向CMake生成构建文件的根目录的路径。这通常是项目构建的目录，与源代码分开。</p>
</li>
<li><p><code>CMAKE_CURRENT_SOURCE_DIR</code>：指向当前处理的CMakeLists.txt文件所在的目录。</p>
</li>
<li><p><code>CMAKE_CURRENT_BINARY_DIR</code>：指向与当前处理的CMakeLists.txt文件关联的构建目录。</p>
</li>
<li><p><code>CMAKE_PROJECT_NAME</code>：包含当前项目的名称，通常由<code>project()</code>命令指定。</p>
</li>
<li><p><code>CMAKE_VERSION</code>：CMake的版本信息。</p>
</li>
<li><p><code>CMAKE_CXX_COMPILER</code>：指向C++编译器的可执行文件路径。</p>
</li>
<li><p><code>CMAKE_C_COMPILER</code>：指向C编译器的可执行文件路径。</p>
</li>
<li><p><code>CMAKE_SYSTEM</code>：指定操作系统的名称。</p>
</li>
<li><p><code>CMAKE_SYSTEM_NAME</code>：指定操作系统的名称，通常是与<code>CMAKE_SYSTEM</code>相同。</p>
</li>
<li><p><code>CMAKE_SYSTEM_VERSION</code>：指定操作系统的版本号。</p>
</li>
<li><p><code>CMAKE_SYSTEM_PROCESSOR</code>：指定操作系统的处理器架构。</p>
</li>
<li><p><code>CMAKE_BUILD_TYPE</code>：用于指定构建类型（例如，Debug、Release、RelWithDebInfo等）。可以使用此变量来控制编译器标志和优化级别。</p>
</li>
<li><p><code>CMAKE_INSTALL_PREFIX</code>：指定安装目标的根目录。默认情况下，它通常是<code>/usr/local</code>（Linux）或<code>C:\Program Files</code>（Windows）。</p>
</li>
<li><p><code>CMAKE_MODULE_PATH</code>：用于指定查找CMake模块的路径。模块通常用于共享一些通用的CMake配置。</p>
</li>
</ol>
<p>这些内置变量可用于配置项目的不同方面，包括源文件路径、构建文件路径、编译器信息、操作系统信息和其他构建选项。您可以在CMakeLists.txt文件中使用这些变量，以根据项目的需求自定义构建过程。</p>
<h2 id="cmake-构建选项-打开开关"><a href="#cmake-构建选项-打开开关" class="headerlink" title="cmake 构建选项 打开开关"></a>cmake 构建选项 打开开关</h2><p>在 CMake 中，你可以使用 <code>option</code> 命令创建构建选项开关，以便在构建时根据用户的选择来开启或关闭某些功能。这些选项通常用于控制编译和构建过程中的一些特定配置。以下是如何在 CMake 中创建和使用构建选项开关的示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 CMakeLists.txt 中添加以下代码</span></span><br><span class="line"><span class="keyword">option</span>(BUILD_FEATURE_X <span class="string">&quot;Build feature X&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">option</span>(BUILD_FEATURE_Y <span class="string">&quot;Build feature Y&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在合适的位置，根据选项的状态来设置相关内容</span></span><br><span class="line"><span class="keyword">if</span>(BUILD_FEATURE_X)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Building feature X&quot;</span>)</span><br><span class="line">    <span class="keyword">add_subdirectory</span>(feature_x)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_FEATURE_Y)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Building feature Y&quot;</span>)</span><br><span class="line">    <span class="keyword">add_subdirectory</span>(feature_y)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了两个构建选项：<code>BUILD_FEATURE_X</code> 和 <code>BUILD_FEATURE_Y</code>。选项的初始状态分别设置为 <code>ON</code> 和 <code>OFF</code>。如果用户希望构建时开启 “Feature X”，可以在构建命令中使用 <code>-DBUILD_FEATURE_X=ON</code>，而如果希望关闭 “Feature Y”，可以使用 <code>-DBUILD_FEATURE_Y=OFF</code>。</p>
<p>根据选项的状态，我们在适当的位置添加了相关的配置。在这个例子中，如果选项 <code>BUILD_FEATURE_X</code> 被设置为 <code>ON</code>，就会构建名为 <code>feature_x</code> 的子目录中的内容。类似地，如果选项 <code>BUILD_FEATURE_Y</code> 被设置为 <code>ON</code>，就会构建 <code>feature_y</code> 子目录中的内容。</p>
<p>在实际项目中，你可以根据需要添加更多的选项和配置。这样的构建选项使得用户能够根据项目需求自定义构建过程，只构建他们需要的功能。</p>
<h2 id="cmake-变量"><a href="#cmake-变量" class="headerlink" title="cmake 变量"></a>cmake 变量</h2><p>在CMake中，变量用于存储和操作数据，可以在CMake脚本中定义、设置和使用。下面是对CMake变量的详细解释：</p>
<ol>
<li><p>CMake缓存变量（CMake Cache Variables）：这些变量存储在CMake缓存中，并可以通过CMake GUI或命令行进行设置。它们在多次运行CMake时保持持久，并且可以影响项目的配置。常见的CMake缓存变量包括<code>CMAKE_INSTALL_PREFIX</code>（安装路径）、<code>CMAKE_BUILD_TYPE</code>（构建类型）等。</p>
</li>
<li><p>CMake内部变量（CMake Internal Variables）：这些变量由CMake自身设置和使用，用于控制CMake的行为和功能。它们具有特殊的前缀或名称，例如<code>CMAKE_SOURCE_DIR</code>（项目根目录路径）、<code>CMAKE_BINARY_DIR</code>（构建目录路径）等。</p>
</li>
<li><p>用户定义变量：这些变量由用户在CMake脚本中定义和设置。使用<code>set()</code>函数可以创建用户定义变量，并使用<code>$&#123;&#125;</code>语法引用它们。例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_VARIABLE <span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>环境变量：CMake可以读取和使用系统环境变量。可以使用<code>$ENV&#123;VAR_NAME&#125;</code>语法引用环境变量。例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Home directory: $ENV&#123;HOME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cache Entry变量：CMake提供了<code>set()</code>函数的高级形式，用于创建带有用户友好描述和其他属性的缓存变量。例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_VARIABLE <span class="string">&quot;Hello, world!&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;A user-friendly description&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为<code>MY_VARIABLE</code>的缓存变量，它具有用户友好的描述和其他属性，可以在CMake GUI中显示和设置。</p>
</li>
<li><p>List变量：List变量是一种特殊类型的变量，可以包含多个值。你可以使用<code>set()</code>函数将多个值存储到List变量中，并使用<code>$&#123;&#125;</code>语法访问和操作它们。例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(LIST_VARIABLE <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;List variable: $&#123;LIST_VARIABLE&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果将是<code>value1;value2;value3</code>。</p>
</li>
</ol>
<p>这些是CMake中常见的变量类型和用法。在CMake脚本中，你可以根据需要使用这些变量来控制和配置项目。</p>
<hr>
<h2 id="cmake-3-10-2-option"><a href="#cmake-3-10-2-option" class="headerlink" title="cmake 3.10.2 option"></a>cmake 3.10.2 option</h2><p>在CMake 3.10.2版本中，<code>option</code>命令用于定义和处理用户选项。它允许您在CMake配置过程中提供一些可配置的选项，以便用户可以根据需要进行选择。</p>
<p>以下是<code>option</code>命令的语法：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span>(&lt;option_variable&gt; <span class="string">&quot;&lt;option_description&gt;&quot;</span> [initial_value])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;option_variable&gt;</code>：要定义的选项的变量名。</li>
<li><code>&lt;option_description&gt;</code>：选项的描述文本，将在配置过程中显示给用户。</li>
<li><code>[initial_value]</code>：选项的初始值，默认情况下为<code>OFF</code>。如果用户选择了该选项，则变量的值为<code>ON</code>。</li>
</ul>
<p>使用<code>option</code>命令定义选项后，可以通过<code>$&#123;&lt;option_variable&gt;&#125;</code>来引用选项的值。</p>
<p>以下是一个示例，展示了CMake 3.10.2中<code>option</code>命令的使用：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span>(BUILD_TESTS <span class="string">&quot;Build test targets&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">option</span>(DEBUG_LOGGING <span class="string">&quot;Enable debug logging&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_TESTS)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Building test targets&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Not building test targets&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(DEBUG_LOGGING)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Debug logging is enabled&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Debug logging is disabled&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>在上述示例中，定义了两个选项：<code>BUILD_TESTS</code>和<code>DEBUG_LOGGING</code>。<code>BUILD_TESTS</code>的初始值为<code>ON</code>，而<code>DEBUG_LOGGING</code>的初始值为<code>OFF</code>。</p>
<p>根据选项的值，使用<code>if</code>语句来执行相应的操作。如果<code>BUILD_TESTS</code>为<code>ON</code>，则输出”Building test targets”；否则输出”Not building test targets”。如果<code>DEBUG_LOGGING</code>为<code>ON</code>，则输出”Debug logging is enabled”；否则输出”Debug logging is disabled”。</p>
<p>在CMake的配置过程中，用户可以通过设置这些选项来控制构建的行为。</p>
<p>请注意，选项的值是通过CMake<strong>缓存系统</strong>进行保存的，可以通过命令行选项或图形界面工具来修改选项的值。</p>
<h2 id="cmake-find-library-和-find-package"><a href="#cmake-find-library-和-find-package" class="headerlink" title="cmake find_library 和 find_package"></a>cmake find_library 和 find_package</h2><p><code>find_library</code> 和 <code>find_package</code> 是 CMake 中用于查找库的两个不同的命令，它们各自适用于不同的场景和目的。</p>
<h3 id="find-library"><a href="#find-library" class="headerlink" title="find_library:"></a><code>find_library</code>:</h3><ul>
<li><strong>用途：</strong> <code>find_library</code> 用于查找和定位系统中的库文件。</li>
<li><strong>语法：</strong> <code>find_library(&lt;VAR&gt; names...)</code></li>
<li><strong>示例：</strong><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_library</span>(MY_LIBRARY mylib)</span><br><span class="line"><span class="keyword">if</span>(MY_LIBRARY)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Library found: $&#123;MY_LIBRARY&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Library not found&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li>
<li><strong>说明：</strong> <code>find_library</code> 将库文件的名称传递给 <code>names</code> 参数，并尝试在系统中找到该库文件。如果找到，它将设置 <code>&lt;VAR&gt;</code> 变量为库文件的完整路径。在上述示例中，如果找到名为 <code>libmylib.so</code> 的库文件，<code>MY_LIBRARY</code> 变量将被设置为该库文件的完整路径。</li>
</ul>
<h3 id="find-package"><a href="#find-package" class="headerlink" title="find_package:"></a><code>find_package</code>:</h3><ul>
<li><strong>用途：</strong> <code>find_package</code> 用于查找和配置第三方软件包，通常用于查找 CMake 模块。</li>
<li><strong>语法：</strong> <code>find_package(&lt;PackageName&gt; [version] [EXACT] [QUIET] [MODULE] [REQUIRED] [COMPONENTS [components...]])</code></li>
<li><strong>示例：</strong><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost <span class="number">1.70</span> REQUIRED COMPONENTS filesystem system)</span><br><span class="line"><span class="keyword">if</span>(Boost_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Boost found: $&#123;Boost_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Boost libraries: $&#123;Boost_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Boost not found&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li>
<li><strong>说明：</strong> <code>find_package</code> 用于查找并配置第三方软件包，通常使用 CMake 模块来实现。在上述示例中，<code>find_package</code> 尝试查找 Boost 库，并确保找到指定版本以及必需的组件（filesystem 和 system）。如果找到，它将设置相应的变量（例如，<code>Boost_INCLUDE_DIRS</code> 和 <code>Boost_LIBRARIES</code>）以供后续使用。</li>
</ul>
<h3 id="选择使用："><a href="#选择使用：" class="headerlink" title="选择使用："></a>选择使用：</h3><ul>
<li>如果你只需要查找和链接系统中的某个库文件，可以使用 <code>find_library</code>。</li>
<li>如果你需要查找和配置第三方软件包，使用 <code>find_package</code> 通常更方便，因为它可以利用 CMake 模块提供的更多信息。</li>
</ul>
<p>总体来说，选择使用哪一个命令取决于你的具体需求和项目的复杂性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/CMake/cmake_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-cmake_3_01_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/CMake/cmake_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-cmake_3_01_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">cmake_3_01_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>CMake常用的方法和CMakeLists编程技巧</li>
</ul>
<h2 id="cmake-选择编译器及设置编译器选项"><a href="#cmake-选择编译器及设置编译器选项" class="headerlink" title="cmake 选择编译器及设置编译器选项"></a>cmake 选择编译器及设置编译器选项</h2><h3 id="使用命令行"><a href="#使用命令行" class="headerlink" title="使用命令行"></a>使用命令行</h3><ul>
<li>在编译时可以通过参数直接选择指定的编译器的完整路径，例如gcc8.3.0安装在&#x2F;usr&#x2F;local&#x2F;gcc&#x2F;bin路径下，在编译时输入： cmake .. -DCMAKE_CXX_COMPILER&#x3D;&#x2F;usr&#x2F;local&#x2F;gcc&#x2F;bin&#x2F;g++</li>
</ul>
<h3 id="在配置文件中指定"><a href="#在配置文件中指定" class="headerlink" title="在配置文件中指定"></a>在配置文件中指定</h3><ul>
<li>在CMakeLists.txt文件中添加<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">&quot;/usr/local/gcc/bin/gcc&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;/usr/local/gcc/bin/g++&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>直接修改全局变量CMAKE_C_COMPILER和CMAKE_CXX_COMPILER为指定的编译器路径</li>
<li>注：<strong>这两条命令应该放在文件的开始位置(cmake_minimum_required命令之下，其他命令之上，否则可能无效)</strong></li>
</ul>
<h2 id="CMakeLists-添加宏定义"><a href="#CMakeLists-添加宏定义" class="headerlink" title="CMakeLists 添加宏定义"></a>CMakeLists 添加宏定义</h2><p>在 CMake 中，要添加宏定义（宏定义通常用于条件编译），您可以使用 <code>add_definitions</code> 或 <code>target_compile_definitions</code> 命令，具体取决于您希望将宏定义应用于整个项目还是特定的目标。</p>
<p><strong>1. 使用 <code>add_definitions</code> 添加宏定义（全局）：</strong></p>
<p><code>add_definitions</code> 命令用于在整个项目范围内添加宏定义。在 CMakeLists.txt 文件中，您可以像这样添加宏定义：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-DMY_MACRO=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这将定义一个名为 <code>MY_MACRO</code> 的宏，其值为 <code>1</code>。您可以在项目的任何源文件中使用该宏。</p>
<p><strong>2. 使用 <code>target_compile_definitions</code> 添加宏定义（特定目标）：</strong></p>
<p>如果您只想为特定目标（如可执行文件或库）添加宏定义，可以使用 <code>target_compile_definitions</code> 命令。例如，假设您有一个名为 <code>my_target</code> 的目标：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(my_target PRIVATE MY_MACRO=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这将为 <code>my_target</code> 目标添加一个名为 <code>MY_MACRO</code> 的宏，其值为 <code>1</code>。<code>PRIVATE</code> 关键字表示该宏定义仅应用于 <code>my_target</code>，而不会传播到其他目标。</p>
<p>请根据您的项目需求和结构选择适当的方法来添加宏定义。无论是使用 <code>add_definitions</code> 还是 <code>target_compile_definitions</code>，都可以为您的 CMake 项目添加宏定义以进行条件编译。</p>
<h2 id="cmake-CMakeLists-txt文件编译多个可执行文件-for循环-示例-详解"><a href="#cmake-CMakeLists-txt文件编译多个可执行文件-for循环-示例-详解" class="headerlink" title="cmake CMakeLists.txt文件编译多个可执行文件 for循环 示例 详解"></a>cmake CMakeLists.txt文件编译多个可执行文件 for循环 示例 详解</h2><p>要在CMake中使用循环来生成多个可执行文件，通常需要使用CMake的<code>foreach</code>循环结构。下面是一个示例CMakeLists.txt文件，展示如何使用<code>foreach</code>循环来生成多个可执行文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有要编译的可执行文件</span></span><br><span class="line"><span class="keyword">set</span>(executables</span><br><span class="line">    MyExecutable1</span><br><span class="line">    MyExecutable2</span><br><span class="line">    MyExecutable3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历可执行文件列表并生成它们</span></span><br><span class="line"><span class="keyword">foreach</span>(executable <span class="variable">$&#123;executables&#125;</span>)</span><br><span class="line">    <span class="comment"># 每个可执行文件的源文件</span></span><br><span class="line">    <span class="keyword">set</span>(<span class="variable">$&#123;executable&#125;</span>_sources <span class="variable">$&#123;executable&#125;</span>.cpp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加可执行文件</span></span><br><span class="line">    <span class="keyword">add_executable</span>(<span class="variable">$&#123;executable&#125;</span> <span class="variable">$&#123;$&#123;executable&#125;</span>_sources&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果可执行文件有依赖库文件，可以在这里链接它们</span></span><br><span class="line">    <span class="comment"># target_link_libraries($&#123;executable&#125; SomeLibrary)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>

<p>这个示例CMakeLists.txt文件包含以下关键部分：</p>
<ol>
<li><p><code>set(executables ...)</code>：这一行定义了一个变量<code>executables</code>，其中包含了要编译的多个可执行文件的名称。在这个示例中，我们列出了三个可执行文件的名称，但您可以根据需要添加更多。</p>
</li>
<li><p><code>foreach(executable $&#123;executables&#125;)</code>：这是一个<code>foreach</code>循环，用于迭代<code>executables</code>变量中的每个可执行文件名称。</p>
</li>
<li><p><code>set($&#123;executable&#125;_sources $&#123;executable&#125;.cpp)</code>：在循环内，我们为每个可执行文件设置了一个源文件变量，例如<code>MyExecutable1_sources</code>，这是根据可执行文件的名称构建的。</p>
</li>
<li><p><code>add_executable($&#123;executable&#125; $&#123;$&#123;executable&#125;_sources&#125;)</code>：在循环内，我们使用<code>add_executable</code>命令为每个可执行文件生成目标。<code>add_executable</code>使用了之前定义的源文件变量。</p>
</li>
<li><p>（可选）<code>target_link_libraries($&#123;executable&#125; SomeLibrary)</code>：如果可执行文件有依赖的库文件，可以使用此命令将它们链接到可执行文件。</p>
</li>
</ol>
<p>这种结构使您能够轻松地扩展项目，以支持多个可执行文件，而无需手动为每个文件编写<code>add_executable</code>命令。这在大型项目中特别有用，因为它可以减少配置文件的复杂性。</p>
<h2 id="cmake-CMakeLists-txt文件编译多个可执行文件常见结构-示例-详解"><a href="#cmake-CMakeLists-txt文件编译多个可执行文件常见结构-示例-详解" class="headerlink" title="cmake CMakeLists.txt文件编译多个可执行文件常见结构 示例 详解"></a>cmake CMakeLists.txt文件编译多个可执行文件常见结构 示例 详解</h2><p>CMake是一个用于管理C++项目的跨平台构建工具，它允许您配置项目并生成适用于不同编译器和操作系统的构建系统。在CMake中，通常将项目的构建配置信息保存在一个名为CMakeLists.txt的文件中。</p>
<p>如果您想要在一个CMake项目中编译多个可执行文件，通常可以按照以下结构来组织CMakeLists.txt文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)  <span class="comment"># 指定最低的CMake版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(MyProject)  <span class="comment"># 指定项目名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件1</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable1</span><br><span class="line">    source1.cpp</span><br><span class="line">    source2.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件2</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable2</span><br><span class="line">    source3.cpp</span><br><span class="line">    source4.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：如果项目中有共享的库文件，可以使用add_library添加库文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库文件到可执行文件1</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable1</span><br><span class="line">    SomeLibrary1</span><br><span class="line">    SomeLibrary2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接库文件到可执行文件2</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable2</span><br><span class="line">    SomeLibrary3</span><br><span class="line">    SomeLibrary4</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上述代码是一个简单的CMakeLists.txt文件，用于编译两个可执行文件。以下是对代码的详细解释：</p>
<ol>
<li><p><code>cmake_minimum_required(VERSION 3.0)</code>：这一行指定了项目所需的最低CMake版本。您可以根据您的需要更改此版本号。</p>
</li>
<li><p><code>project(MyProject)</code>：这一行指定了项目的名称。在这里，项目名称被设置为”MyProject”，您可以将其替换为您的项目名称。</p>
</li>
<li><p><code>add_executable(MyExecutable1 source1.cpp source2.cpp)</code>：这一行添加了一个名为”MyExecutable1”的可执行文件，并指定了源代码文件(source1.cpp和source2.cpp)。您可以根据您的项目需要添加更多的源文件。</p>
</li>
<li><p><code>add_executable(MyExecutable2 source3.cpp source4.cpp)</code>：同样，这一行添加了一个名为”MyExecutable2”的可执行文件，并指定了不同的源代码文件。</p>
</li>
<li><p><code>target_link_libraries(MyExecutable1 SomeLibrary1 SomeLibrary2)</code>：如果您的项目依赖于一些库文件，您可以使用这行来链接这些库文件到”MyExecutable1”。类似地，您可以为”MyExecutable2”链接其他库文件。</p>
</li>
</ol>
<p>这只是一个简单的示例，CMake支持更复杂的项目结构和配置选项，可以根据实际需求进行定制。在实际项目中，您可能需要添加更多的配置信息，如编译选项、包含路径、安装规则等。请根据您的项目需求进一步扩展和定制CMakeLists.txt文件。</p>
<h2 id="cmake-CMakeLists-txt文件常见结构-示例-详解"><a href="#cmake-CMakeLists-txt文件常见结构-示例-详解" class="headerlink" title="cmake CMakeLists.txt文件常见结构 示例 详解"></a>cmake CMakeLists.txt文件常见结构 示例 详解</h2><p>CMakeLists.txt文件是CMake项目的核心配置文件，它定义了项目的属性、源文件、依赖关系和构建规则。以下是一个常见的CMakeLists.txt文件结构示例，带有详细的解释：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定CMake的最低版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义项目名称</span></span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件并指定源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(myapp</span><br><span class="line">    main.cpp         <span class="comment"># 主程序入口</span></span><br><span class="line">    utils.cpp        <span class="comment"># 自定义工具函数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可选的编译标志</span></span><br><span class="line"><span class="comment"># add_compile_options(-std=c++11)  # 设置C++标准，可选</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找并添加依赖的库（例如，查找并添加Boost库）</span></span><br><span class="line"><span class="comment"># find_package(Boost REQUIRED)</span></span><br><span class="line"><span class="comment"># include_directories($&#123;Boost_INCLUDE_DIRS&#125;)</span></span><br><span class="line"><span class="comment"># target_link_libraries(myapp $&#123;Boost_LIBRARIES&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出目录，将可执行文件放在bin目录中</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置C++标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加子目录，可以在子目录中定义更多的CMakeLists.txt文件</span></span><br><span class="line"><span class="comment"># add_subdirectory(subdirectory_name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以定义自定义的构建规则、安装规则等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以包括其他CMakeLists.txt文件</span></span><br><span class="line"><span class="comment"># include(subdirectory_name/CMakeLists.txt)</span></span><br></pre></td></tr></table></figure>

<p>上述示例演示了一个简单的CMakeLists.txt文件，以下是各个部分的详细解释：</p>
<ol>
<li><p><code>cmake_minimum_required(VERSION 3.0)</code>：这一行指定了最低的CMake版本要求。</p>
</li>
<li><p><code>project(MyProject)</code>：这一行定义了项目的名称。项目名称将用于生成构建文件和可执行文件的前缀。</p>
</li>
<li><p><code>add_executable(myapp ...)</code>：这一行定义了可执行文件（myapp）以及与之关联的源文件。列出了要包括在可执行文件中的所有源文件。</p>
</li>
<li><p><code>add_compile_options(-std=c++11)</code>：这是一个可选部分，用于设置编译选项。在这里，它设置了C++标准为C++11。</p>
</li>
<li><p><code>find_package(Boost REQUIRED)</code>：这是一个可选的示例，用于查找并添加依赖的库。在这里，它查找并添加了Boost库。</p>
</li>
<li><p><code>set(EXECUTABLE_OUTPUT_PATH $&#123;CMAKE_BINARY_DIR&#125;/bin)</code>：这一行指定了可执行文件的输出目录，通常会将可执行文件放在<code>bin</code>子目录中。</p>
</li>
<li><p><code>set(CMAKE_CXX_STANDARD 11)</code>：这一行指定了项目所使用的C++标准。</p>
</li>
<li><p><code>add_subdirectory(subdirectory_name)</code>：这一行用于包括子目录，如果项目需要包括其他模块或库，你可以在子目录中定义另一个CMakeLists.txt文件。</p>
</li>
<li><p><code>include(subdirectory_name/CMakeLists.txt)</code>：这一行可以用于包括其他CMakeLists.txt文件，如果你希望将其他项目的构建规则包括到当前项目中。</p>
</li>
</ol>
<p>这只是一个简单的示例，你可以根据项目的需求和复杂性来扩展和修改CMakeLists.txt文件。CMake提供了广泛的选项和命令，以支持各种不同类型的项目和构建需求。</p>
<h2 id="cmake-3-10-2-退出-终止-命令"><a href="#cmake-3-10-2-退出-终止-命令" class="headerlink" title="cmake 3.10.2 退出 终止 命令"></a>cmake 3.10.2 退出 终止 命令</h2><p>在CMake 3.10.2版本中，可以使用<code>return()</code>命令来退出当前的CMake脚本的执行。这个命令会立即终止当前脚本的执行，并返回到调用方。</p>
<p>以下是<code>return()</code>命令的用法：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>()</span><br></pre></td></tr></table></figure>

<p>当调用<code>return()</code>命令时，CMake会立即停止执行当前的CMake脚本，并返回到调用方。</p>
<p>以下是一个简单的示例，演示如何使用<code>return()</code>命令退出CMake脚本的执行：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查条件，如果不满足则退出脚本</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> SOME_CONDITION)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Condition not met, exiting...&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行其他操作</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Continuing execution...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，如果<code>SOME_CONDITION</code>条件不满足，那么在执行到<code>return()</code>命令时，脚本将立即退出并返回到调用方。否则，将继续执行后续的操作。</p>
<p>请注意，<code>return()</code>命令只能用于退出当前的CMake脚本，并返回到调用方。它不会终止整个CMake过程。如果您需要终止整个CMake过程，可以使用<code>message(FATAL_ERROR &quot;Error message&quot;)</code>命令，该命令会显示一个致命错误消息并终止整个CMake过程的执行。</p>
<hr>
<h2 id="cmake-3-10-2-switch-选择实现"><a href="#cmake-3-10-2-switch-选择实现" class="headerlink" title="cmake 3.10.2 switch 选择实现"></a>cmake 3.10.2 switch 选择实现</h2><p>在CMake 3.10.2版本中，由于没有直接支持的<code>switch</code>语句，您可以使用多个<code>if</code>和<code>elseif</code>语句来实现类似的功能。</p>
<p>以下是一个示例，展示如何使用多个<code>if</code>和<code>elseif</code>语句实现类似<code>switch</code>的功能：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(SWITCH_VAR <span class="string">&quot;value2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SWITCH_VAR <span class="keyword">STREQUAL</span> <span class="string">&quot;value1&quot;</span>)</span><br><span class="line">    <span class="comment"># 执行value1对应的操作</span></span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Switch case: value1&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(SWITCH_VAR <span class="keyword">STREQUAL</span> <span class="string">&quot;value2&quot;</span>)</span><br><span class="line">    <span class="comment"># 执行value2对应的操作</span></span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Switch case: value2&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(SWITCH_VAR <span class="keyword">STREQUAL</span> <span class="string">&quot;value3&quot;</span>)</span><br><span class="line">    <span class="comment"># 执行value3对应的操作</span></span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Switch case: value3&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="comment"># 执行默认的操作</span></span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Switch default case&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了多个<code>if</code>和<code>elseif</code>语句来检查变量<code>SWITCH_VAR</code>的值，并根据不同的条件执行相应的操作。如果<code>SWITCH_VAR</code>的值等于<code>value1</code>，则执行与<code>value1</code>对应的操作；如果<code>SWITCH_VAR</code>的值等于<code>value2</code>，则执行与<code>value2</code>对应的操作，依此类推。如果没有匹配的条件，将执行<code>else</code>语句中定义的默认操作。</p>
<p>虽然这种方式在CMake 3.10.2中没有直接的<code>switch</code>语句，但通过使用多个<code>if</code>和<code>elseif</code>语句，您可以根据不同的条件选择不同的操作，实现类似<code>switch</code>的功能。请根据实际需求编写适当的条件判断，并执行相应的操作。</p>
<hr>
<h2 id="cmake-3-10-2-通过宏选择不同目标编译"><a href="#cmake-3-10-2-通过宏选择不同目标编译" class="headerlink" title="cmake 3.10.2 通过宏选择不同目标编译"></a>cmake 3.10.2 通过宏选择不同目标编译</h2><p>在CMake 3.10.2版本中，可以使用<code>option</code>命令来定义宏，并通过<code>if</code>语句来选择不同的目标编译。以下是一个示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义宏，用于选择编译选项</span></span><br><span class="line"><span class="keyword">option</span>(BUILD_TARGET_A <span class="string">&quot;Build target A&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">option</span>(BUILD_TARGET_B <span class="string">&quot;Build target B&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加源文件</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES src/main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据宏的值，选择要构建的目标</span></span><br><span class="line"><span class="keyword">if</span>(BUILD_TARGET_A)</span><br><span class="line">    <span class="keyword">add_executable</span>(targetA <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line">    <span class="comment"># 其他针对目标A的配置</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_TARGET_B)</span><br><span class="line">    <span class="keyword">add_executable</span>(targetB <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line">    <span class="comment"># 其他针对目标B的配置</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用<code>option</code>命令定义了两个宏：<code>BUILD_TARGET_A</code>和<code>BUILD_TARGET_B</code>。这两个宏的默认值分别为ON和OFF。根据这些宏的值，我们使用<code>if</code>语句选择要构建的目标。</p>
<p>要使用CMake 3.10.2版本运行上述CMakeLists.txt文件，可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -H. -Bbuild</span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>

<p>这将在<code>build</code>目录中生成构建文件，并使用生成的构建文件来构建目标。</p>
<p>请注意，如果您的CMake版本较旧，某些语法可能不受支持。确保在运行CMake命令之前，检查您所使用的CMake版本是否支持所需的功能。</p>
<hr>
<h2 id="cmake-3-10-2-打印-语法"><a href="#cmake-3-10-2-打印-语法" class="headerlink" title="cmake 3.10.2 打印 语法"></a>cmake 3.10.2 打印 语法</h2><p>在CMake 3.10.2版本中，您可以使用<code>message</code>命令来打印消息、变量值和其他调试信息。<code>message</code>命令的语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([&lt;mode&gt;] <span class="string">&quot;&lt;message string&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>其中，<code>mode</code>是可选参数，用于指定消息的类型。常用的<code>mode</code>参数有以下几种：</p>
<ul>
<li><code>STATUS</code>：打印带有前缀<code>--</code>的消息。</li>
<li><code>WARNING</code>：打印带有前缀<code>-- Warning:</code>的警告消息。</li>
<li><code>AUTHOR_WARNING</code>：打印带有前缀<code>-- Author Warning:</code>的作者警告消息。</li>
<li><code>SEND_ERROR</code>：打印带有前缀<code>-- Send Error:</code>的错误消息，并停止配置过程。</li>
<li><code>FATAL_ERROR</code>：打印带有前缀<code>-- FATAL_ERROR:</code>的严重错误消息，并停止配置过程。</li>
<li><code>DEPRECATION</code>：打印带有前缀<code>-- DEPRECATION:</code>的过时警告消息。</li>
</ul>
<p>以下是一些示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印普通消息</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;This is a message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印带有前缀的消息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;This is a status message&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;This is a warning message&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(AUTHOR_WARNING <span class="string">&quot;This is an author warning message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印错误消息并停止配置过程</span></span><br><span class="line"><span class="keyword">message</span>(SEND_ERROR <span class="string">&quot;This is an error message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印严重错误消息并停止配置过程</span></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;This is a fatal error message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印过时警告消息</span></span><br><span class="line"><span class="keyword">message</span>(DEPRECATION <span class="string">&quot;This is a deprecation warning message&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当运行CMake时，这些消息将显示在终端上，以便您查看配置过程中的相关信息、警告和错误。</p>
<p>请注意，<code>message</code>命令在CMake 3.10.2版本中的语法与较新版本（如CMake 3.21）中的语法略有不同。如果您的CMake版本是3.10.2，可以使用上述示例来打印消息。如果使用的是较新版本的CMake，请参考官方文档以获取更准确的语法信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Compiler/LLVM/2024-05-22-Clang-llvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Compiler/LLVM/2024-05-22-Clang-llvm/" class="post-title-link" itemprop="url">Clang-llvm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p><code>-fsyntax-only</code>  –  语义分析</p>
</li>
<li><p><code>-D&lt;macroname&gt;=&lt;value&gt;</code>  –  定义宏</p>
</li>
<li><p><code>-include &lt;filename&gt;</code>  </p>
</li>
<li><p><code>-I&lt;directory&gt;</code>  –  头文件路径</p>
</li>
<li><p><code>-ferror-limit=9999</code>  –  错误警告数量</p>
</li>
<li><p><code>clang++</code>  – C++编译器</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/CMake/cmake_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-cmake_3_02_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/CMake/cmake_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-cmake_3_02_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">cmake_3_02_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cmake 常用的技巧</li>
</ul>
<h2 id="CMake-引用第三方库的CMakelists"><a href="#CMake-引用第三方库的CMakelists" class="headerlink" title="CMake 引用第三方库的CMakelists"></a>CMake 引用第三方库的CMakelists</h2><p>在 CMake 中引用第三方库的 <code>CMakeLists.txt</code> 主要有以下几种方式：</p>
<h2 id="1-使用-find-package"><a href="#1-使用-find-package" class="headerlink" title="1. 使用 find_package"></a>1. <strong>使用 <code>find_package</code></strong></h2><p>适用于已安装在系统中的库（如 OpenCV、Boost）。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 OpenCV 库</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 OpenCV 库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含 OpenCV 头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-使用-add-subdirectory"><a href="#2-使用-add-subdirectory" class="headerlink" title="2. 使用 add_subdirectory"></a>2. <strong>使用 <code>add_subdirectory</code></strong></h2><p>适用于将源码包含在项目中的库。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加第三方库的源码目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(third_party/MyLib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接第三方库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE MyLib)</span><br></pre></td></tr></table></figure>

<h2 id="3-使用-FetchContent"><a href="#3-使用-FetchContent" class="headerlink" title="3. 使用 FetchContent"></a>3. <strong>使用 <code>FetchContent</code></strong></h2><p>适用于自动下载并编译第三方库。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">    fmt</span><br><span class="line">    GIT_REPOSITORY https://github.com/fmtlib/fmt.git</span><br><span class="line">    GIT_TAG <span class="number">10.0</span>.<span class="number">0</span></span><br><span class="line">)</span><br><span class="line">FetchContent_MakeAvailable(fmt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE fmt)</span><br></pre></td></tr></table></figure>

<h2 id="4-使用-ExternalProject-Add"><a href="#4-使用-ExternalProject-Add" class="headerlink" title="4. 使用 ExternalProject_Add"></a>4. <strong>使用 <code>ExternalProject_Add</code></strong></h2><p>适用于构建时拉取和编译外部库，而不直接暴露给 CMake。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(ExternalProject)</span><br><span class="line">ExternalProject_Add(</span><br><span class="line">    MyExternalLib</span><br><span class="line">    GIT_REPOSITORY https://github.com/some/library.git</span><br><span class="line">    GIT_TAG master</span><br><span class="line">    CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/external</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定库的路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/external/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/external/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE MyExternalLib)</span><br></pre></td></tr></table></figure>

<h2 id="5-使用-pkg-config"><a href="#5-使用-pkg-config" class="headerlink" title="5. 使用 pkg-config"></a>5. <strong>使用 <code>pkg-config</code></strong></h2><p>适用于 Linux 上的系统库。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PkgConfig REQUIRED)</span><br><span class="line">pkg_check_modules(GLIB REQUIRED glib-<span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(MyExecutable PRIVATE <span class="variable">$&#123;GLIB_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE <span class="variable">$&#123;GLIB_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="选择合适的方法："><a href="#选择合适的方法：" class="headerlink" title="选择合适的方法："></a>选择合适的方法：</h3><ul>
<li><strong>已安装库</strong> → <code>find_package</code></li>
<li><strong>源码包含在项目中</strong> → <code>add_subdirectory</code></li>
<li><strong>在线拉取</strong> → <code>FetchContent</code> 或 <code>ExternalProject_Add</code></li>
<li><strong>Linux 系统库</strong> → <code>pkg-config</code></li>
</ul>
<p>你具体是想引用哪个库？</p>
<h2 id="vscode中cmake项目配置文件手动修改编译器路径"><a href="#vscode中cmake项目配置文件手动修改编译器路径" class="headerlink" title="vscode中cmake项目配置文件手动修改编译器路径"></a>vscode中cmake项目配置文件手动修改编译器路径</h2><p>在 VSCode 中，如果你想为 CMake 项目手动配置编译器路径，可以通过修改 <code>CMakeSettings.json</code> 或者 <code>.vscode/settings.json</code> 文件来实现。以下是配置步骤：</p>
<h3 id="1-使用-CMakeSettings-json"><a href="#1-使用-CMakeSettings-json" class="headerlink" title="1. 使用 CMakeSettings.json"></a>1. 使用 <code>CMakeSettings.json</code></h3><p>CMake 支持通过 <code>CMakeSettings.json</code> 来设置不同的构建配置，比如指定编译器路径。创建或修改项目根目录中的 <code>CMakeSettings.json</code> 文件，添加类似下面的配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x64-Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;generator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Ninja&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;configurationType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;buildRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;projectDir&#125;\\out\\build\\$&#123;name&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;installRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;projectDir&#125;\\out\\install\\$&#123;name&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cmakeCommandArgs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;buildCommandArgs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ctestCommandArgs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;variables&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CMAKE_C_COMPILER&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/Your/Compiler/gcc.exe&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CMAKE_CXX_COMPILER&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/Your/Compiler/g++.exe&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这会告诉 CMake 使用指定的编译器路径。</p>
<h3 id="2-使用-vscode-settings-json"><a href="#2-使用-vscode-settings-json" class="headerlink" title="2. 使用 .vscode/settings.json"></a>2. 使用 <code>.vscode/settings.json</code></h3><p>你也可以直接在 VSCode 的工作区配置中设置编译器路径，方法是修改 <code>.vscode/settings.json</code> 文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cmake.cmakePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/CMake/cmake.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cmake.generator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Ninja&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cmake.buildDirectory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cmake.environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;CC&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/Your/Compiler/gcc.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;CXX&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/Your/Compiler/g++.exe&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里 <code>cmake.environment</code> 变量用于指定 C 和 C++ 编译器路径。</p>
<h3 id="3-通过-CMakeLists-txt-文件"><a href="#3-通过-CMakeLists-txt-文件" class="headerlink" title="3. 通过 CMakeLists.txt 文件"></a>3. 通过 <code>CMakeLists.txt</code> 文件</h3><p>你也可以在 <code>CMakeLists.txt</code> 中直接添加设置编译器的指令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">&quot;C:/Path/To/Your/Compiler/gcc.exe&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;C:/Path/To/Your/Compiler/g++.exe&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-使用-cmake-kits-json"><a href="#4-使用-cmake-kits-json" class="headerlink" title="4. 使用 cmake-kits.json"></a>4. 使用 <code>cmake-kits.json</code></h3><p>VSCode 的 CMake Tools 扩展提供了一种通过 <code>cmake-kits.json</code> 来管理编译器的方式。你可以在 <code>.vscode/cmake-kits.json</code> 中定义编译器路径：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GCC&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;compilers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;C&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/Your/Compiler/gcc.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;CXX&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Path/To/Your/Compiler/g++.exe&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>然后在 VSCode 的 CMake Tools 扩展中选择这个编译器套件。</p>
<h3 id="5-选择编译器"><a href="#5-选择编译器" class="headerlink" title="5. 选择编译器"></a>5. 选择编译器</h3><p>如果你已经配置了多个编译器，可以通过命令面板（<code>Ctrl+Shift+P</code>）打开 <code>CMake: Select a Kit</code>，然后从列表中选择你配置的编译器。</p>
<p>这几种方式都可以帮助你手动指定 CMake 项目的编译器路径。</p>
<h2 id="cmake-静态链接库顺序问题"><a href="#cmake-静态链接库顺序问题" class="headerlink" title="cmake 静态链接库顺序问题"></a>cmake 静态链接库顺序问题</h2><ul>
<li><p>默认情况下要求被依赖的库放在依赖它的库后面，当一个程序或共享库依赖的静态库较多时，可能会陷入解决链接问题的坑中。如果对静态库不熟悉，需要结构nm等工具来解决顺序问题。</p>
</li>
<li><p>如果去掉顺序的烦恼和痛苦，可以采用如下方法</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    x</span><br><span class="line">    -Wl,--start-group</span><br><span class="line">    libX1.a</span><br><span class="line">    libX3.a</span><br><span class="line">    libX2.a</span><br><span class="line">    -Wl,--end-group</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="cmake-设置编译线程数量"><a href="#cmake-设置编译线程数量" class="headerlink" title="cmake 设置编译线程数量"></a>cmake 设置编译线程数量</h2><p>在使用 CMake 构建项目时，你可以通过设置编译器选项来指定编译时使用的线程数量。具体步骤如下：</p>
<ol>
<li><p><strong>使用 <code>cmake</code> 命令配置项目：</strong><br>例如，你可以在项目根目录中运行以下命令来生成构建文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>cmake --build</code> 命令进行构建并指定线程数量：</strong><br>使用 <code>--parallel</code> 选项可以指定编译时使用的线程数量。例如，如果你想使用 8 个线程来进行编译，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build build --parallel 8</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样，CMake 会根据你指定的线程数量来并行执行构建任务，从而加快编译速度。</p>
<p>完整的流程示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build</span><br><span class="line">cmake --build build --parallel 8</span><br></pre></td></tr></table></figure>

<p>此外，你还可以直接在 <code>make</code> 或 <code>ninja</code> 命令中指定线程数量（假设你使用的是这些生成器）：</p>
<ul>
<li>对于 <code>make</code> 生成器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure></li>
<li>对于 <code>ninja</code> 生成器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -j8</span><br></pre></td></tr></table></figure></li>
</ul>
<p>CMake 会根据你的项目配置选择合适的生成器并使用相应的构建工具。</p>
<h2 id="CMakeLists-txt-编译性能参数配置"><a href="#CMakeLists-txt-编译性能参数配置" class="headerlink" title="CMakeLists.txt 编译性能参数配置"></a>CMakeLists.txt 编译性能参数配置</h2><p>在 <code>CMakeLists.txt</code> 中配置编译性能参数，可以通过一些特定的编译选项和设置来优化编译时间和资源使用。以下是一些常见的方法和配置选项，可以用来提升编译性能：</p>
<h3 id="1-使用-CMAKE-BUILD-TYPE"><a href="#1-使用-CMAKE-BUILD-TYPE" class="headerlink" title="1. 使用 CMAKE_BUILD_TYPE"></a>1. 使用 <code>CMAKE_BUILD_TYPE</code></h3><p>通过设置 <code>CMAKE_BUILD_TYPE</code> 可以启用特定的编译器优化选项。例如，在开发过程中可以设置为 <code>Debug</code>，在发布时设置为 <code>Release</code>。使用 <code>Release</code> 模式可以启用优化选项，从而减少生成的代码大小和提升执行性能。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br></pre></td></tr></table></figure>

<h3 id="2-使用-CMAKE-CXX-FLAGS-和-CMAKE-C-FLAGS"><a href="#2-使用-CMAKE-CXX-FLAGS-和-CMAKE-C-FLAGS" class="headerlink" title="2. 使用 CMAKE_CXX_FLAGS 和 CMAKE_C_FLAGS"></a>2. 使用 <code>CMAKE_CXX_FLAGS</code> 和 <code>CMAKE_C_FLAGS</code></h3><p>可以为编译器指定一些优化选项，比如 <code>-O2</code> 或者 <code>-O3</code>，这些选项可以启用更多的编译器优化，从而提升生成代码的性能。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -O2&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -O2&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-使用-CMAKE-LINKER-FLAGS"><a href="#3-使用-CMAKE-LINKER-FLAGS" class="headerlink" title="3. 使用 CMAKE_LINKER_FLAGS"></a>3. 使用 <code>CMAKE_LINKER_FLAGS</code></h3><p>对于链接阶段，可以设置 <code>CMAKE_EXE_LINKER_FLAGS</code> 和 <code>CMAKE_SHARED_LINKER_FLAGS</code> 来优化链接器的行为。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -Wl,--as-needed&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125; -Wl,--as-needed&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-启用并行链接"><a href="#4-启用并行链接" class="headerlink" title="4. 启用并行链接"></a>4. 启用并行链接</h3><p>某些编译器和链接器支持并行链接，可以显著减少链接时间。对于 GNU 链接器，可以使用 <code>-Wl,--parallel</code>。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -Wl,--parallel&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125; -Wl,--parallel&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-使用-ccache"><a href="#5-使用-ccache" class="headerlink" title="5. 使用 ccache"></a>5. 使用 <code>ccache</code></h3><p><code>ccache</code> 是一个编译缓存工具，可以显著减少重复编译的时间。要在 CMake 中启用 <code>ccache</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_program</span>(CCACHE_PROGRAM ccache)</span><br><span class="line"><span class="keyword">if</span>(CCACHE_PROGRAM)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_C_COMPILER_LAUNCHER <span class="variable">$&#123;CCACHE_PROGRAM&#125;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_COMPILER_LAUNCHER <span class="variable">$&#123;CCACHE_PROGRAM&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h3 id="6-使用-Ninja-生成器"><a href="#6-使用-Ninja-生成器" class="headerlink" title="6. 使用 Ninja 生成器"></a>6. 使用 <code>Ninja</code> 生成器</h3><p><code>Ninja</code> 是一个快速的构建系统，通常比默认的 <code>Make</code> 更快。要使用 <code>Ninja</code>，可以在 CMake 配置阶段指定生成器：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G Ninja ..</span><br></pre></td></tr></table></figure>

<p>在 <code>CMakeLists.txt</code> 中没有直接指定 <code>Ninja</code> 的方法，但可以通过命令行来指定。</p>
<h3 id="7-预编译头文件"><a href="#7-预编译头文件" class="headerlink" title="7. 预编译头文件"></a>7. 预编译头文件</h3><p>预编译头文件可以显著减少编译时间，特别是当项目包含大量头文件时。可以通过 <code>target_precompile_headers</code> 指令来设置预编译头文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_precompile_headers(my_target PRIVATE precompiled.h)</span><br></pre></td></tr></table></figure>

<h3 id="8-使用编译选项优化"><a href="#8-使用编译选项优化" class="headerlink" title="8. 使用编译选项优化"></a>8. 使用编译选项优化</h3><p>根据不同的编译器，可以启用一些特定的优化选项。例如，针对 GCC，可以启用以下选项：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">STREQUAL</span> <span class="string">&quot;GNU&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -march=native -flto&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -march=native -flto&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><p>以下是一个包含上述多个优化配置的 <code>CMakeLists.txt</code> 示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译类型</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译器优化选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -O2 -march=native -flto&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -O2 -march=native -flto&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接器优化选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -Wl,--as-needed -Wl,--parallel&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125; -Wl,--as-needed -Wl,--parallel&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 ccache</span></span><br><span class="line"><span class="keyword">find_program</span>(CCACHE_PROGRAM ccache)</span><br><span class="line"><span class="keyword">if</span>(CCACHE_PROGRAM)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_C_COMPILER_LAUNCHER <span class="variable">$&#123;CCACHE_PROGRAM&#125;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_COMPILER_LAUNCHER <span class="variable">$&#123;CCACHE_PROGRAM&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预编译头文件</span></span><br><span class="line">target_precompile_headers(MyTarget PRIVATE precompiled.h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyTarget main.cpp)</span><br></pre></td></tr></table></figure>

<p>通过在 <code>CMakeLists.txt</code> 中添加这些配置，可以显著提升编译性能并减少系统资源的使用。</p>
<h2 id="cmake-子项目设置二进制文件保存路径"><a href="#cmake-子项目设置二进制文件保存路径" class="headerlink" title="cmake 子项目设置二进制文件保存路径"></a>cmake 子项目设置二进制文件保存路径</h2><p>要设置子项目的二进制文件保存路径，你可以在使用 <code>add_subdirectory()</code> 函数添加子项目时，通过第二个参数 <code>binary_dir</code> 来指定。</p>
<p>假设你有如下的项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">project_root/</span><br><span class="line">    CMakeLists.txt</span><br><span class="line">    src/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        file1.cpp</span><br><span class="line">        file2.cpp</span><br><span class="line">    test/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        test1.cpp</span><br><span class="line">        test2.cpp</span><br></pre></td></tr></table></figure>

<p>如果你希望将子项目的二进制文件保存在不同的目录中，可以像这样在父项目的 <code>CMakeLists.txt</code> 中设置：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src bin/src)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">test</span> bin/<span class="keyword">test</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>src</code> 子项目的二进制文件将保存在 <code>project_root/bin/src</code> 目录中，而 <code>test</code> 子项目的二进制文件将保存在 <code>project_root/bin/test</code> 目录中。</p>
<p>如果不指定 <code>binary_dir</code> 参数，子项目的二进制文件将默认保存在子项目目录下的 <code>bin</code> 目录中。</p>
<h2 id="cmake-在子项目中设置头文件包含目录"><a href="#cmake-在子项目中设置头文件包含目录" class="headerlink" title="cmake 在子项目中设置头文件包含目录"></a>cmake 在子项目中设置头文件包含目录</h2><p>在 CMake 中，你可以在子项目中使用 <code>target_include_directories()</code> 函数来设置头文件包含目录。这个函数用于为指定的目标（例如库或可执行文件）设置头文件搜索路径。假设你有如下的项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">project_root/</span><br><span class="line">    CMakeLists.txt</span><br><span class="line">    src/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        file1.cpp</span><br><span class="line">        file2.cpp</span><br><span class="line">        include/</span><br><span class="line">            header1.h</span><br><span class="line">            header2.h</span><br><span class="line">    test/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        test1.cpp</span><br><span class="line">        test2.cpp</span><br></pre></td></tr></table></figure>

<p>在 <code>src/CMakeLists.txt</code> 中，你可以这样设置头文件包含目录：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(my_target_name PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>my_target_name</code> 是你在 <code>src/CMakeLists.txt</code> 中定义的目标名称，<code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</code> 表示当前源码目录的路径，<code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include</code> 就是 <code>include</code> 目录的路径。使用 <code>PUBLIC</code> 关键字可以将这个头文件包含目录设置为公开的，这意味着这个目录将会被导出到依赖这个目标的其他目标中。</p>
<p>在 <code>test/CMakeLists.txt</code> 中，你也可以类似地设置头文件包含目录：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(test_target_name PRIVATE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/../src/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>test_target_name</code> 是你在 <code>test/CMakeLists.txt</code> 中定义的目标名称，<code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../src/include</code> 是相对于 <code>test</code> 目录的父目录 <code>src/include</code> 的路径。使用 <code>PRIVATE</code> 关键字可以将这个头文件包含目录设置为私有的，这意味着这个目录只对当前目标有效，不会被导出到依赖当前目标的其他目标中。</p>
<h2 id="cmake-打印目标的头文件路径和编译选项"><a href="#cmake-打印目标的头文件路径和编译选项" class="headerlink" title="cmake 打印目标的头文件路径和编译选项"></a>cmake 打印目标的头文件路径和编译选项</h2><p>要打印目标的头文件路径和编译选项，您可以使用 <code>get_target_property</code> 命令来获取目标的属性。以下是一个示例代码，假设您的目标名为 <code>my_target</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取目标的头文件路径</span></span><br><span class="line"><span class="keyword">get_target_property</span>(<span class="keyword">TARGET_INCLUDE_DIRECTORIES</span> my_target <span class="keyword">INCLUDE_DIRECTORIES</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;My target include directories: $&#123;TARGET_INCLUDE_DIRECTORIES&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目标的编译选项</span></span><br><span class="line"><span class="keyword">get_target_property</span>(<span class="keyword">TARGET_COMPILE_OPTIONS</span> my_target COMPILE_OPTIONS)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;My target compile options: $&#123;TARGET_COMPILE_OPTIONS&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码将打印出目标 <code>my_target</code> 的头文件路径和编译选项。您可以根据需要获取和打印其他属性。</p>
<h2 id="cmake-find-package-配置opencv库"><a href="#cmake-find-package-配置opencv库" class="headerlink" title="cmake find_package 配置opencv库"></a>cmake find_package 配置opencv库</h2><p>配置 OpenCV 库时，通常会使用 CMake 的 <code>find_package</code> 命令。以下是一个简单的示例，展示如何在 CMake 中配置和链接 OpenCV 库：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 find_package 查找并配置 OpenCV 库</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出找到的 OpenCV 库信息</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;OpenCV_INCLUDE_DIRS: $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;OpenCV_LIBRARIES: $&#123;OpenCV_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件，并链接 OpenCV 库</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(MyExecutable PRIVATE <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE <span class="variable">$&#123;OpenCV_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>在上述代码中：</p>
<ul>
<li><code>find_package(OpenCV REQUIRED)</code> 用于查找并配置 OpenCV 库。<code>REQUIRED</code> 表示如果找不到 OpenCV 库，将产生一个错误。</li>
<li><code>OpenCV_INCLUDE_DIRS</code> 包含了 OpenCV 库的头文件目录。</li>
<li><code>OpenCV_LIBRARIES</code> 包含了 OpenCV 库的链接库的名称。</li>
<li><code>add_executable</code> 添加了一个可执行文件，并使用 <code>target_include_directories</code> 将 OpenCV 库的头文件目录包含进来，使用 <code>target_link_libraries</code> 将 OpenCV 库链接到可执行文件中。</li>
</ul>
<p>确保 OpenCV 已经安装在你的系统中，或者你可以使用 CMake 的 <code>ExternalProject</code> 或其他方法在 CMake 中构建 OpenCV。</p>
<p>此外，<code>find_package</code> 还可以通过指定版本号和特定组件来细化查找过程。例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV <span class="number">4.5</span>.<span class="number">1</span> REQUIRED COMPONENTS core imgproc highgui)</span><br></pre></td></tr></table></figure>

<p>这将查找并配置 OpenCV 版本为 4.5.1，并确保包含了 core、imgproc 和 highgui 组件。</p>
<h2 id="cmake-find-package-配置gflags库"><a href="#cmake-find-package-配置gflags库" class="headerlink" title="cmake find_package 配置gflags库"></a>cmake find_package 配置gflags库</h2><p>当使用 CMake 的 <code>find_package</code> 配置 <code>gflags</code> 库时，你需要确保 <code>gflags</code> 库的 CMake 模块文件 <code>Findgflags.cmake</code> 被正确找到并使用。以下是一个简单的例子，演示如何在 CMake 中使用 <code>find_package</code> 配置 <code>gflags</code> 库：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 find_package 查找 gflags 库</span></span><br><span class="line"><span class="keyword">find_package</span>(gflags REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出找到的 gflags 库信息</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;gflags_INCLUDE_DIRS: $&#123;gflags_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;gflags_LIBRARIES: $&#123;gflags_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件，并链接 gflags 库</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE gflags)</span><br></pre></td></tr></table></figure>

<p>在上述代码中：</p>
<ul>
<li><code>find_package(gflags REQUIRED)</code> 用于查找并配置 <code>gflags</code> 库。<code>REQUIRED</code> 表示如果找不到 gflags 库，将产生一个错误。</li>
<li><code>gflags_INCLUDE_DIRS</code> 包含了 <code>gflags</code> 库的头文件目录。</li>
<li><code>gflags_LIBRARIES</code> 包含了 <code>gflags</code> 库的链接库的名称。</li>
<li><code>add_executable</code> 添加了一个可执行文件，并使用 <code>target_link_libraries</code> 将 <code>gflags</code> 库链接到可执行文件中。</li>
</ul>
<p>确保 <code>gflags</code> 库已经安装在系统中，或者你可以使用 <code>ExternalProject</code> 或其他方法在 CMake 中构建 <code>gflags</code>。</p>
<p>此外，如果你的项目中还用到其他外部库，可能需要在 <code>find_package</code> 后面添加其他库的查找，以确保这些库的依赖关系也得到正确配置。</p>
<p>最后，记得在 <code>CMakeLists.txt</code> 中引入 <code>main.cpp</code> 或其他源代码文件，以确保它们被编译到可执行文件中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/Trash/2024-05-22-C++_%E6%A0%87%E5%87%86%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/Trash/2024-05-22-C++_%E6%A0%87%E5%87%86%E5%BA%93/" class="post-title-link" itemprop="url">C++_标准库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>所有标准库类和函数都在std名称空间或其子名称空间中声明</li>
<li>C++标准库的核心是泛型容器和泛型算法。该库中的这个子集通常程序标准模板库(Standard Template Library, STL)，因为它最初基于第三方库“标准模板库”，该库大量使用了模板。</li>
</ul>
<h2 id="–-字符串-ok"><a href="#–-字符串-ok" class="headerlink" title="&lt;string&gt; – 字符串 [ok]"></a><code>&lt;string&gt;</code> – 字符串 [ok]</h2><ul>
<li>C++20包括了一个强大的类型安全的字符串格式化库，可以通过定义在<code>&lt;format&gt;</code>头文件中的<code>std::format()</code>进行访问</li>
</ul>
<h2 id="–-正则表达式-ok"><a href="#–-正则表达式-ok" class="headerlink" title="&lt;regex&gt; – 正则表达式[ok]"></a><code>&lt;regex&gt;</code> – 正则表达式[ok]</h2><h2 id="–-I-O流-ok"><a href="#–-I-O流-ok" class="headerlink" title="&lt;fstream&gt; – I&#x2F;O流[ok]"></a><code>&lt;fstream&gt;</code> – I&#x2F;O流[ok]</h2><ul>
<li>大多数的I&#x2F;O功能在如下几个头文件中定义：<ul>
<li><code>&lt;fstream&gt;</code></li>
<li><code>&lt;iomanip&gt;</code></li>
<li><code>&lt;ios&gt;</code></li>
<li><code>&lt;iosfwd&gt;</code></li>
<li><code>&lt;iostream&gt;</code></li>
<li><code>&lt;istream&gt;</code></li>
<li><code>&lt;ostream&gt;</code></li>
<li><code>&lt;sstream&gt;</code></li>
<li><code>&lt;streambuf&gt;</code></li>
<li><code>&lt;strstream&gt;</code></li>
</ul>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title="&lt;iomanip&gt;"></a><code>&lt;iomanip&gt;</code></h3><h4 id="resetiosflags"><a href="#resetiosflags" class="headerlink" title="resetiosflags()"></a><code>resetiosflags()</code></h4><ul>
<li>简述：清除指定的 ios_base 标志</li>
</ul>
<h4 id="setiosflags"><a href="#setiosflags" class="headerlink" title="setiosflags()"></a><code>setiosflags()</code></h4><ul>
<li>简述：设置指定的 ios_base 标志</li>
</ul>
<h4 id="setbase"><a href="#setbase" class="headerlink" title="setbase()"></a><code>setbase()</code></h4><ul>
<li>简述：更改用于整数 I&#x2F;O 的基数</li>
</ul>
<h4 id="setfill"><a href="#setfill" class="headerlink" title="setfill()"></a><code>setfill()</code></h4><ul>
<li>简述：更改填充字符</li>
</ul>
<h4 id="setprecision"><a href="#setprecision" class="headerlink" title="setprecision()"></a><code>setprecision()</code></h4><ul>
<li>简述：更改浮点精度</li>
</ul>
<h4 id="setw"><a href="#setw" class="headerlink" title="setw()"></a><code>setw()</code></h4><ul>
<li>简述：更改下个输入&#x2F;输出域的宽度</li>
</ul>
<h4 id="get-money"><a href="#get-money" class="headerlink" title="get_money()"></a><code>get_money()</code></h4><ul>
<li>简述：剖析货币值</li>
</ul>
<h4 id="put-money"><a href="#put-money" class="headerlink" title="put_money()"></a><code>put_money()</code></h4><ul>
<li>简述：格式化并输出货币值</li>
</ul>
<h4 id="get-time"><a href="#get-time" class="headerlink" title="get_time()"></a><code>get_time()</code></h4><ul>
<li>简述：剖析指定格式的日期&#x2F;时间值</li>
</ul>
<h4 id="put-time"><a href="#put-time" class="headerlink" title="put_time()"></a><code>put_time()</code></h4><ul>
<li>简述：按照指定格式格式化并输出日期&#x2F;时间值</li>
<li>声明：<code>template&lt;class CharT&gt; put_time(const std::tm* tmb, const CharT* fmt);</code></li>
<li>参数：<ul>
<li><code>tmb</code> – 指向从 std::localtime 或 std::gmtime 获得的日历时间结构体的指针</li>
<li><code>fmt</code> – 指向指定转换格式的空终止 CharT 串的指针，具体参考：<code>https://zh.cppreference.com/w/cpp/io/manip/put_time</code>（默认使用<code>%c %Z</code>）</li>
</ul>
</li>
</ul>
<h4 id="quoted"><a href="#quoted" class="headerlink" title="quoted()"></a><code>quoted()</code></h4><ul>
<li>简述：插入和读取带有内嵌空格的被引号括起来的字符串</li>
</ul>
<h2 id="–-智能指针-ok"><a href="#–-智能指针-ok" class="headerlink" title="&lt;memory&gt; – 智能指针[ok]"></a><code>&lt;memory&gt;</code> – 智能指针[ok]</h2><ul>
<li>编写健壮程序时，需要面对的一个问题就是要知道何时删除对象。</li>
<li>有几种可能发生的故障：<ul>
<li>根本没有删除对象（没有释放内存），这称为内存泄漏(memory leaks)。</li>
<li>一段代码删除了内存，而另一段代码仍然引用了这个内存，导致直线那个内存的指针不再可用或已重新分配作他用，这称为悬空指针(dangling pointer)</li>
<li>一段代码释放了内存，而另一端代码试图释放同一块内存，这称为双重释放(double deletion)</li>
</ul>
</li>
</ul>
<h2 id="–-异常-ok"><a href="#–-异常-ok" class="headerlink" title="&lt;exception&gt; – 异常[ok]"></a><code>&lt;exception&gt;</code> – 异常[ok]</h2><ul>
<li>大多数异常支持在下面几个头文件中定义：<ul>
<li><code>&lt;exception&gt;</code></li>
<li><code>&lt;stdexcept&gt;</code></li>
<li><code>&lt;system_error&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="–-数学工具"><a href="#–-数学工具" class="headerlink" title="&lt;cmath&gt; – 数学工具"></a><code>&lt;cmath&gt;</code> – 数学工具</h2><ul>
<li>数学工具类和函数</li>
</ul>
<h2 id="–-时间和日期工具-ok"><a href="#–-时间和日期工具-ok" class="headerlink" title="&lt;chrono&gt; – 时间和日期工具[ok]"></a><code>&lt;chrono&gt;</code> – 时间和日期工具[ok]</h2><ul>
<li>简述：在C++11的日期时间库中，共有3个概念，分别是持续时间（Duration）、时间点（timepoint）、时钟（clock）。</li>
</ul>
<h3 id="Clocks"><a href="#Clocks" class="headerlink" title="Clocks"></a>Clocks</h3><ul>
<li><p>定义中的时钟主要有3个，分别是:</p>
<ul>
<li>system_clock，顾名思义，就是系统时钟，他一般是unix时间，即从1970年1月1日到现在的间隔。如果系统时间发生调整，那么调用该方法获取的时间值也会跟着变化。</li>
<li>steady_clock，是单调时间，即每后一次调用都一定会比前一次调用的时间要晚，它并不反映真实的世界时间。在内部的实现中，有可能是系统开启以来的时间。通过该时钟很适合用来获取一段时间内的间隔，它不随系统时间改变而改变</li>
<li>high_resolution_clock，高精度时间，用来测量细微间隔的一段时间，它的内部实现中可能是system_clock或是steady_clock，也可能是其他独立的时间。</li>
</ul>
</li>
<li><p>一般来说，我们使用的都是system_clock</p>
</li>
<li><p>system_clock的主要方法有3个，分别是</p>
<ul>
<li>now，用来获取当前时间。</li>
<li>to_time_t，用来将系统时间转变为std::time_t类型。</li>
<li>from_time_t，用来将std::time_t类型转换为系统时间点</li>
</ul>
</li>
<li><p>使用system_clock获取当前系统时间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">auto</span> time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> tt = std::chrono::system_clock::<span class="built_in">to_time_t</span>(time);</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;tt), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计函数的执行耗时，这种情况更适合使用steady_clock。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">fibonacci</span><span class="params">(<span class="type">unsigned</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;f(42) = &quot;</span> &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">42</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">auto</span> end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        std::chrono::duration&lt;<span class="type">double</span>&gt; elapsed_seconds = end-start;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;elapsed time: &quot;</span> &lt;&lt; elapsed_seconds.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ```  </span><br><span class="line"></span><br><span class="line">### Duration</span><br><span class="line"></span><br><span class="line">+ 持续时间表示一个时间段，比如<span class="number">1</span>s、<span class="number">1</span>min、<span class="number">1</span>day等等，这些时间段是有单位的，因此持续时间也是一个模板变量，用来指定不同的单位</span><br><span class="line">+ 它的定义如下：</span><br><span class="line">  ```cpp</span><br><span class="line">    <span class="comment">// Rep表示单位的数量单位</span></span><br><span class="line">    <span class="comment">// Period表示单位</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Rep</span>,  <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;&gt; <span class="keyword">class</span> duration;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Period用来表示时间的单位，比如秒、天、小时等等，而Rep则表示容纳某个数量时间的单位。比较绕口，举个例子，比如说10天，那么Period是单位day，那么其数量是10，而10的类型可以是int型，也可以short型，Rep就用来表示这到底是什么类型存储这个量，如果类型过小，如果时间太长的话将会导致溢出。</p>
</li>
<li><p>再来看下Period的定义，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Num，表示分子</span></span><br><span class="line"><span class="comment">// Denom，表示分母</span></span><br><span class="line"><span class="keyword">template</span>&lt;std::<span class="type">intmax_t</span> Num, std::<span class="type">intmax_t</span> Denom = <span class="number">1</span>&gt; <span class="keyword">class</span> ratio;</span><br></pre></td></tr></table></figure></li>
<li><p>举个简单点的例子，Num为1，Denom也为1时，表示是1s，如果Num为1，Denom为1000，那么相当于是1&#x2F;1000s，也即毫秒。如果Num为60，Denom为1，那么表示 60 &#x2F; 1s，也即相当于1min。</p>
</li>
<li><p>下面是chrono头文件中的一些常见持续时间定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Type	Definition</span><br><span class="line">std::chrono::nanoseconds	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">64</span> bits*/, std::nano&gt;</span><br><span class="line">std::chrono::microseconds	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">55</span> bits*/, std::micro&gt;</span><br><span class="line">std::chrono::milliseconds	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">45</span> bits*/, std::milli&gt;</span><br><span class="line">std::chrono::seconds	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">35</span> bits*/&gt;</span><br><span class="line">std::chrono::minutes	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">29</span> bits*/, std::ratio&lt;<span class="number">60</span>&gt;&gt;</span><br><span class="line">std::chrono::hours	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">23</span> bits*/, std::ratio&lt;<span class="number">3600</span>&gt;&gt;</span><br><span class="line">std::chrono::<span class="built_in">days</span> (since C+<span class="number">+20</span>)	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">25</span> bits*/, std::ratio&lt;<span class="number">86400</span>&gt;&gt;</span><br><span class="line">std::chrono::<span class="built_in">weeks</span> (since C+<span class="number">+20</span>)	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">22</span> bits*/, std::ratio&lt;<span class="number">604800</span>&gt;&gt;</span><br><span class="line">std::chrono::<span class="built_in">months</span> (since C+<span class="number">+20</span>)	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">20</span> bits*/, std::ratio&lt;<span class="number">2629746</span>&gt;&gt;</span><br><span class="line">std::chrono::<span class="built_in">years</span> (since C+<span class="number">+20</span>)	duration&lt;/*<span class="type">signed</span> integer type of at least <span class="number">17</span> bits*/, std::ratio&lt;<span class="number">31556952</span>&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>针对Duraion来说，一般有两种操作，</p>
<ul>
<li>时间的增减。</li>
<li>不同持续时间单位之间的转换。</li>
</ul>
</li>
<li><p>Duration重载了+&#x2F;-运算符，可以直接进行+&#x2F;-操作，类型之间的转换可以使用duration_cast方法。</p>
</li>
<li><p>下面是一些使用实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ms.<span class="built_in">count</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> second = std::chrono::duration&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    <span class="keyword">auto</span> s = std::chrono::<span class="built_in">duration_cast</span>&lt;second&gt;(ms);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%llf\n&quot;</span>, s.<span class="built_in">count</span>());</span><br><span class="line"></span><br><span class="line">    std::<span class="function">chrono::seconds <span class="title">sec</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> du = sec + ms;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, du.<span class="built_in">count</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="TimePoint"><a href="#TimePoint" class="headerlink" title="TimePoint"></a>TimePoint</h3><ul>
<li><p>从时钟拿到的时间是时间点，它代表了时间段上的一个点，比如2019年10月21日10:20:10。</p>
</li>
<li><p>时间点的定义如下。</p>
<ul>
<li><code>template&lt;class Clock, class Duration = typename Clock::duration&gt; class time_point;</code></li>
</ul>
</li>
<li><p>通过time_point的模板参数，我们可以看到，一个是时钟，另外一个是持续时间，实际上timepoint就是一个时钟的基准时间加上一个时间段</p>
</li>
<li><p>对于时间点来说，下面这几个方法比较重要。</p>
<ul>
<li>time_since_epoch，获取以模板时钟的起始时间到现在的这个持续时间</li>
<li>time_point_cast，用来将时间点转换为基于同一个时钟，但不同类型持续时间的时间点。</li>
<li>时间点也重载了+&#x2F;-运算符，用来进行两个时间点之间的相加减</li>
</ul>
</li>
<li><p>下面是一些使用示例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::<span class="function">chrono::minutes <span class="title">m</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; then = now + m;</span><br><span class="line">    std::<span class="type">time_t</span> tt = std::chrono::system_clock::<span class="built_in">to_time_t</span>(then);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;timestamp is : &quot;</span> &lt;&lt; now.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;tt), <span class="string">&quot;%F %T&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降低时间精度，默认system_clock的duration精度是 1/10 micro sec</span></span><br><span class="line">    <span class="keyword">auto</span> then_min = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::minutes&gt;(then);</span><br><span class="line">    tt = std::chrono::system_clock::<span class="built_in">to_time_t</span>(then_min);</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;tt), <span class="string">&quot;%F %T&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="一些应用"><a href="#一些应用" class="headerlink" title="一些应用"></a>一些应用</h3><ul>
<li><p>获取时间戳。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::<span class="type">time_t</span> <span class="title">getTimeStamp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock,std::chrono::milliseconds&gt; tp = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::milliseconds&gt;(std::chrono::system_clock::<span class="built_in">now</span>());</span><br><span class="line">    <span class="keyword">auto</span> tmp=std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(tp.<span class="built_in">time_since_epoch</span>());</span><br><span class="line">    std::<span class="type">time_t</span> timestamp = tmp.<span class="built_in">count</span>();</span><br><span class="line">    <span class="comment">//std::time_t timestamp = std::chrono::system_clock::to_time_t(tp);</span></span><br><span class="line">    <span class="keyword">return</span> timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将时间戳转为日期。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tm* <span class="title">gettm</span><span class="params">(int64 timestamp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 milli = timestamp+ (int64)<span class="number">8</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>;<span class="comment">//此处转化为东八区北京时间，如果是其它时区需要按需求修改</span></span><br><span class="line">    <span class="keyword">auto</span> mTime = std::chrono::<span class="built_in">milliseconds</span>(milli);</span><br><span class="line">    <span class="keyword">auto</span> tp=std::chrono::<span class="built_in">time_point</span>&lt;std::chrono::system_clock,std::chrono::milliseconds&gt;(mTime);</span><br><span class="line">    <span class="keyword">auto</span> tt = std::chrono::system_clock::<span class="built_in">to_time_t</span>(tp);</span><br><span class="line">    std::tm* now = std::<span class="built_in">gmtime</span>(&amp;tt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%4d年%02d月%02d日 %02d:%02d:%02d\n&quot;</span>,now-&gt;tm_year<span class="number">+1900</span>,now-&gt;tm_mon<span class="number">+1</span>,now-&gt;tm_mday,now-&gt;tm_hour,now-&gt;tm_min,now-&gt;tm_sec);</span><br><span class="line">   <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在上面的程序中，时间精度只到秒，这是time_t结构的限制，如果希望获取到ms精度，那么直接使用timestamp % 1000的方式就行。</p>
</li>
</ul>
<h2 id="–-随机数-ok"><a href="#–-随机数-ok" class="headerlink" title="&lt;random&gt; – 随机数[ok]"></a><code>&lt;random&gt;</code> – 随机数[ok]</h2><ul>
<li>随机数库，带有随机数引擎，随机数引擎适配器以及随机数分布。</li>
<li>通过这些组件可以生成更适合特定问题的随机数，例如正态分布，负指数分布等</li>
</ul>
<h2 id="–-初始化列表"><a href="#–-初始化列表" class="headerlink" title="&lt;initializer_list&gt; – 初始化列表"></a><code>&lt;initializer_list&gt;</code> – 初始化列表</h2><ul>
<li>它们便于编写参数数目可变的函数</li>
</ul>
<h2 id="–-pair"><a href="#–-pair" class="headerlink" title="&lt;utility&gt; – pair"></a><code>&lt;utility&gt;</code> – pair</h2><ul>
<li>它定义了pair类模板，用于存储两种不同类型的元素。这称为存储异构元素</li>
<li>pair允许在一个对象中保存类型毫不相关的元素</li>
</ul>
<h2 id="–-tuple"><a href="#–-tuple" class="headerlink" title="&lt;tuple&gt; – tuple"></a><code>&lt;tuple&gt;</code> – tuple</h2><ul>
<li>它定义的tuple是pair的一种泛化，它是固定大小的序列，元组的元素可以是异构的，tuple实例化的元素数目和类型在编译器是固定不变的。</li>
</ul>
<h2 id="词汇类型-vocabulary-type"><a href="#词汇类型-vocabulary-type" class="headerlink" title="词汇类型(vocabulary type)"></a>词汇类型(vocabulary type)</h2><ul>
<li><p><code>&lt;optional&gt;</code></p>
<ul>
<li>要么存储指定类型的值，要么什么都不存储</li>
</ul>
</li>
<li><p><code>&lt;variant&gt;</code></p>
<ul>
<li>可存储单个值（属于一组给定类型中的一种类型）</li>
</ul>
</li>
<li><p><code>&lt;any&gt;</code></p>
<ul>
<li>可包含单个值，值可以是任何类型</li>
</ul>
</li>
</ul>
<h2 id="–-函数对象"><a href="#–-函数对象" class="headerlink" title="&lt;functional&gt; – 函数对象"></a><code>&lt;functional&gt;</code> – 函数对象</h2><ul>
<li><p>在<code>&lt;functional&gt;</code>中定义的<code>std::function</code>函数模板是一个多态函数包装器，可以用来创建指向任何可调用对象的类型，例如函数，函数对象或者lambda表达式</p>
</li>
<li><p><code>std::function</code>的示例可以用作函数指针，也可以用作函数实现回调的参数，可以存储，赋值，移动，也可以执行</p>
</li>
<li><p>函数模板的模板参数看起来和大多数模板参数有些不同，语法如下：</p>
<ul>
<li><code>std::function&lt;R(ArgTypes...)&gt;</code></li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li><code>R</code> : 是函数的返回类型</li>
<li><code>ArgTypes</code> : 是函数参数类型的逗号分隔列表</li>
</ul>
</li>
<li><p>实现函数调用运算符的类称为函数对象(function object)</p>
</li>
<li><p>函数对象可用作某些标准库算法的谓词</p>
</li>
</ul>
<h2 id="–-文件系统"><a href="#–-文件系统" class="headerlink" title="&lt;filesystem&gt; – 文件系统"></a><code>&lt;filesystem&gt;</code> – 文件系统</h2><h2 id="–-多线程-ok"><a href="#–-多线程-ok" class="headerlink" title="&lt;thread&gt;  – 多线程[ok]"></a><code>&lt;thread&gt;</code>  – 多线程[ok]</h2><h2 id="–-类型萃取"><a href="#–-类型萃取" class="headerlink" title="&lt;type_traits&gt; – 类型萃取"></a><code>&lt;type_traits&gt;</code> – 类型萃取</h2><h2 id="–-标准整数类型"><a href="#–-标准整数类型" class="headerlink" title="&lt;cstdint&gt; – 标准整数类型"></a><code>&lt;cstdint&gt;</code> – 标准整数类型</h2><ul>
<li>它定义了大量标准整数类型，例如int8_t 和 int64_t 等，还包含了多个宏（指定这些类型的最小值和最大值）</li>
</ul>
<h2 id="–-相关实现信息-ok"><a href="#–-相关实现信息-ok" class="headerlink" title="&lt;version&gt; – 相关实现信息[ok]"></a><code>&lt;version&gt;</code> – 相关实现信息[ok]</h2><ul>
<li>它可用于查询正在使用的C++标准库的相关实现信息<ul>
<li>版本号</li>
<li>发布日期</li>
<li>版权声明</li>
</ul>
</li>
</ul>
<h2 id="–-源位置"><a href="#–-源位置" class="headerlink" title="&lt;source_location&gt; – 源位置"></a><code>&lt;source_location&gt;</code> – 源位置</h2><ul>
<li>C++20添加了<code>std::source_location</code>类，用来查询有关源代码的信息，例如文件名，函数名，行号和列号，并可用于替换旧的C风格宏<code>__FILE__</code>和<code>__LINE__</code></li>
</ul>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="ok"><a href="#ok" class="headerlink" title="&lt;vector&gt;[ok]"></a><code>&lt;vector&gt;</code>[ok]</h3><h3 id="-1"><a href="#-1" class="headerlink" title="&lt;list&gt;"></a><code>&lt;list&gt;</code></h3><h3 id="-2"><a href="#-2" class="headerlink" title="&lt;forward_list&gt;"></a><code>&lt;forward_list&gt;</code></h3><h3 id="-3"><a href="#-3" class="headerlink" title="&lt;deque&gt;"></a><code>&lt;deque&gt;</code></h3><h3 id="-4"><a href="#-4" class="headerlink" title="&lt;array&gt;"></a><code>&lt;array&gt;</code></h3><h3 id="-5"><a href="#-5" class="headerlink" title="&lt;span&gt;"></a><code>&lt;span&gt;</code></h3><h3 id="-6"><a href="#-6" class="headerlink" title="&lt;queue&gt;"></a><code>&lt;queue&gt;</code></h3><h3 id="-7"><a href="#-7" class="headerlink" title="&lt;stack&gt;"></a><code>&lt;stack&gt;</code></h3><h3 id="-8"><a href="#-8" class="headerlink" title="&lt;set&gt;"></a><code>&lt;set&gt;</code></h3><h3 id="-9"><a href="#-9" class="headerlink" title="&lt;map&gt;"></a><code>&lt;map&gt;</code></h3><h2 id="–-算法-ok"><a href="#–-算法-ok" class="headerlink" title="&lt;alogrithm&gt; – 算法[ok]"></a><code>&lt;alogrithm&gt;</code> – 算法[ok]</h2><h2 id="–-范围库"><a href="#–-范围库" class="headerlink" title="&lt;ranges&gt; – 范围库"></a><code>&lt;ranges&gt;</code> – 范围库</h2><ul>
<li>C++20引入了范围库，这使得处理元素序列变得更加简单和优雅</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/24/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/26/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
