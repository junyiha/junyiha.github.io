<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/18/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/18/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Makefile_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Makefile_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">Makefile_基础语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 Makefile 中，有一些内置的变量可以用于表示常见的目录路径。以下是一些常用的 Makefile 内置变量相关的目录：</p>
<ol>
<li><strong><code>$(CURDIR)</code></strong>: 当前工作目录的绝对路径。</li>
<li><strong><code>$(SRCDIR)</code></strong>: 源代码目录的路径。</li>
<li><strong><code>$(INCDIR)</code></strong>: 头文件目录的路径。</li>
<li><strong><code>$(BINDIR)</code></strong>: 可执行文件目录的路径。</li>
<li><strong><code>$(LIBDIR)</code></strong>: 库文件目录的路径。</li>
</ol>
<p>这些内置变量可以用于指定源代码、头文件、可执行文件和库文件的目录路径。你可以根据需要在 Makefile 中使用这些变量，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前工作目录</span></span><br><span class="line">CURRENT_DIR := <span class="variable">$(CURDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 源代码目录</span></span><br><span class="line">SRC_DIR := <span class="variable">$(CURRENT_DIR)</span>/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line">INC_DIR := <span class="variable">$(CURRENT_DIR)</span>/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行文件目录</span></span><br><span class="line">BIN_DIR := <span class="variable">$(CURRENT_DIR)</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 库文件目录</span></span><br><span class="line">LIB_DIR := <span class="variable">$(CURRENT_DIR)</span>/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译选项</span></span><br><span class="line">CXXFLAGS := -std=c++11 -Wall -I<span class="variable">$(INC_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件和可执行文件名</span></span><br><span class="line">TARGET := <span class="variable">$(BIN_DIR)</span>/myapp</span><br><span class="line">OBJS := <span class="variable">$(SRC_DIR)</span>/main.o <span class="variable">$(SRC_DIR)</span>/foo.o <span class="variable">$(SRC_DIR)</span>/bar.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译每个源文件</span></span><br><span class="line"><span class="variable">$(SRC_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.cpp</span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了 <code>$(CURDIR)</code> 变量获取当前工作目录的路径，并根据它构建了其他目录的路径。然后，我们使用这些路径变量来设置源代码、头文件、可执行文件和库文件的路径。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>编写 Makefile 是一种常用的方式来管理和构建 C++ 项目。下面是一个简单的示例 Makefile，展示了如何编写一个基本的 C++ 项目的 Makefile。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译器设置</span></span><br><span class="line">CXX = g++</span><br><span class="line">CXXFLAGS = -std=c++11 -Wall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件和可执行文件名</span></span><br><span class="line">TARGET = myapp</span><br><span class="line">OBJS = main.o foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译每个源文件</span></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了以下内容：</p>
<ul>
<li><code>CXX</code> 和 <code>CXXFLAGS</code> 变量用于设置编译器和编译选项。</li>
<li><code>TARGET</code> 变量用于指定最终生成的可执行文件名。</li>
<li><code>OBJS</code> 变量用于指定目标文件（即编译后的中间文件）。</li>
<li><code>all</code> 是默认目标，用于构建整个项目。它依赖于 <code>$(TARGET)</code>。</li>
<li><code>$(TARGET)</code> 目标用于生成最终的可执行文件。它依赖于 <code>$(OBJS)</code>。</li>
<li><code>%.o</code> 是一个模式规则，用于编译每个源文件。它依赖于对应的 <code>.cpp</code> 文件，并使用 <code>$&lt;</code> 和 <code>$@</code> 分别表示依赖和目标文件。</li>
<li><code>clean</code> 目标用于清理生成的目标文件和可执行文件。</li>
</ul>
<p>你可以根据实际项目的需要进行修改和扩展。例如，你可以添加更多的源文件、头文件目录、链接库等。</p>
<p>要使用上述 Makefile，只需在项目根目录下创建一个名为 <code>Makefile</code>（注意大小写），并将上述内容粘贴到文件中。然后，在项目根目录下执行 <code>make</code> 命令即可构建项目。执行 <code>make clean</code> 可以清理生成的文件。</p>
<p>请注意，Makefile 的编写可能会因具体的项目需求和构建环境而有所差异。上述示例仅为一个简单的起点，你可以根据自己的需要进行进一步的定制和优化。同时，还可以考虑使用更高级的构建工具和自动化构建系统（如 CMake、Autotools 等）来管理更复杂的项目。</p>
<h2 id="书写规则："><a href="#书写规则：" class="headerlink" title="书写规则："></a>书写规则：</h2><ul>
<li>依赖关系：生成目标的方法</li>
</ul>
<h2 id="规则语法："><a href="#规则语法：" class="headerlink" title="规则语法："></a>规则语法：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">targets:prerequisites</span><br><span class="line">    command</span><br><span class="line">targets：文件名，以空格分开，可以使用通配符</span><br><span class="line">command：命令行，如果不与prerequisites在一行，必须在下一行以Tab键开头，如果在一行，用分号做分割</span><br><span class="line">prerequisites：目标所依赖的文件</span><br><span class="line">反斜杠（\）：换行符</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li><code>make -C dir</code>, <code>--directory=dir</code> : Change to directory <code>dir</code> before reading the makefiles or doing anything else.</li>
</ul>
<h2 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h2><ul>
<li><p>变量在声明时，需要给予初值，而在使用时，需要给变量名前加上$符号，并且用小括号括起来</p>
</li>
<li><p>makefile中变量分为环境变量，内置变量和自动变量</p>
</li>
<li><p><strong>环境变量</strong></p>
<ul>
<li><code>DESKTOP_SESSION</code> : ubuntu</li>
<li><code>XDG_SESSION_TYPE</code>: x11</li>
<li><code>XAUTHORITY</code>      : &#x2F;run&#x2F;user&#x2F;1000&#x2F;gdm&#x2F;Xauthority</li>
<li><code>_</code>               : &#x2F;usr&#x2F;bin&#x2F;make</li>
</ul>
</li>
<li><p><strong>自动变量</strong></p>
<ul>
<li><code>$@</code> : 表示规则的目标文件名</li>
<li><code>$&lt;</code> : 规则的第一个依赖文件名。如果是一个目标文件使用隐含规则来重建，则代表由隐含规则加入的第一个依赖文件</li>
<li><code>$^</code> : 规则的所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有库成员(.0文件)名。一个文件可重复的出现在目标的依赖中，变量<code>$^</code>只记录它的一次引用情况。就是说变量<code>$^</code>会去掉重复的依赖文件。</li>
<li><code>$+</code> : 类似于<code>$^</code>，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合</li>
</ul>
</li>
<li><p><strong>内置变量</strong></p>
<ul>
<li><code>$(CURDIR)</code> : 显示当前路径</li>
<li><code>$(SHELL)</code>  : &#x2F;bin&#x2F;sh</li>
<li><code>$(CC)</code>     : cc , C语言编译器的名称</li>
<li><code>$(CPP)</code>    : $(CC) -E ， C语言预处理器的名称</li>
<li><code>$(CXX)</code>    : g++ , C++语言的编译器的名称</li>
<li><code>$(RM)</code>     : rm -f , 删除文件程序的名称</li>
<li><code>$(CFLAGS)</code> : C语言编译器的编译选项，无默认值</li>
<li><code>$(CXXFLAGS)</code>: C++语言编译器的编译选项，无默认值</li>
</ul>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p><code>?=</code></p>
<ul>
<li>条件变量分配运算符，它仅在尚未定义的变量时具有效果</li>
</ul>
</li>
<li><p><code>+=</code></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">variable = main.o merge.o</span><br><span class="line">variable += delete.o</span><br><span class="line"># ALL:$(variable)</span><br><span class="line">all:</span><br><span class="line">	@echo $&#123;variable&#125; </span><br><span class="line"># 输出: main.o merge.o delete.o</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p><code>$(abspath names...)</code> : 获取文件的绝对地址 </p>
</li>
<li><p><code>ifeq (condition1, condition2) ... endif</code>   </p>
<ul>
<li>如果<code>condition1</code> 等于 <code>conditon2</code> , 则执行下面的操作，否则不执行</li>
</ul>
</li>
<li><p><code>$&#123;addprefix &quot;前缀&quot;, filenames...&#125;</code>  </p>
<ul>
<li>为文件加前缀<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">variable = main.o merge.o</span><br><span class="line">variable += delete.o</span><br><span class="line">var = $&#123;addprefix -x/, $&#123;variable&#125;&#125;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	@echo $&#123;var&#125; </span><br><span class="line"><span class="comment"># 输出: -x/main.o -x/merge.o -x/delete.o</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>$&#123;wildcard /home/user/workspace/shell/*.sh&#125;</code>  </p>
<ul>
<li>获取指定路径下的指定文件<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var = $&#123;wildcard ./*.txt&#125;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	@echo $&#123;var&#125; </span><br><span class="line"><span class="comment"># 输出: ./foo.txt ./bar.txt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>$&#123;patsubst pattern, replacement, text&#125;</code> </p>
<ul>
<li>根据相应规则替换文件名<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var = $&#123;wildcard ./*.txt&#125;</span><br><span class="line">pat = $&#123;patsubst %.txt, %.md, $&#123;var&#125;&#125;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	@echo $&#123;var&#125; </span><br><span class="line">	@echo $&#123;pat&#125;</span><br><span class="line"><span class="comment"># 输出: ./foo.txt ./bar.txt   \  ./foo.md ./bar.md</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="Makefile中获取当前执行的Makefile所在路径"><a href="#Makefile中获取当前执行的Makefile所在路径" class="headerlink" title="Makefile中获取当前执行的Makefile所在路径"></a>Makefile中获取当前执行的Makefile所在路径</h3><ul>
<li><p>Linux下我们可以用pwd命令来获取当前所执行命令的目录，在Makefile中对应可用<code>PWD := $(shell pwd)</code>来获取。</p>
</li>
<li><p>但是如果子Makefile 文件是从别处执行的(通过<code>make -f .../Makefile</code> 执行)，那么<code>$(shell pwd)</code>得到的目录即为执行<code>make -f</code>命令的当前目录</p>
</li>
<li><p>在这种情况下</p>
<ul>
<li>根据gnu make定义，<code>gnu make</code> 会自动将所有读取的<code>makefile</code>路径都会加入到<code>MAKEFILE_LIST</code>变量中，而且是按照读取的先后顺序添加</li>
<li>所以可以通过<code>$(abspath $(lastword $(MAKEFILE_LIST)))</code>返回当前正在被执行的<code>Makefile</code>的绝对路径,然后通过<code>patsubst</code>去掉文件名得到绝对目录</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">makefile_path:=<span class="variable">$(<span class="built_in">abspath</span> $(<span class="built_in">lastword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span>)</span><br><span class="line">cur_makefile_path:=<span class="variable">$(<span class="built_in">patsubst</span> %/makefile, %/, $&#123;<span class="built_in">shell</span> ls <span class="variable">$(makefile_path)</span>&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	@echo $&#123;makefile_path&#125;</span><br><span class="line">	@echo $&#123;cur_makefile_path&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Nginx/" class="post-title-link" itemprop="url">Nginx</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>nginx 相关理论知识</li>
</ul>
<h2 id="nginx-是什么"><a href="#nginx-是什么" class="headerlink" title="nginx 是什么"></a>nginx 是什么</h2><p>Nginx（发音为”engine-x”）是一个开源的高性能的Web服务器和反向代理服务器。它最初由伊戈尔·赛索耶夫（Igor Sysoev）创建，并于2004年首次发布。Nginx专注于高并发性能、低资源消耗和稳定性，使其成为许多互联网公司和网站的首选Web服务器。</p>
<p>主要特点包括：</p>
<ol>
<li><p><strong>高性能：</strong> Nginx被设计为能够处理大量并发连接而不陷入性能问题。它采用事件驱动、非阻塞的架构，能够高效地处理数千个同时连接。</p>
</li>
<li><p><strong>低资源消耗：</strong> 相比一些传统的Web服务器，Nginx使用较少的内存和CPU资源，这使其在资源有限的环境中表现出色。</p>
</li>
<li><p><strong>反向代理：</strong> Nginx可以作为反向代理服务器，将请求从客户端传递到后端服务器，然后将响应返回给客户端。这使得它在负载均衡和提高应用程序性能方面非常有用。</p>
</li>
<li><p><strong>静态文件服务：</strong> Nginx优化了对静态文件的服务，能够快速地提供图片、CSS、JavaScript等静态文件，减轻了动态内容生成的压力。</p>
</li>
<li><p><strong>模块化设计：</strong> Nginx的模块化结构使得用户可以方便地扩展其功能，添加新的特性和功能。</p>
</li>
</ol>
<p>由于其性能和灵活性，Nginx常被用于搭建高流量的网站和应用，同时也广泛用于反向代理、负载均衡、缓存等场景。</p>
<h2 id="nginx-详解"><a href="#nginx-详解" class="headerlink" title="nginx 详解"></a>nginx 详解</h2><p>Nginx（发音为“engine-x”）是一个高性能的开源Web服务器软件，也可以用作反向代理服务器、负载均衡器和HTTP缓存等。在进行Nginx配置时，主要是编辑Nginx的配置文件，通常是<code>nginx.conf</code>，以及可能的其他配置文件，如虚拟主机配置文件等。以下是一个简要的Nginx配置详解：</p>
<ol>
<li><p><strong>基本语法和结构</strong>：<br>Nginx的配置文件使用简单的语法，主要由指令和块构成，块内可以包含多个指令。配置文件通常分为全局配置、http块和server块等。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"></span><br><span class="line"><span class="comment"># http块</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># http全局配置</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># server块</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># server配置</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>监听端口和虚拟主机</strong>：<br>使用<code>server</code>块可以配置虚拟主机，允许在同一台服务器上通过不同的域名或IP地址提供不同的网站。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 配置处理请求的规则</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反向代理和负载均衡</strong>：<br>Nginx经常被用作反向代理服务器，将客户端请求代理到后端服务器，并可以进行负载均衡以提高性能和可靠性。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> myapp.com;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_servers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> backend_servers &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态文件服务</strong>：<br>Nginx可以高效地提供静态文件，从而减轻后端服务器的负担。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> static.example.com;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /path/to/static/files;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SSL&#x2F;TLS加密</strong>：<br>配置Nginx支持安全的SSL&#x2F;TLS连接，用于加密数据传输。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> secure.example.com;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">ssl_certificate</span> /path/to/cert.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/cert.key;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># SSL配置</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重定向和URL重写</strong>：<br>Nginx可以执行URL的重定向和重写，以实现网站访问路径的优化和规范化。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> old-example.com;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^</span> https://new-example.com<span class="variable">$request_uri</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上只是Nginx配置的一些常见方面，实际上Nginx提供了丰富的配置选项，可以根据具体需求进行更复杂的配置。在编写Nginx配置文件时，建议参考官方文档以及其他可靠的资源，以确保正确配置并确保服务器的安全和性能。</p>
<h2 id="nginx-配置代理转发-示例"><a href="#nginx-配置代理转发-示例" class="headerlink" title="nginx 配置代理转发 示例"></a>nginx 配置代理转发 示例</h2><p>以下是一个基本的Nginx配置示例，用于将客户端请求代理转发到后端服务器。在这个示例中，Nginx将监听80端口，将客户端请求代理到名为<code>backend_server</code>的后端服务器。请根据您的实际情况进行适当的修改。</p>
<ol>
<li><p><strong>安装和启动Nginx</strong>：<br>在安装和启动Nginx之前，请确保您已经正确安装了Nginx，并且配置文件位于<code>/etc/nginx/nginx.conf</code>。以下是示例配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置代理转发</strong>：<br>在配置文件夹中创建一个新的文件，例如<code>/etc/nginx/conf.d/proxy.conf</code>，并添加以下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_server;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，将<code>your_domain.com</code>替换为您的域名，<code>backend_server</code>替换为实际的后端服务器地址（可以是IP地址或域名）。</p>
</li>
<li><p><strong>重新加载Nginx配置</strong>：<br>在进行任何配置更改后，都需要重新加载Nginx配置，以便使更改生效。使用以下命令重新加载Nginx配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nginx -t   <span class="comment"># 检查配置是否正确</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl reload nginx</span><br></pre></td></tr></table></figure>

<p>如果没有错误，Nginx将重新加载配置。</p>
</li>
</ol>
<p>这样，当客户端发送请求到您的域名（例如<code>http://your_domain.com</code>），Nginx将会代理转发请求到指定的后端服务器。在实际应用中，您可能还需要配置SSL&#x2F;TLS以实现安全的HTTPS连接，以及其他一些高级配置，取决于您的需求。</p>
<h2 id="nginx-模块化编程"><a href="#nginx-模块化编程" class="headerlink" title="nginx 模块化编程"></a>nginx 模块化编程</h2><p>Nginx支持模块化编程，允许您根据需求添加自定义功能和扩展。Nginx模块可以分为核心模块和第三方模块。核心模块是Nginx自带的，而第三方模块则是由社区或个人开发的。</p>
<p>下面是一个简要的Nginx模块化编程概述：</p>
<ol>
<li><p><strong>核心模块</strong>：<br>Nginx的核心模块包括各种基本功能，如HTTP、事件处理、文件I&#x2F;O等。核心模块在编译Nginx时包含在内，无需额外安装。例如：</p>
<ul>
<li><code>ngx_http_core_module</code>：处理HTTP请求、URI解析和请求分发。</li>
<li><code>ngx_http_proxy_module</code>：实现反向代理功能。</li>
<li><code>ngx_event_core_module</code>：管理事件循环和异步I&#x2F;O。</li>
<li><code>ngx_http_ssl_module</code>：提供SSL&#x2F;TLS支持等。</li>
</ul>
</li>
<li><p><strong>第三方模块</strong>：<br>第三方模块是由Nginx社区或个人开发的扩展，可以添加额外的功能和定制化选项。您可以选择性地将第三方模块添加到Nginx中。以下是一些常见的第三方模块示例：</p>
<ul>
<li><code>ngx_http_geoip_module</code>：使用GeoIP数据库进行地理位置识别。</li>
<li><code>ngx_http_lua_module</code>：在Nginx配置中嵌入Lua脚本。</li>
<li><code>ngx_http_gzip_static_module</code>：提供静态Gzip压缩功能。</li>
<li><code>ngx_http_upstream_module</code>：扩展负载均衡选项等。</li>
</ul>
</li>
<li><p><strong>编写自定义模块</strong>：<br>如果您需要添加特定的自定义功能，您可以编写自己的Nginx模块。编写Nginx模块需要对C语言编程有一定的了解。基本的步骤包括：</p>
<ul>
<li>编写模块代码：创建一个C文件，并实现模块的处理逻辑，例如请求处理、配置解析等。</li>
<li>修改配置：在Nginx配置文件中添加模块相关的配置指令。</li>
<li>编译安装：将模块源代码编译到Nginx中。</li>
</ul>
<p>请注意，编写自定义模块可能需要深入理解Nginx的内部机制和事件处理流程。在编写模块之前，建议您详细阅读Nginx的模块开发文档和示例。</p>
</li>
</ol>
<p>总之，Nginx的模块化架构使其非常灵活，可以根据需求轻松添加或定制功能。无论是使用核心模块还是第三方模块，都能够扩展Nginx的功能以满足不同的需求。</p>
<h2 id="linux下nginx配置-详解"><a href="#linux下nginx配置-详解" class="headerlink" title="linux下nginx配置 详解"></a>linux下nginx配置 详解</h2><p>在Linux系统下，Nginx的配置文件通常是<code>nginx.conf</code>。下面是一个简单的Nginx配置文件的详解：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局块</span></span><br><span class="line"><span class="attribute">user</span> nginx;         <span class="comment"># Nginx worker进程运行的用户</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">4</span>;  <span class="comment"># 启动的worker进程数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># error_log定义错误日志的路径</span></span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log <span class="literal">warn</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># events块定义Nginx的事件模型</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;  <span class="comment"># 每个worker进程允许的最大连接数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># http块是配置HTTP服务器的主要部分</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># server块定义具体的虚拟主机</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;  <span class="comment"># 监听的端口</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">server_name</span> example.com;  <span class="comment"># 域名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># location块定义不同URL的行为</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /path/to/your/files;  <span class="comment"># 根目录</span></span><br><span class="line">            <span class="attribute">index</span> index.html;          <span class="comment"># 默认首页</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># location块可以有多个，用于处理不同的URL</span></span><br><span class="line">        <span class="section">location</span> /api &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend-server;  <span class="comment"># 反向代理到后端服务器</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 静态文件缓存</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~* \.(jpg|jpeg|png|gif|ico|css|js)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">1y</span>;</span><br><span class="line">            <span class="attribute">add_header</span> Cache-Control <span class="string">&quot;public, max-age=31536000&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 错误页面配置</span></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">        <span class="section">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">            internal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># SSL配置</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">ssl_certificate</span> /path/to/your/ssl_certificate.crt;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /path/to/your/ssl_certificate.key;</span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span> <span class="string">&#x27;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&#x27;</span>;</span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述配置文件简单地说明了Nginx的一些基本配置，包括全局配置、事件模型、HTTP服务器、虚拟主机、URL处理、反向代理、静态文件缓存、错误页面和SSL配置等。你可以根据自己的需要进行调整和扩展。</p>
<p>请注意，实际配置可能会根据具体的使用场景和需求有所不同。详细的配置可以查阅<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/">Nginx官方文档</a>。</p>
<h2 id="linux-web服务器-nginx反向代理是什么"><a href="#linux-web服务器-nginx反向代理是什么" class="headerlink" title="linux web服务器 nginx反向代理是什么"></a>linux web服务器 nginx反向代理是什么</h2><p>Nginx的反向代理是一种服务器架构，其中Nginx服务器接收客户端的请求，并将这些请求转发给后端的一组服务器。反向代理隐藏了真实的服务器，使得客户端无法直接访问到后端服务器，而是通过反向代理服务器进行中转。</p>
<p>具体来说，Nginx反向代理的工作流程如下：</p>
<ol>
<li><p><strong>客户端发送请求：</strong> 客户端发送HTTP请求到Nginx服务器。</p>
</li>
<li><p><strong>Nginx接收请求：</strong> Nginx服务器接收到客户端的请求。</p>
</li>
<li><p><strong>反向代理处理：</strong> 根据配置，Nginx决定将请求转发给后端的哪个服务器。这个后端服务器可以是一个应用服务器、负载均衡器，或者其他类型的服务器。</p>
</li>
<li><p><strong>向后端服务器发送请求：</strong> Nginx将接收到的请求转发给后端服务器。</p>
</li>
<li><p><strong>后端服务器处理请求：</strong> 后端服务器处理请求，并生成响应。</p>
</li>
<li><p><strong>响应返回给客户端：</strong> 后端服务器将生成的响应返回给Nginx。</p>
</li>
<li><p><strong>Nginx返回响应给客户端：</strong> Nginx将接收到的响应返回给客户端，客户端认为是直接从Nginx获取的响应。</p>
</li>
</ol>
<p>反向代理的优点包括：</p>
<ul>
<li><p><strong>负载均衡：</strong> 可以实现负载均衡，将请求分发到多个后端服务器，防止单一服务器负载过大。</p>
</li>
<li><p><strong>隐藏后端服务器：</strong> 客户端无法直接访问到后端服务器，增加了安全性。</p>
</li>
<li><p><strong>缓存和压缩：</strong> Nginx可以对后端服务器的响应进行缓存和压缩，提高性能。</p>
</li>
<li><p><strong>SSL终结：</strong> 可以在Nginx上进行SSL终结，解密加密的流量，减轻后端服务器的负担。</p>
</li>
</ul>
<p>反向代理是一种常见的服务器架构，特别适用于需要提高可用性、安全性和性能的场景。</p>
<h2 id="常见的服务器架构有哪些？"><a href="#常见的服务器架构有哪些？" class="headerlink" title="常见的服务器架构有哪些？"></a>常见的服务器架构有哪些？</h2><p>有许多常见的服务器架构，每种都有其适用的场景和优势。以下是一些常见的服务器架构类型：</p>
<ol>
<li><p><strong>单层架构（Single-Tier Architecture）：</strong></p>
<ul>
<li>单层架构是最简单的架构形式，将应用程序、数据库和用户界面等功能集成在一个单一的层中。</li>
<li>适用于小型应用和测试环境，但在大型和复杂应用中使用较少。</li>
</ul>
</li>
<li><p><strong>两层架构（Two-Tier Architecture）：</strong></p>
<ul>
<li>由客户端层和服务器层组成，客户端负责用户界面，而服务器负责处理业务逻辑和数据存储。</li>
<li>常见于传统的客户端-服务器应用，例如数据库应用。</li>
</ul>
</li>
<li><p><strong>三层架构（Three-Tier Architecture）：</strong></p>
<ul>
<li>包括客户端层、应用服务器层和数据库服务器层。</li>
<li>分离业务逻辑、数据处理和用户界面，提高灵活性和可维护性。</li>
</ul>
</li>
<li><p><strong>微服务架构（Microservices Architecture）：</strong></p>
<ul>
<li>将应用程序拆分成小型、独立的服务，每个服务专注于特定的业务功能。</li>
<li>提供弹性、可伸缩性和独立部署的优势，适用于大型、复杂的分布式系统。</li>
</ul>
</li>
<li><p><strong>服务导向架构（Service-Oriented Architecture, SOA）：</strong></p>
<ul>
<li>将应用程序拆分为可重用的服务，这些服务通过网络进行通信。</li>
<li>促进了松耦合和模块化，使得系统更易于维护和扩展。</li>
</ul>
</li>
<li><p><strong>反向代理架构（Reverse Proxy Architecture）：</strong></p>
<ul>
<li>使用反向代理服务器作为前端，将请求转发给后端服务器，隐藏真实的服务器。</li>
<li>常用于负载均衡、安全性增强和性能优化。</li>
</ul>
</li>
<li><p><strong>无服务器架构（Serverless Architecture）：</strong></p>
<ul>
<li>应用程序的开发和运行无需关心底层的服务器和基础设施。</li>
<li>利用云服务提供商的无服务器计算服务，按需执行代码。</li>
</ul>
</li>
</ol>
<p>这些架构类型根据应用程序的规模、需求和特点选择，每种架构都有其优势和劣势。在实际应用中，也可以采用混合架构，结合不同的组件和服务来满足特定的需求。</p>
<h2 id="在linux下使用nginx构建反响代理架构服务器"><a href="#在linux下使用nginx构建反响代理架构服务器" class="headerlink" title="在linux下使用nginx构建反响代理架构服务器"></a>在linux下使用nginx构建反响代理架构服务器</h2><p>在Linux下使用Nginx构建反向代理架构的服务器是相对简单的。以下是基本步骤：</p>
<h3 id="步骤一：安装Nginx"><a href="#步骤一：安装Nginx" class="headerlink" title="步骤一：安装Nginx"></a>步骤一：安装Nginx</h3><p>确保你的Linux系统中已经安装了Nginx。使用包管理工具，如<code>apt</code>、<code>yum</code>或<code>dnf</code>，执行以下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于基于Debian的系统（例如Ubuntu）</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于基于Red Hat的系统（例如CentOS）</span></span><br><span class="line"><span class="built_in">sudo</span> yum install epel-release</span><br><span class="line"><span class="built_in">sudo</span> yum install nginx</span><br></pre></td></tr></table></figure>

<h3 id="步骤二：编辑Nginx配置文件"><a href="#步骤二：编辑Nginx配置文件" class="headerlink" title="步骤二：编辑Nginx配置文件"></a>步骤二：编辑Nginx配置文件</h3><p>Nginx的主配置文件通常位于 <code>/etc/nginx/nginx.conf</code> 或 <code>/etc/nginx/conf.d/default.conf</code>。你可以使用文本编辑器（如<code>nano</code>或<code>vim</code>）编辑该文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure>

<p>在配置文件中，你需要配置反向代理的相关设置。以下是一个简单的例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;  <span class="comment"># 替换成你的域名或服务器IP</span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_server;  <span class="comment"># 替换成你的后端服务器地址</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保替换 <code>your_domain.com</code> 为你的域名或服务器IP，并将 <code>http://backend_server</code> 替换为你的后端服务器地址。</p>
<h3 id="步骤三：重启Nginx"><a href="#步骤三：重启Nginx" class="headerlink" title="步骤三：重启Nginx"></a>步骤三：重启Nginx</h3><p>完成配置后，保存并退出编辑器。然后，重新启动Nginx以使配置生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart nginx</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>你可能需要调整防火墙规则，确保Nginx监听的端口是开放的。</li>
<li>确保后端服务器上的应用程序正常运行，并且Nginx能够访问它。</li>
</ul>
<p>这只是一个简单的反向代理配置示例。实际应用中，你可能还需要考虑负载均衡、SSL&#x2F;TLS设置、缓存等其他配置，具体根据你的需求进行调整。请查阅<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/">Nginx官方文档</a>以获取更多详细信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-ModBus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-ModBus/" class="post-title-link" itemprop="url">ModBus</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ModBus 相关理论知识</li>
</ul>
<h2 id="Contexts-上下文-资源句柄"><a href="#Contexts-上下文-资源句柄" class="headerlink" title="Contexts 上下文 资源句柄"></a>Contexts 上下文 资源句柄</h2><ul>
<li>使用 modbus_new_rtu 申请，返回一个 modbus_t ，它包含所有必要的数据</li>
</ul>
<h2 id="modbus-协议-详解"><a href="#modbus-协议-详解" class="headerlink" title="modbus 协议 详解"></a>modbus 协议 详解</h2><p>Modbus（Modular Communications System）是一种通信协议，用于在不同设备之间进行数据通信和控制。它通常用于工业自动化领域，用于连接和控制各种设备，如传感器、执行器、PLC（可编程逻辑控制器）等。Modbus协议的详解包括以下几个方面：</p>
<ol>
<li><p><strong>协议类型</strong>：</p>
<ul>
<li>Modbus RTU：基于串行通信，以二进制格式传输数据。</li>
<li>Modbus ASCII：也是基于串行通信，但以ASCII字符形式传输数据。</li>
<li>Modbus TCP：基于TCP&#x2F;IP网络通信，用于以太网连接。</li>
</ul>
</li>
<li><p><strong>通信方式</strong>：</p>
<ul>
<li>Modbus是主从（Master-Slave）协议，其中有一个主设备（主站）可以向多个从设备（从站）发送请求，并接收它们的响应。</li>
<li>主站发出请求，从站回应请求，并提供所需的数据。</li>
</ul>
</li>
<li><p><strong>数据格式</strong>：</p>
<ul>
<li>Modbus通信包括读（读取从站的数据）和写（向从站写入数据）操作。</li>
<li>请求和响应消息通常包括功能码、数据字段、CRC校验等部分。</li>
</ul>
</li>
<li><p><strong>寄存器</strong>：</p>
<ul>
<li>Modbus协议使用寄存器来表示数据，寄存器可以是输入寄存器、保持寄存器、输入状态、线圈状态等不同类型。</li>
<li>输入寄存器通常用于表示只读数据，如传感器读数。</li>
<li>保持寄存器通常用于表示读写数据，如控制器的设置参数。</li>
</ul>
</li>
<li><p><strong>功能码</strong>：</p>
<ul>
<li>功能码用于指定要执行的操作，如读取输入寄存器、写入保持寄存器等。</li>
<li>常见的功能码包括读操作（功能码 3 和功能码 4）和写操作（功能码 6 和功能码 16）。</li>
</ul>
</li>
<li><p><strong>异常处理</strong>：</p>
<ul>
<li>Modbus协议包括异常码，用于指示错误情况，如无效功能码、寄存器不可用等。</li>
<li>异常响应通常包含一个特殊的异常功能码，以及一个描述异常的代码。</li>
</ul>
</li>
<li><p><strong>通信速率</strong>：</p>
<ul>
<li>Modbus RTU和Modbus ASCII的通信速率通常在9600、19200、38400等不同速率之间选择。</li>
<li>Modbus TCP通常使用以太网连接，通信速率由以太网规范确定。</li>
</ul>
</li>
<li><p><strong>安全性</strong>：</p>
<ul>
<li>Modbus协议在设计上没有内置安全性，因此在需要安全通信的环境中，通常需要使用其他协议或方法来加强安全性。</li>
</ul>
</li>
</ol>
<p>总的来说，Modbus协议是一种用于在工业自动化环境中进行设备间通信和控制的标准化协议。它有多种变体和实现，可以根据不同的通信需求和硬件来选择合适的协议类型。 Modbus协议的详细规范可以在Modbus.org等资源中找到。如果需要使用Modbus协议，通常需要查看相关设备的文档以了解如何配置和使用它。</p>
<h2 id="CRC-详解"><a href="#CRC-详解" class="headerlink" title="CRC 详解"></a>CRC 详解</h2><p>CRC (Cyclic Redundancy Check) 是一种错误检测码，用于验证数据的完整性。它是一种快速且广泛应用的校验算法，常用于通信协议、存储设备、网络传输等领域。</p>
<p>CRC 的基本原理是通过对数据进行多项式计算来生成校验值，这个校验值称为 CRC 值。发送方在传输数据前，会计算数据的 CRC 值，并将该值附加到数据后面一并传输。接收方在接收到数据后，也会计算接收到的数据的 CRC 值，并与接收到的 CRC 值进行比较。如果两个 CRC 值匹配，表示数据没有出现错误；如果 CRC 值不匹配，表示数据可能在传输过程中发生了错误或被篡改。</p>
<p>CRC 的特点包括：</p>
<ol>
<li><p>快速：CRC 是一种非常快速的校验算法，适用于实时数据传输和处理。</p>
</li>
<li><p>简单：CRC 的实现相对简单，通常用位操作来处理数据和多项式计算。</p>
</li>
<li><p>检测能力：CRC 能够检测不少常见的错误，但并不是绝对可靠，无法检测所有错误。</p>
</li>
<li><p>冗余：CRC 增加了一定的冗余数据，用于检测错误。</p>
</li>
</ol>
<p>在使用 CRC 时，需要事先定义一个生成多项式。不同的 CRC 标准使用不同的多项式，常见的标准有 CRC-16、CRC-32 等。选择合适的 CRC 标准取决于具体应用的要求。</p>
<p>总体而言，CRC 是一种简单、高效且广泛应用的错误检测码。它在数据传输和存储中起着重要的作用，帮助保障数据的完整性和可靠性。</p>
<h2 id="linux-libmodbus-库-详解"><a href="#linux-libmodbus-库-详解" class="headerlink" title="linux libmodbus 库 详解"></a>linux libmodbus 库 详解</h2><p><code>libmodbus</code> 是一个用于通信协议 Modbus 的开源C库，用于实现 Modbus 协议的通信。Modbus 是一种通信协议，用于连接工业自动化设备，使它们能够在不同设备之间进行数据传输。以下是关于 <code>libmodbus</code> 库的详细信息：</p>
<p><strong>安装 libmodbus 库</strong>：</p>
<p>你可以使用你的 Linux 发行版的包管理器来安装 <code>libmodbus</code> 库。例如，如果你使用的是 Ubuntu，可以使用以下命令安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libmodbus-dev</span><br></pre></td></tr></table></figure>

<p><strong>使用 libmodbus 库</strong>：</p>
<p>以下是一些关于 <code>libmodbus</code> 库的基本使用方法和功能：</p>
<ol>
<li><p><strong>创建 modbus 上下文</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">modbus_t</span>* ctx = modbus_new_rtu(<span class="string">&quot;/dev/ttyUSB0&quot;</span>, <span class="number">9600</span>, <span class="string">&#x27;N&#x27;</span>, <span class="number">8</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个用于串口通信的 Modbus 上下文。</p>
</li>
<li><p><strong>连接到 Modbus 设备</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (modbus_connect(ctx) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Connection failed&quot;</span>);</span><br><span class="line">    modbus_free(ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>modbus_connect</code> 函数连接到 Modbus 设备。</p>
</li>
<li><p><strong>读取和写入 Modbus 寄存器</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> data[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> num = modbus_read_registers(ctx, <span class="number">0</span>, <span class="number">5</span>, data);</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> value = <span class="number">1234</span>;</span><br><span class="line">modbus_write_register(ctx, <span class="number">10</span>, value);</span><br></pre></td></tr></table></figure>

<p>使用 <code>modbus_read_registers</code> 函数读取寄存器数据，使用 <code>modbus_write_register</code> 函数写入寄存器数据。</p>
</li>
<li><p><strong>关闭连接并释放资源</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modbus_close(ctx);</span><br><span class="line">modbus_free(ctx);</span><br></pre></td></tr></table></figure>

<p>在完成通信后，使用 <code>modbus_close</code> 函数关闭连接，并使用 <code>modbus_free</code> 函数释放资源。</p>
</li>
<li><p><strong>其他功能</strong>：</p>
<p><code>libmodbus</code> 还提供了其他一些功能，如 Modbus TCP&#x2F;IP 支持、异常处理、不同寄存器类型的读写等。</p>
</li>
</ol>
<p><code>libmodbus</code> 库使得在 Linux 下实现 Modbus 协议通信变得更加容易。你可以查阅官方文档或在线教程，深入了解 <code>libmodbus</code> 库的更多功能和用法。在编程中，你可以根据需要使用合适的函数来实现 Modbus 通信，并根据通信需求进行相应的设置和处理。</p>
<h2 id="linux-libmodbus-库-使用-详解-示例"><a href="#linux-libmodbus-库-使用-详解-示例" class="headerlink" title="linux libmodbus 库 使用 详解 示例"></a>linux libmodbus 库 使用 详解 示例</h2><p>下面是一个使用 <code>libmodbus</code> 库进行 Modbus 通信的简单示例。在这个示例中，我们将使用 Modbus RTU 通信协议通过串口与 Modbus 设备通信，并读取一些寄存器的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;modbus.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">modbus_t</span> *ctx;</span><br><span class="line">    <span class="type">uint16_t</span> data[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Modbus 上下文，串口路径为 &quot;/dev/ttyUSB0&quot;，波特率为 9600</span></span><br><span class="line">    ctx = modbus_new_rtu(<span class="string">&quot;/dev/ttyUSB0&quot;</span>, <span class="number">9600</span>, <span class="string">&#x27;N&#x27;</span>, <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to create Modbus context\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到 Modbus 设备</span></span><br><span class="line">    <span class="keyword">if</span> (modbus_connect(ctx) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Connection failed: %s\n&quot;</span>, modbus_strerror(errno));</span><br><span class="line">        modbus_free(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取寄存器数据，起始地址为 0，读取 5 个寄存器</span></span><br><span class="line">    <span class="type">int</span> num = modbus_read_registers(ctx, <span class="number">0</span>, <span class="number">5</span>, data);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Read error: %s\n&quot;</span>, modbus_strerror(errno));</span><br><span class="line">        modbus_close(ctx);</span><br><span class="line">        modbus_free(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印读取的寄存器值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Register %d: %d\n&quot;</span>, i, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接并释放资源</span></span><br><span class="line">    modbus_close(ctx);</span><br><span class="line">    modbus_free(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了一个 Modbus 上下文 <code>ctx</code>，然后使用 <code>modbus_connect</code> 函数连接到 Modbus 设备。接着，使用 <code>modbus_read_registers</code> 函数读取起始地址为 0 的连续 5 个寄存器的值。最后，我们打印出读取的寄存器值，并在完成通信后关闭连接和释放资源。</p>
<p>请注意，此示例是一个基本的用法演示。在实际应用中，你可能需要根据 Modbus 设备的配置和通信需求进行适当的设置和处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-OpenGL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-OpenGL/" class="post-title-link" itemprop="url">OpenGL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>OpenGL和图形应用程序开发相关基础知识笔记</li>
</ul>
<h2 id="GLFW-是什么"><a href="#GLFW-是什么" class="headerlink" title="GLFW 是什么"></a>GLFW 是什么</h2><p>GLFW (Graphics Library Framework) 是一个用于创建图形用户界面(GUI)和窗口管理的开源库。它提供了一个跨平台的、简单易用的接口，用于创建窗口、处理输入、处理OpenGL上下文和渲染等功能。</p>
<p>主要特性包括：</p>
<ol>
<li><p>创建窗口：GLFW 允许开发人员创建窗口和上下文，用于图形渲染。</p>
</li>
<li><p>处理输入：它提供了对键盘、鼠标和其他输入设备的处理，以便开发人员可以轻松地获取用户的输入。</p>
</li>
<li><p>多窗口和多监视器支持：GLFW 支持在多个窗口和多个监视器上创建和管理图形界面。</p>
</li>
<li><p>时间处理：GLFW 提供了一种机制来处理时间，比如定时器和时间间隔。</p>
</li>
<li><p>OpenGL 上下文管理：它可以与OpenGL图形库很好地集成，为OpenGL提供一个合适的渲染上下文。</p>
</li>
<li><p>跨平台：GLFW 被设计为跨平台的库，可以在多个操作系统上运行，包括Windows、macOS、Linux和其他一些系统。</p>
</li>
</ol>
<p>GLFW 是游戏开发、图形应用程序和其他需要图形界面的项目中常用的工具之一，它简化了窗口和输入处理的复杂性，让开发人员能够更专注于图形渲染和应用逻辑的实现。</p>
<hr>
<h2 id="OpenGL-详解"><a href="#OpenGL-详解" class="headerlink" title="OpenGL 详解"></a>OpenGL 详解</h2><p>OpenGL (Open Graphics Library) 是一种用于渲染2D和3D图形的跨平台图形库。它提供了一组用于绘制图形的函数，可以让开发人员利用计算机的GPU来生成高性能的图形效果。OpenGL 最初由SGI (Silicon Graphics, Inc.) 开发，并于1992年首次发布。如今，OpenGL 已成为图形编程中广泛使用的标准，并得到了许多硬件厂商和开发者的支持。</p>
<p>以下是一些关键的概念和特性，帮助你更详细地了解 OpenGL：</p>
<ol>
<li><p>三维图形：OpenGL 是一种专门用于渲染三维图形的图形库。它支持在三维空间中创建和渲染复杂的图形场景。</p>
</li>
<li><p>着色器：OpenGL 使用着色器来控制图形的绘制过程。着色器是运行在GPU上的小程序，包括顶点着色器(Vertex Shader)和片段着色器(Fragment Shader)。顶点着色器负责处理顶点的变换和光照计算，而片段着色器则负责计算像素的颜色。</p>
</li>
<li><p>缓冲区对象：OpenGL 使用缓冲区对象来管理图形数据。这些数据可以包括顶点坐标、颜色、法向量和纹理坐标等。缓冲区对象将数据存储在GPU的显存中，以便更快地访问。</p>
</li>
<li><p>纹理映射：OpenGL 支持纹理映射，可以将图片或图案映射到三维对象的表面，以增加细节和逼真感。</p>
</li>
<li><p>坐标系：OpenGL 使用右手坐标系来表示三维空间。X轴指向右边，Y轴指向上方，Z轴指向屏幕内部。</p>
</li>
<li><p>状态机：OpenGL 是一个基于状态机的图形库，意味着绘制图形之前需要设置一些状态，比如颜色、深度测试、剔除等。然后，OpenGL 根据当前状态来绘制图形。</p>
</li>
<li><p>执行管线：OpenGL 执行图形渲染的过程被称为图形管线。它包括几个阶段，比如顶点处理、几何处理、光栅化和片段处理等。</p>
</li>
<li><p>扩展和版本：OpenGL 是一个不断发展的图形库，每个版本都会引入新的特性和扩展。开发者可以根据需要选择合适的OpenGL版本。</p>
</li>
</ol>
<p>虽然OpenGL在图形编程中非常强大且广泛应用，但在一些情况下，也可以考虑使用更高级的图形库或API，比如Vulkan或DirectX，以获得更多的控制权和更高的性能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-PlatformIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-PlatformIO/" class="post-title-link" itemprop="url">PlatformIO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>嵌入式开发板编程IDE笔记</li>
<li>官方文档<ul>
<li><a target="_blank" rel="noopener" href="https://docs.platformio.org/en/latest/integration/ide/vscode.html#quick-start">https://docs.platformio.org/en/latest/integration/ide/vscode.html#quick-start</a></li>
</ul>
</li>
</ul>
<h2 id="platformIO-详解"><a href="#platformIO-详解" class="headerlink" title="platformIO 详解"></a>platformIO 详解</h2><p>PlatformIO 是一个开源的跨平台的物联网（IoT）开发生态系统，它用于嵌入式系统和嵌入式应用程序的开发。PlatformIO 提供了一个强大的集成开发环境（IDE），支持多种硬件平台，包括Arduino、ESP8266、ESP32、Raspberry Pi等，以及多种开发框架，如Arduino、Mbed、FreeRTOS等。以下是 PlatformIO 的主要特点和功能的详细解释：</p>
<ol>
<li><p><strong>多平台支持</strong>：PlatformIO 可以在不同的操作系统上运行，包括 Windows、macOS 和 Linux，因此可以轻松迁移到不同的开发环境。</p>
</li>
<li><p><strong>多硬件平台支持</strong>：PlatformIO 支持多种硬件平台，使开发人员能够在不同的嵌入式设备上进行开发，而无需为每个平台使用不同的开发工具。</p>
</li>
<li><p><strong>多框架支持</strong>：PlatformIO 支持多种开发框架和库，包括 Arduino、Mbed、ESP-IDF、STM32Cube等，使开发人员能够选择适合其项目的最佳框架。</p>
</li>
<li><p>**集成开发环境 (IDE)**：PlatformIO 提供了一个集成开发环境，使开发人员能够方便地编写、构建、上传和调试嵌入式应用程序。PlatformIO 支持 Visual Studio Code（VSCode）等流行的文本编辑器和IDE。</p>
</li>
<li><p><strong>自动依赖管理</strong>：PlatformIO 自动处理项目依赖关系，包括库、框架和工具链，以确保项目能够顺利构建和运行。</p>
</li>
<li><p><strong>自动固件升级</strong>：PlatformIO 具有内置的固件升级工具，使嵌入式设备的固件更新变得更加容易。</p>
</li>
<li><p><strong>强大的命令行工具</strong>：PlatformIO 还提供了命令行工具，使开发人员能够自动化和自定义开发流程，以满足其特定需求。</p>
</li>
<li><p><strong>丰富的插件生态系统</strong>：PlatformIO 的插件系统使开发人员能够扩展其功能，添加新硬件平台、框架、工具等。</p>
</li>
<li><p><strong>跨平台固件开发</strong>：PlatformIO 使开发人员能够开发跨不同平台的嵌入式固件，从单片机到嵌入式Linux系统。</p>
</li>
</ol>
<p>总的来说，PlatformIO 是一个强大且灵活的工具，适用于嵌入式系统开发人员，它简化了开发流程，提供了一体化的开发环境，支持多种硬件平台和开发框架，以及自动化依赖管理，从而大大提高了嵌入式开发的效率。如果您是嵌入式开发人员或对嵌入式系统感兴趣，PlatformIO 是一个值得考虑的工具。</p>
<h2 id="platformIO-VSCode插件-使用-详解"><a href="#platformIO-VSCode插件-使用-详解" class="headerlink" title="platformIO VSCode插件 使用 详解"></a>platformIO VSCode插件 使用 详解</h2><p>PlatformIO 在 Visual Studio Code（VSCode）中提供了一个功能强大的插件，使嵌入式系统开发变得更加便捷。以下是详细的 PlatformIO VSCode 插件的使用说明：</p>
<p><strong>1. 安装 PlatformIO 插件：</strong></p>
<ul>
<li>打开 Visual Studio Code (VSCode)。</li>
<li>在左侧的 Extensions (扩展) 面板中，搜索 “PlatformIO IDE” 并安装该插件。</li>
</ul>
<p><strong>2. 创建或打开 PlatformIO 项目：</strong></p>
<ul>
<li>如果您已有一个 PlatformIO 项目，可以直接在 VSCode 中打开它，或者您可以使用 <code>File</code> -&gt; <code>New Project</code> 创建一个新项目。</li>
</ul>
<p><strong>3. 配置项目：</strong></p>
<ul>
<li>在项目文件夹中，打开 <code>platformio.ini</code> 文件。这个文件用于配置项目的硬件平台、框架、依赖库等。</li>
<li>在 <code>platformio.ini</code> 文件中，您可以指定目标硬件板（<code>[env]</code> 部分）、选择框架、添加依赖库等。</li>
</ul>
<p><strong>4. 编写代码：</strong></p>
<ul>
<li>在 VSCode 中创建或打开源代码文件（通常是 <code>.cpp</code> 或 <code>.ino</code> 文件），然后开始编写嵌入式代码。</li>
</ul>
<p><strong>5. 构建项目：</strong></p>
<ul>
<li>使用 PlatformIO 插件，您可以构建项目。在 VSCode 中，点击底部工具栏的构建按钮（绿色的勾号），或者使用快捷键（通常是 Ctrl + Alt + B）来构建项目。</li>
</ul>
<p><strong>6. 上传固件：</strong></p>
<ul>
<li>构建成功后，您可以将固件上传到目标硬件板。在 VSCode 中，点击底部工具栏的上传按钮（右边的右箭头），或使用快捷键（通常是 Ctrl + Alt + U）来上传固件。</li>
</ul>
<p><strong>7. 调试项目（可选）：</strong></p>
<ul>
<li>如果您需要调试嵌入式应用程序，PlatformIO 插件支持硬件调试器。您可以配置调试器，设置断点，以及使用 VSCode 的调试功能进行嵌入式代码的调试。</li>
</ul>
<p><strong>8. 库管理：</strong></p>
<ul>
<li>PlatformIO 插件支持库管理。您可以搜索、安装、升级和删除依赖库，以简化项目的依赖管理。这可以在 VSCode 中的 PlatformIO Sidebar（侧边栏）中完成。</li>
</ul>
<p><strong>9. 终端和监控：</strong></p>
<ul>
<li>PlatformIO 插件集成了终端和监控功能。您可以在 VSCode 中的 PlatformIO Sidebar 中打开终端，以运行特定的命令。监控功能可用于查看串口输出。</li>
</ul>
<p><strong>10. 插件设置：</strong></p>
<ul>
<li>您可以通过点击 VSCode 左下角的齿轮图标（设置按钮）来访问 PlatformIO 插件的设置。这里您可以进行各种自定义设置，包括构建选项、上传速度、调试器配置等。</li>
</ul>
<p>PlatformIO 插件在 VSCode 中提供了一个完整的嵌入式开发环境，支持多种硬件平台和开发框架。通过 VSCode 的集成性和 PlatformIO 的功能，您可以在一个集成的环境中完成项目配置、编码、构建、上传和调试，提高了嵌入式开发的效率。如果您是嵌入式开发人员或对嵌入式系统感兴趣，PlatformIO 插件是一个强大的工具，使您能够更轻松地进行开发和调试。</p>
<h2 id="platformio-ini文件-常见的配置参数"><a href="#platformio-ini文件-常见的配置参数" class="headerlink" title="platformio.ini文件 常见的配置参数"></a>platformio.ini文件 常见的配置参数</h2><p><code>platformio.ini</code> 文件是PlatformIO项目的配置文件，用于指定项目的构建、上传、目标设备以及其他参数。以下是一些常见的<code>platformio.ini</code>配置参数：</p>
<ol>
<li><strong>平台和框架选择</strong>:<ul>
<li><code>platform</code>：指定目标平台，如Arduino、Espressif、Raspberry Pi等。</li>
<li><code>framework</code>：指定项目使用的框架，如Arduino、Mbed、ESP-IDF等。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">platform</span> = espressif8266</span><br><span class="line"><span class="attr">framework</span> = ardui<span class="literal">no</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>目标环境配置</strong>:<ul>
<li><code>board</code>：选择目标开发板型号。</li>
<li><code>board_build.mcu</code>：指定目标微控制器型号。</li>
<li><code>board_build.f_cpu</code>：指定目标CPU的时钟频率。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">board</span> = nodemcu</span><br><span class="line"><span class="attr">board_build.mcu</span> = esp8266</span><br><span class="line"><span class="attr">board_build.f_cpu</span> = <span class="number">80000000</span>L</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>串口配置</strong>:<ul>
<li><code>upload_port</code>：指定上传固件时的串口端口。</li>
<li><code>monitor_port</code>：指定监控串口端口。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">upload_port</span> = COM3</span><br><span class="line"><span class="attr">monitor_port</span> = COM3</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>编译参数</strong>:<ul>
<li><code>build_flags</code>：添加编译选项，如宏定义、编译标志等。</li>
<li><code>extra_scripts</code>：引用自定义脚本以进行更高级的构建操作。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">build_flags</span> = -D DEBUG_MODE</span><br><span class="line"><span class="attr">extra_scripts</span> = custom_script.py</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>库依赖</strong>:<ul>
<li><code>lib_deps</code>：指定项目所需的库依赖。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">lib_deps</span> =</span><br><span class="line">    Wire</span><br><span class="line">    Adafruit Unified Sensor</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>上传和调试工具配置</strong>:<ul>
<li><code>upload_protocol</code>：指定上传协议，如<code>stlink</code>、<code>espota</code>、<code>avr109</code>等。</li>
<li><code>debug_tool</code>：指定调试工具，如<code>stlink</code>, <code>esp-prog</code>, <code>jlink</code>等。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">upload_protocol</span> = espota</span><br><span class="line"><span class="attr">debug_tool</span> = esp-prog</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>上传速度和端口配置</strong>:<ul>
<li><code>upload_speed</code>：指定上传速度，如<code>115200</code>。</li>
<li><code>monitor_speed</code>：指定监控串口的波特率。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">upload_speed</span> = <span class="number">921600</span></span><br><span class="line"><span class="attr">monitor_speed</span> = <span class="number">115200</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li><strong>其他项目设置</strong>:<ul>
<li><code>platform_packages</code>：指定特定平台的软件包。</li>
<li><code>extra_configs</code>：引用其他配置文件。</li>
</ul>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[env:my_target]</span></span><br><span class="line"><span class="attr">platform_packages</span> = framework-arduinoespressif8266</span><br><span class="line"><span class="attr">extra_configs</span> = additional_config.ini</span><br></pre></td></tr></table></figure>

<p>这些是一些常见的<code>platformio.ini</code>配置参数，您可以根据您的项目需求进行自定义。<code>platformio.ini</code>文件使您能够轻松配置PlatformIO项目的各个方面，以适应特定的硬件和软件需求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-PostgreSQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-PostgreSQL/" class="post-title-link" itemprop="url">PostgreSQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>PostgreSQL数据库</li>
</ul>
<h2 id="postgreSQL-数据库是什么"><a href="#postgreSQL-数据库是什么" class="headerlink" title="postgreSQL 数据库是什么"></a>postgreSQL 数据库是什么</h2><p>PostgreSQL是一个免费的开源关系型数据库管理系统（RDBMS），它采用了PostgreSQL许可证，允许用户免费使用、修改和分发它。PostgreSQL经常被简称为”Postgres”。它具有强大的功能和可扩展性，被广泛用于开发各种类型的应用程序。</p>
<p>一些 PostgreSQL 的关键特性包括：</p>
<ol>
<li><p><strong>关系型数据库管理系统（RDBMS）</strong>：PostgreSQL是一种基于关系模型的数据库系统，允许用户以表格的形式存储和管理数据。</p>
</li>
<li><p><strong>免费且开源</strong>：PostgreSQL是免费的，用户可以自由使用、修改和分发它。</p>
</li>
<li><p><strong>支持多种数据类型</strong>：除了常见的数据类型如整数、字符和日期等，PostgreSQL还支持JSON、数组、几何数据类型等多种复杂数据类型。</p>
</li>
<li><p><strong>支持SQL语言</strong>：它支持标准的结构化查询语言（SQL），允许用户进行数据查询、操作和管理。</p>
</li>
<li><p><strong>扩展性</strong>：PostgreSQL具有良好的扩展性，支持插件和扩展模块，允许用户添加额外的功能和特性。</p>
</li>
<li><p><strong>事务支持</strong>：它支持ACID（原子性、一致性、隔离性和持久性）属性，确保数据操作的完整性和一致性。</p>
</li>
<li><p><strong>触发器和存储过程</strong>：PostgreSQL支持触发器和存储过程，使得用户能够在特定事件发生时自动执行操作。</p>
</li>
<li><p><strong>复制和高可用性</strong>：提供复制功能，可以创建备份以及实现高可用性和故障容错。</p>
</li>
</ol>
<p>PostgreSQL是一个功能强大、稳定可靠且高度可定制的数据库管理系统，被广泛应用于各种类型的应用程序，从个人项目到大型企业级应用都可以使用它来存储和管理数据。</p>
<h2 id="PostgreSQL-详解"><a href="#PostgreSQL-详解" class="headerlink" title="PostgreSQL 详解"></a>PostgreSQL 详解</h2><p>PostgreSQL是一个功能强大的开源关系型数据库管理系统（RDBMS），具有许多特性和优势，适用于各种规模和类型的应用。以下是对PostgreSQL的一些详细解释：</p>
<h3 id="特性和功能："><a href="#特性和功能：" class="headerlink" title="特性和功能："></a>特性和功能：</h3><ol>
<li><p><strong>数据类型支持</strong>：除了标准的数据类型（整数、字符、日期等），PostgreSQL支持复杂数据类型如数组、JSON、几何数据等。</p>
</li>
<li><p><strong>多种编程语言扩展</strong>：允许使用多种编程语言编写存储过程、函数和触发器，如PL&#x2F;pgSQL、PL&#x2F;Python、PL&#x2F;Perl、PL&#x2F;Java等。</p>
</li>
<li><p><strong>ACID兼容</strong>：支持事务的ACID属性（原子性、一致性、隔离性、持久性），确保数据的完整性和一致性。</p>
</li>
<li><p><strong>扩展性</strong>：具有良好的扩展性，支持插件和扩展模块，可添加额外功能以满足特定需求。</p>
</li>
<li><p><strong>复杂查询优化</strong>：支持复杂的查询语句和联合查询，提供了强大的优化功能以提高查询性能。</p>
</li>
<li><p><strong>完整性约束</strong>：支持各种完整性约束，如主键约束、外键约束、唯一约束等，确保数据的完整性。</p>
</li>
<li><p><strong>触发器和存储过程</strong>：允许开发者定义触发器和存储过程，以实现在特定事件发生时自动执行的操作。</p>
</li>
<li><p><strong>并发控制</strong>：提供有效的并发控制机制，支持多个用户同时对数据库进行访问和操作。</p>
</li>
<li><p><strong>复制和高可用性</strong>：支持数据复制功能，可创建备份以及实现高可用性和故障容错。</p>
</li>
<li><p><strong>安全性</strong>：提供多种安全功能，包括访问控制、SSL支持、数据加密等，保护数据库免受未经授权的访问和攻击。</p>
</li>
</ol>
<h3 id="应用领域："><a href="#应用领域：" class="headerlink" title="应用领域："></a>应用领域：</h3><ol>
<li><p><strong>Web应用程序</strong>：用于存储和管理Web应用程序的数据，如电子商务平台、社交媒体网站等。</p>
</li>
<li><p><strong>企业级应用</strong>：被广泛用于企业级应用，用于数据分析、报告生成、客户关系管理等。</p>
</li>
<li><p><strong>地理信息系统（GIS）</strong>：由于其对地理空间数据的支持，常用于开发GIS应用。</p>
</li>
<li><p><strong>科学研究</strong>：用于处理大量数据和进行复杂查询，满足科学研究领域的需求。</p>
</li>
<li><p><strong>物联网（IoT）</strong>：适用于存储和管理大量物联网设备生成的数据。</p>
</li>
</ol>
<h3 id="社区和生态系统："><a href="#社区和生态系统：" class="headerlink" title="社区和生态系统："></a>社区和生态系统：</h3><ol>
<li><p><strong>活跃的社区支持</strong>：拥有一个活跃的开发社区，提供广泛的文档、教程和支持。</p>
</li>
<li><p><strong>丰富的第三方工具和扩展</strong>：有许多第三方工具和扩展可用于简化开发、监控和管理PostgreSQL数据库。</p>
</li>
</ol>
<p>总的来说，PostgreSQL是一个功能强大、稳定可靠且高度可定制的数据库管理系统，它的特性和灵活性使其成为许多应用程序开发者和企业的首选数据库之一。</p>
<h2 id="PostgreSQL-可以用哪些编程语言开发"><a href="#PostgreSQL-可以用哪些编程语言开发" class="headerlink" title="PostgreSQL 可以用哪些编程语言开发"></a>PostgreSQL 可以用哪些编程语言开发</h2><p>PostgreSQL本身是用C语言开发的，但它提供了许多支持扩展的方式，允许使用多种编程语言来开发扩展功能。这些扩展可以作为存储过程、函数、触发器等与数据库交互的组件，其中一些常用的开发语言包括：</p>
<ol>
<li><p><strong>PL&#x2F;pgSQL</strong>：这是PostgreSQL的内置过程式语言，类似于Oracle的PL&#x2F;SQL。它与SQL语句紧密集成，允许开发者编写存储过程和触发器等。</p>
</li>
<li><p><strong>PL&#x2F;Python</strong>：允许使用Python语言编写存储过程、函数和触发器。它使得开发者可以利用Python的强大功能来扩展数据库功能。</p>
</li>
<li><p><strong>PL&#x2F;Perl</strong>：允许使用Perl语言编写存储过程、函数和触发器。对于熟悉Perl的开发者来说，这是一个很好的选择。</p>
</li>
<li><p><strong>PL&#x2F;Java</strong>：允许使用Java语言编写存储过程、函数和触发器。这个扩展允许开发者利用Java的强大功能来扩展数据库。</p>
</li>
<li><p><strong>PL&#x2F;SQL</strong>：通过第三方扩展，允许在PostgreSQL中使用Oracle的PL&#x2F;SQL语言，从而方便那些熟悉Oracle数据库的开发者。</p>
</li>
<li><p><strong>其他语言扩展</strong>：除了上述常用的语言外，PostgreSQL还支持其他一些语言的扩展，如PL&#x2F;R（R语言）、PL&#x2F;V8（JavaScript）等。这些扩展使得开发者可以根据自己的需求选择适合的编程语言来开发数据库功能。</p>
</li>
</ol>
<p>通过这些扩展，开发者可以选择自己熟悉的编程语言来扩展PostgreSQL的功能，使其适应各种需求和场景。</p>
<h2 id="PostgreSQL-语法"><a href="#PostgreSQL-语法" class="headerlink" title="PostgreSQL 语法"></a>PostgreSQL 语法</h2><ul>
<li><p>默认情况下 PostgreSQL 安装完成后，自带了一个命令行工具 SQL Shell(psql)。</p>
</li>
<li><p>Linux 系统可以直接切换到 postgres 用户来开启命令行工具：</p>
<ul>
<li><h1 id="sudo-i-u-postgres"><a href="#sudo-i-u-postgres" class="headerlink" title="sudo -i -u postgres"></a>sudo -i -u postgres</h1></li>
</ul>
</li>
<li><p>进入命令行工具，我们可以使用 \help 来查看各个命令的语法 ：</p>
<ul>
<li>postgres-# \help <command_name></li>
</ul>
</li>
<li><p>SQL 语句</p>
<ul>
<li>一个 SQL 语句通常包含了关键字、标识符（字段）、常量、特殊符号等，下面是一个简单的 SQL 语句：</li>
<li>SELECT id, name FROM runoob</li>
</ul>
</li>
<li><p>PostgreSQL 命令</p>
<ul>
<li>ABORT<ul>
<li>ABORT 用于退出当前事务。</li>
<li>ABORT [ WORK | TRANSACTION ]</li>
</ul>
</li>
<li>ALTER AGGREGATE<ul>
<li>修改一个聚集函数的定义 。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> AGGREGATE _name_ ( _argtype_ [ , ... ] ) RENAME <span class="keyword">TO</span> _new_name_</span><br><span class="line"><span class="keyword">ALTER</span> AGGREGATE _name_ ( _argtype_ [ , ... ] ) OWNER <span class="keyword">TO</span> _new_owner_</span><br><span class="line"><span class="keyword">ALTER</span> AGGREGATE _name_ ( _argtype_ [ , ... ] ) <span class="keyword">SET</span> SCHEMA _new_schema_</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ALTER COLLATION<ul>
<li>修改一个排序规则定义 。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLLATION</span> _name_ RENAME <span class="keyword">TO</span> _new_name_</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLLATION</span> _name_ OWNER <span class="keyword">TO</span> _new_owner_</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLLATION</span> _name_ <span class="keyword">SET</span> SCHEMA _new_schema_</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ALTER CONVERSION<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> CONVERSION name RENAME <span class="keyword">TO</span> new_name</span><br><span class="line"><span class="keyword">ALTER</span> CONVERSION name OWNER <span class="keyword">TO</span> new_owner</span><br></pre></td></tr></table></figure></li>
<li>ALTER DATABASE<ul>
<li>修改一个数据库。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE name <span class="keyword">SET</span> <span class="keyword">parameter</span> &#123; <span class="keyword">TO</span> <span class="operator">|</span> <span class="operator">=</span> &#125; &#123; <span class="keyword">value</span> <span class="operator">|</span> <span class="keyword">DEFAULT</span> &#125;</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE name RESET <span class="keyword">parameter</span></span><br><span class="line"><span class="keyword">ALTER</span> DATABASE name RENAME <span class="keyword">TO</span> new_name</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE name OWNER <span class="keyword">TO</span> new_owner</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ALTER DEFAULT PRIVILEGES<ul>
<li>定义默认的访问权限。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DEFAULT</span> PRIVILEGES</span><br><span class="line">    [ <span class="keyword">FOR</span> &#123; ROLE <span class="operator">|</span> <span class="keyword">USER</span> &#125; target_role [, ...] ]</span><br><span class="line">    [ <span class="keyword">IN</span> SCHEMA schema_name [, ...] ]</span><br><span class="line">    abbreviated_grant_or_revoke</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> abbreviated_grant_or_revoke <span class="keyword">is</span> <span class="keyword">one</span> <span class="keyword">of</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> &#123; &#123; <span class="keyword">SELECT</span> <span class="operator">|</span> <span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> <span class="keyword">DELETE</span> <span class="operator">|</span> <span class="keyword">TRUNCATE</span> <span class="operator">|</span> <span class="keyword">REFERENCES</span> <span class="operator">|</span> <span class="keyword">TRIGGER</span> &#125;</span><br><span class="line">    [, ...] <span class="operator">|</span> <span class="keyword">ALL</span> [ PRIVILEGES ] &#125;</span><br><span class="line">    <span class="keyword">ON</span> TABLES</span><br><span class="line">    <span class="keyword">TO</span> &#123; [ <span class="keyword">GROUP</span> ] role_name <span class="operator">|</span> PUBLIC &#125; [, ...] [ <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-RESTful/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-RESTful/" class="post-title-link" itemprop="url">RESTful</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>RESTful接口相关笔记</li>
<li>表现层状态转换(Representational State Transfer, REST)</li>
</ul>
<h2 id="表现层状态转换"><a href="#表现层状态转换" class="headerlink" title="表现层状态转换"></a>表现层状态转换</h2><ul>
<li><p>表现层状态转换（英语：Representational State Transfer，缩写：REST）是Roy Thomas Fielding博士于2000年在他的博士论文[1]中提出来的一种万维网软件架构风格，目的是便于不同软件&#x2F;程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于超文本传输协议（HTTP）之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。符合或兼容于这种架构风格（简称为 REST 或 RESTful）的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。因此表现层状态转换提供了在互联网络的计算系统之间，彼此资源可交互使用的协作性质（interoperability）。相对于其它种类的网络服务，例如SOAP服务，则是以本身所定义的操作集，来访问网络上的资源。</p>
</li>
<li><p>目前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的Web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务执行图书查询；雅虎提供的Web服务也是REST风格的。</p>
</li>
</ul>
<h2 id="要点及标准"><a href="#要点及标准" class="headerlink" title="要点及标准"></a>要点及标准</h2><ul>
<li><p>需要注意的是，REST是设计风格而不是标准。REST通常基于HTTP、URI、XML以及HTML这些现有的广泛流行的协议和标准。</p>
</li>
<li><p>资源是由URI来指定。</p>
</li>
<li><p>对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。</p>
</li>
<li><p>通过操作资源的表现形式来操作资源。</p>
</li>
<li><p>资源的表现形式则是XML或者HTML，取决于读者是机器还是人、是消费Web服务的客户软件还是Web浏览器。当然也可以是任何其他的格式，例如JSON。</p>
</li>
<li><p>可重新表达的状态迁移的特征</p>
<ul>
<li>Uniform Interface：统一接口。<ul>
<li>以资源为基础<ul>
<li>每个资源都可以通过URI访问到。</li>
<li>也就是一个个可以认知的资源，比如文档，音乐，视频等信息，都可以通过唯一的URI确定。</li>
</ul>
</li>
<li>通过重表达的客户端可以管理原资源<ul>
<li>就是我们通过客户端可以修改原资源的状态。</li>
</ul>
</li>
<li>返回信息足够描述自己<ul>
<li>这样重表达的客户端可以知道如何处理。</li>
</ul>
</li>
<li>超媒体是应用状态的引擎<ul>
<li>处理以超媒体为基础的状态变化。</li>
</ul>
</li>
</ul>
</li>
<li>Stateless：无状态。</li>
<li>Cacheable：可缓存。</li>
<li>Client-Server：客户服务器分离模式，任何一个客户端与服务器都是可替换的。</li>
<li>Layered System：分层的系统，客户端不知道他联系的是不是最终服务器。</li>
<li>Code on Demand（可选）：服务器可以将能力扩展到客户端，如果客户端可以执行的话。这个功能是可选择的</li>
</ul>
</li>
</ul>
<h2 id="REST架构的限制条件"><a href="#REST架构的限制条件" class="headerlink" title="REST架构的限制条件"></a>REST架构的限制条件</h2><ul>
<li>REST架构风格最重要的架构限制有6个：<ol>
<li>客户端-服务器（Client-Server）</li>
</ol>
<ul>
<li>客户端-服务器结构限制的目的是将客户端和服务器端的关注点分离。将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来有助于提高用户界面的跨平台的可移植性。通过简化服务器模块也有助于服务器模块的可扩展性。</li>
</ul>
<ol start="2">
<li>无状态(Stateless)</li>
</ol>
<ul>
<li>服务器不能保存客户端的信息；每一次从客户端发送的请求中，要包含所有的必须的状态信息，会话信息由客户端保存，服务器端根据这些状态信息来处理请求。</li>
<li>服务器可以将会话状态信息传递给其他服务，比如数据库服务，这样可以保持一段时间的状态信息，从而实现认证功能。</li>
<li>当客户端可以切换到一个新状态的时候发送请求信息。</li>
<li>当一个或者多个请求被发送之后，客户端就处于一个状态变迁过程中。每一个应用的状态描述可以被客户端用来初始化下一次的状态变迁。</li>
</ul>
<ol start="3">
<li>缓存(Cacheability)</li>
</ol>
<ul>
<li>如同万维网一样，客户端和中间的通讯传递者可以将回复缓存起来。回复必须明确的或者间接的表明本身是否可以进行缓存，这可以预防客户端在将来进行请求的时候得到陈旧的或者不恰当的数据。管理良好的缓存机制可以减少客户端-服务器之间的交互，甚至完全避免客户端-服务器交互，这进一步提了高性能和可扩展性</li>
</ul>
<ol start="4">
<li>统一接口(Uniform Interface)</li>
</ol>
<ul>
<li>这是 RESTful 系统设计的基本出发点。它简化了系统架构，减少了耦合性，可以让所有模块各自独立的进行改进。包括下列四个限制：<ul>
<li>请求中包含资源的 ID（Resource identification in requests）<ul>
<li>请求中包含了各种独立资源的标识，例如，在Web服务中的URI。资源本身和发送给客户端的标识是独立。例如，服务器可以将自身的数据库信息以HTML、XML或者JSON的方式发送给客户端，但是这些可能都不是服务器的内部记录方式。</li>
</ul>
</li>
<li>资源通过标识来操作（Resource manipulation through representations）<ul>
<li>当客户端拥有一个资源的标识，包括附带的元数据，则它就有足够的信息来删除这个资源。</li>
</ul>
</li>
<li>消息的自我描述性（Self-descriptive messages）<ul>
<li>每一个消息都包含足够的信息来描述如何来处理这个信息. 例如，媒体类型 (media-type) 就可以确定需要什么样的分析器来分析媒体数据.</li>
</ul>
</li>
<li>用超媒体驱动应用状态（Hypermedia as the engine of application state (HATEOAS)）<ul>
<li>同用户访问Web服务器的Home页面相似，当一个 REST 客户端访问了最初的REST应用的URI之后，REST 客户端应该可以使用服务器端提供的链接，动态的发现所有的可用的资源和可执行的操作。随着访问的进行，服务器在响应中提供文字超链接，以便客户端可以得到当前可用的操作。客户端无需用确定的编码的方式记录下服务器端所提供的动态应用的结构信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="5">
<li>分层系统(Layered System)</li>
</ol>
<ul>
<li>客户端一般不知道是否直接连接到了最终的服务器，或者是路径上的中间服务器。中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性，这样可也便于安全策略的部署</li>
</ul>
<ol start="6">
<li>按需代码(Code-On-Demand, 可选)</li>
</ol>
<ul>
<li>服务器可以通过发送可执行代码给客户端的方式临时性的扩展功能或者定制功能，例如Java Applet、Flash或JavaScript。</li>
</ul>
</li>
</ul>
<h2 id="关于状态"><a href="#关于状态" class="headerlink" title="关于状态"></a>关于状态</h2><ul>
<li>应该注意区别应用的状态和连接协议的状态。HTTP连接是无状态的（也就是不记录每个连接的信息），而REST传输会包含应用的所有状态信息，因此可以大幅降低对HTTP连接的重复请求资源消耗</li>
</ul>
<h2 id="REST的优点"><a href="#REST的优点" class="headerlink" title="REST的优点"></a>REST的优点</h2><ul>
<li>可更高效利用缓存来提高响应速度</li>
<li>通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性</li>
<li>浏览器即可作为客户端，简化软件需求</li>
<li>相对于其他叠加在HTTP协议之上的机制，REST的软件依赖性更小</li>
<li>不需要额外的资源发现机制</li>
<li>在软件技术演进中的长期的兼容性更好</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Repo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Repo/" class="post-title-link" itemprop="url">Repo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>repo工具的笔记</li>
</ul>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>在Linux系统中，”repo” 是一个版本控制工具，用于协调多个Git存储库的管理和同步。它是Google为了管理Android开源项目而开发的，但也可用于其他项目。</p>
<p>repo工具基于Python编写，它提供了一个简化的方式来处理包含多个Git存储库的项目。使用repo工具，您可以轻松地进行跨多个存储库的代码同步、分支管理和代码审查等操作。</p>
<p>以下是repo工具的一些常见用法和功能：</p>
<ol>
<li><p>安装repo：要使用repo工具，您首先需要安装它。通常，您可以从Linux发行版的软件仓库中安装repo软件包。例如，在Ubuntu上可以使用以下命令安装repo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install repo</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化项目：要在一个新项目中使用repo工具，您需要创建一个包含一个特殊的仓库清单（manifest）文件的目录。这个清单文件描述了项目中的所有Git存储库以及它们的分支、路径等信息。然后，使用以下命令初始化项目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u &lt;manifest-url&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;manifest-url&gt;</code>是指向清单文件的URL。</p>
</li>
<li><p>同步代码：一旦项目初始化完成，您可以使用以下命令将代码同步到本地工作区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure>

<p>这将根据清单文件中定义的分支和路径，将各个Git存储库的代码下载到本地。</p>
</li>
<li><p>创建分支：使用repo工具可以轻松创建和切换Git分支。例如，要创建一个名为<code>mybranch</code>的分支，可以执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo start mybranch --all</span><br></pre></td></tr></table></figure>

<p>这将在所有Git存储库中创建名为<code>mybranch</code>的新分支。</p>
</li>
<li><p>提交更改：在进行代码更改后，可以使用普通的Git命令将更改提交到特定的存储库。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;repository-directory&gt;</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Commit message&quot;</span><br></pre></td></tr></table></figure>

<p>然后，使用<code>repo upload</code>命令将提交的更改推送到相应的存储库。</p>
</li>
</ol>
<p>这只是repo工具的一些基本用法，它还提供了其他功能，例如管理代码分支、处理代码审查等。您可以通过运行<code>repo help</code>命令获取更多的帮助和使用说明。</p>
<p>请注意，repo工具主要用于管理包含多个Git存储库的大型项目，因此在小型项目或单个存储库的情况下，可能没有必要使用repo工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Software_Development_Process_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Software_Development_Process_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" class="post-title-link" itemprop="url">Software_Development_Process_软件工程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>项目启动</p>
<ul>
<li>确定产品方向 -》需求调研，市场调研 -》业务梳理，思维导图 -》业务梳理，评审</li>
</ul>
</li>
<li><p>需求阶段</p>
<ul>
<li>产品原型 -》了解需求 -》 了解开发难度，评估开发工作量 -》 评估需求 -》项目里程碑，项目开发计划，项目任务分解 -》 需求概要</li>
</ul>
</li>
<li><p>设计阶段</p>
<ul>
<li>UI界面以及标注，UI设计规范 -》 需求规格 -》 概要设计，通讯协议，表结构设计</li>
</ul>
</li>
<li><p>开发阶段</p>
<ul>
<li>产品开发</li>
</ul>
</li>
<li><p>测试阶段</p>
<ul>
<li>修改bug -》 测试用例，测试结果报告，测试周报，用户体验</li>
</ul>
</li>
<li><p>系统上线</p>
<ul>
<li>上线</li>
</ul>
</li>
</ul>
<h2 id="开发流程-2"><a href="#开发流程-2" class="headerlink" title="开发流程 2"></a>开发流程 2</h2><ul>
<li><p>软件工程的思想主要集中于加强项目管理者的工作上</p>
</li>
<li><p>软件开发流程分为：</p>
<ul>
<li>可行性分析</li>
<li>需求分析</li>
<li>概要设计</li>
<li>详细设计</li>
<li>测试</li>
<li>运维</li>
</ul>
</li>
<li><p>可行性分析</p>
<ul>
<li>考虑要点：技术 经济 法律 市场；</li>
<li>说明：系统是否可以开发</li>
<li>查看文档人员：项目经理、技术总监、客户。</li>
</ul>
</li>
<li><p>需求分析</p>
<ul>
<li>说明：客户和开发人员进行沟通，为开发人员开发出来软件满足客户的需要提供依据</li>
<li>应有图：功能框架图、原型图 、用例图、功能模型图（ER图）、IPO、数据字典</li>
<li>查看文档人员：客户、需求分析人员、开发人员、测试人员</li>
</ul>
</li>
<li><p>概要设计</p>
<ul>
<li>说明：开发阶段对整体框架进行设计</li>
<li>应有图：架构图、包图、类图、接口图、流程图、功能模块对应图</li>
<li>查看文档人员：技术总监、开发人员</li>
</ul>
</li>
<li><p>详细设计</p>
<ul>
<li>说明：对程序进行详细的设计</li>
<li>应有图：时序图、协作图 、类图、活动图、状态图</li>
<li>查看文档人员：技术总监、开发人员</li>
</ul>
</li>
<li><p>数据库设计</p>
<ul>
<li>说明：指导数据库设计规划以及实现；</li>
<li>应有图：ER图、数据库关系图；</li>
<li>查看文档人员：数据库设计人员、数据库管理员、开发人员</li>
</ul>
</li>
<li><p>测试情况</p>
<ul>
<li>说明：对开发好的程序进行测试，以发现系统中出现的Bug；</li>
<li>应有图：测试用例</li>
<li>查看文档人员：测试人员、开发人员</li>
</ul>
</li>
<li><p>用户手册</p>
<ul>
<li>说明：让用户快速使用这个系统，并且在使用过程中出现问题可快速解决</li>
<li>应有图：界面截图；</li>
<li>查看文档人员：用户，文档审核人员</li>
</ul>
</li>
<li><p>运行与维护</p>
<ul>
<li>说明：交付东西——目标安装程序、数据库文件、用户手册、需求报告。</li>
<li>查看文档人员：用户、项目经理、文档审核人员</li>
</ul>
</li>
<li><p>小结</p>
<ul>
<li>系统要做就要有文档先行，要用文档驱动</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-NodeMCU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-NodeMCU/" class="post-title-link" itemprop="url">NodeMCU</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>NodeMCU 固件相关笔记</li>
</ul>
<h2 id="NodeMCU开发板-常见的内置宏"><a href="#NodeMCU开发板-常见的内置宏" class="headerlink" title="NodeMCU开发板 常见的内置宏"></a>NodeMCU开发板 常见的内置宏</h2><p>NodeMCU开发板在Arduino编程环境中通常具有以下常见的内置宏和引脚映射：</p>
<ol>
<li><p><code>LED_BUILTIN</code>：这个宏用于指代NodeMCU开发板上的内置LED引脚。通常映射到板上的一个特定引脚（如D4或GPIO2），用于方便控制内置LED。</p>
</li>
<li><p><code>D0</code> 到 <code>D8</code>：这些宏表示NodeMCU开发板上的数字引脚，从D0到D8。它们通常映射到相应的GPIO引脚，可用于连接外部设备。</p>
</li>
<li><p><code>A0</code>：这个宏表示NodeMCU开发板上的模拟引脚A0，通常用于模拟输入。</p>
</li>
<li><p><code>MISO</code>、<code>MOSI</code>、<code>SCK</code>、<code>SS</code>：这些宏表示SPI总线上的引脚，用于与SPI外设通信。NodeMCU开发板上通常有SPI接口。</p>
</li>
</ol>
<p>这些宏通常用于编程NodeMCU开发板，以便更轻松地访问和控制内置引脚和外部设备。请注意，NodeMCU开发板的具体引脚映射可能因不同版本和制造商而异，因此在编程时最好查看您使用的具体NodeMCU开发板的引脚映射表，以确保正确的引脚使用。</p>
<h2 id="nodemcu编程-LED-BUILTIN宏是什么-详解"><a href="#nodemcu编程-LED-BUILTIN宏是什么-详解" class="headerlink" title="nodemcu编程 LED_BUILTIN宏是什么 详解"></a>nodemcu编程 LED_BUILTIN宏是什么 详解</h2><p><code>LED_BUILTIN</code> 是一个常用于编程NodeMCU开发板的宏，通常在Arduino环境下使用。这个宏用于指代NodeMCU开发板上的内置LED引脚。</p>
<p>NodeMCU开发板通常内置了一个LED，它位于板子上的某个特定引脚。使用<code>LED_BUILTIN</code> 宏可以让您在编程中引用这个LED而不必记住实际引脚编号。这对于快速编程和示例代码非常方便，因为不同的NodeMCU版本可能具有不同的LED引脚。</p>
<p>在Arduino编程环境中，您可以使用<code>LED_BUILTIN</code> 宏来控制NodeMCU开发板上的内置LED，例如点亮或熄灭它。以下是一个简单的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(LED_BUILTIN, OUTPUT); <span class="comment">// 将LED引脚设置为输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_BUILTIN, HIGH);   <span class="comment">// 点亮LED</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);                      <span class="comment">// 延时1秒</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(LED_BUILTIN, LOW);    <span class="comment">// 熄灭LED</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);                      <span class="comment">// 延时1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中，<code>LED_BUILTIN</code> 宏会自动映射到NodeMCU开发板上的内置LED引脚，无需手动指定引脚编号。这样，代码在不同NodeMCU版本之间通常可以通用。</p>
<p>请注意，不同版本的NodeMCU开发板可能具有不同的LED引脚映射，因此使用<code>LED_BUILTIN</code> 宏可以提高代码的可移植性，而不必担心特定引脚编号。</p>
<h2 id="用于lua脚本上传到IOT开发板的工具-详解"><a href="#用于lua脚本上传到IOT开发板的工具-详解" class="headerlink" title="用于lua脚本上传到IOT开发板的工具 详解"></a>用于lua脚本上传到IOT开发板的工具 详解</h2><p>为了将Lua脚本上传到物联网（IoT）开发板，你可以使用各种工具和方法，具体取决于你的开发板类型和连接方式。以下是一些通用的工具和方法，以及它们的简要说明：</p>
<ol>
<li><p><strong>NodeMCU工具 - ESPlorer</strong>：</p>
<ul>
<li>ESPlorer是一个用于NodeMCU开发板的跨平台Lua文件上传工具。</li>
<li>它提供了文件管理、上传、下载、运行和调试Lua脚本的功能。</li>
<li>ESPlorer是一个开源工具，可以从GitHub上获得。</li>
</ul>
</li>
<li><p><strong>NodeMCU工具 - NodeMCU Flasher</strong>：</p>
<ul>
<li>NodeMCU Flasher是一个用于NodeMCU开发板的固件烧写工具，但它也允许上传Lua脚本。</li>
<li>你可以将Lua脚本文件添加到NodeMCU Flasher中，然后将它们上传到NodeMCU开发板。</li>
<li>这个工具适用于Windows环境。</li>
</ul>
</li>
<li><p><strong>Luatool</strong>：</p>
<ul>
<li>Luatool是一个命令行工具，用于上传Lua脚本到ESP8266（NodeMCU）开发板。</li>
<li>你可以使用命令行来指定要上传的Lua脚本文件以及开发板的串口端口。</li>
<li>Luatool支持Windows、Linux和macOS。</li>
</ul>
</li>
<li><p><strong>PlatformIO</strong>：</p>
<ul>
<li>如果你使用PlatformIO开发环境，你可以使用其内置的功能来上传Lua脚本到支持ESP8266的开发板。</li>
<li>PlatformIO提供了丰富的开发工具，包括代码编辑、编译、上传和监视。</li>
</ul>
</li>
<li><p><strong>Arduino IDE</strong>：</p>
<ul>
<li>如果你在Arduino IDE中编写Lua脚本，可以使用Arduino IDE的ESP8266支持来上传脚本。</li>
<li>你需要在Arduino IDE中选择适当的开发板和端口，然后将Lua脚本上传。</li>
</ul>
</li>
<li><p><strong>其他工具</strong>：</p>
<ul>
<li>根据你使用的硬件开发板和环境，还可以找到其他工具和方法来上传Lua脚本。请查看你的硬件制造商或社区的支持资源。</li>
</ul>
</li>
</ol>
<p>在使用这些工具之前，确保已正确配置串口端口、波特率和其他通信参数，以便与开发板进行通信。上传Lua脚本后，你可以通过串口监视器或其他方法运行和调试它们。请查看相关工具的文档和示例，以确保顺利上传和执行Lua脚本。</p>
<h2 id="IOT中的硬件开发板是什么-详解"><a href="#IOT中的硬件开发板是什么-详解" class="headerlink" title="IOT中的硬件开发板是什么 详解"></a>IOT中的硬件开发板是什么 详解</h2><p>在物联网（IoT）应用中，硬件开发板是一种特殊的硬件设备，通常用于构建和测试物联网设备和应用。这些硬件开发板提供了一种用于开发、原型制作和测试物联网项目的平台，通常包括微控制器、传感器、通信接口和其他必要的组件。以下是有关IoT中硬件开发板的详细解释：</p>
<ol>
<li><p><strong>硬件开发板的组成</strong>：</p>
<ul>
<li><strong>微控制器</strong>：硬件开发板通常包括一款嵌入式微控制器，如ESP8266、ESP32、Arduino、Raspberry Pi等。微控制器是硬件的大脑，用于控制和管理连接的设备、传感器和通信模块。</li>
<li><strong>传感器</strong>：硬件开发板通常配备了各种传感器，如温度传感器、湿度传感器、加速度传感器、光敏传感器等，用于监测环境和设备数据。</li>
<li><strong>通信接口</strong>：硬件开发板通常具备Wi-Fi、蓝牙、LoRa、Zigbee等通信接口，以便设备与其他设备或云服务进行通信。</li>
<li><strong>GPIO引脚</strong>：通用输入输出引脚可用于连接其他硬件组件，如执行器、LED、继电器等。</li>
</ul>
</li>
<li><p><strong>开发环境</strong>：</p>
<ul>
<li>硬件开发板通常与特定的开发环境（如Arduino IDE、PlatformIO、MicroPython、Raspberry Pi OS等）兼容，以便开发人员可以使用合适的编程语言和工具来编写和测试代码。</li>
<li>这些开发环境提供了用于编程和调试硬件的库、示例代码和工具。</li>
</ul>
</li>
<li><p><strong>应用领域</strong>：</p>
<ul>
<li>硬件开发板广泛应用于各种IoT应用领域，包括智能家居、工业自动化、农业、医疗保健、智能城市、车联网等。</li>
<li>它们可以用于监测环境数据、控制设备、收集传感器信息、与云服务通信等各种任务。</li>
</ul>
</li>
<li><p><strong>原型开发</strong>：</p>
<ul>
<li>硬件开发板是快速原型制作的理想选择，因为它们提供了一种简单的方式来构建和测试物联网设备的初始版本，无需进行大规模的硬件设计和制造。</li>
<li>开发人员可以在硬件开发板上快速验证其创意和概念。</li>
</ul>
</li>
<li><p><strong>生态系统</strong>：</p>
<ul>
<li>许多硬件开发板都有庞大的社区支持和生态系统，提供了丰富的资源、库和示例代码，使得IoT项目开发更容易。</li>
</ul>
</li>
</ol>
<p>总之，硬件开发板在物联网应用中扮演着重要的角色，它们为开发人员提供了一个用于构建、测试和原型制作物联网设备的平台。这些硬件开发板具有各种传感器和通信接口，可用于满足不同IoT应用的需求，并提供了相应的开发环境和资源，以简化IoT项目的开发流程。硬件开发板使得IoT的原型开发更加容易，促进了创新和新产品的推出。</p>
<h2 id="NodeMCU-详解"><a href="#NodeMCU-详解" class="headerlink" title="NodeMCU 详解"></a>NodeMCU 详解</h2><p>NodeMCU是一款开源的物联网（IoT）开发板，它使用了Espressif Systems的ESP8266模块，并提供了易于使用的硬件和软件接口，使得开发物联网项目变得非常方便。以下是有关NodeMCU的详细信息：</p>
<ol>
<li><p><strong>硬件特性</strong>：</p>
<ul>
<li><strong>微控制器</strong>：NodeMCU使用ESP8266模块，其中包括一个Tensilica L106 32位处理器，闪存（Flash）和SRAM内存。</li>
<li><strong>Wi-Fi</strong>：NodeMCU支持802.11b&#x2F;g&#x2F;n标准的Wi-Fi连接，允许设备通过无线网络连接到互联网。</li>
<li><strong>GPIO引脚</strong>：NodeMCU具有多个通用输入输出引脚，可用于连接传感器、执行器和其他外部设备。</li>
<li><strong>USB接口</strong>：NodeMCU板上集成了Micro USB接口，用于供电和连接到计算机。</li>
<li><strong>开发者友好</strong>：NodeMCU采用了模块化设计，具有易于使用的引脚标签，开发人员可以方便地连接和测试不同的传感器和设备。</li>
</ul>
</li>
<li><p><strong>开发环境</strong>：</p>
<ul>
<li><strong>Lua</strong>：NodeMCU最初以Lua编程环境为基础，使得编程变得简单。</li>
<li><strong>Arduino</strong>：NodeMCU还支持Arduino IDE，使用ESP8266核心，允许使用C&#x2F;C++编程语言进行开发。</li>
<li><strong>MicroPython</strong>：通过MicroPython，你可以使用Python语言进行NodeMCU开发。</li>
</ul>
</li>
<li><p><strong>电源供应</strong>：NodeMCU可以通过Micro USB接口供电，也可以通过外部电源供电。</p>
</li>
<li><p><strong>内置固件</strong>：NodeMCU通常预装了NodeMCU固件，该固件提供了Lua编程环境，因此开发人员可以通过串口监视器轻松执行Lua脚本。</p>
</li>
<li><p><strong>应用领域</strong>：</p>
<ul>
<li><strong>物联网（IoT）项目</strong>：NodeMCU广泛用于开发智能家居设备、传感器网络、监控系统和其他物联网应用。</li>
<li><strong>原型开发</strong>：它是快速原型开发的理想选择，因为它易于编程和集成。</li>
<li><strong>教育和学习</strong>：NodeMCU适用于学习嵌入式系统、物联网和编程，因为它提供了友好的硬件和软件界面。</li>
</ul>
</li>
<li><p><strong>社区和支持</strong>：NodeMCU拥有庞大的开发者社区，你可以在各种论坛、社交媒体平台和网站上找到关于NodeMCU的帮助、教程和示例代码。</p>
</li>
</ol>
<p>总之，NodeMCU是一款强大且易于使用的开发板，适用于开发物联网和嵌入式应用。它的灵活性、低成本和广泛的生态系统使其成为学习嵌入式系统和物联网的理想选择，也是原型开发的好工具。如果你有兴趣开发与NodeMCU相关的项目，可以使用支持的编程环境，如Lua、Arduino或MicroPython，来编写和测试你的代码。</p>
<h2 id="NodeMCU和ESP8266的关系-详解"><a href="#NodeMCU和ESP8266的关系-详解" class="headerlink" title="NodeMCU和ESP8266的关系 详解"></a>NodeMCU和ESP8266的关系 详解</h2><p>NodeMCU和ESP8266之间的关系比较容易混淆，因为它们之间存在一些密切的联系，但实际上它们代表了不同的概念和产品。下面是有关NodeMCU和ESP8266之间关系的详细解释：</p>
<ol>
<li><p><strong>ESP8266</strong>：</p>
<ul>
<li><strong>ESP8266</strong>是一个由乐鑫（Espressif Systems）开发制造的低成本、低功耗、高性能的Wi-Fi模块。</li>
<li>ESP8266模块内部包括一个Tensilica L106 32位微控制器、闪存（Flash）存储器和SRAM内存，以及Wi-Fi模块。</li>
<li>ESP8266模块可用于连接设备到Wi-Fi网络，并允许设备通过互联网进行通信。它常常被嵌入到各种硬件设备中，从传感器到智能家电，以实现物联网连接。</li>
</ul>
</li>
<li><p><strong>NodeMCU</strong>：</p>
<ul>
<li><strong>NodeMCU</strong>是一款开源的硬件平台，基于ESP8266模块构建。NodeMCU硬件板上集成了ESP8266模块，提供了额外的硬件支持，如USB接口、电源管理电路和GPIO引脚。</li>
<li>NodeMCU还预装了NodeMCU固件，该固件基于Lua编程语言，为开发人员提供了一个易于使用的编程环境，可以通过串口监视器直接执行Lua脚本。</li>
<li>NodeMCU是一种开发板，使得基于ESP8266的应用程序开发变得更加容易，无需额外的硬件设计。</li>
</ul>
</li>
<li><p><strong>关系</strong>：</p>
<ul>
<li>NodeMCU是一种硬件开发板，而ESP8266是一款Wi-Fi模块。</li>
<li>NodeMCU基于ESP8266，通过提供额外的硬件和固件支持，简化了ESP8266的开发和编程。</li>
<li>开发人员可以选择使用NodeMCU硬件板，也可以直接使用ESP8266模块进行开发。NodeMCU是一种加速开发的工具，它提供了便捷的开发环境，尤其适用于初学者和原型开发。</li>
</ul>
</li>
</ol>
<p>总之，NodeMCU是基于ESP8266的硬件开发板，它提供了额外的硬件支持和易于使用的编程环境，使得ESP8266的应用程序开发更加容易。ESP8266是NodeMCU的核心，而NodeMCU是一种简化开发流程的工具。你可以选择使用其中之一，具体取决于你的需求和经验水平。</p>
<h2 id="nodemcu-使用lua开发"><a href="#nodemcu-使用lua开发" class="headerlink" title="nodemcu 使用lua开发"></a>nodemcu 使用lua开发</h2><p>NodeMCU是一款支持Lua编程的开源硬件平台，通常基于ESP8266模块构建。使用NodeMCU和Lua编程，你可以轻松地开发物联网（IoT）应用程序，而无需太多的低级硬件编程知识。以下是一些基本步骤，演示如何在NodeMCU上使用Lua进行开发：</p>
<ol>
<li><p><strong>准备NodeMCU硬件</strong>：</p>
<ul>
<li>获取NodeMCU开发板。</li>
<li>通过Micro USB线连接NodeMCU开发板到计算机，以供电和进行数据传输。</li>
</ul>
</li>
<li><p><strong>安装驱动程序</strong>：</p>
<ul>
<li>在连接NodeMCU到计算机后，可能需要安装相应的USB驱动程序，以便计算机能够识别NodeMCU设备。</li>
</ul>
</li>
<li><p><strong>安装LuaLoader</strong>：</p>
<ul>
<li>为了编写、上传和运行Lua脚本，你可以使用名为”LuaLoader”的开发工具，它是NodeMCU Lua的一个集成开发环境（IDE）。</li>
<li>下载和安装LuaLoader，并确保它能够识别你的NodeMCU设备。</li>
</ul>
</li>
<li><p><strong>编写Lua脚本</strong>：</p>
<ul>
<li>使用LuaLoader或任何文本编辑器编写Lua脚本。示例Lua脚本如下：</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Blink LED on NodeMCU</span></span><br><span class="line">led_pin = <span class="number">4</span>  <span class="comment">-- GPIO4 on NodeMCU</span></span><br><span class="line"></span><br><span class="line">gpio.mode(led_pin, gpio.OUTPUT)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    gpio.<span class="built_in">write</span>(led_pin, gpio.LOW)</span><br><span class="line">    tmr.delay(<span class="number">1000000</span>) <span class="comment">-- 1 second</span></span><br><span class="line">    gpio.<span class="built_in">write</span>(led_pin, gpio.HIGH)</span><br><span class="line">    tmr.delay(<span class="number">1000000</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这是一个简单的示例，演示如何让NodeMCU上的LED闪烁。</p>
</li>
<li><p><strong>上传Lua脚本</strong>：</p>
<ul>
<li>使用LuaLoader将编写的Lua脚本上传到NodeMCU设备。通常，你需要连接到NodeMCU，选择要上传的脚本文件，并将其上传到设备。</li>
</ul>
</li>
<li><p><strong>运行Lua脚本</strong>：</p>
<ul>
<li>一旦上传完成，你可以运行Lua脚本。NodeMCU将执行脚本中的指令，从而实现特定的功能。</li>
<li>在这个示例中，NodeMCU将使连接到GPIO 4的LED灯闪烁。</li>
</ul>
</li>
</ol>
<p>这些是基本的步骤，演示如何在NodeMCU上使用Lua进行开发。你可以通过编写自定义Lua脚本来实现各种物联网应用，如传感器数据采集、远程控制、物联网通信等。LuaLoader提供了许多工具和示例代码，以帮助你开始编写和调试Lua脚本。请注意，NodeMCU还支持Arduino和MicroPython等编程环境，你可以根据自己的需求选择适当的开发工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Robot_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Robot_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Robot_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>机器人相关的理论基础知识</li>
</ul>
<h2 id="轴角"><a href="#轴角" class="headerlink" title="轴角"></a>轴角</h2><p>轴角（Axis-Angle）表示是一种用于描述三维空间中旋转的方法，它使用一个旋转轴的方向向量和一个旋转角度来表示旋转操作。轴角表示法具有直观性和数学简洁性，尤其在对大角度旋转和连续旋转的情况下很有用。</p>
<p>以下是轴角表示法的一些详细说明：</p>
<p><strong>1. 旋转轴向量：</strong> 旋转轴向量是一个单位向量，它指示了围绕它进行旋转的轴的方向。通常用一个三维向量 ( \mathbf{v} &#x3D; (x, y, z) ) 表示。这个向量不仅指明了旋转的方向，还表明了旋转的轴在三维空间中的位置。</p>
<p><strong>2. 旋转角度：</strong> 旋转角度是旋转操作的大小，通常以弧度为单位来度量。它决定了围绕旋转轴旋转多少弧度。正值表示逆时针旋转，负值表示顺时针旋转。</p>
<p><strong>3. 旋转矩阵：</strong> 使用轴角表示旋转，可以通过旋转矩阵来表示旋转操作。旋转矩阵是一个 3x3 的矩阵，它描述了绕指定轴旋转指定角度的操作。可以使用 Rodrigues 公式将轴角转换为旋转矩阵。公式如下：</p>
<p>[ \mathbf{R} &#x3D; \mathbf{I} + \sin(\theta)\mathbf{K} + (1 - \cos(\theta))\mathbf{K}^2 ]</p>
<p>其中 ( \mathbf{R} ) 是旋转矩阵，( \mathbf{I} ) 是单位矩阵，( \theta ) 是旋转角度，( \mathbf{K} ) 是由旋转轴向量构建的反对称矩阵。</p>
<p><strong>4. 应用领域：</strong> 轴角表示法在计算机图形学、计算机动画、机器人学等领域中得到广泛应用。它特别适用于模拟物体的旋转运动，例如在计算机游戏中模拟角色的转身、飞行器的定向等。</p>
<p><strong>5. 优点和缺点：</strong> 轴角表示法在大角度旋转情况下更加稳定，不会遇到欧拉角中的万向节死锁问题。然而，对于描述连续旋转过程，它可能不如四元数（Quaternions）表示法那么方便，因为连续旋转的组合操作可能导致旋转轴的不断变化，而轴角表示需要不断重新计算旋转轴。</p>
<p>综上所述，轴角表示法是一种有用且常见的方法，用于描述三维空间中的旋转操作。它通过一个旋转轴的方向和一个旋转角度来定义旋转，可以方便地将旋转转化为旋转矩阵进行计算和应用。</p>
<h2 id="旋转矩阵-欧拉角-旋转向量-四元数-详解"><a href="#旋转矩阵-欧拉角-旋转向量-四元数-详解" class="headerlink" title="旋转矩阵 欧拉角 旋转向量 四元数 详解"></a>旋转矩阵 欧拉角 旋转向量 四元数 详解</h2><p>在计算机图形学、计算机视觉、机器人学等领域，旋转是一个重要的概念，用于描述物体在三维空间中的姿态变化。为了表示旋转，存在多种方法，包括旋转矩阵、欧拉角、旋转向量和四元数。以下是对这些方法的详细解释：</p>
<p><strong>1. 旋转矩阵（Rotation Matrix）：</strong><br>旋转矩阵是一个3x3的矩阵，用于描述物体在三维空间中的旋转操作。矩阵的每一列和每一行都是一个单位向量，分别表示旋转后的X、Y和Z轴方向。旋转矩阵满足正交性质，即列向量和行向量都是正交归一的。旋转矩阵可以通过多种方式创建，例如使用轴角、欧拉角、四元数等。</p>
<p><strong>2. 欧拉角（Euler Angles）：</strong><br>欧拉角是一组用于描述旋转的三个角度，通常表示为 ( \phi, \theta, \psi ) 或者 Roll、Pitch、Yaw。它们分别表示绕X轴、Y轴和Z轴旋转的角度。尽管欧拉角在某些情况下很直观，但它们存在万向节死锁问题，当某个轴的角度接近90度时，其他轴的旋转将受到限制。</p>
<p><strong>3. 旋转向量（Rotation Vector）：</strong><br>旋转向量是一个三维向量，其方向指示旋转轴，大小表示旋转角度。旋转向量通常与轴角表示法相关联，其中向量的方向是旋转轴，向量的长度是旋转角度。旋转向量的优点之一是它在大角度旋转时较稳定。</p>
<p><strong>4. 四元数（Quaternions）：</strong><br>四元数是一种复数扩展，用于表示旋转。它们在旋转计算中非常有用，因为它们避免了欧拉角的问题，并且在连续旋转和插值计算中表现出色。四元数由一个实部和三个虚部组成，可以使用复数运算来进行旋转计算。</p>
<p>每种方法都有其优点和缺点，适用于不同的应用场景。选择正确的表示方法取决于您的需求，考虑到精度、稳定性和计算效率等因素。在实际应用中，通常会根据具体情况选择最适合的旋转表示方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Tesseract/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Tesseract/" class="post-title-link" itemprop="url">Tesseract</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Tesseract库</li>
</ul>
<h2 id="Tesseract是什么"><a href="#Tesseract是什么" class="headerlink" title="Tesseract是什么"></a>Tesseract是什么</h2><p>Tesseract是一个开源的OCR（光学字符识别）引擎，由HP实验室开发，并在2006年后由Google维护和发展。该引擎能够将图像中的文本转换成可编辑的文本格式，例如TXT、HTML或PDF。Tesseract能够处理多种语言，并且在某些情况下，它的识别准确率相当高。</p>
<p>Tesseract采用C++编写，但也提供了Python、Java等语言的接口，因此可以方便地在不同的编程环境中使用。它支持多种操作系统，包括Windows、Linux和macOS。</p>
<p>Tesseract的功能强大，应用广泛。它被用于许多领域，如文档扫描、数字化图书馆、自动化办公等。配合其他图像处理库，例如OpenCV，Tesseract能够实现更复杂的文本识别任务，并且被广泛应用于实际项目中。</p>
<h2 id="Tesseract-详解"><a href="#Tesseract-详解" class="headerlink" title="Tesseract 详解"></a>Tesseract 详解</h2><p>Tesseract是一个开源的OCR（光学字符识别）引擎，它能够将图像中的文本转换成可编辑的文本格式。以下是对Tesseract的详细解释：</p>
<ol>
<li><p><strong>历史</strong>：</p>
<ul>
<li>Tesseract最初由HP实验室开发，并于1985年首次发布。在2006年之后，Google接手了Tesseract的开发和维护，并进行了大幅改进和更新。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>文本识别：Tesseract能够从图像中识别文本，将其转换为计算机可编辑的文本格式，例如TXT、HTML或PDF。</li>
<li>多语言支持：Tesseract支持超过100种语言的识别，包括各种语种的拉丁字母、亚洲语言等。</li>
<li>精度和性能：Tesseract在一些情况下具有较高的识别准确率，特别是对于印刷体文本和标准字体。</li>
<li>配置灵活：用户可以通过配置文件来调整Tesseract的识别行为，例如指定识别语言、设置识别参数等。</li>
</ul>
</li>
<li><p><strong>使用</strong>：</p>
<ul>
<li>Tesseract提供了C++接口，但也支持其他编程语言的接口，如Python、Java等，因此可以方便地在不同的开发环境中使用。</li>
<li>通常，使用Tesseract进行文本识别的过程包括图像预处理、调用Tesseract进行识别、获取识别结果并处理。</li>
</ul>
</li>
<li><p><strong>应用领域</strong>：</p>
<ul>
<li>文档扫描和数字化：Tesseract常用于将扫描的文档转换为可搜索的文本，或将图书、报纸等内容数字化。</li>
<li>自动化办公：Tesseract可以用于自动化办公流程中的文本提取和识别，如自动化填写表单、识别发票、提取邮件内容等。</li>
<li>数据挖掘和信息检索：Tesseract也被用于数据挖掘和信息检索领域，以从图像中提取有用的信息和数据。</li>
</ul>
</li>
</ol>
<p>总的来说，Tesseract是一个功能强大且广泛应用的OCR引擎，它为用户提供了将图像中的文本转换为可编辑文本的解决方案，并在许多领域中发挥着重要作用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Software_development_base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Software_development_base/" class="post-title-link" itemprop="url">Software_development_base</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="计算机系统-–-基础知识"><a href="#计算机系统-–-基础知识" class="headerlink" title="计算机系统 –  基础知识"></a>计算机系统 –  基础知识</h2><ul>
<li><p>计算系统，是一个完整的工作系统。系统不仅包括计算机，还包括各种软件以及外部设备。</p>
</li>
<li><p>计算机就是用于执行指定操作的机器，这些操作通常是一组指令的集合，这些指令也称为软件(software)</p>
</li>
<li><p>计算机硬件(hardware)是系统的物理组成部分，是可以真真切切触摸到的</p>
</li>
<li><p>硬件包括计算机及其周边设备，例如键盘，鼠标，显示器，硬盘，打印机等</p>
</li>
<li><p>计算机软件是以电子形式在硬件中驻留和运行的程序，例如编译器，操作系统以及应用程序等。软件提供了人机接口(Human Computer Interface, HCI)，并定义了计算机应该执行的操作</p>
</li>
</ul>
<h3 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h3><ul>
<li><p>在冯·诺依曼的模型里，可以看到输入设备，输出设备，存储单元以及由控制单元(control unit)和带有累加器(accumulator)的算数逻辑单元(Arithmetic Logic Unit, ALU)构成的模块</p>
</li>
<li><p>存储单元存储数据，控制单元则控制数据的传输和数据的处理。</p>
</li>
<li><p>控制单元取回指令并对其进行译码后存入存储单元中，同时从输入设备接收数据，并将数据存入存储单元</p>
</li>
<li><p>控制单元对可执行指令进行译码，并将数据送入ALU。 ALU执行操作，控制单元则将计算结果送入输出设备。</p>
</li>
<li><p>这里的控制单元和ALU一起称为中央处理单元(Central Processing Unit, CPU)</p>
</li>
<li><p>ALU中的累加器是一组高速寄存器的集合，用作算术和逻辑操作的操作数和结果的临时存储</p>
</li>
<li><p>ALU中的寄存器大小对应着计算机的字长(word size)。</p>
</li>
<li><p>一般的字长有16位，32位，64位，这取决于处理器的设计方案</p>
</li>
<li><p>1位代表一个二进制位，而且处理器的字长都是2的幂</p>
</li>
</ul>
<h3 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h3><ul>
<li><p>计算机软甲包含了我们希望计算机执行的指令或者命令。</p>
</li>
<li><p>在计算机软件中的分类中有几类比较重要，包括操作系统，软件工具，各种程序语言的编译器</p>
</li>
<li><p>如果某个工程问题可以通过使用软件工具解决，通常来说，这比写一个程序来解决问题更高效。</p>
</li>
<li><p>然而，很多问题都不能通过现有软件工具来解决，或者软件工具在需要解决问题的计算机系统上不可用，因此，我们也需要知道如何使用计算机语言来写程序。</p>
</li>
<li><p>随着一些功能强大的软件的出现，这些软件除了支持专门的操作系统还包含了编程语言，这使得软件工具和计算机语言之间的区别变得越来越模糊</p>
</li>
</ul>
<h3 id="计算机语言"><a href="#计算机语言" class="headerlink" title="计算机语言"></a>计算机语言</h3><ul>
<li><p>计算机语言有不同的层次</p>
</li>
<li><p>机器语言(machine language)是最基础的语言，是与计算机硬件设计密切相关的</p>
</li>
<li><p>因为计算机的设计是建立在二态技术（类似的情况有电路的开合，开关的打开与关闭，电池的正负极）基础上的，所以机器语言也使用两种符号来编写，通常使用数字0和1来表示。</p>
</li>
<li><p>因此，机器语言也是一种二进制语言，它的指令都是使用由0和1组成的序列携程的，这些序列称为二进制串</p>
</li>
<li><p>因为机器语言是与计算机硬件紧密相关的，所以SUN计算机上与HP计算机上的机器语言是不同的</p>
</li>
<li><p>对于某种特定的计算机设计语言，汇编语言(assembly language)也是唯一的，但是汇编语言的指令是用可读性更好的符号语句而非二进制串编写的</p>
</li>
<li><p>汇编语言的语句类型通常并不是很多，在使用汇编语言时，必须了解与之相应的硬件信息，</p>
</li>
<li><p>包含微处理器的设备通常要求程序能够极快地执行，这样的程序称为实时程序(real-time program)</p>
</li>
<li><p>实时程序通常使用汇编语言编写，这样可以发挥特定计算机硬件的优势，以提高执行速度</p>
</li>
<li><p>高级语言(high-level language)是具有类似自然语言的命令和指令的计算机语言，C++，C, Fortran,Ada, Java,Basic等都是高级语言</p>
</li>
<li><p>执行计算机程序，要执行使用诸如C++这样的高级语言编写的程序，必须先将高级语言指令翻译成机器语言。</p>
</li>
<li><p>执行这种翻译任务的程序称为编译器(compiler)</p>
</li>
<li><p>在编译阶段出现的错误称作解析错误(parse error)或语法错误(syntax error)</p>
</li>
<li><p>当没有语法错误后，编译器就可以成功地翻译程序，并声称机器语言形式的程序，生成的程序将完成最开始C++程序所要执行的功能。</p>
<ul>
<li>这一，C++程序称为源文件(source file)，而生成的机器语言版本则称为目标文件(object file)</li>
<li>因此，源程序和目标程序所描述的功能是一致的，但是源程序使用高级语言编写的，而目标程序则是以机器语言的形式</li>
</ul>
</li>
<li><p>执行(execution)，这些步骤包括将目标程序与机器语言语句进行链接(linking)和把程序载入(loading)内存</p>
</li>
<li><p>在执行阶段出现的错误称为执行错误(execution error)，运行时错误(run-time error)或逻辑错误(logic error)，这些错误也叫做程序bug</p>
</li>
<li><p>如果执行错误是由于程序中所编写的语句产生的，必须在源程序中修改错误并重新进行编译，这个过程叫做调试(debugging)</p>
</li>
</ul>
<h3 id="数据的表示与存储"><a href="#数据的表示与存储" class="headerlink" title="数据的表示与存储"></a>数据的表示与存储</h3><ul>
<li><p>在数字计算机中，一个二进制位可以使用一个位(bit)表示。</p>
</li>
<li><p>位上的值在任何时候都只能是0或1.从硬件的角度来说，当该位处于关闭或低电位时，它的值为0，而当其处于打开或高电位时，其值为1</p>
</li>
<li><p>二进制数在内存中以序列的形式存储，位序列称为字(word)</p>
</li>
<li><p>字的长度每增加1位，字所表示的数的大小就以2的幂增加，而其所能表示的范围就翻一倍</p>
</li>
<li><p>内存中可用的字的数目称为内存空间，或者地址空间(address space)</p>
</li>
<li><p>字长决定了存储在某个地址中的数值范围，而地址空间则决定了可以存储多少个字</p>
</li>
<li><p>C++包含整型数，浮点数，字符和布尔值等内建的数据类型。每种数据类型都由一个以字节(byte)为单位来确定的预定义大小，1个字节就是一个8位的序列。</p>
</li>
<li><p>为了定义标识符(identifier)并为它分配空间，则需要使用类型声明语句(type declaration statement)。</p>
</li>
<li><p>当定义一个标识符时，便确定了其数据类型，并在内存中分配相应字节数的空间。</p>
</li>
<li><p>当数据存储在内存中时，它是以位序列存在的。</p>
</li>
<li><p>这些位序列可能是指令，数字，字符，图像或数字信号的一部分，或者是其他类型的数据</p>
<ul>
<li>负数的存储</li>
<li>浮点数的存储</li>
</ul>
</li>
</ul>
<h2 id="框架-Framework"><a href="#框架-Framework" class="headerlink" title="框架(Framework)"></a>框架(Framework)</h2><ul>
<li><p>什么是框架？</p>
<ul>
<li>框架(<code>Framework</code>)是构成一类特定软件可复用设计的一组相互协作的类。框架规定了你的应用的体系结构。</li>
<li>它定义了整体结构，类和对象的分割，各部分的主要责任，类和对象怎么协作，以及控制流程。框架预定义了这些设计参数，以便于应用设计者或实现者能集中精力于应用本身的特定细节</li>
<li>框架一般处在低层应用平台和高层业务逻辑之间的中间层</li>
</ul>
</li>
<li><p>为什么要用框架？</p>
<ul>
<li>因为软件系统发展到今天已经很复杂了，特别是服务器端软件，涉及到的知识，内容，问题太多。在某些方面使用别人成熟的框架，就相当于让别人帮你完成一些基础工作，你只需要集中精力完成系统的业务逻辑设计。</li>
<li>而且框架一般是成熟，稳健的，他可以处理系统很多细节问题，比如，事务处理，安全性，数据流控制等问题。</li>
<li>还有框架一般都经过很多人使用，所以结构很好，所以扩展性也很好，而且它是不断升级的，你可以直接享受别人升级代码带来的好处</li>
</ul>
</li>
<li><p>软件为什么要分层？</p>
</li>
</ul>
<ul>
<li>为了<strong>实现“高内聚、低耦合”</strong>。把问题划分开来各个解决，易于控制，易于延展，易于分配资源等</li>
</ul>
<ul>
<li><p>框架和设计模式</p>
<ul>
<li>构件通常是代码重用，而设计模式是设计重用，框架则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用</li>
<li>框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象</li>
<li>框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;</li>
<li>设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用</li>
</ul>
</li>
<li><p>构件(component)</p>
<ul>
<li>构件是面向软件体系架构的可复用软件模块。</li>
<li>构件是可复用的软件组成成份，可被用来构造其他软件。它可以是被封装的对象类、类树、一些功能模块、软件框架（framework）、软件构架（或体系结构Architectural）、文档、分析件、设计模式（Pattern）等</li>
<li>1995年，Ian Graham给出的构件定义如下：构件（Component）是指一个对象（接口规范、或二进制代码），它被用于复用，接口被明确定义</li>
<li>构件是作为一个逻辑紧密的程序代码包的形式出现的，有着良好的接口</li>
<li>采用构件软件不需要重新编译，也不需要源代码并且不局限于某一种编程语言。该过程叫做<strong>二进制复用（Binary Reuse）</strong>，因为它是建立在接口而不是源代码级别的复用之上的。虽然软件构件必须遵守一致的接口，但是它们的内部实现是完全自动的。因此，可以用过程语言和面向对象语言创建构件</li>
</ul>
</li>
<li><p>构件和面向对象设计的差别</p>
<ul>
<li>在纯面向对象的设计中，对象（类）、封装和继承三者缺一不可，但对构件可以没有继承性，只要实现封装即可</li>
<li>从构件和对象的生成方式上，对象生成属于实例化的过程，比较单一，而生成构件的方式较多</li>
<li><strong>构件是设计的概念，与具体编程语言无关，不像对象属于编程中的概念，要依赖于具体的编程语言</strong></li>
<li>在对构件操作时不允许直接操作构件中的数据，数据真正被封装了。而对象的操作通过公共接口部分，这样数据是可能被访问操作的</li>
<li>对象对软件复用是通过继承实现的，构件对软件复用不仅可以通过继承还可以通过组装时的引用来实现</li>
<li>因此，构件不是对象，只是与对象类似</li>
</ul>
</li>
<li><p>在软件生产中有三种级别的重用：</p>
<ul>
<li><strong>内部重用</strong>，即在同一应用中能公共使用的抽象块</li>
<li><strong>代码重用</strong>，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用</li>
<li><strong>应用框架的重用</strong>，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性</li>
</ul>
</li>
<li><p>框架开发</p>
<ul>
<li>框架的最大好处就是重用。面向对象系统获得的最大的复用方式就是框架，一个大的应用系统往往可能由多层互相协作的框架组成</li>
<li>由于框架能重用代码，因此从一已有构件库中建立应用变得非常容易，因为构件都采用框架统一定义的接口，从而使构件间的通信简单</li>
</ul>
</li>
<li><p>框架解决的问题</p>
<ul>
<li>框架要解决的最重要的一个问题是技术整合的问题</li>
<li>软件企业的研发将集中在应用的设计上，而不是具体的技术实现，技术实现是应用的底层支撑，它不应该直接对应用产生影响</li>
<li>举例：<ul>
<li>一个做视频流应用的软件企业，他为电广行业提供整体的解决方案。他的优势在于将各种各样的视频硬件、服务器、和管理结合起来，因此他扮演的是一个集成商的角色。因此他的核心价值在于使用软件技术将不同的硬件整合起来，并在硬件的整合层面上提供一个统一的管理平台。所以他的精力应该放在解决两个问题<ul>
<li>如何找到一种方法，将不同的硬件整合起来，注意，这里的整合并不是技术整合，而是一种思路上的整合 </li>
<li>如何描述这个管理系统的规范。你需要描述各种管理活动，以及管理中所涉及的不同实体。因为管理系统是针对硬件的管理，所以它是构架在硬件整合平台之上的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据模型-Data-Model"><a href="#数据模型-Data-Model" class="headerlink" title="数据模型(Data Model)"></a>数据模型(Data Model)</h2><ul>
<li><p>数据模型（Data Model）是数据特征的抽象，它从抽象层次上描述了系统的静态特征、动态行为和约束条件，<strong>为数据库系统的信息表示与操作提供一个抽象的框架</strong>。数据模型所描述的内容有三部分，分别是数据结构、数据操作和数据约束</p>
</li>
<li><p>模型可更形象、直观地揭示事物的本质特征，使人们对事物有一个更加全面、深入的认识，从而可以帮助人们更好地解决问题。利用模型对事物进行描述是人们在认识和改造世界过程中广泛采用的一种方法。计算机不能直接处理现实世界中的客观事物，而数据库系统正是使用计算机技术对客观事物进行管理，因此就需要对客观事物进行抽象、模拟，以建立适合于数据库系统进行管理的数据模型。数据模型是对现实世界数据特征的模拟和抽象</p>
</li>
<li><p>数据模型是数据库设计中用来对现实世界进行抽象的工具，是数据库中用于提供信息表示和操作手段的形式构架。数据模型是数据库系统的核心和基础</p>
</li>
<li><p>数据模型所描述的内容包括三个部分：数据结构、数据操作、数据约束</p>
<ul>
<li><strong>数据结构</strong>：数据模型中的数据结构主要描述数据的类型、内容、性质以及数据间的联系等。数据结构是数据模型的基础，数据操作和约束都建立在数据结构上。不同的数据结构具有不同的操作和约束</li>
<li><strong>数据操作</strong>：数据模型中数据操作主要描述在相应的数据结构上的操作类型和操作方式</li>
<li><strong>数据约束</strong>：数据模型中的数据约束主要描述数据结构内数据间的语法、词义联系、它们之间的制约和依存关系，以及数据动态变化的规则，以保证数据的正确、有效和相容</li>
</ul>
</li>
</ul>
<h2 id="如何分析和解决一个任务：思维方式"><a href="#如何分析和解决一个任务：思维方式" class="headerlink" title="如何分析和解决一个任务：思维方式"></a>如何分析和解决一个任务：思维方式</h2><ol>
<li>先从整体上有一个总体思路，比如各个模块之间如何通信、依赖等，然后从一个点开始，照着调用路径分析下去，不要看一个类中的每个方法，而是只看用到的方法。</li>
<li>把所想要完成的目标分步实现，如果思路不清晰，不知道如何去做，可以模拟现实中的步骤。<ol>
<li>要把想实现的东西转换成代码，不要想着最终结果好难，不知道怎么做。</li>
<li>先分步，一步一步完成，然后分别去想每一步是怎么实现的。第一次写完之后肯定是缺陷的，仔细反复调试，慢慢修改优化，不要看着目标就被吓到。</li>
</ol>
</li>
<li>函数最主要的作用就是将一个大型程序分解成多个易于管理的小部分，这一过程称为分解（decomposition）。而你所需做的应是将一个高层次问题细分为一系列低层次的函数，每一个函数有其自己独立的功能。然而，找到问题正确的细分方法有很大的挑战，需要不断练习、思考和尝试。编程是一门艺术，好的问题分解策略主要来源于实际经验。</li>
<li>然而，作为一种通用的规则，问题的分解过程一般从程序的主程序开始。此时，我们将整个程序视为一个整体，并尝试从中分析并抓取出其主要部分。一旦程序的最主要部分被识别出来，就可以将它们定义为一些相互独立的函数。由于某些函数可能本身依然复杂，因此通常需要将他们再分解为更小的部分。我们可以不断重复这一分解过程直到每个问题足够简单明了以便于解决。上述分解过程称为<strong>自顶向下的程序设计（top-down design）</strong>或<strong>逐步求精的方法（ste[wose refinement）</strong></li>
</ol>
<h2 id="深入理解计算机操作系统"><a href="#深入理解计算机操作系统" class="headerlink" title="深入理解计算机操作系统"></a>深入理解计算机操作系统</h2><p>过程是软件中一种很重要的抽象</p>
<ul>
<li>它提供了一种封装代码的方式,用一组指定的参数和一个可选的返回值实现了某种功能.然后,可以再程序中不同的地方调用这个函数,设计良好的软件用过程作为抽象机制,隐藏某个行为的具体实现,同时又提供清晰简洁的接口定义,说明要计算的是哪些值,过程会对程序状态产生什么样的影响.</li>
<li>不同编程语言中,过程的形式多样:函数(function),方法(method),子例程(subroutine),处理函数(handle)等等</li>
</ul>
<p>数据对齐</p>
<ul>
<li>许多计算机系统对基本数据类型的合法地址做出了一些限制,要求某种类型对象的地址必须是某个值K(通常是2,4或8)的倍数,这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计</li>
<li>强制对齐:<ul>
<li>对于大多数x86-64指令来说,保持数据对其能够提高效率,但是它不会影响程序的行为</li>
<li>另一方面,如果数据没有对齐,某些型号的Intel和AMD处理器对于有些实现多媒体操作的SSE指令,就无法正确执行.</li>
</ul>
</li>
</ul>
<p>理解指针</p>
<ul>
<li><p>指针以一种统一方式,对不同数据结构中的元素产生引用</p>
</li>
<li><p>每个指针都对应一个类型,这个类型表明该指针指向的是哪一类对象</p>
<ul>
<li><code>int* ip</code>表示变量ip是一个指向int类型对象的指针,<code>char** cpp</code>表示cpp指针指向的对象自身就是一个指向char类型对象的指针</li>
<li>通常,如果对象类型为<code>T</code>,那么指针的类型为<code>T*</code>;特殊的, <code>void *</code>类型代表通用指针.比如说,malloc函数返回一个通用指针,然后通过显式强制类型转换或者赋值操作那样的隐式强制类型转换,将它转换成一个有类型的指针.</li>
<li>指针类型不是机器代码中的一部分,它们是C语言提供的一种抽象,帮助程序员避免寻址错误</li>
<li>每个指针都有一个值,这个值是某个指定类型的对象的地址.特殊的NULL(0)值表示该指针没有指向任何地方</li>
<li>指针用<code>&amp;</code>运算符创建.这个运算符可以应用到任何<code>lvalue</code>类的C表达式上,<code>lvalue</code>表示可以出现在赋值语句左边的表达式</li>
<li><code>*</code>操作符用于间接引用指针,其结果是一个值,它的类型与该指针的类型一致,<strong>间接引用</strong>是用内存引用来实现的,要么是存储到一个指定的地址,要么是从指定的地址读取</li>
<li>数组与指针紧密联系.一个数组的名字可以像一个指针变量一样引用(但是不能修改).数组引用(例如<code>a[3]</code>)与指针运算和间接引用(例如<code>*(a + 3)</code>)有一样的效果.数组引用和指针运算都需要用对象大小对偏移量进行伸缩</li>
<li>将指针从一种类型强制转换成另一种类型,只改变它的类型,而不改变它的值.强制类型转换的一个效果是改变指针运算的伸缩</li>
<li>指针也可以指向函数.这提供了一个很强大的存储和向代码传递引用的功能,这些引用可以被程序的某个其他部分调用</li>
</ul>
</li>
<li><p>内存越界引用和缓冲区溢出</p>
<ol>
<li>模型相关的,b站视频</li>
<li>多看项目(github),多练</li>
<li>大厂的代码,main中变量的声明(amlogic, nvidia)</li>
<li>shell 不必花费太多精力,推荐:python,php(现在不要去学,单点击穿,现在主要学习C++)</li>
</ol>
</li>
</ul>
<h2 id="如何阅读大型项目的代码？"><a href="#如何阅读大型项目的代码？" class="headerlink" title="如何阅读大型项目的代码？"></a>如何阅读大型项目的代码？</h2><ul>
<li>目的性：读代码的时候如果有目的性是最好的。</li>
<li>时间：总体来讲，阅读大型项目的代码需要时间。</li>
<li>方法论：抽象地说，阅读代码有两种方向，自底向上和自顶向下。<ul>
<li>自底向上，从具体的文件到子模块，从子模块到功能集，再到整个项目，强调的是从具体实现出发总结出一般抽象。</li>
<li>自顶向下，从项目的顶层设计到责任分发，从责任分发到功能分发，再到具体的实现代码，强调的是从抽象设计出发落实到具体实现。</li>
<li>两种方法是两个不同的视角。实践中经常需要结合两种方向随时切换地采用，当对大方向了解不足的时候自顶向下的看，当对实现细节不够明确的时候自底向上的看</li>
</ul>
</li>
</ul>
<h2 id="上下文-context"><a href="#上下文-context" class="headerlink" title="上下文 context"></a>上下文 context</h2><ul>
<li><p>维基百科</p>
<ul>
<li>在计算机科学中，任务(task)的上下文(context)是一个任务所必不可少的一组数据（该任务可以是进程，线程）。</li>
<li>这些数据允许任务中断，在这之后仍可在同一个地方继续执行。上下文的这一概念在中断的任务的场景下具有重大意义。其中，任务在被中断之后，处理器保存上下文并提供中断处理(interrupt service routine)。因此，上下文越小，延迟越小。</li>
<li>上下文的数据可能存放于处理器寄存器，任务所利用的内存，某些操作系统管理的任务所使用的控制寄存器(control registers)</li>
</ul>
</li>
<li><p>通俗的理解，上下文，也就是执行任务所需要的相关信息。</p>
</li>
<li><p>这个任务可以是一段代码，一个线程，一个进程，一个函数。当这个“任务”相关的信息需要保存下来时，就可以使用<code>context</code>来记录。</p>
</li>
</ul>
<h2 id="关于业务对象（Business-Object）本质的思考"><a href="#关于业务对象（Business-Object）本质的思考" class="headerlink" title="关于业务对象（Business Object）本质的思考"></a>关于业务对象（Business Object）本质的思考</h2><ul>
<li><p>对于采用OO(<code>Object Oriented</code>)思想，并具有N层架构的计算机程序而言，业务对象（<code>Business Object</code>）一般位于业务逻辑层（也叫领域层[1]），作为领域模型元素的一部分，描述了来自于业务域中的一个人、事、物或概念[2]，主要用来解决商业逻辑（即业务操作）问题，是为实现当前软件（或系统）的某一（或某些）特定功能而服务的。因此，它仅仅是从当前业务域的角度，对现实世界的一次抽象。</p>
</li>
<li><p>业务对象、业务实体、实体、领域对象在某种程度上是可以互换的术语[此处仅仅说是“某种程度上”，目的在于分析BO三要素的实质，针对于不同的理论，这几个名词确实存在差别]</p>
</li>
<li><p>对象三要素</p>
<ul>
<li>标识（identity），是唯一区别其他对象的标志；</li>
<li>状态（state），描述对象所蕴含的信息；</li>
<li>行为（behavior），对象所持有的、描述对象如何被使用的方法</li>
</ul>
</li>
</ul>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li><p>相对于字段、变量、属性等词，用“状态”一词来描述对象的“性格特点”最为合适。字段、变量、属性等，无非是描述对象状态的不同表现手法</p>
</li>
<li><p>就目前个人对BO状态的理解而言，BO的状态信息有两类：固有信息和动态信息。</p>
<ul>
<li>固有信息，是对象从诞生时与生俱来的信息（就像一个新生命的诞生一样，出生年月日、肤色、性别等信息是生来就有的）；</li>
<li>动态信息，即随着BO的成长，它会走入某一个人生场景中，扮演了某一个角色，从而在这个场景中被赋予了一些额外的信息，如：小明是个学生（从入学时，学生的基本信息被赋予），某天他去市图书馆借阅图书，此时他在借书这个场景中扮演了借书者这个角色，从而具有了借阅证、借阅信息等动态信息。</li>
</ul>
</li>
<li><p><strong>固有信息</strong></p>
<ul>
<li>业务对象在被构建（初始化）后，应达到一个相对比较稳定，且具有一定业务含义的状态，即业务对象的属性应已进行了相应的初始化设置，这样的构建才算合理、完整</li>
<li>与人类世界类似，人在出生时，就已经构造好了婴儿的鼻子、眼睛、手等内容，虽然此时他还没有衣服、母语、身份证等信息，但他在出生时，是一个相对较稳定且有意义的个体，就可以完成婴儿的核心操作，如：哭、呼吸、挥手等。</li>
<li>提前构造好该构造好的信息（注意：不是所有的信息都要一股脑的全构造好）是保证BO不被滥用的第一步</li>
</ul>
</li>
<li><p>动态信息</p>
<ul>
<li>进入某一场景，扮演某一角色（我更喜欢用“戴上帽子”这个说法），将拥有额外的动态属性。同“固有属性”的构建，某一业务对象走入特定的场景，扮演了另一角色时，也应该将这些动态属性予以设置</li>
<li><strong>对象应尽量在构建自身的过程中完成自身状态的设置</strong>。</li>
</ul>
</li>
</ul>
<h3 id="属性封装"><a href="#属性封装" class="headerlink" title="属性封装"></a>属性封装</h3><ul>
<li><p>在OO的世界里，封装的概念是最简单的，但却是最关键且最难以把握的</p>
</li>
<li><p>信息不封装（或封装不完整）带来的副作用</p>
<ul>
<li>内聚，难。业务对象的信息过多的暴露出去，容易滋生强盗逻辑，想捏回去形成一团，难！信息全部都暴露给外界，调用者还需要你BO干嘛？原因很简单：我能够伸手拿到你的任何信息，想实现什么就实现什么，可以为所欲为。如果你还有胆量暴露一些更改BO属性的权限，那我岂不是想怎么改就怎么改</li>
<li>解耦，难。一个成语叫“覆水难收”，放出去的信息将被调用者肆意使用，而且呈现出快速蔓延的趋势，一张复杂的<strong>耦合网</strong>必然产生。等回头开始重构解耦时，发现堆积如山的代码、耦合似网的结构，已经让你无从下手。动一下，就引起全身阵痛</li>
<li>常见的做法<ul>
<li>刨一小块，改改变量名、方法名，移一些代码，用接口再包装一下（隔离嘛），循环的修改，最终发现进展依然是非常缓慢，几乎还没触及到业务核心；</li>
<li>先用方法（1）试试，一阵子后，MD，烦死了，直接推倒重新搞。这些做法还需要考虑一个问题：放出去的接口和信息已被调用者大量使用，怎么办？</li>
</ul>
</li>
</ul>
</li>
<li><p>针对上述的苦痛，推荐下面的做法：</p>
<ul>
<li>在对象构建时，把能设置的状态信息尽可能的予以赋值，提前封装；</li>
<li>尽可能的不要公布内部信息。能够<code>private</code>的，尽可能的私有。除非迫不得已，尽量不要将<code>setter()</code> 放出，仅使其<code>read only</code>。</li>
</ul>
</li>
</ul>
<h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><ul>
<li><p>业务行为才是软件真正所关注的问题，对象的行为方式是对象价值的重要体现，也是区别于其他对象的重要标志。</p>
</li>
<li><p><strong>因此，我们说“BO因职责而存在！”</strong></p>
</li>
<li><p>贫血VS充血</p>
<ul>
<li>贫血对象<ul>
<li>由不具有任何行为的业务对象形成的领域模型，称为“贫血模型”[2]。对只有属性的getter&#x2F;setter方法，不具有业务行为的BO，可认为是“贫血对象”。</li>
<li>丧失业务逻辑行为的贫血对象，和Value Oject类似，扮演了Data Container的角色，而在业务域中的逻辑操作方面将失去能力（或被遗弃、边缘化）</li>
</ul>
</li>
<li>充血对象</li>
<li>按大师的说法，与BO直接相关的行为职责将划归到BO中，使其在领域模型中扮演重要的角色</li>
</ul>
</li>
<li><p>但是二者不能绝对的说谁好、谁不好，应该一分为二的去看，它们各自具有其特点，应用在不同的场景中。特别地，对于那些需求难以完全吃透、明确，或许用贫血模型较充血模型要更好把控局势。</p>
</li>
<li><p><strong>用户需求——业务——领域</strong>是一个对知识掌握程度递增的过程，领域模型的建立应基于对客观业务域的透彻掌握，不能偏左，也不可以偏右（不就是博弈么？没有最优秀的东西，只存在考虑诸多因素下的较为合适的东西）</p>
</li>
<li><p>business core</p>
<ul>
<li>它应该是最精炼、纯粹、简单、直接、轻量级的业务核心。</li>
<li>因此，不属于核心业务逻辑范畴的职责和行为（如：持久化操作），尽量抛出去交给该处理它们的对象去处理。</li>
</ul>
</li>
<li><p>上帝类（God class）</p>
<ul>
<li>可以认为它就是一个充血充得快爆掉的对象</li>
<li>它几乎可以干所有涉及到它的工作，从而形成代码有几百行乃至上千行的牛X类</li>
<li>有了这么一个牛X类，其他类不就成了浮云和鸡肋了么？这样可能引发很多问题<ul>
<li>理解难。几千行的代码，没有几个人有耐心阅读，几乎没人能够完全理解其表达的业务含义。</li>
<li>修改难。没有很好的理解，如何修改？如何重构？</li>
<li>扩展难。丢了它玩不转，不丢它又引来一堆麻烦，对于一个几千行的实现类来说（除非大多都是public static 的方法），吃资源不说，接口隔离、应对扩展方面也是比较吃力的。</li>
</ul>
</li>
</ul>
</li>
<li><p>谁拥有数据，谁持有行为</p>
<ul>
<li>BO行为的本质是对BO自身状态的改变，以实现业务目标，并且这种状态的更改可能还需要其他协作者的参与（关联关系）。</li>
<li>因此，我们可以说“<strong>谁拥有数据，谁就持有更改这些数据（状态）的行为</strong>”</li>
<li>现实中，跟BO有关系的行为可能较多，全部纳入到BO中，会造成BO的臃肿和污染，违背SRP（职责单一）<ul>
<li>可重用度高或是对象固有、与BO状态密切关联的方法放在BO中</li>
<li>可重用度低或者不是对象所固有（而依赖于特定场景）、与BO状态没有密切联系的方法放在BO管理者或服务层</li>
</ul>
</li>
</ul>
</li>
<li><p>方法属于客户</p>
<ul>
<li>BO就是一个黑盒子，其中包含了逻辑和数据，而对象的使用者不知道里面有什么数据，也不知道实际的运行逻辑。使用者所能做的就是与对象进行交互，以完成当前的业务目标。因此，对象的行为是为客户而定</li>
<li>行为（方法、职责）是BO存在的根本，而行为就是为了交互，为供调用者所使用。</li>
<li>调用者会根据自己的需要，向它认为应该由谁提供行为的BO发出操作申请，一切都是以“客户（调用者）”为中心而服务的</li>
</ul>
</li>
</ul>
<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><ul>
<li><p>程序 &#x3D; 算法 + 模型 + 数据结构</p>
</li>
<li><p>传统的程序只是算法和数据结构的组合，但是在AI迅猛发展的今天，在程序里几乎都有个“模型”</p>
</li>
<li><p>模型，一般是指机器学习或深度学习训练出来的<code>Model</code>，里面既有逻辑又有数据，所以它既不是单纯的算法，也不是单纯的数据结构。</p>
</li>
<li><p>软件工程师 &#x3D; 程序员 + 软件工程知识</p>
</li>
<li><p>PM(Program Manager) &#x3D; 项目管理 + 产品管理，直译为程序经理，实际上是项目管理和产品管理的二合一角色</p>
</li>
<li><p>团队 &#x3D; PM + 软件工程师 + Designer</p>
<ul>
<li>Designer， 直译就是设计师，负责用户界面和交互的设计</li>
<li>通常情况下，PM和软件工程师是长期合作的，而Designer有自己的独立组织，与团队是临时合作</li>
</ul>
</li>
<li><p>软件工程 &#x3D; 团队 + 过程定义 + 执行</p>
</li>
<li><p>软件 &#x3D; 程序 + 软件工程</p>
</li>
<li><p>软件公司 &#x3D; 软件产品 + 商业模式</p>
</li>
</ul>
<h3 id="商业模式的三个概念：产品，-项目，-服务"><a href="#商业模式的三个概念：产品，-项目，-服务" class="headerlink" title="商业模式的三个概念：产品， 项目， 服务"></a>商业模式的三个概念：产品， 项目， 服务</h3><ul>
<li><p>产品，其特点由公司决定要做什么，给客户提供什么，具有长期规划，不断迭代</p>
</li>
<li><p>项目，包括两类：</p>
<ul>
<li>一种是狭义的，在销售给客户产品后，再同时开发&#x2F;提供一些定制软件，那么会有配套的开发人员进行售后服务</li>
<li>另一种是广义的，其宿主是服务或产品，完成其一个小功能</li>
</ul>
</li>
<li><p>服务，以云端服务为主，具有战略意义，这种服务的后台通常有超级复杂的架构体系支撑，在性能，可用性，可靠性上下足了功夫，高并发大容量</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Unit_testing_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Unit_testing_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Unit_testing_单元测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。至于“单元”的大小或范围，并没有一个明确的标准，“单元”可以是一个函数、方法、类、功能模块或者子系统。</li>
<li>单元测试通常和白盒测试联系到一起，如果单从概念上来讲两者是有区别的，不过我们通常所说的“单元测试”和“白盒测试”都认为是和代码有关系的，所以在某些语境下也通常认为这两者是同一个东西。还有一种理解方式，单元测试和白盒测试就是对开发人员所编写的代码进行测试</li>
</ul>
<h2 id="单元测试谁来做？"><a href="#单元测试谁来做？" class="headerlink" title="单元测试谁来做？"></a>单元测试谁来做？</h2><ul>
<li>单元测试一般是有开发人员或测试人员来做。谁来做并没有一个绝对的标准，要根据公司的实际情况来决定。接下来我们分析一下开发人员或测试人员做单元测试的优缺点：</li>
<li>开发人员做单元测试：<ul>
<li>优点：开发人员对代码最熟悉，而且开发人员编程技能相对比较强，所以开发人员自己写单元测试效率上和覆盖率上都比较高</li>
<li>缺点：开发人员平时写业务代码就要花费很多时间，有时候确实没有时间写单元测试；而且大部分开发人员没有太好的测试思想，单元测试可能只是写个最简单的用例就完了；自己写的代码自己测，往往都是不靠谱！</li>
</ul>
</li>
<li>测试人员做单元测试：<ul>
<li>优点：测试人员有比较系统的测试思想，可以更好地保证用例的覆盖。而且通过写单测测试能更好地了解具体代码结构、流程，对于后续的业务测试也非常有利。</li>
<li>缺点：测试人员的编程技能相对比较弱，如果不同编程是无法开展单元测试的。并且测试人员对代码没有开发人员熟悉，效率会比较低。</li>
</ul>
</li>
</ul>
<h2 id="单元测试怎么做？"><a href="#单元测试怎么做？" class="headerlink" title="单元测试怎么做？"></a>单元测试怎么做？</h2><ul>
<li><p>单元测试的实现方式包括：人工静态检查、动态执行跟踪</p>
<ul>
<li>人工静态检查：就是通常所说的“代码走读”，主要是保证代码逻辑的正确性</li>
<li>动态执行跟踪：就是把程序代码运行起来，检查实际的运行结果和预期结果是否一致</li>
</ul>
</li>
<li><p>人工静态检查包含的主要内容：</p>
<ul>
<li>检查算法的逻辑正确性</li>
<li>模块接口的正确性检查</li>
<li>输入参数有没有作正确性检查</li>
<li>调用其他方法接口的正确性</li>
<li>异常错误处理</li>
<li>保证表达式、SQL语句的正确性</li>
<li>检查常量或全局变量使用的正确性</li>
<li>程序风格的一致性、规范性</li>
<li>检查代码注释是否完整</li>
</ul>
</li>
<li><p>动态执行跟踪</p>
<ul>
<li>动态执行跟踪需要编写测试脚本调用业务代码进行测试，为了更好的管理维护测试脚本，一般会采用单元测试框架来管理，不同的语言有不同的单元测试框架：<ul>
<li>Java：JUnit、TestNG</li>
<li>Python：UintTest、pyTest</li>
<li>C++: Catch,googletest</li>
</ul>
</li>
</ul>
</li>
<li><p>单元测试的一个重要的衡量标准就是代码覆盖率，尽量做到代码的全覆盖。常见单元测试覆盖标准：</p>
<ul>
<li>语句覆盖</li>
<li>分支覆盖</li>
<li>条件覆盖</li>
<li>分支-条件覆盖</li>
<li>条件组合覆盖</li>
<li>路径覆盖</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Vim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Vim/" class="post-title-link" itemprop="url">Vim</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>vim相关的笔记</li>
</ul>
<h2 id="linux-vim-全局替换指定字符"><a href="#linux-vim-全局替换指定字符" class="headerlink" title="linux vim 全局替换指定字符"></a>linux vim 全局替换指定字符</h2><p>在 Vim 中进行全局替换指定字符的操作可以使用 <code>:s</code> 命令。下面是一个简单的例子：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/old_pattern/new_pattern/g</span><br></pre></td></tr></table></figure>

<p>在这个命令中，<code>%</code> 表示对整个文件进行操作，<code>s/old_pattern/new_pattern/g</code> 表示将文本中所有的 <code>old_pattern</code> 替换为 <code>new_pattern</code>。如果你希望进行大小写敏感的替换，可以在 <code>g</code> 后面加上 <code>i</code> 选项：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/old_pattern/new_pattern/gi</span><br></pre></td></tr></table></figure>

<p>如果你想确认每一次替换，可以使用 <code>c</code> 选项：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/old_pattern/new_pattern/gic</span><br></pre></td></tr></table></figure>

<p>在上述命令中，<code>:s</code> 是替换命令的缩写，<code>old_pattern</code> 是要被替换的字符或模式，<code>new_pattern</code> 是替换后的字符或模式。<code>g</code> 表示全局替换，<code>i</code> 表示大小写不敏感，<code>c</code> 表示逐一确认。</p>
<p>请根据你的需求调整命令中的参数。在 Vim 中进行全局替换时，确保你理解替换的范围和影响，以免不小心替换了不应该修改的内容。</p>
<h2 id="vim-详解"><a href="#vim-详解" class="headerlink" title="vim 详解"></a>vim 详解</h2><p>Vim 是一个文本编辑器，是在 Vi 编辑器基础上发展而来的。它可以在终端中运行，并且具有很多强大的编辑功能。Vim 的强大功能主要体现在以下几个方面：</p>
<ol>
<li><p><strong>模式</strong>：Vim 有多种模式，其中最常见的是命令模式和编辑模式。在命令模式下，可以执行各种命令，比如移动光标、复制粘贴等；在编辑模式下可以编辑文本。</p>
</li>
<li><p><strong>多窗口编辑</strong>：Vim 支持在一个屏幕内同时编辑多个文件，通过分割窗口（<code>:sp</code>、<code>:vsp</code>）或分割标签页（<code>:tabnew</code>）来实现。</p>
</li>
<li><p><strong>自定义</strong>：可以通过配置文件（<code>.vimrc</code>）来自定义 Vim 的行为，如自定义快捷键、设置颜色主题、安装插件等。</p>
</li>
<li><p><strong>插件支持</strong>：Vim 支持各种插件，可以增强编辑功能，如代码高亮、自动补全、文件树等。</p>
</li>
<li><p><strong>强大的编辑功能</strong>：Vim 支持各种快捷键操作，可以高效地进行文本编辑、搜索、替换等操作。</p>
</li>
</ol>
<p>Vim 的基本使用方法包括以下几点：</p>
<ul>
<li><p><strong>命令模式</strong>：按下 <code>Esc</code> 键进入命令模式。</p>
<ul>
<li><code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>：左、下、上、右移动光标。</li>
<li><code>i</code>、<code>a</code>、<code>o</code>：在当前光标位置插入文本。</li>
<li><code>x</code>：删除光标所在处的字符。</li>
<li><code>dd</code>：删除当前行。</li>
<li><code>yy</code>：复制当前行。</li>
<li><code>p</code>：粘贴复制或删除的文本。</li>
<li><code>/</code>：进行文本搜索。</li>
<li><code>:w</code>：保存文件。</li>
<li><code>:q</code>：退出 Vim。</li>
</ul>
</li>
<li><p><strong>编辑模式</strong>：在命令模式下按下 <code>i</code>、<code>a</code> 或 <code>o</code> 键切换到编辑模式，进行文本编辑。</p>
</li>
<li><p><strong>插件管理</strong>：使用插件管理器（如 Vim-Plug）来安装和管理 Vim 插件。</p>
</li>
<li><p><strong>配置文件</strong>：修改 <code>~/.vimrc</code> 文件来定制化 Vim 编辑器的行为。</p>
</li>
</ul>
<p>以上只是 Vim 的基础用法，Vim 有非常丰富的功能和命令，可以根据个人需求和习惯进行更多的定制和配置。如果您想要深入学习 Vim，可以参考 Vim 的官方文档或者在线教程。</p>
<h2 id="ubuntu-vim-plug-安装C-插件"><a href="#ubuntu-vim-plug-安装C-插件" class="headerlink" title="ubuntu vim-plug 安装C++插件"></a>ubuntu vim-plug 安装C++插件</h2><p>当您想要在 Ubuntu 上使用 Vim-Plug 安装 C++ 开发相关的插件时，您可以遵循以下步骤：</p>
<h3 id="步骤-1：安装-Vim-Plug"><a href="#步骤-1：安装-Vim-Plug" class="headerlink" title="步骤 1：安装 Vim-Plug"></a>步骤 1：安装 Vim-Plug</h3><ol>
<li>打开终端（Ctrl + Alt + T）。</li>
<li>使用 curl 命令下载 Vim-Plug：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure></li>
<li>确保插件目录存在。如果不存在，执行以下命令创建目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.vim/plugged</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="步骤-2：编辑-vimrc-文件"><a href="#步骤-2：编辑-vimrc-文件" class="headerlink" title="步骤 2：编辑 .vimrc 文件"></a>步骤 2：编辑 .vimrc 文件</h3><ol>
<li>使用 Vim 打开 <code>.vimrc</code> 配置文件，如果该文件不存在则创建它：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc</span><br></pre></td></tr></table></figure></li>
<li>在 <code>.vimrc</code> 文件中添加以下内容，这会告诉 Vim 使用 Vim-Plug 管理插件：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot; Vim-Plug 设置</span></span><br><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 安装 C++ 相关插件</span></span><br><span class="line">Plug <span class="string">&#x27;octol/vim-cpp-enhanced-highlight&#x27;</span></span><br><span class="line"><span class="comment">&quot; 其他插件...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure>
在 <code>call plug#begin()</code> 和 <code>call plug#end()</code> 之间的区域是用于列出要安装的插件的地方。</li>
</ol>
<h3 id="步骤-3：安装插件"><a href="#步骤-3：安装插件" class="headerlink" title="步骤 3：安装插件"></a>步骤 3：安装插件</h3><ol>
<li>保存并关闭 <code>.vimrc</code> 文件（在 Vim 中执行 <code>:wq</code>）。</li>
<li>重新打开 Vim。</li>
<li>在 Vim 中输入以下命令安装列出的插件：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:PlugInstall</span><br></pre></td></tr></table></figure></li>
<li>按下 Enter 键开始安装所列的插件。</li>
</ol>
<h3 id="步骤-4：配置插件"><a href="#步骤-4：配置插件" class="headerlink" title="步骤 4：配置插件"></a>步骤 4：配置插件</h3><p>安装完成后，根据您安装的插件类型和需求，可能需要进行一些额外的配置步骤。这些步骤通常可以在每个插件的 GitHub 页面或文档中找到。</p>
<p>这些步骤将帮助您在 Ubuntu 上使用 Vim-Plug 安装 C++ 相关的插件，以便在 Vim 编辑器中更轻松地开发和编辑 C++ 代码。</p>
<h2 id="Ubuntu-vim-plug-C-代码补全插件"><a href="#Ubuntu-vim-plug-C-代码补全插件" class="headerlink" title="Ubuntu vim-plug C++代码补全插件"></a>Ubuntu vim-plug C++代码补全插件</h2><p>在 Ubuntu 上，有几个流行的 Vim 插件可以用于 C++ 代码补全，其中最知名的是 <strong>YouCompleteMe</strong> 和 <strong>coc.nvim</strong>。</p>
<h4 id="YouCompleteMe"><a href="#YouCompleteMe" class="headerlink" title="YouCompleteMe"></a>YouCompleteMe</h4><p>YouCompleteMe 是一个功能强大的 Vim 插件，提供了高效的代码补全功能，并支持多种编程语言，包括 C++。要安装 YouCompleteMe 插件，请按照以下步骤操作：</p>
<ol>
<li>首先，确保您已经按照上面提供的步骤安装了 Vim-Plug 插件管理器。</li>
<li>在您的 <code>.vimrc</code> 配置文件中添加 YouCompleteMe 插件：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot; Vim-Plug 设置</span></span><br><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 安装 YouCompleteMe 插件</span></span><br><span class="line">Plug <span class="string">&#x27;ycm-core/YouCompleteMe&#x27;</span>, &#123; <span class="string">&#x27;do&#x27;</span>: <span class="string">&#x27;./install.py&#x27;</span> &#125;</span><br><span class="line"><span class="comment">&quot; 其他插件...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure></li>
<li>保存并关闭 <code>.vimrc</code> 文件（在 Vim 中执行 <code>:wq</code>）。</li>
<li>重新打开 Vim。</li>
<li>在 Vim 中输入以下命令来安装 YouCompleteMe 插件：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:PlugInstall</span><br></pre></td></tr></table></figure></li>
<li>安装完成后，进入 <code>~/.vim/plugged/YouCompleteMe</code> 目录，并执行以下命令进行 YCM 插件的编译安装：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 install.py --clangd-completer</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="coc-nvim"><a href="#coc-nvim" class="headerlink" title="coc.nvim"></a>coc.nvim</h4><p>另一个流行的 Vim 插件是 coc.nvim，它是一个具有高级特性的插件，可提供 C++ 代码补全和 IntelliSense 功能。安装步骤如下：</p>
<ol>
<li>确保您已经按照上述步骤安装了 Vim-Plug 插件管理器。</li>
<li>在您的 <code>.vimrc</code> 配置文件中添加 coc.nvim 插件：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot; Vim-Plug 设置</span></span><br><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 安装 coc.nvim 插件</span></span><br><span class="line">Plug <span class="string">&#x27;neoclide/coc.nvim&#x27;</span>, &#123;<span class="string">&#x27;branch&#x27;</span>: <span class="string">&#x27;release&#x27;</span>&#125;</span><br><span class="line"><span class="comment">&quot; 其他插件...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure></li>
<li>保存并关闭 <code>.vimrc</code> 文件（在 Vim 中执行 <code>:wq</code>）。</li>
<li>重新打开 Vim。</li>
<li>在 Vim 中输入以下命令安装 coc.nvim 插件：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:PlugInstall</span><br></pre></td></tr></table></figure></li>
<li>安装完成后，在 Vim 中使用 <code>:CocInstall coc-clangd</code> 安装 C++ 相关的语言服务器。</li>
</ol>
<p>安装完成后，您可以根据需要配置这些插件以满足您的需求，并享受更加便捷的 C++ 开发体验。</p>
<h2 id="vim-删除指定插件"><a href="#vim-删除指定插件" class="headerlink" title="vim 删除指定插件"></a>vim 删除指定插件</h2><p>要从 Vim 中删除插件，你需要编辑你的 <code>.vimrc</code> 文件，找到包含你想删除插件的行，并将其删除。然后保存文件并退出 Vim。</p>
<p>假设你正在使用 Vim-Plug 来管理你的插件，你可以按照以下步骤来删除一个插件：</p>
<ol>
<li><p>打开终端并输入以下命令以编辑你的 <code>.vimrc</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到你想要删除的插件的配置行。它们通常具有 <code>Plug</code> 字样。比如：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">&#x27;some-plugin&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将你想要删除的插件的配置行从 <code>.vimrc</code> 文件中删除。</p>
</li>
<li><p>保存并关闭文件。你可以按下 <code>Esc</code> 键，然后输入 <code>:wq</code> 并按回车键保存并退出。</p>
</li>
<li><p>重新打开 Vim，然后执行 <code>:PlugClean</code> 命令，它会删除未在 <code>.vimrc</code> 文件中列出的任何插件。</p>
</li>
</ol>
<p>这样就完成了删除插件的操作。请记住，这些步骤可能因你的插件管理器或特定的插件而有所不同，因此你需要根据你自己的情况进行调整。</p>
<h2 id="Vim-plug"><a href="#Vim-plug" class="headerlink" title="Vim-plug"></a>Vim-plug</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>运行命令:<ul>
<li>curl -fLo ~&#x2F;.vim&#x2F;autoload&#x2F;plug.vim –create-dirs <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</a></li>
</ul>
</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul>
<li>安装插件<ul>
<li>要安装插件，你必须如下所示首先在 Vim 配置文件中声明它们。一般 Vim 的配置文件是  ~&#x2F;.vimrc</li>
<li>请记住，当你在配置文件中声明插件时，列表应该以 call plug#begin(PLUGIN_DIRECTORY) 开始，并以 plug#end() 结束。</li>
<li>例如，我们安装 “lightline.vim” 插件。为此，请在 ~&#x2F;.vimrc 的顶部添加以下行。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line">Plug <span class="string">&#x27;itchyny/lightline.vim&#x27;</span></span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="检查状态"><a href="#检查状态" class="headerlink" title="检查状态"></a>检查状态</h3><ul>
<li>使用以下命令检查状态：<ul>
<li>:PlugStatus</li>
</ul>
</li>
</ul>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><ul>
<li>使用以下命令安装：<ul>
<li>:PlugInstall</li>
</ul>
</li>
</ul>
<h3 id="更新插件"><a href="#更新插件" class="headerlink" title="更新插件"></a>更新插件</h3><ul>
<li>要更新插件，请运行：<ul>
<li>:PlugUpdate</li>
</ul>
</li>
<li>更新插件后，按下 d 查看更改。或者，你可以之后输入 :PlugDiff。</li>
</ul>
<h3 id="审查插件"><a href="#审查插件" class="headerlink" title="审查插件"></a>审查插件</h3><ul>
<li>有时，更新的插件可能有新的 bug 或无法正常工作。要解决这个问题，你可以简单地回滚有问题的插件。输入 :PlugDiff 命令，然后按回车键查看上次 :PlugUpdate的更改，并在每个段落上按 X 将每个插件回滚到更新前的前一个状态。</li>
</ul>
<h3 id="删除插件"><a href="#删除插件" class="headerlink" title="删除插件"></a>删除插件</h3><ul>
<li>删除一个插件删除或注释掉你以前在你的 vim 配置文件中添加的 plug 命令。然后，运行 :source ~&#x2F;.vimrc 或重启 Vim 编辑器。最后，运行以下命令卸载插件：<ul>
<li>:PlugClean</li>
</ul>
</li>
<li>该命令将删除 vim 配置文件中所有未声明的插件。</li>
</ul>
<h2 id="升级-Vim-plug"><a href="#升级-Vim-plug" class="headerlink" title="升级 Vim-plug"></a>升级 Vim-plug</h2><ul>
<li>要升级vim-plug本身，请输入：<ul>
<li>:PlugUpgrade</li>
</ul>
</li>
</ul>
<h2 id="NERDTree"><a href="#NERDTree" class="headerlink" title="NERDTree"></a>NERDTree</h2><ul>
<li><p>这个插件是几乎所有研发人员都会安装的一个插件——目录树，可以支持在不退出vim的编辑器的前提下，在文件中快速切换，同时能让开发人员快速掌握项目目录结构，是提升开发效率必不可少的工具</p>
</li>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin()</span><br><span class="line">Plug <span class="string">&#x27;preservim/nerdtree&#x27;</span></span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置</p>
<ul>
<li>NERDTree默认无须配置即可直接使用，当然更改部分映射后，可以使得目录树试用起来更加得心应手。最常见的配置在~&#x2F;.vimrc添加如下命令，即可使用Ctrl+n快速开启目录树。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li>目录树的使用主要通过在vim的command模式下键入如下命令，即可达到相应的效果。</li>
<li>?: 快速帮助文档</li>
<li>o: 打开一个目录或者打开文件，创建的是 buffer，也可以用来打开书签</li>
<li>go: 打开一个文件，但是光标仍然留在 NERDTree，创建的是 buffer</li>
<li>t: 打开一个文件，创建的是Tab，对书签同样生效</li>
<li>T: 打开一个文件，但是光标仍然留在 NERDTree，创建的是 Tab，对书签同样生效</li>
<li>i: 水平分割创建文件的窗口，创建的是 buffer</li>
<li>gi: 水平分割创建文件的窗口，但是光标仍然留在 NERDTree</li>
<li>s: 垂直分割创建文件的窗口，创建的是 buffer</li>
<li>gs: 和 gi，go 类似</li>
<li>x: 收起当前打开的目录</li>
<li>X: 收起所有打开的目录</li>
<li>e: 以文件管理的方式打开选中的目录</li>
<li>D: 删除书签</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Wps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Wps/" class="post-title-link" itemprop="url">Wps</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>WPS 使用笔记</li>
</ul>
<h2 id="wps-word一键删除空行"><a href="#wps-word一键删除空行" class="headerlink" title="wps word一键删除空行"></a>wps word一键删除空行</h2><ul>
<li>第一步：选择WPS-Word文档中的“开始”菜单栏，选择旗下的“文字工具”。 继续点击“删除”，此时会跳出四个选项，如下图所示，Sara点击的是“删除空段”。 </li>
<li>第二步：点击“删除空段”后，所有的Word文档空白行就一秒全部消失啦。</li>
</ul>
<h2 id="wps-分页"><a href="#wps-分页" class="headerlink" title="wps 分页"></a>wps 分页</h2><p>WPS Office（金山办公）是一款办公软件套件，包括文字处理、演示文稿和电子表格等功能。在WPS文字（WPS Writer）中，你可以设置分页选项来控制文档的分页方式。以下是如何在WPS文字中进行分页设置的一般步骤：</p>
<ol>
<li><p><strong>打开文档：</strong> 打开你想要进行分页设置的文档。</p>
</li>
<li><p><strong>选择页面布局：</strong> 在菜单栏中选择“页面布局”选项，通常位于顶部导航栏的位置。</p>
</li>
<li><p><strong>设置页面大小：</strong> 在页面布局选项中，你可以选择预定义的页面大小，如A4、信纸等，或者自定义页面大小。选择适合你需要的页面大小。</p>
</li>
<li><p><strong>设置页面边距：</strong> 同样在页面布局选项中，你可以设置页面的上、下、左、右边距。这些边距会影响页面内容的位置和间距。</p>
</li>
<li><p><strong>设置分页方式：</strong> 在页面布局选项中，你可以设置文档的分页方式。有两种常见的分页方式：</p>
<ul>
<li><strong>分页符：</strong> 你可以手动插入分页符来控制文档的分页。在需要分页的位置插入分页符，文档将在此处分页。</li>
<li><strong>自动分页：</strong> 选择此选项后，WPS会根据页面大小、字体大小等因素自动进行分页，无需手动插入分页符。</li>
</ul>
</li>
<li><p><strong>插入分节符（可选）：</strong> 如果你的文档需要不同的分页设置，比如首页不显示页眉页脚，你可以在“插入”菜单中选择“分节符”来实现这些设置。</p>
</li>
<li><p><strong>预览分页效果：</strong> 在设置完分页选项后，你可以通过查看打印预览来检查分页效果。这可以帮助你确认文档在打印或显示时的分页情况。</p>
</li>
<li><p><strong>保存文档：</strong> 确认分页设置无误后，记得保存文档以保存你的分页设置。</p>
</li>
</ol>
<p>请注意，WPS Office的界面可能在不同的版本中略有不同，但一般来说，上述步骤适用于大多数版本的WPS文字。如果你使用的是特定版本，可以参考软件自带的帮助文档或在线资源，以获取更详细和准确的分页设置指导。</p>
<h2 id="wps-怎么插入分页符"><a href="#wps-怎么插入分页符" class="headerlink" title="wps 怎么插入分页符"></a>wps 怎么插入分页符</h2><p>在WPS Office文字处理软件（WPS Writer）中，插入分页符是很简单的。分页符会将文档内容分为两部分，使得在分页符之前的内容位于前一页，分页符之后的内容位于下一页。以下是在WPS Writer中插入分页符的步骤：</p>
<ol>
<li><p>打开你要编辑的文档，确保你在编辑模式下。</p>
</li>
<li><p>将光标移动到你想要插入分页符的位置。这通常是你希望在这里开始新的一页的地方。</p>
</li>
<li><p>在菜单栏中，点击”插入”选项。</p>
</li>
<li><p>在弹出的下拉菜单中，选择”分页符”选项。这将在你的光标所在位置插入一个分页符。</p>
</li>
<li><p>保存你的文档以保存分页符的插入。</p>
</li>
</ol>
<p>现在，你已经成功地在WPS Writer中插入了一个分页符。在此分页符之前的内容将出现在前一页，分页符之后的内容将出现在下一页。</p>
<p>请注意，分页符只会影响打印或显示时的页面分割，而不会在编辑模式下直接显示分页符图标。如果你希望在编辑模式下看到分页符的位置，可以在WPS Writer的“查看”选项中启用“非打印字符”或类似的选项，这样你就可以看到分页符的位置。</p>
<p>以上是在WPS Writer中插入分页符的一般步骤，实际界面可能会根据不同的WPS Office版本略有不同。如果你使用的是特定版本，可以查阅该版本的帮助文档或在线资源以获取更详细和准确的插入分页符的指导。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-WiFi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-WiFi/" class="post-title-link" itemprop="url">WiFi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>WPA是WiFi Protected Access的缩写，中文含义为“WiFi网络安全存取”。WPA是一种基于标准的可互操作的WLAN安全性增强解决方案，可大大增强现有以及未来无线局域网络的数据保护和访问控制水平</p>
</li>
<li><p>经过编译后 的 wpa_supplicant源程序可以看到两个主要的可执行工具：wpa_supplicant 和 wpa_cli。wpa_supplicant是核心程序，它和wpa_cli的关系就是服务和客户端的关系：后台运行wpa_supplicant，使用 wpa_cli来搜索、设置、和连接网络</p>
</li>
<li><p>wpa_supplicant.conf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ctrl_interface=/sbin/wpa_supplicant       //wpa_supplicant命令执行文件目录</span><br><span class="line">ap_scan=1</span><br><span class="line"> </span><br><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;GH_wx_05&quot;   //WiFi 名字</span><br><span class="line">psk=&quot;Grand@honor666666!@#&quot;  //WiFi 密码</span><br><span class="line">key_mgmt=WPA-PSK  //加密方式</span><br><span class="line"># key_mgmt=NONE  //不加密</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启wifi服务：<code>wpa_supplicant -B -i wlan0 -c /data/cfg/wpa_supplicant.conf</code></p>
</li>
<li><p>重新读取上述配置：<code>wpa_cli reconfigure</code></p>
</li>
<li><p>并重新连接:<code>wpa_cli reconnect</code></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-Yaml/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-Yaml/" class="post-title-link" itemprop="url">Yaml</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>YAML 基础知识</li>
</ul>
<h2 id="yaml是什么"><a href="#yaml是什么" class="headerlink" title="yaml是什么"></a>yaml是什么</h2><p>YAML（YAML Ain’t Markup Language的递归缩写）是一种人类可读的数据序列化格式。它常用于配置文件和数据交换格式，特别适用于各种编程语言之间的数据传递。</p>
<p>YAML的设计目标之一是提供一种易读且简洁的表示方法，以区别于其他常见的数据交换格式，如JSON（JavaScript Object Notation）和XML（eXtensible Markup Language）。相对于其他格式，YAML更注重人类可读性，其语法结构主要基于缩进和简洁的标记。</p>
<p>以下是一个简单的YAML示例，表示一个包含一些信息的简单结构：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">John</span> <span class="string">Doe</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">city:</span> <span class="string">New</span> <span class="string">York</span></span><br><span class="line"><span class="attr">is_student:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，每一行都是一个键值对，用冒号分隔。缩进表示层次结构，例如<code>name</code>、<code>age</code>和<code>city</code>是顶级键，而<code>is_student</code>是其中一个嵌套的键。与其他格式相比，YAML更加人类可读，因为它不需要额外的符号和标记。</p>
<p>YAML广泛用于各种场景，包括配置文件、CI&#x2F;CD流水线配置、数据序列化等。</p>
<h2 id="YAML-详解"><a href="#YAML-详解" class="headerlink" title="YAML 详解"></a>YAML 详解</h2><p>YAML（YAML Ain’t Markup Language）是一种用于表示数据序列化的格式，其设计目标是提供一个易读且简洁的文本表达方式。下面是一些关于YAML的详细解释：</p>
<ol>
<li><p><strong>基本语法</strong>：</p>
<ul>
<li><strong>键值对</strong>：使用冒号（<code>:</code>）将键和值分隔。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span> <span class="string">value</span></span><br></pre></td></tr></table></figure></li>
<li><strong>列表</strong>：使用连字符（<code>-</code>）表示列表项，列表项可以包含简单的值或者嵌套的键值对。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">item1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">item2</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">value</span></span><br></pre></td></tr></table></figure></li>
<li><strong>嵌套结构</strong>：使用缩进表示层次结构。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">parent:</span></span><br><span class="line">  <span class="attr">child1:</span> <span class="string">value1</span></span><br><span class="line">  <span class="attr">child2:</span> <span class="string">value2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数据类型</strong>：</p>
<ul>
<li><strong>字符串</strong>：可以使用单引号或双引号括起来，也可以不使用引号。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">string1:</span> <span class="string">&#x27;single quoted&#x27;</span></span><br><span class="line"><span class="attr">string2:</span> <span class="string">&quot;double quoted&quot;</span></span><br><span class="line"><span class="attr">string3:</span> <span class="string">unquoted</span></span><br></pre></td></tr></table></figure></li>
<li><strong>整数和浮点数</strong>：直接表示数字。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">integer:</span> <span class="number">42</span></span><br><span class="line"><span class="attr">float:</span> <span class="number">3.14</span></span><br></pre></td></tr></table></figure></li>
<li><strong>布尔值</strong>：可以使用 <code>true</code> 或 <code>false</code> 表示。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">boolean:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>注释</strong>：以井号（<code>#</code>）开头表示注释。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a comment</span></span><br><span class="line"><span class="attr">key:</span> <span class="string">value</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多行文本</strong>：使用竖线符号（<code>|</code>）表示多行文本块，保留换行符。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">multiline:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  This is a</span></span><br><span class="line"><span class="string">  multiline</span></span><br><span class="line"><span class="string">  text block.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>折叠多行文本</strong>：使用右尖括号（<code>&gt;</code>）表示折叠多行文本块，将换行符替换为空格。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">folded:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  This is a folded</span></span><br><span class="line"><span class="string">  multiline</span></span><br><span class="line"><span class="string">  text block.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用</strong>：可以使用 <code>&amp;</code> 创建锚点，使用 <code>*</code> 引用锚点。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">parent:</span> <span class="meta">&amp;anchor</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">value</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reference:</span> <span class="meta">*anchor</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特殊值</strong>：</p>
<ul>
<li><code>null</code> 表示空值。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>更多示例</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">John</span> <span class="string">Doe</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">is_student:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">colors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">red</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">green</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">blue</span></span><br><span class="line"></span><br><span class="line"><span class="attr">settings:</span></span><br><span class="line">  <span class="attr">enable_feature:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>总体而言，YAML是一种灵活且易读的数据格式，广泛用于配置文件、数据交换和其他应用场景。在使用时，要注意缩进和空格的正确使用，因为它们在YAML中起着重要的语法作用。</p>
<h2 id="yaml-基本语法-详解"><a href="#yaml-基本语法-详解" class="headerlink" title="yaml 基本语法 详解"></a>yaml 基本语法 详解</h2><p>YAML（YAML Ain’t Markup Language）的基本语法非常简洁和直观，以下是对其基本语法要点的详解：</p>
<ol>
<li><p><strong>键值对</strong>：</p>
<ul>
<li>使用冒号（<code>:</code>）将键和值分隔。</li>
<li>键值对的格式为 <code>key: value</code>。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">John</span> <span class="string">Doe</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列表</strong>：</p>
<ul>
<li>使用连字符（<code>-</code>）表示列表项。</li>
<li>列表项可以包含简单的值或者嵌套的键值对。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fruits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">orange</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>嵌套结构</strong>：</p>
<ul>
<li>使用缩进表示层次结构，通常使用空格进行缩进。</li>
<li>缩进的空格数可以不同，但同一层次必须保持一致。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">John</span> <span class="string">Doe</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">city:</span> <span class="string">New</span> <span class="string">York</span></span><br><span class="line">    <span class="attr">zip:</span> <span class="string">&#x27;10001&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串</strong>：</p>
<ul>
<li>字符串可以使用单引号或双引号括起来，也可以不使用引号。</li>
<li>使用引号可以避免一些特殊字符引起的歧义。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">single_quoted:</span> <span class="string">&#x27;This is a single-quoted string.&#x27;</span></span><br><span class="line"><span class="attr">double_quoted:</span> <span class="string">&quot;This is a double-quoted string.&quot;</span></span><br><span class="line"><span class="attr">unquoted:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">an</span> <span class="string">unquoted</span> <span class="string">string.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>整数和浮点数</strong>：</p>
<ul>
<li>直接表示数字，可以是整数或浮点数。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">integer:</span> <span class="number">42</span></span><br><span class="line"><span class="attr">float:</span> <span class="number">3.14</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>布尔值</strong>：</p>
<ul>
<li>使用 <code>true</code> 或 <code>false</code> 表示布尔值。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">is_student:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注释</strong>：</p>
<ul>
<li>使用井号（<code>#</code>）表示注释，注释可以单独一行或在行尾添加。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a comment</span></span><br><span class="line"><span class="attr">key:</span> <span class="string">value</span>  <span class="comment"># Comment at the end of a line</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多行文本</strong>：</p>
<ul>
<li>使用竖线符号（<code>|</code>）表示多行文本块，保留换行符。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">multiline:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  This is a</span></span><br><span class="line"><span class="string">  multiline</span></span><br><span class="line"><span class="string">  text block.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>折叠多行文本</strong>：</p>
<ul>
<li>使用右尖括号（<code>&gt;</code>）表示折叠多行文本块，将换行符替换为空格。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">folded:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  This is a folded</span></span><br><span class="line"><span class="string">  multiline</span></span><br><span class="line"><span class="string">  text block.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用</strong>：</p>
<ul>
<li>可以使用 <code>&amp;</code> 创建锚点，使用 <code>*</code> 引用锚点。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">parent:</span> <span class="meta">&amp;anchor</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">value</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reference:</span> <span class="meta">*anchor</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特殊值</strong>：</p>
<ul>
<li><code>null</code> 表示空值。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些基本语法要点构成了YAML的基础，使其适用于多种场景，特别是作为配置文件或数据交换格式。在使用YAML时，注意缩进和空格的正确使用是非常重要的，因为它们直接影响文档的结构。</p>
<h2 id="CPP中常用的YAML解析工具"><a href="#CPP中常用的YAML解析工具" class="headerlink" title="CPP中常用的YAML解析工具"></a>CPP中常用的YAML解析工具</h2><p>除了YAML-cpp之外，还有一些其他常用的C++ YAML解析工具，这些工具提供了不同的功能和特性，可以根据项目需求选择合适的工具。以下是一些常见的C++ YAML解析工具：</p>
<ol>
<li><p><strong>YAML-cpp</strong>：YAML-cpp是一个流行的C++库，用于解析和生成YAML数据。它提供了简单易用的API，支持YAML 1.2规范，并且可以在多种平台上使用。上面提供的示例代码演示了如何使用YAML-cpp。</p>
</li>
<li><p><strong>LibYAML</strong>：LibYAML是一个C库，但也有C++绑定可供使用。它是一个高性能的YAML解析器和生成器，支持YAML 1.2规范。虽然它在C++中需要使用C绑定，但它在处理大型YAML文件时性能出色。</p>
</li>
<li><p><strong>YAML-cpp-Parser</strong>：这是一个建立在YAML-cpp之上的库，用于更方便地解析YAML数据。它提供了更简洁的API，可以帮助简化解析过程。</p>
</li>
<li><p><strong>yaml-cpp03</strong>：这是YAML-cpp的一个旧版本，与C++03标准兼容。如果你的项目需要C++03支持，可以考虑使用此版本。</p>
</li>
<li><p><strong>yaml-cpp11</strong>：这是YAML-cpp的C++11版本，支持现代C++标准。它在C++11及更高版本中使用时更适用。</p>
</li>
<li><p>**YAML++**：YAML++是另一个C++ YAML解析库，它提供了类型安全的API和更高级的功能，如自定义类型序列化和反序列化。</p>
</li>
<li><p><strong>SimpleYAML</strong>：SimpleYAML是一个轻量级的C++库，用于处理YAML数据。它设计简单，易于学习和使用，适用于小型项目和快速原型开发。</p>
</li>
<li><p><strong>Boost.PropertyTree</strong>：虽然Boost.PropertyTree不是专门用于YAML的库，但它支持多种数据格式，包括JSON和INI，可以用于解析YAML文件。这个库是Boost C++库集合的一部分。</p>
</li>
</ol>
<p>根据项目的具体要求和C++标准的选择，你可以选择适合你需求的YAML解析工具。不同的工具在性能、易用性和功能方面可能有所不同，因此选择合适的工具非常重要。在使用任何库之前，建议查看其文档和示例以了解如何正确使用。</p>
<h2 id="yaml数组"><a href="#yaml数组" class="headerlink" title="yaml数组"></a>yaml数组</h2><p>在 YAML (YAML Ain’t Markup Language) 中，数组（或列表）是一种用于表示多个值的结构。YAML 支持两种方式来定义数组：一是使用连字符（<code>-</code>）作为前缀的列表，二是使用方括号（<code>[]</code>）包裹的逗号分隔值的方式。</p>
<h3 id="1-使用连字符的数组"><a href="#1-使用连字符的数组" class="headerlink" title="1. 使用连字符的数组"></a>1. 使用连字符的数组</h3><p>这种方式在 YAML 中是最常见的，适合定义多行的列表。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fruits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Apple</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Banana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Orange</span></span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fruits:</span> [<span class="string">Apple</span>, <span class="string">Banana</span>, <span class="string">Orange</span>]</span><br></pre></td></tr></table></figure>

<h3 id="2-使用方括号的数组"><a href="#2-使用方括号的数组" class="headerlink" title="2. 使用方括号的数组"></a>2. 使用方括号的数组</h3><p>这种方式适合单行定义数组。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fruits:</span> [<span class="string">Apple</span>, <span class="string">Banana</span>, <span class="string">Orange</span>]</span><br></pre></td></tr></table></figure>

<p>这两种方式的功能是等效的。使用哪一种主要取决于格式的需求和个人的习惯。</p>
<h2 id="YAML-数组中的每个元素是一个数组"><a href="#YAML-数组中的每个元素是一个数组" class="headerlink" title="YAML 数组中的每个元素是一个数组"></a>YAML 数组中的每个元素是一个数组</h2><p>在 YAML 中，如果数组的每个元素都是一个数组，可以通过多级缩进来表示。例如，使用 <code>-</code> 来表示数组的每一层，格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">matrix:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="bullet">-</span> <span class="number">1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="bullet">-</span> <span class="number">4</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">5</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">6</span></span><br><span class="line">  <span class="bullet">-</span> <span class="bullet">-</span> <span class="number">7</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">8</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>matrix</code> 是一个数组，其中的每个元素都是一个嵌套的数组。</li>
<li>每个嵌套的数组在 <code>matrix</code> 下又包含多个元素。</li>
</ul>
<p>你也可以将这些元素放在同一行来简化结构：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">matrix:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>这样也能表示一个二维数组，其中 <code>matrix</code> 是一个包含三个数组的数组，每个内部数组包含 3 个数字。这种格式特别适合表示矩阵或表格数据结构。</p>
<h2 id="YAML-嵌套数组"><a href="#YAML-嵌套数组" class="headerlink" title="YAML 嵌套数组"></a>YAML 嵌套数组</h2><p>在 YAML 中，嵌套数组可以通过缩进的方式来实现。具体语法如下：</p>
<ol>
<li><strong>普通数组</strong>：使用短横线 <code>-</code> 表示数组元素。</li>
<li><strong>嵌套数组</strong>：在数组的某个元素下，再次使用短横线并进行适当缩进，来定义嵌套数组的层次结构。</li>
</ol>
<p>以下是一个 YAML 嵌套数组的示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fruits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">berries:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">strawberry</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blueberry</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">raspberry</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">citrus:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">orange</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lemon</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lime</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>fruits</code> 是一个数组，包含 4 个元素。</li>
<li>第三个元素 <code>berries</code> 和第四个元素 <code>citrus</code> 是对象，这些对象的值是一个数组。</li>
</ul>
<p>也可以用更深层次的嵌套数组：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">library:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Fiction</span></span><br><span class="line">    <span class="attr">books:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">title:</span> <span class="string">&quot;The Great Gatsby&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">title:</span> <span class="string">&quot;To Kill a Mockingbird&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Science</span></span><br><span class="line">    <span class="attr">books:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">title:</span> <span class="string">&quot;A Brief History of Time&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">title:</span> <span class="string">&quot;The Selfish Gene&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里 <code>library</code> 是一个包含多个对象的数组，每个对象包含一个 <code>books</code> 数组。</p>
<p>这种 YAML 结构适用于表示复杂的树状数据。只要按照正确的缩进格式来写，就能顺利定义出嵌套数组。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-cnpy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-cnpy/" class="post-title-link" itemprop="url">cnpy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>CNPY第三方工具相关笔记</li>
</ul>
<h2 id="cnpy-是什么"><a href="#cnpy-是什么" class="headerlink" title="cnpy 是什么"></a>cnpy 是什么</h2><p><code>cnpy</code> 是一个用于读取和写入.npy（NumPy数组文件）的C++库。这个库使C++程序能够方便地处理NumPy数组数据，而无需依赖Python。NumPy是一个Python库，用于处理多维数组和科学计算，但有时需要在C++应用程序中使用NumPy数组数据。<code>cnpy</code>库提供了在C++中处理.npy文件的功能，包括读取和写入NumPy数组。</p>
<p>以下是<code>cnpy</code>库的一些主要特点和功能：</p>
<ol>
<li><p><strong>读取.npy文件</strong>：<code>cnpy</code>库允许C++程序读取.npy文件中的NumPy数组数据，并将其转换为C++数据结构，以便在C++中进行进一步处理和分析。</p>
</li>
<li><p><strong>写入.npy文件</strong>：使用<code>cnpy</code>库，C++程序可以创建新的.npy文件并将NumPy数组数据写入其中，以便与其他Python或C++应用程序共享数据。</p>
</li>
<li><p><strong>支持多种NumPy数据类型</strong>：<code>cnpy</code>库支持NumPy中的多种数据类型，包括整数、浮点数、复数、布尔值等，以便适应各种科学计算需求。</p>
</li>
<li><p><strong>跨平台支持</strong>：<code>cnpy</code>库是跨平台的，可在多种操作系统上使用，包括Windows、Linux和macOS。</p>
</li>
<li><p><strong>灵活性</strong>：该库允许用户指定数据的存储顺序（如C风格和Fortran风格存储），以满足不同数据来源的需求。</p>
</li>
</ol>
<p><code>cnpy</code>库的使用使C++开发人员能够与Python中使用NumPy的同事轻松共享和处理数据，从而更容易实现跨语言数据交互。这对于需要在C++应用程序中处理科学数据或与Python中的数据分析工具进行集成的项目非常有用。库的源代码和文档通常可以在GitHub上找到。</p>
<h2 id="cnpy-示例-详解-C"><a href="#cnpy-示例-详解-C" class="headerlink" title="cnpy 示例 详解 C++"></a>cnpy 示例 详解 C++</h2><p><code>cnpy</code> 是一个用于处理.npy文件的C++库，允许你读取和写入NumPy数组数据。下面是一个简单的示例，展示如何在C++中使用<code>cnpy</code>库读取.npy文件、修改数据，然后将数据写回.npy文件的过程。</p>
<p>首先，确保你已经安装了<code>cnpy</code>库并设置好了开发环境。你可以在项目的GitHub页面上找到库的源代码和详细文档，然后进行编译和安装。</p>
<p>假设有一个名为<code>example.npy</code>的.npy文件，其中包含一个NumPy数组。以下是示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cnpy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取.npy文件</span></span><br><span class="line">    cnpy::NpyArray arr = cnpy::<span class="built_in">npy_load</span>(<span class="string">&quot;example.npy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取NumPy数组的数据指针和形状</span></span><br><span class="line">    <span class="type">float</span>* data = arr.<span class="built_in">data</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line">    std::vector&lt;<span class="type">size_t</span>&gt; shape = arr.shape;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数据（这里将所有元素乘以2）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; shape[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        data[i] *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的.npy文件来保存修改后的数据</span></span><br><span class="line">    cnpy::<span class="built_in">npy_save</span>(<span class="string">&quot;modified_example.npy&quot;</span>, data, shape, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data has been modified and saved as &#x27;modified_example.npy&#x27;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例代码做了以下几件事：</p>
<ol>
<li><p>使用<code>cnpy::npy_load</code>函数读取名为<code>example.npy</code>的.npy文件，将数据加载到<code>cnpy::NpyArray</code>对象中。</p>
</li>
<li><p>从<code>NpyArray</code>对象中获取数据指针和数组的形状。</p>
</li>
<li><p>修改数据。在这个示例中，我们将所有元素乘以2，但你可以根据需要进行任何修改。</p>
</li>
<li><p>使用<code>cnpy::npy_save</code>函数将修改后的数据保存为一个新的.npy文件，名为<code>modified_example.npy</code>。请注意，我们传递了参数 “w”，表示写入模式。</p>
</li>
</ol>
<p>这样，你就能在C++中使用<code>cnpy</code>库读取、处理和保存NumPy数组数据了。这对于处理科学数据、跨语言数据交互以及与Python中的数据分析工具集成非常有用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Tools/2024-05-22-XShell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Tools/2024-05-22-XShell/" class="post-title-link" itemprop="url">XShell</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>文件传输协议：文件传输是数据交换的主要形式，在进行文件传输时，为使文件能被正确识别和传送，需要在两台计算机之间建立统一的传输协议。这个协议包括了文件的识别，传送的起止时间，错误的判断与纠正等内容</p>
</li>
<li><p>在SecureCRT下的传输协议有ASCII， XMODEM， YMODEM， ZMODEM</p>
<ul>
<li>ASCII：这是最快的传输协议，但只能传送文本文件</li>
<li>XMODEM： 这种古老的传输协议速度较慢，但是由于使用了CRC错误侦测方法，传输的准确里可高达99.6%。XMODEM是一种在串口通信中广泛使用的异步文件传输协议。分为XMODE和1k-XMODEM协议两种，前者使用128字节的数据块，后者使用1024字节即1k字节的数据块</li>
<li>YMODEM：这个个是XMODEM的改良版，使用了1024位区段传送，速度比XMODEM要快</li>
<li>ZMODEM：这个采用了串流式（streaming）传输方式，传输速度较快，而且还具有自动改变区段大小和断点续传，快速错误侦测等功能，这是目前最流行的文件传输协议。</li>
</ul>
</li>
<li><p>Windows下生成md5校验码: <code>certutil -hashfile filename MD5</code></p>
</li>
<li><p>Linux下生成md5校验码: <code>md5sum filename</code></p>
</li>
<li><p>xshell 传输文件</p>
<ul>
<li><code>sz filename</code></li>
</ul>
</li>
</ul>
<p>psmisc adduser libc6  libcurl4  libdevmapper1.02.1 libgcc1  libgl1 libopus0  libpng16-16 libqt5core5a libqt5gui5 libqt5opengl5  libqt5printsupport5  libqt5widgets5  libqt5x11extras5 libsdl1.2debian  libssl1.1 libstdc++6 libvpx5 libx11-6 libxcb1 libxcursor1 libxext6 libxml2 libxt6 zlib1g</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/17/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/19/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
