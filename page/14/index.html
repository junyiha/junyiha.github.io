<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/14/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Git/2024-05-22-git_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Git/2024-05-22-git_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">git_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Git的理论基础知识</li>
</ul>
<h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><ol>
<li>克隆Git资源作为工作目录</li>
<li>在克隆的资源上添加或者修改文件</li>
<li>如果其他人修改了,你可以更新资源</li>
<li>在提交前查看修改</li>
<li>提交修改</li>
<li>在修改完成后,如果发现错误,可以撤回提交并再次修改并提交</li>
</ol>
<h2 id="基本概念-工作区-暂存区和版本库"><a href="#基本概念-工作区-暂存区和版本库" class="headerlink" title="基本概念:工作区,暂存区和版本库"></a>基本概念:工作区,暂存区和版本库</h2><ul>
<li>工作区:就是在电脑里能够看到的目录</li>
<li>暂存区:英文叫stage或index,一般放在.git目录下的index文件中,所以把暂存区有时也叫做索引(index)</li>
<li>版本库:工作区有一个隐藏目录.git,这个不算工作区,而是git的版本库</li>
</ul>
<ol>
<li>当对工作区修改(或新增)的文件执行 <code>git add</code> 命令时,暂存区的目录树被更新,同时工作区修改(或新增)的文件内容被写入到对象库中的一个新的对象中,而该对象的ID被记录在暂存区的文件索引中</li>
<li>当执行提交操作时 <code>git commit</code> 时,暂存区的目录树写到版本库(对象库)中,master分支会做相应的更新,即<strong>master只想的目录树就是提交时暂存区的目录树.</strong></li>
</ol>
<h2 id="Git官方手册"><a href="#Git官方手册" class="headerlink" title="Git官方手册"></a>Git官方手册</h2><h3 id="Git的三种状态-已提交-committed-已修改-modified-和已暂存-staged"><a href="#Git的三种状态-已提交-committed-已修改-modified-和已暂存-staged" class="headerlink" title="Git的三种状态:已提交(committed), 已修改(modified)和已暂存(staged)"></a>Git的三种状态:已提交(committed), 已修改(modified)和已暂存(staged)</h3><ul>
<li>已修改:表示修改了文件,但还没有保存到数据库中</li>
<li>已暂存:表示对一个已修改文件的当前版本做了标记,使之包含在下次提交的快照中</li>
<li>已提交:表示数据已经安全地保存在本地数据库中</li>
</ul>
<h3 id="这会让Git项目拥有三个三阶段-工作区-暂存区和Git目录"><a href="#这会让Git项目拥有三个三阶段-工作区-暂存区和Git目录" class="headerlink" title="这会让Git项目拥有三个三阶段:工作区, 暂存区和Git目录"></a>这会让Git项目拥有三个三阶段:工作区, 暂存区和Git目录</h3><ul>
<li>工作区:是对项目的某个版本独立提取出来的内容,这些从Git仓库的压缩数据中提取出来的文件,放在磁盘上进行使用或修改</li>
<li>暂存区:是一个文件,保存了下次将要提交的文件列表信息,一般在Git仓库目录中.按照Git的术语叫做”索引”,不过一般说法还是叫”暂存区”</li>
<li>Git仓库目录:是Git用来保存项目的元数据和对象数据库的地方.这是Git中最重要的部分,<strong>从其他计算机克隆仓库时,复制的就是这里的数据.</strong></li>
</ul>
<h3 id="基本的Git工作流程"><a href="#基本的Git工作流程" class="headerlink" title="基本的Git工作流程"></a>基本的Git工作流程</h3><ol>
<li>在工作区中修改文件</li>
<li>将想要下次提交的更改 选择性地暂存,这样只会将更改的部分添加到暂存区</li>
<li>提交更新,找到暂存区的文件,将快照永久性存储到Git目录</li>
</ol>
<h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a><code>.gitignore</code> 文件</h2><ul>
<li>In the project, it does not need to save all of the files. And the <code>.gitignore</code> file is used to save the folders which do not need to save.</li>
<li>在工程中，并不是所有文件都需要保存到版本库中。在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，把要忽略的文件名填进去，Git就会自动忽略这些文件或目录</li>
<li>匹配规则<ul>
<li>空格不匹配任意文件，可作为分隔符，可用反斜杠转义</li>
<li>开头的文件标识注释，可以使用反斜杠进行转义</li>
<li><code>/</code> 结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件</li>
<li><code>/</code> 开始的模式匹配项目和目录</li>
<li><code>?</code> 通用匹配单个字符</li>
<li><code>*</code> 通用匹配零个或多个字符</li>
<li><code>[]</code> 通用匹配单个字符列表</li>
</ul>
</li>
</ul>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><ol>
<li>working directory:持有实际文件</li>
<li>Index:类似于一个缓冲区与,临时保存文件的改动</li>
<li>HEAD:指向最后一次提交的结果</li>
</ol>
<h2 id="添加与提交"><a href="#添加与提交" class="headerlink" title="添加与提交"></a>添加与提交</h2><ol>
<li>把文件添加到暂存区: <code>git add &lt;filename&gt;</code></li>
<li>提交改动信息: <code>git commit -m &quot;代码提交信息&quot;</code>. (至此,改动已经提交到了HEAD,但是还没有到远端仓库)</li>
<li>推送改动: <code>git push origin master(master 换成想要推送的分支)</code></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Docker/2024-05-22-docker_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Docker/2024-05-22-docker_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">docker_3_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>docker常用技巧</li>
</ul>
<h2 id="docker-启动容器并分离到后台"><a href="#docker-启动容器并分离到后台" class="headerlink" title="docker 启动容器并分离到后台"></a>docker 启动容器并分离到后台</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -<span class="built_in">id</span> -p 4000:4000 jekyll/ubuntu:v1 /bin/bash</span></span><br></pre></td></tr></table></figure>

<h2 id="docker-镜像存储位置"><a href="#docker-镜像存储位置" class="headerlink" title="docker 镜像存储位置"></a>docker 镜像存储位置</h2><ul>
<li><p>Docker 镜像存储位置取决于你在安装 Docker 时所选择的存储驱动程序。Docker 默认使用“overlay2”存储驱动程序，它会将镜像存储在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2 目录下。但是，如果你使用的是其他存储驱动程序，那么镜像存储位置可能会有所不同。</p>
</li>
<li><p>你可以通过以下命令查看 Docker 镜像存储位置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info | grep -i <span class="string">&#x27;docker root dir&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在输出结果中，你将看到存储路径的具体位置。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker Root Dir: /var/lib/docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你想将 Docker 镜像存储到不同的位置，可以通过以下步骤进行设置：</p>
</li>
<li><p>停止 Docker 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop docker</span><br></pre></td></tr></table></figure></li>
<li><p>移动 &#x2F;var&#x2F;lib&#x2F;docker 目录到新的位置，例如 &#x2F;new&#x2F;docker&#x2F;path：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /var/lib/docker /new/docker/path</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个指向新目录的符号链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /new/docker/path /var/lib/docker</span><br></pre></td></tr></table></figure></li>
<li><p>启动 Docker 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li><p>现在，Docker 镜像将被存储在新的位置 &#x2F;new&#x2F;docker&#x2F;path 中。请注意，这种更改可能会导致现有的 Docker 容器无法正常运行，因此请谨慎操作。</p>
</li>
</ul>
<h2 id="网络模式设置"><a href="#网络模式设置" class="headerlink" title="网络模式设置"></a>网络模式设置</h2><p>在 Docker 中，<code>-net=host</code> 是一种网络模式选项，用于指定容器的网络命名空间。当你使用该选项时，容器将与宿主机共享网络命名空间，这意味着容器将使用宿主机的网络栈，与宿主机具有相同的网络接口和IP地址。</p>
<p>具体来说，使用<code>-net=host</code>选项，容器内的网络配置与宿主机完全一致，容器可以直接访问宿主机上的网络接口和端口。这样的配置有一些优势和限制：</p>
<p>优势：</p>
<ol>
<li>简化网络配置：使用该选项，不需要再单独设置容器的网络配置，容器直接继承宿主机的网络配置。</li>
<li>容器与宿主机共享IP地址：可以让容器直接使用宿主机的IP地址，方便某些网络应用场景。</li>
</ol>
<p>限制：</p>
<ol>
<li>安全性：容器与宿主机共享网络命名空间，容器内的进程可以直接访问宿主机的网络，这可能会增加潜在的安全风险，因此需要格外小心。</li>
<li>端口冲突：由于容器与宿主机共享网络，如果宿主机上已经在使用的端口被容器尝试使用，可能会导致端口冲突。</li>
<li>主机网络的限制：由于容器使用宿主机网络栈，容器将受到宿主机网络设置和限制的影响。</li>
</ol>
<p>在大多数情况下，推荐使用默认的网络模式，Docker会为容器分配独立的网络命名空间，从而保持隔离和安全性。只有在特定的使用场景下，才应该考虑使用<code>-net=host</code>选项。</p>
<p>请注意，Docker在不同版本中可能会有一些变化，因此建议查阅最新的Docker文档以获得最准确的信息。</p>
<h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2><ul>
<li>使用命令：<code>tar cvf image.tar --exclude=/proc --exclude=/image.tar /</code>， 在容器里打包系统所需要的文件，<ul>
<li>记录以下：<code>tar cvf image.tar --exclude=/system --exclude=/sys --exclude=/proc --exclude=/image.tar /</code></li>
</ul>
</li>
<li><code>sudo docker cp containerID:/image.tar ./</code> , 将容器中打包的文件拷贝到主机中</li>
<li><code>cat image.tar | sudo docker import - image:v1</code>, 导入镜像</li>
</ul>
<h2 id="linux下重启-启动-关闭docker服务"><a href="#linux下重启-启动-关闭docker服务" class="headerlink" title="linux下重启,启动,关闭docker服务"></a>linux下重启,启动,关闭docker服务</h2><ul>
<li><code>sudo systemctl start docker</code> : 启动</li>
<li><code>sudo systemctl daemon-reload</code>: 守护进程重启</li>
<li><code>sudo systemctl restart docker</code> or <code>sudo service docker restart</code> : 重启docker服务</li>
<li><code>sudo service docker stop</code> or <code>sudo systemctl stop docker</code> : 关闭docker</li>
</ul>
<h2 id="以非root用户身份管理"><a href="#以非root用户身份管理" class="headerlink" title="以非root用户身份管理"></a>以非root用户身份管理</h2><ul>
<li>Docker守护程序绑定到Unix套接字而不是TCP端口，默认情况下，Unix套接字的用户有root，其它用户只能使用sudo来访问。 Docker守护程序始终以root用户身份运行</li>
<li>不想使用sudo，创建docker的Unix组，将用户添加到改组<ul>
<li><code>sudo groupadd docker</code></li>
<li><code>sudo usermod -aG docker $USER</code></li>
<li><code>newgrp docker</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="镜像的上传和拉取"><a href="#镜像的上传和拉取" class="headerlink" title="镜像的上传和拉取"></a>镜像的上传和拉取</h2><ul>
<li><p>登录docker </p>
<ul>
<li><code>docker login</code></li>
</ul>
</li>
<li><p>修改镜像命名</p>
<ul>
<li>修改镜像的repository，使之与Docker Hub账号匹配</li>
<li>Docker Hub为了区分不同用户的同名镜像，镜像的<code>registry</code>中要包含用户名，完整的格式为:<code>[username]/xxx:tag</code></li>
<li>Docker官方自己维护的镜像没有用户名</li>
</ul>
</li>
<li><p>镜像上传</p>
<ul>
<li>通过<code>docker push</code>将镜像上传到<code>Docker Hub</code></li>
</ul>
</li>
<li><p>镜像的拉取</p>
<ul>
<li>上传的是公共镜像仓库，任何人都可以下载使用</li>
</ul>
</li>
</ul>
<h2 id="根据这些md5目录名检查是哪个容器"><a href="#根据这些md5目录名检查是哪个容器" class="headerlink" title="根据这些md5目录名检查是哪个容器"></a>根据这些md5目录名检查是哪个容器</h2><ul>
<li><code>docker inspect xxx | grep merge</code></li>
</ul>
<h2 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h2><ul>
<li><code>docker logs &lt;container-id&gt;</code>，查看日志</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">user@computer:test-docker$ docker logs 172</span><br><span class="line">root@1722c360945f:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  src  srv  sys  tmp  usr  var</span><br><span class="line">root@1722c360945f:/# cd src</span><br><span class="line">root@1722c360945f:/src# ks</span><br><span class="line">bash: ks: command not found</span><br><span class="line">root@1722c360945f:/src# ls</span><br><span class="line">one.txt</span><br><span class="line">root@1722c360945f:/src# ls</span><br><span class="line">one.txt  two.txt</span><br><span class="line">root@1722c360945f:/src# cat two.txt</span><br><span class="line">root@1722c360945f:/src# ls</span><br><span class="line">two.txt</span><br><span class="line">root@1722c360945f:/src# ls</span><br><span class="line">two.txt</span><br><span class="line">root@1722c360945f:/src# pwd</span><br><span class="line">/src</span><br><span class="line">user@computer:test-docker$ </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><ul>
<li><code>docker run -it --mount type=bind,src=&quot;$(pwd)&quot;，target=/src ubuntu:18.04 bash</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Git/2024-05-22-git_2_%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Git/2024-05-22-git_2_%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">git_2_语法基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Git常见的语法知识</li>
</ul>
<h2 id="git-bundle-命令-详解"><a href="#git-bundle-命令-详解" class="headerlink" title="git bundle 命令 详解"></a>git bundle 命令 详解</h2><p><code>git bundle</code> 命令用于将 Git 仓库的所有对象（commit、tree、blob等）打包成一个二进制文件，这个文件可以在不连接到中央仓库的情况下传递给其他人，并且可以克隆该仓库。这在离线环境或网络较差的情况下非常有用。</p>
<p>以下是 <code>git bundle</code> 命令的基本语法和一些常见用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个包含所有分支的 bundle 文件</span></span><br><span class="line">git bundle create repo.bundle --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含指定分支的 bundle 文件</span></span><br><span class="line">git bundle create repo.bundle branch1 branch2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个指定范围的 bundle 文件（从某个 commit 到另一个 commit）</span></span><br><span class="line">git bundle create repo.bundle &lt;start-commit&gt;..&lt;end-commit&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 bundle 文件中提取对象到本地仓库</span></span><br><span class="line">git <span class="built_in">clone</span> repo.bundle new-repo</span><br></pre></td></tr></table></figure>

<p>这里是一些命令的详细解释：</p>
<ul>
<li><code>git bundle create</code>: 创建一个 bundle 文件。后面的参数是要包含的分支或 commit 的范围。</li>
<li><code>repo.bundle</code>: bundle 文件的名称。你可以自定义文件名。</li>
<li><code>--all</code>: 包含所有分支。</li>
<li><code>branch1 branch2</code>: 包含指定的分支。</li>
<li><code>&lt;start-commit&gt;..&lt;end-commit&gt;</code>: 包含指定范围内的 commit。</li>
</ul>
<p>一旦你创建了 bundle 文件，你可以将它传递给其他人，他们可以通过克隆该 bundle 文件来获取整个仓库的历史。例如，他们可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repo.bundle new-repo</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>git bundle</code> 不包含远程仓库的引用，因此在使用 bundle 文件进行克隆时，你将得到一个没有远程跟踪分支的本地仓库。如果需要获取远程跟踪分支，可以使用 <code>git fetch</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> new-repo</span><br><span class="line">git fetch origin refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure>

<p>这样，你就可以在新的本地仓库中获取与远程仓库相同的分支。</p>
<h2 id="git-config-详解"><a href="#git-config-详解" class="headerlink" title="git config 详解"></a>git config 详解</h2><p><code>git config</code> 是 Git 版本控制系统中用于配置和管理 Git 仓库的命令。通过 <code>git config</code> 命令，你可以设置和获取 Git 仓库的各种配置选项，包括全局配置和仓库级配置。</p>
<p><code>git config</code> 命令有三个不同的级别：全局、仓库和本地。这些级别决定了配置选项的作用范围。</p>
<p>以下是 <code>git config</code> 命令的一些常用选项和使用方法：</p>
<ol>
<li><p><strong>获取配置值</strong>：使用 <code>git config &lt;key&gt;</code> 命令获取特定配置选项的值。例如，要获取用户的姓名配置，可以使用 <code>git config user.name</code>。</p>
</li>
<li><p><strong>设置配置值</strong>：使用 <code>git config &lt;key&gt; &lt;value&gt;</code> 命令设置特定配置选项的值。例如，要设置用户的姓名配置，可以使用 <code>git config user.name &quot;Your Name&quot;</code>。</p>
</li>
<li><p><strong>全局配置</strong>：使用 <code>git config --global</code> 命令来设置全局配置选项。全局配置选项将应用于当前用户的所有 Git 仓库。例如，使用 <code>git config --global user.name &quot;Your Name&quot;</code> 来设置全局用户姓名。</p>
</li>
<li><p><strong>仓库配置</strong>：在 Git 仓库的根目录下，使用 <code>git config</code> 命令来设置仓库配置选项。这些配置选项将仅应用于当前仓库。例如，使用 <code>git config user.email &quot;your@example.com&quot;</code> 来设置仓库的用户邮箱。</p>
</li>
<li><p><strong>本地配置</strong>：对于某个特定的 Git 命令，你可以通过在命令后添加 <code>--local</code> 参数，将配置选项设置为本地级别。例如，使用 <code>git config --local core.ignorecase true</code> 来设置当前仓库的忽略文件大小写的配置。</p>
</li>
<li><p><strong>列出配置</strong>：使用 <code>git config --list</code> 命令列出当前仓库的所有配置选项及其对应的值。添加 <code>--global</code> 参数可以列出全局配置选项。</p>
</li>
<li><p><strong>编辑配置文件</strong>：使用 <code>git config --edit</code> 命令打开 Git 配置文件进行手动编辑。对于全局配置，会打开用户主目录下的 <code>.gitconfig</code> 文件，对于仓库配置，会打开仓库目录下的 <code>.git/config</code> 文件。</p>
</li>
</ol>
<p>这些是 <code>git config</code> 命令的一些常见用法和选项。通过适当配置 Git，你可以定制化和优化你的版本控制工作流程。</p>
<hr>
<h2 id="git-config-常用选项"><a href="#git-config-常用选项" class="headerlink" title="git config 常用选项"></a>git config 常用选项</h2><p>下面是一些常用的 <code>git config</code> 命令选项：</p>
<ol>
<li><p><strong>用户信息</strong>：</p>
<ul>
<li><code>user.name</code>：设置用户的姓名。</li>
<li><code>user.email</code>：设置用户的电子邮件地址。</li>
<li>例如：<code>git config --global user.name &quot;Your Name&quot;</code></li>
</ul>
</li>
<li><p><strong>文本编辑器</strong>：</p>
<ul>
<li><code>core.editor</code>：设置用于 Git 提交消息的文本编辑器。</li>
<li>例如：<code>git config --global core.editor &quot;vim&quot;</code></li>
</ul>
</li>
<li><p><strong>自动换行</strong>：</p>
<ul>
<li><code>core.autocrlf</code>：控制换行符的处理方式。<ul>
<li><code>true</code>：在提交时自动将换行符转换为 CRLF，检出时转换为 LF（适用于 Windows 系统）。</li>
<li><code>input</code>：在提交时将换行符转换为 LF，检出时不做转换（适用于 macOS 和 Linux 系统）。</li>
<li><code>false</code>：保持换行符不变。</li>
</ul>
</li>
<li>例如：<code>git config --global core.autocrlf true</code></li>
</ul>
</li>
<li><p><strong>忽略文件</strong>：</p>
<ul>
<li><code>core.excludesfile</code>：指定一个全局的忽略文件，用于列出不应受版本控制的文件和目录。</li>
<li>例如：<code>git config --global core.excludesfile ~/.gitignore_global</code></li>
</ul>
</li>
<li><p><strong>分支合并策略</strong>：</p>
<ul>
<li><code>merge.tool</code>：设置用于解决合并冲突的工具。</li>
<li>例如：<code>git config --global merge.tool kdiff3</code></li>
</ul>
</li>
<li><p><strong>查看提交历史</strong>：</p>
<ul>
<li><code>alias.log</code>：设置自定义的 <code>git log</code> 命令别名。</li>
<li>例如：<code>git config --global alias.log &quot;log --oneline --decorate&quot;</code></li>
</ul>
</li>
<li><p><strong>远程仓库</strong>：</p>
<ul>
<li><code>remote.origin.url</code>：设置远程仓库的 URL。</li>
<li><code>branch.&lt;branchname&gt;.remote</code>：设置分支与远程仓库的关联。</li>
<li>例如：<code>git config remote.origin.url &quot;https://github.com/username/repo.git&quot;</code></li>
</ul>
</li>
</ol>
<p>这些是一些常用的 <code>git config</code> 命令选项，你可以根据自己的需求进行配置。使用 <code>--global</code> 参数将选项设置为全局级别，省略该参数则为当前仓库级别的配置。</p>
<h2 id="git-tag-标签的使用"><a href="#git-tag-标签的使用" class="headerlink" title="git tag 标签的使用"></a>git tag 标签的使用</h2><h2 id="标签-tag-相关的常用命令"><a href="#标签-tag-相关的常用命令" class="headerlink" title="标签(tag)相关的常用命令"></a>标签(tag)相关的常用命令</h2><ul>
<li><code>git tag</code> 查看标签</li>
<li><code>git tag &lt;tag-name&gt;</code> 创建命名标签</li>
<li><code>git tag -a &lt;tag-name&gt; -m &lt;message&gt;</code> 添加一个注解标签</li>
<li><code>git tag &lt;tag-name&gt; &lt;commit-id&gt; -a -m &lt;message&gt;</code> 给过去提交记录创建标签</li>
<li><code>git push origin &lt;tag-name&gt;</code> 推送标签到远程仓库</li>
<li><code>git push origin --tags</code> 推送全部标签</li>
<li><code>git pull origin --tags</code> 远程拉取标签</li>
<li><code>git tag -d &lt;tag-name&gt;</code> 删除本地标签</li>
<li><code>git push origin :refs/tags/&lt;tag-name&gt;</code> 删除远程标签</li>
</ul>
<h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><ul>
<li><code>git remote</code>：用于管理远程仓库</li>
<li><code>git remote</code>：不带参数时可以查看远程仓库名称</li>
<li><code>git remote -v</code> : 可以查看远程仓库名称和网址</li>
<li><code>git remote add 仓库名 仓库地址</code> : 添加远程仓库，同时设置远程仓库的名字</li>
<li><code>git remote rm origin</code> : 删除名字为<code>origin</code>的远程仓库</li>
</ul>
<h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><ul>
<li><p><code>git branch</code> : 可以查看本地仓库的分支情况</p>
</li>
<li><p><code>git branch 分支名</code> : 创建分支</p>
</li>
<li><p><code>git checkout 分支名</code> : 切换到指定分支</p>
<ul>
<li>两个命令可以合成一个命令：<code>git checkout -b 分支名</code> ，相当于创建分支后切换到新建分支</li>
</ul>
</li>
<li><p><code>git branch -d 分支名</code> : 删除某个分支</p>
</li>
<li><p><code>git merge 分支名</code> : 合并某个分支到现在所处的分支</p>
</li>
<li><p><code>git branch -r</code> : 查看远程仓库的分支情况</p>
</li>
<li><p><code>git branch -a</code> : 查看所有分支的情况，即本地分支和远程分支（上面的部分是本地分支，下面红色的部分是远程的分支）</p>
</li>
<li><p>远程分支的创建不能通过<code>git branch</code>进行，而是在<code>git push</code>的时候默认执行</p>
</li>
<li><p>分支重命名：<code>git branch -m oldname newname</code></p>
</li>
</ul>
<h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><ul>
<li><p><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt; : &lt;远程分支名&gt;</code></p>
<ul>
<li>分支的推送顺序写法是：<code>&lt;来源地&gt;:&lt;目的地&gt;</code></li>
</ul>
</li>
<li><p>远程分支的删除也不能使用<code>git branch</code> , 同样采用<code>git push</code></p>
<ul>
<li><code>git push &lt;远程主机名&gt; --delete &lt;删除的分支名&gt;</code></li>
<li>或者：<code>git push &lt;远程主机名&gt; : &lt;远程分支名&gt;</code> ，省略了本地分支名相当于推送了一个空的本地分支到远程分支上，就相当于删除了远程分支</li>
</ul>
</li>
</ul>
<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><ul>
<li><code>git fetch</code>这个命令用于取回远程仓库上的更新到本地仓库，默认是取回远程仓库上的所有更新，</li>
<li>如果要取回执行分支上的内容，可以使用<code>git fetch &lt;远程仓库&gt; &lt;分支名&gt;</code>。这样取回的分支是不会影响本地仓库中的代码，通常用于查看他人进程，取回远程分支之后，可以在远程分支的基础上创建新的分支，也可以将远程分支和本地分支合并:<code>git merge origin/dev</code> or <code>git rebase origin/dev</code> ： 表示将当前分支与远程分支合并</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Docker/2024-05-22-docker_2_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Docker/2024-05-22-docker_2_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">docker_2_基础语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>docker基础语法</li>
</ul>
<h2 id="docker-inspect-详解"><a href="#docker-inspect-详解" class="headerlink" title="docker inspect 详解"></a>docker inspect 详解</h2><p><code>docker inspect</code> 命令用于查看 Docker 中的各种对象的详细信息，包括容器、镜像、网络、卷等。这个命令以 JSON 格式输出对象的配置和状态信息，可用于调试、监视和了解 Docker 对象的各个方面。下面是有关 <code>docker inspect</code> 命令的详细解释：</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] OBJECT [OBJECT...]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>OPTIONS</code>：可选，可以附加一些选项来控制输出格式和内容。</li>
<li><code>OBJECT</code>：必需，指定要检查的 Docker 对象的名称或 ID。</li>
</ul>
<p>以下是一些常见的用法和选项：</p>
<ol>
<li><p>查看容器详细信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect container_name_or_id</span><br></pre></td></tr></table></figure>

<p>这将输出指定容器的详细信息，包括容器的配置、状态、网络设置等等。</p>
</li>
<li><p>查看镜像详细信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect image_name_or_id</span><br></pre></td></tr></table></figure>

<p>这将输出指定镜像的详细信息，包括镜像的元数据、层信息等。</p>
</li>
<li><p>输出格式选项：</p>
<p>默认情况下，<code>docker inspect</code> 输出 JSON 格式的信息，但你可以使用 <code>--format</code> 选项来指定自定义输出格式。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format container_name_or_id</span><br></pre></td></tr></table></figure>

<p>这将仅输出容器的状态（运行、停止等）。</p>
</li>
<li><p>查看多个对象的信息：</p>
<p>你可以一次查看多个 Docker 对象的信息。例如，要查看多个容器的详细信息，可以列出它们的名称或 ID 并用空格分隔：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect container1 container2</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>--type</code> 选项过滤对象类型：</p>
<p>你可以使用 <code>--type</code> 选项来过滤要检查的 Docker 对象的类型。例如，要查看所有网络的详细信息，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --<span class="built_in">type</span> network</span><br></pre></td></tr></table></figure>

<p>这将列出所有网络的详细信息。</p>
</li>
<li><p>导出信息到文件：</p>
<p>如果你想将对象的详细信息保存到文件中，可以使用重定向操作符（<code>&gt;</code>）将输出重定向到文件。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect container_name_or_id &gt; container_info.json</span><br></pre></td></tr></table></figure>

<p>这将容器的详细信息保存到 <code>container_info.json</code> 文件中。</p>
</li>
</ol>
<p><code>docker inspect</code> 命令是一个非常有用的工具，可用于深入了解 Docker 对象的各个方面，从容器的配置到网络设置，以及镜像的元数据等等。通过查看这些信息，你可以更好地理解和管理你的 Docker 环境。</p>
<h2 id="docker-–network-net-详解"><a href="#docker-–network-net-详解" class="headerlink" title="docker –network(net) 详解"></a>docker –network(net) 详解</h2><p>在 Docker 中，网络是容器和其他容器或宿主机之间进行通信的基础。Docker 提供了多种网络模式和选项，可以根据不同的需求选择适当的网络配置。以下是 Docker 中一些常见的网络选项：</p>
<ol>
<li><p><code>--network</code>：这是一个全局选项，用于指定容器所属的网络。可以通过以下几种预定义的网络进行选择：</p>
<ul>
<li><p><code>bridge</code>：默认网络模式，Docker 在主机上创建一个名为 <code>bridge</code> 的虚拟网络，容器将连接到该网络，容器可以通过它与宿主机和其他容器通信。</p>
</li>
<li><p><code>host</code>：使用宿主机的网络命名空间，容器与宿主机共享网络栈，与宿主机拥有相同的网络接口和IP地址。适用于需要容器与宿主机共享网络的场景。</p>
</li>
<li><p><code>none</code>：不使用任何网络，容器将没有网络接口，只适用于特殊情况。</p>
</li>
<li><p><code>container:&lt;name|id&gt;</code>：使容器与指定名称或ID的另一个容器共享网络命名空间，从而实现容器之间的网络通信。</p>
</li>
<li><p>自定义网络：可以使用 <code>docker network create</code> 命令创建自定义网络，并将容器连接到该网络。</p>
</li>
</ul>
</li>
<li><p><code>--publish</code> 或 <code>-p</code>：这个选项用于将容器内部的端口映射到宿主机上，允许外部主机通过宿主机的IP和端口访问容器内部的服务。</p>
<p>例如：<code>docker run -p 8080:80 nginx</code> 将容器内部的80端口映射到宿主机的8080端口。</p>
</li>
<li><p><code>--expose</code>：用于将容器内部的端口暴露给与容器连接的其他容器，但不映射到宿主机。这只是一种文档工具，实际上并不会进行端口映射。</p>
</li>
<li><p><code>--link</code>：已经过时，不推荐使用。用于在容器之间创建链接，允许容器使用对方的环境变量进行通信。</p>
</li>
<li><p><code>--hostname</code>：指定容器的主机名。</p>
</li>
</ol>
<p>这些选项可以通过 <code>docker run</code> 命令进行设置，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --network=bridge -p 8080:80 --name my_container nginx</span><br></pre></td></tr></table></figure>

<p>上述命令将创建一个名为 <code>my_container</code> 的容器，连接到默认的 <code>bridge</code> 网络，并将容器内部的80端口映射到宿主机的8080端口，让外部可以通过宿主机的IP和端口访问容器内的NGINX服务。</p>
<p>请注意，Docker 的网络功能在不同版本之间可能会有一些变化，建议查阅最新的 Docker 文档以获得最准确的信息。</p>
<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><p>Docker Compose 是一个用于定义和管理多容器应用程序的工具，它使用一个单独的 YAML 文件来配置应用程序的服务、网络和卷等。</p>
<p>以下是一些常用的 Docker Compose 命令及其功能：</p>
<ol>
<li><p>启动和停止容器组：</p>
<ul>
<li>启动容器组：<code>docker-compose up</code> 或 <code>docker-compose start</code> 命令可以启动 Docker Compose 配置文件中定义的所有服务和容器。</li>
<li>停止容器组：<code>docker-compose stop</code> 命令可以停止 Docker Compose 配置文件中定义的所有服务和容器。</li>
</ul>
</li>
<li><p>构建和重建容器：</p>
<ul>
<li>构建容器：<code>docker-compose build</code> 命令可以根据 Docker Compose 配置文件中的定义，构建容器的镜像。</li>
<li>重建容器：<code>docker-compose up --build</code> 命令可以重建所有容器的镜像，并重新启动容器组。</li>
</ul>
</li>
<li><p>查看容器组状态：</p>
<ul>
<li>查看容器组状态：<code>docker-compose ps</code> 命令可以列出 Docker Compose 配置文件中定义的所有服务和容器的状态信息。</li>
</ul>
</li>
<li><p>执行命令：</p>
<ul>
<li>在容器内执行命令：<code>docker-compose exec &lt;service&gt; &lt;command&gt;</code> 命令可以在指定的服务容器内执行命令。</li>
</ul>
</li>
<li><p>清理容器和资源：</p>
<ul>
<li>删除容器：<code>docker-compose rm</code> 命令可以删除停止的容器。</li>
<li>清理资源：<code>docker-compose down</code> 命令可以停止并删除所有容器、网络和卷。</li>
</ul>
</li>
<li><p>查看日志：</p>
<ul>
<li>查看容器日志：<code>docker-compose logs</code> 命令可以查看 Docker Compose 配置文件中定义的所有服务和容器的日志。</li>
</ul>
</li>
</ol>
<p>这些是一些常见的 Docker Compose 命令及其功能。你可以根据需要使用这些命令来管理和操作 Docker Compose 配置文件中定义的容器组。</p>
<p>请注意，在使用 Docker Compose 命令之前，确保已经安装了 Docker Compose 工具，并在当前工作目录下存在正确的 Docker Compose 配置文件。</p>
<hr>
<h2 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h2><ul>
<li><p>简介：</p>
<ul>
<li>docker save 命令用于将 Docker 镜像保存为一个 tar 归档文件。这个归档文件可以方便地传输、备份或在其他 Docker 主机上加载和使用</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>OPTIONS：可选参数，用于指定额外的选项，如压缩级别等。</li>
<li>IMAGE：要保存为归档文件的 Docker 镜像名称或镜像 ID</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o myimage.tar myimage:latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述示例将名为 myimage:latest 的 Docker 镜像保存为 myimage.tar 归档文件。</li>
<li>要了解更多关于 docker save 命令的详细信息，你可以使用 docker save –help 查看帮助文档</li>
<li>使用 docker save 命令保存的归档文件可以使用 docker load 命令进行加载和导入。这样可以在其他 Docker 主机上使用相同的镜像，或者进行备份和共享镜像</li>
</ul>
</li>
</ul>
<h2 id="docker-system"><a href="#docker-system" class="headerlink" title="docker system"></a>docker system</h2><p><code>docker system</code> 命令用于管理和查看 Docker 系统资源的相关信息。它提供了一组子命令，可以用于获取关于 Docker 守护进程（Docker daemon）的状态、清理无用资源以及查看 Docker 系统的使用情况。下面是对 <code>docker system</code> 命令的一些常用子命令的详细解释：</p>
<ol>
<li><p>**<code>docker system df</code>**：显示 Docker 系统的磁盘使用情况，包括镜像、容器和卷的使用情况。</p>
</li>
<li><p>**<code>docker system events</code>**：实时显示 Docker 系统的事件流，包括容器的创建、启动、停止、删除等事件。</p>
</li>
<li><p>**<code>docker system info</code>**：显示 Docker 系统的详细信息，包括容器、镜像、存储驱动、内核版本等。</p>
</li>
<li><p>**<code>docker system prune</code>**：清理无用的 Docker 资源，包括未使用的镜像、停止的容器、未使用的网络等。</p>
</li>
<li><p>**<code>docker system resize</code>**：调整 Docker 容器终端的大小。</p>
</li>
</ol>
<p>这只是 <code>docker system</code> 命令的一些常见用法。你可以通过运行 <code>docker system --help</code> 或 <code>docker system &lt;子命令&gt; --help</code> 查看完整的帮助文档，以了解更多关于各个子命令的详细信息和使用方式。</p>
<p>请注意，<code>docker system</code> 命令需要在具有足够权限的环境中执行，例如在管理员或超级用户模式下执行。</p>
<h2 id="docker-system-prune"><a href="#docker-system-prune" class="headerlink" title="docker system prune"></a>docker system prune</h2><p><code>docker system prune</code> 命令用于清理无用的 Docker 资源，以释放磁盘空间。它会删除未使用的镜像、停止的容器、未使用的网络和未被任何容器引用的卷。这可以帮助你清理系统中的不必要资源，以避免占用过多的磁盘空间。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune [OPTIONS]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>OPTIONS</code>：可选参数，用于指定额外的选项。常见的选项包括：<ul>
<li><code>-a, --all</code>：清理所有未使用的资源，包括未使用的镜像、容器、网络和卷。</li>
<li><code>-f, --force</code>：强制执行清理操作，不需要用户进行确认。</li>
<li><code>--filter &lt;FILTER&gt;</code>：按照指定的条件过滤要清理的资源。</li>
<li><code>-v, --volumes</code>：同时清理未被容器引用的卷。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune -a</span><br></pre></td></tr></table></figure>

<p>上述示例将清理所有未使用的 Docker 资源，包括未使用的镜像、停止的容器、未使用的网络和未被任何容器引用的卷。</p>
<p>请注意，清理操作是不可逆的，一旦执行将无法恢复被删除的资源。在执行 <code>docker system prune</code> 命令之前，请确保你了解将要删除的资源，并确认没有重要的数据会被删除。</p>
<p>使用 <code>docker system prune</code> 命令可以帮助你管理 Docker 系统资源，提供更高效和规整的环境。</p>
<!-- + 语法：`docker system prune [options]`
+ 作用：清除缓存
+ `[options]`
  - `-all, -a` : 删除所有未使用的镜像，不只是闲置的。(Remove all unused images not just dangling ones)
  - `--filter` : 提供数值过滤，例如：`label=<key>=<value>`。(Provide filter values)
  - `--force, -f` : 不提示确认。(Do not prompt for confirmation)
  - `--volumes` : 清除卷。(Prune volumes)

+ `docker system prune --volumes`
+ 该命令清除：
  - 所有停止的容器
  - 所有不被任何一个容器使用的网络
  - 所有不被任何一个容器使用的volume
  - 所有无实例的镜像 -->

<h2 id="docker-system-df"><a href="#docker-system-df" class="headerlink" title="docker system df"></a>docker system df</h2><p><code>docker system df</code> 命令用于显示 Docker 系统的磁盘使用情况，包括镜像、容器和卷的使用情况。它可以帮助你了解 Docker 系统在磁盘上占用的空间，以便更好地管理和优化资源。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system <span class="built_in">df</span> [OPTIONS]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>OPTIONS</code>：可选参数，用于指定额外的选项。常见的选项包括：<ul>
<li><code>--no-trunc</code>：不截断输出的镜像和容器名称。</li>
<li><code>-v, --volumes</code>：同时显示卷的使用情况。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system <span class="built_in">df</span></span><br></pre></td></tr></table></figure>

<p>上述示例将显示 Docker 系统的磁盘使用情况，包括镜像、容器和卷的使用情况。</p>
<p>输出内容包括以下几个部分：</p>
<ul>
<li><code>IMAGE TYPE</code>：镜像类型（例如，镜像、容器或卷）。</li>
<li><code>TOTAL</code>：总大小。</li>
<li><code>USED</code>：已使用的大小。</li>
<li><code>SHARED</code>：共享的大小。</li>
<li><code>CACHE</code>：缓存的大小。</li>
<li><code>RECLAIMABLE</code>：可回收的大小。</li>
<li><code>PARENT</code>：父镜像的 ID。</li>
<li><code>TAG</code>：镜像的标签或容器的名称。</li>
<li><code>VIRTUAL SIZE</code>：虚拟大小。</li>
</ul>
<p>使用 <code>docker system df</code> 命令可以方便地查看 Docker 系统的磁盘使用情况，帮助你了解镜像和容器占用的空间。这有助于进行资源管理和优化，以确保磁盘空间得到合理利用。</p>
<!-- + 语法：`docker system df [options]`
+ 作用：显示docker磁盘的使用情况(show docker disk usage)
+ `options` :
  - `--format` : 使用go模板打印更好的图像
  - `--verbose, -v` : 显示空间使用的详细信息 -->

<h2 id="docker-system-info"><a href="#docker-system-info" class="headerlink" title="docker system info"></a>docker system info</h2><p><code>docker system info</code> 命令用于显示 Docker 系统的详细信息，包括容器、镜像、存储驱动、内核版本等。它提供了有关 Docker 守护进程（Docker daemon）和运行环境的相关信息。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system info</span><br></pre></td></tr></table></figure>

<p>示例输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Client:</span><br><span class="line"> Context:    default</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Plugins:</span><br><span class="line">  app: Docker App (Docker Inc., v0.9.1-beta3)</span><br><span class="line">  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 3</span><br><span class="line">  Running: 2</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 1</span><br><span class="line"> Images: 15</span><br><span class="line"> Server Version: 20.10.6</span><br><span class="line"> Storage Driver: overlay2</span><br><span class="line">  Backing Filesystem: extfs</span><br><span class="line">  Supports d_type: true</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>输出内容包括以下几个部分：</p>
<ul>
<li><code>Client</code>：客户端相关信息，如上下文和调试模式。</li>
<li><code>Plugins</code>：安装的插件列表。</li>
<li><code>Server</code>：Docker 守护进程相关信息，如容器数量、镜像数量、服务器版本等。</li>
<li><code>Storage Driver</code>：存储驱动信息，如使用的驱动类型、底层文件系统等。</li>
<li>其他相关信息，如操作系统类型、内核版本等。</li>
</ul>
<p>通过运行 <code>docker system info</code> 命令，你可以获得有关 Docker 系统的详细信息，帮助你了解 Docker 运行环境和配置。这对于故障排查、性能优化和了解 Docker 系统的状态非常有用。</p>
<!-- + 语法：`docker system info [options]`
+ 作用：显示全部系统的信息
+ `[options]`:
  - `--format, -f` : 以指定的go模板格式化输出 -->

<h2 id="docker-stats"><a href="#docker-stats" class="headerlink" title="docker stats"></a>docker stats</h2><p><code>docker stats</code> 命令用于实时监视 Docker 容器的资源使用情况，包括 CPU 使用率、内存使用量、网络 I&#x2F;O 等。它提供了一个实时的流式输出，可以帮助你了解正在运行的容器的性能和资源消耗情况。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats [OPTIONS] [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>OPTIONS</code>：可选参数，用于指定额外的选项。常见的选项包括：<ul>
<li><code>--all, -a</code>：显示所有的容器（包括停止的容器）。</li>
<li><code>--format</code>：自定义输出格式。</li>
<li><code>--no-stream</code>：只显示一次统计结果，然后退出。</li>
<li><code>--no-trunc</code>：不截断输出的容器名称。</li>
</ul>
</li>
<li><code>CONTAINER</code>：要监视的容器名称或容器 ID。如果不指定容器，则会监视所有正在运行的容器。</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats container1 container2</span><br></pre></td></tr></table></figure>

<p>上述示例将实时监视名为 <code>container1</code> 和 <code>container2</code> 的容器的资源使用情况。</p>
<p>输出内容包括以下几个部分：</p>
<ul>
<li><code>CONTAINER ID</code>：容器的 ID。</li>
<li><code>NAME</code>：容器的名称。</li>
<li><code>CPU %</code>：CPU 使用率。</li>
<li><code>MEM USAGE / LIMIT</code>：内存使用量和限制。</li>
<li><code>MEM %</code>：内存使用率。</li>
<li><code>NET I/O</code>：网络输入&#x2F;输出。</li>
<li><code>BLOCK I/O</code>：块设备输入&#x2F;输出。</li>
<li><code>PIDS</code>：进程 ID 数量。</li>
</ul>
<p>使用 <code>docker stats</code> 命令可以实时监视 Docker 容器的资源使用情况，帮助你了解容器的性能和资源消耗情况。这对于监控和优化容器的运行非常有用。请注意，<code>docker stats</code> 命令会持续输出监视结果，可以通过 Ctrl+C 终止命令的执行。</p>
<!-- + 显示容器资源的使用情况，包括：CPU，内存，网络I/O等
+ 语法：`docker stats [options] [container...]`
+ `[options]`:
  - `-all, -a` : 显示所有的容器，包括未运行的
  - `--format` : 指定返回值的模板文件
  - `-no-stream` : 展示当前状态就直接退出了，不再实时更新
  - `--no-trunc` : 不截断输出
+ 输出详情：
  - `CONTAINER ID` ， `NAME` : 容器ID，名称
  - `CPU%, MEM%` : 容器使用的CPU和内存的百分比
  - `MEM USAGE/LIMIT` : 容器正在使用的总内存，以及允许使用的内存总量
  - `NET I/O` : 容器通过其网络接口发送和接受的数据量
  - `BLOCK I/O` : 容器从主机上的块设备读取和写入的数据量
  - `PIDs` : 容器创建的进程或线程数 -->

<h2 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h2><p><code>docker history</code> 命令用于查看 Docker 镜像的历史记录，包括每个镜像层的创建步骤和相关信息。它可以帮助你了解镜像是如何构建的，每个镜像层的来源和变更，以及各个镜像层的大小。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> [OPTIONS] IMAGE</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>OPTIONS</code>：可选参数，用于指定额外的选项。常见的选项包括：<ul>
<li><code>--no-trunc</code>：显示完整的命令信息，不截断输出。</li>
<li><code>--quiet, -q</code>：仅显示镜像层的 ID。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> myimage:latest</span><br></pre></td></tr></table></figure>

<p>上述示例将显示名为 <code>myimage:latest</code> 的 Docker 镜像的历史记录。</p>
<p>输出内容包括以下几个部分：</p>
<ul>
<li><code>IMAGE ID</code>：镜像层的 ID。</li>
<li><code>CREATED</code>：镜像层的创建时间。</li>
<li><code>CREATED BY</code>：创建镜像层的命令或操作。</li>
<li><code>SIZE</code>：镜像层的大小。</li>
</ul>
<p><code>docker history</code> 命令按照镜像层的构建顺序列出了镜像的历史记录。每个镜像层都代表一个变更，它可以是一个 Dockerfile 中的一条指令或者基于其他镜像层的修改。通过查看镜像的历史记录，你可以了解镜像是如何构建的，每个步骤的细节和影响，以及镜像层的大小情况。</p>
<p>请注意，镜像历史记录中的每一行都会添加一个新的镜像层，并且每个镜像层都会占用磁盘空间。因此，构建过多的镜像层可能会增加镜像的大小和磁盘消耗。</p>
<!-- + 语法：`docker history [options] IMAGE`
+ 作用：显示一个镜像的历史
+ `[options]`:
  - `--format` : 使用go模板输出
  - `--human, -H` : 以人习惯的阅读方式输出
  - `--no-trunc` : 不截断输出
  - `--quiet, -q` : 仅显示镜像IDs -->

<h2 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h2><p><code>docker kill</code> 命令用于强制停止正在运行的 Docker 容器。它发送一个 SIGKILL 信号给容器的主进程，使容器立即停止运行，类似于使用 <code>kill -9</code> 命令终止进程。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>OPTIONS</code>：可选参数，用于指定额外的选项。常见的选项包括：<ul>
<li><code>-s, --signal</code>：指定要发送的信号。默认为 SIGKILL。</li>
</ul>
</li>
<li><code>CONTAINER</code>：要停止的容器名称或容器 ID。</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> mycontainer</span><br></pre></td></tr></table></figure>

<p>上述示例将停止名为 <code>mycontainer</code> 的 Docker 容器。</p>
<p>注意事项：</p>
<ul>
<li>使用 <code>docker kill</code> 命令会立即停止容器，不会触发容器的停止信号或执行容器的停止脚本。</li>
<li>如果你希望优雅地停止容器并触发容器的停止信号和脚本，可以使用 <code>docker stop</code> 命令。</li>
<li>使用 <code>docker kill</code> 命令强制停止容器可能导致数据丢失或不正常的容器状态，请谨慎使用。</li>
</ul>
<p><code>docker kill</code> 命令用于强制停止正在运行的容器，对于无法通过正常方式停止的容器，这是一种有效的方法。然而，它不是优雅停止容器的首选方法，因为容器没有机会进行清理操作。建议在必要时使用，并确保了解可能的副作用。</p>
<!-- + 语法：`docker kill [options] container [container...]`
+ 作用：杀死一个或者多个正在运行的容器
+ `[options]`
  - `--signal, -s` : 发送到容器的信号。(Signal to send to the container)
  - `SIGHUB` , 信号，网络编程 -->

<h2 id="docker-pause"><a href="#docker-pause" class="headerlink" title="docker pause"></a>docker pause</h2><p><code>docker pause</code> 命令用于暂停正在运行的 Docker 容器。它会暂停容器内所有的进程，使其停止在当前状态，直到恢复为止。暂停后的容器不会消耗 CPU 资源，但内存和磁盘资源仍然保留。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>CONTAINER</code>：要暂停的容器名称或容器 ID。</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause mycontainer</span><br></pre></td></tr></table></figure>

<p>上述示例将暂停名为 <code>mycontainer</code> 的 Docker 容器。</p>
<p>注意事项：</p>
<ul>
<li>暂停容器会暂停容器内的所有进程，包括正在运行的和后台运行的。</li>
<li>暂停后的容器可以使用 <code>docker unpause</code> 命令来恢复运行。</li>
<li>暂停容器并不会影响容器的网络连接，因此容器仍然可以接收网络流量。</li>
<li>只有在支持容器暂停功能的操作系统上才能使用 <code>docker pause</code> 命令。</li>
</ul>
<p>使用 <code>docker pause</code> 命令可以方便地暂停正在运行的容器，以便进行调试、维护或其他需要容器暂停的操作。请确保在使用此命令之前了解其影响，并谨慎操作以避免不必要的问题。</p>
<!-- + 语法：`docker pause container [container...]`
+ 作用：暂停一个或多个容器中的所有进程 -->

<h2 id="docker-unpause"><a href="#docker-unpause" class="headerlink" title="docker unpause"></a>docker unpause</h2><p><code>docker unpause</code> 命令用于恢复被暂停的 Docker 容器。它会使之前被暂停的容器继续运行，并恢复容器内的所有进程的执行。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>CONTAINER</code>：要恢复的容器名称或容器 ID。</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause mycontainer</span><br></pre></td></tr></table></figure>

<p>上述示例将恢复名为 <code>mycontainer</code> 的 Docker 容器。</p>
<p>注意事项：</p>
<ul>
<li>只有被暂停的容器才能使用 <code>docker unpause</code> 命令进行恢复。</li>
<li>恢复容器后，之前被暂停的进程会继续执行。</li>
<li>容器的网络连接不会受到 <code>docker unpause</code> 命令的影响。</li>
</ul>
<p>使用 <code>docker unpause</code> 命令可以恢复之前被暂停的容器，使其继续运行。这对于从暂停状态中恢复容器非常有用，例如在进行调试或维护操作后重新启动容器。请注意，只能对已暂停的容器执行 <code>docker unpause</code> 命令。</p>
<!-- + 语法：`docker unpause container [container...]`
+ 作用：不暂停一个或多个容器中的所有进程 -->

<h2 id="docker-rename"><a href="#docker-rename" class="headerlink" title="docker rename"></a>docker rename</h2><p><code>docker rename</code> 命令用于为 Docker 容器重命名。它可以修改容器的名称标识符，使其更符合你的需求或命名约定。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename CONTAINER NEW_NAME</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>CONTAINER</code>：要重命名的容器名称或容器 ID。</li>
<li><code>NEW_NAME</code>：新的容器名称。</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename mycontainer newname</span><br></pre></td></tr></table></figure>

<p>上述示例将名为 <code>mycontainer</code> 的 Docker 容器重命名为 <code>newname</code>。</p>
<p>注意事项：</p>
<ul>
<li>重命名容器只会修改容器的名称标识符，不会对容器内的运行进程或状态造成影响。</li>
<li>容器的新名称必须是唯一的，不得与现有容器名称重复。</li>
</ul>
<p>使用 <code>docker rename</code> 命令可以轻松地为 Docker 容器重新命名，以便更好地管理容器或与命名约定保持一致。请记住，在容器被重命名后，你需要使用新的名称来执行其他容器相关的操作。</p>
<!-- + 语法：`docker rename container new_name`
+ 作用：重命名一个容器 -->

<h2 id="builder"><a href="#builder" class="headerlink" title="builder"></a>builder</h2><ul>
<li>manage builds</li>
</ul>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><ul>
<li>命令：<code>docker builder build [OPTIONS] PATH | URL | -</code></li>
<li>简介：从Dockerfile创建一个镜像</li>
<li>选项：<ul>
<li><code>--add-host</code> : 添加一个自定义的主机到IP的映射（host:ip）</li>
<li><code>--build-arg</code> : 设置构建时的变量</li>
<li><code>--cache-from</code> : 考虑作为缓存来源的镜像</li>
<li><code>--cgroup-parent</code> : 容器的可选父级c组</li>
<li><code>--compress</code> : 使用gzip压缩构建环境</li>
<li><code>--cpu-period</code></li>
<li><code>--cpu-quota</code></li>
<li><code>--cpu-shares,-c</code></li>
<li><code>--cpuset-cpus</code></li>
<li><code>--cpuset-mems</code></li>
<li><code>--disable-content-true</code> : 跳过镜像验证，默认为true</li>
<li><code>--file,-f</code> : Dockerfile的名称，默认为PATH&#x2F;Dockerfile</li>
<li><code>--force-rm</code> : 始终移除中间的容器</li>
<li><code>--iidfile</code> : 将镜像的ID写入到文件中</li>
<li><code>--isolation</code> : 容器隔离技术</li>
<li><code>--label</code> : 设置镜像的元数据</li>
<li><code>--memory,-m</code> : 内存限制</li>
<li><code>--memory-swap</code> : 交换限制等于内存加交换：-1表示启用无限制交换。</li>
<li><code>--network</code> : 在构建过程中为RUN指令设置网络模式</li>
<li><code>--no-cache</code> : 在构建镜像的时候不要使用缓存</li>
<li><code>--platform</code> : 如果服务器是多平台的，则设置平台</li>
<li><code>--pull</code> : 始终尝试拉取一个较新版本的镜像</li>
<li><code>--quiet,-q</code> : 过滤构建镜像的输出，仅在成功时输出镜像的ID</li>
<li><code>--rm</code> : 构建成功后删除中间容器</li>
<li><code>--security-opt</code> : 安全选项</li>
<li><code>--shm-size</code> : &#x2F;dev&#x2F;shm的大小</li>
<li><code>--squash</code> : 将新建的层压成一个新的层</li>
<li><code>--tag,-t</code> : 名称和可选的标签，格式为name:tag</li>
<li><code>--target</code> : 设置目标构建阶段为构建。</li>
<li><code>--ulimit</code> : 限定选项</li>
</ul>
</li>
</ul>
<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><ul>
<li>命令：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></li>
<li>简介：docker run命令首先在指定的镜像上创建一个可写的容器层，然后用指定的命令启动它。也就是说，docker run相当于API中的&#x2F;containers&#x2F;create然后&#x2F;containers&#x2F;(id)&#x2F;start。一个停止的容器可以用docker start来重新启动，其之前的所有变化都是完整的。</li>
<li>选项：<ul>
<li><code>--add-host</code> : 添加一个自定义的主机到IP的映射（host:ip）</li>
<li><code>--attach,-a</code> : 附加到STDIN、STDOUT或STDERR上</li>
<li><code>--blkio-weight</code> : 区块IO（相对权重），在10和1000之间，或0表示禁用（默认为0）。</li>
<li><code>--blkio-weight-device</code> : 块状IO重量（相对设备重量）</li>
<li><code>--cap-add</code> : 	增加Linux功能</li>
<li><code>--cap-drop</code> : 	降低Linux的能力</li>
<li><code>--cgroup-parent</code> : 容器的可选父级c组</li>
<li><code>--cgroupns</code></li>
<li><code>--cidfile</code> : 将容器ID写到文件中</li>
<li><code>--cpu-count</code> : CPU计数，仅支持Windows</li>
<li><code>--cpu-percent</code> : </li>
<li><code>--cpu-period</code> </li>
<li><code>--cpu-quota</code></li>
<li><code>--cpu-rt-period</code></li>
<li><code>--cpu-rt-runtime</code></li>
<li><code>--cpu-shared,-c</code></li>
<li><code>--cpus</code> : cpu的数量</li>
<li><code>--cpuset-cpus</code></li>
<li><code>--cpuset-mems</code></li>
<li><code>--detach,-d</code> : 在后台运行容器并打印容器ID</li>
<li><code>--detach-keys</code> : 覆盖脱离容器的按键顺序</li>
<li><code>--device</code> : 在容器中添加一个主机设备</li>
<li><code>--device-cgroup-rule</code> : 在cgroup允许的设备列表中添加一条规则</li>
<li><code>--device-read-bps</code> : 限制从一个设备上的读取速率（每秒字节数）。</li>
<li><code>--device-read-iops</code> : 限制从一个设备的读取率（每秒的IO）。</li>
<li><code>--device-write-bps</code></li>
<li><code>--device-write-iops</code></li>
<li><code>--disable-content-trust</code> : 跳过镜像验证，默认为true</li>
<li><code>--dns</code> : 设置自定义的DNS服务器</li>
<li><code>--dns-option</code> : 设置DNS选项</li>
<li><code>--dns-search</code> : 设置自定义DNS搜索域</li>
<li><code>--domainname</code> : 容器NIS域名</li>
<li><code>--entrypoint</code> : 覆盖镜像的默认ENTRYPOINT</li>
<li><code>--env,-e</code> : 设置环境变量</li>
<li><code>--env-file</code> : 读取环境变量的文件</li>
<li><code>--expose</code> : 暴露一个端口或一系列的端口</li>
<li><code>--gpus</code> : 要添加到容器中的GPU设备（’全部’用于传递所有GPU）。</li>
<li><code>--group-add</code></li>
<li><code>--health-cmd</code> : 运行命令以检查健康状况</li>
<li><code>--health-interval</code> : 运行检查的间隔时间（ms|s|m|h）（默认为0s）。</li>
<li><code>--health-retries</code></li>
<li><code>--health-start-period</code></li>
<li><code>--health-timeout</code></li>
<li><code>--help</code> : 输出帮助信息</li>
<li><code>--hostname,-h</code> : 容器主机名称</li>
<li><code>--init</code> : 在容器内运行一个init，转发信号并收割进程</li>
<li><code>--interactive,-i</code> : 保持STDIN开放，即使没有连接</li>
<li><code>--io-maxbandwidth</code> : 系统驱动器的最大IO带宽限制（仅Windows）。</li>
<li><code>--io-maxiops</code> : 系统驱动器的最大IOps限制（仅Windows）。</li>
</ul>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h2 id="docker-images-docker-image-ls"><a href="#docker-images-docker-image-ls" class="headerlink" title="docker images, docker image ls"></a><code>docker images, docker image ls</code></h2><ul>
<li>列出本地主机上的镜像<ul>
<li><code>repository</code> : 表示镜像的仓库源</li>
<li><code>tag</code> : 镜像的标签</li>
<li><code>image id</code> : 镜像id</li>
<li><code>created</code> : 镜像创建时间</li>
<li><code>size</code> : 镜像大小</li>
</ul>
</li>
</ul>
<h2 id="docker-rmi-helloworld"><a href="#docker-rmi-helloworld" class="headerlink" title="docker rmi helloworld"></a><code>docker rmi helloworld</code></h2><ul>
<li>删除镜像</li>
</ul>
<h2 id="docker-run-it-ubuntu-bin-bash"><a href="#docker-run-it-ubuntu-bin-bash" class="headerlink" title="docker run -it ubuntu /bin/bash"></a><code>docker run -it ubuntu /bin/bash</code></h2><ul>
<li>使用ubuntu镜像启动一个容器,参数为以命令模式进入该容器<ul>
<li><code>-i</code> : 交互操作</li>
<li><code>-t</code> : 终端</li>
<li><code>ubuntu</code> : ubuntu镜像</li>
<li><code>/bin/bash</code> : 放在镜像名后的是命令,这里是希望有个交互式shell</li>
</ul>
</li>
</ul>
<h2 id="docker-run-itd-name-ubuntu-test-ubuntu-bin-bash"><a href="#docker-run-itd-name-ubuntu-test-ubuntu-bin-bash" class="headerlink" title="docker run -itd --name ubuntu-test ubuntu /bin/bash"></a><code>docker run -itd --name ubuntu-test ubuntu /bin/bash</code></h2><ul>
<li>后台运行容器<ul>
<li><code>-d</code> : 默认不会进入容器,想要进入容器需要使用指令<code>docker exec</code></li>
</ul>
</li>
</ul>
<h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a><code>docker ps</code></h2><ul>
<li>语法：<code>docker ps [options]</code></li>
<li>作用：列出容器</li>
<li><code>[options]</code><ul>
<li><code>--all, -a</code> : 显示所有容器(默认仅显示正在运行的)。(Show all containers(default shows just running))</li>
<li><code>--filter, -f</code> : 基于指定的条件过滤输出信息。(Filter output based on conditions provided)</li>
<li><code>--format</code> : 使用go模板输出</li>
<li><code>--last, -n</code> : 显示n个最后创建的容器。(Show n last created containers(includes all states))</li>
<li><code>--no-trunc</code> : 不截断输出。(Don’t truncate output)</li>
<li><code>--quiet, -q</code> : 仅显示容器ID。(Only display container IDs)</li>
<li><code>--size, -s</code> : 显示总文件大小。(Display total file sizes)</li>
</ul>
</li>
</ul>
<h2 id="docker-start-id"><a href="#docker-start-id" class="headerlink" title="docker start id"></a><code>docker start id</code></h2><ul>
<li>启动一个已停止的容器</li>
</ul>
<h2 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop"></a><code>docker stop</code></h2><ul>
<li>语法：<code>docker stop [options] container [container...]</code></li>
<li>作用：停止一个容器</li>
<li><code>[options]</code>:<ul>
<li><code>--time, -t</code> : 在杀死容器之前等待停止的时间，默认为10秒</li>
</ul>
</li>
</ul>
<h2 id="docker-restart-id"><a href="#docker-restart-id" class="headerlink" title="docker restart id"></a><code>docker restart id</code></h2><ul>
<li>重启一个容器</li>
</ul>
<h2 id="docker-attach-docker-exec"><a href="#docker-attach-docker-exec" class="headerlink" title="docker attach, docker exec"></a>docker attach, docker exec</h2><ul>
<li>进入容器:在使用<code>-d</code>参数时,容器启动后会进入后台,此时想要进入容器,通过以下指令:<ul>
<li>docker attach: <code>docker attach id</code></li>
<li>docker exec:推荐使用此命令,因为使用它退出容器终端,但是不会导致容器的停止,<code>docker exec -it id /bin/bash</code></li>
</ul>
</li>
</ul>
<h2 id="docker-export-docker-import-docker-commit"><a href="#docker-export-docker-import-docker-commit" class="headerlink" title="docker export, docker import, docker commit"></a>docker export, docker import, docker commit</h2><h2 id="docker-export"><a href="#docker-export" class="headerlink" title="docker export"></a>docker export</h2><ul>
<li><code>docker export</code>命令不会导出与容器关联的卷的内容。如果卷安装在容器中现有目录的顶部，则<code>docker export</code>将导出底层目录的内容，而不是卷的内容</li>
<li>功能：将容器的文件系统导出为tar存档</li>
<li><code>docker export 容器id &gt; 容器名称.tar , docker export 容器id --output 容器名称.tar</code><ul>
<li>导出本地某个容器到tar包</li>
</ul>
</li>
<li>参数<ul>
<li><code>--output, -o</code> : 写入一个文件，而不是<code>stdout</code></li>
</ul>
</li>
</ul>
<h2 id="docker-import"><a href="#docker-import" class="headerlink" title="docker import"></a>docker import</h2><ul>
<li>语法：<code>docker import [options] file|URL|- [REPOSITORY[:TAG]]</code></li>
<li>作用：从一个tar包导入文件数据并创建一个文件系统镜像</li>
<li><code>[options]</code> :<ul>
<li><code>--change, -c</code> : 应用于创建镜像的dockerfile 指示</li>
<li><code>--message, -m</code> : 为导入的镜像设置提交信息</li>
</ul>
</li>
<li><code>cat docker/ubuntu.tar | docker import - test/ubuntu:v1</code><ul>
<li>通过管道和标准输入的方式导入容器快照</li>
</ul>
</li>
</ul>
<h2 id="docker-load"><a href="#docker-load" class="headerlink" title="docker load"></a>docker load</h2><ul>
<li>导入镜像文件：<code>docker load --input imagePath</code></li>
</ul>
<h2 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h2><ul>
<li>更新镜像:通过命令<code>docker commit</code>来提交容器副本,Warning:使用此命令保存镜像，会以层的概念保存，每一次保存都会增加一层，镜像会越来越大<ul>
<li>示例:<code>docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</code></li>
<li>参数说明:<ul>
<li><code>-m</code>:提交的描述信息</li>
<li><code>-a</code>:指定镜像作者</li>
<li><code>e218edb10161</code> : 容器ID</li>
<li><code>runoob/ubuntu:v2</code> : 指定要创建的目标镜像名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h2><ul>
<li>修改镜像标签:<code>docker tag image-id name:tag</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Git/2024-05-22-git_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Git/2024-05-22-git_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">git_3_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Git常见的使用技巧</li>
</ul>
<h2 id="写了很多代码，发现写错了分支怎么办"><a href="#写了很多代码，发现写错了分支怎么办" class="headerlink" title="写了很多代码，发现写错了分支怎么办"></a>写了很多代码，发现写错了分支怎么办</h2><ul>
<li><p>未提交的情况下</p>
<ul>
<li>git add . (把所有改动暂存)</li>
<li>git stash (把暂存的文件提交到git的暂存栈)</li>
<li>git checkout 本该提交代码的分支</li>
<li>git stash pop (将暂存栈中的代码放出来)</li>
</ul>
</li>
<li><p>至于是继续改还是提交就随你了</p>
</li>
<li><p>已提交的情况下</p>
<ul>
<li>git checkout 不该提交代码提交了代码的分支</li>
<li>git reset HEAD~1 （最近一次提交放回暂存区, 并取消此次提交）</li>
<li>git stash (把暂存的文件提交到git的暂存栈)</li>
<li>git checkout 该提交代码的分支</li>
<li>git stash pop</li>
</ul>
</li>
<li><p>下面一顿操作随你猛了，等你把代码提交到了正确的分支后，再次切到刚刚错的分支</p>
</li>
</ul>
<h2 id="git-迭代拉取子项目"><a href="#git-迭代拉取子项目" class="headerlink" title="git 迭代拉取子项目"></a>git 迭代拉取子项目</h2><p>在 Git 中，如果你有一个父项目，而该项目包含了子项目，你可能希望在父项目中拉取或更新这些子项目。这种情况下，通常会使用 Git 的子模块（submodule）功能。子模块允许你在一个 Git 仓库中引用另一个仓库。</p>
<p>要拉取或更新子项目，可以按照以下步骤进行：</p>
<ol>
<li><p><strong>添加子模块</strong>：如果尚未添加子模块，可以使用以下命令将子模块添加到父项目中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add &lt;URL-of-submodule-repository&gt; &lt;path-to-store-submodule&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/example/submodule.git path/to/submodule</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化子模块</strong>：在克隆父项目后，子模块目录中可能还没有子模块的文件。要初始化子模块，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>更新子模块</strong>：一旦子模块被添加并初始化，你可以使用以下命令更新子模块到父项目所引用的特定版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure>
<p>这会将每个子模块更新到它们在父项目中所引用的最新提交。</p>
</li>
</ol>
<p>记住，当你拉取父项目时，子模块不会自动更新。你需要显式运行 <code>git submodule update --remote</code> 来更新子模块。</p>
<p>这些是用于在 Git 中迭代拉取子项目的基本步骤。</p>
<h2 id="git-仅检查指定项目-忽略子项目"><a href="#git-仅检查指定项目-忽略子项目" class="headerlink" title="git 仅检查指定项目 忽略子项目"></a>git 仅检查指定项目 忽略子项目</h2><p>在Git中，如果你想仅检查指定项目而忽略子项目，你可以使用<code>.gitignore</code>文件来指定哪些文件或目录应该被忽略。在<code>.gitignore</code>中，你可以列出你希望忽略的文件或目录的模式。</p>
<p>以下是一些建议：</p>
<ol>
<li><p><strong>创建.gitignore文件：</strong> 在你的项目根目录下创建一个名为<code>.gitignore</code>的文件。</p>
</li>
<li><p><strong>编辑.gitignore文件：</strong> 打开<code>.gitignore</code>文件并添加你希望忽略的文件或目录的模式。如果你想忽略所有子项目，你可以使用通配符（如<code>/*</code>）来匹配所有直接子目录。例如：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">!/指定项目/</span><br></pre></td></tr></table></figure>

<p> 这将忽略根目录下的所有内容，但允许<code>指定项目</code>目录被追踪。</p>
</li>
<li><p><strong>将.gitignore文件添加到版本控制：</strong> 确保将<code>.gitignore</code>文件添加到Git版本控制中，这样其他人克隆你的仓库时也会遵循这些规则。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .gitignore</span><br><span class="line">git commit -m &quot;Add .gitignore to ignore subprojects&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>更新.gitignore：</strong> 如果在项目的后续开发中需要调整忽略规则，只需更新<code>.gitignore</code>文件并提交更改即可。</p>
</li>
</ol>
<p>请记住，<code>.gitignore</code>文件中的模式是相对于<code>.gitignore</code>所在目录的相对路径的。确保你的规则符合你的项目结构。</p>
<h2 id="git-config-查看默认编辑器"><a href="#git-config-查看默认编辑器" class="headerlink" title="git config 查看默认编辑器"></a>git config 查看默认编辑器</h2><p>要查看 Git 的默认文本编辑器，可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor</span><br></pre></td></tr></table></figure>

<p>上述命令将显示全局配置中设置的默认编辑器。如果没有设置默认编辑器，它将不会返回任何输出。</p>
<p>如果你在命令行中看到了输出，它将是你当前配置的默认编辑器的名称或路径。常见的编辑器包括 Vim、Emacs、Nano、Sublime Text、Visual Studio Code 等。</p>
<h2 id="撤回本地修改"><a href="#撤回本地修改" class="headerlink" title="撤回本地修改"></a>撤回本地修改</h2><ul>
<li>放弃对本地已经修改，但是尚未提交的文件的修改，还原到其未修改前的状态</li>
<li>命令<ul>
<li>撤回对所有已经修改，但是未提交的文件的修改，但不包括新增的文件<ul>
<li><code>git checkout .</code></li>
</ul>
</li>
<li>撤回对指定文件的修改，<code>[filename]</code>为文件名<ul>
<li><code>git checkout [filename]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="git-reset-回退项目版本"><a href="#git-reset-回退项目版本" class="headerlink" title="git reset 回退项目版本"></a>git reset 回退项目版本</h2><ul>
<li>可以回退到任意已经提交过的版本，已经add, commit但是没有push的文件也适用</li>
<li>命令<ul>
<li><code>git reset --hard [commit-hashcode]</code></li>
</ul>
</li>
<li>参数：<ul>
<li><code>commit-hashcode</code> 是某个commit的哈希值，可以适用git log查看</li>
<li>因此，一般用法是先用git log 查看具体commit的哈希值，然后reset到那个版本</li>
</ul>
</li>
</ul>
<h2 id="对于新增文件"><a href="#对于新增文件" class="headerlink" title="对于新增文件"></a>对于新增文件</h2><ul>
<li>撤回本地修改和回退项目版本都不会对新增文件起作用。因为新增的文件是还未加到git的记录里面的，即属于未被<code>tracked</code>的状态，所以撤销修改和回退均对其不受影响。</li>
<li>解决方法：<ul>
<li>直接手动删除文件即可</li>
</ul>
</li>
</ul>
<h2 id="上游分支-upstream"><a href="#上游分支-upstream" class="headerlink" title="上游分支 upstream"></a>上游分支 upstream</h2><ul>
<li><p>upstream意为上游，即本地分支所对应的远程分支。</p>
</li>
<li><p>一般，本地分支如果是从clone或者fetch得到的，都在远程库有一个upstream分支。</p>
</li>
<li><p>设置upstream的方法有两种：</p>
<ul>
<li>在push的时候指定：<code>git push --set-upstream origin my_remote_branch_name</code></li>
<li>在新建分支的时候指定：<code>git branch --set-upstream my_local_branch_name origin/my_remote_branch_name</code>(错误)</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>在运行<code>git branch --set-upstream</code>命令时，出现错误(git –version: 2.17.1)</li>
<li><code>fatal: the &#39;--set-upstream&#39; option is no longer supported. Please use &#39;--track&#39; or &#39;--set-upstream-to&#39; instead.</code></li>
<li>设置方法：<code>git branch --set-upstream-to=origin/&lt;远程分支&gt; &lt;本地分支&gt;</code></li>
</ul>
</li>
<li><p>实际上，上述命令，就是在修改本地的.git&#x2F;config文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[branch &quot;my_local_branch_name&quot;]</span><br><span class="line">	remote = origin</span><br><span class="line">	merge = refs/heads/my_remote_branch_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消分支上游</p>
<ul>
<li><code>git branch --inset-upstream</code></li>
</ul>
</li>
<li><p>查看分支上游</p>
<ul>
<li><code>git status</code></li>
<li><code>git checkout &lt;分支&gt;</code></li>
<li><code>git branch -vv</code></li>
</ul>
</li>
<li><p>设置完upstream后，就可以直接用 <code>git push/pull</code> 来拉取或推送相应的分支了。</p>
</li>
</ul>
<h2 id="直接拉取远程分支"><a href="#直接拉取远程分支" class="headerlink" title="直接拉取远程分支"></a>直接拉取远程分支</h2><ul>
<li>新建分支分支并切换到指定分支<ul>
<li><code>git checkout -b dev origin/dev</code></li>
<li><code>git checkout -b 本地分支名 origin/远程分支名</code></li>
</ul>
</li>
<li>该命令可以将远程Git仓库里的指定分支拉取到本地，这样就在本地新建了一个dev分支，并和指定的远程分支<code>origin/dev</code>关联起来了。</li>
<li>示例：<ul>
<li><code>git checkout -b dev notes/dev</code> : 切换指定远程分支</li>
</ul>
</li>
</ul>
<h2 id="在本地使用指定提交id创建分支"><a href="#在本地使用指定提交id创建分支" class="headerlink" title="在本地使用指定提交id创建分支"></a>在本地使用指定提交id创建分支</h2><ul>
<li><p>查看远程分支最新的commitSHA，例如：<code>aa4339fbe90f68bc82901d976a7c11fe92179ef3</code></p>
</li>
<li><p>使用命令直接从指定的commit新建分支：</p>
<ul>
<li><code>git branch [branch-name] [commit-id]</code></li>
<li><code>git branch v1.x aa4339fbe90f68bc82901d976a7c11fe92179ef3</code></li>
</ul>
</li>
</ul>
<h2 id="使用标签的方式"><a href="#使用标签的方式" class="headerlink" title="使用标签的方式"></a>使用标签的方式</h2><ul>
<li><code>git clone [--branch tag-name/branch-name] &lt;git-url&gt; [dir]</code> 下载并绑定指定分支或下载指定标签</li>
</ul>
<h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ul>
<li><p>在本地仓库创建标签，并推送到远程：</p>
<ul>
<li><code>git tag -a v1.0 -m &quot;create tag&quot;</code></li>
<li><code>git push origin v1.0</code></li>
</ul>
</li>
<li><p>下载指定标签到本地：</p>
<ul>
<li><code>git clone --branch v1.0 http://192.169.4.28/zjy/clean_code.git</code></li>
</ul>
</li>
<li><p>下载标签之后，出现的提示：</p>
<ul>
<li>你处于分离的HEAD状态。您可以环顾四周，进行实验性更改并提交它们，您可以放弃在此状态下所做的任何提交，而不会通过执行另一次签出影响任何分支。</li>
<li>如果您想创建一个新的分支来保留您创建的提交，您可以(现在或以后)再次使用-b和chckout命令。</li>
</ul>
</li>
</ul>
<h2 id="git同步项目进度方法"><a href="#git同步项目进度方法" class="headerlink" title="git同步项目进度方法"></a>git同步项目进度方法</h2><ul>
<li><p>创建三个分支：</p>
<ul>
<li>master </li>
<li>dev</li>
<li>local</li>
</ul>
</li>
<li><p>master分支：</p>
<ul>
<li>存放稳定版本的代码，在这个分支上的项目，所有的功能都是经过测试，不再改动的</li>
<li>这个是对外发行的分支</li>
</ul>
</li>
<li><p>dev分支</p>
<ul>
<li>存放正在开发的代码，在这个分支上的项目，可能正在新加功能，需要经过反复修改的，或者是同步的</li>
<li>这个是面向所有开发者的</li>
<li>所有开发者通过拉取这个分支的代码来同步项目开发的进程</li>
</ul>
</li>
<li><p>local分支</p>
<ul>
<li>存放本地的项目的代码，在这个分支上的项目，随时都有可能修改</li>
<li>这个是存放在本地，面向的是自己</li>
<li>其作用是，自己开发的时候，都在这个本地分支上修改，需要推送到远程git上或者拉取远程git上最新的代码时，需要进行如下几步<ul>
<li>首先，将local分支的修改全部添加，并在本地提交</li>
<li>其次，切换到本地的dev分支，然后拉取远程git上最新的dev分支</li>
<li>最后，切换回local分支，将本地拉取到的最新的分支合并到local分支</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="git删除远程分支文件"><a href="#git删除远程分支文件" class="headerlink" title="git删除远程分支文件"></a>git删除远程分支文件</h2><ul>
<li>git删除远程分支文件包括两种情况：<ul>
<li>（1）仅仅删除远程分支文件，不删除本地的文件；</li>
<li>（2）删除远程分支文件的同时，删除本地的文件。</li>
</ul>
</li>
</ul>
<h2 id="仅仅删除远程分支文件，不删除本地文件"><a href="#仅仅删除远程分支文件，不删除本地文件" class="headerlink" title="仅仅删除远程分支文件，不删除本地文件"></a>仅仅删除远程分支文件，不删除本地文件</h2><ul>
<li><p>删除远程文件filename</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached filename</span><br><span class="line">git commit -m &quot;delete remote file filename &quot;</span><br><span class="line">git push -u origin master(此处是当前分支的名字)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除远程文件夹directoryname</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached directoryname</span><br><span class="line">git commit -m &quot;delete remote directory directoryname &quot;</span><br><span class="line">git push -u origin master(此处是当前分支的名字)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="删除本地文件与远程分支文件"><a href="#删除本地文件与远程分支文件" class="headerlink" title="删除本地文件与远程分支文件"></a>删除本地文件与远程分支文件</h2><ul>
<li><p>删除文件filename</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm filename</span><br><span class="line">git commit -m &quot;delete file filename &quot;</span><br><span class="line">git push -u origin master(此处是当前分支的名字)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件夹directoryname</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r directoryname</span><br><span class="line">git commit -m &quot;delete directory directoryname &quot;</span><br><span class="line">git push -u origin master(此处是当前分支的名字)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="git常见错误"><a href="#git常见错误" class="headerlink" title="git常见错误"></a>git常见错误</h2><h2 id="fatal-refusing-to-merge-unrelated-histories"><a href="#fatal-refusing-to-merge-unrelated-histories" class="headerlink" title="fatal:refusing to merge unrelated histories"></a><code>fatal:refusing to merge unrelated histories</code></h2><ul>
<li>在使用<code>git pull</code>命令拉取代码时出现这个错误</li>
<li>原因：本地仓库和远程仓库实际上时独立的两个仓库</li>
<li>解决方法：添加选项<code>--allow-unrelated-histories</code>解决问题<ul>
<li><code>git pull zhuoer dev --allow-unrelated-histories</code></li>
</ul>
</li>
</ul>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><ul>
<li><code>git clone &lt;url&gt;</code> : 克隆远程版本库</li>
<li><code>git init</code> : 初始化本地版本库</li>
</ul>
<h2 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h2><ul>
<li><code>git status</code> : 查看状态</li>
<li><code>git diff</code> : 查看变更内容</li>
<li><code>git add .</code> : 跟踪所有改动过的文件</li>
<li><code>git add &lt;file&gt;</code> : 跟踪指定的文件</li>
<li><code>git mv &lt;old&gt; &lt;new&gt;</code> : 文件改名</li>
<li><code>git rm &lt;file&gt;</code> : 删除文件</li>
<li><code>git commit -m &quot;commit message&quot;</code> : 提交所有更新过的文件</li>
<li><code>git commit --amend</code> : 修改最后一次提交</li>
</ul>
<h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><ul>
<li><code>git log</code> : 查看提交历史</li>
<li><code>git log -p &lt;file&gt;</code> : 查看指定文件的提交历史</li>
<li><code>git blame &lt;file&gt;</code> : 以列表方式查看指定文件的提交历史</li>
</ul>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul>
<li><code>git reset --     0  1.9G   0% /sys/fs/cgroup /dev/mmcblk0p7   16G   12G  3.1G  79% /data  HEAD</code> : 撤销工作目录中所有未提交文件的修改内容</li>
<li><code>git checkout HEAD &lt;file&gt;</code> : 撤销指定的未提交的修改内容</li>
<li><code>git revert &lt;commit&gt;</code> : 取消指定的提交</li>
</ul>
<h2 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h2><ul>
<li><code>git branch</code> : 显示所有本地分支</li>
<li><code>git checkout &lt;branch/tag&gt;</code> : 切换到指定分支或标签</li>
<li><code>git branch &lt;new-branch&gt;</code> : 创建新分支</li>
<li><code>git branch -d &lt;branch&gt;</code> : 删除本地分支</li>
<li><code>git tag</code> : 列出所有本地标签</li>
<li><code>git tag &lt;tagname&gt;</code> : 基于最新提交的创建标签</li>
<li><code>git tag -d &lt;tagname&gt;</code> : 删除标签</li>
<li><code>git checkout -b dev notes/dev</code> : 切换指定远程分支</li>
</ul>
<h2 id="合并和衍合"><a href="#合并和衍合" class="headerlink" title="合并和衍合"></a>合并和衍合</h2><ul>
<li><code>git merge &lt;branch&gt;</code> : 合并指定分支到当前分支</li>
<li><code>git rebase &lt;branch&gt;</code> : 衍合指定分支到当前分支</li>
</ul>
<h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><ul>
<li><code>git remote -v</code> : 查看远程版本库信息</li>
<li><code>git remote show &lt;remote&gt;</code> : 查看指定远程版本库信息</li>
<li><code>git remote add &lt;remote&gt; &lt;url&gt;</code> : 添加远程版本库</li>
<li><code>git fetch &lt;remote&gt;</code> : 从远程库获取代码</li>
<li><code>git pull &lt;remote&gt; &lt;branch&gt;</code> : 下载代码及快速合并</li>
<li><code>git push &lt;remote&gt; &lt;branch&gt;</code> : 上传代码及快速合并</li>
<li><code>git push &lt;remote&gt; :&lt;branch/tag-name&gt;</code> : 删除远程分支或标签</li>
<li><code>git push --tags</code> : 上传所有标签</li>
</ul>
<h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><ul>
<li><code>git pull origin master</code><ul>
<li><code>push</code> : 将本地仓库与远程仓库合并</li>
<li><code>-u</code> : 将本地仓库分支与远程仓库分支一起合并，就是说将master的分支也提交上去，这样就可以在远程仓库上看到在本地仓库的master中创建了多少分支。不加这个参数，只将当前的master与远程的合并，没有分支的历史纪录，也不能切换分支</li>
<li><code>origin</code> : 远程仓库的意思，如果这个仓库是远程的，那么必须使用这个选项</li>
<li><code>master</code> : 提交本地master分支仓库</li>
</ul>
</li>
</ul>
<h2 id="递归克隆"><a href="#递归克隆" class="headerlink" title="递归克隆"></a>递归克隆</h2><ul>
<li><code>git clone --recursive http://192.167.10.28/dagger/manager_node.git</code></li>
<li><code>recursive</code>选项会递归克隆项目下的所有git项目</li>
</ul>
<h2 id="撤销-git-add-并保留修改的方法"><a href="#撤销-git-add-并保留修改的方法" class="headerlink" title="撤销 git add 并保留修改的方法"></a>撤销 <code>git add</code> 并保留修改的方法</h2><ul>
<li><strong><code>git reset --mixed</code> – 撤销所有的已经<code>add</code>的文件</strong></li>
<li><code>git reset HEAD .</code> – 复制撤销某个文件或文件夹</li>
<li><code>git reset HEAD -filename</code> – 另外，可以使用<code>git status</code> ，git会告诉可以通过哪一个命令来执行操作</li>
</ul>
<h2 id="git从历史上的某一次提交处建立分支"><a href="#git从历史上的某一次提交处建立分支" class="headerlink" title="git从历史上的某一次提交处建立分支"></a>git从历史上的某一次提交处建立分支</h2><ul>
<li><code>git log --oneline --all --graph --decorate</code></li>
<li><code>git branch dev 3be5879</code></li>
</ul>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><ul>
<li><p><code>git remote add &lt;shortname&gt; &lt;url&gt;</code> ： 添加一个新的远程Git仓库，同时指定一个方便使用的简写.</p>
<ul>
<li><code>git remote add zhuoer http://192.167.10.28/dagger/zhuoer</code> ： 现在可以在命令行中使用字符串<code>zhuoer</code>来代替整个URL</li>
</ul>
</li>
<li><p><code>git fetch &lt;remote&gt;</code> : 从远程仓库中获得数据。这个命令会访问远程仓库，从中拉取所有还没有的数据。执行完成后，将会拥有那个远程仓库中所有分支的引用，可以随时合并或者查看。</p>
</li>
<li><p><strong>如果使用<code>clone</code>命令克隆了一个仓库，命令会自动将其添加为远程仓库并且默认以<code>origin</code>为简写</strong>。所以，<code>git fetch origin</code>会抓取克隆（或上一次抓取）后新推送的所有工作。</p>
<ul>
<li>注意：<code>git fetch</code>命令只会将数据下在到本地仓库，它并不会自动合并或者修改当前的工作，当准备好时，必须要手动将其合并入你的工作。</li>
</ul>
</li>
<li><p>如果当前分支设置了跟踪远程分支，那么可以使用<code>git pull</code>命令自动抓取后合并该远程分支到当前分支。</p>
</li>
<li><p>默认情况下，<code>git clone</code>命令会自动设置本地<code>master</code>分支跟踪克隆的远程仓库的<code>master</code>分支（或其他名字的默认分支）。运行<code>git pull</code>通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。）</p>
</li>
</ul>
<h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><ul>
<li><code>git push &lt;remote&gt; &lt;branch&gt;</code><ul>
<li>当你想要将<code>master</code>分支推送到<code>origin</code>服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器。</li>
</ul>
</li>
</ul>
<h2 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h2><ul>
<li><code>git remote show &lt;remote&gt;</code><ul>
<li>查看某一个远程仓库的更多信息</li>
<li>它同样会列出远程仓库的URL与跟踪分支的信息。它告诉你正在处于<code>master</code>分支，并且如果运行<code>git pull</code>，就会抓取所有的远程引用，然后将远程<code>master</code>分支合并到本地<code>master</code>分支，</li>
<li>它也会列出拉取到的所有远程引用。</li>
</ul>
</li>
</ul>
<h2 id="远程仓库的重命名与移除"><a href="#远程仓库的重命名与移除" class="headerlink" title="远程仓库的重命名与移除"></a>远程仓库的重命名与移除</h2><ul>
<li><p><code>git remote rename</code></p>
<ul>
<li>修改一个远程仓库的简写名</li>
<li>这个操作也会修改所有远程跟踪的分支名字</li>
</ul>
</li>
<li><p><code>git remote remove</code>或者<code>git remote rm</code></p>
<ul>
<li>移除一个远程仓库</li>
<li>一旦使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</li>
</ul>
</li>
</ul>
<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><ul>
<li><p><code>git tag</code></p>
<ul>
<li>在Git中列出已有的标签</li>
<li>按照通配符列出标签需要<code>-l</code>或者<code>--list</code>选项</li>
<li>如果只想要完整的标签列表，那么运行<code>git tag</code>就会默认假定你想要一个列表，它会直接列出来</li>
</ul>
</li>
<li><p>创建标签，Git支持两种标签：轻量标签(<code>lightweight</code>)与附注标签(<code>annotated</code>)</p>
<ul>
<li>轻量标签很像一个不会改变的分支–它只是某个特定提交的引用</li>
<li>附注标签是存储在Git数据库中的一个完整对象，它们是可以被校验的，其中包括打标签者的名字，电子邮件，地址，日期时间，此外还有一个标签信息，并且可以使用GNU Privacy Guard（GTG）签名并验证。</li>
</ul>
</li>
<li><p>通常会建议创建附注标签，这样可以拥有以上所有信息，但是如果只是想用一个临时的标签，或者因为某些原因不想要保存信息，那么也可以用轻量标签</p>
</li>
<li><p>附注标签的创建: <code>git tag -a v1.4 -m &quot;my version 1.4&quot;</code></p>
<ul>
<li><code>-m</code> : 指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会启动编辑其要求你输入信息</li>
</ul>
</li>
<li><p>推送标签</p>
<ul>
<li>git push origin v1.4</li>
</ul>
</li>
<li><p>轻量标签，本质上是将提交校验和存储到一个文件中–没有保存任何其他信息。</p>
</li>
<li><p>创建轻量标签，不需要使用<code>-a</code>, <code>-s</code>, <code>-m</code>选项，只需要提供标签名字：<code>git tag v1.4-lw</code></p>
</li>
<li><p>后期打标签</p>
<ul>
<li>要在提交上打标签，需要在命令的末尾指定提交的校验和（或部分校验和）</li>
<li><code>git tag -a v1.2 9fcaw1</code></li>
</ul>
</li>
<li><p>删除标签</p>
<ul>
<li>删除本地仓库上的标签，可以使用命令<code>git tag -d &lt;tagname&gt;</code><ul>
<li>注意：该命令并不会从任何远程仓库中移除这个标签，必须使用<code>git push &lt;remote&gt;:refs/tags/&lt;tagname&gt;</code>来更新远程仓库</li>
<li>第一种变体是：<code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code>，这种操作的含义是：将冒号前面的空值推送到远程标签名，从而高效地删除它</li>
<li>第二种更加直观的删除远程标签的方式是：<code>git push &lt;remote&gt; --delete &lt;tagname&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>通过使用<code>git show</code>可以看到标签信息和与之对应的提交信息</p>
</li>
</ul>
<h2 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h2><ul>
<li>Git并不会在输入部分命令时自动推断出想要的命令。如果不想每次都输入完整的Git命令，可以通过<code>git config</code>文件来轻松地为每一个命令设置一个别名。</li>
<li>例如：<ul>
<li><code>git config --global alias.co checkout</code></li>
<li><code>git config --global alias.br branch</code></li>
<li><code>git config --global alias.ci commit</code></li>
<li><code>git config --global alias.st status</code></li>
<li>这意味着，当要输入<code>git commit</code>时，只需要输入<code>git ci</code></li>
</ul>
</li>
<li>在创建认为应该存在的命令时，这个技术会很有用。<ul>
<li>例如：为了解决取消暂存文件的易用性问题，可以向Git中添加取消暂存别名,<code>git config --global alias.unstage &#39;reset HEAD --</code></li>
<li>通常也会添加一个<code>last</code>命令：<code>git config --global alias.last &#39;log -l HEAD</code>。这样，可以很轻松地看到最后一次提交</li>
</ul>
</li>
<li>Git只是简单地将别名替换为对应的命令。</li>
</ul>
<h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><ul>
<li><p>几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着可以把工作从开发主线上分离开来，以免影响开发主线。</p>
</li>
<li><p><strong>Git保存的不是文件的变化或者差异，而是一系列不同时刻的快照。</strong></p>
</li>
<li><p>Git的分支，其实质上仅仅是指向提交对象的可变指针。Git的默认分支名字是<code>master</code>，在多次提交操作之后，其实已经有一个指向最后哪个提交对象的<code>master</code>分支。<code>master</code>分支会在每次提交时自动向前移动。</p>
<ul>
<li>Git的<code>master</code>分支并不是一个特殊分支。它跟其他分支完全没有区别。之所以几乎每一个仓库都有<code>master</code>分支，是因为<code>git init</code>命令默认创建它，并且大多数人都懒得去改动它</li>
</ul>
</li>
<li><p><code>git branch testing</code> : 创建分支<code>testing</code>，这会在当前所在的提交对象上创建一个指针。那么，Git又是怎么知道当前在哪一个分支上呢？</p>
<ul>
<li>也很简单，它有一个名为<code>HEAD</code>的特殊指针。它是一个指针，指向当前所在的本地分支（可以把<code>HEAD</code>想象为当前分支的别名）</li>
<li>在本示例中，仍然在<code>master</code>分支上，因为<code>git branch</code>命令仅仅创建一个新分支，并不会自动切换到新分支中去</li>
</ul>
</li>
<li><p><code>git log --decorate</code> ： 查看各个分支当前所指的对象</p>
</li>
<li><p>分支切换:<code>git checkout testing</code>。如此以来，<code>HEAD</code>就指向<code>testing</code>分支了。</p>
</li>
<li><p>由于Git的分支实质上仅是包含所指对象校验和（长度为40的SHA-1值字符串）的文件，所以它的创建和销毁都异常高效</p>
</li>
</ul>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><ul>
<li><p>远程引用是对远程仓库的引用（指针），包括分支，标签等。</p>
</li>
<li><p>可以通过 <code>git ls-remote &lt;remote&gt;</code>来显示地获得远程引用的完整列表</p>
</li>
<li><p>或者通过<code>git remote show &lt;remote&gt;</code>获得远程分支的更多信息</p>
</li>
<li><p>更常见的做法是利用<strong>远程跟踪分支</strong>，远程跟踪分支是远程分支状态的引用，它们以<code>&lt;remote&gt;/&lt;branch&gt;</code>的形式命名</p>
<ul>
<li>例如：假设网络里由一个在<code>git.ourcompany.com</code>的Git服务器。如果从这里克隆，Git的<code>clone</code>命令会自动将其命名为<code>origin</code>，拉取它的所有数据，创建一个指向它的<code>master</code>分支的指针，并且在本地将其命名为<code>origin/master</code>。Git也会给你一个与<code>origin</code>的<code>master</code>分支在指向同一个地方的本地<code>master</code>分支，这样你就有工作的基础。</li>
<li><code>origin</code>并无特殊含义。远程仓库名字<code>origin</code>与分支名字<code>master</code>一样，在Git中并没有任何特别的含义一样。同时,<code>master</code>是当你运行<code>git init</code>时默认的起始分支名字。如果你运行<code>git clone -o booyah</code>，那么默认的远程分支名字将会是<code>booyah/master</code></li>
</ul>
</li>
<li><p><code>git push &lt;remote&gt; &lt;branch&gt;</code> ： 推送到某个分支</p>
</li>
<li><p>与给定的远程仓库同步数据，运行<code>git fetch &lt;remote&gt;</code>命令。</p>
<ul>
<li>示例：<code>git fetch a311d</code></li>
<li>这个命令查找<code>a311d</code>是哪一个服务器，从中抓取本地没有的数据，并且更新本地数据库，移动<code>a311d/master</code>指针到更新之后的位置。</li>
</ul>
</li>
<li><p><code>git pull</code> : 拉取</p>
<ul>
<li>当<code>git fetch</code>命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容，它只会获取数据然后让你自己合并</li>
<li><code>git pull</code>命令在大多数情况下它的含义是一个<code>git fetch</code>紧接着一个<code>git merge</code>命令</li>
</ul>
</li>
</ul>
<h2 id="如何避免每次输入密码"><a href="#如何避免每次输入密码" class="headerlink" title="如何避免每次输入密码"></a>如何避免每次输入密码</h2><ul>
<li>如果正在使用<code>HTTPS URL</code>来推送，Git服务器会询问用户名与密码。默认情况下它会在终端中提示服务器是否允许你进行推送</li>
<li>如果不想在每一个推送时都输入用户名与密码，可以设置一个<code>credential cache</code>。最简单的方式就是将其保存在内存中几分钟，可以简单地运行<code>git config --global credential.helper cache</code>来设置</li>
</ul>
<h2 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h2><ul>
<li>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。</li>
<li>跟踪分支是与远程分支有直接关系的本地分支。如果在一个跟踪分支上输入<code>git pull</code>，Git能够自动地识别去那个服务器上抓取，合并到哪个分支。</li>
<li>当克隆一个仓库时，它通常会自动地创建一个跟踪<code>origin/master</code>的<code>master</code>分支。</li>
<li>如果想设置其他的跟踪分支，或者是一个在其他远程仓库上的跟踪分支，简单的示例：<code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。这是一个十分常用的操作，所以Git提供了<code>--track</code>快捷方式</li>
<li>如果想要将本地分支与远程分支设置为不同的名字，可以使用命令<code>git checkout -b sf origin/serverfix</code></li>
</ul>
<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><ul>
<li>运行带有<code>--delete</code>选项的<code>git push</code>命令，用来删除一个远程分支，例如:<code>git push zhuoer --delete docker-mqtt</code></li>
<li>基本上这个命令做的只是从服务器上移除这个指针。Git服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</li>
</ul>
<h2 id="Git-子模块"><a href="#Git-子模块" class="headerlink" title="Git 子模块"></a>Git 子模块</h2><ul>
<li><p>使用场景：某个工作中的项目需要包含并使用另一个项目。也许是第三方库，或者独立开发的，用于多个父项目的库。现在问题是：把它们当作两个独立的项目，同时又想在一个项目中使用另一个</p>
</li>
<li><p>Git通过<strong>子模块</strong>来解决这个问题：子模块允许将一个Git仓库作为另一个Git仓库的子目录。它能够将另一个仓库克隆到自己的项目中，同时还可以保持提交的独立。</p>
</li>
<li><p>将一个已存在的Git仓库添加为正在工作的仓库的自模块：<code>git submodule add</code>命令后加上想要跟踪的项目的相对或者绝对URL来添加新的子模块。</p>
<ul>
<li>默认情况下，子模块会将子项目放到一个与仓库同名的目录中，如果想放到其他地方，可以在命令结尾添加一个不同的路径。</li>
</ul>
</li>
<li><p><code>.gitmodules</code>配置文件，保存了项目URL与已经拉取的本地目录之间的映射</p>
</li>
<li><p>我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。 你可以通过在 git submodule add 命令后面加上想要跟踪的项目的相对或绝对 URL 来添加新的子模块。 在本例中，我们将会添加一个名为 “DbConnector” 的库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule add https://github.com/chaconinc/DbConnector</span><br><span class="line">Cloning into <span class="string">&#x27;DbConnector&#x27;</span>...</span><br><span class="line">remote: Counting objects: 11, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (10/10), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure></li>
<li><p>默认情况下，子模块会将子项目放到一个与仓库同名的目录中，本例中是 “DbConnector”。 如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Eigen3/2024-05-22-Eigen_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Eigen3/2024-05-22-Eigen_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Eigen_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen3/" itemprop="url" rel="index"><span itemprop="name">Eigen3</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Eigen 第三方库基础知识</li>
<li>Eigen，仅包含头文件即可</li>
</ul>
<h2 id="eigen3-Eigen-MatrixBaseEigen-Vector3d-normalized-函数-详解"><a href="#eigen3-Eigen-MatrixBaseEigen-Vector3d-normalized-函数-详解" class="headerlink" title="eigen3 Eigen::MatrixBaseEigen::Vector3d::normalized()函数 详解"></a>eigen3 Eigen::MatrixBase<a href="Eigen::Vector3d">Eigen::Vector3d</a>::normalized()函数 详解</h2><p><code>Eigen::MatrixBase&lt;Eigen::Vector3d&gt;::normalized()</code> 函数用于返回一个单位向量，即输入向量的归一化版本。这个函数返回一个新的向量，该向量具有与原始向量相同的方向，但长度为1。</p>
<p>下面是一些关键的详解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Eigen::MatrixBase&lt;Eigen::Vector3d&gt;::<span class="built_in">normalized</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>返回类型：</strong> 返回类型是 <code>Eigen::MatrixBase&lt;Derived&gt;</code>，其中 <code>Derived</code> 表示输入矩阵或向量的派生类类型。</p>
</li>
<li><p><strong>用途：</strong> <code>normalized()</code> 函数用于将向量归一化，即将其缩放为单位长度。</p>
</li>
<li><p><strong>注意事项：</strong></p>
<ul>
<li>如果输入向量的长度为零，则 <code>normalized()</code> 会产生一个未定义的结果。</li>
<li>对于零向量，<code>normalized()</code> 返回与原始向量相同的零向量。</li>
<li><code>normalized()</code> 函数不会修改原始向量，而是返回一个新的归一化向量。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    Eigen::Vector3d normalized_v = v.<span class="built_in">normalized</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Normalized Vector: &quot;</span> &lt;&lt; normalized_v &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中，<code>normalized_v</code> 将包含 <code>v</code> 的单位向量。</p>
</li>
</ul>
<p>总的来说，<code>normalized()</code> 函数在Eigen库中是用于向量归一化的方便方法。归一化是在计算机图形学、机器学习和其他领域中经常使用的操作，它确保向量的长度为1，并保持原始向量的方向。</p>
<h2 id="Eigen-Isometry3d-类-详解"><a href="#Eigen-Isometry3d-类-详解" class="headerlink" title="Eigen::Isometry3d 类 详解"></a>Eigen::Isometry3d 类 详解</h2><p><code>Eigen::Isometry3d</code> 是Eigen库中的一个类，用于表示三维空间中的等距变换（Isometry Transformation），也称为刚体变换（Rigid Transformation）。等距变换包括平移和旋转，通常用于表示物体在三维空间中的姿态和位置。</p>
<p>以下是关于 <code>Eigen::Isometry3d</code> 类的详细信息：</p>
<p><strong>构造函数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Isometry3d transform = Eigen::Isometry3d::<span class="built_in">Identity</span>();</span><br></pre></td></tr></table></figure>

<p>构造函数用于创建一个等距变换，通常初始化为单位等距变换，表示物体的初始位置和姿态。</p>
<p><strong>成员函数</strong>：</p>
<ol>
<li><p><code>translation()</code>：<br>返回等距变换的平移部分，它是一个三维向量表示平移的位移。</p>
</li>
<li><p><code>translation()</code>（重载）：<br>设置等距变换的平移部分。</p>
</li>
<li><p><code>rotation()</code>：<br>返回等距变换的旋转部分，它是一个<code>Eigen::Matrix3d</code>表示旋转矩阵。</p>
</li>
<li><p><code>matrix()</code>：<br>返回等距变换的矩阵表示，是一个<code>Eigen::Matrix4d</code>矩阵。</p>
</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建等距变换，表示平移(1, 2, 3)并绕X轴旋转45度</span></span><br><span class="line">    Eigen::Isometry3d transform = Eigen::Isometry3d::<span class="built_in">Identity</span>();</span><br><span class="line">    transform.<span class="built_in">translation</span>() = Eigen::<span class="built_in">Vector3d</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line">    transform.<span class="built_in">rotate</span>(Eigen::<span class="built_in">AngleAxisd</span>(M_PI / <span class="number">4.0</span>, Eigen::Vector3d::<span class="built_in">UnitX</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取平移部分和旋转部分</span></span><br><span class="line">    Eigen::Vector3d translation = transform.<span class="built_in">translation</span>();</span><br><span class="line">    Eigen::Matrix3d rotation = transform.<span class="built_in">rotation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;平移部分：&quot;</span> &lt;&lt; translation.<span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;旋转部分：&quot;</span> &lt;&lt; std::endl &lt;&lt; rotation &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取等距变换的矩阵表示</span></span><br><span class="line">    Eigen::Matrix4d transform_matrix = transform.<span class="built_in">matrix</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;等距变换矩阵：&quot;</span> &lt;&lt; std::endl &lt;&lt; transform_matrix &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们创建了一个等距变换对象，并使用成员函数设置其平移部分和旋转部分。然后，我们分别获取了平移部分和旋转部分，并输出了等距变换的矩阵表示。</p>
<p><code>Eigen::Isometry3d</code> 类是Eigen库中用于表示三维等距变换的重要工具。它允许您方便地表示和操作物体在三维空间中的姿态和位置，这在机器人学、计算机图形学和仿真等领域中非常有用。</p>
<h2 id="Eigen-AngleAxisd-类-详解"><a href="#Eigen-AngleAxisd-类-详解" class="headerlink" title="Eigen::AngleAxisd 类 详解"></a>Eigen::AngleAxisd 类 详解</h2><p><code>Eigen::AngleAxisd</code> 是Eigen库中的一个类，用于表示轴角（Axis-Angle）形式的旋转。轴角表示是一种用于描述三维空间中的旋转的常见方式，它包括一个旋转轴和一个旋转角度。该类位于Eigen库的Eigen&#x2F;Geometry模块中。</p>
<p>以下是关于 <code>Eigen::AngleAxisd</code> 类的详细信息：</p>
<p><strong>构造函数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Eigen::<span class="built_in">AngleAxisd</span>(<span class="type">const</span> Scalar&amp; angle, <span class="type">const</span> Vector3d&amp; axis)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>angle</code>：旋转角度，以弧度表示。</li>
<li><code>axis</code>：旋转轴的单位向量。</li>
</ul>
<p>构造函数用于创建一个轴角表示的旋转，指定旋转角度和旋转轴。</p>
<p><strong>成员函数</strong>：</p>
<ol>
<li><p><code>angle()</code>：<br>返回轴角表示中的旋转角度（以弧度表示）。</p>
</li>
<li><p><code>axis()</code>：<br>返回轴角表示中的旋转轴，它是一个单位向量。</p>
</li>
<li><p><code>toRotationMatrix()</code>：<br>将轴角表示转换为旋转矩阵（<code>Eigen::Matrix3d</code>），这个矩阵可以用于执行坐标变换。</p>
</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建轴角表示的旋转（绕X轴旋转45度）</span></span><br><span class="line">    <span class="function">Eigen::AngleAxisd <span class="title">rotation</span><span class="params">(M_PI / <span class="number">4.0</span>, Eigen::Vector3d::UnitX())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取旋转角度和旋转轴</span></span><br><span class="line">    <span class="type">double</span> angle = rotation.<span class="built_in">angle</span>();</span><br><span class="line">    Eigen::Vector3d axis = rotation.<span class="built_in">axis</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;旋转角度 (弧度): &quot;</span> &lt;&lt; angle &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;旋转轴: &quot;</span> &lt;&lt; axis.<span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将轴角表示转换为旋转矩阵</span></span><br><span class="line">    Eigen::Matrix3d rotation_matrix = rotation.<span class="built_in">toRotationMatrix</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;旋转矩阵：&quot;</span> &lt;&lt; std::endl &lt;&lt; rotation_matrix &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们创建了一个轴角表示的旋转对象，并使用成员函数获取旋转角度和旋转轴。然后，我们使用 <code>toRotationMatrix()</code> 函数将轴角表示转换为旋转矩阵。</p>
<p><code>Eigen::AngleAxisd</code> 类是Eigen库中用于处理轴角旋转的重要工具，它使您能够方便地表示和操作旋转信息。您可以使用旋转矩阵来执行坐标变换，或将其与其他旋转进行组合。这对于机器人学、计算机图形学和仿真等领域非常有用。</p>
<h2 id="Eigen-Matrix3d-数据结构-详解"><a href="#Eigen-Matrix3d-数据结构-详解" class="headerlink" title="Eigen::Matrix3d 数据结构 详解"></a>Eigen::Matrix3d 数据结构 详解</h2><p><code>Eigen::Matrix3d</code> 是Eigen库中的一个数据结构，表示一个3x3的矩阵，其中<code>d</code>表示矩阵元素的数据类型为<code>double</code>。Eigen库是一个用于线性代数操作的C++库，提供了高性能的矩阵和向量运算，特别适用于数学和科学计算。</p>
<p><code>Eigen::Matrix3d</code> 可以用来表示各种线性代数和几何学中的3x3矩阵，如旋转矩阵、变换矩阵、协方差矩阵等。这个数据结构在计算机图形学、机器人学、物理模拟等领域中经常被使用。</p>
<p>以下是一些关于<code>Eigen::Matrix3d</code>的详细信息和常见操作：</p>
<ol>
<li><p><strong>构造函数</strong>：您可以使用多种构造函数创建<code>Eigen::Matrix3d</code>对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix3d mat1; <span class="comment">// 默认构造函数，创建零矩阵</span></span><br><span class="line"><span class="function">Eigen::Matrix3d <span class="title">mat2</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>)</span></span>; <span class="comment">// 从给定的元素创建矩阵</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>元素访问</strong>：您可以通过行和列索引来访问矩阵的元素。Eigen库支持使用<code>(i, j)</code>或<code>i</code>、<code>j</code>索引方式，其中<code>(i, j)</code>表示第<code>i</code>行、第<code>j</code>列的元素，<code>i</code>和<code>j</code>从0开始。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> element = <span class="built_in">mat2</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 访问第2行第3列的元素</span></span><br><span class="line"><span class="type">double</span> element_row_col = mat<span class="number">2.</span><span class="built_in">row</span>(<span class="number">1</span>)[<span class="number">2</span>]; <span class="comment">// 也可以使用行和列的方式访问</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>矩阵运算</strong>：您可以对<code>Eigen::Matrix3d</code>对象执行各种矩阵运算，如矩阵加法、矩阵乘法、矩阵转置等。Eigen库提供了丰富的运算符重载和成员函数来进行这些操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix3d result = mat1 + mat2; <span class="comment">// 矩阵加法</span></span><br><span class="line">Eigen::Matrix3d product = mat1 * mat2; <span class="comment">// 矩阵乘法</span></span><br><span class="line">Eigen::Matrix3d transposed = mat<span class="number">1.</span><span class="built_in">transpose</span>(); <span class="comment">// 矩阵转置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>单位矩阵</strong>：您可以使用<code>Eigen::Matrix3d::Identity()</code>来创建一个单位矩阵。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix3d identity = Eigen::Matrix3d::<span class="built_in">Identity</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>行和列操作</strong>：Eigen库提供了许多操作来处理矩阵的行和列，如获取行、列、设置行、列等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3d row_vector = mat<span class="number">2.</span><span class="built_in">row</span>(<span class="number">1</span>); <span class="comment">// 获取第2行</span></span><br><span class="line">Eigen::Vector3d col_vector = mat<span class="number">2.</span><span class="built_in">col</span>(<span class="number">2</span>); <span class="comment">// 获取第3列</span></span><br><span class="line">mat<span class="number">2.</span><span class="built_in">row</span>(<span class="number">0</span>) = Eigen::<span class="built_in">Vector3d</span>(<span class="number">10.0</span>, <span class="number">20.0</span>, <span class="number">30.0</span>); <span class="comment">// 设置第1行的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>其他操作</strong>：Eigen库还提供了许多其他操作，如求逆、行列式计算、特征值分解等。</p>
</li>
</ol>
<p><code>Eigen::Matrix3d</code> 是Eigen库中一个非常有用的数据结构，用于表示和处理3x3矩阵数据。您可以使用它来执行各种线性代数和几何计算。Eigen库还支持其他矩阵大小的数据结构，如<code>Eigen::Matrix4d</code>、<code>Eigen::MatrixXd</code>（动态大小矩阵）等，以满足不同的需求。</p>
<h2 id="Eigen-Vector3d-数据结构-详解"><a href="#Eigen-Vector3d-数据结构-详解" class="headerlink" title="Eigen::Vector3d  数据结构 详解"></a>Eigen::Vector3d  数据结构 详解</h2><p><code>Eigen::Vector3d</code> 是Eigen库中的一个数据结构，表示三维向量，其中<code>d</code>表示向量元素的数据类型为<code>double</code>。Eigen库是一个用于线性代数操作的C++库，提供了高性能的矩阵和向量运算，特别适用于数学和科学计算。</p>
<p><code>Eigen::Vector3d</code> 表示一个包含三个<code>double</code>类型元素的向量，通常用于表示三维空间中的位置、方向或其他三维向量数据。这个数据结构在机器人学、计算机图形学、物理模拟等领域中经常被使用。</p>
<p>以下是一些关于<code>Eigen::Vector3d</code>的详细信息和常见操作：</p>
<ol>
<li><p><strong>构造函数</strong>：您可以使用多种构造函数创建<code>Eigen::Vector3d</code>对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3d v1;           <span class="comment">// 默认构造函数，创建零向量 (0, 0, 0)</span></span><br><span class="line"><span class="function">Eigen::Vector3d <span class="title">v2</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>; <span class="comment">// 从给定的元素创建向量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>元素访问</strong>：您可以通过下标或成员函数来访问向量的元素。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = v2[<span class="number">0</span>]; <span class="comment">// 访问第一个元素（x坐标）</span></span><br><span class="line"><span class="type">double</span> y = v2[<span class="number">1</span>]; <span class="comment">// 访问第二个元素（y坐标）</span></span><br><span class="line"><span class="type">double</span> z = v2[<span class="number">2</span>]; <span class="comment">// 访问第三个元素（z坐标）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用成员函数</span></span><br><span class="line"><span class="type">double</span> x = v<span class="number">2.</span><span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> y = v<span class="number">2.</span><span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> z = v<span class="number">2.</span><span class="built_in">z</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>向量运算</strong>：您可以对<code>Eigen::Vector3d</code>对象执行各种向量运算，如加法、减法、点积、叉积等。Eigen库提供了丰富的运算符重载和成员函数来进行这些操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3d result = v1 + v2; <span class="comment">// 向量加法</span></span><br><span class="line">Eigen::Vector3d diff = v1 - v2;   <span class="comment">// 向量减法</span></span><br><span class="line"><span class="type">double</span> dot_product = v<span class="number">1.</span><span class="built_in">dot</span>(v2);  <span class="comment">// 点积</span></span><br><span class="line">Eigen::Vector3d cross_product = v<span class="number">1.</span><span class="built_in">cross</span>(v2); <span class="comment">// 叉积</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>归一化</strong>：您可以使用成员函数将向量归一化为单位向量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v<span class="number">2.</span><span class="built_in">normalize</span>(); <span class="comment">// 归一化v2为单位向量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>长度和距离</strong>：您可以使用成员函数计算向量的长度（模）或两个点之间的距离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> length = v<span class="number">2.</span><span class="built_in">norm</span>(); <span class="comment">// 向量的长度</span></span><br><span class="line"><span class="type">double</span> distance = (v1 - v2).<span class="built_in">norm</span>(); <span class="comment">// 两个点之间的距离</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>其他操作</strong>：Eigen库提供了许多其他操作，如向量的投影、反射、角度计算等。</p>
</li>
</ol>
<p><code>Eigen::Vector3d</code> 是Eigen库中一个非常有用的数据结构，用于表示和处理三维向量数据。您可以使用它来执行各种线性代数和几何计算。注意，Eigen库支持其他数据类型的向量，如<code>Eigen::Vector3f</code>（<code>float</code>类型元素）和<code>Eigen::Vector3i</code>（<code>int</code>类型元素）等，以满足不同的需求。</p>
<h2 id="Eigen-Vector3f-详解"><a href="#Eigen-Vector3f-详解" class="headerlink" title="Eigen::Vector3f 详解"></a>Eigen::Vector3f 详解</h2><p>在C++中，Eigen是一个开源的线性代数库，用于高效地进行矩阵和向量计算。<code>Eigen::Vector3f</code>是Eigen库中表示三维浮点数向量的数据类型。</p>
<p>下面是对<code>Eigen::Vector3f</code>的详细解释：</p>
<ol>
<li><p><strong>Eigen库</strong>：<br>Eigen是一个C++模板库，专注于线性代数运算。它提供了各种矩阵和向量操作，包括基本的线性代数运算、矩阵分解、特征值计算等。Eigen的设计目标是高性能和表达力，适用于各种科学计算和工程应用。</p>
</li>
<li><p><strong>Eigen::Vector3f</strong>：<br><code>Eigen::Vector3f</code>是Eigen库中的一个模板类，表示一个三维浮点数向量。这个向量类包含了三个浮点数字段，分别表示向量的 x、y 和 z 分量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3f v;  <span class="comment">// 声明一个三维浮点数向量</span></span><br><span class="line">v &lt;&lt; <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>; <span class="comment">// 设置向量的 x、y 和 z 分量</span></span><br></pre></td></tr></table></figure>

<p>在Eigen中，向量和矩阵都是模板类，它们提供了许多重载的操作符和函数，使得线性代数运算变得方便和高效。</p>
<p>使用<code>Eigen::Vector3f</code>时，您可以执行向量加法、减法、点积、叉积、标量乘法等操作，以及其他线性代数运算。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Eigen::Vector3f <span class="title">v1</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">v2</span><span class="params">(<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Eigen::Vector3f sum = v1 + v2;</span><br><span class="line"><span class="type">float</span> dotProduct = v<span class="number">1.</span><span class="built_in">dot</span>(v2);</span><br><span class="line">Eigen::Vector3f crossProduct = v<span class="number">1.</span><span class="built_in">cross</span>(v2);</span><br></pre></td></tr></table></figure>

<p>此外，Eigen还提供了丰富的线性代数函数，使您能够执行向量的归一化、取模、求距离、求角度等操作。</p>
</li>
</ol>
<p>总之，<code>Eigen::Vector3f</code>是Eigen库中用于表示三维浮点数向量的类型。它是Eigen库在处理线性代数运算时的基本构建块之一，方便高效地进行各种向量计算和分析。</p>
<h2 id="Eigen-是什么"><a href="#Eigen-是什么" class="headerlink" title="Eigen 是什么"></a>Eigen 是什么</h2><p>Eigen是一个用于线性代数运算的C++模板库。它提供了许多用于向量、矩阵、数组和其他线性代数对象的数学运算和操作。Eigen是一个开源库，具有高性能和易用性的特点，广泛用于科学计算、图形学、机器学习和机器人等领域。</p>
<p>以下是Eigen库的一些特点：</p>
<ol>
<li><p>高性能：Eigen通过使用表达式模板技术和编译时优化，能够生成高效的代码，提供快速的数值计算。</p>
</li>
<li><p>简洁易用：Eigen提供了简洁的API，使得进行线性代数运算变得直观和易于理解。它支持类似于数学符号的语法，使得代码更加清晰和可读。</p>
</li>
<li><p>丰富的功能：Eigen提供了广泛的线性代数运算功能，包括矩阵和向量的基本运算（如加法、乘法、转置等）、线性方程求解、特征值计算、奇异值分解、矩阵分解等。</p>
</li>
<li><p>跨平台支持：Eigen是一个纯头文件库，没有外部依赖，可以方便地在不同的操作系统和编译器上使用。</p>
</li>
<li><p>可扩展性：Eigen支持自定义类型和运算，可以与现有的代码和数据结构集成，并方便地扩展功能。</p>
</li>
</ol>
<p>Eigen的语法和用法类似于数学符号，使得编写线性代数相关的代码更加直观和易于维护。它被广泛应用于科学计算、机器学习、计算机图形学等领域，是C++中进行线性代数运算的常用工具库之一。</p>
<p>总结来说，Eigen是一个高性能、易用且功能丰富的C++线性代数库，用于进行矩阵、向量和其他线性代数对象的数学运算。</p>
<hr>
<h2 id="Eigen-详解"><a href="#Eigen-详解" class="headerlink" title="Eigen 详解"></a>Eigen 详解</h2><p>Eigen是一个C++模板库，用于进行线性代数运算和数值计算。它提供了丰富的线性代数功能，包括矩阵和向量的基本运算、线性方程求解、特征值计算、奇异值分解、矩阵分解等。以下是Eigen库的一些详细解释：</p>
<ol>
<li><p>数据结构：Eigen库通过模板类来定义不同类型的线性代数对象，如矩阵（Matrix）、向量（Vector）、数组（Array）等。这些对象可以具有不同的维度和数据类型，如动态大小或静态大小的矩阵。</p>
</li>
<li><p>数学运算：Eigen提供了大量的数学运算操作符和函数，使得进行线性代数运算变得方便和直观。例如，你可以使用运算符进行矩阵和向量的加法、减法、乘法和除法操作，还可以进行转置、逆矩阵、点积、叉积等运算。</p>
</li>
<li><p>线性方程求解：Eigen提供了多种方法来求解线性方程组，包括常规的LU分解、QR分解、Cholesky分解等。你可以使用这些方法来解决线性方程组、最小二乘问题和最小化问题等。</p>
</li>
<li><p>特征值和奇异值计算：Eigen支持计算矩阵的特征值和特征向量，以及奇异值分解。这些计算对于矩阵的分析和特征提取非常有用。</p>
</li>
<li><p>矩阵分解：Eigen提供了多种矩阵分解的方法，如LU分解、QR分解、Cholesky分解等。这些分解方法可以用于解决矩阵方程、计算矩阵的逆等问题。</p>
</li>
<li><p>数值计算性能：Eigen通过使用表达式模板技术和编译时优化，生成高效的代码，提供了出色的数值计算性能。它能够自动进行向量化和并行化处理，以充分利用现代计算机的硬件特性。</p>
</li>
<li><p>跨平台支持：Eigen是一个纯头文件库，没有外部依赖，可以在不同的操作系统和编译器上进行使用。它与标准的C++语法和库相容，易于集成到现有的C++项目中。</p>
</li>
</ol>
<p>Eigen是一个广泛应用于科学计算、机器学习、计算机图形学等领域的工具库。它提供了强大的线性代数功能和高性能的数值计算能力，使得进行复杂的数学运算变得更加简单和高效。</p>
<p>如果你需要更详细的信息和示例代码，可以参考Eigen官方文档和示例。</p>
<hr>
<h2 id="Eigen-官网"><a href="#Eigen-官网" class="headerlink" title="Eigen 官网"></a>Eigen 官网</h2><p>Eigen的官方网站是：<a target="_blank" rel="noopener" href="https://eigen.tuxfamily.org/">https://eigen.tuxfamily.org/</a></p>
<p>在Eigen官网上，你可以找到关于Eigen库的详细文档、示例代码、教程和其他资源。以下是一些在Eigen官网上可以找到的主要内容：</p>
<ol>
<li><p>文档：Eigen官网提供了全面的文档，包括用户手册、快速入门指南、API参考等。文档详细介绍了Eigen库的各个方面，包括使用方法、功能特性、使用示例等。</p>
</li>
<li><p>示例代码：Eigen官网提供了大量的示例代码，涵盖了各种线性代数运算和数值计算的常见用法。这些示例代码可以帮助你快速上手并理解Eigen库的使用方法。</p>
</li>
<li><p>教程：Eigen官网上提供了一些教程和指南，帮助你深入了解Eigen库的内部机制和高级功能。这些教程涵盖了Eigen的设计原理、性能优化技巧、高级数学运算等方面的内容。</p>
</li>
<li><p>下载和安装：Eigen官网提供了源代码的下载链接和安装指南。你可以根据自己的需要下载适合的版本，并按照安装指南进行配置和编译。</p>
</li>
<li><p>社区和支持：Eigen官网上有用户论坛和邮件列表，你可以在这里与其他用户交流经验、提问问题和寻求帮助。此外，官方网站还提供了联系开发团队的方式，以便于反馈bug、提供反馈和建议等。</p>
</li>
</ol>
<p>通过Eigen官方网站，你可以获取关于Eigen库的最新信息、更新、支持和社区交流。如果你对Eigen库有兴趣或需要使用它进行线性代数运算和数值计算，官方网站是一个很好的起点。</p>
<p>请注意，由于网站内容可能会有更新，建议你访问Eigen官方网站以获取最新的信息和资源。</p>
<hr>
<h2 id="Eigen-示例"><a href="#Eigen-示例" class="headerlink" title="Eigen 示例"></a>Eigen 示例</h2><p>以下是一个简单的示例，展示了Eigen库的基本用法和一些常见的线性代数运算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建矩阵</span></span><br><span class="line">    Eigen::Matrix3f A;</span><br><span class="line">    A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建向量</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解线性方程 Ax = b</span></span><br><span class="line">    Eigen::Vector3f x = A.<span class="built_in">lu</span>().<span class="built_in">solve</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Solution:\n&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算特征值和特征向量</span></span><br><span class="line">    <span class="function">Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix3f&gt; <span class="title">eigensolver</span><span class="params">(A)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (eigensolver.<span class="built_in">info</span>() != Eigen::Success) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to compute eigenvalues!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Eigenvalues:\n&quot;</span> &lt;&lt; eigensolver.<span class="built_in">eigenvalues</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Eigenvectors:\n&quot;</span> &lt;&lt; eigensolver.<span class="built_in">eigenvectors</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了一个3x3的矩阵A和一个3维向量b。然后，使用A.lu().solve(b)求解线性方程Ax &#x3D; b，得到解x。我们输出了解x的值。</p>
<p>接下来，我们使用Eigen库的SelfAdjointEigenSolver来计算矩阵A的特征值和特征向量。通过eigensolver.eigenvalues()和eigensolver.eigenvectors()，我们分别获取了特征值和特征向量，并将它们输出到控制台。</p>
<p>请确保在使用这个示例之前，已经正确安装了Eigen库，并将其包含路径配置正确。</p>
<p>这只是Eigen库的一个简单示例，Eigen库还提供了许多其他功能和操作，如矩阵乘法、逆矩阵、奇异值分解等。你可以在Eigen的官方文档和示例中找到更多详细的用法和示例代码。</p>
<hr>
<h2 id="Eigen-安装第三方库"><a href="#Eigen-安装第三方库" class="headerlink" title="Eigen 安装第三方库"></a>Eigen 安装第三方库</h2><p>在Linux系统上安装Eigen库可以按照以下步骤进行操作：</p>
<ol>
<li><p>打开终端，并确保你的系统已经安装了C++编译器和CMake工具。</p>
</li>
<li><p>下载Eigen库的源代码。你可以从Eigen的官方网站（<a target="_blank" rel="noopener" href="https://eigen.tuxfamily.org/%EF%BC%89%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9%E5%8C%85%EF%BC%8C%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8Git%E8%BF%9B%E8%A1%8C%E5%85%8B%E9%9A%86%E3%80%82">https://eigen.tuxfamily.org/）下载最新版本的源代码压缩包，或者使用Git进行克隆。</a></p>
<p>例如，使用Git进行克隆：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.com/libeigen/eigen.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入Eigen源代码的目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd eigen</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个用于构建Eigen库的目录，并进入该目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行CMake命令生成构建文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用make命令进行编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>（可选）运行make install命令将库安装到系统目录中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>注意：执行<code>make install</code>命令可能需要root权限。</p>
</li>
</ol>
<p>现在，你已经成功在Linux系统上安装了Eigen库。你可以在自己的C++项目中包含Eigen的头文件，并链接Eigen库进行使用。</p>
<p>例如，在你的C++源文件中，使用以下方式包含Eigen的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>然后，你就可以使用Eigen库提供的各种功能进行线性代数运算和数值计算了。</p>
<p>请注意，安装过程中的具体命令可能会因系统环境和Eigen库的版本而有所不同。建议在安装过程中仔细阅读Eigen的文档，并按照其中的指导进行操作。</p>
<p>另外，如果你使用的是特定的Linux发行版，也可以尝试通过包管理器安装Eigen库。例如，使用apt包管理器安装Eigen：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libeigen3-dev</span><br></pre></td></tr></table></figure>

<p>这将自动安装Eigen库及其相关的开发文件到系统中，使你能够在C++项目中直接使用Eigen库。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>在使用Eigen库时，你可以根据需要包含不同的头文件。以下是一些常用的Eigen头文件：</p>
<ol>
<li><p><code>Eigen/Dense</code>：包含了Eigen库的核心功能，如矩阵、向量和数组的定义和运算符重载。</p>
</li>
<li><p><code>Eigen/Core</code>：提供了Eigen库的基本功能和类型定义，是<code>Eigen/Dense</code>头文件的核心部分。</p>
</li>
<li><p><code>Eigen/Eigenvalues</code>：包含了计算矩阵特征值和特征向量的功能。</p>
</li>
<li><p><code>Eigen/SVD</code>：提供了奇异值分解（Singular Value Decomposition，SVD）的功能。</p>
</li>
<li><p><code>Eigen/QR</code>：提供了QR分解的功能。</p>
</li>
<li><p><code>Eigen/LU</code>：提供了LU分解的功能。</p>
</li>
<li><p><code>Eigen/Cholesky</code>：提供了Cholesky分解的功能。</p>
</li>
<li><p><code>Eigen/Geometry</code>：包含了用于几何计算的功能，如旋转矩阵、变换矩阵等。</p>
</li>
</ol>
<p>这只是一小部分常用的Eigen头文件。根据你的具体需求，你可能还需要包含其他特定的头文件。Eigen库的头文件结构清晰，你可以根据你的具体使用情况选择包含适当的头文件。</p>
<p>例如，在你的C++源文件中，你可以按照以下方式包含Eigen库的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span>          <span class="comment">// 包含核心功能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Eigenvalues&gt;</span>    <span class="comment">// 计算特征值和特征向量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/SVD&gt;</span>            <span class="comment">// 奇异值分解</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/QR&gt;</span>             <span class="comment">// QR分解</span></span></span><br></pre></td></tr></table></figure>

<p>请注意，在包含Eigen库的头文件之前，确保你已经正确安装并配置了Eigen库。同时，根据你的操作系统和安装方式，可能需要调整头文件的路径。</p>
<p>希望这些信息能帮助你使用Eigen库进行C++编程！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/EtherCat/2024-05-22-ethercat_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/EtherCat/2024-05-22-ethercat_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">EtherCat 理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/EtherCat/" itemprop="url" rel="index"><span itemprop="name">EtherCat</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ethercat的理论基础知识</li>
</ul>
<h2 id="可能出现从站依次松闸现象的原因有哪些"><a href="#可能出现从站依次松闸现象的原因有哪些" class="headerlink" title="可能出现从站依次松闸现象的原因有哪些"></a>可能出现从站依次松闸现象的原因有哪些</h2><p>EtherCAT 从站<strong>依次松闸</strong>（即从站的执行机构或电机控制器按顺序解锁&#x2F;启动，而不是同时执行）可能由以下原因引起：</p>
<hr>
<h2 id="1-主站状态机控制问题"><a href="#1-主站状态机控制问题" class="headerlink" title="1. 主站状态机控制问题"></a><strong>1. 主站状态机控制问题</strong></h2><ul>
<li>EtherCAT 从站需要经过 <strong>Init → Pre-Op → Safe-Op → OP</strong> 状态转换才能正式运行。</li>
<li>如果主站没有同时对所有从站发送 <strong>状态切换命令</strong>，可能导致<strong>从站依次进入 OP 状态</strong>，从而导致依次松闸。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 在主站程序中，确保所有从站在<strong>同一周期</strong>内切换到 OP 状态，而不是顺序执行。</p>
<hr>
<h2 id="2-同步机制（Distributed-Clocks-DC）问题"><a href="#2-同步机制（Distributed-Clocks-DC）问题" class="headerlink" title="2. 同步机制（Distributed Clocks, DC）问题"></a><strong>2. 同步机制（Distributed Clocks, DC）问题</strong></h2><ul>
<li><strong>从站时钟不同步</strong>：如果使用 <strong>DC（分布式时钟）模式</strong>，但从站的时钟没有正确同步，不同从站可能会在不同的时间点进入 OP 状态。</li>
<li><strong>时钟漂移</strong>：某些从站可能会<strong>比其他从站慢</strong>进入 OP 状态，导致松闸的时间差异。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 在主站配置中检查 DC 设置，确保所有从站的时钟同步。<br>✅ 通过 <code>dcOffset</code> 进行时钟补偿，使所有从站的启动时间一致。</p>
<hr>
<h2 id="3-PDO-映射或过程数据更新问题"><a href="#3-PDO-映射或过程数据更新问题" class="headerlink" title="3. PDO 映射或过程数据更新问题"></a><strong>3. PDO 映射或过程数据更新问题</strong></h2><ul>
<li>EtherCAT 采用 <strong>PDO（过程数据对象）</strong> 进行输入&#x2F;输出数据交换。</li>
<li>如果 <strong>PDO 更新不一致</strong> 或者 <strong>某些从站的数据没有及时刷新</strong>，会导致<strong>某些从站较晚接收到松闸指令</strong>。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 在主站配置中，确保所有从站的 PDO <strong>在同一周期内更新</strong>。<br>✅ 使用 <strong>周期同步模式（Cyclic Synchronous Mode）</strong> 以确保所有从站同时执行操作。</p>
<hr>
<h2 id="4-设备响应时间差异"><a href="#4-设备响应时间差异" class="headerlink" title="4. 设备响应时间差异"></a><strong>4. 设备响应时间差异</strong></h2><ul>
<li>不同从站的<strong>硬件响应时间不同</strong>（如伺服驱动器、电磁阀、继电器等）。</li>
<li>某些从站可能需要<strong>更长的初始化时间</strong>，导致它们比其他从站<strong>晚进入 OP 状态</strong>。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 在主站程序中，<strong>等待所有从站进入 OP 状态后再统一发送松闸指令</strong>。<br>✅ 使用 <strong>EtherCAT 总线诊断工具</strong> 检查从站进入 OP 状态的时间是否一致。</p>
<hr>
<h2 id="5-网络拓扑和通信延迟"><a href="#5-网络拓扑和通信延迟" class="headerlink" title="5. 网络拓扑和通信延迟"></a><strong>5. 网络拓扑和通信延迟</strong></h2><ul>
<li>EtherCAT 采用<strong>菊花链结构</strong>，如果<strong>总线负载过高</strong>或<strong>链路有异常</strong>，可能导致数据包在不同从站之间传输时间不同。</li>
<li>这种情况下，<strong>靠近主站的从站可能会比远离主站的从站更早收到指令</strong>，导致依次松闸。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 使用 EtherCAT 网络分析工具（如 Wireshark + EtherCAT 插件）检查数据包延迟。<br>✅ 在<strong>高负载场景下</strong>，优化 PDO 更新频率，避免总线数据阻塞。  </p>
<hr>
<h2 id="6-设备上电顺序不一致"><a href="#6-设备上电顺序不一致" class="headerlink" title="6. 设备上电顺序不一致"></a><strong>6. 设备上电顺序不一致</strong></h2><ul>
<li>如果<strong>从站上电时间不同</strong>，即某些设备比其他设备<strong>晚启动</strong>，则可能导致它们进入 OP 状态的时间不同。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 确保所有从站<strong>同时上电</strong>，或者在主站程序中<strong>等待所有设备启动后再进入 OP 状态</strong>。</p>
<hr>
<h2 id="7-触发信号或启动命令不同步"><a href="#7-触发信号或启动命令不同步" class="headerlink" title="7. 触发信号或启动命令不同步"></a><strong>7. 触发信号或启动命令不同步</strong></h2><ul>
<li>如果松闸依赖于<strong>外部触发信号</strong>（如数字输入 DI、PLC 触发），而该信号的传播或执行时间不同，也会导致从站<strong>依次解锁</strong>。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 检查<strong>触发信号</strong>是否<strong>同步</strong>发送到所有从站。<br>✅ 在主站逻辑中，使用 <strong>全局触发信号</strong> 或 <strong>基于 DC 的同步触发</strong> 来确保所有设备同时执行动作。</p>
<hr>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>EtherCAT 从站依次松闸的常见原因包括：</p>
<table>
<thead>
<tr>
<th><strong>原因类别</strong></th>
<th><strong>可能问题</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>主站状态机</strong></td>
<td>主站未同步切换 OP</td>
<td>在主站程序中确保所有从站同步进入 OP</td>
</tr>
<tr>
<td><strong>DC 时钟同步</strong></td>
<td>时钟未同步、漂移</td>
<td>确保所有从站 DC 同步</td>
</tr>
<tr>
<td><strong>PDO 更新</strong></td>
<td>数据未及时刷新</td>
<td>确保所有从站的 PDO 在同一周期内更新</td>
</tr>
<tr>
<td><strong>设备响应时间</strong></td>
<td>设备处理速度不同</td>
<td>统一等待所有设备进入 OP</td>
</tr>
<tr>
<td><strong>网络拓扑</strong></td>
<td>总线负载高，数据延迟</td>
<td>优化数据更新频率，检查总线健康状态</td>
</tr>
<tr>
<td><strong>上电顺序</strong></td>
<td>设备启动时间不同</td>
<td>确保所有从站同时上电</td>
</tr>
<tr>
<td><strong>触发信号不同步</strong></td>
<td>触发时间不同</td>
<td>使用 DC 触发或全局信号同步</td>
</tr>
</tbody></table>
<p>如果 EtherCAT 从站出现 <strong>依次松闸</strong> 现象，可以从 <strong>主站状态机、DC 时钟、PDO 更新、网络拓扑、设备响应、触发信号</strong> 等方面进行检查和优化。</p>
<h2 id="EtherCAT-从站有几种状态"><a href="#EtherCAT-从站有几种状态" class="headerlink" title="EtherCAT 从站有几种状态"></a>EtherCAT 从站有几种状态</h2><p>在 EtherCAT（Ethernet for Control Automation Technology）协议中，<strong>从站（Slave）</strong> 具有 <strong>四种状态（State Machine）</strong>，每个状态代表不同的操作模式。  </p>
<hr>
<h2 id="EtherCAT-从站的-4-种状态"><a href="#EtherCAT-从站的-4-种状态" class="headerlink" title="EtherCAT 从站的 4 种状态"></a><strong>EtherCAT 从站的 4 种状态</strong></h2><p>从站状态由 <strong>AL 状态机（Application Layer State Machine）</strong> 控制，状态包括：</p>
<ol>
<li><strong>初始化（Init）</strong></li>
<li><strong>预操作（Pre-Operational, Pre-Op）</strong></li>
<li><strong>安全操作（Safe-Operational, Safe-Op）</strong></li>
<li><strong>操作（Operational, OP）</strong></li>
</ol>
<p>EtherCAT <strong>主站（Master）</strong> 通过 <strong>AL 控制寄存器</strong> 控制从站的状态转换。</p>
<hr>
<h3 id="1-初始化（Init）"><a href="#1-初始化（Init）" class="headerlink" title="1. 初始化（Init）"></a><strong>1. 初始化（Init）</strong></h3><ul>
<li><strong>功能</strong>：从站上电后进入 <strong>初始状态</strong>，此时只进行 <strong>基础通信配置</strong>，还不能进行过程数据（Process Data）交换。</li>
<li><strong>特性</strong>：<ul>
<li>只能访问 <strong>物理层和链路层</strong>（EtherCAT 层）。</li>
<li>仅支持 <strong>CoE&#x2F;SDO</strong>（对象字典）等<strong>配置数据通信</strong>。</li>
<li>从站必须完成 <strong>寄存器初始化</strong> 和 <strong>EEPROM 读取</strong>。</li>
</ul>
</li>
<li><strong>状态转换</strong>：<ul>
<li><strong>进入 Pre-Op</strong>：主站发送 <code>Init → Pre-Op</code> 命令。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-预操作（Pre-Operational-Pre-Op）"><a href="#2-预操作（Pre-Operational-Pre-Op）" class="headerlink" title="2. 预操作（Pre-Operational, Pre-Op）"></a><strong>2. 预操作（Pre-Operational, Pre-Op）</strong></h3><ul>
<li><strong>功能</strong>：在该状态下，从站允许主站访问<strong>对象字典（Object Dictionary）</strong> 进行参数配置，但仍不能交换过程数据。</li>
<li><strong>特性</strong>：<ul>
<li>允许<strong>CoE（CANopen over EtherCAT）</strong> 进行<strong>SDO 参数传输</strong>。</li>
<li>不能进行实时过程数据交换（PDO 无效）。</li>
<li>适用于 <strong>参数下载、设备初始化</strong> 等任务。</li>
</ul>
</li>
<li><strong>状态转换</strong>：<ul>
<li><strong>进入 Safe-Op</strong>：主站配置完成后，发送 <code>Pre-Op → Safe-Op</code> 命令。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-安全操作（Safe-Operational-Safe-Op）"><a href="#3-安全操作（Safe-Operational-Safe-Op）" class="headerlink" title="3. 安全操作（Safe-Operational, Safe-Op）"></a><strong>3. 安全操作（Safe-Operational, Safe-Op）</strong></h3><ul>
<li><strong>功能</strong>：从站可以进行<strong>输入数据的读取</strong>，但不能修改输出数据（即，不能改变执行机构的状态）。</li>
<li><strong>特性</strong>：<ul>
<li>允许主站<strong>读取</strong>从站的输入数据。</li>
<li>但不允许主站<strong>写入</strong>从站的输出数据（防止设备误动作）。</li>
<li>适用于<strong>调试过程</strong>，确保系统在操作前数据正确。</li>
</ul>
</li>
<li><strong>状态转换</strong>：<ul>
<li><strong>进入 OP（Operational）</strong>：主站确认输入数据正确后，发送 <code>Safe-Op → OP</code> 命令。</li>
<li><strong>返回 Pre-Op</strong>：如果数据异常，主站可发送 <code>Safe-Op → Pre-Op</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-操作（Operational-OP）"><a href="#4-操作（Operational-OP）" class="headerlink" title="4. 操作（Operational, OP）"></a><strong>4. 操作（Operational, OP）</strong></h3><ul>
<li><strong>功能</strong>：从站进入<strong>全功能状态</strong>，主站可以<strong>读取输入数据、写入输出数据</strong>，正式运行 EtherCAT 过程数据（PDO）。</li>
<li><strong>特性</strong>：<ul>
<li>允许<strong>完整过程数据通信</strong>（输入&#x2F;输出）。</li>
<li>适用于<strong>正常生产、设备运行</strong>。</li>
</ul>
</li>
<li><strong>状态转换</strong>：<ul>
<li><strong>返回 Safe-Op</strong>：如果出现紧急情况（如数据错误），主站可发送 <code>OP → Safe-Op</code> 命令。</li>
<li><strong>返回 Pre-Op</strong>：如果主站要修改配置，主站可发送 <code>OP → Pre-Op</code> 命令。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="状态转换流程"><a href="#状态转换流程" class="headerlink" title="状态转换流程"></a><strong>状态转换流程</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Init → Pre-Op（初始化完成，进入参数配置）</span><br><span class="line">2. Pre-Op → Safe-Op（参数配置完成，输入数据可用）</span><br><span class="line">3. Safe-Op → OP（进入全功能模式，允许数据输入/输出）</span><br><span class="line">4. OP → Safe-Op/Pre-Op/Init（错误或主站请求降级）</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ethercat.org/download/press/ethercat_state_machine.png"></p>
<hr>
<h2 id="异常状态处理"><a href="#异常状态处理" class="headerlink" title="异常状态处理"></a><strong>异常状态处理</strong></h2><p>如果从站发生错误，它可能：</p>
<ul>
<li><strong>进入 “错误状态”（Error）</strong>（通常表现为 Safe-Op 或 Init）。</li>
<li><strong>重启后回到 Init 状态</strong>，等待重新进入 OP。</li>
</ul>
<p>主站可以通过：</p>
<ul>
<li><strong>检查 AL 状态寄存器</strong></li>
<li><strong>读取诊断信息</strong></li>
<li><strong>尝试重新配置</strong></li>
</ul>
<p>来判断从站的状态并进行恢复。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>EtherCAT 从站有 4 种状态：</p>
<table>
<thead>
<tr>
<th><strong>状态</strong></th>
<th><strong>能否进行 PDO 通信？</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Init</strong></td>
<td>❌ 不能</td>
<td>上电、基础通信</td>
</tr>
<tr>
<td><strong>Pre-Op</strong></td>
<td>❌ 不能</td>
<td>参数配置</td>
</tr>
<tr>
<td><strong>Safe-Op</strong></td>
<td>✅ 只能读取输入</td>
<td>调试、验证</td>
</tr>
<tr>
<td><strong>OP（Operational）</strong></td>
<td>✅ 允许输入&#x2F;输出</td>
<td>正常运行</td>
</tr>
</tbody></table>
<p>EtherCAT 主站通过 <strong>状态机控制</strong> 从站，确保从 <strong>初始化 → 预操作 → 安全操作 → 运行</strong> 的<strong>安全平稳过渡</strong>。</p>
<h2 id="ethercat-主站与从站通讯协议"><a href="#ethercat-主站与从站通讯协议" class="headerlink" title="ethercat 主站与从站通讯协议"></a>ethercat 主站与从站通讯协议</h2><p>EtherCAT（<strong>Ethernet for Control Automation Technology</strong>）是一种基于<strong>以太网</strong>的实时工业网络协议，广泛用于<strong>运动控制、I&#x2F;O、传感器、机器人</strong>等领域。EtherCAT 的核心是<strong>主站（Master）</strong>和<strong>从站（Slave）</strong>之间的高速数据交换，采用<strong>主从架构</strong>。  </p>
<hr>
<h2 id="1-EtherCAT-通讯协议架构"><a href="#1-EtherCAT-通讯协议架构" class="headerlink" title="1. EtherCAT 通讯协议架构"></a><strong>1. EtherCAT 通讯协议架构</strong></h2><p>EtherCAT 采用<strong>以太网帧</strong>进行通信，但与标准以太网不同，EtherCAT 具有以下特点：</p>
<ul>
<li><strong>主站（Master）</strong> 负责发送和处理EtherCAT 数据包，不需要专用芯片，可由普通网卡或专用控制器实现。</li>
<li><strong>从站（Slave）</strong> 设备按照帧数据处理规则响应主站请求，通常使用<strong>EtherCAT专用芯片</strong>（如<strong>ET1100</strong>）。</li>
<li><strong>循环拓扑</strong> 方式（支持菊花链、环形、树形等），数据帧沿<strong>单向传输</strong>。</li>
<li><strong>帧穿透</strong> 机制：数据包在传输时直接在从站设备间传递，无需存储转发。</li>
</ul>
<hr>
<h2 id="2-EtherCAT-通讯流程"><a href="#2-EtherCAT-通讯流程" class="headerlink" title="2. EtherCAT 通讯流程"></a><strong>2. EtherCAT 通讯流程</strong></h2><p>EtherCAT 通讯采用主站主动轮询方式：</p>
<ol>
<li><p><strong>主站发送EtherCAT帧</strong></p>
<ul>
<li>主站生成数据帧，并包含多个<strong>过程数据对象（PDO）</strong>。</li>
<li>帧内携带多个从站的数据请求&#x2F;指令。</li>
</ul>
</li>
<li><p><strong>从站解析和处理帧</strong></p>
<ul>
<li>帧经过从站时，<strong>从站在数据帧上直接读写相关数据区域</strong>，而不是接收整个帧再处理。</li>
<li>这极大提升了通信效率，避免了传统以太网的<strong>存储转发</strong>延迟。</li>
</ul>
</li>
<li><p><strong>主站接收并解析返回数据</strong></p>
<ul>
<li>当帧经过所有从站后，数据会返回给主站，主站读取修改后的数据。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-EtherCAT-帧结构"><a href="#3-EtherCAT-帧结构" class="headerlink" title="3. EtherCAT 帧结构"></a><strong>3. EtherCAT 帧结构</strong></h2><p>EtherCAT 帧基于标准<strong>IEEE 802.3 以太网帧</strong>，但采用特殊的<strong>EtherType &#x3D; 0x88A4</strong>，表示是EtherCAT数据帧。</p>
<p>EtherCAT 数据帧结构如下：</p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>长度（字节）</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>目标MAC地址</td>
<td>6</td>
<td>目的设备MAC</td>
</tr>
<tr>
<td>源MAC地址</td>
<td>6</td>
<td>发送设备MAC</td>
</tr>
<tr>
<td>EtherType</td>
<td>2</td>
<td>固定为 0x88A4</td>
</tr>
<tr>
<td>EtherCAT数据</td>
<td>46-1500</td>
<td>实际数据，包含多个命令</td>
</tr>
<tr>
<td>CRC校验</td>
<td>4</td>
<td>以太网帧校验</td>
</tr>
</tbody></table>
<p>EtherCAT数据部分主要包含：</p>
<ul>
<li><strong>命令头（CMD Header）</strong><ul>
<li>包含<strong>命令类型（LRW、APRD、APWR、BRD等）</strong>，目标<strong>从站地址</strong>，数据长度等信息。</li>
</ul>
</li>
<li><strong>过程数据（Process Data）</strong><ul>
<li>具体的输入&#x2F;输出数据内容。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-主要EtherCAT通信命令"><a href="#4-主要EtherCAT通信命令" class="headerlink" title="4. 主要EtherCAT通信命令"></a><strong>4. 主要EtherCAT通信命令</strong></h2><p>EtherCAT 主站与从站的通讯主要基于以下<strong>命令类型</strong>：</p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>缩写</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>逻辑读取</td>
<td><strong>LRD</strong></td>
<td>读取过程数据</td>
</tr>
<tr>
<td>逻辑写入</td>
<td><strong>LWR</strong></td>
<td>写入过程数据</td>
</tr>
<tr>
<td>逻辑读写</td>
<td><strong>LRW</strong></td>
<td>读写数据，最常用</td>
</tr>
<tr>
<td>自动增量读取</td>
<td><strong>APRD</strong></td>
<td>按自动增量地址读取</td>
</tr>
<tr>
<td>自动增量写入</td>
<td><strong>APWR</strong></td>
<td>按自动增量地址写入</td>
</tr>
<tr>
<td>自动增量读写</td>
<td><strong>APRW</strong></td>
<td>读写数据，并自动增量</td>
</tr>
<tr>
<td>广播读取</td>
<td><strong>BRD</strong></td>
<td>读取所有从站数据</td>
</tr>
<tr>
<td>广播写入</td>
<td><strong>BWR</strong></td>
<td>写入所有从站数据</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-EtherCAT-工作模式"><a href="#5-EtherCAT-工作模式" class="headerlink" title="5. EtherCAT 工作模式"></a><strong>5. EtherCAT 工作模式</strong></h2><p>EtherCAT 主要有以下<strong>4种工作模式</strong>：</p>
<h3 id="1）自由运行模式（Free-Run-Mode）"><a href="#1）自由运行模式（Free-Run-Mode）" class="headerlink" title="1）自由运行模式（Free Run Mode）"></a><strong>1）自由运行模式（Free Run Mode）</strong></h3><ul>
<li>主站<strong>不停发送数据</strong>，不依赖同步时钟。</li>
<li>适用于简单IO控制，不需要高精度同步。</li>
</ul>
<h3 id="2）同步管理模式（SM-Sync-Mode）"><a href="#2）同步管理模式（SM-Sync-Mode）" class="headerlink" title="2）同步管理模式（SM Sync Mode）"></a><strong>2）同步管理模式（SM Sync Mode）</strong></h3><ul>
<li>通过<strong>同步管理器（Sync Manager）</strong>控制数据交换。</li>
<li>适用于<strong>离散IO</strong>，但同步性较低。</li>
</ul>
<h3 id="3）分布式时钟模式（DC-Mode）"><a href="#3）分布式时钟模式（DC-Mode）" class="headerlink" title="3）分布式时钟模式（DC Mode）"></a><strong>3）分布式时钟模式（DC Mode）</strong></h3><ul>
<li>采用<strong>从站时钟同步机制</strong>，主站下发时间戳，从站调整本地时钟。</li>
<li>适用于<strong>高精度运动控制</strong>，同步精度可达<strong>纳秒级</strong>。</li>
</ul>
<h3 id="4）周期同步模式（Cyclic-Sync-Mode）"><a href="#4）周期同步模式（Cyclic-Sync-Mode）" class="headerlink" title="4）周期同步模式（Cyclic Sync Mode）"></a><strong>4）周期同步模式（Cyclic Sync Mode）</strong></h3><ul>
<li>类似DC模式，但主站以<strong>固定周期</strong>发送数据。</li>
<li>适用于<strong>实时性要求高的应用</strong>（如伺服驱动）。</li>
</ul>
<hr>
<h2 id="6-EtherCAT与其他工业总线对比"><a href="#6-EtherCAT与其他工业总线对比" class="headerlink" title="6. EtherCAT与其他工业总线对比"></a><strong>6. EtherCAT与其他工业总线对比</strong></h2><table>
<thead>
<tr>
<th><strong>总线类型</strong></th>
<th><strong>通信方式</strong></th>
<th><strong>同步精度</strong></th>
<th><strong>通信速率</strong></th>
<th><strong>优点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CANopen</td>
<td>轮询+事件触发</td>
<td>毫秒级</td>
<td>1Mbps</td>
<td>成熟稳定，成本低</td>
</tr>
<tr>
<td>PROFINET</td>
<td>以太网+RT&#x2F;IRT</td>
<td>微秒级</td>
<td>100Mbps</td>
<td>兼容性好，普及广</td>
</tr>
<tr>
<td>EtherCAT</td>
<td>主站轮询</td>
<td>纳秒级</td>
<td>100Mbps</td>
<td>高速、低延迟</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-EtherCAT-应用场景"><a href="#7-EtherCAT-应用场景" class="headerlink" title="7. EtherCAT 应用场景"></a><strong>7. EtherCAT 应用场景</strong></h2><ul>
<li><strong>运动控制</strong><ul>
<li>伺服驱动、电机控制</li>
<li>CNC机床、机器人控制</li>
</ul>
</li>
<li><strong>工业自动化</strong><ul>
<li>PLC与IO模块连接</li>
<li>传感器数据采集</li>
</ul>
</li>
<li><strong>半导体制造</strong><ul>
<li>高精度同步传输</li>
</ul>
</li>
<li><strong>汽车测试</strong><ul>
<li>车辆HIL仿真测试系统</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a><strong>8. 结论</strong></h2><p>EtherCAT 作为高性能工业以太网协议，具有<strong>低延迟、高同步精度</strong>的特点，广泛应用于<strong>实时控制领域</strong>。主站通过<strong>轮询</strong>与从站通信，从站在<strong>数据帧穿透</strong>机制下直接修改数据，提高了通信效率，是目前<strong>工业4.0和智能制造</strong>的核心技术之一。</p>
<h2 id="ethercat-是什么-详细解释"><a href="#ethercat-是什么-详细解释" class="headerlink" title="ethercat 是什么 详细解释"></a>ethercat 是什么 详细解释</h2><h3 id="EtherCAT-详解"><a href="#EtherCAT-详解" class="headerlink" title="EtherCAT 详解"></a>EtherCAT 详解</h3><p><strong>EtherCAT</strong>（<strong>以太网控制自动化技术</strong>）是一种基于以太网的高性能实时工业通信协议，专为工业自动化系统设计。它由德国Beckhoff公司于2003年开发，现已成为工业自动化领域的重要标准（IEC 61158）。</p>
<hr>
<h4 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h4><ol>
<li><p><strong>实时性与高效性</strong>  </p>
<ul>
<li><strong>数据帧“飞行处理”机制</strong>：主站发送的以太网帧依次经过每个从站设备，各从站实时提取或插入数据（类似“快递包裹”在传输过程中被动态处理），大幅减少通信延迟，典型周期低至100 μs。</li>
<li><strong>带宽利用率高</strong>：单个帧可携带多个设备的数据，支持最大1486字节的有效载荷。</li>
</ul>
</li>
<li><p><strong>主从架构</strong>  </p>
<ul>
<li><strong>主站（Master）</strong>：控制网络，生成和解析数据帧（如PLC、IPC）。</li>
<li><strong>从站（Slave）</strong>：执行具体任务（如伺服驱动器、I&#x2F;O模块），每个从站有唯一地址，支持热插拔。</li>
</ul>
</li>
<li><p><strong>分布式时钟同步</strong>  </p>
<ul>
<li>主站与从站通过精确的时间戳同步，实现<strong>纳秒级时钟偏差</strong>，确保多设备协同（如机器人多轴同步）。</li>
</ul>
</li>
<li><p><strong>灵活拓扑结构</strong>  </p>
<ul>
<li>支持线型、树型、星型拓扑，并可混合使用，适应复杂工业环境布线需求。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a><strong>技术细节</strong></h4><ul>
<li><p><strong>协议结构</strong><br>EtherCAT帧嵌入标准以太网帧（类型字段<code>0x88A4</code>），兼容常规以太网硬件（需从站支持EtherCAT专用芯片如ESC）。</p>
</li>
<li><p><strong>通信模式</strong>  </p>
<ul>
<li><strong>过程数据通信（PDO）</strong>：实时传输控制信号（如电机位置）。</li>
<li><strong>邮箱数据通信（SDO）</strong>：非实时配置参数或传输文件。</li>
</ul>
</li>
<li><p><strong>分布式时钟（DC）机制</strong><br>主站选定参考时钟，从站测量链路延迟并动态调整本地时钟，确保全网络时间同步。</p>
</li>
</ul>
<hr>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul>
<li><strong>性能</strong>：支持≤1000节点，循环周期低至微秒级。</li>
<li><strong>成本效益</strong>：基于标准以太网硬件，无需专用交换机。</li>
<li><strong>兼容性</strong>：支持CoE（CANopen over EtherCAT）、FoE（文件传输）等应用层协议。</li>
<li><strong>扩展性</strong>：通过EtherCAT分支器（如EBUS）可扩展复杂网络。</li>
</ul>
<hr>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ol>
<li><strong>工业机器人</strong>：多关节同步控制，路径精度优化。</li>
<li><strong>数控机床</strong>：高精度加工，实时反馈刀具状态。</li>
<li><strong>包装机械</strong>：高速生产线上的同步启停与张力控制。</li>
<li><strong>能源管理</strong>：分布式光伏逆变器的实时监控。</li>
</ol>
<hr>
<h4 id="标准化与生态"><a href="#标准化与生态" class="headerlink" title="标准化与生态"></a><strong>标准化与生态</strong></h4><ul>
<li><strong>ETG（EtherCAT技术协会）</strong>：全球拥有7,000+会员，推动协议标准化。</li>
<li><strong>开发工具</strong>：如Beckhoff TwinCAT、CODESYS，支持PLC编程与网络配置。</li>
<li><strong>硬件支持</strong>：TI、Infineon等提供ESC芯片，多家厂商推出兼容I&#x2F;O模块、驱动器。</li>
</ul>
<hr>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>EtherCAT凭借其实时性、灵活性和高性价比，成为工业4.0的核心通信技术之一，尤其适用于需要高速同步和复杂控制的场景。随着边缘计算和TSN（时间敏感网络）的融合，其未来在智能制造中的应用将更加广泛。</p>
<h2 id="ethercat-和-xenomai-分别是什么-详细解释"><a href="#ethercat-和-xenomai-分别是什么-详细解释" class="headerlink" title="ethercat 和 xenomai 分别是什么 详细解释"></a>ethercat 和 xenomai 分别是什么 详细解释</h2><p>EtherCAT 和 Xenomai 是两个在工业自动化和实时系统中广泛应用的关键技术，但它们的功能和应用领域不同。以下是详细解释：</p>
<hr>
<h3 id="1-EtherCAT"><a href="#1-EtherCAT" class="headerlink" title="1. EtherCAT"></a><strong>1. EtherCAT</strong></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><strong>EtherCAT</strong>（Ethernet for Control Automation Technology）是一种基于以太网的<strong>实时工业通信协议</strong>，专为工业自动化中的高速、高精度控制设计。它由德国 Beckhoff 公司开发，现已成为国际标准（IEC 61158）。</p>
<h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a><strong>核心特性</strong></h4><ol>
<li><p><strong>实时性</strong>  </p>
<ul>
<li>数据帧在传输过程中被从站设备（Slave）<strong>“实时处理”</strong>，而非存储转发，显著降低通信延迟（典型周期低至 100 μs）。</li>
<li>支持分布式时钟（Distributed Clocks, DC），实现全系统的时间同步（精度可达纳秒级）。</li>
</ul>
</li>
<li><p><strong>高效带宽利用</strong>  </p>
<ul>
<li>数据帧在传输过程中被多个从站设备依次读取和写入，单帧可完成对所有设备的读写操作，减少带宽占用。</li>
</ul>
</li>
<li><p><strong>灵活拓扑结构</strong>  </p>
<ul>
<li>支持线型、树型、星型等多种拓扑，无需专用交换机，降低成本。</li>
</ul>
</li>
<li><p><strong>主从架构</strong>  </p>
<ul>
<li><strong>主站（Master）</strong>：控制通信周期，发起数据交换（如 PLC、工业 PC）。</li>
<li><strong>从站（Slave）</strong>：执行具体任务（如伺服驱动器、I&#x2F;O模块）。</li>
</ul>
</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h4><ul>
<li>主站发送一个以太网帧，从站设备在帧通过时<strong>直接提取或插入数据</strong>，无需等待完整帧传输完毕。</li>
<li>数据帧在环型或线型拓扑中依次传递，最终由主站回收并处理。</li>
</ul>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul>
<li>运动控制（如多轴伺服驱动）</li>
<li>分布式 I&#x2F;O 系统</li>
<li>可编程逻辑控制器（PLC）</li>
<li>机器人控制系统</li>
</ul>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul>
<li>高性价比（基于标准以太网硬件）</li>
<li>低延迟、高同步精度</li>
<li>适用于大规模分布式系统</li>
</ul>
<hr>
<h3 id="2-Xenomai"><a href="#2-Xenomai" class="headerlink" title="2. Xenomai"></a><strong>2. Xenomai</strong></h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><strong>Xenomai</strong> 是一个开源的<strong>实时操作系统框架</strong>（Real-Time Operating System Framework），旨在为 Linux 提供<strong>硬实时（Hard Real-Time）</strong>能力。它通过内核扩展和协作调度机制，使普通 Linux 系统能够满足严格实时性要求。</p>
<h4 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a><strong>核心特性</strong></h4><ol>
<li><p><strong>双核架构（Cobalt Core）</strong>  </p>
<ul>
<li><strong>实时核（Xenomai）</strong>：处理硬实时任务（如中断响应、定时器）。</li>
<li><strong>非实时核（Linux）</strong>：运行普通任务（如网络通信、文件系统）。</li>
</ul>
</li>
<li><p><strong>Adéos 中间层</strong>  </p>
<ul>
<li>作为硬件抽象层，接管中断并优先分配给 Xenomai 实时核，确保实时任务的确定性。</li>
</ul>
</li>
<li><p><strong>实时 API 支持</strong>  </p>
<ul>
<li>提供多种实时编程接口（如 POSIX、VxWorks 风格的 API），支持跨平台实时应用开发。</li>
<li>与 Linux 原生 API（如 pthreads）兼容。</li>
</ul>
</li>
<li><p><strong>硬实时性能</strong>  </p>
<ul>
<li>中断响应延迟通常低于 10 μs，适用于微秒级精度的控制任务。</li>
</ul>
</li>
</ol>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h4><ul>
<li>Xenomai 通过修改 Linux 内核（或作为内核模块），在硬件中断和 Linux 内核之间插入实时调度层。</li>
<li>实时任务运行在 Xenomai 核，直接访问硬件资源，避免 Linux 内核的调度延迟。</li>
</ul>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul>
<li>机器人关节控制</li>
<li>CNC 机床</li>
<li>高速数据采集系统</li>
<li>航空航天控制系统</li>
</ul>
<h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul>
<li>低成本（基于开源 Linux）</li>
<li>兼容现有 Linux 生态</li>
<li>硬实时性能接近专用 RTOS（如 VxWorks）</li>
</ul>
<hr>
<h3 id="3-EtherCAT-与-Xenomai-的结合"><a href="#3-EtherCAT-与-Xenomai-的结合" class="headerlink" title="3. EtherCAT 与 Xenomai 的结合"></a><strong>3. EtherCAT 与 Xenomai 的结合</strong></h3><p>在工业控制系统中，两者常结合使用：  </p>
<ul>
<li><strong>Xenomai</strong> 提供实时操作系统环境，确保控制任务的确定性。</li>
<li><strong>EtherCAT</strong> 作为实时通信协议，连接主站（如运行 Xenomai 的工控机）与从站设备（如伺服驱动器）。</li>
</ul>
<h4 id="典型架构示例"><a href="#典型架构示例" class="headerlink" title="典型架构示例"></a><strong>典型架构示例</strong></h4><ol>
<li><strong>硬件</strong>：工业 PC（主站） + EtherCAT 从站设备（伺服驱动器、I&#x2F;O模块）。  </li>
<li><strong>软件</strong>：  <ul>
<li>Xenomai 实时核处理运动控制算法、中断响应。  </li>
<li>EtherCAT 主站协议栈（如 IgH EtherCAT Master）运行在 Xenomai 实时环境中，确保通信周期精确。  </li>
<li>Linux 非实时核处理人机界面（HMI）和网络通信。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>EtherCAT</strong>：实时工业以太网协议，解决高速、高精度设备通信问题。  </li>
<li><strong>Xenomai</strong>：实时操作系统框架，为 Linux 提供硬实时能力。  </li>
<li><strong>协同价值</strong>：在复杂控制系统中，Xenomai 保障实时任务执行，EtherCAT 实现高效设备通信，共同构建高性能工业自动化平台。</li>
</ul>
<h2 id="EtherCAT"><a href="#EtherCAT" class="headerlink" title="EtherCAT"></a>EtherCAT</h2><ul>
<li><p><code>EtherCAT</code>是<code>Ethernet for Control Automation Technolog</code>的简称，是一个实时控制的开放标准。</p>
</li>
<li><p><code>ETG</code>, <code>EtherCAT技术小组</code>，该组织是<code>Beckhoff</code>为支持和推广<code>EtherCAT</code>而成立的。<code>ETG</code>网站是关于<code>EtherCAT</code>的信息来源。</p>
</li>
</ul>
<h3 id="EtherCAT-xenomai-安装"><a href="#EtherCAT-xenomai-安装" class="headerlink" title="EtherCAT xenomai 安装"></a>EtherCAT xenomai 安装</h3><ul>
<li><del><code>notes/PDF/EtherCAT（ubuntu18.04，linux4.9.38，xenomai3.1，igh1.52）配置完整流程.docx</code></del> </li>
<li>pdf文档配置menuconfig时步骤不完整，坑！！！</li>
<li>另一个地址:<code>https://www.icode9.com/content-3-916631.html</code></li>
</ul>
<h3 id="固定RxPDOs"><a href="#固定RxPDOs" class="headerlink" title="固定RxPDOs"></a>固定<code>RxPDOs</code></h3><ul>
<li><p><code>notes/PDF/AP系列驱动器+EtherCAT+手册V1.0.pdf -- P12</code></p>
</li>
<li><p>**对于<code>CSP</code>(循环同步位置)**0x6060的操作方式&#x3D;8：</p>
<ul>
<li>接收PDO 4 ： 0x1700<ul>
<li><code>0x6040</code> – 控制字</li>
<li><code>0x607A</code> – 轨迹目标位置</li>
<li><code>0x60B1</code> – 速度偏移</li>
<li><code>0x60B2</code> – 转矩偏移</li>
</ul>
</li>
</ul>
</li>
<li><p>对于<code>CSV</code>(循环同步速度)0x6060的操作模式&#x3D;9：</p>
<ul>
<li>接收PDO 5：0x1701<ul>
<li><code>0x6040</code> – 控制字</li>
<li><code>0x60FF</code> – 目标速度</li>
<li><code>0x60B2</code> – 转矩偏移量</li>
</ul>
</li>
</ul>
</li>
<li><p>对于<code>CST</code>(循环同步转矩)0x6060的操作方式&#x3D;10：</p>
<ul>
<li>接收PDO 6：0x1702<ul>
<li><code>0x6040</code> – 控制字</li>
<li><code>0x60FF</code> – 目标速度</li>
<li><code>0x60B2</code> – 转矩偏移量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="固定TxPDO"><a href="#固定TxPDO" class="headerlink" title="固定TxPDO"></a>固定<code>TxPDO</code></h3><ul>
<li>发送PDO 5：0x1B00<ul>
<li><code>0x6041</code> – 16 – 状态字</li>
<li><code>0x6064</code> – 32 – 实际电机位置</li>
<li><code>0x60F4</code> – 32 – 位置循环错误（跟随错误）</li>
<li><code>0x606C</code> – 32 – 实际电机速度</li>
<li><code>0x6077</code> – 16 – 转矩实际值</li>
</ul>
</li>
</ul>
<h3 id="请求主站"><a href="#请求主站" class="headerlink" title="请求主站"></a>请求主站</h3><ul>
<li><p>用户程序通过<code>ecrt_request_master</code>请求主站设备，该函数调用<code>ecrt_request_master_err()</code>，取得<code>master</code>设备，并执行<code>ec_master_enter_operation_phase()</code>函数</p>
</li>
<li><p>请求主站设备完成后，开始<strong>创建数据域</strong>，调用<code>ecrt_master_create_domain()</code></p>
</li>
<li><p>创建数据域成功后，分别完成对各从站设备的配置，配置内容包括：<code>PDO</code>映射，<code>SM</code>配置，<code>FFMU</code>配置和<code>DC</code>配置</p>
</li>
<li><p>用户程序调用的入口是<code>ecrt.h</code>和相关的库文件，通过<code>ioctl</code>以驱动的形式实现，与<code>master</code>文件夹中的部分函数稍有区别</p>
</li>
</ul>
<h3 id="从站配置"><a href="#从站配置" class="headerlink" title="从站配置"></a>从站配置</h3><ul>
<li>从站配置是应用层通过<code>ecrt_master_slave_config()</code>函数添加到主站的<code>config</code>链表中</li>
</ul>
<h2 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h2><ul>
<li><p>过程数据对象(<code>Process Data Object, PDO</code>)，是用来传输实时数据的，提供对设备应用对象的直接访问通道，它用来传输实时短帧数据，具有较高的优先权。</p>
</li>
<li><p><code>PDO</code>传输的数据必须少于或等于8个字节，<code>PDO</code>的<strong>CAN报文数据域</strong>中每个字节都用作数据传输，因此，在应用层上不包含传输控制信息，报文利用率极高。</p>
</li>
<li><p><code>PDO</code>通信是基于生产者&#x2F;消费者的通讯模式，每个<code>PDO</code>有一个唯一的标识符且可以通过一个节点发送，但有多个节点可以接收。<code>PDO</code>的接收不需要消费者确认。</p>
<ul>
<li>由生产者发送的<code>PDO</code>称为发送PDO<code>(TPDO)</code></li>
<li>由消费者接收的<code>PDO</code>称为接收PDO<code>(RPDO)</code></li>
</ul>
</li>
<li><p>每个<code>PDO</code>在对象字典中由两个对象描述： 通信参数和映射参数</p>
<ul>
<li><code>PDO</code>通信参数指明使用哪个<code>COB-ID</code>，传输类型，禁用时间和定时时间</li>
<li><code>PDO</code>映射参数用于设定<code>PDO</code>报文中的数据的映射关系，确定要传输的数据在<code>CAN</code>报文数据域中的定位。该参数允许<code>PDO</code>的生产者和消费者知道正在传输什么信息，而不需要在<code>CAN</code>报文中增加额外的协议控制信息，使传输的效率达到最高。一个<code>PDO</code>最多可以映射64个对象</li>
</ul>
</li>
<li><p><code>PDO</code>通讯具有三种出发模式：内部事件驱动或内部定时器触发，同步触发，远程请求触发</p>
<ul>
<li><strong>内部事件驱动或内部定时触发。</strong>通讯由某一事件触发。例如数字I&#x2F;O口状态改变，超过预先设定的值，定时器中断等都会触发节点发送一个<code>PDO</code>。这种模式可使总线负载达到最小，在相对低的波特率下获得比较高的通讯特性。</li>
<li><strong>同步触发。</strong>同步触发<code>PDO</code>是指<code>CANopen</code>节点收到由管理节点发出的同步报文（同步对象Sync）之后，根据触发报文条件向总线发出<code>PDO</code>报文。同步传输又分为周期性和非周期性。周期性是指<code>CANopen</code>节点收到一定数量的同步报文之后才开始发送；非周期性<code>PDO</code>是指<code>PDO</code>触发条件成立之后，当收到下一个同步对象后马上发送<code>PDO</code></li>
<li><strong>远程请求触发。</strong><code>PDO</code>消费者可以给<code>PDO</code>生产者发送远程<code>PDO</code>请求，相应<code>PDO</code>生产者将对远程帧作出相应，向总线上发送相应的<code>PDO</code>数据。</li>
</ul>
</li>
<li><p><code>PDO</code>通讯时的触发模式由<code>PDO</code>通信参数中的传输类型来确定，传输类型是一个8位无符号整数，这个传输类型值的大小与<code>PDO</code>触发方式的对应关系</p>
</li>
<li><p>主站和从站<code>PDO</code>通信的机制</p>
<ul>
<li><code>PDO</code>的基本概念及其在对象字典中的索引，在主站和从战采用<code>PDO</code>通信方式时，思路是 – 先配置主站的<code>PDO</code>的通信参数(COB-ID,数据传输类型)，再配置从站的通信参数与主站一致，这样就建立了主站与从站的<code>PDO</code>通信的关系。然后再通过字典配置主站<code>PDO</code>映射参数，配置完成后从主站就可以通过<code>PDO</code>通信传输数据。</li>
</ul>
</li>
<li><p><code>PDO</code>传输的“总指挥”就是对象字典。<code>PDO</code>发送什么数据，接收什么数据，什么时候发送和接收，发送和接收的数据都放在哪儿，都是由对象字典配置。</p>
</li>
</ul>
<h2 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h2><ul>
<li>CAN是控制器局域网络(<code>Controller Area Network, CAN</code>)的简称，是由以研发和生产汽车电子产品著称的德国<code>BOSCH</code>公司开发的，并最终称为国际标准，是国际上应用最广泛的<strong>现场总线</strong>之一</li>
</ul>
<h2 id="EtherCAT-使用与解析–关于ethercat应用层使用"><a href="#EtherCAT-使用与解析–关于ethercat应用层使用" class="headerlink" title="EtherCAT 使用与解析–关于ethercat应用层使用"></a>EtherCAT 使用与解析–关于ethercat应用层使用</h2><ul>
<li><p>url – <code>https://blog.csdn.net/lswdcyy/article/details/105441470</code></p>
</li>
<li><p>下载<code>ethercat</code>源码并且安装好之后，测试<code>ethercat</code>使用可以遵循以下步骤</p>
</li>
<li><p>开启<code>ethercat</code>系统 – <code>sudo /etc/init.d/ethercat start</code></p>
<ul>
<li>执行这一步需要确保一点 – 按照<code>ethercat</code>源码中的<code>README</code>指导将一些需要的文件复制以及创建软连接到<code>/opt/init.d/ethercat</code>以及<code>/opt/sysconfig/ethercat</code>两个文件，前者是系统启动文件，后者是系统配置文件</li>
<li>系统配置文件，是一份变量定义文件，在系统启动脚本中执行，定义两类变量，一个是主站MAC地址(<code>MASTER0_DEVICE</code>)，一个是使用的模块驱动名称(<code>DEVICE_MODULES</code>)</li>
</ul>
</li>
<li><p>开启系统后，要在应用层进行对主站模块的使用，本质上是通过开启<code>/dev/EtherCAT</code>字符设备，而后基于<code>ioctl</code>方式调用内核主站模块各种功能</p>
<ul>
<li>开启系统后，用户主要需要进行从站配置与PDO映射，域操作功能，然后就可以进行PDO交换了</li>
<li><strong>主站程序运行在内核空间，应用层需要一种方式实现对内核调用。通过打开主站创建的字符设备<code>/dev/EtherCAT</code>就是这个作用</strong></li>
<li>主要用到的函数<ul>
<li><code>ec_master_t *ecrt_request_master(unsigned int master_index);</code> – <ul>
<li><strong>负责打开字符设备文件，传入参数为使用主站索引</strong>（使用<code>/etc/init.d/ethercat</code>开启系统的时候可以一次性传入多个MAC地址从而开启多个主站，不同主站创建不同的字符设备，例如<code>/dev/EtherCAT0, /dev/EtherCAT1...</code>），</li>
<li>而这个索引就是用于开启对应的字符设备，从而使用不同的主站，使用<code>open接口</code>打开，然后返回文件描述符，该文件描述符用于<code>ioctl</code>调用对应主站功能。另外在申请到主站后就不再允许进行总线的重新扫描，固化了主站连接的从站链表，而且设置从站状态当前申请状态为<code>PREOP</code></li>
</ul>
</li>
<li><code>ec_domain_t *ecrt_master_create_domain(ec_master_t* master);</code><ul>
<li><strong>负责创建域，</strong><code>domain</code>与<code>PDO</code>映射有密切联系，在激活的位置详谈</li>
<li>这个函数具体内容就是直接在内核空间中创建一块<code>ec_domain</code>空间并且将该空间连接到主站<code>domain</code>链表尾部</li>
</ul>
</li>
<li><code>ec_slave_config_t *ecrt_master_slave_config(ec_master_t* master, uint16_t alias, uint16_t position, uint32_t vendor_id, uint32_t product_code);</code><ul>
<li><strong>从站配置函数</strong>，</li>
<li>主站模块中的从站链表，它们之间的关系为：从站配置是应用层通过<code>ecrt_master_slave_config()</code>函数添加到主站的<code>configs</code>链表中的，而从站链表<code>slaves</code>则是通过<code>ethercat</code>主站状态机通过扫描<code>ethercat</code>总线得到的，两者的共同之处在于<strong>从站配置过程的<code>alias, position, VID, PID</code>，这些在主站扫描到的从站链表中都是有一份参数的，当应用层设置配置和主站扫描到从站信息相匹配的时候，那就将从站与从站配置相联系</strong>（这时候会将主站扫描的<code>SII</code>信息关于<code>sync</code>关联的<code>PDO</code>信息复制到从站配置中，也就是默认<code>PDO</code>配置）；这样，就可以通过从站配置寻找到主站模块中从站配置信息，进而获取到从站信息。</li>
</ul>
</li>
<li><code>int ecrt_slave_config_reg_pdo_entry(ec_slave_config_t *sc, uint16_t index, uint8_t subindex, ec_domain_t *domain, unsigned int *bit position);</code><ul>
<li><strong>从站配置<code>PDO</code>函数</strong></li>
<li>需要注意的一点 – 在主站正式激活之前，所有配置<code>PDO</code>相关的其实并没有相对应的空间申请操作，一切都是进行的计算，计算<code>PDO</code>需要多大空间，计算<code>domains</code>的逻辑位置，计算<code>FMMU</code>的逻辑位置，计算<code>PDO</code>的逻辑位置，直到主站正式激活，主站会根据自身已经申请的域链表<code>domains</code>，获取所有域所需要的空间大小，而后对每个域进行逻辑地址分配，每个域中再对每个<code>FMMU</code>进行逻辑地址分配。</li>
<li>接口参数<ul>
<li><code>uint16_t index</code> – 对象字典索引</li>
<li><code>uint8_t subindex</code> – 对象字典子索引</li>
<li><code>ec_domain_t *domain</code> – 使用的域</li>
<li><code>unsigned int* bit_position</code> – 一个Byte中的偏移量，当PDO映射逻辑地址不是完整的Byte时有用</li>
</ul>
</li>
<li>首先，通过从站应用层配置索引可以获取到主站的从站配置链表中对应的从站配置，而后根据配置目标domain的索引获取到主站的domains链表对应的域，这样就可以实现应用层的从站配置和domain切换到主站对应的从站配置和domain，然后进行pdo映射操作。</li>
<li>每次进行PDO映射的时候，并不是只对设置的一个对象进行处理，而是直接将整个sync关联的PDO都进行批次化处理。所以，本质上来讲，PDO配置映射就是确定PDO的逻辑地址位置</li>
</ul>
</li>
<li><code>int ecrt_master_activate(ec_master_t *master);</code><ul>
<li><strong>函数为正式激活的函数</strong></li>
<li>主站注册的domains链表整体大小计算；经过PDO注册映射之后，对主站中关联的每个domains都是相互独立的，并且每个domains都只是一个计算得到的值，其实并没有需要的空间申请，因此在主站激活的时候会将全部domians需要的空间进行统一申请。具体申请到的PDO映射逻辑空间存放在字符设备打开文件的priv指针处，关于字符设备的file-&gt;priv在字符设备打开eccdev_open的时候进行指定。然后按照主站连接的domains链表顺序对每个domian起始地址进行设置：主要是domain的逻辑起始地址，domain的大小，以及domain中的FMMU的逻辑地址重新设置，最终，domain和FMMU的逻辑起始地址都是在主站全部domains环境下的逻辑起始地址。为了进行PDO映射，在主站激活过程中还对每个domain需要的子报文进行空间申请。在计算子报文需要个数的时候，各个domain计算各自需要的子报文需要，这样就可以满足不同domain的PDO交换周期是可以单独设置的；在domain计算自己需要的子报文个数的时候，计算是以FMMU为一个基本单位进行计算的，每个子报文可承载的数据大小为1486Byte，然后根据一个子报文中FMMU的输入输出情况设置子报文类型，也就是EC_DATAGRAM_LRD类型子报文，EC_DATAGRAM_LRR类型子报文以及EC_DATAGRAM_LRW类型子报文。然后将这些子报文添加到domain的datagram_pairs链表中。当然，整体过程中，domain映射空间和子报文使用的数据空间都是同一段空间。</li>
<li>完成主站的domains域空间处理，之后就停止主站的空闲阶段线程（等待空间阶段线程退出）</li>
<li>开启主站的操作阶段线程，该线程和空闲阶段线程相比不同之处–在于将主站子报文队列组合发送移动到用户手中进行处理</li>
</ul>
</li>
<li><code>uint8_t *ecrt_domain_data(ec_domain_t *domain);</code><ul>
<li><strong>返回domain在逻辑空间的逻辑地址</strong></li>
</ul>
</li>
<li><code>void ecrt_domain_queue(ec_domain_t *domain);</code><ul>
<li><strong>将对应domain空间使用的子报文排列到主站子报文发送链表中</strong></li>
</ul>
</li>
<li><code>void ecrt_master_send(ec_master_t *master);</code><ul>
<li><strong>将主站的子报文发送链表的子报文进行发送</strong>，在发送过程中，默认的会将从站状态机子报文和主站状态机子报文进行排队发送</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ecrt-h头文件接口"><a href="#ecrt-h头文件接口" class="headerlink" title="ecrt.h头文件接口"></a><code>ecrt.h</code>头文件接口</h2><ul>
<li><p><code>ecrt_master_receive()</code></p>
<ul>
<li>功能：从硬件获取接收到的帧并处理数据报。通过调用中断服务例程查询网络设备接收到的帧。提取收到的数据报并将结果发送到队列中的数据报对象。接收到的数据报和超时的数据报将被标记并退出队列</li>
<li>函数原型：<code>void ecrt_master_receive(ec_master_t* master);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_domain_process()</code></p>
<ul>
<li>功能：确定域数据报的状态。评估接收到的数据报的工作计数器，并在必要时输出统计信息。必须在<code>ecrt_master_receive()</code>接收域数据报之后调用此函数，以便<code>ecrt_domain_state()</code>返回上一次进程数据交换的结果。</li>
<li>函数原型：<code>void ecrt_domain_process(ec_domain_t *domain);</code></li>
<li>参数：<code>domain</code> – 域</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>EC_READ_U16()</code></p>
<ul>
<li>功能：宏函数，计算整数数据，同样还有<code>EC_READ_U32()</code></li>
</ul>
</li>
<li><p><code>EC_WRITE_U16()</code></p>
<ul>
<li>功能：宏函数，将整型数据写入内存。内存大小是<code>ecrt_slave_config_create_sdo_request()</code>的参数。</li>
</ul>
</li>
<li><p><code>ecrt_master_sync_reference_clock()</code></p>
<ul>
<li>功能：将DC参考时钟偏移补偿数据报排队发送，参考时钟将上次取消<code>ecrt_master_application_time()</code>提供的应用程序时间同步</li>
<li>函数原型：<code>void ecrt_master_sync_reference_clock(ec_master_t *master)</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_master_sync_slave_clocks()</code></p>
<ul>
<li>功能：将DC时钟偏移补偿数据报排队发送，所有的子时钟与基准时钟同步</li>
<li>函数原型：<code>void ecrt_master_sync_slave_clocks(ec_master_t* master);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_domain_queue()</code></p>
<ul>
<li>功能：<strong>将主数据报队列中的所有域数据报排队</strong>。调用此函数可标记域的数据报以便在<code>ecrt_master_send()</code>的下一次调用</li>
<li>函数原型：<code>void ecrt_domain_queue(ec_domain_t* domain);</code></li>
<li>参数：<code>domain</code> – 域</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_master_send()</code></p>
<ul>
<li>功能：<strong>发送队列中的所有数据报</strong>。该方法接收所有排队等待传输的数据报，将他们放入帧中，并将他们传递给以太网设备进行发送</li>
<li>函数原型：<code>void ecrt_master_send(ec_master_t* master);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_master_application_time()</code></p>
<ul>
<li>功能：设置应用程序时间。在使用分布式时钟操作从机时，主机必须知道应用程序的时间。时间不是由主机本身增加的，因此必须循环调用此方法</li>
<li>函数原型：<code>void ecrt_master_application_time(ec_master_t* master, uint64_t app_time);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机；<code>app_time</code> – 应用时间</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_release_master()</code></p>
<ul>
<li>功能：释放请求的<code>ethercat</code>主机</li>
<li>函数原型：<code>void ecrt_release_master(ec_master_t* master);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
</ul>
<h2 id="关于PDO映射"><a href="#关于PDO映射" class="headerlink" title="关于PDO映射"></a>关于PDO映射</h2><ul>
<li><p><code>https://www.codeleading.com/article/95113301360/#:~:text=%E5%BD%93%E7%84%B6%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%B0%B1%E6%98%AF%E4%BD%BF%E7%94%A8ecrt_slave_config_pdos,%28%29%E5%87%BD%E6%95%B0%E5%AF%B9%E4%BB%8E%E7%AB%99%E9%85%8D%E7%BD%AE%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE%EF%BC%8C%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BC%9A%E5%B0%86%E5%8E%9F%E6%9C%ACSII%E5%A4%8D%E5%88%B6%E5%88%B0%E7%9A%84%E4%BB%8E%E7%AB%99%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84sync%E8%BF%9B%E8%A1%8C%E6%B8%85%E9%99%A4%EF%BC%8C%E8%80%8C%E5%90%8E%E4%BE%9D%E6%8D%AE%E6%96%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE%EF%BC%9A%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%84%E5%A6%82%E4%B8%8B%EF%BC%9A</code></p>
</li>
<li><p>对于PDO映射，首先它是已经有了一个sync中关联PDO的链表的前提下才进行的PDO映射。</p>
</li>
<li><p>使用<code>ecrt_slave_config_pdos()</code>函数进行PDO的在<code>sync</code>中的配置</p>
<ul>
<li>之所以有这样一个步骤，是因为主站状态部分，主站状态机在扫描SII信息时会提取<code>TxPDO</code>和<code>RxPDO</code>到从站的同步管理器(SII信息中有PDO和sync相关的信息)；然后再使用<code>ecrt_master_slave_config()</code>进行函数配置的时候会将对应从站的sync相关的PDO(<code>master-&gt;slaves-&gt;sync</code>)复制到从站配置部分，这样即使不去人为的配置同步管理器和PDO的映射关系，也没有什么影响</li>
</ul>
</li>
<li><p><code>ecrt_slave_config_pdos()</code></p>
<ul>
<li>函数对从站配置进行设置，会将原本SII复制到从站配置中的sync进行清除，而后依据新的配置进行设置，（目的就是为了对从站同步管理器的自定义设置）</li>
<li>需要使用到的参数分别是<code>sync, pdo, pdo_entry</code>结构体，三者关系是<code>sync</code>索引<code>PDO</code>， <code>PDO</code>索引<code>PDO_entry</code></li>
<li>从站如何获取PDO配置，可以使用<code>sudo ethercat cstruct</code>命令进行该信息的提取</li>
<li>针对每个<code>ec_sync_info_t</code>输入结构数组进行PDO映射处理，分为三个层次<ul>
<li>sync层次 – sync层次主要配置同步管理器的方向和看门狗设置</li>
<li>PDO层次 – 处理PDO的时候需要两个过程，一个是对之前的PDO配置进行清除，另一个是将自定义配置的<code>PDO</code>设置到从站配置的同步管理器链表中，这个过程还会查询之前的默认配置，将之前<code>PDO</code>中的<code>PDO_entry</code>复制到<code>PDO</code>中</li>
</ul>
</li>
</ul>
</li>
<li><p>以上两种PDO配置并不冲突，可以理解为前者是从站的默认配置，后者是用户为了个性化自定义配置（有无均可，只不过自定义的化可能会有冗余信息）</p>
</li>
</ul>
<h2 id="主站和从站"><a href="#主站和从站" class="headerlink" title="主站和从站"></a>主站和从站</h2><ul>
<li>参考：<ul>
<li><code>https://blog.csdn.net/qq923433160/article/details/83781812</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>主站的实现可采用嵌入式和PC机两种方式，均需配备标准以太网MAC控制器，传输介质可使用100BASE-TX规范的5类UTP线缆。</p>
</li>
<li><p>EtherCAT从站设备除了具备通信功能外，还需具备对从站设备的控制功能。常见的从站设备有I&#x2F;O端子、伺服设备、微处理器等。</p>
</li>
<li><p>EtherCAT主站运行需具备以下几个基本功能：</p>
<ul>
<li>读取从站设备描述XML文件并对其进行解析，获取其中配置参数</li>
<li>捕获和发送EtherCAT数据帧，完成EtherCAT子报文解析、打包等</li>
<li>管理从站设备状态，运行状态机，完成主从站状态机设置和维护</li>
<li>可进行非周期性数据通信，完成系统参数配置，处理通讯过程中突发事件</li>
<li>实现周期性过程数据通信，实现数据实时交换，实时监控从站状态，从站反馈 信号实时处理等功能。</li>
</ul>
</li>
</ul>
<h2 id="控制卡"><a href="#控制卡" class="headerlink" title="控制卡"></a>控制卡</h2><ul>
<li>参考：<ul>
<li><code>https://www.cnblogs.com/cariohu/p/15508175.html</code></li>
</ul>
</li>
</ul>
<h3 id="控制卡分类"><a href="#控制卡分类" class="headerlink" title="控制卡分类"></a>控制卡分类</h3><ul>
<li><p>控制器或者控制卡的性能主要取决于控制算法，不同厂家控制卡的性能差别可能非常大。</p>
</li>
<li><p>目前常见工业应用中比较高端的有以色列ACS，美国Aerotech，这是属于第一梯队的，其他国外的流行品牌还有elmo、PMAC、Galil、欧姆龙等。国内的有固高、雷赛、正运动、柏楚等，与国外产品相比仍然有一定差距，但也在不断突破。</p>
</li>
<li><p>根据控制器传递命令给驱动器的方式，可以分为：总线型、模拟量型、PWM型、脉冲型控制卡。</p>
</li>
<li><p>目前，总线型控制卡是最主流的，各大厂家的口号都是一网到底，这个网就是指的总线，就是通过一根总线把所有模块都接上去，确实方便。其他三种类型控制卡也有各自的特色，所以都并行存在于主流市场</p>
</li>
</ul>
<h3 id="总线控制卡"><a href="#总线控制卡" class="headerlink" title="总线控制卡"></a>总线控制卡</h3><ul>
<li><p>常见的总线接口有，<strong>EtherCAT</strong>、CAN、Modbus、Profinet、EPA、SERCOS-Ⅲ等。</p>
</li>
<li><p>总线有这么多种，他们之间是否有联系，又有哪些区别呢？这是我们学习总线之前需要搞清楚的问题，不然总是会心里没底，或者是错误的把总线混搭一起，这些是新手的必经之路。</p>
</li>
<li><p>要想搞清楚不同总线之间的区别与联系，我们就得从总线通讯的组成或者是框架去看</p>
<ul>
<li>通讯的概念出现的很早，早期的电话电报就是一种通讯方式，但工业上的通讯应用都是OSI七层模型。OSI(open system interconnect)即开放系统的互连，这个是二十世纪七十年代的产物，当时就是为了解决各系统之间通讯的问题。</li>
<li>OSI七层模型图，从模型中我们可以看到，通讯最终是转化为比特流发送出去，我们说的通讯速率就是比特流的速率，比如百兆网络100Mbit&#x2F;s。比特流的传输载体是物理层，是我们看的见摸得着的线缆以及接口芯片等。</li>
<li>物理层往上是数据链路层，数据链路层的职责是负责将具体的数据转化成比特流，然后通过物理层的硬件发送。可以简单理解为，硬件的编码与解码，比如要发送数字8，那么数字8的比特流高低电平是怎样的；当收到一串比特流后，应该转换为哪个数字，这个就靠数据链路层完成的，数据链路层也是硬件。 </li>
<li>数据链路层再往上，还有五层。这五层都有一个特点，他们都是软件层，是运行在处理器上的软件代码，这五层完成数据报的解析，编组，归类，最终到显示。</li>
</ul>
</li>
<li><p>当我们用因特网看视频时，这些层就在周而复始发送请求，解析数据，并最终刷新到显示界面。这五层搞起来确实有点复杂，有些时候其实是不需要的，比如我们知道数据的具体含义，我们就不需要再去分组整理数量，直接使用即可，工业通讯应用正是符合这个特点。</p>
</li>
<li><p>尤其是针对运动控制或者过程控制总线，层太多不仅没用，反而会增加成本，并且运动控制或者过程控制这种专用总线上数据的含义都是严格一一对应的，不需各种分组分段解析啥的。所以，将五层压缩为一层，叫应用层。</p>
</li>
<li><p>物理层，数据链路层，应用层都有各自的功能，三层功能没有重叠部分。</p>
</li>
<li><p>发送工作流程是当数据到达后应用层后把数据放到对应的存储区，数据需要发送时到对应区域取出数据，交给数据链路层，比特流经物理层发送出去；</p>
</li>
<li><p>接收工作流程就是反过来，物理层上的比特流被数据链路层解析为正确的数值，放到对应的存储区域，应用层需要数据的时候取走数据即可。</p>
</li>
<li><p>所以，运动控制或者过程控制总线，这种专用总线都是三层模型，三层模型的功能：</p>
<ul>
<li>应用层：搬运数据，完成控制功能</li>
<li>数据链路层：承上启下，生成比特流，以及解析比特流</li>
<li>物理层：比特流传输载体</li>
</ul>
</li>
<li><p>当我们接触或者学习新的总线时，主要是搞清楚总线的框架，即这三层的情况是怎样的。只有搞清楚了这三层，你才不会被各种新鲜名词所吓倒，你才不会去随便混搭总线。搞清楚了总线通讯模型后，我们看下当前最火的两个总线，EtherCAT和CAN总线。</p>
</li>
<li><p>为什么EtherCAT和CAN总线这么火？</p>
</li>
</ul>
<h4 id="CAN总线"><a href="#CAN总线" class="headerlink" title="CAN总线"></a>CAN总线</h4><ul>
<li><p>首先，是CAN总线起步早，博世公司1986年推出，当时主要是面向汽车行业。注意这里我说的是CAN总线，不是CANOPEN总线，CANOPEN只是基于CAN总线的应用层协议，汽车行业基于CAN总线的应用层协议是J1939。经过汽车行业的多年应用，大家发现这个总线的优点很多，速度快，1Mbit在现在看确实不快，但在那个年代还是非常牛的；有COB-ID，有仲裁机制，高优先级的数据可以先传输，低优先级是数据后发送，排队的数据在总线空闲的时候会自动发送，无需人为干预；差分传输，数据传输可靠性高；理论上可以在总线上挂任意多节点；成本低，几块钱的MCU就自带CAN控制器，现在一般同时支持CAN2.0A和2.0B。</p>
</li>
<li><p>既然CAN总线有这么多优点，那就得充分利用上，紧接着有个组织叫CIA(CAN in Automation)起草了基于CANopen的设备及通讯子协议定义DS 301(Draft Standard 301)，也就是我们经常说的301协定。DS301只是CANopen的一个基础规范，具体到细分领域有，I&#x2F;O模组的DS401，运动控制的DS402。讲到这里就出现了我们期盼已久的CANopen协议，之所以火就是因为起步早，又赶上了电机运动控制的蓬勃发展时期，靠谱好用，便宜，易上手。其实基于CAN总线的应用层协议还有北美船舶行业通讯协议，广州周立功公司的iCAN，但这个两个协议都不在运动控制系统中出现。其实协议就是这么简单，你也可以基于CAN总线创立自己的协议，只要有人用，你就很了不起。</p>
</li>
<li><p>这里简单讲下CANopen DS402的相关知识，方便我们后面的理解。DS402里面有一些概念，对象字典，Node-ID，COB-ID，SDO，PDO，NMT，Heartbeat，状态机，Master，Slave，我们都简单介绍下。</p>
<ul>
<li>DS402中规定网络中各设备是主从关系，即Master-Slave模式，原则上只能有一个Master，负责整个网络的管理。其实CAN总线上的都是节点，没有主从的概念，主从的概念是在DS402中规定的，这一点我们要清楚。</li>
<li><strong>对象字典我们可以理解为寄存器表</strong>，只不过DS402已经规定了这个寄存器表的组织结构，包括一部分地址必须给协议使用，如0x6040,0x6041这些都是规定好的。有了对象字典我们就知道每个对象代表的是什么意思，每个厂家都按这个去设计。传输数据的时候我们得知道这个是哪个从站设备的数据，就需要有个Node-ID，简单说就是设备的编号。</li>
<li>假如不同设备同时要传输同样对象字典的数据，那我们该怎样区分呢？这个时候就有COB-ID，COB-ID是对应的编码加上Node-ID，如0x600表示SDO读，对应节点1组合后的COB-ID就是0x600+0x01&#x3D;0x601，节点2则为0x602，以此类推。这样我们就可以通过COB-ID来直接操作数据了，而无需关心是哪个节点的，如果数据同时需要发送，那么总线的仲裁机制就会起作用，COB-ID越小的优先级越高，优先发送，等待的数据在前面的数据发送完之后会自动重发。</li>
</ul>
</li>
<li><p>数据的传输分为两种</p>
<ul>
<li>一种是SDO，就是有问才有答，查询一次回复一次，类似服务生一样。</li>
<li>另一种是PDO，叫过程数据，提前配置好了数据的传输方式后数据就会自动上传，如可以设置数据的最小间隔时间，同步、异步、RTR等。</li>
</ul>
</li>
<li><p>SDO和PDO都是为了传输数据，但PDO传输的是过程数据，更精简，传输数据的效率会更高，<strong>如循环同步模式肯定是PDO传输数据</strong></p>
</li>
<li><p>NMT是网络管理的意思，主站负责管理整个网络，如各节点的状态切换等。</p>
</li>
<li><p>状态机是控制节点切换的，如在非使能状态到使能状态应该怎么响应，这个是状态机管理的。</p>
</li>
<li><p>最后一个是Hearbeat，当然也有NodeGuarding，这两个都是反馈节点的状态。当总线在工作的时候我们得知道节点是否还在线，Hearbeat就类似我们的心跳，间隔多长时间必须收到一次心跳，超出设定时间没收到心跳则表示该节点已死亡。</p>
</li>
<li><p>NodeGuarding是另外一种监测方式，它有主站和从站的互动，这是不同于Hearbeat的，就是主站要发命令给从站，从站也要回应命令，也是要求在规定的时间内，目前Hearbeat用的更多一些。</p>
</li>
</ul>
<h4 id="EtherCAT总线"><a href="#EtherCAT总线" class="headerlink" title="EtherCAT总线"></a>EtherCAT总线</h4><ul>
<li><p>EthterCAT的字面意思就是以太网自动化控制技术。简单点说就是基于以太网，完成自动化控制功能，但肯定与普通以太网还是有区别的。</p>
</li>
<li><p>他们的传输介质是一样的，都是RJ45网口+网线，但EtherCAT网络的数据链路层芯片是专门设计的，其目的是为了提高总线的性能。比如，增加了DC同步单元，数据自动转发，还有FMMU单元，SM单元，详细的情况可以去查询相关资料。</p>
</li>
<li><p>DC同步单元的时钟都是ns为单位，可以满足非常高的同步要求，然后以太网的通讯速度又非常快，现在1000Mbit&#x2F;s都已经不是事了，在每个传输周期可以有非常大量的数据交互。这些都是基于硬件的，做应用的人可以不用关心，我们还是讲讲上层协议。</p>
</li>
<li><p>对硬件感兴趣的可以参考AX58100、ET1100芯片的数据手册，山东大学李正军教授的《EtherCAT工业以太网应用技术》非常不错，里面有详细的介绍，值得一看，这里就不展开讲了。</p>
</li>
<li><p>基于EtherCAT总线的应用层协议有FoE、CoE、SoE、EoE、AoE、VoE，各个协议的具体描述如下表2-2：</p>
<ul>
<li>FoE, File over EtherCAT     –  在EtherCAT总线上传输文件的协议</li>
<li>CoE, CANopen over EtherCAT  –  在EtherCAT总线上执行CANopen协议</li>
<li>SoE, SERCOS over EtherCAT   –  在EtherCAT总线上执行SERCOS协议</li>
<li>EoE, Ethernet over EtherCAT –  在EtherCAT总线上执行Ethernet协议</li>
<li>AoE  –  访问底层现场总线的从站设备的对象字典，如对连接到EtherCAT-CAN网关设备的CAN从站</li>
<li>VoE  –  供应商自定义协议，基于邮箱</li>
</ul>
</li>
<li><p>这些都是运行在EhterCAT总线基础上的应用层协议，各个协议分管与自己相关的工作。</p>
</li>
<li><p>我们现在常用的EtherCAT伺服驱动器，说白了就是把CANopen应用层协议搬到了EtherCAT总线之上。由于EhterCAT总线的高传输速度，所以这个时候可以有更高的控制信号频率，就会有更好的控制效果。</p>
</li>
<li><p>讲到这里，我们可以发现，同样的协议可以在不同的总线上，同样的总线也可以用不同的协议。所以，<strong>当我们讨论总线的时候也要讨论总线的应用层协议</strong>，即我们前文提到的三层模型，只有三层模型都一样的系统才能完美对接。对总线就介绍这么多，原理都是一样的，其他总线可以按照这个方法学习，事半功倍。</p>
</li>
<li><p>有了这样可靠性高，同步性好，控制频率可以很高的总线，现在控制指令的频率到8Khz已经不是问题了。控制卡的指令就可以很快很准的发送给总线上的驱动单元，最终达到好的控制效果。总线型控制系统的所有指令，位置反馈，指示状态，错误代码等等，都是由通讯来完成交互的，这一点和传统的控制方式有很大的区别。</p>
</li>
</ul>
<h2 id="驱动支持的各种模式详解"><a href="#驱动支持的各种模式详解" class="headerlink" title="驱动支持的各种模式详解"></a>驱动支持的各种模式详解</h2><ul>
<li><p>早期非总线的驱动器一般是支持三个工作模式，位置模式，速度模式和电流模式，这个都比较简单，配置好模式，给对应的指令即可工作。</p>
</li>
<li><p>这些模式一般都可以接收模拟量和PWM命令，位置模式还可以接收脉冲命令，这个就不展开讲了，参对应驱动的手册即可知道特定模式支持哪些类型的命令输入。这种驱动最大的缺点就是接线复杂，控制卡离驱动不能太远，还需要考虑控制线缆抗干扰，不利于分布式现场的情况。这种一般是应用于小型独立式设备，设备相对比较小，线缆不会太长，干扰问题比较好解决。</p>
</li>
<li><p>随着总线型驱动器的出现，驱动器的工作模式增加了好几个。没有特殊说明的话，这里的总线指的是CAN总线和EtherCAT总线。</p>
</li>
<li><p>基于这两个总线的驱动器一般都支持如表3-1所示的模式，当然还有PVT模式，IPM模式，但这些现在已经都不太常见了，有需要的可以查阅相关资料。   </p>
<ul>
<li>HM   –  回零模式</li>
<li>PVM  –  带规划的速度模式</li>
<li>PPM  –  带规划的位置模式</li>
<li>CSP  –  循环同步的位置模式</li>
<li>CSV  –  循环同步的速度模式</li>
<li>CST  –  循环同步的转矩模式</li>
</ul>
</li>
<li><p>HM模式是回零模式，驱动器已经内置好了各种回零方式。如先找负限位再找index方式；用限位作为回零原点方式；碰到硬限位回零方式等等。这些回零方式的程序已经在驱动器内部实现好了，我们只需要配置好相关参数，启动回零即可，回零过程都是驱动器内部程序完成。同时，也有状态变量可以监控当前的回零状态，是否完成，是否有报错等。</p>
</li>
<li><p>PVM和PPM是带规划的速度和位置模式，规划的意思就是根据用户设定的加减速度去启动和停止运动。这个两个模式很简单，有点像非总线伺服驱动器的速度模式和位置模式，这里不详细介绍了。</p>
</li>
<li><p>我们重点介绍下循环同步模式，循环同步的意思就是以一个固定的时间间隔，周而复始的发送数据和同步指令。为什么要搞这个玩法呢？PVM PPM不香吗？这是我们学习新知识前需要考虑的问题，搞清楚了背景，理解起来会更有帮助。</p>
<ul>
<li>我们先想下，控制卡+非总线伺服驱动器是怎样实现多轴同步的，是多个驱动的控制命令在同一个DSP中运算，这样时间上就不会有偏差，确保每次都是几乎同一时间把指令发送给驱动器。如果是多个DSP有各自控制的驱动器，这些驱动器之间做同步运动，比如插补，效果都会差于一个DSP内部轴同步的效果，除非你把多个DSP任一时刻都同步起来，同样的时间做同样的运算，这样也许会是一样的效果。</li>
<li>而我们这里说的循环同步就是干这个事情，总线型驱动器与控制卡或者叫master之间的连接只有一条通讯线，无论这条通讯线是CAN总线的半双工，或是EtherCAT总线的全双工，再加100Mbit&#x2F;s的带宽，数据传输总会有先后顺序，这个事实没法改变。假如总线上的所有驱动器都以收到指令数据的那一刻去执行指令，那么驱动器之间就无法很好同步了。</li>
<li>那么应该怎么办呢？人是真的聪明，总会想办法去解决问题，天才的工程师提出了一个解决方案。所有驱动器都先收指令数据，但不要立马执行，等待一个命令再执行，这个就是同步命令，这样就完美的解决了总线上数据传输有先后顺序的问题。大家都是先把数据准备好，然后等待同步命令，这个就好比百米赛跑一样，大家都先准备好，等待发令枪再跑，这样就是公平的。至于最终跑的结果怎样看个人水平，驱动器最终执行的效果怎样也是看驱动器的性能，感觉这个启发真是源于生活，最终又服务于生活。</li>
</ul>
</li>
<li><p>讲完什么是循环同步后，我们看下循环同步的三个模式到底是啥。</p>
</li>
<li><p>首先说CSP，循环同步的位置模式：</p>
<ul>
<li>这个模式接收的是控制卡下发的位置指令，但这个位置不是随便发的，需要根据位置轨迹解算为一个一个点，这个是需要上位机解算的。</li>
<li>上位解算点的这个过程叫粗插，就是粗线条的给出一些点，这些点不是驱动伺服环路能直接使用的，驱动器在接收到这些点后需要再进行精插，最终变成伺服环路能直接执行的位置点。</li>
<li>精插是相对于粗插来说的，精插是以伺服周期为基准时间单位，精细的将轨迹分成很多个位置点，形成一个位置表，每个伺服周期去这个表中取一个值执行即可。</li>
<li>我们以一个T形加减速，有匀速过程的点到点运动为例来剖析CSP模式的细节。如图3-15，是一个点到点运动，位置—时间和速度—时间关系图，加速和减速阶段的轨迹是曲线，匀速阶段是直线。再看下位置图中的插值点，这些点之间的时间是均匀间隔的，每到一个时间点位置轨迹与时间轴围成一个面积，这个面积就是我们在CSP模式发送给驱动器的位置指令，随着时间的增加，这个面积会越来越大。</li>
<li>只要这些插值点是均匀的，指令发送的时间是准确的，满足这两个条件的情况下，电机的转动必然是平滑的。这两个条件中的任何一个不满足，电机的转动都是会顿挫的。</li>
<li>如果插值点不均匀，比如有的时候插值点是间隔10ms，有的时候插值点是20ms。最明显的结果就是电机运动不平滑，那么为什么会不平滑呢？我们知道位置轨迹连续则位置轨迹的导数或者叫曲线的曲率才不会有突变，位置轨迹导数对应着的是速度，速度不突变则电机运转平稳。如果我的插值点时间突然增加或者缩短，则必然会导致曲率突变，这是上位在解算轨迹点需要注意的问题。</li>
<li>尤其是任意轨迹曲线，曲率的突变非常厉害，即使在均匀的插值情况下，电机运转可能都会抖动明显。所以，对任意曲线的插值，还有需要针对锐角以及曲率突变的点做优化，比如用圆弧过度锐角，或者降低运动速度。</li>
<li>到这里我们对CSP的整个细节基本讲完了，在使用过程中，我们还需注意循环同步指令的周期以及指令到达是否准时。指令的周期不应过短，要让驱动器有精插的空间，比如驱动伺服环路400us，那么你就不要给低于400us的同步周期，当然很多驱动也不支持这么短的同步周期，即使支持也不要这样给。同步指令要有硬时性，或者实时性好，我们一般以us为单位，尽可能的准时，指令不准时同样会导致电机运动的时候顿挫严重，甚至驱动器报错。</li>
<li>到这里我们讲完了整个CSP模式的要点，在使用CSP模式的时候如果电机运转不平滑，该怎样去找问题，这才是我们要关注的核心。看到这里应该有一种豁然开朗的感觉，就证明你完全理解了循环同步位置模式的精髓。</li>
</ul>
</li>
<li><p>讲完CSP模式，后面的CSV和CST模式就简单了，我们先看看CSV模式：</p>
<ul>
<li>CSV是循环同步的速度模式，控制卡下发的是速度指令，这个速度指令和位置指令一样，也不是随便给的。需要对速度曲线进行插值，解算每个周期应该给驱动的速度指令，对位置轨迹求导数就是速度，也就有了速度曲线。</li>
<li>同CSP一样，控制卡或者上位也只是粗插，伺服环路还会根据指令和周期的时间进行精插，最终就变成了伺服环路可以执行的指令。</li>
<li>同样，CSV模式对指令的实时性要求同CSP一样，不准时的指令就会导致电机运转的时候顿挫，顿挫就是速度突变造成的，分析方法和CSP模式一样，这里不再赘述</li>
</ul>
</li>
<li><p>看完CSV，我们再看看CST：</p>
<ul>
<li>这个模式和前面两个的共同之处是都为循环同步模式，不同之处是CST模式的指令直接被伺服环路所用，中间没有精插的过程。由于这个不同，CST模式的指令实时性不好的时候我们也很难发现，因为CST模式对应的是电机的电流，电流对应的是电机的输出转矩，电流的突变就是转矩的突变。</li>
<li>转矩的是突变对应三种情况：<ul>
<li>一种是电机输出转矩大于负载转矩，电机加速</li>
<li>另一种是电机输出转矩等于负载转矩，电机还是静止；</li>
<li>甚至是电机输出转矩小于负载转矩，电机被负载拖动，运动控制中这种一般很少</li>
</ul>
</li>
<li>指令实时性不好很难被发现，并不是说CST模式对指令实时性没有要求，既然叫循环同步模式，那就是有这个要求。</li>
</ul>
</li>
<li><p>总结下三个循环同步模式，循环同步模式的出现，使得我们对任意轨迹的指令规划变得非常方便，就是对曲线插值，获得各时刻应该下发的指令。它使我们更加靠近了伺服环路的工作原理，伺服环路其实也是一直在插，不断的解算各个伺服周期的命令，然后算法以读表的方式不断的读取各个周期的指令。</p>
</li>
<li><p>讲到这里，整个驱动器的相关知识就介绍完了。简单总结就是，驱动器有硬件和固件两部分，硬件部分负责控制电机的换向，电流调节，反馈信号采集等；固件部分或者叫软件部分，则是通过硬件的各种反馈信号，周而复的运算，并将运算结果输出到硬件。其实整个伺服系统工作的过程，就是一个不断纠偏的过程，大了就小点，小了就大点，没有真正的静止，一直运动，只是在几个脉冲来回移动，这才是伺服系统的精髓，没有真正的静止。</p>
</li>
</ul>
<h2 id="EtherCAT-配置流程"><a href="#EtherCAT-配置流程" class="headerlink" title="EtherCAT 配置流程"></a>EtherCAT 配置流程</h2><ol>
<li>init master</li>
<li>init slave</li>
<li>init pdo</li>
<li>init pdo_entry</li>
<li>config pdo_entry</li>
<li>config pdo</li>
<li>config slave </li>
<li>config master</li>
<li>config sdo</li>
<li>lock memory</li>
<li>start master</li>
<li>start slave</li>
</ol>
<h2 id="EtherCAT-通讯流程"><a href="#EtherCAT-通讯流程" class="headerlink" title="EtherCAT 通讯流程"></a>EtherCAT 通讯流程</h2><ol>
<li>master receive </li>
<li>slave receive </li>
<li>pdo read update</li>
<li>control strategy</li>
<li>pdo write update</li>
<li>master sync</li>
<li>slave send </li>
<li>master send</li>
</ol>
<h2 id="PDO-1"><a href="#PDO-1" class="headerlink" title="PDO"></a>PDO</h2><ul>
<li>pdo 可以分为三级<ul>
<li>SM(sync manager)，每个SM可以同步多个 pdo</li>
<li>pdo，每个 pdo 包含多个 pdo entry</li>
<li>pdo entry，每个 pdo entry 对应一个 index 和 subindex</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Eigen3/2024-05-22-Eigen_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Eigen3/2024-05-22-Eigen_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Eigen_2_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen3/" itemprop="url" rel="index"><span itemprop="name">Eigen3</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Eigen 库常用的编程技巧</li>
</ul>
<h2 id="eigen3-两个矩阵相乘-示例详解"><a href="#eigen3-两个矩阵相乘-示例详解" class="headerlink" title="eigen3 两个矩阵相乘 示例详解"></a>eigen3 两个矩阵相乘 示例详解</h2><p>Eigen是一个C++模板库，用于线性代数操作，包括矩阵相乘。Eigen的3.x版本中提供了一个简洁而强大的矩阵相乘接口，用于进行矩阵乘法运算。下面是一个简单的示例，展示如何在Eigen中进行两个矩阵的相乘。</p>
<p>首先，确保你已经安装了Eigen库，并且包含了适当的头文件。通常，你需要在代码中包含类似这样的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>然后，你可以使用Eigen库来执行矩阵相乘操作。以下是一个示例代码，假设你已经创建了两个矩阵 A 和 B，并且想要计算它们的乘积 C。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建矩阵 A 和 B</span></span><br><span class="line">    <span class="function">Eigen::MatrixXd <span class="title">A</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;  <span class="comment">// 3x3 矩阵</span></span><br><span class="line">    <span class="function">Eigen::MatrixXd <span class="title">B</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;  <span class="comment">// 3x3 矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化矩阵 A 和 B</span></span><br><span class="line">    A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    B &lt;&lt; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>,</span><br><span class="line">         <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>,</span><br><span class="line">         <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算矩阵相乘 C = A * B</span></span><br><span class="line">    Eigen::MatrixXd C = A * B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Matrix B:\n&quot;</span> &lt;&lt; B &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Matrix C (A * B):\n&quot;</span> &lt;&lt; C &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了两个3x3的矩阵 A 和 B，并使用<code>&lt;&lt;</code>操作符初始化它们。然后，我们使用<code>*</code>运算符将矩阵 A 和 B 相乘，将结果存储在矩阵 C 中。</p>
<p>最后，我们打印了矩阵 A、B 和 C 的值。你会看到矩阵 C 包含了矩阵 A 和 B 的乘积。</p>
<p>这只是一个简单的示例，展示了如何在Eigen中进行矩阵相乘操作。Eigen提供了丰富的线性代数功能，包括各种矩阵运算和分解，使其成为处理线性代数问题的强大工具。</p>
<h2 id="Eigen-Vector3d-获取元素值"><a href="#Eigen-Vector3d-获取元素值" class="headerlink" title="Eigen::Vector3d 获取元素值"></a>Eigen::Vector3d 获取元素值</h2><p>在Eigen C++库中，<code>Eigen::Vector3d</code> 是一个表示三维向量的类。要获取<code>Eigen::Vector3d</code> 对象的元素值，你可以使用<code>operator[]</code>或者成员函数<code>x()</code>, <code>y()</code> 和 <code>z()</code>。下面是一些示例代码：</p>
<ol>
<li><p>使用 <code>operator[]</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> x = v[<span class="number">0</span>];  <span class="comment">// 获取第一个元素</span></span><br><span class="line">    <span class="type">double</span> y = v[<span class="number">1</span>];  <span class="comment">// 获取第二个元素</span></span><br><span class="line">    <span class="type">double</span> z = v[<span class="number">2</span>];  <span class="comment">// 获取第三个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用成员函数 <code>x()</code>, <code>y()</code> 和 <code>z()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> x = v.<span class="built_in">x</span>();  <span class="comment">// 获取第一个元素</span></span><br><span class="line">    <span class="type">double</span> y = v.<span class="built_in">y</span>();  <span class="comment">// 获取第二个元素</span></span><br><span class="line">    <span class="type">double</span> z = v.<span class="built_in">z</span>();  <span class="comment">// 获取第三个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>两种方法都可以用来获取向量的元素值。选择哪种方法取决于你的偏好和代码的上下文。使用 <code>operator[]</code> 更类似于访问普通的数组，而使用成员函数则更加直观，因为它们使用了更具描述性的名称。</p>
<h2 id="Eigen-Vector3f-示例"><a href="#Eigen-Vector3f-示例" class="headerlink" title="Eigen::Vector3f 示例"></a>Eigen::Vector3f 示例</h2><p>以下是一个简单的示例，演示了如何使用Eigen库中的<code>Eigen::Vector3f</code>来执行向量计算操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明两个三维浮点数向量</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">v1</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">v2</span><span class="params">(<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量加法</span></span><br><span class="line">    Eigen::Vector3f sum = v1 + v2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量点积</span></span><br><span class="line">    <span class="type">float</span> dotProduct = v<span class="number">1.</span><span class="built_in">dot</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量叉积</span></span><br><span class="line">    Eigen::Vector3f crossProduct = v<span class="number">1.</span><span class="built_in">cross</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v1: &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v2: &quot;</span> &lt;&lt; v<span class="number">2.</span><span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum.<span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dot product: &quot;</span> &lt;&lt; dotProduct &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cross product: &quot;</span> &lt;&lt; crossProduct.<span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先包含了Eigen库的头文件，并声明了两个三维浮点数向量 <code>v1</code> 和 <code>v2</code>。然后，我们执行了向量加法、点积和叉积操作，并输出了结果。</p>
<p>请确保您已经正确安装了Eigen库，并且能够通过编译器访问该库。在实际应用中，您可以使用<code>g++</code>或其他支持C++的编译器来编译和运行这段示例代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/EtherCat/2024-05-22-ethercat_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/EtherCat/2024-05-22-ethercat_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">EtherCat_2_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/EtherCat/" itemprop="url" rel="index"><span itemprop="name">EtherCat</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ethercat常用函数</li>
</ul>
<h2 id="ethercat"><a href="#ethercat" class="headerlink" title="ethercat"></a>ethercat</h2><h2 id="1-1-启动，设置"><a href="#1-1-启动，设置" class="headerlink" title="1.1 启动，设置"></a>1.1 启动，设置</h2><ul>
<li><p>ethercat都是在root用户下执行命令</p>
</li>
<li><p>设置从站</p>
<ul>
<li>ethercat alias -p 2 0:2</li>
</ul>
</li>
<li><p>启动ethercat</p>
<ul>
<li><code>/etc/init.d/ethercat start</code></li>
</ul>
</li>
<li><p>查看状态</p>
<ul>
<li><code>ethercat slv</code></li>
</ul>
</li>
</ul>
<h2 id="1-2-调试命令"><a href="#1-2-调试命令" class="headerlink" title="1.2 调试命令"></a>1.2 调试命令</h2><ul>
<li><p>查看从站状态码</p>
<ul>
<li><code>ethercat upload -t int16 -p 0 0x603f 00</code></li>
</ul>
</li>
<li><p>查看从站位置：</p>
<ul>
<li><code>ethercat upload -t int32 -p 0 0x6064 00</code></li>
</ul>
</li>
</ul>
<h2 id="1-2-demo-webserver-c-分析"><a href="#1-2-demo-webserver-c-分析" class="headerlink" title="1.2 demo_webserver.c 分析"></a>1.2 demo_webserver.c 分析</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="ec-pdo-entry-info-t"><a href="#ec-pdo-entry-info-t" class="headerlink" title="ec_pdo_entry_info_t"></a><code>ec_pdo_entry_info_t</code></h2><ul>
<li>简介：PDO条目配置信息。这是<code>ec_pdo_info_t</code>中的<code>entries</code>字段的数据类型</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">uint16_t</span> index;      <span class="comment">/**&lt; PDO entry index. */</span></span><br><span class="line">  <span class="type">uint8_t</span>  subindex;   <span class="comment">/**&lt; PDO entry subindex. */</span></span><br><span class="line">  <span class="type">uint8_t</span>  bit_length; <span class="comment">/**&lt; Size of the PDO entry in bit. */</span></span><br><span class="line">&#125; <span class="type">ec_pdo_entry_info_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-pdo-info-t"><a href="#ec-pdo-info-t" class="headerlink" title="ec_pdo_info_t"></a><code>ec_pdo_info_t</code></h2><ul>
<li>简介：PDO配置信息。这是<code>ec_sync_info_t</code>中的<code>pdos</code>字段的数据类型</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">uint16_t</span> index;              <span class="comment">/**&lt; PDO index. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n_entries;      <span class="comment">/**&lt; 要映射的entries PDO条目数 (0表示使用默认映射，这只能在从服务器处于总线配置时完成)*/</span></span><br><span class="line">  <span class="type">ec_pdo_entry_info_t</span> *entries;<span class="comment">/**&lt; 要映射的PDO项数组。可以是NULL，或者必须包含至少n_entries个值*/</span></span><br><span class="line">&#125; <span class="type">ec_pdo_info_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-sync-info-t"><a href="#ec-sync-info-t" class="headerlink" title="ec_sync_info_t"></a><code>ec_sync_info_t</code></h2><ul>
<li>简介：同步管理器配置信息。这可以用于配置多个同步管理器，包括PDO分配和PDO映射。它被作为<code>ecrt_slave_config_pdos()</code>函数的输入参数使用</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span> index;  <span class="comment">/**&lt; 同步管理器索引。Sync manager index.Must be less than #EC_MAX_SYNC_MANAGERS for a valid sync manager,but can also be \a 0xff to mark the end of the list. */</span></span><br><span class="line">  <span class="type">ec_direction_t</span> dir;  <span class="comment">/**&lt;同步管理器方向 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>   n_pdos;  <span class="comment">/**&lt; PDOs在pdos结构体数组中的数量 */</span></span><br><span class="line">  <span class="type">ec_pdo_info_t</span>  *pdos;  <span class="comment">/**&lt;带有要分配的pdo的数组。所包含的PDOs必须不少于n_pdos</span></span><br><span class="line"><span class="comment">  ec_watchdog_mode_t watchdog_mode;  /**&lt; 看门狗模式 */</span></span><br><span class="line">&#125; <span class="type">ec_sync_info_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-master-t"><a href="#ec-master-t" class="headerlink" title="ec_master_t"></a><code>ec_master_t</code></h2><ul>
<li>简介：主站</li>
</ul>
<h2 id="ecrt-master-state-t"><a href="#ecrt-master-state-t" class="headerlink" title="ecrt_master_state_t"></a><code>ecrt_master_state_t</code></h2><ul>
<li>简介：主站状态，这个是用于函数<code>ecrt_master_state()</code>函数的输出参数</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> slaves_responding;  <span class="comment">// 所有Ethernet设备响应从站的总和</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> al_states : <span class="number">4</span>;      <span class="comment">// 所有从站的应用层状态。状态被编码在较低的4位。如果设置了一个比特位，就意味着至少有一个从站在主线上响应：Bit 0: \a INIT；Bit 1: \a PREOP；Bit 2: \a SAFEOP；Bit 3: \a OP */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> link_up : <span class="number">1</span>;        <span class="comment">// true，如果至少有一个 Ethernet link是在线的，则为true</span></span><br><span class="line">&#125; <span class="type">ec_master_state_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-slave-config-t"><a href="#ec-slave-config-t" class="headerlink" title="ec_slave_config_t"></a><code>ec_slave_config_t</code></h2><ul>
<li>简介：从站配置</li>
</ul>
<h2 id="ec-slave-config-state-t"><a href="#ec-slave-config-state-t" class="headerlink" title="ec_slave_config_state_t"></a><code>ec_slave_config_state_t</code></h2><ul>
<li>简介：从站配置状态。它用于函数<code>ecrt_slave_config_state()</code>的输出参数</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> online : <span class="number">1</span>;      <span class="comment">// 这个从站是在线的</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> operational : <span class="number">1</span>; <span class="comment">// 这个从站通过指定配置进入OP状态</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> al_state : <span class="number">4</span>;    <span class="comment">// 应用层的从站状态：1: \a INIT；2: \a PREOP；4: \a SAFEOP；8: \a OP</span></span><br><span class="line">&#125; <span class="type">ec_slave_config_state_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-domain-t"><a href="#ec-domain-t" class="headerlink" title="ec_domain_t"></a><code>ec_domain_t</code></h2><ul>
<li>简介：域</li>
</ul>
<h2 id="ec-wc-state-t"><a href="#ec-wc-state-t" class="headerlink" title="ec_wc_state_t"></a><code>ec_wc_state_t</code></h2><ul>
<li>简介：域工作计数器状态说明。这个是在<code>ec_domain_state_t</code>中使用</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  EC_WC_ZERO = <span class="number">0</span>,   <span class="comment">// 没有交换注册的过程数据</span></span><br><span class="line">  EC_WC_INCOMPLETE, <span class="comment">// 交换了一些已注册的过程数据(部分过程数据)</span></span><br><span class="line">  EC_WC_COMPLETE    <span class="comment">// 交换了所有已注册的过程数据</span></span><br><span class="line">&#125; <span class="type">ec_wc_state_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-domain-state-t"><a href="#ec-domain-state-t" class="headerlink" title="ec_domain_state_t"></a><code>ec_domain_state_t</code></h2><ul>
<li>简介：域状态。它被作为函数<code>ecrt_domain_state()</code>的输出参数使用</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> working_counter;   <span class="comment">// 最后一个工作计数器的值</span></span><br><span class="line">  <span class="type">ec_wc_state_t</span> ws_state;         <span class="comment">// 工作计数器状态说明</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> redundancy_active; <span class="comment">// 冗余链路正在使用</span></span><br><span class="line">&#125; <span class="type">ec_domain_state_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-pdo-entry-reg-t"><a href="#ec-pdo-entry-reg-t" class="headerlink" title="ec_pdo_entry_reg_t"></a><code>ec_pdo_entry_reg_t</code></h2><ul>
<li>简介：列出PDO条目批量注册的记录类型。此类型用于<code>ecrt_domain_reg_pdo_entry_list()</code>的数组参数。</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">uint16_t</span> alias;             <span class="comment">// 从站别名地址</span></span><br><span class="line">  <span class="type">uint16_t</span> position;          <span class="comment">// 从站位置</span></span><br><span class="line">  <span class="type">uint32_t</span> vendor_id;         <span class="comment">// 从站供销商ID</span></span><br><span class="line">  <span class="type">uint32_t</span> product_code;      <span class="comment">// 从站产品码</span></span><br><span class="line">  <span class="type">uint16_t</span> index;             <span class="comment">// PDO条目索引</span></span><br><span class="line">  <span class="type">uint8_t</span>  subindex;          <span class="comment">// PDO条目子索引</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *offset;       <span class="comment">// 指向在进程数据中存储PDO条目(字节-)偏移量的变量的指针。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *bit_position; <span class="comment">// 指向一个变量的指针，用于在\a偏移量内存储位位置(0-7)。可以为NULL，在这种情况下，如果PDO条目不字节对齐会引发错误</span></span><br><span class="line">&#125; <span class="type">ec_pdo_entry_reg_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h2 id="ecrt-master-create-domain"><a href="#ecrt-master-create-domain" class="headerlink" title="ecrt_master_create_domain"></a><code>ecrt_master_create_domain</code></h2><ul>
<li>简介：创建一个新的过程数据域。对于流程数据交换，至少需要一个流程数据域。这个方法创建一个新的过程数据域，并返回一个指向新域对象的指针。这个对象能够在循环操作中用于注册PDOs和交换PDOs</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ec_domain_t</span> *<span class="title">ecrt_master_create_domain</span><span class="params">( <span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ecrt-request-master"><a href="#ecrt-request-master" class="headerlink" title="ecrt_request_master"></a><code>ecrt_request_master</code></h2><ul>
<li>简介：请求EtherCAT主机进行实时操作。<ul>
<li>在应用程序可以访问EtherCAT主机之前，它必须预留一个专用的主机。</li>
<li>在用户空间，这是<code>ecrt_open_master()</code>和<code>ecrt_master_reserve()</code>的方便函数。</li>
<li>这个函数必须是应用程序使用EtherCAT时必须调用的第一个函数</li>
<li>该函数以master的索引作为参数。第一个主节点的索引为0，第n个主节点的索引为n- 1。</li>
<li>在加载master时，必须指定master的数量。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ec_master_t</span> *<span class="title">ecrt_request_master</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> master_index)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ecrt-master-sdo-upload"><a href="#ecrt-master-sdo-upload" class="headerlink" title="ecrt_master_sdo_upload"></a><code>ecrt_master_sdo_upload</code></h2><ul>
<li>简介：执行SDO上传请求从从站读取数据。<ul>
<li>此请求由主状态机处理。</li>
<li>他的方法会阻塞，直到请求被处理，并且不能在实时上下文中调用。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_sdo_upload</span><span class="params">(<span class="type">ec_master_t</span> *master, <span class="type">uint16_t</span> slave_position, <span class="type">uint16_t</span> index, <span class="type">uint8_t</span> subindex, <span class="type">uint8_t</span> *target, <span class="type">size_t</span> target_size, <span class="type">size_t</span> *result_size, <span class="type">uint32_t</span> *abort_code)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>          –  EtherCAT主站</li>
<li><code>slave_position</code>  –  从站位置</li>
<li><code>index</code>           –  SDO索引</li>
<li><code>subindex</code>        –  SDO的子索引</li>
<li><code>target</code>          –  上传的目标缓冲区。</li>
<li><code>target_size</code>     –  目标缓冲区的大小</li>
<li><code>result_size</code>     –  已经上传的数据大小</li>
<li><code>abort_code</code>      –  SDO上传的中止代码。</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功 –  0</li>
<li>失败 –  &lt; 0</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-sdo-download"><a href="#ecrt-master-sdo-download" class="headerlink" title="ecrt_master_sdo_download"></a><code>ecrt_master_sdo_download</code></h2><ul>
<li>简介：执行SDO下载请求，将数据写入从站。<ul>
<li>此请求由主状态机处理。</li>
<li>他的方法会阻塞，直到请求被处理，并且不能在实时上下文中调用。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_sdo_download</span><span class="params">(<span class="type">ec_master_t</span> *master, <span class="type">uint16_t</span> slave_position, <span class="type">uint16_t</span> index, <span class="type">uint8_t</span> subindex, <span class="type">uint8_t</span> *data, <span class="type">size_t</span> data_size, <span class="type">uint32_t</span> *abort_code)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>          –  EtherCAT主站</li>
<li><code>slave_position</code>  –  从站位置</li>
<li><code>index</code>           –  SDO索引</li>
<li><code>subindex</code>        –  SDO的子索引</li>
<li><code>data</code>            –  要下载的数据缓冲区</li>
<li><code>data_size</code>       –  数据缓冲区大小</li>
<li><code>abort_code</code>      –  SDO上传的中止代码。</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功 –  0</li>
<li>失败 –  &lt; 0</li>
</ul>
</li>
</ul>
<h2 id="ecrt-domain-reg-pdo-entry-list"><a href="#ecrt-domain-reg-pdo-entry-list" class="headerlink" title="ecrt_domain_reg_pdo_entry_list"></a><code>ecrt_domain_reg_pdo_entry_list</code></h2><ul>
<li>简介：为一个域注册一堆PDO条目。此方法必须在<code>ecrt_master_activate()</code>之前在非实时上下文中调用。</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_domain_reg_pdo_entry_list</span><span class="params">(<span class="type">ec_domain_t</span> *domain, <span class="type">const</span> <span class="type">ec_pdo_entry_reg_t</span> *pdo_entry_regs)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>domain</code>  – 域</li>
<li><code>pdo_entry_regs</code>  – PDO注册数组。注册数组必须以一个空结构体结束，或者将\a索引字段设置为0 !</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – 0</li>
<li>失败  – 其他</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-activate"><a href="#ecrt-master-activate" class="headerlink" title="ecrt_master_activate"></a><code>ecrt_master_activate</code></h2><ul>
<li>简介：完成配置阶段并为循环操作做准备。<ul>
<li>这个函数告诉主机配置阶段已经完成，将开始实时操作。</li>
<li>该函数为域分配内部内存，并为域成员计算逻辑FMMU地址。</li>
<li>它告诉主状态机现在要应用总线配置。</li>
<li>调用此函数后，实时应用程序负责循环调用<code>ecrt_master_send()</code>和<code>ecrt_master_receive()</code>以确保总线通信。</li>
<li>在调用这个函数之前，由主线程负责，所以这些函数可能不会被调用!</li>
<li>该方法本身分配内存，不应该在实时上下文中调用。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_activate</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  EtherCAT 主站</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – 0</li>
<li>失败  – &lt; 0</li>
</ul>
</li>
</ul>
<h2 id="ecrt-domain-data"><a href="#ecrt-domain-data" class="headerlink" title="ecrt_domain_data"></a><code>ecrt_domain_data</code></h2><ul>
<li>简介：返回域的过程数据。<ul>
<li>在内核上下文中:<ul>
<li>如果使用<code>ecrt_domain_external_memory()</code>提供外部内存，则返回的指针将包含该内存的地址。</li>
<li>否则它将指向内部分配的内存。</li>
<li>在后一种情况下，在<code>ecrt_master_activate()</code>之前不能调用此方法。</li>
</ul>
</li>
<li>在用户空间上下文中:<ul>
<li>必须在<code>ecrt_master_activate()</code>之后调用此方法以获取映射的域进程数据内存。</li>
</ul>
</li>
</ul>
</li>
<li>声明：<code>uint8_t *ecrt_domain_data(ec_domain_t *domain);</code></li>
<li>参数：<ul>
<li><code>domain</code>  –  域</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回指向过程数据内存区域的指针</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-select-reference-clock"><a href="#ecrt-master-select-reference-clock" class="headerlink" title="ecrt_master_select_reference_clock"></a><code>ecrt_master_select_reference_clock</code></h2><ul>
<li>简介：为分布式时钟选择参考时钟。如果这个方法没有被某个主时钟调用，或者从时钟配置指针为NULL，那么第一个具有DC功能的从时钟将提供参考时钟。</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_select_reference_clock</span><span class="params">(<span class="type">ec_master_t</span> *master, <span class="type">ec_slave_config_t</span> *sc)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  EtherCAT 主站</li>
<li><code>sc</code>      –  Slave的Slave配置要引用的Slave(或NULL)。</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – 0</li>
<li>失败  –  负数，错误码</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-application-time"><a href="#ecrt-master-application-time" class="headerlink" title="ecrt_master_application_time"></a><code>ecrt_master_application_time</code></h2><ul>
<li>简介：设置应用时间。在使用分布式时钟操作从服务器时，主服务器必须知道应用程序的时间。主程序本身不会增加时间，因此必须循环调用此方法。<ul>
<li>传递给该方法的时间用于计算从服务器的SYNC0&#x2F;1中断的阶段。它应该经常在实时周期的同一点被调用。因此，建议在计算开始时调用它，以避免由于执行时间的变化而导致的偏差。</li>
<li>该时间用于设置从机的系统时间偏移和循环操作开始时间寄存器，以及通过ecrt_master_sync_reference_clock()将DC参考时钟同步到应用程序时间。</li>
<li>时间定义为从2000-01-01 00:00开始的纳秒。可以使用EC_TIMEVAL2NANO()宏来转换epoch时间，但这不是必需的，因为绝对值无关紧要</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_application_time</span><span class="params">(<span class="type">ec_master_t</span> *master, <span class="type">uint64_t</span> app_time)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  EtherCAT 主站</li>
<li><code>app_time</code>  –  应用时间</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-sync-reference-clock"><a href="#ecrt-master-sync-reference-clock" class="headerlink" title="ecrt_master_sync_reference_clock"></a><code>ecrt_master_sync_reference_clock</code></h2><ul>
<li>简介：将DC参考时钟漂移补偿数据报排队发送。参考时钟将被同步到由最后一次调用取消ecrt_master_application_time()提供的应用程序时间。</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_sync_reference_clock</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  EtherCAT 主站</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-sync-slave-clocks"><a href="#ecrt-master-sync-slave-clocks" class="headerlink" title="ecrt_master_sync_slave_clocks"></a><code>ecrt_master_sync_slave_clocks</code></h2><ul>
<li>简介：将DC时钟漂移补偿数据报排队发送。所有从时钟同步到参考时钟。</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_sync_slave_clocks</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  EtherCAT 主站</li>
</ul>
</li>
</ul>
<h2 id="ecrt-release-master"><a href="#ecrt-release-master" class="headerlink" title="ecrt_release_master"></a><code>ecrt_release_master</code></h2><ul>
<li>简介：释放一个请求的EtherCAT主机。<ul>
<li>在使用后，必须释放master，以便其他应用程序可以使用它。</li>
<li>此方法释放所有已创建的数据结构。它不应该在实时上下文中调用。</li>
<li>如果主站被激活，则内部调用<code>ecrt_master_deactivate()</code>。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_release_master</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  EtherCAT 主站</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-receive"><a href="#ecrt-master-receive" class="headerlink" title="ecrt_master_receive"></a><code>ecrt_master_receive</code></h2><ul>
<li>简介：从硬件中获取接收到的帧并处理数据报。<ul>
<li>通过调用中断服务例程查询网络设备接收的帧。</li>
<li>提取接收到的数据报，并将结果分派到队列中的数据报对象。</li>
<li>接收到的数据报和超时的数据报将被标记，并退出队列</li>
<li>必须在<code>ecrt_master_activate()</code>返回后由实时应用程序循环调用。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_receive</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ecrt-domain-process"><a href="#ecrt-domain-process" class="headerlink" title="ecrt_domain_process"></a><code>ecrt_domain_process</code></h2><ul>
<li>简介：确定域的数据报的状态。<ul>
<li>计算接收到的数据报的工作计数器，并在必要时输出统计信息。</li>
<li>这必须在<code>ecrt_master_receive()</code>接收域数据报之后调用，以便使<code>ecrt_domain_state()</code>返回最后一次进程数据交换的结果。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_domain_process</span><span class="params">(<span class="type">ec_domain_t</span> *domain)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ecrt-domain-queue"><a href="#ecrt-domain-queue" class="headerlink" title="ecrt_domain_queue"></a><code>ecrt_domain_queue</code></h2><ul>
<li>简介：(Re-)将所有域数据报放在主数据报队列中。调用此函数来标记域的数据报，以便在下一次调用<code>ecrt_master_send()</code>时进行交换</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_domain_queue</span><span class="params">(<span class="type">ec_domain_t</span> *domain)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ecrt-master-send"><a href="#ecrt-master-send" class="headerlink" title="ecrt_master_send"></a><code>ecrt_master_send</code></h2><ul>
<li>简介：发送队列中的所有数据报。<ul>
<li>该方法获取所有已排队等待传输的数据报，将它们放入帧中，并将它们传递给以太网设备进行发送。</li>
<li>必须在<code>ecrt_master_activate()</code>返回后由应用程序循环调用。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_send</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ecrt-domain-state"><a href="#ecrt-domain-state" class="headerlink" title="ecrt_domain_state"></a><code>ecrt_domain_state</code></h2><ul>
<li>简介：读取域的状态。<ul>
<li>在给定的\a状态结构中存储域状态。</li>
<li>利用该方法，可以实时监控过程数据交换情况。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_domain_state</span><span class="params">(<span class="type">const</span> <span class="type">ec_domain_t</span> *domain, <span class="type">ec_domain_state_t</span> *state)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>domain</code>  –  域</li>
<li><code>state</code>   –  指向用于存储信息的状态对象的指针。</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-state"><a href="#ecrt-master-state" class="headerlink" title="ecrt_master_state"></a><code>ecrt_master_state</code></h2><ul>
<li>简介：读取当前主站的状态。<ul>
<li>在给定的\a状态结构中存储主站状态。</li>
<li>此方法返回一个全局状态。对于冗余总线拓扑中特定于链路的状态，请使用<code>ecrt_master_link_state()</code>方法。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_state</span><span class="params">(<span class="type">const</span> <span class="type">ec_master_t</span> *master, <span class="type">ec_master_state_t</span> *state)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  主站</li>
<li><code>state</code>   –  指向用于存储信息的状态对象的指针</li>
</ul>
</li>
</ul>
<h2 id="ecrt-slave-config-state"><a href="#ecrt-slave-config-state" class="headerlink" title="ecrt_slave_config_state"></a><code>ecrt_slave_config_state</code></h2><ul>
<li>简介：输出从站配置的状态。<ul>
<li>在给定的\a状态结构中存储状态信息。状态信息由主状态机更新，因此可能需要几个周期，直到它发生变化。</li>
<li>如果需要实时监控进程数据交换的状态，则应该使用<code>ecrt_domain_state()</code>。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_slave_config_state</span><span class="params">(<span class="type">const</span> <span class="type">ec_slave_config_t</span> *sc, <span class="type">ec_slave_config_state_t</span> *state)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>sc</code>  –  从站配置</li>
<li><code>state</code>  –  需要写入的状态对象</li>
</ul>
</li>
</ul>
<h2 id="ecrt-request-master-1"><a href="#ecrt-request-master-1" class="headerlink" title="ecrt_request_master"></a>ecrt_request_master</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_request_master() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于请求 EtherCAT 主站的实例</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ec_master_t</span>* <span class="title">ecrt_request_master</span><span class="params">(<span class="type">uint32_t</span> master_id)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master_id：一个无符号 32 位整数，表示所请求的 EtherCAT 主站的 ID</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 ec_master_t* 类型的指针，指向请求的 EtherCAT 主站实例。</li>
<li>失败时，返回 NULL</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_request_master() 函数用于请求 EtherCAT 主站的实例，以便后续使用 EtherCAT Master Library 的其他函数进行 EtherCAT 网络的配置和操作。</li>
<li>在调用 ecrt_request_master() 函数之前，需要确保 EtherCAT Master Library 已被正确初始化。</li>
<li>master_id 参数指定所请求的 EtherCAT 主站的 ID。在系统中存在多个 EtherCAT 主站时，可以使用不同的 ID 来区分它们。</li>
<li>请求成功后，将返回指向请求的 EtherCAT 主站实例的指针。通过该指针，可以对 EtherCAT 主站进行配置、管理和操作。</li>
<li>返回的 EtherCAT 主站实例指针将用作其他 EtherCAT Master Library 函数的参数，以标识要操作的 EtherCAT 主站。</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，ecrt_request_master() 函数只是请求 EtherCAT 主站实例的第一步。在使用 EtherCAT Master Library 进行 EtherCAT 网络的配置和操作之前，还需要使用其他函数进行更详细的初始化和配置，如 ecrt_master_open()、ecrt_master_activate() 等函数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-create-domain-1"><a href="#ecrt-master-create-domain-1" class="headerlink" title="ecrt_master_create_domain"></a>ecrt_master_create_domain</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_create_domain() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于创建 EtherCAT 主站的数据域（Domain）</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ec_domain_t</span>* <span class="title">ecrt_master_create_domain</span><span class="params">(<span class="type">ec_master_t</span>* master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向已请求的 EtherCAT 主站实例的 ec_master_t* 类型指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 ec_domain_t* 类型的指针，指向创建的 EtherCAT 数据域（Domain）实例。</li>
<li>失败时，返回 NULL</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_create_domain() 函数用于创建 EtherCAT 主站的数据域，用于管理 EtherCAT 从站设备的数据通信。</li>
<li>在调用 ecrt_master_create_domain() 函数之前，需要先通过 ecrt_request_master() 函数请求 EtherCAT 主站的实例。</li>
<li>参数 master 是指向已请求的 EtherCAT 主站实例的指针，用于指定创建数据域的主站。</li>
<li>创建数据域后，可以使用其他 EtherCAT Master Library 函数来配置和管理数据域，如添加从站设备、映射对象字典、读取和写入数据等。</li>
<li>返回的数据域实例指针将用作其他 EtherCAT Master Library 函数的参数，以标识要操作的数据域</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，ecrt_master_create_domain() 函数只是创建数据域的第一步。在使用数据域进行数据通信之前，还需要使用其他函数进行更详细的配置和映射，如 ecrt_domain_register()、ecrt_domain_queue() 等函数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-slave-config"><a href="#ecrt-master-slave-config" class="headerlink" title="ecrt_master_slave_config"></a>ecrt_master_slave_config</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_slave_config() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于配置 EtherCAT 主站中的从站设备</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ec_slave_config_t</span>* <span class="title">ecrt_master_slave_config</span><span class="params">(<span class="type">ec_master_t</span>* master, <span class="type">uint16_t</span> alias, <span class="type">uint16_t</span> position, <span class="type">uint32_t</span> vendor_id, <span class="type">uint32_t</span> product_code)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向已请求的 EtherCAT 主站实例的 ec_master_t* 类型指针。</li>
<li>alias：一个无符号 16 位整数，表示从站设备的别名（Alias）。</li>
<li>position：一个无符号 16 位整数，表示从站设备的位置（Position）。</li>
<li>vendor_id：一个无符号 32 位整数，表示从站设备的供应商 ID。</li>
<li>product_code：一个无符号 32 位整数，表示从站设备的产品码</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 ec_slave_config_t* 类型的指针，指向配置的从站设备实例。</li>
<li>失败时，返回 NULL</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_slave_config() 函数用于配置 EtherCAT 主站中的从站设备。</li>
<li>在调用 ecrt_master_slave_config() 函数之前，需要先通过 ecrt_request_master() 函数请求 EtherCAT 主站的实例。</li>
<li>参数 master 是指向已请求的 EtherCAT 主站实例的指针，用于指定要配置的主站。</li>
<li>参数 alias 和 position 是从站设备的别名和位置，用于唯一标识从站设备在 EtherCAT 网络中的位置。</li>
<li>参数 vendor_id 和 product_code 是从站设备的供应商 ID 和产品码，用于识别特定的从站设备。</li>
<li>配置从站设备后，可以使用其他 EtherCAT Master Library 函数来访问和操作该设备，如读取和写入从站设备的对象字典数据等。</li>
<li>返回的从站设备实例指针将用作其他 EtherCAT Master Library 函数的参数，以标识要操作的从站设备</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，ecrt_master_slave_config() 函数只是配置从站设备的一部分。在配置从站设备后，还需要使用其他函数进行更详细的初始化和设置，如 ecrt_slave_config_pdos()、ecrt_slave_config_sdo() 等函数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-slave-config-pdos"><a href="#ecrt-slave-config-pdos" class="headerlink" title="ecrt_slave_config_pdos"></a>ecrt_slave_config_pdos</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_slave_config_pdos() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于配置从站设备的过程数据对象（Process Data Objects，PDOs）</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_slave_config_pdos</span><span class="params">(<span class="type">ec_slave_config_t</span>* config, <span class="type">int</span> direction, <span class="type">const</span> <span class="type">ec_pdo_entry_reg_t</span>* entries)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>config：指向已配置的从站设备实例的 ec_slave_config_t* 类型指针。</li>
<li>direction：整数，表示 PDO 的方向。可以是以下值之一<ul>
<li>EC_DIR_OUTPUT：表示输出 PDO。</li>
<li>EC_DIR_INPUT：表示输入 PDO</li>
</ul>
</li>
<li>entries：指向 ec_pdo_entry_reg_t 结构的指针，定义了要配置的 PDO 条目</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回一个负数表示错误码。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_slave_config_pdos() 函数用于配置从站设备的 PDOs，即定义输入和输出数据的结构和格式。</li>
<li>在调用 ecrt_slave_config_pdos() 函数之前，需要先通过 ecrt_master_slave_config() 函数配置从站设备。</li>
<li>参数 config 是指向已配置的从站设备实例的指针，用于指定要配置的从站设备。</li>
<li>参数 direction 指定 PDO 的方向，可以是输出（发送给从站设备）或输入（从从站设备接收）。</li>
<li>参数 entries 是指向 ec_pdo_entry_reg_t 结构的指针，用于定义要配置的 PDO 条目。</li>
<li>ec_pdo_entry_reg_t 结构定义了 PDO 条目的索引、子索引、数据类型、长度等信息，用于描述从站设备的数据结构。</li>
<li>通过调用 ecrt_slave_config_pdos() 函数，可以将 PDO 条目注册到指定的方向上，并配置从站设备的数据通信</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，PDO 的配置涉及到更详细的数据结构和通信配置，如 PDO 映射、PDO 类型、PDO 数据长度等。具体的操作流程和函数使用方式应根据实际需求和 EtherCAT Master Library 的文档进行进一步的学习和了解</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-domain-reg-pdo-entry-list-1"><a href="#ecrt-domain-reg-pdo-entry-list-1" class="headerlink" title="ecrt_domain_reg_pdo_entry_list"></a>ecrt_domain_reg_pdo_entry_list</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_domain_reg_pdo_entry_list() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于在数据域（Domain）中注册 PDO 条目列表</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_domain_reg_pdo_entry_list</span><span class="params">(<span class="type">ec_domain_t</span>* domain, <span class="type">const</span> <span class="type">ec_pdo_entry_reg_t</span>* entries)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>domain：指向已创建的数据域（Domain）实例的 ec_domain_t* 类型指针。</li>
<li>entries：指向 ec_pdo_entry_reg_t 结构的指针，定义了要注册的 PDO 条目列表</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回一个负数表示错误码</li>
</ul>
</li>
<li><p>说明：</p>
<ul>
<li>ecrt_domain_reg_pdo_entry_list() 函数用于在数据域中注册 PDO 条目列表，将 PDO 条目与数据域进行关联。</li>
<li>在调用 ecrt_domain_reg_pdo_entry_list() 函数之前，需要先通过 ecrt_master_create_domain() 函数创建数据域。</li>
<li>参数 domain 是指向已创建的数据域实例的指针，用于指定要注册 PDO 条目的数据域。</li>
<li>参数 entries 是指向 ec_pdo_entry_reg_t 结构的指针，定义了要注册的 PDO 条目列表。</li>
<li>ec_pdo_entry_reg_t 结构定义了 PDO 条目的索引、子索引、数据类型、长度等信息，用于描述从站设备的数据结构。</li>
<li>通过调用 ecrt_domain_reg_pdo_entry_list() 函数，可以将 PDO 条目列表注册到指定的数据域中，以便进行数据通信</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，PDO 条目的注册与数据域的映射和通信相关。在注册 PDO 条目列表后，需要使用其他函数来配置和管理数据域，如 ecrt_domain_queue()、ecrt_domain_state() 等函数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-slave-config-dc"><a href="#ecrt-slave-config-dc" class="headerlink" title="ecrt_slave_config_dc"></a>ecrt_slave_config_dc</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_slave_config_dc() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于配置从站设备的分布式时钟（Distributed Clock）</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_slave_config_dc</span><span class="params">(<span class="type">ec_slave_config_t</span>* config, <span class="type">uint32_t</span> sync0_shift, <span class="type">uint32_t</span> sync1_shift, <span class="type">uint32_t</span> sync0_cycle_time, <span class="type">uint32_t</span> sync1_cycle_time)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>config：指向已配置的从站设备实例的 ec_slave_config_t* 类型指针。</li>
<li>sync0_shift：一个无符号 32 位整数，表示 Sync 0 时钟的相位偏移。</li>
<li>sync1_shift：一个无符号 32 位整数，表示 Sync 1 时钟的相位偏移。</li>
<li>sync0_cycle_time：一个无符号 32 位整数，表示 Sync 0 时钟的周期时间。</li>
<li>sync1_cycle_time：一个无符号 32 位整数，表示 Sync 1 时钟的周期时间</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回一个负数表示错误码</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_slave_config_dc() 函数用于配置从站设备的分布式时钟，以便与 EtherCAT 网络的同步机制进行协调。</li>
<li>在调用 ecrt_slave_config_dc() 函数之前，需要先通过 ecrt_master_slave_config() 函数配置从站设备。</li>
<li>参数 config 是指向已配置的从站设备实例的指针，用于指定要配置的从站设备。</li>
<li>参数 sync0_shift 和 sync1_shift 是用于同步时钟的相位偏移值，以微秒为单位。这些值决定了从站设备与主站之间的同步关系。</li>
<li>参数 sync0_cycle_time 和 sync1_cycle_time 是 Sync 0 和 Sync 1 时钟的周期时间，以纳秒为单位。这些值决定了同步时钟的周期性。</li>
<li>通过调用 ecrt_slave_config_dc() 函数，可以配置从站设备的分布式时钟参数，以确保从站设备在 EtherCAT 网络中的同步性能</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，分布式时钟的配置涉及到与 EtherCAT 网络的同步机制和时钟同步周期的相关设置</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-activate-1"><a href="#ecrt-master-activate-1" class="headerlink" title="ecrt_master_activate"></a>ecrt_master_activate</h2><ul>
<li><p>简介</p>
<ul>
<li>ecrt_master_activate() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于激活 EtherCAT 主站。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_activate</span><span class="params">(<span class="type">ec_master_t</span>* master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向已请求的 EtherCAT 主站实例的 ec_master_t* 类型指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回一个负数表示错误码。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_activate() 函数用于激活 EtherCAT 主站，启动 EtherCAT 网络通信。</li>
<li>在调用 ecrt_master_activate() 函数之前，需要先通过 ecrt_request_master() 函数请求 EtherCAT 主站的实例，并完成主站的配置和初始化。</li>
<li>参数 master 是指向已请求的 EtherCAT 主站实例的指针，用于指定要激活的主站。</li>
<li>激活主站后，可以使用其他 EtherCAT Master Library 函数来访问和操作从站设备，如读取和写入从站设备的对象字典数据等。</li>
<li>主站激活后，开始进行 EtherCAT 网络的实时通信，主站与从站设备之间进行数据交换和同步</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，激活主站是启动 EtherCAT 网络通信的关键步骤。在激活主站之前，需要确保主站的配置和初始化工作已经完成，并且从站设备已经正确配置和连接到 EtherCAT 网络</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-domain-data-1"><a href="#ecrt-domain-data-1" class="headerlink" title="ecrt_domain_data"></a>ecrt_domain_data</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_domain_data() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于获取数据域（Domain）的数据缓冲区指针</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ecrt_domain_data</span><span class="params">(<span class="type">ec_domain_t</span>* domain)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>domain：指向已创建的数据域（Domain）实例的 ec_domain_t* 类型指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回 void* 类型的指针，指向数据域的数据缓冲区</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_domain_data() 函数用于获取数据域的数据缓冲区指针，以便读取和写入数据。</li>
<li>在调用 ecrt_domain_data() 函数之前，需要先通过 ecrt_master_create_domain() 函数创建数据域。</li>
<li>参数 domain 是指向已创建的数据域实例的指针，用于指定要获取数据的数据域。</li>
<li>通过调用 ecrt_domain_data() 函数，可以获取数据域的数据缓冲区指针，从而进行数据的读取和写入。</li>
<li>数据缓冲区的类型取决于数据域的配置，可以是一个数组或结构体，用于存储与从站设备进行通信的数据</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，数据域的数据缓冲区指针可以用于直接读取和写入数据，但在进行数据操作之前，需要确保 EtherCAT 主站已经激活并与从站设备进行通信</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-release-master-1"><a href="#ecrt-release-master-1" class="headerlink" title="ecrt_release_master"></a>ecrt_release_master</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_release_master() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于释放已分配的主站资源</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_release_master</span><span class="params">(<span class="type">ec_master_t</span>* master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向已分配的 EtherCAT 主站实例的 ec_master_t* 类型指针</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_release_master() 函数用于释放已分配的 EtherCAT 主站资源。</li>
<li>在使用 EtherCAT 主站进行通信时，需要先使用 ecrt_request_master() 函数来请求主站资源，并在使用完毕后调用 ecrt_release_master() 函数来释放这些资源。</li>
<li>参数 master 是指向已分配的 EtherCAT 主站实例的指针，用于指定要释放的主站资源。</li>
<li>调用 ecrt_release_master() 函数后，主站资源将被释放，该资源将可用于其他目的。</li>
<li>在释放主站资源之前，应确保已完成所有与从站设备的通信和操作，并确保不再需要使用主站</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，在使用 EtherCAT 主站进行通信时，应始终遵循正确的初始化、配置、通信和释放资源的流程。确保按照 EtherCAT Master Library 的文档和指导进行正确的函数调用和顺序。</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-application-time-1"><a href="#ecrt-master-application-time-1" class="headerlink" title="ecrt_master_application_time"></a>ecrt_master_application_time</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_application_time() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于设置 EtherCAT 主站的应用程序时间</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_application_time</span><span class="params">(<span class="type">uint64_t</span> cycletime)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>cycletime：以纳秒为单位表示的 EtherCAT 主站的应用程序周期时间</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果设置成功，返回 0。</li>
<li>如果设置失败，返回一个负数，表示错误的原因</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_application_time() 函数用于设置 EtherCAT 主站的应用程序时间，即 EtherCAT 通信的周期时间。</li>
<li>要使用 ecrt_master_application_time() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>cycletime 参数指定 EtherCAT 主站的应用程序周期时间，以纳秒为单位。它定义了 EtherCAT 网络中的数据交换周期。</li>
<li>在 EtherCAT 网络中，所有从站设备都按照相同的应用程序周期时间进行通信。</li>
<li>通过调用 ecrt_master_application_time() 函数，可以设置主站的应用程序周期时间，以确保从站设备之间的同步性。</li>
<li>设置应用程序周期时间后，主站将按照该周期周期性地发送和接收数据，从而实现同步和通信。</li>
<li>返回值为 0 表示设置成功，否则表示设置失败，可以根据返回值进行错误处理</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_master_application_time() 函数进行 EtherCAT 主站的应用程序时间设置时，需要确保对应的 EtherCAT 主站驱动库支持该功能，并且遵循相关的使用要求和限制</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-receive-1"><a href="#ecrt-master-receive-1" class="headerlink" title="ecrt_master_receive"></a>ecrt_master_receive</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_receive() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于接收从站设备发送的数据</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_receive</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向 EtherCAT 主站的指针，表示要接收数据的主站</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果接收数据成功，返回 0。</li>
<li>如果接收数据失败，返回一个负数，表示错误的原因</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_receive() 函数用于从 EtherCAT 主站接收从站设备发送的数据。</li>
<li>要使用 ecrt_master_receive() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>通过调用 ecrt_master_receive() 函数，可以从主站接收数据，并将其存储在主站的内部数据结构中，以供后续处理和访问。</li>
<li>接收的数据通常是从站设备发送的输入数据或状态信息。</li>
<li>ecrt_master_receive() 函数会阻塞当前线程，直到接收到数据或发生错误。</li>
<li>返回值为 0 表示接收数据成功，否则表示接收数据失败，可以根据返回值进行错误处理</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_master_receive() 函数接收从站设备发送的数据时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且在调用该函数之前已经进行了相关的配置和启动操作。具体的使用方法和注意事项，应该根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-domain-process-1"><a href="#ecrt-domain-process-1" class="headerlink" title="ecrt_domain_process"></a>ecrt_domain_process</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_domain_process() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于处理 EtherCAT 领域（Domain）的数据</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_domain_process</span><span class="params">(<span class="type">ec_domain_t</span> *domain)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>domain：指向要处理的 EtherCAT 领域的指针。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果处理成功，返回 0。</li>
<li>如果处理失败，返回一个负数，表示错误的原因。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_domain_process() 函数用于处理 EtherCAT 领域中的数据，即实现从站设备的数据交换。</li>
<li>要使用 ecrt_domain_process() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>通过调用 ecrt_domain_process() 函数，可以将 EtherCAT 领域中的数据发送给从站设备，并从从站设备接收数据。</li>
<li>在 EtherCAT 网络中，一个领域包含了一组 PDO（Process Data Object），每个 PDO 包含了从站设备的输入或输出数据。</li>
<li>调用 ecrt_domain_process() 函数时，主站会将领域中的数据发送到各个从站设备，并等待从站设备发送响应数据。</li>
<li>ecrt_domain_process() 函数会阻塞当前线程，直到数据交换完成或发生错误。</li>
<li>返回值为 0 表示处理成功，否则表示处理失败，可以根据返回值进行错误处理</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_domain_process() 函数处理 EtherCAT 领域的数据时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且 EtherCAT 主站和从站设备已经正确配置和启动。具体的使用方法和注意事项，应该根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-state-1"><a href="#ecrt-master-state-1" class="headerlink" title="ecrt_master_state"></a>ecrt_master_state</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_state() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于获取 EtherCAT 主站的状态信息</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ec_master_state_t</span> <span class="title">ecrt_master_state</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向 EtherCAT 主站的指针，表示要获取状态信息的主站</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>ec_master_state_t 类型的值，表示 EtherCAT 主站的状态信息</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_state() 函数用于获取 EtherCAT 主站的状态信息，如主站是否启动、错误状态等。</li>
<li>要使用 ecrt_master_state() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>通过调用 ecrt_master_state() 函数，可以获取主站的当前状态信息。</li>
<li>返回的 ec_master_state_t 类型的值包含了主站的各种状态信息，如启动状态、错误状态、从站数量等。</li>
<li>ec_master_state_t 是一个结构体，包含了以下成员变量：<ul>
<li>int slaves_responding：应答的从站数量。</li>
<li>int al_states：AL 状态。</li>
<li>int link_up：链路是否连接。</li>
<li>int linking：链路状态。</li>
<li>int operational：主站是否进入操作状态。</li>
<li>int error_flag：错误标志。</li>
<li>int slave_states：从站状态</li>
</ul>
</li>
<li>您可以通过访问返回的 ec_master_state_t 结构体的成员变量来获取各个状态信息。</li>
<li>使用 ecrt_master_state() 函数可以帮助您监控和了解 EtherCAT 主站的状态，以便进行适当的处理和错误处理</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_master_state() 函数获取 EtherCAT 主站状态信息时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且主站已经正确配置和启动。具体的使用方法和注意事项，应根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-slave-config-state-1"><a href="#ecrt-slave-config-state-1" class="headerlink" title="ecrt_slave_config_state"></a>ecrt_slave_config_state</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_slave_config_state() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于获取 EtherCAT 从站配置对象的状态信息</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ec_slave_config_state_t</span> <span class="title">ecrt_slave_config_state</span><span class="params">(<span class="type">ec_slave_config_t</span> *slave_config)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>slave_config：指向 EtherCAT 从站配置对象的指针，表示要获取状态信息的从站配置对象</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>ec_slave_config_state_t 类型的值，表示 EtherCAT 从站配置对象的状态信息</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_slave_config_state() 函数用于获取 EtherCAT 从站配置对象的状态信息，如从站是否应答、错误状态等。</li>
<li>要使用 ecrt_slave_config_state() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>通过调用 ecrt_slave_config_state() 函数，可以获取从站配置对象的当前状态信息。</li>
<li>返回的 ec_slave_config_state_t 类型的值包含了从站配置对象的各种状态信息，如从站是否应答、错误状态、应答延迟等。</li>
<li>ec_slave_config_state_t 是一个结构体，包含了以下成员变量：<ul>
<li>int online：从站是否在线。</li>
<li>int operational：从站是否进入操作状态。</li>
<li>int al_state：从站的 AL 状态。</li>
<li>int state：从站的状态。</li>
<li>int error_flag：错误标志。</li>
<li>int response_delay：应答延迟</li>
</ul>
</li>
<li>您可以通过访问返回的 ec_slave_config_state_t 结构体的成员变量来获取各个状态信息。</li>
<li>使用 ecrt_slave_config_state() 函数可以帮助您监控和了解 EtherCAT 从站配置对象的状态，以便进行适当的处理和错误处理</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_slave_config_state() 函数获取 EtherCAT 从站配置对象状态信息时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且相关的从站配置对象已经正确配置和启动。具体的使用方法和注意事项，应根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-sync-reference-clock-1"><a href="#ecrt-master-sync-reference-clock-1" class="headerlink" title="ecrt_master_sync_reference_clock"></a>ecrt_master_sync_reference_clock</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_sync_reference_clock() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于同步 EtherCAT 主站的参考时钟。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_sync_reference_clock</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向 EtherCAT 主站的指针，表示要同步参考时钟的主站。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_sync_reference_clock() 函数用于同步 EtherCAT 主站的参考时钟，以确保整个 EtherCAT 网络的同步性。</li>
<li>要使用 ecrt_master_sync_reference_clock() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>在 EtherCAT 网络中，参考时钟用于同步主站和从站设备的通信，以保证数据的准确性和一致性。</li>
<li>调用 ecrt_master_sync_reference_clock() 函数时，主站会发送同步命令，从而启动参考时钟的同步过程。</li>
<li>在同步过程中，主站会等待从站设备应答并进行相应的时钟调整，以达到整个网络的同步。</li>
<li>一旦参考时钟同步完成，主站和从站设备之间的通信将在同一时基上进行。</li>
<li>ecrt_master_sync_reference_clock() 函数通常在 EtherCAT 网络启动之前被调用，以确保网络中的设备在通信开始之前具有一致的时钟。</li>
<li>请注意，EtherCAT 网络中的参考时钟同步是非常重要的，因为它直接影响到数据的传输和同步性能</li>
</ul>
</li>
<li><p>注:</p>
<ul>
<li>需要注意的是，使用 ecrt_master_sync_reference_clock() 函数进行参考时钟同步时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且主站和从站设备已经正确配置和启动。具体的使用方法和注意事项，应根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-sync-slave-clocks-1"><a href="#ecrt-master-sync-slave-clocks-1" class="headerlink" title="ecrt_master_sync_slave_clocks"></a>ecrt_master_sync_slave_clocks</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_sync_slave_clocks() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于同步 EtherCAT 从站的时钟</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_sync_slave_clocks</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向 EtherCAT 主站的指针，表示要同步从站时钟的主站</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_sync_slave_clocks() 函数用于同步 EtherCAT 主站下所有从站的时钟，以确保整个 EtherCAT 网络中从站设备之间的时钟同步。</li>
<li>要使用 ecrt_master_sync_slave_clocks() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>在 EtherCAT 网络中，从站设备的时钟同步是重要的，以保证数据的传输和同步性能。</li>
<li>调用 ecrt_master_sync_slave_clocks() 函数时，主站会发送同步命令，通知所有从站设备进行时钟调整。</li>
<li>从站设备会根据主站发送的同步命令进行时钟调整，以达到整个网络的同步。</li>
<li>一旦从站时钟同步完成，主站和从站设备之间的通信将在同一时基上进行。</li>
<li>ecrt_master_sync_slave_clocks() 函数通常在 EtherCAT 网络启动之前被调用，以确保网络中的所有从站设备在通信开始之前具有一致的时钟。</li>
<li>请注意，EtherCAT 网络中从站的时钟同步对于数据的传输和同步性能非常重要</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_master_sync_slave_clocks() 函数进行从站时钟同步时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且主站和从站设备已经正确配置和启动。具体的使用方法和注意事项，应根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-domain-queue-1"><a href="#ecrt-domain-queue-1" class="headerlink" title="ecrt_domain_queue"></a>ecrt_domain_queue</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_domain_queue() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于将数据写入 EtherCAT 数据域（Domain）</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_domain_queue</span><span class="params">(<span class="type">ec_domain_t</span> *domain)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>domain：指向 EtherCAT 数据域（Domain）的指针，表示要将数据写入的数据域</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_domain_queue() 函数用于将数据写入 EtherCAT 数据域，以进行数据传输和同步。</li>
<li>要使用 ecrt_domain_queue() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>EtherCAT 数据域是用于存储和传输与从站设备通信的数据的内存区域。</li>
<li>通过调用 ecrt_domain_queue() 函数，可以将待发送的数据放入数据域中，以待发送到从站设备。</li>
<li>调用 ecrt_domain_queue() 函数后，数据将进入数据域的发送队列，等待适当的时间点发送到从站设备。</li>
<li>一旦数据被发送到从站设备，从站设备将读取并处理这些数据，以进行数据交换和通信。</li>
<li>使用 ecrt_domain_queue() 函数可以实现周期性的数据传输和同步，以满足实时控制系统的要求</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_domain_queue() 函数进行数据域写入时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且相关的数据域已经正确配置和启动。具体的使用方法和注意事项，应根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-send-1"><a href="#ecrt-master-send-1" class="headerlink" title="ecrt_master_send"></a>ecrt_master_send</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_send() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于发送数据到 EtherCAT 从站设备。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_send</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向 EtherCAT 主站的指针，表示要发送数据的主站</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>ecrt_master_send() 函数返回一个整数值，表示发送操作的结果。通常情况下，0 表示成功，负数表示失败</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_send() 函数用于向 EtherCAT 从站设备发送数据，以进行数据传输和通信。</li>
<li>要使用 ecrt_master_send() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>在 EtherCAT 网络中，主站负责向从站设备发送数据，并处理从站设备的应答。</li>
<li>通过调用 ecrt_master_send() 函数，可以触发主站向从站设备发送先前通过 ecrt_domain_queue() 函数放置在数据域中的数据。</li>
<li>当调用 ecrt_master_send() 函数时，主站将按照预定的通信周期发送数据到从站设备。</li>
<li>ecrt_master_send() 函数会阻塞主线程，直到发送操作完成或发生错误。</li>
<li>发送操作完成后，可以通过调用 ecrt_master_state() 函数来检查发送的结果状态</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_master_send() 函数发送数据时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且相关的数据域已经正确配置和启动。具体的使用方法和注意事项，应根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/GitHub/2024-05-22-Github/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/GitHub/2024-05-22-Github/" class="post-title-link" itemprop="url">Github</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GitHub/" itemprop="url" rel="index"><span itemprop="name">GitHub</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>github 平台使用</li>
</ul>
<h2 id="使用https"><a href="#使用https" class="headerlink" title="使用https"></a>使用https</h2><ul>
<li><p>清除所有的git配置</p>
<ul>
<li>sudo aptitude purge git</li>
</ul>
</li>
<li><p>在github生成token，它具有访问项目的权限</p>
</li>
<li><p>安装gh工具</p>
<ul>
<li>sudo apt install gh</li>
</ul>
</li>
<li><p>配置个人信息</p>
<ul>
<li>gh auth login</li>
<li>username: </li>
<li>token</li>
</ul>
</li>
<li><p>git使用https</p>
</li>
</ul>
<h2 id="git-clone-出错"><a href="#git-clone-出错" class="headerlink" title="git clone 出错"></a>git clone 出错</h2><ul>
<li>今天克隆GitHub仓库中的项目时，执行git clone git:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;Tangram-Android.git却失败报错：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &#x27;Tangram-Android&#x27;...</span><br><span class="line">fatal: unable to access &#x27;http://github.com/alibaba/Tangram-Android.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure></li>
<li>解决方法，需要执行以下两个步骤：<ul>
<li>输入git config –global http.sslVerify “false”，解除SSL验证；</li>
<li>将地址https:&#x2F;&#x2F;改为git:&#x2F;&#x2F;，避开SSL验证。</li>
</ul>
</li>
</ul>
<h2 id="git连接到github远程仓库，并提交代码至远程仓库"><a href="#git连接到github远程仓库，并提交代码至远程仓库" class="headerlink" title="git连接到github远程仓库，并提交代码至远程仓库"></a>git连接到github远程仓库，并提交代码至远程仓库</h2><ul>
<li><p>设置用户名和邮箱</p>
<ul>
<li><code>git config --global user.name &quot;elliot53&quot;</code></li>
<li><code>git config --global user.email &quot;1604244855@qq.com&quot;</code></li>
</ul>
</li>
<li><p>查看配置的用户名和邮箱</p>
<ul>
<li><code>git config user.name</code></li>
<li><code>git config user.email</code></li>
</ul>
</li>
<li><p>生成SSH Key密钥</p>
<ul>
<li><code>ssh-keygen -t rsa -C &quot;1604244855@qq.com&quot;</code></li>
<li>连续按下三次回车，密钥会在第一次回车的时候，输出密钥文件将要保存的位置</li>
</ul>
</li>
<li><p>获取SSH Key密钥</p>
<ul>
<li><code>cat /root/.ssh/rsa.pub</code></li>
<li>选中并复制全部密钥（ssh-rsa开始，一直到.com结束）</li>
</ul>
</li>
<li><p>配置github密钥</p>
<ul>
<li>打开github-settings</li>
<li>选择SSH and GPG keys</li>
<li>点击New SSH key </li>
<li>填入title和key</li>
</ul>
</li>
<li><p>在本地仓库配置远程仓库地址，本地仓库链接远程仓库</p>
<ul>
<li>复制远程仓库的ssh地址</li>
<li><code>git remote add origin_ssh ssh@github.com/elliot53/notes.git</code></li>
</ul>
</li>
<li><p>测试链接是否成功</p>
<ul>
<li><code>ssh -T git@github.com</code></li>
</ul>
</li>
<li><p>脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;elliot53&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;1604244855@qq.com&quot;</span></span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;1604244855@qq.com&quot;</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br><span class="line">git remote add origin_ssh ssh@github.com/elliot53/notes.git</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="什么是GitHub-Actions"><a href="#什么是GitHub-Actions" class="headerlink" title="什么是GitHub Actions"></a>什么是GitHub Actions</h2><ul>
<li><p>一个简单的需求，是在仓库出现更改时自动更新构建与部署博客。其实，监视仓库并在由改动时自动执行一系列动作是非常广泛的需求。软件开发工作中，经常需要对新添加的代码随时进行测试，或者进行部署，都是通过这样的自动化流程实现的。</p>
</li>
<li><p>实际上，这类服务还有个专业名词: 持续集成(Continuous Intergration)&#x2F;持续部署(Continuous Deploy)，简称CI&#x2F;CD</p>
</li>
<li><p>此前，最广泛使用的CI服务当属于Travis CI;现在GitHub也推出了自家的CI服务GitHub Actions。</p>
</li>
<li><p>当仓库收到新的更新(push)时,GitHub会根据仓库中.github&#x2F;workflows文件夹下的YAML配置文件启动CI流程</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Logger/2024-05-22-glog_log4cpluc_spdlog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Logger/2024-05-22-glog_log4cpluc_spdlog/" class="post-title-link" itemprop="url">glog_log4cpluc_spdlog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Logger/" itemprop="url" rel="index"><span itemprop="name">Logger</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>深入探讨三个流行的C++日志库： glog, log4cplug, spdlog</li>
<li>glog、log4cplus 和 spdlog，这三个日志库各有千秋，它们在性能、功能和易用性方面都有各自的优势</li>
<li>探讨它们如何处理日志滚动、如何配置日志清理策略，以及如何实现自定义的日志管理策略</li>
</ul>
<h2 id="glog-日志库"><a href="#glog-日志库" class="headerlink" title="glog 日志库"></a>glog 日志库</h2><ul>
<li><p>glog，即Google Logging Library，是由Google开发的一款高效的日志库，广泛应用于C++项目中。它提供了丰富的日志记录功能，包括日志级别、条件日志、日志滚动等。</p>
</li>
<li><p>glog 是一个为了满足高性能需求而设计的日志库，它支持多线程环境，能够在不同的日志级别上打印信息，并且支持日志滚动。日志滚动是一种常见的日志管理策略，用于防止日志文件无限制地增长，占用过多的磁盘空间</p>
</li>
<li><p>glog 支持基于文件大小的日志滚动。当日志文件达到预设的大小限制时，glog 会自动将当前日志文件重命名为备份文件，并创建一个新的日志文件继续写入。这个过程是自动的，对程序运行无影响。</p>
</li>
<li><p>虽然 glog 支持日志滚动，但它并不直接提供日志清理的功能。这意味着随着时间的推移，日志文件会不断累积，可能会占用大量的磁盘空间。为了解决这个问题，你可能需要依赖外部工具或者自己编写脚本来定期清理旧的日志文件。</p>
</li>
<li><p>虽然 glog 本身不提供日志清理的功能，但你可以通过实现自定义的清理策略来管理日志文件。这通常涉及到文件系统操作，如检查文件的创建时间、大小等属性，然后根据你的清理策略删除旧的日志文件</p>
</li>
</ul>
<h2 id="log4cplus"><a href="#log4cplus" class="headerlink" title="log4cplus"></a>log4cplus</h2><ul>
<li><p>log4cplus 是一个灵活且易于使用的日志库，它提供了丰富的日志记录功能，包括日志级别、日志格式化、日志滚动和日志清理等。它的设计哲学是使日志记录尽可能地简单而不失灵活性</p>
</li>
<li><p>log4cplus 提供了多种日志滚动策略，包括基于文件大小的滚动 (RollingFileAppender) 和基于时间的滚动 (DailyRollingFileAppender 和 TimeBasedRollingFileAppender)</p>
</li>
<li><p>RollingFileAppender 允许日志文件在达到指定大小时滚动。你可以配置 MaxFileSize 和 MaxBackupIndex 来控制日志文件的最大大小和备份文件的数量。</p>
</li>
<li><p>DailyRollingFileAppender 和 TimeBasedRollingFileAppender 提供了基于时间的日志滚动策略，允许你按照每天或者更精细的时间间隔来滚动日志文件。</p>
</li>
<li><p>log4cplus 的日志清理策略通常与日志滚动策略结合使用。通过配置 MaxBackupIndex，你可以限制保留的备份文件数量，从而实现基于文件个数的日志清理</p>
</li>
<li><p>然而，log4cplus 不直接提供基于时间的日志清理策略。如果你需要根据日志文件的创建时间或最后修改时间来清理日志，你可能需要实现自定义的 Appender 或者使用外部工具</p>
</li>
<li><p>log4cplus 支持通过 XML 或 properties 文件来配置日志管理策略，这使得你可以在不修改代码的情况下调整日志行为</p>
</li>
<li><p>如果 log4cplus 提供的日志管理策略不能满足你的需求，你可以通过继承 Appender 类来实现自定义的日志清理策略。</p>
</li>
<li><p>你需要重写 append() 方法，在这里实现你的日志清理逻辑。例如，你可以检查日志文件的创建时间或大小，并在达到一定条件时删除旧的日志文件</p>
</li>
</ul>
<h2 id="spdlog"><a href="#spdlog" class="headerlink" title="spdlog"></a>spdlog</h2><ul>
<li>spdlog 是一个快速、轻量级的日志库，它支持多线程、异步日志记录。它的设计哲学是“快速和简单”，旨在提供一个直观而强大的日志记录工具</li>
<li>spdlog 提供了多种日志滚动策略，包括按大小滚动和按时间滚动。</li>
<li>这种滚动策略会在日志文件达到一定大小时滚动日志。你可以配置 max_size 和 max_files 来控制日志文件的最大总大小和保留的日志文件的最大数量。</li>
<li>这种滚动策略会在每天的某个特定时间滚动日志。你可以配置 rotation_hour 和 rotation_minute 来决定每天滚动日志的时间。</li>
<li>spdlog 的配置通常是通过代码进行的，你需要在代码中创建和配置 Logger 和 Sink。</li>
<li>虽然 spdlog 提供了一些内置的滚动策略，但你也可以实现自己的 Sink 来实现自定义的清理策略</li>
</ul>
<h2 id="比较和总结-Comparison-and-Conclusion"><a href="#比较和总结-Comparison-and-Conclusion" class="headerlink" title="比较和总结 (Comparison and Conclusion)"></a>比较和总结 (Comparison and Conclusion)</h2><h3 id="性能比较-Performance-Comparison"><a href="#性能比较-Performance-Comparison" class="headerlink" title="性能比较 (Performance Comparison)"></a>性能比较 (Performance Comparison)</h3><ul>
<li><p>在性能方面，spdlog 通常被认为是最快的，因为它是为高性能而设计的，支持异步日志记录。glog 和 log4cplus 的性能也不错，但通常略低于 spdlog</p>
</li>
<li><p>glog：虽然 glog 提供了丰富的功能和灵活的配置，但这也使得它在性能上有所牺牲。特别是在高并发的环境下，glog 的性能可能会受到影响。</p>
</li>
<li><p>log4cplus：log4cplus 提供了更丰富的功能，包括多种 Appender 和 Layout，但这也意味着更多的性能开销。尽管如此，对于大多数应用来说，这种性能差异是可以接受的。</p>
</li>
<li><p>spdlog：spdlog 是专为高性能设计的，支持异步日志记录，能够在高并发环境下提供极高的日志记录性能。</p>
</li>
</ul>
<h3 id="功能比较-Feature-Comparison"><a href="#功能比较-Feature-Comparison" class="headerlink" title="功能比较 (Feature Comparison)"></a>功能比较 (Feature Comparison)</h3><ul>
<li><p>在功能方面，log4cplus 提供了最丰富的特性，包括多种 Appender、Layout 和日志滚动策略。glog 和 spdlog 在功能上略有不足，但仍然能满足大多数日志记录需求。</p>
</li>
<li><p>glog：提供基本的日志记录功能，支持按大小滚动日志，但在日志清理和滚动策略方面略显不足。</p>
</li>
<li><p>log4cplus：提供最丰富的功能和配置选项，支持多种日志滚动和清理策略，是功能最全面的选择。</p>
</li>
<li><p>spdlog：虽然在功能上不如 log4cplus 丰富，但 spdlog 提供了高性能的异步日志记录功能，非常适合性能敏感的应用。</p>
</li>
</ul>
<h3 id="使用场景建议-Usage-Scenario-Recommendations"><a href="#使用场景建议-Usage-Scenario-Recommendations" class="headerlink" title="使用场景建议 (Usage Scenario Recommendations)"></a>使用场景建议 (Usage Scenario Recommendations)</h3><ul>
<li>glog：适用于需要简单、高效日志记录的场景，特别是在 Google 的生态系统中。</li>
<li>log4cplus：适用于需要丰富功能和灵活配置的企业级应用，尤其是在需要复杂日志管理策略的场景。</li>
<li>spdlog：适用于性能敏感、需要高速日志记录的应用，如游戏、高频交易等。</li>
</ul>
<h3 id="总结-Conclusion"><a href="#总结-Conclusion" class="headerlink" title="总结 (Conclusion)"></a>总结 (Conclusion)</h3><ul>
<li>选择合适的日志库对于确保应用程序的稳定性和性能至关重要。glog、log4cplus 和 spdlog 都是优秀的 C++ 日志库，各有其优势和应用场景。通过本文的比较和分析，希望读者能够根据自己的具体需求，做出明智的选择。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/JSON/2024-05-22-json_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/JSON/2024-05-22-json_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">json_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JSON/" itemprop="url" rel="index"><span itemprop="name">JSON</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>JSON，指的是JavaScript对象表示法(JavaScript Object Notation)</li>
<li>JSON是轻量级的文本数据交换格式</li>
<li>JSON独立于语言，JSON使用Javascript语法来描述数据对象，但是JSON仍然独立于语言和平台。JSON解析器和JSON库支持许多种不同的编程语言。目前非常多的动态编程语言都支持JSON</li>
<li>JSON具有自我描述性，更容易理解</li>
</ul>
<h2 id="与XML相同之处"><a href="#与XML相同之处" class="headerlink" title="与XML相同之处"></a>与XML相同之处</h2><ul>
<li>JSON和XML都用于接收Web服务端的数据</li>
<li>JSON是纯文本</li>
<li>JSON具有自我描述性（人类可读）</li>
<li>JSON具有层级结构（值中存在值）</li>
<li>JSON可通过JavaScript进行解析</li>
<li>JSON数据可使用AJAX进行传输</li>
</ul>
<h2 id="JSON语法规则"><a href="#JSON语法规则" class="headerlink" title="JSON语法规则"></a>JSON语法规则</h2><ul>
<li><p>JSON语法是JavaScript对象表示语法的子集</p>
</li>
<li><p>数据在名称&#x2F;值对中</p>
</li>
<li><p>数据由逗号<code>,</code>分隔</p>
</li>
<li><p>使用斜杠<code>\</code>来转义字符</p>
</li>
<li><p>大括号<code>&#123;&#125;</code>保存对象</p>
</li>
<li><p>中括号<code>[]</code>保存数组，数组可以包含多个对象</p>
</li>
<li><p>JSON的两种结构</p>
<ul>
<li>对象：大括号<code>&#123;&#125;</code>保存的对象是一个无序的名称&#x2F;值对集合。一个对象以左括号<code>&#123;</code>开始，右括号<code>&#125;</code>结束。每个键后跟一个冒号<code>:</code>，名称&#x2F;值对使用逗号<code>,</code>分隔。</li>
<li>数组：中括号<code>[]</code>保存的数组是值(value)的有序集合。一个数组以左中括号<code>[</code>开始，右中括号<code>]</code>结束，值之间使用逗号<code>,</code>分隔。值(value)可以是双引号括起来的字符串，数值，true, false, null, 对象或者数组，它们是可以嵌套的</li>
</ul>
</li>
</ul>
<h2 id="JSON名称-值对"><a href="#JSON名称-值对" class="headerlink" title="JSON名称&#x2F;值对"></a>JSON名称&#x2F;值对</h2><ul>
<li>JSON数据的书写格式是:<code>key:value</code></li>
<li>名称&#x2F;值对包括字段名称（在双引号中），后面写一个冒号，然后值：<code>&quot;name&quot;:&quot;abc&quot;</code>，等价于JavaScript语句：<code>name = &quot;abc&quot;</code></li>
</ul>
<h2 id="C-处理JSON的开源库"><a href="#C-处理JSON的开源库" class="headerlink" title="C++处理JSON的开源库"></a>C++处理JSON的开源库</h2><p>在C++中，有多个流行的库可以用于处理JSON数据。以下是一些常用的C++ JSON处理库：</p>
<ol>
<li><p><strong>RapidJSON</strong>: RapidJSON是一个高性能的JSON解析和生成库，提供了灵活的API和丰富的功能。它具有快速的解析速度和低内存占用，并支持DOM和SAX风格的API。</p>
</li>
<li><p><strong>jsoncpp</strong>: jsoncpp是一个简单易用的C++ JSON库，提供了方便的API用于解析和生成JSON数据。它支持将JSON数据与C++对象进行相互转换，并提供了灵活的配置选项。</p>
</li>
<li><p><strong>nlohmann&#x2F;json</strong>: nlohmann&#x2F;json是一个现代化的C++ JSON库，具有简单易用的API和高性能。它支持以类似于JavaScript的方式访问和操作JSON数据，并提供了方便的函数和操作符用于序列化和反序列化。</p>
</li>
</ol>
<p>这些库都是开源库，可以从它们的官方网站或代码托管平台获取源代码和使用文档。你可以选择适合你项目需求和编程风格的库来处理JSON数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8%E5%AD%A6/" class="post-title-link" itemprop="url">刚体运动学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>刚体运动学相关笔记</li>
</ul>
<h2 id="刚体运动学是什么"><a href="#刚体运动学是什么" class="headerlink" title="刚体运动学是什么"></a>刚体运动学是什么</h2><p>刚体运动学是研究刚体在空间中的运动和位置的学科。刚体是一个在运动过程中不发生形变的物体，即它的各个点在运动中相对位置不变。刚体运动学主要关注刚体的平动（直线运动）和转动（绕轴旋转）。</p>
<p>以下是刚体运动学的一些关键概念：</p>
<ol>
<li><p><strong>平动（Translation）：</strong> 刚体的平动是指整个刚体保持平行于自身的情况下沿直线运动。平动的描述通常涉及到刚体的质心、速度和加速度。</p>
</li>
<li><p><strong>转动（Rotation）：</strong> 刚体的转动是指刚体绕轴旋转。转动的描述通常包括角度、角速度和角加速度。刚体的转动可以是绕固定轴或绕刚体自身的质心轴。</p>
</li>
<li><p><strong>刚体的位姿（Pose）：</strong> 描述刚体在空间中的位置和姿态。通常用平移矢量（描述位置）和旋转矩阵或四元数（描述姿态）来表示。</p>
</li>
<li><p><strong>刚体的速度（Velocity）：</strong> 描述刚体各点在运动中的速度。对于平动，速度是常矢量；对于转动，速度是角速度矢量。</p>
</li>
<li><p><strong>刚体的加速度（Acceleration）：</strong> 描述刚体各点在运动中的加速度。对于平动，加速度是常矢量；对于转动，加速度是角加速度矢量。</p>
</li>
<li><p><strong>刚体的运动学方程（Equations of Motion）：</strong> 这是一组描述刚体运动的方程，通常涉及刚体的位姿、速度和加速度。</p>
</li>
<li><p><strong>刚体坐标系（Body-fixed Coordinate System）：</strong> 用于描述刚体运动的坐标系，通常固定在刚体上。刚体坐标系的选择对于简化运动学方程很有帮助。</p>
</li>
<li><p><strong>欧拉角（Euler Angles）：</strong> 一种描述刚体旋转的方法，使用三个角度来表示刚体的姿态。</p>
</li>
</ol>
<p>刚体运动学在机器人学、航空航天、机械工程、计算机图形学等领域都有着广泛的应用。在这些领域，研究刚体运动学有助于理解和控制物体在三维空间中的运动。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E5%BE%AE%E7%A7%AF%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E5%BE%AE%E7%A7%AF%E5%88%86/" class="post-title-link" itemprop="url">微积分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>微积分相关笔记</li>
</ul>
<h2 id="微积分是什么"><a href="#微积分是什么" class="headerlink" title="微积分是什么"></a>微积分是什么</h2><p>微积分是数学的一个分支，研究函数的变化率和积分。它由微分学和积分学两部分组成，两者是互相联系的。微积分在自然科学、工程学、计算机科学等领域中有着广泛的应用。</p>
<p>以下是微积分的主要概念：</p>
<ol>
<li><p><strong>导数（Derivative）：</strong> 导数表示函数在某一点的变化率，即函数在这一点的斜率。对于函数 (y &#x3D; f(x))，其导数通常表示为 (f’(x)) 或 (\frac{dy}{dx})。</p>
</li>
<li><p><strong>微分（Differential）：</strong> 微分是导数的一种近似，它描述函数在某一点附近的局部线性变化。微分可以用于近似计算函数在某一点的变化。</p>
</li>
<li><p><strong>积分（Integration）：</strong> 积分是导数的逆运算，表示函数的累积变化量。对于函数 (y &#x3D; f(x))，其积分通常表示为 (\int f(x) , dx)，表示 (f(x)) 关于 (x) 的积累总和。</p>
</li>
<li><p><strong>不定积分和定积分（Indefinite and Definite Integrals）：</strong> 不定积分是对函数积分得到的结果，带有一个积分常数；定积分是对函数在一个区间上的积分，表示函数在该区间上的总变化。</p>
</li>
<li><p><strong>微分方程（Differential Equations）：</strong> 微分方程描述了一个或多个未知函数及其导数之间的关系，是许多科学和工程问题的数学模型。</p>
</li>
<li><p><strong>链式法则、乘积法则和商法则（Chain Rule, Product Rule, Quotient Rule）：</strong> 这些是导数计算中的常用规则，用于计算复合函数、乘积和商的导数。</p>
</li>
<li><p><strong>定积分的应用（Applications of Definite Integrals）：</strong> 定积分在计算面积、弧长、体积、质心等方面有着广泛的应用。</p>
</li>
</ol>
<p>微积分为了解变化和量的累积提供了一种强大的工具，使得我们能够理解和分析函数的性质，并解决实际问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">优化理论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>优化理论相关笔记</li>
</ul>
<h2 id="优化理论是什么"><a href="#优化理论是什么" class="headerlink" title="优化理论是什么"></a>优化理论是什么</h2><p>优化理论是数学的一个分支，研究如何找到最佳解决方案的方法，以满足特定的目标和约束条件。在优化问题中，通常需要在给定的一组可行解中找到最优解，使得某个目标函数取得最大值或最小值。</p>
<p>以下是优化理论的一些关键概念：</p>
<ol>
<li><p><strong>目标函数（Objective Function）：</strong> 优化问题的目标是通过最小化或最大化一个目标函数来找到最佳解。目标函数通常表示为一组变量的函数。</p>
</li>
<li><p><strong>约束条件（Constraint）：</strong> 优化问题通常伴随一些约束条件，这些条件限制了变量的取值范围。优化的解决方案必须满足这些约束。</p>
</li>
<li><p><strong>最优解（Optimal Solution）：</strong> 最优解是在满足约束条件下，使目标函数取得最小值或最大值的解决方案。</p>
</li>
<li><p><strong>局部最优解和全局最优解（Local Optimum and Global Optimum）：</strong> 局部最优解是在某一邻域内为最优的解，而全局最优解是在整个解空间中为最优的解。</p>
</li>
<li><p><strong>线性规划（Linear Programming）：</strong> 一类优化问题，其中目标函数和约束条件都是线性的。线性规划在工程、经济学、运筹学等领域有广泛应用。</p>
</li>
<li><p><strong>非线性优化（Nonlinear Optimization）：</strong> 优化问题中目标函数或约束条件是非线性的。非线性优化方法用于解决这类问题，如牛顿法、梯度下降等。</p>
</li>
<li><p><strong>整数规划（Integer Programming）：</strong> 一类优化问题，其中变量被限制为整数值。整数规划在组合优化、资源分配等方面有应用。</p>
</li>
<li><p><strong>凸优化（Convex Optimization）：</strong> 一类特殊的优化问题，其中目标函数和约束条件都是凸函数。凸优化问题具有良好的性质，可以使用高效的算法求解。</p>
</li>
<li><p><strong>多目标优化（Multi-objective Optimization）：</strong> 在一个优化问题中有多个目标函数，需要找到一个平衡的解决方案。</p>
</li>
<li><p><strong>全局优化（Global Optimization）：</strong> 寻找整个解空间中的全局最优解，而不仅仅是局部最优解。</p>
</li>
</ol>
<p>优化理论在工程、经济学、运筹学、机器学习等领域都有广泛应用，它提供了一系列方法来解决复杂的决策和设计问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">数值分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>数值分析相关笔记</li>
</ul>
<h2 id="数值分析是什么"><a href="#数值分析是什么" class="headerlink" title="数值分析是什么"></a>数值分析是什么</h2><p>数值分析是数学的一个分支，研究使用数值计算方法解决数学问题的理论和算法。它主要涉及到通过计算机进行近似数值解的技术，尤其是在那些无法或难以通过解析方法得到精确解的问题上。数值分析在科学、工程、计算机科学等领域都有广泛的应用。</p>
<p>以下是数值分析的主要内容和概念：</p>
<ol>
<li><p><strong>数值逼近（Numerical Approximation）：</strong> 研究如何使用有限的计算资源来获得数学问题的近似解。这包括插值、拟合、级数展开等方法。</p>
</li>
<li><p><strong>数值解法（Numerical Methods）：</strong> 开发和分析通过计算机进行数值计算的算法，解决代数方程组、微分方程、积分等问题。常见的数值解法包括牛顿法、迭代法、龙格-库塔法等。</p>
</li>
<li><p><strong>误差分析（Error Analysis）：</strong> 研究数值计算中产生的误差，包括截断误差和舍入误差。误差分析有助于评估数值算法的准确性和稳定性。</p>
</li>
<li><p><strong>插值和拟合（Interpolation and Curve Fitting）：</strong> 插值方法用于估算在已知数据点之间的值，而拟合方法用于找到最佳拟合曲线或曲面。</p>
</li>
<li><p><strong>数值积分（Numerical Integration）：</strong> 使用数值方法计算函数在区间上的积分，例如通过数值方法计算定积分的近似值。</p>
</li>
<li><p><strong>数值微分（Numerical Differentiation）：</strong> 使用数值方法计算函数在某点的导数，尤其是在没有解析导数表达式的情况下。</p>
</li>
<li><p><strong>迭代法（Iterative Methods）：</strong> 通过反复迭代更新来逼近函数的解，是求解非线性方程、线性方程组等问题的常见方法。</p>
</li>
<li><p><strong>最优化方法（Optimization Methods）：</strong> 研究在给定约束下找到函数的最大值或最小值的数值方法。</p>
</li>
</ol>
<p>数值分析的应用非常广泛，包括工程设计、科学模拟、金融建模、图像处理、数据分析等领域。在这些领域，数值分析为复杂问题提供了有效的、可计算的解决方案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/" class="post-title-link" itemprop="url">平面几何</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>平面几何相关笔记</li>
</ul>
<h2 id="平面几何教材"><a href="#平面几何教材" class="headerlink" title="平面几何教材"></a>平面几何教材</h2><p>平面几何是几何学的一个分支，涉及二维空间内的点、线、面及其相互关系。以下是一些常见的平面几何教材，它们可能是针对不同年级和水平的学生：</p>
<ol>
<li><p>《高中数学（必修）：平面几何》 - 这是中国高中数学课程中常见的一本教材，涵盖了平面几何的基本概念、定理和解题方法。</p>
</li>
<li><p>《几何学原理》（Geometry: Euclid and Beyond）- 作者：Robin Hartshorne。这本书着重介绍了古典欧几里得几何，并深入讨论了几何学的一些高级主题，适合对几何学有深入兴趣的学生。</p>
</li>
<li><p>《平面几何学》（Plane Geometry）- 作者：George E. Martin。这本书通常作为大学本科阶段的平面几何学教材，内容涵盖了基本的几何学原理和证明方法。</p>
</li>
<li><p>《几何学》（Geometry）- 作者：David A. Brannan、Matthew F. Esplen、Jeremy J. Gray。这本书提供了一个广泛的几何学概述，适合高中或大学水平的学生，内容包括平面几何和立体几何。</p>
</li>
<li><p>《高中几何》（High School Geometry）- 作者：Jurgensen、Charles、Dolley。这是一本适用于高中学生的教材，涵盖了基本的平面几何概念和定理。</p>
</li>
</ol>
<p>请注意，教材的选择可能会根据学生的年级、水平和教学要求而有所不同。建议查看学校或课程的具体教学大纲，以选择最适合的教材。</p>
<h2 id="平面几何是什么"><a href="#平面几何是什么" class="headerlink" title="平面几何是什么"></a>平面几何是什么</h2><p>平面几何是几何学的一个分支，主要研究在一个平面上的几何关系和性质。在平面几何中，研究的对象包括点、直线、多边形、圆等在平面上的性质和相互关系。平面几何是欧几里德几何的一个主要组成部分，起源于古希腊的数学研究。</p>
<p>关键概念和主题包括：</p>
<ol>
<li><p><strong>点（Point）：</strong> 平面上的位置，用坐标 ( (x, y) ) 表示。</p>
</li>
<li><p><strong>直线（Line）：</strong> 无数个点的集合，可以用方程或者参数方程表示。</p>
</li>
<li><p><strong>线段（Segment）：</strong> 直线上两个点之间的部分。</p>
</li>
<li><p><strong>射线（Ray）：</strong> 一条起始于一个点并延伸到无穷远的直线上的部分。</p>
</li>
<li><p><strong>角（Angle）：</strong> 由两条射线或线段的夹角形成，通常用度数或弧度来度量。</p>
</li>
<li><p><strong>多边形（Polygon）：</strong> 由一系列连续的线段组成的封闭图形，如三角形、四边形等。</p>
</li>
<li><p><strong>圆（Circle）：</strong> 平面上所有到圆心的距离都相等的点的集合。</p>
</li>
</ol>
<p>平面几何的研究通常涉及基本的几何定理、公理和构造方法，以及通过这些基本概念推导出的各种性质。平面几何不仅是纯数学的一部分，而且在工程、建筑、计算机图形学等应用领域中有着广泛的应用。</p>
<h2 id="数学-平面几何-法向量是什么"><a href="#数学-平面几何-法向量是什么" class="headerlink" title="数学 平面几何 法向量是什么"></a>数学 平面几何 法向量是什么</h2><p>在平面几何中，一个平面的法向量是与该平面垂直的一个向量。法向量是描述平面方向和垂直性质的重要工具。</p>
<p>设平面的方程为 (ax + by + cz &#x3D; d)，其中 (a, b, c) 是平面的法向量的分量，而 (d) 是一个常数。法向量通常表示为<br>$$<br>\mathbf{N} &#x3D; \langle a, b, c \rangle<br>$$<br>。</p>
<p>平面的法向量具有以下性质：</p>
<ol>
<li>法向量与平面上的任意向量的点积为零，即<br>$$<br>\mathbf{N} \cdot \mathbf{V} &#x3D; 0<br>$$<br>，其中<br>$$<br>\mathbf{V}<br>$$<br>是平面上的一个向量。</li>
<li>法向量的方向与平面的法线方向一致。</li>
<li>法向量的长度表示平面到原点的距离，可以通过公式<br>$$<br>\frac{|d|}{\sqrt{a^2 + b^2 + c^2}}<br>$$<br>计算。</li>
</ol>
<p>法向量在平面几何中有多种应用，包括判断两平面的关系、求解平面的交点、计算平面的夹角等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">控制理论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>控制理论相关笔记</li>
</ul>
<h2 id="控制理论是什么"><a href="#控制理论是什么" class="headerlink" title="控制理论是什么"></a>控制理论是什么</h2><p>控制理论是研究如何设计并分析动态系统的一门工程和数学学科。它涉及系统的建模、分析、设计和优化，以便系统能够实现预期的性能和行为。控制理论广泛应用于自动化、机械工程、电气工程、航空航天、化工等领域。</p>
<p>以下是控制理论的一些关键概念：</p>
<ol>
<li><p><strong>系统（System）：</strong> 一个可以被观测和操控的实体，可以是物理系统、电气系统、生物系统等。系统通常由一组相互关联的元件组成。</p>
</li>
<li><p><strong>控制器（Controller）：</strong> 控制器是一个用于调节系统行为的设备或算法。它通过对系统的输入进行调整，使系统输出达到期望的目标。</p>
</li>
<li><p><strong>过程或系统的建模（System Modeling）：</strong> 将实际系统抽象为数学模型，以便进行分析和设计。模型可以是线性或非线性的，时变或时不变的，连续或离散的，等等。</p>
</li>
<li><p><strong>反馈控制（Feedback Control）：</strong> 反馈控制是指通过测量系统输出并将这些信息反馈到控制器，从而调整系统输入，使系统保持在期望的状态。</p>
</li>
<li><p><strong>开环和闭环控制（Open-Loop and Closed-Loop Control）：</strong> 在开环控制中，系统的输出不直接影响控制器的输入；而在闭环控制中，系统的输出被用于调整控制器的输入。</p>
</li>
<li><p><strong>稳定性分析（Stability Analysis）：</strong> 研究系统是否在长时间内保持有限的响应。稳定性分析是控制系统设计中的一个重要步骤。</p>
</li>
<li><p><strong>控制性能评估（Control Performance Evaluation）：</strong> 衡量控制系统在不同操作条件下的性能，包括稳定性、灵敏度、鲁棒性等。</p>
</li>
<li><p><strong>状态空间表示（State-Space Representation）：</strong> 将系统的动态行为表示为一组状态变量和它们的导数的方程，通常采用矩阵形式。</p>
</li>
<li><p><strong>PID控制（Proportional-Integral-Derivative Control）：</strong> 一种常见的控制策略，通过调整比例、积分和微分参数来实现系统的稳定性和性能。</p>
</li>
<li><p><strong>鲁棒控制（Robust Control）：</strong> 考虑系统参数变化和外部扰动时仍能保持良好性能的控制设计方法。</p>
</li>
</ol>
<p>控制理论的目标是设计稳定、高性能、鲁棒的控制系统，以满足特定应用领域的需求。控制理论在自动化系统、飞行器、机器人、工业过程控制等方面有广泛的应用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E6%95%B0%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E6%95%B0%E5%AD%A6/" class="post-title-link" itemprop="url">数学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>数学相关笔记</li>
</ul>
<h2 id="数学有哪些分支"><a href="#数学有哪些分支" class="headerlink" title="数学有哪些分支"></a>数学有哪些分支</h2><p>数学是一门广泛而深刻的学科，涵盖了多个分支和领域。以下是一些主要的数学分支：</p>
<ol>
<li><p><strong>代数学（Algebra）：</strong> 研究代数结构、方程、多项式、群论、环论等。它包括基本代数、抽象代数等方向。</p>
</li>
<li><p><strong>分析学（Analysis）：</strong> 研究极限、微积分、积分学、级数、实变函数、复变函数等。分析学分为实分析和复分析。</p>
</li>
<li><p><strong>几何学（Geometry）：</strong> 研究空间和图形的形状、大小、性质以及它们之间的关系。平面几何和空间几何是几何学的两个主要方向。</p>
</li>
<li><p><strong>概率论与数理统计（Probability and Statistics）：</strong> 研究随机事件、概率、统计推断、回归分析等，应用于数据分析、科学实验、风险管理等领域。</p>
</li>
<li><p><strong>数论（Number Theory）：</strong> 研究整数的性质，涉及素数、同余、数的分布等问题。</p>
</li>
<li><p><strong>拓扑学（Topology）：</strong> 研究空间的连通性、紧性、维度等概念，不关注度量和角度，而更注重形状和空间的变换。</p>
</li>
<li><p><strong>微分方程学（Differential Equations）：</strong> 研究方程中的导数和微分的关系，以及解这些方程的方法。包括常微分方程和偏微分方程。</p>
</li>
<li><p><strong>离散数学（Discrete Mathematics）：</strong> 研究离散结构，如集合、图论、逻辑、代数系统等。在计算机科学中有广泛应用。</p>
</li>
<li><p><strong>数学逻辑（Mathematical Logic）：</strong> 研究数学推理和证明的形式系统，包括命题逻辑、谓词逻辑等。</p>
</li>
<li><p><strong>运筹学（Operations Research）：</strong> 利用数学方法解决决策问题，包括线性规划、整数规划、动态规划等。</p>
</li>
<li><p><strong>应用数学（Applied Mathematics）：</strong> 将数学方法和技术应用于其他学科和实际问题，包括物理学、工程学、经济学等。</p>
</li>
</ol>
<p>这些数学分支之间有许多交叉和相互关联，数学的发展也在不断拓展和丰富这些领域。</p>
<h2 id="几何学是什么"><a href="#几何学是什么" class="headerlink" title="几何学是什么"></a>几何学是什么</h2><p>几何学是数学的一个分支，研究空间和图形的性质、形状、大小以及它们之间的相互关系。几何学关注的主要对象包括点、直线、平面、多边形、圆等几何图形，以及这些图形之间的相对位置和性质。</p>
<p>几何学可以分为平面几何和空间几何两个主要方向：</p>
<ol>
<li><p><strong>平面几何：</strong> 主要研究在一个平面上的几何关系和性质，包括点、直线、多边形、圆等在平面上的性质和相互关系。欧几里德几何是平面几何的一个经典分支，其中包含了许多基本的几何定理和公理。</p>
</li>
<li><p><strong>空间几何：</strong> 主要研究在三维空间中的几何关系和性质，涉及点、直线、平面、曲线、曲面等在空间中的相互关系。空间几何通常涉及更复杂的数学工具，如向量、矩阵等，用于描述和计算三维空间中的几何对象。</p>
</li>
</ol>
<p>几何学在数学中有着深远的影响，并且在许多其他学科中也有广泛的应用，如物理学、工程学、计算机图形学、地理学、建筑学等。它不仅关注于理论性质和证明，还在实际问题的建模、分析和解决方案中发挥着重要的作用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E7%A9%BA%E9%97%B4%E5%87%A0%E4%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E7%A9%BA%E9%97%B4%E5%87%A0%E4%BD%95/" class="post-title-link" itemprop="url">空间几何</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>空间几何相关笔记</li>
</ul>
<h2 id="空间几何是什么"><a href="#空间几何是什么" class="headerlink" title="空间几何是什么"></a>空间几何是什么</h2><p>空间几何是几何学的一个分支，主要研究三维空间中的几何关系和性质。在空间几何中，我们考虑点、直线、平面等基本几何元素在三维空间中的相互关系、位置、距离、角度等性质。</p>
<p>主要的几何元素包括：</p>
<ol>
<li><p><strong>点（Point）：</strong> 在三维空间中的位置，由坐标 ( (x, y, z) ) 表示。</p>
</li>
<li><p><strong>直线（Line）：</strong> 由无数个点组成，可以用方程或者参数方程表示。</p>
</li>
<li><p><strong>平面（Plane）：</strong> 由无数个点和直线组成，可以用法向量和一个点表示。</p>
</li>
<li><p><strong>曲线（Curve）：</strong> 在三维空间中的曲线，可以用参数方程或者其他方式表示。</p>
</li>
<li><p><strong>曲面（Surface）：</strong> 在三维空间中的曲面，可以用方程或者参数方程表示。</p>
</li>
<li><p><strong>体（Solid）：</strong> 在三维空间中的立体，可以用方程或者参数方程表示。</p>
</li>
</ol>
<p>空间几何研究的问题包括点与直线的位置关系、点与平面的位置关系、直线与平面的位置关系、两条直线的交点、两平面的交线等等。这些关系和性质在计算机图形学、计算机辅助设计（CAD）、工程学、物理学等领域都有广泛的应用。</p>
<p>在空间几何中，通常使用向量、矩阵、坐标系等工具来表示和计算几何对象的性质，以及解决几何问题。</p>
<h2 id="叉积法是什么"><a href="#叉积法是什么" class="headerlink" title="叉积法是什么"></a>叉积法是什么</h2><p>叉积法是一种基于向量叉积的几何计算方法。在三维空间中，给定两个向量 (\mathbf{v_1} &#x3D; (x_1, y_1, z_1)) 和 (\mathbf{v_2} &#x3D; (x_2, y_2, z_2))，它们的叉积 (\mathbf{v_1} \times \mathbf{v_2}) 是另一个向量，其计算方式为：</p>
<p>[<br>\mathbf{v_1} \times \mathbf{v_2} &#x3D; (y_1z_2 - z_1y_2, z_1x_2 - x_1z_2, x_1y_2 - y_1x_2)<br>]</p>
<p>叉积的结果是一个垂直于原始两个向量的新向量。具体来说，叉积的方向由右手法则确定：将右手的四指从第一个向量的方向转向第二个向量的方向，那么大拇指的方向就是叉积的方向。</p>
<p>在几何学和计算几何中，叉积有很多应用，其中之一就是判断点是否在平面内或者在某个区域内。在本讨论中，叉积被用来判断一个点是否在一个由向量围成的平面或体内。如果两个向量是线段的边，叉积法可以用来判断一个点是否在这两个点围成的区域内。</p>
<p>总体来说，叉积法通过计算向量的方向关系，可以判断点在向量所在的平面的哪一侧，从而用于解决空间几何问题。</p>
<h2 id="射线法是什么"><a href="#射线法是什么" class="headerlink" title="射线法是什么"></a>射线法是什么</h2><p>射线法是一种在计算几何中常用的方法，用于判断点是否在多边形内部。该方法基于射线与多边形的交点数量，通过统计交点的奇偶性来确定点是否在多边形内。</p>
<p>具体步骤如下：</p>
<ol>
<li>从待判断点发射一条射线（水平或垂直方向均可）。</li>
<li>记录射线与多边形的交点数量，每次与多边形的一条边相交就增加计数。</li>
<li>如果交点数量为奇数，那么点在多边形内部；如果为偶数，点在多边形外部。</li>
</ol>
<p>这个方法的原理是，如果一个点在多边形内部，那么从这个点发射的射线与多边形的边界会有奇数个交点，而如果在外部，则交点数量是偶数。这是因为多边形内的射线与多边形的边界相交的次数总是奇数，而在外部则总是偶数。</p>
<p>射线法的优点是简单易懂，适用于凸多边形和凹多边形。然而，对于自相交的多边形，射线法可能无法正确判断点的位置。</p>
<p>这个方法在计算机图形学、地理信息系统（GIS）等领域经常被使用。在实际编程中，需要考虑浮点数计算误差、边界条件等因素，以提高算法的准确性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
