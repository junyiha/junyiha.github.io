<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/14/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-09 14:02:38" itemprop="dateModified" datetime="2025-06-09T14:02:38+08:00">2025-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>深度学习 模型 相关理论基础</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/DeepLearning/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-DL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-DL/" class="post-title-link" itemprop="url">DL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>深度学习（deep learning）是机器学习的分支，是一种以<strong>人工神经网络</strong>为架构，对资料进行<strong>表征学习</strong>的算法。</li>
<li>深度学习的好处是用非监督式或半监督式的特征学习和分层提取高效算法来替代手工获取特征。</li>
<li>表征学习的目标是寻求更好的表示方法并建立更好的模型来从大规模未标记数据中学习这些表示方法。表示方法来自神经科学，并松散地建立在类似神经系统中的信息处理和对通信模式的理解上</li>
<li>至今已有深度学习框架，如<ol>
<li>深度神经网络</li>
<li>卷积神经网络</li>
<li>深度置信网络</li>
<li>循环神经网络</li>
</ol>
</li>
<li>深度学习的基础是机器学习中的<strong>分散表示（distributed representation）</strong>。分散表示假定观测值是由不同因子相互作用生成。在此基础上，深度学习进一步假定这一相互作用的过程可分为多个层次，代表对观测值的多层抽象。不同的层数和层的规模可用于不同程度的抽象。</li>
</ol>
<h1 id="神经网络（西瓜书）"><a href="#神经网络（西瓜书）" class="headerlink" title="神经网络（西瓜书）"></a>神经网络（西瓜书）</h1><ol>
<li>神经元模型<ol>
<li>神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所做出的交互反应。[Kohonen,  1988]</li>
<li>神经网络中最基本的成分是神经元（neuron）模型，即上述定义中的“简单单元”</li>
<li>感知机与多层网络<ol>
<li>感知机（Perceptron）由两层神经元组成，输入层接受外界输入信号后传递给输出层，输出层是M-P神经元，亦称“阈值逻辑单元”（threshold logic unit）</li>
<li>输出层与输入层之间的一层神经元，被称为隐层或隐含层（hidden layer），隐含层和输出层神经元都是拥有激活函数的功能神经元</li>
<li>常见的神经网络，每层神经元与下一层神经元全互连，神经元之间不存在同层连接，也不存在跨层连接，这样的神经网络结构通常称为“多层前馈神经网络”（multi-layer feedforward neural networks）,其中输入层神经元接受外界输入，隐层与输出层神经元对信号进行加工，最终结果由输出层神经元输出；换言之，输入层神经元仅是接受输入，不进行函数处理，隐层与输出层包含功能神经元。<ol>
<li>“前馈”并不意味着网络中信号不能向后传，而是指网络拓扑结构上不存在环或回路</li>
<li>只需要包含隐层，即可称为多层网络。</li>
<li>神经网络的学习过程，就是根据训练数据来调整神经元之间的“连接权”（connection weight）以及每个功能神经元的阈值；换言之，神经网络“学”到的东西，蕴涵在连接权与阈值中。</li>
</ol>
</li>
</ol>
</li>
<li>误差逆传播算法（亦称“反向传播算法”）<ol>
<li>多层网络的学习能力比单层感知机强得多，想要训练多层网络，简单感知机学习规则显然不够，需要更加强大的学习算法，误差逆传播算法（errorBackPropagation, BP）就是其中最杰出的代码，它是迄今为止最成功的神经网络学习算法。</li>
<li>BP算法不仅可用于多层前馈神经网络，还可用于其他类型的神经网路，例如训练递归神经网络，但是通常说“BP网络”时，一般是指用BP算法训练的多层前馈神经网络。</li>
</ol>
</li>
<li>深度学习<ol>
<li>理论上来说，参数越多的模型复杂度越高、容量越大，这意味着它能够完成更复杂的学习任务。但是在一般情形下，复杂模型的训练效率低，易陷入过拟合，因此难以受到人们青睐</li>
<li>我们可以从另外一个角度来理解深度学习。无论是DBN还是CNN，其多隐层堆叠、每层对上一层的输出进行处理的机制，可看作是在对输入信号进行逐层加工，从而把初始的、与输出目标之间联系不太密切的输入表示，转化成与输出目标联系更密切的表示，使得原来仅基于最后一层输出映射难以完成的任务成为可能。换言之，通过多层处理，逐渐将初始的“低层”特征表示转化为“高层”特征表示后，用“简单模型”即可完成复杂的分类等学习任务，由此可将深度学习理解为“特征学习”（feature learning）或“表示学习”(representation learning)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="深度神经网络（Deep-Neural-Network-DNN）"><a href="#深度神经网络（Deep-Neural-Network-DNN）" class="headerlink" title="深度神经网络（Deep Neural Network, DNN）"></a>深度神经网络（Deep Neural Network, DNN）</h1><ol>
<li>深度神经网络是一种具备至少一个隐层的神经网络。与<strong>浅层神经网络</strong>类似，深度神经网络也能够为复杂非线性系统提供建模，但多出的层次为模型提供了更高的抽象层次，因而提高了模型的能力。深度神经网络通常都是<strong>前馈神经网络</strong>，但也有语言建模方面的研究将其拓展到循环神经网络。卷积神经网络在计算机视觉领域得到了成功的应用。</li>
<li>深度神经网络是一种<strong>判别模型</strong>，可以使用<strong>反向传播算法</strong>进行训练。权重更新可以使用下式进行<strong>随机梯度下降法</strong>求解。</li>
<li>与其它神经网络模型类似，如果仅仅是简单地训练，深度神经网络可能会存在很多问题。常见的两类问题是<strong>过拟合</strong>和<strong>过长的运算时间</strong>。</li>
</ol>
<h1 id="Cmake-VScode"><a href="#Cmake-VScode" class="headerlink" title="Cmake &amp; VScode"></a>Cmake &amp; VScode</h1><h2 id="Create-a-CMake-project"><a href="#Create-a-CMake-project" class="headerlink" title="Create a CMake project"></a>Create a CMake project</h2><ol>
<li>makdir cmakeQuickStart</li>
<li>cd cmakeQuickStart</li>
<li>code .</li>
<li>Open the Command Palette and run the <strong>CMake:Quick Start</strong> command</li>
<li>main.cpp , CMakeLists.txt(which tells the CMake tools how to build your project)</li>
<li>CMake Tools 插件能够给C&#x2F;C++插件提供信息，实现IntelliSense、代码补全、注释浏览、文件跳转等功能</li>
</ol>
<h1 id="Opencv-DNN"><a href="#Opencv-DNN" class="headerlink" title="Opencv DNN"></a>Opencv DNN</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ol>
<li>在深度学习初始阶段，每个深度学习研究者都需要写大量的重复代码。为了提高工作效率，这些研究者就将这些代码写成了一个框架放到网上让所有研究者一起使用。接着，网上就出现了不同的框架。随着时间的推移，最为好用的几个框架被大量的人使用从而流行了起来。全世界最为流行的深度学习框架有<ol>
<li>PaddlePaddle（Baidu）<ol>
<li>PaddlePaddle是Baidu研发的开源开放的深度学习平台，是国内最早开源、也是当前唯一一个功能完备的深度学习平台。</li>
</ol>
</li>
<li>Tensorflow（Google）</li>
<li>Caffe</li>
<li>Theano</li>
<li>MXNet</li>
<li>Torch（NYU&#x2F;Facebook）<ol>
<li>Torch是Facebook的开源机器学习库、科学计算框架和基于Lua编程语言的脚本语言。</li>
</ol>
</li>
<li>PyTorch</li>
</ol>
</li>
</ol>
<h2 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h2><ol>
<li>PyTorch是一个开源的Python机器学习库，基于Torch，用于自然语言处理等应用程序</li>
</ol>
<h2 id="TensorFlow（符号数学系统）"><a href="#TensorFlow（符号数学系统）" class="headerlink" title="TensorFlow（符号数学系统）"></a>TensorFlow（符号数学系统）</h2><ol>
<li>TensorFlow是一个基于数据流变成（dataflow programming）的符号数学系统，被广泛应用于各类机器学习（machine learning）算法的编程实现，其前身是谷歌的神经网络算法库DistBelief。</li>
</ol>
<h2 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h2><ol>
<li>Caffe(Convolutional Architecture for Fast Feature Embedding)，卷积神经网络框架，是一个兼具表达性、速度和四维模块化的深度学习框架。</li>
<li>结构：<ol>
<li>简单来讲，Caffe中的数据结构是以Blobs-layers-Net形式存在。其中，Blobs是通过4维向量形式（num, channel, height, width）存储网络中所有权重，激活值以及正向反向的数据。</li>
<li>作为Caffe的标准数据格式，Blob提供了统一内存借口。Layers表示的是神经网络中具体层，例如卷积层等，是Caffe模型的本质内容和执行计算的基本单元。layer层接受底层输入的Blobs，向高层输出Blobs。在每层会实现前向传播，后向传播。Net是由多个层连接在一起，组成的有向无环图。<strong>一个网络讲最初的data数据层加载数据开始到最后的loss层组合为整体</strong>。</li>
</ol>
</li>
</ol>
<h2 id="ONNX"><a href="#ONNX" class="headerlink" title="ONNX"></a>ONNX</h2><ol>
<li>了解Open Neural Network Exchange（ONNX）来帮助优化机器学习模型的推理。推理或模型评分是将部署的模型用于预测（通常针对生产数据）的阶段。</li>
<li>什么是ONNX？<ol>
<li>ONNX（Open Neural Network Exchange），开放神经网络交换，是一种<strong>模型IR</strong>，用于在各种深度学习训练和推理框架转换的一个<strong>中间表示格式</strong>。在实际业务中，可以使用Pytorch或者TensorFlow训练模型，导出ONNX格式，然后在转换成目标设备上支撑的模型格式，比如TensorRT Engine、 NCNN、MNN等格式。ONNX定义了一组和环境、平台均无关的标准格式，来增强各种AI模型的可交互性，开放性较强。</li>
<li>换句话说，无论你使用何种训练框架训练模型（例如TensorFlow&#x2F;Pytorch&#x2F;OneFlow&#x2F;Paddle），在训练完毕后你都可以将这些框架的模型统一转换为ONNX这种统一的格式进行存储，转为ONNX模型，然后就可以放在其他框架上面去推理（inference）。</li>
</ol>
</li>
<li>ProtoBuf简介<ol>
<li>在分析ONNX组织格式前，需要了解Protobuf。ONNX作为一个文件格式，自然需要一定的规则去读取想要的信息或者写入需要保存的信息。ONNX使用的是Protobuf这个序列化数据结构去存储神经网络的圈中信息。熟悉Caffe（深度学习框架）或者Caffe2的应该知道，它们的模型存储数据结构协议也是Protobuf。</li>
<li>Protobuf是一种轻便高校的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了C++、Java、Python三种语言的API</li>
</ol>
</li>
<li>ONNX中最核心的部分是onnx.proto。它定义了ONNX这个数据协议的规则和一些其他信息，其中最核心的几个对象：<ol>
<li>ModelProto<ol>
<li>包含了一些版本信息，生产者信息和一个GraphProto</li>
</ol>
</li>
<li>GraphProto<ol>
<li>包含了四个repeated数组，分别是<ol>
<li>node（NodeProto类型）<ol>
<li>存放模型中所有的计算节点</li>
</ol>
</li>
<li>input（ValueInfoProto类型<ol>
<li>存放模型的输入节点</li>
</ol>
</li>
<li>output（ValueInfoProto类型）<ol>
<li>存放模型中所有的输出节点</li>
</ol>
</li>
<li>initializer（TensorProto类型）<ol>
<li>存放模型的所有权重参数</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>NodeProto</li>
<li>ValueInfoProto</li>
<li>TensorProto</li>
<li>AttributeProto</li>
</ol>
</li>
</ol>
<h2 id="使用Google-inception-5h实现图像分类"><a href="#使用Google-inception-5h实现图像分类" class="headerlink" title="使用Google inception-5h实现图像分类"></a>使用Google inception-5h实现图像分类</h2><ol>
<li>DNN模块介绍：<ol>
<li>OpenCV的DNN模块是在OpenCV3.3合并到OpenCV release中的，它最早是在扩展模块中的，可以导入caffe、tensorflow、pytorch等深度学习框架训练生成的模型文件，从而正向传递实现预测功能</li>
</ol>
</li>
<li>加载模型读取网络信息<ol>
<li>模型可以使用readNet API来加载 <code>Net cv::dnn::readNet(const String&amp; model, const String&amp; config = String(), const String&amp; framework = String());</code><ol>
<li>model是训练好的二进制网络权重文件，支持多种框架训练出来的模型</li>
<li>config是二进制模型的描述文件，不同的框架配置文件有不同的扩展名</li>
<li>framework则声明模型对应框架名称</li>
</ol>
</li>
<li>也可以使用<ol>
<li><code>Net readNetFromTensorflow(const String&amp; model, const String&amp; config = String());</code></li>
<li><code>Net readNetFromCaffe(const String&amp; prototxt, const String&amp; caffeModel = String());</code></li>
<li>其他等API直接加载对应框架训练出来的模型</li>
</ol>
</li>
</ol>
</li>
<li>模型正向传递预测<ol>
<li><p>使用模型实现预测的时候，需要读取图像作为输入，网络模型支持的输入数据是四维的输入，所以要把读取到的Mat对象转换为四维张量，OpenCV提供的API如下</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   Mat blobFromImage(</span><br><span class="line">      InputArray image,</span><br><span class="line">      double scalefactor = 1.0,</span><br><span class="line">      const Size&amp; size = Size(),</span><br><span class="line">      const Scalar&amp; mean = Scalar(),</span><br><span class="line">      bool swapRB = false,</span><br><span class="line">      bool crop = false,</span><br><span class="line">      int ddepth = CV_32F</span><br><span class="line">   )</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol>
<li>image：输入图像</li>
<li>scalefactor：默认是1.0</li>
<li>size表示网络接受的数据大小</li>
<li>mean表示训练时数据集的均值</li>
<li>swapRB是否互换Red与Blur通道</li>
<li>crop是剪切</li>
<li>ddepth是数据类型</li>
</ol>
</li>
<li><p>模型的输入和正向传递则使用如下两个API</p>
<ol>
<li><code>void setInput(InputArray blob, const String&amp; name = &quot;&quot;);</code></li>
<li><code>Mat forward(const String&amp; outputName = String());</code></li>
</ol>
</li>
</ol>
</li>
<li>输出预测结果<ol>
<li>首先读取标签文件，定义一个读取文件的额函数read_class_names();</li>
</ol>
</li>
</ol>
<h2 id="模块（DNN）的应用–图像分类"><a href="#模块（DNN）的应用–图像分类" class="headerlink" title="模块（DNN）的应用–图像分类"></a>模块（DNN）的应用–图像分类</h2><h2 id="训练（training）和推理（inference）"><a href="#训练（training）和推理（inference）" class="headerlink" title="训练（training）和推理（inference）"></a>训练（training）和推理（inference）</h2><ol>
<li>训练（training）包含了前向传播和后向传播两个阶段，针对的是训练集，训练时通过误差反向传播来不断修改网络权值（weights）<ol>
<li>训练一个神经网络时，训练数据被输入该网络的第一层，同时一个神经元会基于所执行的任务为该输入分配一个权重–即该输入正确与否的程度</li>
<li>在一个用于图像识别的网络中，第一层可能是用来寻找图像的边缘。第二层可能是寻找这些边所构成的形状–矩形或者是圆形。第三层可能是寻找特定的特征–比如闪亮的眼睛或者按钮式的鼻子。每一层都会将图像传递给下一层，直到最后一层；最后的输出由该网络所产生的所有这些权重总体决定。</li>
</ol>
</li>
<li>推理（inference）只包含前向传播一个阶段，针对的是除了训练集之外的新数据。可以是测试机，但不完全是，更多的是整个数据集之外的数据。其实就是针对新数据进行预测，预测时，速度是一个很重要的因素。<ol>
<li>神经网络训练好了，已经为推理做好了准备</li>
<li>准确分配加权了的神经网络本质上是一个笨重的巨型数据库。此前，为了让它学习而准备的各种东西已经远远多余它在完成某一特定任务时所需要的内容</li>
<li>在现实世界中，如果有人想要使用这些训练，真正所需要的是一种可以保持学习并能将其学习成果应用于其从未见过的数据的快速应用，这就是推理：只需要少的多的真实数据，就能快速得出正确答案（实际上是对什么是正确的预测）<ol>
<li>训练是为了让“猫”这个线索得以抽象，推理就是利用这个抽象在应用场景下给出是不是“猫”这个结论。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="数据预处理与名字解释"><a href="#数据预处理与名字解释" class="headerlink" title="数据预处理与名字解释"></a>数据预处理与名字解释</h1><ol>
<li>深度学习中的数据预处理有哪些方式？<ol>
<li>数据归一化。包括高斯归一化、最大最小值归一化等</li>
<li>白化。许多深度学习算法都以来于白化来获得更好的特征。所谓的白化，以PCA白化来说，就是对PCA降维后的数据的每一列除以其特征值的根号。</li>
</ol>
</li>
<li>为什么需要图像预处理？<ol>
<li>图像预处理的主要目的是消除图像中无关的信息，恢复有用的真实信息，增强有关信息的可检测性和最大限度地简化数据，从而改进特征抽取，图像分隔，匹配和识别的可靠性。</li>
</ol>
</li>
<li>为什么需要对数据进行归一化处理，归一化的方式有哪些？<ol>
<li>为了后面数据处理的方便，归一化的确可以避免一些不必要的数值问题</li>
<li>为了程序运行时收敛加快</li>
<li>同一量纲。样本数据的评价标准不一样，需要对其量纲化，统一评价标准。这算是应用层面的需求</li>
<li>避免神经元饱和。当神经元的激活在接近0或者1时会饱和，在这些区域，梯度几乎为0，这样，再反向传播过程中，局部梯度就会接近0，这样会有效地“杀死”梯度</li>
<li>保证输出数据中数值小的不被吞食</li>
<li>归一化的方式主要有：线性归一化、标准差归一化、非线性归一化</li>
</ol>
</li>
<li>数据增强的方式有哪些？<ol>
<li>翻转、旋转、缩放、裁剪、平移、尺度变化、添加噪声、色彩抖动、亮度调整、对比度增强</li>
<li>数据增强可以分为两类：离线增强和在线增强<ol>
<li>离线增强：直接对数据集进行处理，数据的数目会变成增强因子乘以原数据集的数目，这种方法常常用于数据集很小的时候。</li>
<li>在线增强：这种增强的方法用于，获得batch数据之后，对这个batch的数据进行增强，如旋转、平移、翻转等相应的变化，由于有些数据集不能接受线性级别的增长，这种方法用于大的数据集</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h1><p>整体上说,后处理的CPU实现分为三部分:</p>
<ol>
<li>框信息的预处理,类似一个decode过程</li>
<li>NMS过程,实现框的选择和合并<ul>
<li>NMS过程是后处理的重点.基本原理是针对每一个类,每次循环选取这个类中概率最高的框与其他所有框计算IOU.如果某个框与最大概率框的IOU大于nms_thresh.这个框对应的概率被设为-1,表示被过滤掉了.</li>
<li>IOU,为两个框重叠面积与总面积的比值</li>
</ul>
</li>
<li>框排序,当选出的结果框数量大于maxBoxNum时选取score最大的maxBoxNum个</li>
</ol>
<h1 id="吴恩达-深度学习课程"><a href="#吴恩达-深度学习课程" class="headerlink" title="吴恩达 深度学习课程"></a>吴恩达 深度学习课程</h1><ol>
<li>Binary Classification（二分分类）<ol>
<li>在二分分类问题中，目标是训练处一个分类器，它以图片的特征向量x作为输入，预测输出的结果标签y是1还是0，也就是预测图片中是否有猫</li>
</ol>
</li>
<li>logistic regression（logistic 回归）<ol>
<li>它是一个学习算法，用在监督学习问题中输出标签是0还是1时，二元分类问题</li>
</ol>
</li>
</ol>
<h2 id="雷锋网"><a href="#雷锋网" class="headerlink" title="雷锋网"></a>雷锋网</h2><ul>
<li><code>https://www.leiphone.com/category/ai/DZeAwe2qgx8JhbU8.html</code></li>
</ul>
<h2 id="大部分深度学习框架都包含以下五个核心组件"><a href="#大部分深度学习框架都包含以下五个核心组件" class="headerlink" title="大部分深度学习框架都包含以下五个核心组件"></a>大部分深度学习框架都包含以下五个核心组件</h2><ul>
<li>张量 （<code>Tensor</code>）</li>
<li>基于张量的各种操作</li>
<li>计算图（<code>Computation Graph</code>）</li>
<li>自动微分工具（<code>Automatic Differentiation</code>）工具</li>
<li><code>BLAS, cuBLAS, cuDNN</code>等扩展包</li>
</ul>
<h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3><ul>
<li><p>张量是所有深度学习框架中最核心的组件，因为后续的所有运算和优化算法都是基于张量进行的</p>
</li>
<li><p>几何代数中定义的张量是， <strong>基于向量和矩阵的推广</strong>，通俗一点理解的话，可以将标量视为零阶张量，矢量视为一阶张量，那么据栈就是二阶张量</p>
</li>
<li><p>举例来说，可以将任意一张RGB彩色图片表示称一个三阶张量， 三个纬度分别是图片的高度，宽度和色彩数据。</p>
</li>
<li><p>将这一定义进行扩展，我们也可以用四阶张量表示一个包含多张图片的数据集，其中的四个纬度分别是 – 图片在数据集中的编号，图片高度，宽度，以及色彩数据。</p>
</li>
<li><p><strong>将各种各样的数据抽象成张量表示，然后再输入神经网络模型进行后续处理是一种非常必要且高效的策略</strong>。</p>
</li>
<li><p>因为，如果没有这一步骤，我们就需要根据各种不同类型的数据组织形式定义各种不同类型的数据操作，这会浪费大量的开发这精力。更关键的是，当数据处理完成后，我们还可以方便地将张量再转回想要的格式。</p>
</li>
</ul>
<h3 id="基于张量的各种操作"><a href="#基于张量的各种操作" class="headerlink" title="基于张量的各种操作"></a>基于张量的各种操作</h3><ul>
<li><p>整个神经网络都可以简单视为为了达到某种目的，针对输入张量进行的一系列操作过程。而所谓的“学习”就是不断纠正神经网络的实际输出结果和预期结果之间的误差的过程。</p>
</li>
<li><p>这里的一系列操作包含的范围很宽，可以是简单的矩阵乘法，也可以是卷积，池化和LSTM等稍复杂的运算。而且各框架支持的张量操作通常也不尽相同。</p>
</li>
<li><p>需要指出的是，<strong>大部分的张量操作都是基于类实现的（而且是抽象类）</strong>，而并不是函数（这一点可能要归功于大部分的深度学习框架都是用面向对象的编程语言实现的）。</p>
</li>
<li><p>这种实现思路一方面允许开发这将各种类似的操作汇总在一起，方便组织管理。另一方面也保证了整个代码的复用性，扩展性和对外接口的统一。总体上让整个框架更灵活和易于扩展，为将来的发展预留了空间。</p>
</li>
</ul>
<h3 id="计算图-Computation-Graph"><a href="#计算图-Computation-Graph" class="headerlink" title="计算图(Computation Graph)"></a>计算图(Computation Graph)</h3><ul>
<li><p>有了张量和基于张量的各种操作之后，下一步就是将各种操作整合起来，输出需要的结果</p>
</li>
<li><p>但不幸的是，随着操作种类和数量的增多，有可能引发各种意想不到的问题，包括多个操作之间应该并行还是顺次执行，如何协同各种不同的底层设备，以及如何避免各种类型的冗余操作等。这些问题有可能拉低整个深度学习网络的运行效率或者引入不必要的Bug，而计算图正是为解决这一问题产生的。</p>
</li>
<li><p>计算图首次被引入人工智能领域是2009年的论文<code>&lt;Learning Deep Architectures for AI&gt;</code>。作者用不同的占位符构成操作结点，以字母构成变量结点，再以有向线段将这些结点连接起来，组成一个表征运算逻辑关系的清晰明了的图型数据结构，这就是最初的计算图</p>
</li>
<li><p>后来随着技术的不断演进，加上脚本语言和低级语言各自不同的特点（概括地说，脚本语言建模方便但执行缓慢，低级语言正好相反），因此业界逐渐形成了一种开发框架：<strong>前端用Python等脚本语言建模，后端用C++等低级语言执行（这里低级是就应用层而言），以此综合了两者的优点</strong>。</p>
</li>
<li><p>这种开发框架大大降低了传统框架做跨设备计算时的代码耦合度，也避免了每次后端变动都需要修改前端的维护开销。而这里，在前端和后端之间起到的关键耦合作用的就是计算图。</p>
</li>
<li><p>将计算图作为前后端之间的中间表示(Intermediate Representations)可以带来良好的交互性，开发这可以将Tensor对象作为数据结构，函数&#x2F;方法作为操作类型，将特定的操作类型应用于特定的数据结构，从而定义出类似MATLAB的强大建模语言。</p>
</li>
<li><p>因为计算图的引入，开发者得以从宏观上俯瞰整个神经网络的内部结构，就好像编译器可以从整个代码的角度决定如何分配寄存器那样，计算图也可以从宏观上决定代码运行时的GPU内存分配，以及分布式环境中不同底层设备间的相互协作方式。除此之外，现在也有许多深度学习框架将计算图应用于模型调试，可以实时输出当前某一操作类型的文本描述。</p>
</li>
</ul>
<h3 id="自动微分-Automatic-Differentiation-工具"><a href="#自动微分-Automatic-Differentiation-工具" class="headerlink" title="自动微分(Automatic Differentiation)工具"></a>自动微分(Automatic Differentiation)工具</h3><ul>
<li><p>计算图带来的另一个好处是让模型训练阶段的梯度计算变得模块化且更为便捷，也就是自动微分法。</p>
</li>
<li><p><strong>我们可以将神经网络视为由许多非线性过程组成的一个复杂的函数体，而计算图则以模块化的方式完整表征了这一函数体的内部逻辑关系，因此微分这一复杂函数体，即求取模型梯度的方法就变成了在计算图中简单地从输入到输出进行一次完整遍历的过程</strong>。与自动微分对应，业内更传统的做法是符号微分。</p>
</li>
</ul>
<h3 id="BLAS-CUBLAS-CUDNN等扩展包"><a href="#BLAS-CUBLAS-CUDNN等扩展包" class="headerlink" title="BLAS, CUBLAS, CUDNN等扩展包"></a><code>BLAS, CUBLAS, CUDNN</code>等扩展包</h3><ul>
<li><p>通过上述所有模块，已经可以搭建一个全功能的深度学习框架：</p>
<ul>
<li>将待处理数据转换为张量，针对张量施加各种需要的操作，通过自动微分对模型展开训练，然后得到输出结果开始测试</li>
<li>这个时候还缺 – 运算效率</li>
</ul>
</li>
<li><p>由于此前的大部分实现都是基于高级语言的，而即时是执行最简单的操作，高级语言也会比低级语言消耗更多的CPU周期，更何况是结构复杂的深度神经网络，因此运算缓慢就成了高级语言的一个天然的缺陷。</p>
</li>
<li><p>目前针对这一个问题有两种解决方案</p>
<ul>
<li>第一种方法是模拟传统的编译器。就好像传统编译器会把高级语言编译成特定平台的汇编语言实现高效运行一样，这种方法将高级语言转换为C语言，然后在C语言基础上编译，执行。为了实现这种转换，每一种张量操作的实现代码就会预先加入C语言的转换部分，然后由编译器在编译阶段将这些由C语言实现的张量操作综合在一起。目前<code>pyCUDA</code>和<code>Cpython</code>等编译器都已经实现了这一功能</li>
<li>第二种方法就是，利用脚本语言实现前端建模，用低级语言实现后端运行，这意味着高级语言和低级语言之间的交互都发生在框架内部，因此每次的后端变动都不需要修改前端，也不需要完整编译（只需要通过修改编译参数进行部分编译），因此整体速度也就更快</li>
</ul>
</li>
<li><p>除此之外，由于低级语言的最优化编程难度很高，而且大部分的基础操作其实也都有公开的最优解决方案，因此另一个显著的加速手段就是利用现成的扩展包。</p>
</li>
<li><p>例如，最初用<code>Fortran</code>实现的BLAS（基础线形代数子程序）就是一个非常优秀的基本矩阵（张量）运算库，此外，还有英特尔的MKL(<code>Math Kernel Library</code>)等</p>
</li>
<li><p>为了向开发者提供尽量简单的接口，大部分深度学习框架通常都会将普通的概念抽象化，这可能是造成许多用户感知不到上述五点核心组件的重要原因。</p>
</li>
</ul>
<h2 id="sigmoid-归一化"><a href="#sigmoid-归一化" class="headerlink" title="sigmoid 归一化"></a>sigmoid 归一化</h2><ul>
<li><p>The sigmoid function is a mathematical function that has a characteristic that can take any real value and map it to between 0 to 1 shaped like the letter “S”.</p>
</li>
<li><p><code>Sigmoid</code>功能在机器学习中扮演激活函数的作用，该功能用于在机器学习模型中添加非线性。基本上，该函数确定要传递的值作为输出以及不通过输出传递的值。机器学习和深度学习中使用了7种类型的激活功能</p>
</li>
<li><p><code>Sigmoid</code>神经元本质上是深神经网络的基础。这些sigmoid神经元与感知性相似，但是它们恰好被稍微修饰，因此来自Sigmoid神经元的输出比Perceptron的步骤功能输出更光滑</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-YoloV3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-YoloV3/" class="post-title-link" itemprop="url">YoloV3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="yolov3算法思想"><a href="#yolov3算法思想" class="headerlink" title="yolov3算法思想"></a>yolov3算法思想</h3><ul>
<li>yolo的作者将目标检测问题视为回归问题:首先将整幅图划分为<code>S*S</code>的网格,如果目标框的中心店落在这个网格中,那么这个网格就负责预测这个目标</li>
<li>每一个网格都会预测<code>bounding box(边界框)</code>, <code>confidence(置信度)</code>以及<code>class probability map(类概率图)</code><ul>
<li>bounding box, 包含四个值:x, y, w, h其中(x, y)代表预测框的中心点, (w, h)代表预测框的宽和高</li>
<li>confidence, 表示预测框包含目标的可能性,训练时的真值为预测框和真值框的IOU</li>
<li>class probability map, 表明这个目标所属类别的置信度</li>
</ul>
</li>
</ul>
<p>yolov3网络结构</p>
<ul>
<li>yolov3在3个scale的特征图上分别预测不同大小的目标,即在8倍,16倍和32倍的特征图上进行预测,也就是说如果我们的输入为416<em>416,那么yolov3预测时采用的特征图的大小分别为52</em>52, 32<em>32, 13</em>13</li>
<li>总之,yolov3在3中不同尺度的特征图上进行检测,因此如果我们输入416*416大小的图像,它将产生三种不同的输出形状张量: <code>13*13*255, 26*26*255和52*52*255</code></li>
</ul>
<p>残差模块</p>
<ul>
<li>残差模块(Residual module)最显著的特点是使用了一种shortcut机制,以缓解因增加神经网络中的深度而导致的梯度消失的问题,从而使神经网络更易于训练</li>
<li>它主要使用identity mapping在输入和输出之间建立连接</li>
</ul>
<p>特征图分析</p>
<ul>
<li>要详细了解yolo的输出含义,首先需要了解什么是特征图</li>
<li>在讨论CNN网络结构的时候,总经常使用的一个词汇叫做<code>feature map</code>,简单地说,输入图像与卷积核进行卷积操作后就可以获得图像特征.</li>
<li>一般来说,当输入图像经过CNN提取特征时,特征图的数量(卷积核的数量)将增加,同时空间信息将减少,当然提取到的特征也会越来越抽象.随着网络变深,特征图的空间尺寸越来越小,但是通道数目越来越大,这是CNN的特性</li>
<li>当CNN网络自下而上从输入图像中提取特征时,生成的特征图通常在空间尺寸上越来越小,在通道数目上越来越深.这个特性与ROI(感兴趣区)到特征图的映射有关.</li>
<li>将原始图像中的ROI映射到CNN网络空间后,特征图上的空间会变小,甚至成为一个点,但是该点的通道信息会非常丰富.该信息是CNN网络上映射的ROI区域中图像信息的特征表示</li>
<li>由于图像中的像素在空间上紧密相连,这导致了空间上的巨大冗余.因此,通常通过减少空间维度和增加通道维度来消除这种冗余,并尝试在最小维度中获得其最重要的特征.举例:图像的ROI经过CNN映射,在特征图上仅获得一个点,但是该点有85个通道线,因此,ROI的维度已经从原来的[32, 32, 3]变为当前的85维.</li>
<li>这实际上是yolo网络对ROI执行特征提取后获得的85维特征向量.该特征向量的前四个维度表示候选框信息,中间维度表示判断对象是否存在的概率,接下来的80个维度表示80个类别的分类概率信息.</li>
</ul>
<p>理解输出</p>
<ul>
<li>yolov3网络的输入尺寸为(m, 416, 416, 3),其中m代表每个batch中图像数目.m&#x3D;1,代表每个batch处理1张输入图像</li>
<li>yolov3分3个尺度进行预测,3个尺度的特征图的大小依次为13 x 13, 26 x 26, 52 x 52</li>
<li>yolov3中每个cell预测3个bounding box,每个bounding box可以表示为6元组:(tx, ty, yw, th, pc, c)</li>
<li>在COCO数据集中一共有80个类别,此时我们将c扩展成80维向量,这样每个bounding box可以用85维向量进行表示</li>
<li>输入图像尺寸为416*416,将采样缩小32倍,得到特征图的大小为<code>13*13</code>,也就是说,将输入图像划分成<code>13*13</code>的网格,每个cell对应输入图像中对应<code>32*32</code>的区域</li>
<li>如果每个cell在原图中包含物体真实框的中心点时,那么这个cell负责预测该目标,</li>
</ul>
<p>理解bounding box</p>
<ul>
<li>yolov3网络结构中有3个分支(3个不同尺度的特征图)被送到decode函数来进一步进行解析</li>
</ul>
<p>NMS后处理</p>
<ul>
<li>从候选框中选择置信度最高的box</li>
<li>计算当前框和其他框的IOU,如果IOU&gt;iou_threshold,则移除对应的box</li>
<li>重复上述步骤进行迭代,知道剩余框中没有和当前挑选出的box重叠iou大于阈值的框</li>
<li>上述过程主要是为了过滤和当前框具有很大重叠度的框,针对每个目标仅保留网络预测置信度最高的那个框</li>
</ul>
<h3 id="yolov3的输出"><a href="#yolov3的输出" class="headerlink" title="yolov3的输出"></a>yolov3的输出</h3><ul>
<li>9个anchor会被三个输出张量平分,根据大中小三种size各自取自己的anchor</li>
<li>每个输出y在自己的网络上都会输出3个预测框,这三个框是9除以3得到的,这是作者设置的,我们可以从输出张量的维度来看</li>
<li>13 * 13 * 255:<ul>
<li>13 * 13 : 表示网格的数量,将图片分成13 * 13个网格</li>
<li>255 : 3 * (5 + 80)<ul>
<li>80:表示能够识别80个物品类别</li>
<li>5:表示位置信息和置信度(x, y, w, h, confidence)</li>
<li>3:表示要输出3个prediction;从代码上来看,3是由<code>num_anchors</code>得到的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>作者使用了logistics回归来对每个anchor包围的内容进行了一个目标性平分(objectness score),根据目标性平分来选择anchor prior进行predict,而不是所有的anchor prior都会有输出.</p>
<h3 id="yolov3输出张量解码过程"><a href="#yolov3输出张量解码过程" class="headerlink" title="yolov3输出张量解码过程"></a>yolov3输出张量解码过程</h3><ul>
<li>yolo网络输出是一个<strong>元组</strong>,包含三个张量,代表三个不同尺度,大小是<code>1*255*13*13</code>, <code>1*255*26*26</code>和<code>1*255*52*52</code>.(255:表示每个格点输出三个预测框,每个预测框包含85个元素,一共是255个元素)</li>
<li>yolov3解码过程包括五个阶段:<ol>
<li>缩小先验框</li>
<li>生成网格</li>
<li>生成预测框</li>
<li>非极大值抑制</li>
<li>显示预测框</li>
</ol>
</li>
<li>解码过程包含的尺寸变换:<ol>
<li>原尺寸变换为416*416</li>
<li>为了在特征图上确定预测框的大小和位置,将先验框缩小(416&#x2F;13, 416&#x2F;26, 416&#x2F;52)倍</li>
<li>在特征图上生成网格,根据输出张量,确定预测框的位置和大小;然后将坐标和宽高信息放大(416&#x2F;13, 416&#x2F;26, 416&#x2F;52)倍,在原图中显示;最后将原图恢复至原来的大小.</li>
</ol>
</li>
</ul>
<p>opencv预处理:</p>
<ul>
<li>blobFromImage():<ul>
<li>Mat cv::dnn::blobFromImage(+<br>        InputArray image,             &#x2F;&#x2F; 输入图像<br>        double scalefactor &#x3D; 1.0,     &#x2F;&#x2F; 图像值的乘数<br>        const Size&amp;   size &#x3D; Size(),  &#x2F;&#x2F; 输出图像的空间大小<br>        const Scalar&amp; mean &#x3D; Scalar(),&#x2F;&#x2F; 带有从通道中减去的平均值的标量.如果图像具有BGR排序且swapRB为真,则值应按(mean-R, mean-G, mean-B)顺序排列<br>        bool   swapRB &#x3D; false,        &#x2F;&#x2F; 表示需要交换3通道图像中的第一个和最后一个通道的标志<br>        bool   crop &#x3D; false,          &#x2F;&#x2F; 指示调整大小后是否裁剪图像的标志<br>        int ddepth &#x3D; CV_32F           &#x2F;&#x2F; 输出blob的深度.选择CV_32F或者CV_8U<br>        )</li>
<li>返回格式:NCHW</li>
<li>从图像创建4维blob.可选择从中心调整图像大小和裁剪图像,减去平均值,按比例因子缩放值,交换蓝色和红色通道</li>
</ul>
</li>
</ul>
<p>opencv后处理:</p>
<ul>
<li><p>minMaxLoc():</p>
<ul>
<li>void cv::minMaxLoc(<br>    InputArray src,             &#x2F;&#x2F; 输入的单通道数组<br>    double* minVal              &#x2F;&#x2F; 指针返回的最小值的指针;如果不需要,则使用NULL<br>    double* maxVal &#x3D; 0,         &#x2F;&#x2F; 指针返回的最大值的指针,如果不需要,则使用NULL<br>    Point*  minLoc &#x3D; 0,         &#x2F;&#x2F; 指向返回的最小位置的指针(在2D情况下),如果不需要,则使用NULL<br>    Point*  maxLoc &#x3D; 0,         &#x2F;&#x2F; 指向返回的最大位置的指针(在2D情况下),如果不需要,则使用NULL<br>    InputArray mask &#x3D; noArray() &#x2F;&#x2F; 用于选择子数组的可选掩码<br>     )</li>
<li>功能:查找数组中的全局最小值和最大值(和位置).</li>
</ul>
</li>
<li><p>NMSBoxes():</p>
<ul>
<li>void cv::dnn::NMSBoxes(<br>        const std::vector<Rect>&amp; bboxes,  &#x2F;&#x2F; 一组边界框来应用NMS<br>        const std::vector<float>&amp; scores, &#x2F;&#x2F; 一组对应的置信度<br>        const float score_threshold,      &#x2F;&#x2F; 用于按分数过滤的阈值<br>        const float nms_threshold,        &#x2F;&#x2F; 用于非最大抑制的阈值<br>        std::vector<int>&amp; indices,        &#x2F;&#x2F; NMS后保存的bbox索引<br>        const flat eta &#x3D; 1.f,             &#x2F;&#x2F; 自适应阈值公式中的一个系数<br>        const int top_k &#x3D; 0               &#x2F;&#x2F; 如果&gt;0,则最多保留top_k个选择的索引<br>        )</li>
<li>功能:在给定框和相应分数的情况下执行非最大抑制</li>
</ul>
</li>
</ul>
<p>yaml:用来写配置文件的语言</p>
<ul>
<li>YAML,是一个可读性高,用来表达数据序列化的格式</li>
<li>YAML,是<code>YAML Ain&#39;t a Markup Language</code>的递归缩写</li>
<li>使用场景:<ul>
<li>由于实现简单,解析成本很低,YAML特别适合在脚本语言中使用</li>
<li>YAML,比较适合做序列化,因为它是宿主语言数据类型直转的</li>
<li>YAML做配置文件也不错.写YAML要比写XML快得多,无需关注标签或引号,并且比ini文档功能更强</li>
<li></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-Caffe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-Caffe/" class="post-title-link" itemprop="url">Caffe</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Caffe，全称Convolutional Architecture for Fast Feature Embedding。是一种常用的深度学习框架，主要应用在视频、图像处理方面的应用上。</li>
<li>caffe是一个清晰，可读性高，快速的深度学习框架</li>
</ul>
<h2 id="网络结构层参数"><a href="#网络结构层参数" class="headerlink" title="网络结构层参数"></a>网络结构层参数</h2><ul>
<li><p><code>prototxt</code>文件是<code>caffe</code>的配置文件，用于保存CNN的网络结构和配置信息。</p>
</li>
<li><p><code>prototxt</code>文件有三种，分别是<code>deploy.prototxt</code>，<code>train_val.prototxt</code>和<code>solver.prototxt</code></p>
</li>
<li><p><code>solver.prototxt</code></p>
<ul>
<li><code>solver.prototxt</code>是caffe的配置文件。里面定义了网络训练时候的各种参数，比如学习率、权重衰减、迭代次数等等。</li>
<li><code>solver.prototxt</code>文件只在网络进行训练的时候需要载入。是网络训练的一个整体的参数配置文件。</li>
</ul>
</li>
<li><p><code>deploy.prototxt</code>和<code>train_val.prototx</code></p>
<ul>
<li>这两个文件是<code>caffe</code>的网络结构文件。</li>
<li><code>train_val.prototx</code>是训练时候的网络结构，<code>deploy.prototxt</code>用于发布（即测试时候的网络结构）。</li>
<li>这两个文件中内容基本一致，但是存在一些细微区别：<ul>
<li>在<code>train_val.prototx</code>中网络结构的<code>data</code>层有两种，分别为<code>TRAIN</code>和<code>TEST</code>。顾名思义，<code>TRAIN</code>是网络训练时后的数据结构，<code>TEST</code>是网络做验证时候的数据结构。一般来说<code>TRAIN</code>中的<code>batchSize</code>比<code>TEST</code>中的要大一些。</li>
<li>在<code>train_val.prototx</code>中的卷积层（<code>Convolution</code>）中存在学习率和权重衰减的参数，而<code>deploy.prototxt</code>文件中则没有这些参数（有些<code>deploy.prototxt</code>中仍然有这些参数，但是对测试不起任何作用）。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-onnx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-onnx/" class="post-title-link" itemprop="url">onnx</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>onnx相关笔记</li>
</ul>
<h2 id="TensorRT-OpenVino-ONNXRuntime-OpenCV-dnn"><a href="#TensorRT-OpenVino-ONNXRuntime-OpenCV-dnn" class="headerlink" title="TensorRT, OpenVino, ONNXRuntime, OpenCV dnn"></a>TensorRT, OpenVino, ONNXRuntime, OpenCV dnn</h2><ul>
<li>无论用什么框架训练的模型，推荐转为onnx格式，方便部署</li>
<li>支持onnx模型的框架如下<ul>
<li>TensorRT： 英伟达的，用于 GPU 推理加速。注意需要英伟达 GPU 硬件的支持</li>
<li>OpenVino： 英特尔的，用于 CPU 推理加速。注意需要英特尔 CPU 硬件的支持</li>
<li>ONNXRuntime： 微软，亚马逊，Facebook和IBM等公司共同开发的，可用于CPU，GPU</li>
<li>OpenCV dnn： OpenCV的调用模型的模块</li>
</ul>
</li>
<li>pt格式的模型，可以用Pytorch框架部署</li>
<li>推理效率上：TensorRT &gt; OpenVino &gt; ONNXRuntime &gt; OpenCV dnn &gt; Pytorch</li>
</ul>
<h2 id="onnx推理"><a href="#onnx推理" class="headerlink" title="onnx推理"></a>onnx推理</h2><ul>
<li>ONNX的推理分别需要装两种框架<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install onnxruntime       <span class="comment"># CPU 版本</span></span><br><span class="line">pip install onnxruntime-gpu   <span class="comment"># GPU 版本</span></span><br></pre></td></tr></table></figure></li>
<li>而且需要在保存pytorch模型的时候也需要指定cpu和gpu。</li>
<li>这里推理就不需要pytorch框架来支持了，尤其是在容器部署的时候pytorch框架安装包非常大这会导致部署的镜像也很大，如果推理去掉pytorch框架的情况下镜像大小也会减少很多，大大减少部署难度。</li>
</ul>
<h2 id="onnx概述"><a href="#onnx概述" class="headerlink" title="onnx概述"></a>onnx概述</h2><ul>
<li><p>深度学习算法大多通过计算数据流图来完成神经网络的深度学习过程。 一些框架（例如CNTK，Caffe2，Theano和TensorFlow）使用静态图形，而其他框架（例如 PyTorch 和 Chainer）使用动态图形。</p>
</li>
<li><p>但是这些框架都提供了接口，使开发人员可以轻松构建计算图和运行时，以优化的方式处理图。 这些图用作中间表示（IR），捕获开发人员源代码的特定意图，有助于优化和转换在特定设备（CPU，GPU，FPGA等）上运行</p>
</li>
<li><p>ONNX 的本质只是一套开放的 ML 模型标准，模型文件存储的只是网络的拓扑结构和权重（其实每个深度学习框架最后保存的模型都是类似的），脱离开框架是没办法对模型直接进行 inference 的</p>
</li>
<li><p>为什么使用通用IR</p>
<ul>
<li>现在很多的深度学习框架提供的功能都是类似的，但是在 API、计算图和 runtime 方面却是独立的，这就给 AI 开发者在不同平台部署不同模型带来了很多困难和挑战，ONNX 的目的在于提供一个跨框架的模型中间表达框架，用于模型转换和部署。ONNX 提供的计算图是通用的，格式也是开源的。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" class="post-title-link" itemprop="url">计算机视觉</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>计算机视觉相关笔记</li>
</ul>
<h2 id="计算机视觉-维基百科"><a href="#计算机视觉-维基百科" class="headerlink" title="计算机视觉(维基百科)"></a>计算机视觉(维基百科)</h2><ul>
<li><p>计算机视觉（Computer vision）是一门研究如何使机器“看”的科学，更进一步的说，就是指用摄影机和计算机代替人眼对目标进行识别、跟踪和测量等机器视觉，并进一步做图像处理，用计算机处理成为更适合人眼观察或传送给仪器检测的图像</p>
</li>
<li><p>作为一门科学学科，计算机视觉研究相关的理论和技术，试图建立能够从图像或者多维数据中获取“信息”的人工智能系统。这里所指的信息指香农定义的，可以用来帮助做一个“决定”的信息。因为感知可以看作是从感官信号中提取信息，所以计算机视觉也可以看作是研究如何使人工系统从图像或多维数据中“感知”的科学</p>
</li>
<li><p>作为一个工程学科，计算机视觉寻求基于相关理论与模型来建立计算机视觉系统。这类系统的组成部分包括：</p>
<ul>
<li>过程控制（例如工业机器人和无人驾驶汽车）</li>
<li>事件监测（例如图像监测）</li>
<li>信息组织（例如图像数据库和图像序列的索引建立）</li>
<li>物体与环境建模（例如工业检查，医学图像分析和拓扑建模）</li>
<li>交感互动（例如人机互动的输入设备）</li>
</ul>
</li>
<li><p>计算机视觉同样可以被看作是生物视觉的一个补充。在生物视觉领域中，人类和各种动物的视觉都得到了研究，从而建立了这些视觉系统感知信息过程中所使用的物理模型。另一方面，在计算机视觉中，靠软件和硬件实现的人工智能系统得到了研究与描述。生物视觉与计算机视觉进行的学科间交流为彼此都带来了巨大价值。</p>
</li>
<li><p>计算机视觉的发展现状</p>
<ul>
<li>在计算机视觉的大多数实际应用当中，计算机被预设为解决特定的任务，然而基于机器学习的方法正日渐普及，一旦机器学习的研究进一步发展，未来“泛用型”的电脑视觉应用或许可以成真。</li>
<li>人工智能所研究的一个主要问题是：如何让系统具备“计划”和“决策能力”？从而使之完成特定的技术动作（例如：移动一个机器人通过某种特定环境）。这一问题便与计算机视觉问题息息相关。在这里，计算机视觉系统作为一个感知器，为决策提供信息。另外一些研究方向包括模式识别和机器学习（这也隶属于人工智能领域，但与计算机视觉有着重要联系），也由此，计算机视觉时常被看作人工智能与计算机科学的一个分支。</li>
<li>物理是与计算机视觉有着重要联系的另一领域。</li>
<li>计算机视觉关注的目标在于充分理解电磁波——主要是可见光与红外线部分——遇到物体表面被反射所形成的图像，而这一过程便是基于光学物理和固态物理，一些尖端的图像传感器甚至会应用到量子力学理论，来解析影像所表示的真实世界。同时，物理学中的很多测量难题也可以通过计算机视觉得到解决，例如流体运动。也由此，计算机视觉同样可以被看作是物理学的拓展</li>
<li>另一个具有重要意义的领域是神经生物学，尤其是其中生物视觉系统的部分</li>
<li>计算机视觉的另一个相关领域是信号处理。很多有关单元变量信号的处理方法，尤其对是时变信号的处理，都可以很自然的被扩展为计算机视觉中对二元变量信号或者多元变量信号的处理方法。但由于图像数据的特有属性，很多计算机视觉中发展起来的方法，在单元信号的处理方法中却找不到对应版本。这类方法的一个主要特征，便是他们的非线性以及图像信息的多维性，以上二点作为计算机视觉的一部分，在信号处理学中形成了一个特殊的研究方向。</li>
<li>除了上面提到的领域，很多研究课题同样可被当作纯粹的数学问题。例如，计算机视觉中的很多问题，其理论基础便是统计学，最优化理论以及几何学。</li>
<li>如何使既有方法通过各种软硬件实现，或说如何对这些方法加以修改，而使之获得合理的执行速度而又不损失足够精度，是现今计算机视觉领域的主要课题。</li>
</ul>
</li>
<li><p>相邻领域的异同</p>
<ul>
<li>计算机视觉，图像处理，图像分析，机器人视觉和机器视觉是彼此紧密关联的学科。如果你翻开带有上面这些名字的教材，你会发现在技术和应用领域上他们都有着相当大部分的重叠。这表明这些学科的基础理论大致是相同的，甚至让人怀疑他们是同一学科被冠以不同的名称。</li>
<li>计算机视觉的研究对象主要是映射到单幅或多幅图像上的三维场景，例如三维场景的重建。计算机视觉的研究很大程度上针对图像的内容。</li>
<li>图像处理与图像分析的研究对象主要是二维图像，实现图像的转化，尤其针对像素级的操作，例如提高图像对比度，边缘提取，去噪声和几何变换如图像旋转。这一特征表明无论是图像处理还是图像分析其研究内容都和图像的具体内容无关。</li>
<li>机器视觉主要是指工业领域的视觉研究，例如自主机器人的视觉，用于检测和测量的视觉。这表明在这一领域通过软件硬件，图像感知与控制理论往往与图像处理得到紧密结合来实现高效的机器人控制或各种实时操作。</li>
<li>模式识别使用各种方法从信号中提取信息，主要运用统计学的理论。此领域的一个主要方向便是从图像数据中提取信息。</li>
<li>还有一个领域被称为成像技术。这一领域最初的研究内容主要是制作图像，但有时也涉及到图像分析和处理。例如，医学成像就包含大量的医学领域的图像分析。</li>
</ul>
</li>
<li><p>计算机视觉的经典问题</p>
<ul>
<li>几乎在每个计算机视觉技术的具体应用都要解决一系列相同的问题。这些经典的问题包括：</li>
<li>识别<ul>
<li>一个计算机视觉，图像处理和机器视觉所共有的经典问题便是判定一组图像数据中是否包含某个特定的物体，图像特征或运动状态。这一问题通常可以通过机器自动解决，但是到目前为止，还没有某个单一的方法能够广泛的对各种情况进行判定：在任意环境中识别任意物体。现有技术能够也只能够很好地解决特定目标的识别，比如简单几何图形识别，人脸识别，印刷或手写文件识别或者车辆识别。而且这些识别需要在特定的环境中，具有指定的光照，背景和目标姿态要求。</li>
<li>广义的识别在不同的场合又演化成了几个略有差异的概念：<ul>
<li>识别（狭义的）：对一个或多个经过预先定义或学习的物体或物类进行辨识，通常在辨识过程中还要提供他们的二维位置或三维姿态。</li>
<li>鉴别：识别辨认单一物体本身。例如：某一人脸的识别，某一指纹的识别。</li>
<li>监测：从图像中发现特定的情况内容。例如：医学中对细胞或组织不正常技能的发现，交通监视仪器对过往车辆的发现。监测往往是通过简单的图象处理发现图像中的特殊区域，为后继更复杂的操作提供起点</li>
</ul>
</li>
<li>识别的几个具体应用方向：<ul>
<li>基于内容的图像提取：在巨大的图像集合中寻找包含指定内容的所有图片。被指定的内容可以是多种形式，比如一个红色的大致是圆形的图案，或者一辆自行车。在这里对后一种内容的寻找显然要比前一种更复杂，因为前一种描述的是一个低级直观的视觉特征，而后者则涉及一个抽象概念（也可以说是高级的视觉特征），即‘自行车’，显然的一点就是自行车的外观并不是固定的。</li>
<li>姿态评估：对某一物体相对于摄像机的位置或者方向的评估。例如：对机器臂姿态和位置的评估。</li>
<li>光学字符识别对图像中的印刷或手写文字进行识别鉴别，通常的输出是将之转化成易于编辑的文档形式。</li>
</ul>
</li>
</ul>
</li>
<li>运动<ul>
<li>基于序列图像的对物体运动的监测包含多种类型，诸如：<ul>
<li>自体运动：监测摄像机的三维刚性运动</li>
<li>图像跟踪：跟踪运动的物体</li>
</ul>
</li>
</ul>
</li>
<li>场景重建<ul>
<li>给定一个场景的二或多幅图像或者一段录像，场景重建寻求为该场景建立一个三维模型。最简单的情况便是生成一组三维空间中的点。更复杂的情况下会建立起完整的三维表面模型。</li>
</ul>
</li>
<li>图像恢复<ul>
<li>图像恢复的目标在于移除图像中的噪声，例如仪器噪声、动态模糊等</li>
</ul>
</li>
</ul>
</li>
<li><p>计算机视觉系统</p>
<ul>
<li>计算机视觉系统的结构形式很大程度上依赖于其具体应用方向。有些是独立工作的，用于解决具体的测量或检测问题；也有些作为某个大型复杂系统的组成部分出现，比如和机械控制系统，数据库系统，人机接口设备协同工作。计算机视觉系统的具体实现方法同时也由其功能决定——是预先固定的抑或是在运行过程中自动学习调整。尽管如此，有些功能却几乎是每个计算机系统都需要具备的：</li>
<li>图像获取：一幅数字图像是由一个或多个图像传感器产生，这里的传感器可以是各种光敏摄像机，包括遥感设备，X射线断层摄影仪，雷达，超声波接收器等。取决于不同的传感器，产生的图片可以是普通的二维图像，三维图组或者一个图像序列。图片的像素值往往对应于光在一个或多个光谱段上的强度（灰度图或彩色图），但也可以是相关的各种物理数据，如声波，电磁波或核磁共振的深度，吸收度或反射度。</li>
<li>预处理：在对图像实施具体的计算机视觉方法来提取某种特定的信息前，一种或一些预处理往往被采用来使图像满足后继方法的要求。例如：<ul>
<li>二次取样保证图像坐标的正确</li>
<li>平滑去噪来滤除传感器引入的设备噪声</li>
<li>提高对比度来保证实现相关信息可以被检测到</li>
<li>调整尺度空间使图像结构适合局部应用</li>
</ul>
</li>
<li>特征提取：从图像中提取各种复杂度的特征。例如<ul>
<li>线、边缘提取和脊侦测</li>
<li>局部化的特征点检测如边角检测、斑点检测</li>
<li>更复杂的特征可能与图像中的纹理形状或运动有关</li>
</ul>
</li>
<li>检测&#x2F;分割：在图像处理过程中，有时会需要对图像进行分割来提取有价值的用于后继处理的部分，例如：<ul>
<li>筛选特征点</li>
<li>分割一或多幅图片中含有特定目标的部分</li>
</ul>
</li>
<li>高级处理：到了这一步，数据往往具有很小的数量，例如图像中经先前处理被认为含有目标物体的部分。这时的处理包括：<ul>
<li>验证得到的数据是否符合前提要求</li>
<li>估测特定系数，比如目标的姿态、体积</li>
<li>对目标进行分类</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-tensorflow_serving/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-tensorflow_serving/" class="post-title-link" itemprop="url">tensorflow_serving</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>tensorflow serving库相关笔记</li>
</ul>
<h2 id="TensorFlow-Serving是什么"><a href="#TensorFlow-Serving是什么" class="headerlink" title="TensorFlow Serving是什么"></a>TensorFlow Serving是什么</h2><ul>
<li>TensorFlow Serving 是一个适用于机器学习模型的灵活、高性能应用系统，专为生产环境而设计。借助 TensorFlow Serving，您可以轻松部署新算法和实验，同时保留相同的服务器架构和 API。TensorFlow Serving 提供与 TensorFlow 模型的开箱即用型集成，但也可以轻松扩展以应用其他类型的模型和数据。</li>
</ul>
<h2 id="C-tensorflow-serving库-详解"><a href="#C-tensorflow-serving库-详解" class="headerlink" title="C++ tensorflow serving库 详解"></a>C++ tensorflow serving库 详解</h2><p>TensorFlow Serving 是一个用于部署机器学习模型的开源库，它提供了一个高性能、灵活的方式来将训练好的 TensorFlow 模型部署到生产环境中，以便进行实时预测。虽然 TensorFlow Serving 主要是用 C++ 实现的，但它也提供了 Python API 以方便用户使用。</p>
<p>下面是对 TensorFlow Serving C++ 库的详细介绍：</p>
<ol>
<li><p><strong>核心功能</strong>：</p>
<ul>
<li>加载和管理模型：TensorFlow Serving 能够加载和管理训练好的 TensorFlow 模型，包括 SavedModel 格式。</li>
<li>提供预测服务：一旦模型被加载，TensorFlow Serving 可以为客户端提供实时的预测服务，支持单个或批量请求。</li>
<li>高性能和可扩展性：TensorFlow Serving 在设计上注重性能和可扩展性，能够处理高并发的请求并保持低延迟。</li>
</ul>
</li>
<li><p><strong>架构</strong>：</p>
<ul>
<li>TensorFlow Serving 的架构主要由三个组件组成：Servable、Loader 和 Servable Manager。</li>
<li>Servable 是指 TensorFlow 模型的一种抽象，它代表了一个可部署的模型或模型的版本。</li>
<li>Loader 负责加载 Servable，并在需要时将其初始化或卸载。</li>
<li>Servable Manager 负责管理 Servable 的生命周期，包括加载、卸载和路由请求等。</li>
</ul>
</li>
<li><p><strong>部署流程</strong>：</p>
<ul>
<li>准备模型：首先需要使用 TensorFlow 训练模型，并将其保存为 SavedModel 格式。</li>
<li>配置 TensorFlow Serving：创建一个模型配置文件，指定模型的路径、输入和输出等信息。</li>
<li>启动 TensorFlow Serving：运行 TensorFlow Serving 服务器，并指定模型配置文件。</li>
<li>发送请求：客户端向 TensorFlow Serving 发送预测请求，服务器返回预测结果。</li>
</ul>
</li>
<li><p><strong>使用示例</strong>：<br>下面是一个简单的 TensorFlow Serving C++ 应用示例，假设我们已经有一个名为 <code>my_model</code> 的 SavedModel：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tensorflow_serving/apis/prediction_service.grpc.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> grpc::Channel;</span><br><span class="line"><span class="keyword">using</span> grpc::ClientContext;</span><br><span class="line"><span class="keyword">using</span> grpc::Status;</span><br><span class="line"><span class="keyword">using</span> tensorflow::serving::PredictRequest;</span><br><span class="line"><span class="keyword">using</span> tensorflow::serving::PredictResponse;</span><br><span class="line"><span class="keyword">using</span> tensorflow::serving::PredictionService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TensorFlowServingClient</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TensorFlowServingClient</span>(std::shared_ptr&lt;Channel&gt; channel)</span><br><span class="line">        : <span class="built_in">stub_</span>(PredictionService::<span class="built_in">NewStub</span>(channel)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送预测请求</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Predict</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PredictRequest request;</span><br><span class="line">        PredictResponse response;</span><br><span class="line">        ClientContext context;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置输入数据</span></span><br><span class="line">        <span class="comment">// request.mutable_model_spec()-&gt;set_name(&quot;my_model&quot;);</span></span><br><span class="line">        <span class="comment">// 添加输入数据</span></span><br><span class="line">        <span class="comment">// request.mutable_inputs()-&gt;...;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送预测请求</span></span><br><span class="line">        Status status = stub_-&gt;<span class="built_in">Predict</span>(&amp;context, request, &amp;response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理预测结果</span></span><br><span class="line">        <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="comment">// 处理 response 中的输出结果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;RPC failed: &quot;</span> &lt;&lt; status.<span class="built_in">error_message</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;PredictionService::Stub&gt; stub_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 TensorFlow Serving 客户端</span></span><br><span class="line">    <span class="function">TensorFlowServingClient <span class="title">client</span><span class="params">(grpc::CreateChannel(<span class="string">&quot;localhost:8500&quot;</span>, grpc::InsecureChannelCredentials()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送预测请求</span></span><br><span class="line">    client.<span class="built_in">Predict</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例演示了如何创建一个 TensorFlow Serving 客户端，并发送预测请求。需要注意的是，你需要根据实际情况修改模型的名称、输入数据等信息。</p>
</li>
</ol>
<p>总的来说，TensorFlow Serving 提供了一个功能强大的 C++ 库，用于部署 TensorFlow 模型并提供实时预测服务。通过了解其核心功能、架构和部署流程，你可以更好地使用 TensorFlow Serving 来满足你的部署需求。</p>
<h2 id="SavedModel格式是什么"><a href="#SavedModel格式是什么" class="headerlink" title="SavedModel格式是什么"></a>SavedModel格式是什么</h2><p>SavedModel 是 TensorFlow 中用于保存和加载模型的标准格式。它是一种可移植、可恢复的模型表示形式，可以轻松地在不同的平台上进行部署和共享。SavedModel 以文件夹的形式存储，其中包含了模型的结构、权重参数、计算图以及其他相关的元数据。</p>
<p>SavedModel 主要由两个部分组成：</p>
<ol>
<li><p><strong>模型图（GraphDef）</strong>：模型的计算图以 Protocol Buffers 格式保存在名为 <code>saved_model.pb</code> 的文件中。计算图定义了模型的结构，包括输入、输出、各种操作（如张量运算、变量等）以及操作之间的连接关系。</p>
</li>
<li><p><strong>变量和资源</strong>：模型的权重参数、变量和其他资源以二进制格式保存在名为 <code>variables/</code> 的文件夹中。这些文件包含了模型的具体参数值，用于在加载模型时恢复模型的状态。</p>
</li>
</ol>
<p>除了这两个基本部分之外，SavedModel 还可以包含其他的元数据信息，例如模型的签名信息（用于描述模型的输入和输出）、运行配置、版本信息等。</p>
<p>SavedModel 的优点在于它具有跨平台和版本控制的能力，可以在不同的 TensorFlow 版本和不同的硬件平台上进行部署和加载。这使得 SavedModel 成为了 TensorFlow 模型部署和共享的标准格式，被广泛应用于生产环境中。</p>
<h2 id="C-tensorflow-serving加载onnx模型"><a href="#C-tensorflow-serving加载onnx模型" class="headerlink" title="C++ tensorflow serving加载onnx模型"></a>C++ tensorflow serving加载onnx模型</h2><p>TensorFlow Serving 最初设计用于加载和提供 TensorFlow 模型的预测服务，但它也支持加载其他格式的模型，包括 ONNX（Open Neural Network Exchange）格式的模型。ONNX 是一种开放的标准，用于表示深度学习模型，它允许用户在不同的深度学习框架之间交换模型，并在不同的硬件平台上运行这些模型。</p>
<p>要在 TensorFlow Serving 中加载 ONNX 模型，你需要先将 ONNX 模型转换为 TensorFlow 的 SavedModel 格式，然后再使用 TensorFlow Serving 加载 SavedModel。以下是一个大致的步骤：</p>
<ol>
<li><p><strong>将 ONNX 模型转换为 TensorFlow SavedModel</strong>：</p>
<ul>
<li>使用 ONNX-TensorFlow 或 onnx-tf 工具将 ONNX 模型转换为 TensorFlow 的 SavedModel 格式。这些工具可以帮助你将 ONNX 模型导入到 TensorFlow 中，并将其保存为 SavedModel 格式。</li>
</ul>
</li>
<li><p><strong>使用 TensorFlow Serving 加载 SavedModel</strong>：</p>
<ul>
<li>使用 TensorFlow Serving 的配置文件（通常是 TensorFlow Serving 的 Docker 镜像中的配置文件），将转换后的 SavedModel 添加到配置中。</li>
<li>启动 TensorFlow Serving 服务器，并指定模型配置文件。</li>
</ul>
</li>
</ol>
<p>下面是一个大致的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 将 ONNX 模型转换为 TensorFlow SavedModel</span></span><br><span class="line">onnx-tf convert -i model.onnx -o saved_model/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 配置 TensorFlow Serving</span></span><br><span class="line"><span class="comment"># 创建一个模型配置文件，例如 model_config.json，指定模型的路径和类型</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;model_version_policy&quot;</span>: &#123; <span class="string">&quot;specific&quot;</span>: &#123; <span class="string">&quot;versions&quot;</span>: &#123; <span class="string">&quot;1&quot;</span>: &#123;&#125; &#125; &#125; &#125;,</span><br><span class="line">  <span class="string">&quot;model_platform&quot;</span>: <span class="string">&quot;tensorflow&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;onnx_model&quot;</span>,</span><br><span class="line">  <span class="string">&quot;base_path&quot;</span>: <span class="string">&quot;/path/to/saved_model&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 启动 TensorFlow Serving</span></span><br><span class="line">docker run -p 8500:8500 -p 8501:8501 --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/path/to/model_config.json,target=/models/onnx_model/config.json -t tensorflow/serving</span><br></pre></td></tr></table></figure>

<p>这里的关键步骤是将 ONNX 模型转换为 TensorFlow 的 SavedModel 格式，并通过 TensorFlow Serving 的配置文件将 SavedModel 添加到 TensorFlow Serving 中。这样就可以在 TensorFlow Serving 中加载和提供 ONNX 模型的预测服务了。</p>
<h2 id="docker方式部署-官方示例"><a href="#docker方式部署-官方示例" class="headerlink" title="docker方式部署(官方示例)"></a>docker方式部署(官方示例)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Download the TensorFlow Serving Docker image and repo</span></span><br><span class="line">docker pull tensorflow/serving</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tensorflow/serving</span><br><span class="line"><span class="comment"># Location of demo models</span></span><br><span class="line">TESTDATA=<span class="string">&quot;<span class="subst">$(pwd)</span>/serving/tensorflow_serving/servables/tensorflow/testdata&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start TensorFlow Serving container and open the REST API port</span></span><br><span class="line">docker run -t --<span class="built_in">rm</span> -p 8501:8501 \</span><br><span class="line">    -v <span class="string">&quot;<span class="variable">$TESTDATA</span>/saved_model_half_plus_two_cpu:/models/half_plus_two&quot;</span> \</span><br><span class="line">    -e MODEL_NAME=half_plus_two \</span><br><span class="line">    tensorflow/serving &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Query the model using the predict API</span></span><br><span class="line">curl -d <span class="string">&#x27;&#123;&quot;instances&quot;: [1.0, 2.0, 5.0]&#125;&#x27;</span> \</span><br><span class="line">    -X POST http://localhost:8501/v1/models/half_plus_two:predict</span><br><span class="line"></span><br><span class="line"><span class="comment"># Returns =&gt; &#123; &quot;predictions&quot;: [2.5, 3.0, 4.5] &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="拉取serving-docker-image"><a href="#拉取serving-docker-image" class="headerlink" title="拉取serving docker image"></a>拉取serving docker image</h2><ul>
<li><p>运行命令</p>
<ul>
<li>docker pull tensorflow&#x2F;serving</li>
</ul>
</li>
<li><p>tensorflow serving docker历史镜像</p>
<ul>
<li>地址: <a target="_blank" rel="noopener" href="https://hub.docker.com/r/tensorflow/serving/tags/">https://hub.docker.com/r/tensorflow/serving/tags/</a></li>
</ul>
</li>
</ul>
<h2 id="从serving-docker-image-启动一个容器"><a href="#从serving-docker-image-启动一个容器" class="headerlink" title="从serving docker image 启动一个容器"></a>从serving docker image 启动一个容器</h2><ul>
<li>serving images有以下属性<ul>
<li>8500 端口服务于gRPC</li>
<li>8501 端口服务于 REST API</li>
<li>可选的环境变量 MODEL_NAME(默认为 model)</li>
<li>可选的环境变量 MODEL_BASE_PATH(默认为 &#x2F;models)</li>
</ul>
</li>
<li>当 serving image运行一个容器时，其内部实际运行的命令是<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensorflow_model_server --port=8500 --rest_api_port=8501 \</span><br><span class="line">  --model_name=<span class="variable">$&#123;MODEL_NAME&#125;</span> --model_base_path=<span class="variable">$&#123;MODEL_BASE_PATH&#125;</span>/<span class="variable">$&#123;MODEL_NAME&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-pytorch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-pytorch/" class="post-title-link" itemprop="url">pytorch</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>pytorch相关笔记</li>
</ul>
<h2 id="pytorch生态部署方案"><a href="#pytorch生态部署方案" class="headerlink" title="pytorch生态部署方案"></a>pytorch生态部署方案</h2><ul>
<li>Pytorch虽然社区生态好，各种功能模块都是非常好用，但是部署生态一直饱受诟病。</li>
<li>ONNX的规范及代码主要由微软，亚马逊，Facebook和IBM等公司共同开发，也主要是为了来对抗谷歌的Tensorflow框架的部署生态。</li>
</ul>
<h2 id="Pytorch保存模型转化为ONNX模型"><a href="#Pytorch保存模型转化为ONNX模型" class="headerlink" title="Pytorch保存模型转化为ONNX模型"></a>Pytorch保存模型转化为ONNX模型</h2><ul>
<li>通过Pytorch保存下来的模型pth，因为pth部署无法跨平台移植，我们必须将模型转化成通用格式</li>
<li>优化由于推理（或模型评分）的机器学习模型非常困难，因为需要调整模型和推理库，充分利用硬件功能。如果想要在不同类型的平台（云&#x2F;Edge、CPU&#x2F;GPU 等）上获得最佳性能，实现起来会异常困难，因为每个平台都有不同的功能和特性。 如果模型来自需要在各种平台上运行的多种框架，会极大增加复杂性。 优化框架和硬件的所有不同组合非常耗时。此时ONNX的作用就显现出来的，专注于模型推理。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-DL__AI-EDU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-DL__AI-EDU/" class="post-title-link" itemprop="url">DL__AI-EDU</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>讲解神经网络基本的训练和工作原理</li>
<li>讲解反向传播和梯度下降</li>
<li>梯度下降是神经网络的基本学习方法<br>讲解损失函数</li>
</ul>
<h3 id="人工智能的定义"><a href="#人工智能的定义" class="headerlink" title="人工智能的定义"></a>人工智能的定义</h3><ol>
<li><p>第一个层面,人们对人工智能的期待可以分为:</p>
<ul>
<li>智能地把某件特定的事情做好,在某个领域增强人类的智慧,这种方式又叫做<strong>智能增强</strong>,例如搜索引擎,智能助手等,帮助人类完成某种特定任务,又称为”弱人工智能”,或者”狭义人工智能”.</li>
<li>像人类一样能认知,思考,判断:模拟人类的智能,这样的智能也称为”<strong>通用人工智能</strong>“(Artificial General Intelligence, AGI),或”强人工智能”.</li>
</ul>
</li>
<li><p>第二个层面,从技术的特点来看</p>
<ul>
<li><p>机器学习:如果一个程序解决任务(T)的效能(用P表示)随着经验(E)得到了提高,那么这个程序就能从经验(E)中学到了关于任务(T)的知识,并让衡量值(P)得到提高.</p>
<ol>
<li>选择一个模型结构(例如逻辑回归,决策树等),这就是上面所说的程序</li>
<li>用训练数据(输入和输出) 输入模型,这就是上面的经验(E)</li>
<li>通过不断执行任务(T)并衡量结果(P),让P不断提高,直到达到一个满意的值.</li>
</ol>
</li>
<li><p>机器学习的各种方法是如何从经验中学习?其大致可分为三种类型:</p>
<ol>
<li>监督学习(Supervised Learning)  :通过标注的数据来学习</li>
<li>无监督学习(Unsupervised Learning):通过没有标注的数据来学习,这种算法可以发现数据中自然形成的共同特性(聚类),可以用来发现不同数据之间的联系</li>
<li>强化学习(Reinforcement Learning):让程序选择和它的环境互动,环境给程序反馈</li>
</ol>
</li>
<li><p><strong>机器学习领域出现了各种模型,其中,神经网络模型是一个重要的方法</strong></p>
<ul>
<li>它的原型在1943年就出现了,在生物神经网络中,每个神经元与其他神经元相连,当它兴奋时,就会向相邻的神经元发送化学物质,从而改变这些神经元内的电位;如果某神经元的电位超过了一个阈值,那么它就会被激活(兴奋) ,向其他神经元发送化学物质.</li>
<li><strong>把许多这样的神经元按照一定的层次结构连接起来,我们就构建了一个神经网络</strong></li>
<li>随着数据的丰富和机器算力的增强,人们不断增加神经网络的层次数目,相邻层次之间的输入输出由非线性函数来控制,这就产生了DNN(<strong>深度神经网络</strong>).</li>
<li><strong>随着人们不断的调整网络结构,DNN也演变成许多不同的网络拓扑结构</strong>,例如 CNN(卷积神经网络), RNN(循环神经网络), LSTM(长期短期记忆), GAN(生成对抗网络), Transfer Learning(迁移学习)等,这些模型还在不断演化中</li>
<li><strong>训练AI模型,需要一系列专门的工具,业界有不少成熟的训练平台</strong>(TensorFlow, PyTorch, MXNet等),这些平台也在不断演化,支持新的模型,提高训练的效率,改进易用性等.</li>
</ul>
</li>
</ul>
</li>
<li><p>第三个层面,从应用的角度来看,狭义人工智能在各个领域都取得了很大的成果</p>
<ul>
<li>一种是标杆式的任务,例如ImageNet,考察AI模型能否识别图像的类别</li>
<li>另一种是AI技术和各种其他技术结合,解决政府,企业,个人用户的需求.在政府方面,把所有计算,数据,云端和物联网终端的设备联系起来,搭建一个能支持智能决定的系统,现代社会的城市管理,金融,医疗,物流和交通管理等等都运行在这样的系统上.专家称之为<strong>智能基础建设</strong></li>
</ul>
</li>
</ol>
<h4 id="模型的生成与应用"><a href="#模型的生成与应用" class="headerlink" title="模型的生成与应用"></a>模型的生成与应用</h4><ul>
<li>首先要设计一个模型,然后用已标注过的数据来训练这个模型,在训练过程中,<strong>模型的各个参数在多次训练中不断得到调整,最后得到了一个达到要求的模型</strong>.</li>
<li>这个模型会被用于一个推理模型中,和其他程序模块一起组成一个应用程序或者是服务,能处理新的数据,满足用户的需求.</li>
</ul>
<h3 id="范式的演化"><a href="#范式的演化" class="headerlink" title="范式的演化"></a>范式的演化</h3><p>范式演化的四个阶段:</p>
<ol>
<li><p>第一阶段:经验</p>
<ul>
<li>人类最早的科学研究,主要以记录和描述自然现象为特征,可以称之为”经验归纳”(第一范式)</li>
</ul>
</li>
<li><p>第二阶段:理论</p>
<ul>
<li>科学家们开始明确定义,速度是什么,质量是什么等等</li>
</ul>
</li>
<li><p>第三阶段:计算仿真</p>
<ul>
<li>从二十世纪中期开始,利用电子计算机对科学实验进行模拟仿真的模式得到迅速普及</li>
</ul>
</li>
<li><p>第四阶段:数据探索</p>
<ul>
<li>在这个阶段,科学家收集数据,分析数据,探索新的规律.</li>
<li>在深度学习的浪潮中出现的许多结果就是基于海量数据学习得来的.有些数据并不是从现实世界中收集而来的,而是由计算机程序自己生成的</li>
</ul>
</li>
</ol>
<h4 id="数据探索"><a href="#数据探索" class="headerlink" title="数据探索"></a>数据探索</h4><ul>
<li>当人类探索客观世界的时候,大部分情况下,我们是不了解新环境的运行规则.这个时候,我们可以观察自己的行动和客观世界的反馈,判断得失,再总结出规律.这种学习方法,叫强化学习(Reinforcement Learning),可以使用这种方法来找出适合的策略</li>
</ul>
<h3 id="神经网络的基本工作原理简介"><a href="#神经网络的基本工作原理简介" class="headerlink" title="神经网络的基本工作原理简介"></a>神经网络的基本工作原理简介</h3><p>神经元计算模型:</p>
<ol>
<li><p>输入 input:</p>
<ul>
<li>(x1, x2, x3)是外界输入信号,一般是一个训练数据样本的多个属性. 例如:(x1, x2, x3)分别代表了(红, 绿, 蓝)三种颜色,而此神经元用于识别输入的信号是暖色还是冷色</li>
</ul>
</li>
<li><p>权重 weights:</p>
<ul>
<li>(w1, w2, w3)是每个输入信号的权重值,以上面的(x1, x2, x3)的例子来说,x1的权重可能是0.92, x2的权重可能是0.2, x3的权重可能是0.03. <strong>权重值相加之后可以不是1</strong></li>
</ul>
</li>
<li><p>偏移 bias:</p>
<ul>
<li>一般的书或者博客上会说:那是因为y &#x3D; w*x + b, b是偏移值,使得直线能够沿Y轴上下移动,这是用结果来解释原因,并非b存在的真实原因</li>
<li>从生物学上解释,在脑神经细胞中,一定是输入信号的电平&#x2F;电流大于某个<strong>临界值</strong>时,神经元细胞才会处于兴奋状态,这个b实际就是那个临界值. 即当: w1 * x1 + w2 * x2 + w3 * x3 &gt;&#x3D; t时,该神经 细胞才会兴奋</li>
</ul>
</li>
<li><p>激活函数 activation:</p>
<ul>
<li>求和之后,神经细胞已经处于兴奋状态了,已经决定要向下一个神经元传递信号了,但是要传递多强烈的信号,要由激活函数来确定.</li>
<li>如果激活函数是一个阶跃信号的话,会像继电器开合一样咔咔的开启和闭合; 但是在生物体中是不可能有这种装置的,而是一个渐渐变化的过程.所以激活函数都是有一个渐变的过程,也就是是个<strong>曲线</strong></li>
</ul>
</li>
</ol>
<h4 id="神经网络的主要功能"><a href="#神经网络的主要功能" class="headerlink" title="神经网络的主要功能"></a>神经网络的主要功能</h4><ol>
<li><p>回归(Regression)或者叫做拟合(Fitting)</p>
<ul>
<li>单层的神经网络能够模拟一条二维平面上的直线,从而可以完成线性分割任务</li>
<li>所谓回归或者拟合,其实就是<strong>给出x值输出y值的过程,并且让y值与样本数据形成的曲线的距离可能的小</strong>,可以理解为是对样本数据的一种骨架式的抽象.</li>
</ul>
</li>
<li><p>分类(Classification)</p>
<ul>
<li>使用一个两层的神经网络可以得到一个非常近似的结果,使得分类误差在满意的范围之内.</li>
<li>分类可以理解为对两类或多类样本数据的边界的抽象</li>
<li>对于复杂的函数,一个两层的神经网络是如何做到的?其实从输入层到隐藏层的矩阵计算,就是对输入数据进行了空间变换,使其可以被线性可分,然后在输出层画出一个分界线.而训练的过程,就是确定那个空间变换矩阵的过程.<strong>因此,多层神经网络的本质就是对复杂函数的拟合.</strong></li>
</ul>
</li>
</ol>
<h4 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a>激活函数的作用</h4><ol>
<li>激活函数相当于人类的关节</li>
<li>如果不运用激活函数,输出信号将仅仅是一个简单的线性函数,线性函数是一个一级多项式.线性方程是很容易解决的,但是它们的复杂性有限,并且从数据中学习复杂函数映射的能力更小.<strong>一个没有激活函数的神经网络将只不过是一个线性回归模型罢了,不能解决现实世界中的大多数非线性问题.</strong></li>
<li>没有激活函数,神经网络将无法学习和模拟其他复杂类型的数据,例如图像,视频,音频,语音等.这就是为什么要使用<strong>人工神经网络技术</strong>,诸如深度学习等来理解一些复杂的事情,一些相互之间具有很多隐藏层的非线性问题</li>
</ol>
<h3 id="神经网络中的三个基本概念-反向传播-梯度下降-损失函数"><a href="#神经网络中的三个基本概念-反向传播-梯度下降-损失函数" class="headerlink" title="神经网络中的三个基本概念:反向传播, 梯度下降, 损失函数"></a>神经网络中的三个基本概念:反向传播, 梯度下降, 损失函数</h3><ul>
<li><p>神经网络训练的最基本的思想就是:先”猜”一个结果,称为预测结果a,看看这个预测结果和事先标记好的训练集中的真是结果y之间的差距,然后调整策略,再试一次,这一次就不是”猜”了,而是有依据地向正确的方向靠近.如此反复多次,一直到预测结果和真实结果之间相差无几,即|a - y| 趋近于 0 ,就结束训练.在神经网络训练中,我们把”猜”叫做初始化,可以随机,也可以根据以前的经验给定初始值</p>
</li>
<li><p>简单总结反向传播和梯度下降的基本工作原理:</p>
<ol>
<li>初始化;</li>
<li>正向计算;</li>
<li>损失函数提供计算损失的方法;</li>
<li>梯度下降是在损失函数基础上向着损失最小的点靠近而指引了网络权重调整的方向;</li>
<li>反向传播把损失值反向传给神经网络的每一层,让每一层都根据损失值反向调整权重;</li>
<li>Go to 2,直到精度足够好</li>
</ol>
</li>
</ul>
<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><ul>
<li><p>梯度下降三要素:</p>
<ol>
<li>当前点;</li>
<li>方向;</li>
<li>步长.</li>
</ol>
</li>
<li><p>为什么说是”梯度下降”?</p>
<ol>
<li>梯度:函数当前位置的最快上升点</li>
<li>下降:与导数相反的方向,用数学语言描述就是那个减号; 亦即与上升相反的方向运动,就是下降.</li>
</ol>
</li>
</ul>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><ul>
<li><p>概念:</p>
<ul>
<li>在各种材料中经常看到的中英文词汇有:误差,偏差,Error,Cost,Loss,损失,代价等,意思都差不多</li>
<li>使用”损失函数”和”Loss Function”这两个词汇,具体的损失函数符号用J来表示,误差值用loss表示</li>
<li>“损失”就是所有样本的”误差”的总和</li>
<li>在黑盒子的例子中,如果说”某个样本的损失”是不对的,只能说”某个样本的误差”,因为样本是一个一个计算的.</li>
<li>如果我们把神经网络的参数调整到完全满足独立样本的输出误差为0,通常会令其它样本的误差变得更大,这样作为误差之和的损失函数值,就会变得更大.所以,<strong>我们通常会根据某个样本的误差调整权重后,计算一下整体样本的损失函数值,来判定网络是不是已经训练到了可接受的状态</strong>.</li>
</ul>
</li>
<li><p>损失函数的作用:</p>
<ul>
<li>损失函数的作用,就是计算神经网络每次迭代的前向计算结果与真实值的差距,从而指导下一步的训练正确的方向进行.</li>
<li>如何使用损失函数?具体步骤:<ol>
<li>用随机值初始化前向计算公式的参数;</li>
<li>代入样本,计算输出的预测值;</li>
<li>用损失函数计算预测值和标签值(真实值)的误差;</li>
<li>根据损失函数的导数,沿梯度最小方向将误差回传,修正前向计算公式中的各个权重值;</li>
<li>进入第二步重复,指导损失函数值达到一个满意的值就停止迭代</li>
</ol>
</li>
</ul>
</li>
<li><p>神经网络中常用的损失函数:</p>
<ul>
<li>均方差函数,主要用于回归</li>
<li>交叉熵函数,主要用于分类</li>
<li>二者都是非负函数,极值在底部,用梯度下降法可以求解.</li>
</ul>
</li>
</ul>
<h1 id="第二步-线性回归"><a href="#第二步-线性回归" class="headerlink" title="第二步:线性回归"></a>第二步:线性回归</h1><h3 id="神经网络法"><a href="#神经网络法" class="headerlink" title="神经网络法"></a>神经网络法</h3><ul>
<li><p>定义神经网络结构:</p>
<ol>
<li>输入层</li>
<li>权重w,b</li>
<li>输出层</li>
<li>损失函数</li>
</ol>
</li>
<li><p>训练过程:</p>
<ol>
<li>读取一个样本数据</li>
<li>前向计算</li>
<li>反向传播</li>
<li>更新梯度</li>
</ol>
</li>
<li><p>推理预测:</p>
<ul>
<li>推理过程,实际上就是一个<strong>前向计算过程</strong>,把它单独拿出来,方便对外接口的设计,所以这个方法被设计成了公开的方法</li>
</ul>
</li>
</ul>
<h3 id="样本特征数据标准化"><a href="#样本特征数据标准化" class="headerlink" title="样本特征数据标准化"></a>样本特征数据标准化</h3><ul>
<li><p>数据标准化(Normalization),又可以叫做数据归一化</p>
</li>
<li><p>为什么要做标准化?</p>
</li>
<li><p>理论层面上,神经网络是以样本在事件中的统计分布概率为基础进行训练和预测的,所以它对样本数据的要求比较苛刻</p>
<ol>
<li>样本的各个特征的取值要符合概率分布,即[0,1]</li>
<li>样本的度量单位要相同</li>
<li>神经网络假设所有的输入输出数据都是标准差为1,均值为0,包括权重值的初始化,激活函数的选择,以及优化算法的设计</li>
<li>数值问题</li>
<li>梯度更新,如果输出层的数量级很大,会引起损失函数的数量级很大,这样做反向传播时的梯度也就很大,这时会给梯度的更新带来数值问题</li>
<li>学习率</li>
</ol>
</li>
<li><p>标准化的常用方法:</p>
<ul>
<li>Min-Max标准化(离差标准化),将数据映射到[0,1]区间</li>
<li>平均值标准化,将数据映射到[-1,1]区间</li>
<li>对数转换</li>
<li>反正切转换</li>
<li>Z-Score法(标准差标准化&#x2F;零均值标准化):把每个特征值中的所有数据,变成平均值为0,标准差为1的数据,最后正态分布</li>
<li>中心化,平均值为0,无标准差要求</li>
<li>比例法,要求数据全是正值</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>:</p>
<ol>
<li>标准如果不做标准化,网络发散,训练无法进行;</li>
<li>训练样本标准化后,网络训练可以得到结果,但是预测结果有问题;</li>
<li>还原参数值后,预测结果正确,但是此还原方法并不普遍使用;</li>
<li>标准化测试样本,而不需要还原参数值,可以保证普遍使用;</li>
<li>标准化标签纸,可以使得网络训练收敛快,但是在预测时需要把结果反标准化,以便得到真实值.</li>
</ol>
<h1 id="第三步-线性分类"><a href="#第三步-线性分类" class="headerlink" title="第三步:线性分类"></a>第三步:线性分类</h1><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><ul>
<li>分类问题在很多资料中都称之为逻辑回归, Logistic Regression, 其原因是使用了线性回归中的线性模型,加上一个Logistic二分类函数,共同构造了一个分类器.</li>
<li>神经网络的一个重要功能就是分类,现实世界中的分类任务复杂多样,但是万变不离其宗,我们都可以用同一种模式的神经网络来处理</li>
</ul>
<h3 id="逻辑回归模型"><a href="#逻辑回归模型" class="headerlink" title="逻辑回归模型"></a>逻辑回归模型</h3><ul>
<li>回归问题可以分为两类:线性回归和逻辑回归<ol>
<li>逻辑回归(Logistic Regression), 回归给出的结果是事件成功或失败的概率.当因变量的类型属于二值(1&#x2F;0, 真&#x2F;假, 是&#x2F;否)变量时,我们就应该使用逻辑回归</li>
<li>线性回归使用一条直线拟合样本数据,而逻辑回归的目标是”拟合”0或1两个数值,而不是具体连续数值,所以成为广义线性模型.</li>
<li>逻辑回归又称Logistic回归分析,常用于数据挖掘,疾病自动诊断,经济预测等领域</li>
<li>逻辑回归的另外一个名字叫做分类器,分为线性分类器和非线性分类器,然后无论是线性还是非线性分类器,又分为两种:二分类问题和多分类问题.</li>
</ol>
</li>
<li>回归问题-&gt;逻辑回归问题-&gt;线性逻辑回归即分类问题-&gt;线性二分类问题</li>
</ul>
<h3 id="二分类函数"><a href="#二分类函数" class="headerlink" title="二分类函数"></a>二分类函数</h3><ul>
<li>对率函数Logistic Function,即可以作为激活函数使用,又可以作为二分类函数使用.在二分类任务中,叫做Logistic函数;在作为激活函数时,叫做Sigmoid函数</li>
</ul>
<h3 id="实现逻辑与或非门"><a href="#实现逻辑与或非门" class="headerlink" title="实现逻辑与或非门"></a>实现逻辑与或非门</h3><ul>
<li>单层神经网络,又叫做感知机,它可以轻松实现逻辑与,或,非门.由于逻辑与,或门,需要有两个变量输入,而逻辑非门只有一个变量输入.但是它们共同的特点是输入为0或1,可以看做是正负两个类别</li>
</ul>
<h1 id="第四步-非线性回归"><a href="#第四步-非线性回归" class="headerlink" title="第四步:非线性回归"></a>第四步:非线性回归</h1><h1 id="第五步-非线性分类"><a href="#第五步-非线性分类" class="headerlink" title="第五步:非线性分类"></a>第五步:非线性分类</h1><h1 id="第六步-模型部署"><a href="#第六步-模型部署" class="headerlink" title="第六步:模型部署"></a>第六步:模型部署</h1><h3 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a><strong>摘要</strong></h3><ul>
<li>如果已经用神经网络训练出来了一套权重矩阵,那么在实际生产环境中如何使用这些权重矩阵?</li>
<li>如果需要将训练好的网络用到后台服务中:搭建网络-&gt;加载权重矩阵-&gt;调用前向计算</li>
<li>如果是在桌面端或手机端应用中使用这些权重矩阵,这就是一个跨平台,跨语言的需求.引出了模型文件的概念,后面也直接简称为模型.</li>
<li>模型文件中不仅包含了所有的权重矩阵,还记录了该神经网络的数据流图.这样不同平台,不同语言都可以根据模型文件里的信息构建网络,加载权重矩阵,执行前向计算.</li>
</ul>
<h3 id="模型的推理与部署"><a href="#模型的推理与部署" class="headerlink" title="模型的推理与部署"></a>模型的推理与部署</h3><ul>
<li>在经过几天或者几个月的训练之后,得到了一系列的能够满足需求的权重矩阵.将输入数据按一定的顺序与权重矩阵进行运算,就可以得到对应的输出,<strong>这个过程就是推理的过程</strong>.</li>
<li>如果没有保存这些权重矩阵,那么每次使用之前,需要重新训练,这在计算资源有限的情况下是难以接受的.另外一个选择是将训练好的权重矩阵保存下来,需要使用的时候重新加载权重矩阵.</li>
<li>几乎所有的训练平台都会把<strong>网络结构,权重矩阵等信息</strong>保存在文件中,这就是我们常说的<strong>模型文件</strong>,后面也直接简称为模型.</li>
<li>模型文件快问快答:<ol>
<li>为什么需要模型文件?<ul>
<li>模型,可以想象为一个”黑盒”,输入是需要处理的一张图像,输出是一个它的类别信息或是一些特征,<strong>模型文件也因此保存了能完成这一过程的所有重要信息,并且还能用来再次训练,推理等,方便了模型的传播与发展.</strong></li>
</ul>
</li>
<li>模型文件描述的是什么?<ul>
<li>首先,目前绝大部分的深度学习框架都将整个AI模型的计算过程抽象成<strong>数据流图(Data Flow Graphs)</strong>,用户写的模型构建代码都由框架组建出一个数据流图(也可以简单理解为神经网络的结构),而当程序开始运行时,框架的执行器会根据调度策略一次执行数据流图,完成整个计算.</li>
<li>有了上面的背景知识,很容易想到:为了方便地重用AI模型的计算过程,需要将它运行的数据流图,相应的运行参数(Parameters)和训练出来的权重(Weights)保存下来,这就是AI模型文件主要描述的内容.</li>
</ul>
</li>
<li>AI模型的作用是什么?<ul>
<li>以视觉处理为例,人通过眼睛捕获光线,传递给大脑处理,返回图像的一些信息,例如:这是花,那是动物.AI模型的作用就相当于大脑的处理,能根据输入的数据给予一定的判断.</li>
<li>使用封装好的AI模型,那么设计者只需要考虑把输入的数据处理成合适的格式(类似于感光细胞的作用),然后传递给AI模型(大脑),之后就可以得到一个想要的数据.</li>
</ul>
</li>
<li>模型文件有哪些类型?TensorFlow和其他框架有什么区别?<ul>
<li>由于每个深度学习框架都有自己的设计理念和工具链,对数据流图的定义和粒度都不一样,所以每家的AI模型文件都有些区别,几乎不能通用.</li>
<li>TensorFlow在设计之处,就考虑了从训练,预测,部署等复杂的需求,所以它的数据流图几乎涵盖了整个过程可能涉及到的操作,例如:初始化,后向求导以及优化算法,设备部署(Device Placement)和分布式化,量化压缩等,所以只需要通过TensorFlow的模型文件就能获取模型完整的运行逻辑,所以很容易迁移到各种平台使用.</li>
</ul>
</li>
<li>拿到一个模型文件,自己有一些新的数据,就能继续训练AI吗?如果不能,还需要做什么 ?</li>
</ol>
<ul>
<li>训练模型的时候,除了网络架构和权重,还有训练时所使用的各种超参,比如:使用的优化器(Optimizer),批量大小(Batch size),学习率(Learning rate),冲量(Momentum)等,这些都会影响我们再训练的效果,需要格外注意.</li>
</ul>
<ol start="6">
<li>ONNX文件是什么,如果保存为ONNX文件?<ul>
<li>开放式神经网络交换(Open Neural Network Exchange,简称ONNX),是由微软,FaceBook,亚马逊等多个公司一起推出的,针对机器学习设计的开放式文件格式,可以用来存储训练好的模型.它使得不同的人工智能框架可以采用相同的格式存储模型数据并交互.</li>
<li>目前很多机器学习框架都支持ONNX格式,如Pytorch,Caffe2,CNTK,ML,NET,MXNet等,它们都有专门的export_to_onnx方法,通过遍历它们原生的数据流图,转换为ONNX标准的数据流图.而对于TensorFlow这样并不原生支持ONNX的框架,通常会使用图匹配(Graph Matching)的方法转化数据流图</li>
</ul>
</li>
<li>转化的来的模型文件有什么信息丢失?<ul>
<li>由于模型文件仅仅描述了数据流和和权重,并不包含操作符的具体实现,所以不同框架对于”同名”的操作符理解和实现也会有所不同,最终可能得到不完全一致的推理结果</li>
</ul>
</li>
<li>模型文件是如何与应用程序一起工作的?<ul>
<li>应用程序使用模型文件,本质也是要执行模型文件的数据流图.一般有两种方式实现模型文件和应用程序的协作:<ol>
<li>如果有可以独立执行模型文件的运行时(Runtime),例如:系统级别的CoreML,WinML和软件级别的Caffe,DarkNet等,我们就可以在程序中动态链接直接使用</li>
<li>除此之外,也可以将数据流图和执行数据流图的程序(一般称为Op Kernel)编译在一起,从而脱离运行时,由于单一模型涉及到的操作有限,这样可以极大减少框架所占用的资源.</li>
</ol>
</li>
<li>在将模型集成到应用程序中之前,应该先使用模型查看工具(例如Netron等)查看模型的接口,输入输出的格式和对应的范围,然后对程序中传入模型的输入作对应的预处理工作,否则可能无法得到预期的效果.</li>
</ul>
</li>
<li>本地机器有GPU,在运行推理模型的时候,怎么能利用上GPU资源?<ul>
<li>首先需要安装匹配的显卡驱动,CUDA和GPU版的框架,然后根据框架进行代码调整:</li>
<li>对于TensorFlow这样能够自动做设备部署(Device Placement)的框架,它会尽量把GPU支持的操作自动分配给GPU计算,不太需要额外的适配;</li>
<li>对于PyTorch,MXNet这样不具有自动设备部署功能的框架,可能需要进行一个额外的操作将模型,张量(tensor)从CPU部署到GPU上.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="ONNX模型文件"><a href="#ONNX模型文件" class="headerlink" title="ONNX模型文件"></a>ONNX模型文件</h3><ul>
<li>ONNX是一个开放式的规范,定义了可扩展的计算图模型,标准数据类型以及内置的运算符.该文件在存储结构上可以理解为是一种层级的结构<ul>
<li>最顶层结构是模型(Model):模型记录了该模型文件的基本数据,例如:使用的ONNX标准的版本,使用的运算符集版本,制造商的名字和版本等信息.除此以外,模型中记录着最主要的信息是图(Graph)</li>
<li>图(Graph):可以理解为是计算图的一种描述,是由输入,输出以及节点(Node)组成的,它们之间通过寻找相同的名字实现连接,也就是说,相同名字的变量会被认为是同一个变量,如果一个节点的输出名字和另一个节点的输入名字相同,这两个节点会被认为是连在一起的</li>
<li>节点(Node):就是要调用的运算符,多个节点(Node)以列表的形式在图(Graph)中存储</li>
</ul>
</li>
</ul>
<h1 id="第七步-深度神经网络"><a href="#第七步-深度神经网络" class="headerlink" title="第七步:深度神经网络"></a>第七步:深度神经网络</h1><h1 id="第八步-卷及神经网络"><a href="#第八步-卷及神经网络" class="headerlink" title="第八步:卷及神经网络"></a>第八步:卷及神经网络</h1><h2 id="卷积神经网络概述"><a href="#卷积神经网络概述" class="headerlink" title="卷积神经网络概述"></a>卷积神经网络概述</h2><ul>
<li><p>卷积神经网络（CNN，Convolutional Neural Net)是神经网络的类型之一，在图像识别和分类领域中取得了非常好的效果，比如识别人脸、物体、交通标识等，这就为机器人、自动驾驶等应用提供了坚实的技术基础。</p>
</li>
<li><p>一个典型的卷积神经网络中，会至少包含以下几个层：</p>
<ul>
<li>卷积层</li>
<li>激活函数层</li>
<li>池化层</li>
<li>全连接分类层</li>
</ul>
</li>
<li><p>卷积核， 就是一个小矩阵， </p>
</li>
<li><p>在卷积层中，我们会用输入数据与卷积核相乘，得到输出数据，就类似全连接层中的Weights一样，所以卷积核里的数值，也是通过反向传播的方法学习到的</p>
</li>
<li><p>各种卷积核的作用</p>
<ul>
<li>锐化(<code>sharpness</code>) ： 如果一个像素点比周围像素点亮，则此算子会令其更亮</li>
<li>检测竖边(<code>vertical edge</code>) ： 检测出了十字线中的竖线，由于是左侧和右侧分别检查一次，所以得到两条颜色不一样的竖线</li>
<li>周边(<code>surround</code>)   ：  把周边增强，把同色的区域变弱，形成大色块</li>
<li>Sobel-Y(<code>sobel y</code>) ：  纵向亮度差分可以检测出横边，与横边检测不同的是，它可以使得两条横线具有相同的颜色，具有分割线的效果</li>
<li>Identity ： 中心为1四周为0的过滤器，卷积后与原图相同</li>
<li>横边检测(<code>horizontal edge</code>)  ： 检测出了十字线中的横线，由于是上侧和下侧分别检查一次，所以得到两条颜色不一样的横线</li>
<li>模糊(<code>blur</code>)  ： 通过把周围的点做平均值计算而“杀富济贫”造成模糊效果</li>
<li>Sobel-X(<code>sobel x</code>)  ： 横向亮度差分可以检测出竖边，与竖边检测不同的是，它可以使得两条竖线具有相同的颜色，具有分割线的效果</li>
<li>浮雕(<code>embossing</code>)    ： 形成大理石浮雕般的效果</li>
</ul>
</li>
<li><p>卷积神经网络通过反向传播而令卷积核自我学习，找到分布在图片中的不同的feature，最后形成的卷积核中的数据。</p>
</li>
<li><p>但是如果想达到这种效果，只有卷积层的话是不够的，还需要激活函数、池化等操作的配合</p>
</li>
<li><p>我们实现的卷积操作不是原始数学含义的卷积，而是工程上的卷积，可以简称为卷积</p>
</li>
<li><p>在实现卷积操作时，并不会反转卷积核</p>
</li>
<li><p>在传统的图像处理中，卷积操作多用来进行滤波，锐化或者边缘检测啥的。我们可以认为<strong>卷积是利用某些设计好的参数组合（卷积核）去提取图像空域上相邻的信息</strong></p>
</li>
<li><p>多入单出的降维卷积</p>
<ul>
<li>一张图片，通常是彩色的，具有红绿蓝三个通道。我们可以有两个选择来处理<ul>
<li>变成灰度的，每个像素只剩下一个值，就可以用二维卷积</li>
<li>对于三个通道，每个通道都使用一个卷积核，分别处理红绿蓝三种颜色的信息</li>
</ul>
</li>
<li>显然第2种方法可以从图中学习到更多的特征，于是出现了三维卷积，即有三个卷积核分别对应输入的三个通道，三个子核的尺寸是一样的，比如都是2x2，这样的话，这三个卷积核就是一个3x2x2的立体核，称为<strong>过滤器Filter</strong>，所以称为三维卷积</li>
</ul>
</li>
<li><p>每一个卷积核对应着左侧相同颜色的输入通道，三个过滤器的值并不一定相同。对三个通道各自做卷积后，得到右侧的三张特征图，然后再按照原始值不加权地相加在一起，得到最右侧的白色特征图，这张图里面已经把三种颜色的特征混在一起了，所以画成了白色，表示没有颜色特征了</p>
</li>
<li><p>虽然输入图片是多个通道的，或者说是三维的，但是在相同数量的过滤器的计算后，相加在一起的结果是一个通道，即2维数据，所以称为<strong>降维</strong>。这当然简化了对多通道数据的计算难度，但同时也会损失多通道数据自带的颜色信息</p>
</li>
<li><p>卷积编程模型， 五个概念</p>
<ul>
<li>输入    – <code>Input Channel</code></li>
<li>卷积核组 – <code>WeightsBias</code></li>
<li>过滤器  – <code>Filter</code></li>
<li>卷积核  – <code>Kernel</code></li>
<li>输出    – <code>Feature Map</code></li>
</ul>
</li>
<li><p>输入是三维数据（3x32x32），经过2x3x5x5的卷积后，输出为三维（2x28x28），维数并没有变化，只是每一维内部的尺寸有了变化，一般都是要向更小的尺寸变化，以便于简化计算</p>
</li>
<li><p>三维卷积的特点：</p>
<ul>
<li>预先定义输出的feature map的数量，而不是根据前向计算自动计算出来</li>
<li>对于每个输出，都有一个对应的过滤器Filter</li>
<li>每个Filter内都有一个或多个卷积核Kernal，对应每个输入通道(Input Channel)，</li>
<li>每个Filter只有一个Bias值，Filter-1对应b1，Filter-2对应b2</li>
<li>卷积核Kernal的大小一般是奇数如：1x1, 3x3, 5x5, 7x7等</li>
</ul>
</li>
<li><p>步长：</p>
<ul>
<li>每次计算后，卷积核会向右或者向下移动一个单元，即步长stride &#x3D; 1</li>
<li>卷积核每次向右或向下移动两个单元，即stride &#x3D; 2</li>
</ul>
</li>
<li><p>一般情况下，我们用正方形的卷积核，且为奇数</p>
</li>
<li><p>如果计算出的输出图片尺寸为小数，则取整，不做四舍五入</p>
</li>
</ul>
<h2 id="卷积神经网络应用"><a href="#卷积神经网络应用" class="headerlink" title="卷积神经网络应用"></a>卷积神经网络应用</h2><ul>
<li><p>卷积神经网络是现在深度学习领域中最有用的网络类型，尤其在计算机视觉领域更是一枝独秀。卷积神经网络从90年代的LeNet开始，沉寂了10年，也孵化了10年，直到2012年AlexNet开始再次崛起，后续的ZF Net、VGG、GoogLeNet、ResNet、DenseNet，网络越来越深，架构越来越复杂，解决反向传播时梯度消失的方法也越来越巧妙。下面让我们一起学习一下这些经典的网络模型</p>
</li>
<li><p>LeNet是卷积神经网络的开创者LeCun在1998年提出，用于解决手写数字识别的视觉任务。自那时起，卷积神经网络的最基本的架构就定下来了：卷积层、池化层、全连接层</p>
</li>
<li></li>
</ul>
<h1 id="第九步-循环神经网络"><a href="#第九步-循环神经网络" class="headerlink" title="第九步:循环神经网络"></a>第九步:循环神经网络</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Debugger/2024-05-22-gdb_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Debugger/2024-05-22-gdb_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">gdb_2_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Debugger/" itemprop="url" rel="index"><span itemprop="name">Debugger</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>gdb工具使用中常见的技巧</li>
</ul>
<h2 id="日志重定向"><a href="#日志重定向" class="headerlink" title="日志重定向"></a>日志重定向</h2><p>在使用GDB进行调试时，您可以将GDB的日志输出重定向到文件中。以下是一种方法：</p>
<ol>
<li><p>打开终端并运行GDB。</p>
</li>
<li><p>在GDB提示符下，输入以下命令以启用日志记录功能并指定输出文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set logging file &lt;file_path&gt;</span><br></pre></td></tr></table></figure>

<p>将<code>&lt;file_path&gt;</code>替换为您想要将日志记录写入的文件路径和文件名。</p>
</li>
<li><p>输入以下命令以开始记录GDB日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set logging on</span><br></pre></td></tr></table></figure>

<p>GDB将开始将日志记录写入指定的文件。</p>
</li>
<li><p>执行您的调试操作，进行需要的步骤和命令。</p>
</li>
<li><p>当您完成调试并想要停止日志记录时，输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set logging off</span><br></pre></td></tr></table></figure>

<p>GDB将停止将日志写入文件。</p>
</li>
</ol>
<p>请注意，这种方法将GDB的整个会话记录到文件中，包括所有输入和输出。这对于调试复杂的问题或追踪程序执行流程非常有用。</p>
<p>希望这可以帮助您将GDB的日志输出到文件中。如有其他问题，请随时提问。</p>
<hr>
<h2 id="启动程序-输入-参数"><a href="#启动程序-输入-参数" class="headerlink" title="启动程序 输入 参数"></a>启动程序 输入 参数</h2><ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb --args ./mnc.exe --port=10008 --ip=0.0.0.0</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="gdb-查看断点"><a href="#gdb-查看断点" class="headerlink" title="gdb 查看断点"></a>gdb 查看断点</h2><p>要查看在GDB中设置的所有断点，你可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info breakpoints</span><br></pre></td></tr></table></figure>

<p>该命令会显示当前设置的所有断点的列表，包括断点编号、断点位置和断点条件（如果有设置条件的话）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x000000000040051a in main at example.c:10</span><br><span class="line">2       breakpoint     keep y   0x00000000004004f6 in foo at example.c:5</span><br></pre></td></tr></table></figure>

<p>在这个例子中，有两个断点，编号为1和2。第一个断点位于文件<code>example.c</code>的第10行的<code>main</code>函数处，第二个断点位于第5行的<code>foo</code>函数处。</p>
<p>如果你只想查看某个特定断点的详细信息，你可以使用以下命令，并将<code>&lt;breakpoint&gt;</code>替换为断点的编号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info breakpoints &lt;breakpoint&gt;</span><br></pre></td></tr></table></figure>

<p>例如，要查看断点1的详细信息，可以执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpoints 1</span><br></pre></td></tr></table></figure>

<p>这将显示关于断点1的更多信息，如断点位置、断点条件等。</p>
<hr>
<h2 id="gdb-选项-详解"><a href="#gdb-选项-详解" class="headerlink" title="gdb 选项 详解"></a>gdb 选项 详解</h2><p>GDB（GNU Debugger）是一个功能强大的调试工具，用于在Linux和其他操作系统上调试程序。GDB 9.2版本引入了许多新的选项和功能，以下是一些常用的选项的详解：</p>
<ol>
<li><p><code>-ex &quot;command&quot;</code>：在启动GDB后执行指定的GDB命令。可以使用多个<code>-ex</code>选项来执行多个命令。</p>
</li>
<li><p><code>-tui</code>：启动GDB的文本用户界面（Text User Interface，TUI）模式。TUI模式提供了源代码和程序状态的交互式显示。</p>
</li>
<li><p><code>-batch</code>：以批处理模式运行GDB，不显示交互式命令提示符。适用于自动化脚本或批处理任务。</p>
</li>
<li><p><code>-core &lt;corefile&gt;</code>：指定要调试的核心转储文件。核心转储文件包含程序在崩溃或异常终止时的状态信息。</p>
</li>
<li><p><code>-pid &lt;pid&gt;</code>：调试指定进程标识符（PID）的正在运行的程序。通过此选项，可以附加到正在运行的进程进行调试。</p>
</li>
<li><p><code>-symbols=&lt;path&gt;</code>：指定要加载的调试符号文件的路径。调试符号文件包含程序的符号信息，如变量名、函数名等。</p>
</li>
<li><p><code>-directory=&lt;path&gt;</code>：指定要搜索源代码文件的目录。当源代码文件不在当前目录或GDB默认搜索路径中时，可以使用此选项指定源代码的位置。</p>
</li>
<li><p><code>-quiet</code>：以静默模式运行GDB，不显示任何冗余的信息。</p>
</li>
<li><p><code>-ex=dir=&lt;dir&gt;</code>：指定GDB的工作目录。GDB将在指定的目录中查找程序和其他文件。</p>
</li>
<li><p><code>-command=&lt;script_file&gt;</code>：指定要执行的GDB脚本文件。可以在脚本文件中定义自定义的GDB命令和操作。</p>
</li>
</ol>
<p>这些选项只是GDB 9.2版本中的一部分，还有许多其他选项可供使用。你可以参考GDB的官方文档或运行<code>gdb --help</code>命令获取完整的选项列表和详细说明。通过熟悉和灵活运用这些选项，你可以根据具体需求使用GDB的功能来调试和分析程序。</p>
<hr>
<h2 id="gdb-9-2-保存崩溃时堆栈信息"><a href="#gdb-9-2-保存崩溃时堆栈信息" class="headerlink" title="gdb 9.2 保存崩溃时堆栈信息"></a>gdb 9.2 保存崩溃时堆栈信息</h2><p>在GDB 9.2中，你可以通过使用<code>generate-core-file</code>命令来保存崩溃时的堆栈信息。这个命令会生成一个核心转储文件，其中包含了程序在崩溃时的内存状态和堆栈信息。</p>
<p>以下是保存崩溃时堆栈信息的步骤：</p>
<ol>
<li><p>在命令行中使用以下命令启动GDB并加载可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./my_program</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置断点或者在崩溃发生的地方让程序停下来。你可以使用<code>break</code>命令设置断点，或者通过其他方式确保程序会在崩溃时停下来。</p>
</li>
<li><p>运行程序。在GDB命令行中，使用以下命令运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure>
</li>
<li><p>当程序崩溃时，GDB会自动停在断点处或者崩溃位置。</p>
</li>
<li><p>在GDB命令行中使用以下命令生成核心转储文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generate-core-file &lt;corefile&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;corefile&gt;</code>是你想要保存核心转储文件的路径和文件名。</p>
</li>
<li><p>此时，核心转储文件就保存了程序崩溃时的堆栈信息和内存状态。</p>
</li>
</ol>
<p>通过保存核心转储文件，你可以在后续的调试过程中使用该文件进行分析。你可以加载核心转储文件并使用GDB命令查看堆栈、变量值等信息，以定位崩溃的原因和解决问题。</p>
<p>需要注意的是，生成核心转储文件可能需要对系统进行相应的配置。确保你的系统允许生成核心转储文件，并且具有足够的权限来保存文件。有些系统默认禁用了核心转储文件的生成，你可能需要修改相应的设置。</p>
<p>另外，记住在发布或共享代码时，避免包含核心转储文件，因为它可能包含敏感信息。核心转储文件主要用于调试和分析崩溃问题。</p>
<hr>
<h2 id="gdb-9-2-调试核心转储文件"><a href="#gdb-9-2-调试核心转储文件" class="headerlink" title="gdb 9.2 调试核心转储文件"></a>gdb 9.2 调试核心转储文件</h2><p>在GDB 9.2中，你可以使用核心转储文件进行调试。核心转储文件是程序在崩溃或异常终止时保存的内存状态的快照，它包含了程序崩溃时的堆栈信息和内存数据。以下是使用GDB调试核心转储文件的步骤：</p>
<ol>
<li><p>启动GDB，并加载可执行文件以及核心转储文件。在命令行中使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./my_program &lt;corefile&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;corefile&gt;</code>是核心转储文件的路径和文件名。</p>
</li>
<li><p>一旦GDB加载了核心转储文件，它会还原程序崩溃时的内存状态。你可以使用GDB命令来查看堆栈信息、变量值等。</p>
</li>
<li><p>使用<code>backtrace</code>或<code>bt</code>命令查看堆栈跟踪，了解程序崩溃的位置和调用链。</p>
</li>
<li><p>使用其他GDB命令进行调试。你可以使用<code>print</code>或<code>p</code>命令查看变量值，使用<code>step</code>或<code>s</code>命令单步执行程序，使用<code>continue</code>或<code>c</code>命令让程序继续执行等。</p>
</li>
<li><p>分析堆栈信息和变量值，定位问题的原因，并进行修复。</p>
</li>
</ol>
<p>需要注意的是，调试核心转储文件时，可执行文件和核心转储文件必须是对应的，即生成核心转储文件的程序版本与进行调试的程序版本相同。如果可执行文件和核心转储文件不匹配，可能会导致调试结果不准确或无法正常调试。</p>
<p>此外，调试核心转储文件还可以结合其他GDB功能和命令，例如条件断点、内存查看等，以进一步分析问题。GDB提供了丰富的调试功能，可以帮助你定位和解决程序崩溃问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Debugger/2024-05-22-gdbserver_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Debugger/2024-05-22-gdbserver_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">gdbserver_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Debugger/" itemprop="url" rel="index"><span itemprop="name">Debugger</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>gdbserver使用过程中遇到的理论知识</li>
</ul>
<h2 id="gdbserver-常用-选项"><a href="#gdbserver-常用-选项" class="headerlink" title="gdbserver 常用 选项"></a>gdbserver 常用 选项</h2><p>GDBserver是一个用于远程调试的程序，它与GDB一起使用，允许你在目标系统上进行远程调试。以下是一些常用的GDBserver选项的详解：</p>
<ol>
<li><p><code>--multi</code>：启动GDBserver以支持多个GDB客户端连接。这允许多个调试器同时连接到同一个目标系统进行并行调试。</p>
</li>
<li><p><code>--attach &lt;pid&gt;</code>：将GDBserver附加到指定进程的PID上进行调试。通过这个选项，你可以在目标系统上调试正在运行的进程。</p>
</li>
<li><p><code>--once</code>：让GDBserver只调试一个进程，并在该进程退出后自动停止。这对于单次调试会话很有用。</p>
</li>
<li><p><code>--remote-debug</code>：启用远程调试支持，允许GDB通过网络与GDBserver通信进行远程调试。通常与<code>--port</code>选项一起使用。</p>
</li>
<li><p><code>--port &lt;port&gt;</code>：指定GDBserver监听的端口号，以便GDB通过网络连接到GDBserver进行远程调试。</p>
</li>
<li><p><code>--attach-command &lt;command&gt;</code>：在附加到进程时执行指定的GDB命令。这对于在附加时自动执行特定的调试命令非常有用。</p>
</li>
<li><p><code>--wrapper &lt;wrapper&gt;</code>：在启动目标程序之前运行指定的包装器程序。这对于在目标系统上执行额外的初始化步骤或设置环境变量非常有用。</p>
</li>
<li><p><code>--localhost</code>：GDBserver仅允许本地主机连接。这可以增加调试的安全性，限制远程访问。</p>
</li>
<li><p><code>--persistent</code>：使GDBserver保持持久运行，即使GDB客户端断开连接或退出。这样，当GDB客户端重新连接时，调试会话可以继续。</p>
</li>
<li><p><code>--separate</code>：将每个连接的GDB客户端隔离开，使它们无法相互干扰。这在并行调试多个目标时很有用。</p>
</li>
</ol>
<p>这些选项只是GDBserver的一部分，还有其他选项可供使用。你可以参考GDBserver的文档或运行<code>gdbserver --help</code>命令获取完整的选项列表和详细说明。GDBserver是一个强大的工具，可用于在目标系统上进行远程调试，帮助你调试和分析嵌入式系统或其他远程目标。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Debugger/2024-05-22-gdbserver_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Debugger/2024-05-22-gdbserver_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">gdbserver_2_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Debugger/" itemprop="url" rel="index"><span itemprop="name">Debugger</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="gdbserver使用方法，与PC机xxx-gdb搭配使用"><a href="#gdbserver使用方法，与PC机xxx-gdb搭配使用" class="headerlink" title="gdbserver使用方法，与PC机xxx-gdb搭配使用"></a><code>gdbserver</code>使用方法，与PC机xxx-gdb搭配使用</h3><ul>
<li><p>开发板：<code>gdbserver &lt;ip address&gt; &lt;listening port&gt; &lt;program&gt;</code></p>
<ul>
<li>例如：<code>gdbserver 192.167.66.112:9999 demo_02.exe</code></li>
<li>需要注意的一点是：需要调试的程序在编译时记得加上<code>-g</code>参数</li>
</ul>
</li>
<li><p>PC机:在终端中输入<code>aarch64-linux-gnu-gdb</code>之后进入gdb调试模式，然后输入<code>target remote ip-address:port</code>即可连接远程目标</p>
</li>
<li><p>交叉编译，程序的参数是从gdbserver 传进来的，其原理就是将调试信息通过端口发送到远程</p>
</li>
</ul>
<h2 id="比特大陆智能盒子远程调试"><a href="#比特大陆智能盒子远程调试" class="headerlink" title="比特大陆智能盒子远程调试"></a>比特大陆智能盒子远程调试</h2><ul>
<li><p>工具</p>
<ul>
<li>vca里面的交叉编译工具链</li>
<li>gdbserver</li>
<li>VSCode</li>
</ul>
</li>
<li><p>大致流程</p>
<ul>
<li>通过使用vca中的交叉编译工具，在x86主机上编译带有调试符号的可执行程序</li>
<li>将可执行程序拷贝到比特大陆盒子上，通过gdbserver启动程序，监听端口，例如：<code>gdbserver 0.0.0.0:19999  /data/dagger/VideoProcess/bin/ice.exe --multi-task-zmq-listen tcp://*:9100</code></li>
<li>在x86主机上，配置launch.json文件：<ul>
<li><code>&quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/ice.exe&quot;,</code></li>
<li><code>&quot;miDebuggerPath&quot;: &quot;$&#123;workspaceFolder&#125;/toolchains/aarch64-linux-gnu-6.3.1/bin/aarch64-linux-gnu-gdb&quot;,</code></li>
<li><code>&quot;miDebuggerServerAddress&quot;: &quot;192.169.5.46:19999&quot;</code></li>
</ul>
</li>
<li>开始调试</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Docker/2024-05-22-docker_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Docker/2024-05-22-docker_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">docker_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>docker相关的理论基础</li>
</ul>
<h2 id="理解Docker镜像和容器的存储路径"><a href="#理解Docker镜像和容器的存储路径" class="headerlink" title="理解Docker镜像和容器的存储路径"></a>理解Docker镜像和容器的存储路径</h2><ul>
<li><p>执行以下命令可以查看Docker的配置信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure></li>
<li><p>输出内容包含了存储驱动和docker根目录的信息</p>
</li>
<li><p>docker镜像和容器的存储路径</p>
<ul>
<li>Docker容器由网络文件，卷和镜像组成。Docker文件的存储路径取决于你的操作系统。</li>
<li>常用操作系统中的路径如下<ul>
<li>Ubuntu: &#x2F;var&#x2F;lib&#x2F;docker&#x2F;</li>
<li>Fedora: &#x2F;var&#x2F;lib&#x2F;docker</li>
<li>Debian: &#x2F;var&#x2F;lib&#x2F;docker</li>
<li>Windows: C:\ProgramData\DockerDesktop</li>
<li>MacOS: <del>&#x2F;Library&#x2F;Containers&#x2F;com.docker.docker&#x2F;Data&#x2F;vms&#x2F;0&#x2F;</del></li>
</ul>
</li>
<li>在MacOS和Windows系统中，Docker在一个虚拟机中运行Linux容器</li>
</ul>
</li>
<li><p>查看常规镜像的信息，会得到linux系统中的路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker insepct nginx</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;UpperDir&quot;</span>:<span class="string">&quot;/var/lib/docker/overlay2/585...9eb/diff&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Docker镜像。最大的文件通常是镜像。如果使用默认的overlay2存储驱动，Docker镜像会保存在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2目录</p>
</li>
<li><p>LowerDir包含镜像的只读层，表示变更的读写层包含在UpperDir中。</p>
</li>
<li><p>MergeDir表示UppeDir和LowerDir合并的结果，Docker用它来运行容器</p>
</li>
<li><p>WorkDir是overlay2的内部目录，应该是空的</p>
</li>
</ul>
<h2 id="docker-一般使用什么方式设置自启动服务"><a href="#docker-一般使用什么方式设置自启动服务" class="headerlink" title="docker 一般使用什么方式设置自启动服务"></a>docker 一般使用什么方式设置自启动服务</h2><p>在 Docker 中，通常使用以下两种方式之一来设置容器的自启动服务：</p>
<ol>
<li><p>使用 Docker Compose：<br>Docker Compose 是一个用于定义和管理多容器应用程序的工具。在 Docker Compose 配置文件中，你可以定义容器的启动顺序和依赖关系。当使用 <code>docker-compose up</code> 启动容器组时，它们将按照定义的顺序自动启动，并在 Docker 守护进程启动时自动启动。</p>
<p>在 Docker Compose 配置文件中，可以使用 <code>restart</code> 字段来设置容器的自启动行为。以下是一个示例 Docker Compose 配置文件的部分内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>restart: always</code> 指示 Docker 在容器退出时自动重新启动该容器。</p>
</li>
<li><p>使用 systemd 或其他宿主机的服务管理工具：<br>如果你的 Docker 容器运行在一个宿主机上，并且宿主机使用 systemd 或其他服务管理工具（如 Upstart 或 SysV init），你可以在宿主机上创建一个服务单元文件来管理 Docker 容器的启动和自启动行为。</p>
<p>在宿主机上，你可以创建一个自定义的 systemd 服务单元文件（通常位于 <code>/etc/systemd/system/</code> 目录下），并使用 <code>docker run</code> 命令来启动容器。然后，通过配置 systemd 服务单元文件，将 Docker 容器与宿主机的服务管理工具集成在一起，以实现容器的自启动。</p>
<p>以下是一个示例 systemd 服务单元文件的部分内容：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Docker Container: My Service</span><br><span class="line"><span class="attr">Requires</span>=docker.service</span><br><span class="line"><span class="attr">After</span>=docker.service</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/docker run --name my-container my-image</span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=default.target</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>ExecStart</code> 字段指定了启动容器的命令。<code>Restart=always</code> 字段指示 systemd 在容器退出时自动重新启动。</p>
</li>
</ol>
<p>无论你选择使用 Docker Compose 还是宿主机的服务管理工具，都可以根据具体需求来设置容器的自启动服务。请注意，在设置自启动服务时，要确保 Docker 服务已经正确安装和启动，并且容器的镜像已经准备好。</p>
<hr>
<h2 id="docker-systemctl-无效"><a href="#docker-systemctl-无效" class="headerlink" title="docker systemctl 无效"></a>docker systemctl 无效</h2><p>在 Docker 容器中，<code>systemctl</code> 命令无效，因为容器中并没有运行 Systemd 进程，而 <code>systemctl</code> 命令是 Systemd 的服务管理工具。</p>
<p>Docker 容器是基于轻量级的容器化技术构建的，它们通常以单个进程运行，并不包含完整的操作系统。因此，与在主机操作系统上一样使用 <code>systemctl</code> 命令是不可行的。</p>
<p>在 Docker 中，你可以通过以下方式来管理容器内的服务或进程：</p>
<ol>
<li><p>启动和停止容器：使用 <code>docker start</code> 和 <code>docker stop</code> 命令来启动和停止容器，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start container_name</span><br><span class="line">docker stop container_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行服务进程：在容器中直接运行服务进程，可以通过 Dockerfile 或者启动容器时指定要运行的命令。</p>
</li>
<li><p>使用 Docker Compose：如果你在 Docker Compose 中定义了服务，可以使用 <code>docker-compose up</code> 和 <code>docker-compose down</code> 命令来启动和停止整个服务组。</p>
</li>
</ol>
<p>请记住，Docker 容器是设计用于运行单个进程或服务的，而不是一个完整的操作系统环境。因此，与在传统的虚拟机或物理机上管理服务的方式有所不同。你可以通过容器的启动命令和配置来管理容器内的服务和进程。</p>
<hr>
<h2 id="目录映射"><a href="#目录映射" class="headerlink" title="目录映射"></a>目录映射</h2><ul>
<li><code>-p</code>:指定端口映射，格式为：主机（宿主）端口：容器端口</li>
<li><code>--privileged=true</code>:关闭安全权限，否则容器操作文件没有权限</li>
<li><code>-v</code>:挂在目录为：主机目录：容器目录，在创建前容器是没有指定目录时，docker容器会自己创建</li>
<li>端口映射:<code>-p 8083:8083 -p 5678:5678</code></li>
<li>目录映射以宿主机为主，换句话说，容器中原本存在的文件一旦进过挂载，就一定会被宿主机覆盖</li>
</ul>
<hr>
<h2 id="如何处理overlay2"><a href="#如何处理overlay2" class="headerlink" title="如何处理overlay2"></a>如何处理overlay2</h2><ul>
<li>真正要处理的不是这两个文件，是要检查正在跑的容器内的服务，有没有往容器本地写文件的行为，如果有，则要把写文件的路径挂载出来，或者直接在容器中删除文件</li>
</ul>
<hr>
<h2 id="docker-语言支持"><a href="#docker-语言支持" class="headerlink" title="docker 语言支持"></a>docker 语言支持</h2><ul>
<li>node.js</li>
<li>python</li>
<li>java</li>
<li>go</li>
<li>c#</li>
</ul>
<hr>
<h2 id="docker中的overlay2"><a href="#docker中的overlay2" class="headerlink" title="docker中的overlay2"></a>docker中的overlay2</h2><ul>
<li>在安装的docker系统中，删除了容器和镜像，但是docker&#x2F;overlay2还是占用很大的磁盘空间</li>
</ul>
<hr>
<h2 id="docker-overlay2下的文件都是些什么"><a href="#docker-overlay2下的文件都是些什么" class="headerlink" title="docker&#x2F;overlay2下的文件都是些什么"></a>docker&#x2F;overlay2下的文件都是些什么</h2><ul>
<li>docker&#x2F;overlay2目录下的文件名基本都是md5编码</li>
<li>overlay2是docker使用的文件存储驱动，也就是说，该目录下的文件都是docker使用的存储<ul>
<li>overlay2是分层存储，每一层通过本层的md5作为文件夹名来命名，如果要存储的两个东西，例如两个镜像的底层中的几层内容是一样的，那么它们的md5也就是一样的，通过md5检验，确认它们这几层是一样的，那么在overlay2实际存储的时候，这几层就可以只存储一份，然后由这两个镜像共同使用，来达到节省空间的目的</li>
</ul>
</li>
</ul>
<hr>
<h2 id="docker底层原理"><a href="#docker底层原理" class="headerlink" title="docker底层原理"></a>docker底层原理</h2><ul>
<li><p>第一次接触docker概念，都会见到或者听见一句话：<strong>docker技术比虚拟技术更为方便，快捷，docker容器本质上是进程</strong></p>
</li>
<li><p>所有容器共享宿主机的cpu，磁盘，网络，内存等：</p>
<ul>
<li><strong>实现了进程隔离</strong>，每个服务独立运行</li>
<li><strong>文件系统隔离</strong>，容器目录修改不影响主机目录</li>
<li><strong>资源隔离</strong>，CPU内存，磁盘，网络资源相互独立</li>
</ul>
</li>
<li><p>Docker容器的实现原理就是通过Namespace命名空间进行进程隔离，Unionfilesystem联合文件系统实现文件系统隔离，ControlGroups控制组实现资源隔离。</p>
</li>
<li><p>其底层原理涉及到<code>linux namespace</code>，Linux Namespace 是Linux提供的一种内核级别环境隔离的方法。 Unix有<code>chroot</code>，提供了一种简单的模式：<code>chroot</code>内部的文件系统无法访问外部的内容。<code>Linux Namespace</code>在此基础上，提供了对<code>UTS, IPC, mount, PID, network, User</code>等的隔离机制</p>
<ul>
<li><code>https://lwn.net/Articles/531114/</code></li>
</ul>
</li>
<li><p>Linux Namespace, 有几个种类：<code>Mount namespaces</code>, <code>UTS namespaces</code>, <code>IPC namespaces</code>, <code>PID namespaces</code>, <code>Network namespaces</code>, <code>User namespaces</code></p>
</li>
<li><p>主要是三个系统调用：</p>
<ul>
<li><code>clone()</code>, 实现线程的系统调用，用来创建一个新的进程，并且可以通过设计上述参数达到隔离</li>
<li><code>unshare()</code>, 使某个进程脱离某个<code>namespace</code></li>
<li><code>setns()</code>, 把某进程加入到某个<code>namespace</code></li>
</ul>
</li>
</ul>
<h2 id="Docker-exec-的实现原理"><a href="#Docker-exec-的实现原理" class="headerlink" title="Docker exec 的实现原理"></a>Docker exec 的实现原理</h2><ul>
<li><code>Linux Namespace</code>创建的隔离空间是虚拟的，一个进程的<code>Namespace</code>信息在宿主机上是真实存在的，并且是以一个文件的方式存在。</li>
<li>一个进程，可以选择加入到某个进程已有的<code>Namespace</code>当中，从而达到“进入”这个进程所在容器的目的，这正是<code>docker exec</code>的实现原理</li>
<li>通过<code>setns()</code>可以将当前进程加入到已有的<code>namespace</code>中。</li>
</ul>
<h2 id="镜像启动容器的本质"><a href="#镜像启动容器的本质" class="headerlink" title="镜像启动容器的本质"></a>镜像启动容器的本质</h2><ul>
<li>首先，需要明确Docker内的文件系统是如何工作的，Docker镜像被存储在一系列的<strong>只读层</strong>。</li>
<li><strong>Docker镜像是由多个文件系统（只读层）叠加而成，当启动一个容器的时候，Docker会加载只读层并在其上（镜像栈顶部）添加一个读写层</strong></li>
<li>如果运行中的容器修改了现有的一个已经存在的文件，那么该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏。当删除Docker容器，并通过该镜像重启的时候，之前的修改将会丢失</li>
<li>在Docker中，只读层和顶部的读写层的组合被称为<strong>联合文件系统(Union File System)</strong></li>
<li>Docker镜像可以理解成多个只读文件叠加而成，因此镜像是只读的，<strong>当镜像运行起来时，就相当于在只读的镜像外面包裹了一层读写层变成了容器。</strong></li>
<li>当删除容器之后，使用镜像重新创建一个容器时，此时的镜像的只读层和原来一样，只是在读写层的修改会全部丢失</li>
<li>所以，docker的数据持久化说的就是：<strong>数据不随容器的删除而消失。</strong></li>
</ul>
<h2 id="数据卷Volume"><a href="#数据卷Volume" class="headerlink" title="数据卷Volume"></a>数据卷Volume</h2><ul>
<li>Docker的数据卷Volume能够让容器从宿主机中读取文件或持久化数据到宿主机内，让容器与容器产生的数据分离开来。</li>
<li>可以简单的把Volume理解为Linux服务器上的挂载点，一个容器可以挂载多个不同的目录</li>
<li>Volume的生命周期是独立于容器的声明周期之外的，即使容器删除，Volume也会保留下来，Docker也不会因为这个Volume没有被容器使用而回收。在容器中，添加或修改这个文件夹中的文件也不会影响容器的联合文件系统。</li>
<li>Volume数据卷不是用分层文件系统，这对经常读取和写入的数据很有用。在开发过程中，可以将代码目录挂载到容器中，这样如果更改代码容器会实时地得到文件修改的返回文件。</li>
</ul>
<h2 id="Docker数据管理-数据库容器化并持久化：数据卷概念，创建数据卷的两种方式，docker-volume用法"><a href="#Docker数据管理-数据库容器化并持久化：数据卷概念，创建数据卷的两种方式，docker-volume用法" class="headerlink" title="Docker数据管理-数据库容器化并持久化：数据卷概念，创建数据卷的两种方式，docker volume用法"></a>Docker数据管理-数据库容器化并持久化：数据卷概念，创建数据卷的两种方式，docker volume用法</h2><h2 id="Docker数据管理"><a href="#Docker数据管理" class="headerlink" title="Docker数据管理"></a>Docker数据管理</h2><ul>
<li>在生产环境中使用Docker的过程，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作</li>
<li>所谓Docker的数据持久化，即：数据不随着容器的结束而结束。在Docker中，要想实现数据的持久化，需要将数据从宿主机挂载到容器中</li>
<li>容器中管理数据主要有两种方式：<ul>
<li>数据卷(Data Volumes)：容器内数据直接映射到本地主机环境</li>
<li>数据卷容器(Data Volume Containers)：使用特定容器维护数据卷</li>
</ul>
</li>
</ul>
<h2 id="Docker核心概念：镜像，容器，仓库，架构核心设计理念"><a href="#Docker核心概念：镜像，容器，仓库，架构核心设计理念" class="headerlink" title="Docker核心概念：镜像，容器，仓库，架构核心设计理念"></a>Docker核心概念：镜像，容器，仓库，架构核心设计理念</h2><h2 id="Docker核心概念"><a href="#Docker核心概念" class="headerlink" title="Docker核心概念"></a>Docker核心概念</h2><ul>
<li><p><strong>镜像</strong>，通俗地讲，<strong>它是一个只读的文件和文件夹组合</strong>。</p>
</li>
<li><p>它包含了容器运行时所需要的所有基础文件和配置信息，是容器启动的基础。所以想启动一个容器，那首先必须要有一个镜像。镜像是Docker容器启动的先决条件</p>
</li>
<li><p>如果想要使用一个镜像，一般有两种方式：</p>
<ul>
<li>自己创建镜像。通常情况下，一个镜像是基于一个基础镜像构建的，可以在基础镜像上添加一些用户自定义的内容。形成业务镜像。</li>
<li>从功能镜像仓库拉取别人制作好的镜像</li>
</ul>
</li>
<li><p><strong>容器</strong>，是Docker的另一个核心概念。</p>
</li>
<li><p>通俗地讲，容器是镜像的运行实体。镜像是静态的只读文件，而容器带有运行时需要的可写文件层，并且容器中的进程属于运行状态。即容器运行着真正的应用进程</p>
</li>
<li><p>虽然容器的本质上是主机上运行的一个进程，但是容器有自己独立的命名空间隔离和资源限制。也就是说，<strong>在容器内部，无法看到主机上的进程，环境变量，网络等信息，这是容器于直接运行在主机上进程的本质区别。</strong></p>
</li>
<li><p><strong>仓库</strong>，Docker的镜像仓库类似于代码仓库，用来存储和分发Docker镜像。</p>
</li>
<li><p>镜像仓库分为公有镜像仓库和私有镜像仓库</p>
</li>
</ul>
<h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><ul>
<li><p><strong>相关背景知识</strong>—-容器的发展史</p>
<ul>
<li>容器技术随着Docker的出现变得炙手可热，所有公司都在积极拥抱容器技术。此时市场上除了有Docker容器，还有很多其他的容器技术，例如：CoresOS的rkt， lxc等。容器技术百花齐放是好事，但是也出现了很多问题，比如容器技术的标准到底是什么？</li>
<li>可能会说，Docker已经成为了事实标准，把Docker作为容器技术的标准不可以吗？事实并没有想象的那么简单。因为那个时候不仅有容器标准之争，编排技术之争也十分激烈。当时的编排技术有三大主力，分别是：<code>Docker Swarm, Kubernetes, Mesos</code>。在这样的背景下，为了形成统一的标准，<strong>OCI应运而生</strong>。</li>
<li>OCI全称为开放容器标准(<code>Open Container Initiative</code>)，它是一个轻量级，开放的治理结构。OCI组织在Linux基金会的大力支持下，于2015年6月分正式注册成立。基金会旨在为用户围绕工业化容器的格式和镜像运行时，制定一个开放的容器标准。目前主要有两个标准文档：**容器运行时标准(<code>runtime spec</code>)和容器镜像标准(<code>image spec</code>)</li>
<li>正是由于容器的战争，才导致Docker不得不改变了一些技术架构。最终，Docker整体架构采用C&#x2F;S（客户端&#x2F;服务器）模式，主要由客户端和服务端两大部分组成。客户端负责发送操作指令，服务端负责接受和处理指令。客户端和服务端通信有多种方式，既可以在通一台机器上通过UNIX套接字通信，也可以通过网络连接远程通信。</li>
</ul>
</li>
<li><p><strong>Docker客户端</strong></p>
<ul>
<li>Docker客户端其实是一种泛称。其中docker命令是Docker用户与Docker服务端交互的主要方式。</li>
<li>除了使用docker命令的方式，还可以使用直接请求REST API的方式与Docker服务端交互，甚至还可以使用各种语言的SDK与Docker服务端交互</li>
</ul>
</li>
<li><p><strong>Docker服务端</strong></p>
<ul>
<li>Docker服务端是Docker所有后台服务的统称。</li>
<li>其中<code>dockerd</code>是一个非常重要的后台管理进程，它负责相应和处理来自Docker客户端的请求，然后将客户端的请求转换为Docker的具体操作。例如镜像，容器，网络和挂载卷等具体对象的管理和操作。</li>
<li>Docker从诞生到现在，服务端经历了多次架构重构。起初，服务端的组件是全部集成在docker二进制里，但是从1.11版本开始，<code>dockerd</code>已经成了独立的二进制，此时的容器也不是直接由<code>dockerd</code>来启动了，而是继承了<code>containerd, runC</code>等多个组件</li>
<li>虽然Docker的架构在不停重构，但是各个模块的基本功能和定位并没有变化。它和一般的C&#x2F;S架构系统一样，Docker服务端模块负责和Docker客户端交互，并管理Docker的容器，镜像，网络等资源。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Docker重要组件</strong><ul>
<li>Docker目前已经有了非常多的组件和工具。Docker的两个至关重要的组件：**<code>runC</code>和<code>containerd</code>**<ul>
<li><code>runC</code>是Docker官方按照OCI容器运行时标准的一个实现。通俗地讲，**<code>runC</code>是一个用来运行容器的轻量级工具，是真正用来运行容器的。**</li>
<li><code>containerd</code>是Docker服务端的一个核心组件，它是从<code>dockerd</code>中剥离出来的，它的诞生完全遵循OCI标准，是容器标准化后的产物。**<code>containerd</code>通过<code>containerd-shim</code>启动并管理<code>runC</code>，可以说<code>containerd</code>真正管理了容器的生命周期**。</li>
</ul>
</li>
<li><code>dockerd</code>通过<code>gRPC</code>与<code>containerd</code>通信，由于<code>dockerd</code>与真正的容器运行时，<code>runC</code>中间有了<code>containerd</code>这一OCI标准层，使的<code>dockerd</code>可以确保接口向下兼容<ul>
<li><code>gRPC</code>是一种远程服务调用</li>
</ul>
</li>
<li><code>containerd-shim</code>的意思是垫片，类似于拧螺丝时夹在螺丝和螺母之间的垫片。<code>containerd-shim</code>的主要作用是：**将<code>containerd</code>和真正的容器进程解耦，使用<code>containerd-shim</code>作为容器进程的父进程，从而实现重启<code>dockerd</code>不影响已经启动的容器进程</li>
<li>事实上，<code>dockerd</code>启动的时候，<code>containerd</code>就随之启动了，<code>dockerd</code>与<code>containerd</code>一直存在。当执行<code>docker run</code>命令时，<code>containerd</code>会创建<code>containerd-shim</code>充当”垫片”进程，然后启动容器的真正进程。（**<code>containerd-shim</code>是真正容器的进程的父进程，这么做为了不让真正的容器进程作为<code>containerd</code>的子进程，从而可以实现重启<code>containerd</code>而不影响已经运行的容器**）</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Debugger/2024-05-22-gdb_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Debugger/2024-05-22-gdb_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">gdb_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Debugger/" itemprop="url" rel="index"><span itemprop="name">Debugger</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>gdb工具的理论知识</li>
</ul>
<h2 id="gdb-常用命令"><a href="#gdb-常用命令" class="headerlink" title="gdb 常用命令"></a>gdb 常用命令</h2><p>GDB（GNU Debugger）是一个功能强大的调试工具，提供了许多命令来帮助程序员进行调试。以下是GDB的全部命令及其详细解释：</p>
<p><strong>常用命令</strong>：</p>
<ol>
<li><strong>run</strong>：运行程序。例如：<code>run arg1 arg2</code>。</li>
<li><strong>break</strong>：设置断点。<ul>
<li><code>break &lt;function&gt;</code>：在指定函数的入口处设置断点。</li>
<li><code>break &lt;line&gt;</code>：在指定行号处设置断点。</li>
<li><code>break &lt;file:line&gt;</code>：在指定文件的指定行号处设置断点。</li>
<li><code>break &lt;address&gt;</code>：在指定地址处设置断点。</li>
</ul>
</li>
<li><strong>continue</strong>：继续执行程序，直到下一个断点或程序结束。</li>
<li><strong>next</strong>：执行下一行代码，但是不会进入函数内部。</li>
<li><strong>step</strong>：执行下一行代码，并进入函数内部。</li>
<li><strong>print</strong>（或者简写为<strong>p</strong>）：打印变量的值。<ul>
<li><code>print &lt;variable&gt;</code>：打印指定变量的值。</li>
<li><code>print &lt;expression&gt;</code>：计算并打印指定表达式的值。</li>
</ul>
</li>
<li><strong>backtrace</strong>（或者简写为<strong>bt</strong>）：显示当前的函数调用堆栈。</li>
<li><strong>info locals</strong>：显示当前函数的局部变量。</li>
<li><strong>info breakpoints</strong>：显示当前设置的所有断点。</li>
<li><strong>delete</strong>：删除指定的断点。</li>
</ol>
<ul>
<li><code>delete &lt;breakpoint&gt;</code>：删除指定编号的断点。</li>
<li><code>delete breakpoints</code>：删除所有断点。</li>
</ul>
<ol start="11">
<li><strong>watch</strong>：设置观察点。</li>
</ol>
<ul>
<li><code>watch &lt;expression&gt;</code>：当指定表达式的值发生变化时中断程序。</li>
</ul>
<ol start="12">
<li><strong>finish</strong>：执行完当前函数并停止。</li>
<li><strong>quit</strong>：退出GDB。</li>
</ol>
<p><strong>其他常用命令</strong>：</p>
<ol>
<li><strong>list</strong>：显示源代码。<ul>
<li><code>list</code>：显示当前位置附近的源代码。</li>
<li><code>list &lt;function&gt;</code>：显示指定函数的源代码。</li>
<li><code>list &lt;line&gt;</code>：显示指定行号附近的源代码。</li>
</ul>
</li>
<li><strong>info registers</strong>：显示寄存器的值。</li>
<li><strong>set</strong>：设置变量的值。<ul>
<li><code>set &lt;variable&gt;=&lt;value&gt;</code>：将指定变量的值设置为指定值。</li>
</ul>
</li>
<li><strong>display</strong>：持续显示表达式的值。<ul>
<li><code>display &lt;expression&gt;</code>：每次停止时显示指定表达式的值。</li>
</ul>
</li>
<li><strong>x</strong>：显示内存内容。<ul>
<li><code>x/&lt;count&gt;&lt;format&gt; &lt;address&gt;</code>：以指定格式显示指定地址开始的内存内容。</li>
</ul>
</li>
<li><strong>info threads</strong>：显示当前线程信息。</li>
<li>**thread <thread-id>**：切换到指定线程。</li>
<li><strong>set args</strong>：设置运行程序时的命令行参数。</li>
<li><strong>set environment</strong>：设置运行程序时的环境变量。</li>
<li><strong>directory</strong>：指定源代码文件的搜索路径。</li>
<li>**run <args>**：运行程序并传递命令行参数。</li>
</ol>
<p>以上只是GDB命令的一小部分，GDB还有更多的命令和选项可供使用。你可以在GDB的命令行界面中输入<code>help</code>命令来查看完整的命令列表和使用说明。</p>
<hr>
<h2 id="gdb-是什么"><a href="#gdb-是什么" class="headerlink" title="gdb 是什么"></a>gdb 是什么</h2><p>GDB（GNU Debugger）是一个功能强大的调试工具，用于在Linux和其他操作系统上调试程序。它提供了许多功能和命令，用于追踪程序的执行、查看变量的值、检测内存错误等。下面是对GDB的一些详解：</p>
<ol>
<li><p>启动程序：使用<code>gdb</code>命令后跟要调试的可执行文件的路径来启动GDB。例如：<code>gdb ./my_program</code></p>
</li>
<li><p>设置断点：使用<code>break</code>或<code>b</code>命令在代码中设置断点。可以使用行号、函数名或文件名来指定断点的位置。例如：<code>b main</code>、<code>b file.cpp:10</code>。</p>
</li>
<li><p>运行程序：使用<code>run</code>或<code>r</code>命令来运行程序。可以带上命令行参数。例如：<code>r arg1 arg2</code>。</p>
</li>
<li><p>单步执行：使用<code>next</code>或<code>n</code>命令进行逐行单步执行。可以逐过程地执行函数体内部的语句。</p>
</li>
<li><p>进入函数：使用<code>step</code>或<code>s</code>命令进入函数内部并逐语句单步执行。</p>
</li>
<li><p>继续执行：使用<code>continue</code>或<code>c</code>命令继续程序的执行直到下一个断点或程序结束。</p>
</li>
<li><p>打印变量值：使用<code>print</code>或<code>p</code>命令打印变量的值。可以打印局部变量、全局变量、表达式等。例如：<code>p my_var</code>。</p>
</li>
<li><p>查看堆栈：使用<code>backtrace</code>或<code>bt</code>命令查看函数调用的堆栈信息，显示调用链。</p>
</li>
<li><p>查看源代码：使用<code>list</code>或<code>l</code>命令查看源代码，显示当前位置附近的代码片段。</p>
</li>
<li><p>修改变量值：使用<code>set</code>命令修改变量的值。例如：<code>set my_var = 42</code>。</p>
</li>
<li><p>监视变量：使用<code>watch</code>命令设置监视点，当变量的值发生变化时，程序会停在相应的位置。</p>
</li>
<li><p>内存调试：使用GDB的内存调试功能，可以检测和分析内存错误、内存泄漏等问题。</p>
</li>
<li><p>调试核心转储文件：使用<code>core</code>命令调试核心转储文件，用于分析程序崩溃或异常终止的情况。</p>
</li>
<li><p>断点条件和命令：可以在设置断点时指定条件和命令，以控制程序的执行流程。</p>
</li>
<li><p>定义自定义命令：可以使用GDB的Python扩展或GDB脚本语言来定义自定义命令，以实现更复杂的调试操作。</p>
</li>
<li><p>调试多线程程序：GDB支持调试多线程程序，可以追踪和控制每个线程的执行。</p>
</li>
</ol>
<p>这只是GDB的一小部分功能和命令，GDB还有很多</p>
<p>其他强大的功能，如条件断点、反汇编、寄存器查看等。你可以查阅GDB的官方文档或其他资源，深入了解和掌握更多关于GDB的知识和技巧。调试是开发过程中的重要环节，GDB可以帮助你更好地理解程序的执行过程，定位和解决问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Git/2024-05-22-git_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Git/2024-05-22-git_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">git_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Git的理论基础知识</li>
</ul>
<h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><ol>
<li>克隆Git资源作为工作目录</li>
<li>在克隆的资源上添加或者修改文件</li>
<li>如果其他人修改了,你可以更新资源</li>
<li>在提交前查看修改</li>
<li>提交修改</li>
<li>在修改完成后,如果发现错误,可以撤回提交并再次修改并提交</li>
</ol>
<h2 id="基本概念-工作区-暂存区和版本库"><a href="#基本概念-工作区-暂存区和版本库" class="headerlink" title="基本概念:工作区,暂存区和版本库"></a>基本概念:工作区,暂存区和版本库</h2><ul>
<li>工作区:就是在电脑里能够看到的目录</li>
<li>暂存区:英文叫stage或index,一般放在.git目录下的index文件中,所以把暂存区有时也叫做索引(index)</li>
<li>版本库:工作区有一个隐藏目录.git,这个不算工作区,而是git的版本库</li>
</ul>
<ol>
<li>当对工作区修改(或新增)的文件执行 <code>git add</code> 命令时,暂存区的目录树被更新,同时工作区修改(或新增)的文件内容被写入到对象库中的一个新的对象中,而该对象的ID被记录在暂存区的文件索引中</li>
<li>当执行提交操作时 <code>git commit</code> 时,暂存区的目录树写到版本库(对象库)中,master分支会做相应的更新,即<strong>master只想的目录树就是提交时暂存区的目录树.</strong></li>
</ol>
<h2 id="Git官方手册"><a href="#Git官方手册" class="headerlink" title="Git官方手册"></a>Git官方手册</h2><h3 id="Git的三种状态-已提交-committed-已修改-modified-和已暂存-staged"><a href="#Git的三种状态-已提交-committed-已修改-modified-和已暂存-staged" class="headerlink" title="Git的三种状态:已提交(committed), 已修改(modified)和已暂存(staged)"></a>Git的三种状态:已提交(committed), 已修改(modified)和已暂存(staged)</h3><ul>
<li>已修改:表示修改了文件,但还没有保存到数据库中</li>
<li>已暂存:表示对一个已修改文件的当前版本做了标记,使之包含在下次提交的快照中</li>
<li>已提交:表示数据已经安全地保存在本地数据库中</li>
</ul>
<h3 id="这会让Git项目拥有三个三阶段-工作区-暂存区和Git目录"><a href="#这会让Git项目拥有三个三阶段-工作区-暂存区和Git目录" class="headerlink" title="这会让Git项目拥有三个三阶段:工作区, 暂存区和Git目录"></a>这会让Git项目拥有三个三阶段:工作区, 暂存区和Git目录</h3><ul>
<li>工作区:是对项目的某个版本独立提取出来的内容,这些从Git仓库的压缩数据中提取出来的文件,放在磁盘上进行使用或修改</li>
<li>暂存区:是一个文件,保存了下次将要提交的文件列表信息,一般在Git仓库目录中.按照Git的术语叫做”索引”,不过一般说法还是叫”暂存区”</li>
<li>Git仓库目录:是Git用来保存项目的元数据和对象数据库的地方.这是Git中最重要的部分,<strong>从其他计算机克隆仓库时,复制的就是这里的数据.</strong></li>
</ul>
<h3 id="基本的Git工作流程"><a href="#基本的Git工作流程" class="headerlink" title="基本的Git工作流程"></a>基本的Git工作流程</h3><ol>
<li>在工作区中修改文件</li>
<li>将想要下次提交的更改 选择性地暂存,这样只会将更改的部分添加到暂存区</li>
<li>提交更新,找到暂存区的文件,将快照永久性存储到Git目录</li>
</ol>
<h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a><code>.gitignore</code> 文件</h2><ul>
<li>In the project, it does not need to save all of the files. And the <code>.gitignore</code> file is used to save the folders which do not need to save.</li>
<li>在工程中，并不是所有文件都需要保存到版本库中。在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，把要忽略的文件名填进去，Git就会自动忽略这些文件或目录</li>
<li>匹配规则<ul>
<li>空格不匹配任意文件，可作为分隔符，可用反斜杠转义</li>
<li>开头的文件标识注释，可以使用反斜杠进行转义</li>
<li><code>/</code> 结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件</li>
<li><code>/</code> 开始的模式匹配项目和目录</li>
<li><code>?</code> 通用匹配单个字符</li>
<li><code>*</code> 通用匹配零个或多个字符</li>
<li><code>[]</code> 通用匹配单个字符列表</li>
</ul>
</li>
</ul>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><ol>
<li>working directory:持有实际文件</li>
<li>Index:类似于一个缓冲区与,临时保存文件的改动</li>
<li>HEAD:指向最后一次提交的结果</li>
</ol>
<h2 id="添加与提交"><a href="#添加与提交" class="headerlink" title="添加与提交"></a>添加与提交</h2><ol>
<li>把文件添加到暂存区: <code>git add &lt;filename&gt;</code></li>
<li>提交改动信息: <code>git commit -m &quot;代码提交信息&quot;</code>. (至此,改动已经提交到了HEAD,但是还没有到远端仓库)</li>
<li>推送改动: <code>git push origin master(master 换成想要推送的分支)</code></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Docker/2024-05-22-docker_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Docker/2024-05-22-docker_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">docker_3_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>docker常用技巧</li>
</ul>
<h2 id="docker-启动容器并分离到后台"><a href="#docker-启动容器并分离到后台" class="headerlink" title="docker 启动容器并分离到后台"></a>docker 启动容器并分离到后台</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -<span class="built_in">id</span> -p 4000:4000 jekyll/ubuntu:v1 /bin/bash</span></span><br></pre></td></tr></table></figure>

<h2 id="docker-镜像存储位置"><a href="#docker-镜像存储位置" class="headerlink" title="docker 镜像存储位置"></a>docker 镜像存储位置</h2><ul>
<li><p>Docker 镜像存储位置取决于你在安装 Docker 时所选择的存储驱动程序。Docker 默认使用“overlay2”存储驱动程序，它会将镜像存储在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2 目录下。但是，如果你使用的是其他存储驱动程序，那么镜像存储位置可能会有所不同。</p>
</li>
<li><p>你可以通过以下命令查看 Docker 镜像存储位置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info | grep -i <span class="string">&#x27;docker root dir&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在输出结果中，你将看到存储路径的具体位置。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker Root Dir: /var/lib/docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你想将 Docker 镜像存储到不同的位置，可以通过以下步骤进行设置：</p>
</li>
<li><p>停止 Docker 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop docker</span><br></pre></td></tr></table></figure></li>
<li><p>移动 &#x2F;var&#x2F;lib&#x2F;docker 目录到新的位置，例如 &#x2F;new&#x2F;docker&#x2F;path：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /var/lib/docker /new/docker/path</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个指向新目录的符号链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /new/docker/path /var/lib/docker</span><br></pre></td></tr></table></figure></li>
<li><p>启动 Docker 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li><p>现在，Docker 镜像将被存储在新的位置 &#x2F;new&#x2F;docker&#x2F;path 中。请注意，这种更改可能会导致现有的 Docker 容器无法正常运行，因此请谨慎操作。</p>
</li>
</ul>
<h2 id="网络模式设置"><a href="#网络模式设置" class="headerlink" title="网络模式设置"></a>网络模式设置</h2><p>在 Docker 中，<code>-net=host</code> 是一种网络模式选项，用于指定容器的网络命名空间。当你使用该选项时，容器将与宿主机共享网络命名空间，这意味着容器将使用宿主机的网络栈，与宿主机具有相同的网络接口和IP地址。</p>
<p>具体来说，使用<code>-net=host</code>选项，容器内的网络配置与宿主机完全一致，容器可以直接访问宿主机上的网络接口和端口。这样的配置有一些优势和限制：</p>
<p>优势：</p>
<ol>
<li>简化网络配置：使用该选项，不需要再单独设置容器的网络配置，容器直接继承宿主机的网络配置。</li>
<li>容器与宿主机共享IP地址：可以让容器直接使用宿主机的IP地址，方便某些网络应用场景。</li>
</ol>
<p>限制：</p>
<ol>
<li>安全性：容器与宿主机共享网络命名空间，容器内的进程可以直接访问宿主机的网络，这可能会增加潜在的安全风险，因此需要格外小心。</li>
<li>端口冲突：由于容器与宿主机共享网络，如果宿主机上已经在使用的端口被容器尝试使用，可能会导致端口冲突。</li>
<li>主机网络的限制：由于容器使用宿主机网络栈，容器将受到宿主机网络设置和限制的影响。</li>
</ol>
<p>在大多数情况下，推荐使用默认的网络模式，Docker会为容器分配独立的网络命名空间，从而保持隔离和安全性。只有在特定的使用场景下，才应该考虑使用<code>-net=host</code>选项。</p>
<p>请注意，Docker在不同版本中可能会有一些变化，因此建议查阅最新的Docker文档以获得最准确的信息。</p>
<h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2><ul>
<li>使用命令：<code>tar cvf image.tar --exclude=/proc --exclude=/image.tar /</code>， 在容器里打包系统所需要的文件，<ul>
<li>记录以下：<code>tar cvf image.tar --exclude=/system --exclude=/sys --exclude=/proc --exclude=/image.tar /</code></li>
</ul>
</li>
<li><code>sudo docker cp containerID:/image.tar ./</code> , 将容器中打包的文件拷贝到主机中</li>
<li><code>cat image.tar | sudo docker import - image:v1</code>, 导入镜像</li>
</ul>
<h2 id="linux下重启-启动-关闭docker服务"><a href="#linux下重启-启动-关闭docker服务" class="headerlink" title="linux下重启,启动,关闭docker服务"></a>linux下重启,启动,关闭docker服务</h2><ul>
<li><code>sudo systemctl start docker</code> : 启动</li>
<li><code>sudo systemctl daemon-reload</code>: 守护进程重启</li>
<li><code>sudo systemctl restart docker</code> or <code>sudo service docker restart</code> : 重启docker服务</li>
<li><code>sudo service docker stop</code> or <code>sudo systemctl stop docker</code> : 关闭docker</li>
</ul>
<h2 id="以非root用户身份管理"><a href="#以非root用户身份管理" class="headerlink" title="以非root用户身份管理"></a>以非root用户身份管理</h2><ul>
<li>Docker守护程序绑定到Unix套接字而不是TCP端口，默认情况下，Unix套接字的用户有root，其它用户只能使用sudo来访问。 Docker守护程序始终以root用户身份运行</li>
<li>不想使用sudo，创建docker的Unix组，将用户添加到改组<ul>
<li><code>sudo groupadd docker</code></li>
<li><code>sudo usermod -aG docker $USER</code></li>
<li><code>newgrp docker</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="镜像的上传和拉取"><a href="#镜像的上传和拉取" class="headerlink" title="镜像的上传和拉取"></a>镜像的上传和拉取</h2><ul>
<li><p>登录docker </p>
<ul>
<li><code>docker login</code></li>
</ul>
</li>
<li><p>修改镜像命名</p>
<ul>
<li>修改镜像的repository，使之与Docker Hub账号匹配</li>
<li>Docker Hub为了区分不同用户的同名镜像，镜像的<code>registry</code>中要包含用户名，完整的格式为:<code>[username]/xxx:tag</code></li>
<li>Docker官方自己维护的镜像没有用户名</li>
</ul>
</li>
<li><p>镜像上传</p>
<ul>
<li>通过<code>docker push</code>将镜像上传到<code>Docker Hub</code></li>
</ul>
</li>
<li><p>镜像的拉取</p>
<ul>
<li>上传的是公共镜像仓库，任何人都可以下载使用</li>
</ul>
</li>
</ul>
<h2 id="根据这些md5目录名检查是哪个容器"><a href="#根据这些md5目录名检查是哪个容器" class="headerlink" title="根据这些md5目录名检查是哪个容器"></a>根据这些md5目录名检查是哪个容器</h2><ul>
<li><code>docker inspect xxx | grep merge</code></li>
</ul>
<h2 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h2><ul>
<li><code>docker logs &lt;container-id&gt;</code>，查看日志</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">user@computer:test-docker$ docker logs 172</span><br><span class="line">root@1722c360945f:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  src  srv  sys  tmp  usr  var</span><br><span class="line">root@1722c360945f:/# cd src</span><br><span class="line">root@1722c360945f:/src# ks</span><br><span class="line">bash: ks: command not found</span><br><span class="line">root@1722c360945f:/src# ls</span><br><span class="line">one.txt</span><br><span class="line">root@1722c360945f:/src# ls</span><br><span class="line">one.txt  two.txt</span><br><span class="line">root@1722c360945f:/src# cat two.txt</span><br><span class="line">root@1722c360945f:/src# ls</span><br><span class="line">two.txt</span><br><span class="line">root@1722c360945f:/src# ls</span><br><span class="line">two.txt</span><br><span class="line">root@1722c360945f:/src# pwd</span><br><span class="line">/src</span><br><span class="line">user@computer:test-docker$ </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><ul>
<li><code>docker run -it --mount type=bind,src=&quot;$(pwd)&quot;，target=/src ubuntu:18.04 bash</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Git/2024-05-22-git_2_%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Git/2024-05-22-git_2_%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">git_2_语法基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Git常见的语法知识</li>
</ul>
<h2 id="git-bundle-命令-详解"><a href="#git-bundle-命令-详解" class="headerlink" title="git bundle 命令 详解"></a>git bundle 命令 详解</h2><p><code>git bundle</code> 命令用于将 Git 仓库的所有对象（commit、tree、blob等）打包成一个二进制文件，这个文件可以在不连接到中央仓库的情况下传递给其他人，并且可以克隆该仓库。这在离线环境或网络较差的情况下非常有用。</p>
<p>以下是 <code>git bundle</code> 命令的基本语法和一些常见用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个包含所有分支的 bundle 文件</span></span><br><span class="line">git bundle create repo.bundle --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含指定分支的 bundle 文件</span></span><br><span class="line">git bundle create repo.bundle branch1 branch2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个指定范围的 bundle 文件（从某个 commit 到另一个 commit）</span></span><br><span class="line">git bundle create repo.bundle &lt;start-commit&gt;..&lt;end-commit&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 bundle 文件中提取对象到本地仓库</span></span><br><span class="line">git <span class="built_in">clone</span> repo.bundle new-repo</span><br></pre></td></tr></table></figure>

<p>这里是一些命令的详细解释：</p>
<ul>
<li><code>git bundle create</code>: 创建一个 bundle 文件。后面的参数是要包含的分支或 commit 的范围。</li>
<li><code>repo.bundle</code>: bundle 文件的名称。你可以自定义文件名。</li>
<li><code>--all</code>: 包含所有分支。</li>
<li><code>branch1 branch2</code>: 包含指定的分支。</li>
<li><code>&lt;start-commit&gt;..&lt;end-commit&gt;</code>: 包含指定范围内的 commit。</li>
</ul>
<p>一旦你创建了 bundle 文件，你可以将它传递给其他人，他们可以通过克隆该 bundle 文件来获取整个仓库的历史。例如，他们可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repo.bundle new-repo</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>git bundle</code> 不包含远程仓库的引用，因此在使用 bundle 文件进行克隆时，你将得到一个没有远程跟踪分支的本地仓库。如果需要获取远程跟踪分支，可以使用 <code>git fetch</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> new-repo</span><br><span class="line">git fetch origin refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure>

<p>这样，你就可以在新的本地仓库中获取与远程仓库相同的分支。</p>
<h2 id="git-config-详解"><a href="#git-config-详解" class="headerlink" title="git config 详解"></a>git config 详解</h2><p><code>git config</code> 是 Git 版本控制系统中用于配置和管理 Git 仓库的命令。通过 <code>git config</code> 命令，你可以设置和获取 Git 仓库的各种配置选项，包括全局配置和仓库级配置。</p>
<p><code>git config</code> 命令有三个不同的级别：全局、仓库和本地。这些级别决定了配置选项的作用范围。</p>
<p>以下是 <code>git config</code> 命令的一些常用选项和使用方法：</p>
<ol>
<li><p><strong>获取配置值</strong>：使用 <code>git config &lt;key&gt;</code> 命令获取特定配置选项的值。例如，要获取用户的姓名配置，可以使用 <code>git config user.name</code>。</p>
</li>
<li><p><strong>设置配置值</strong>：使用 <code>git config &lt;key&gt; &lt;value&gt;</code> 命令设置特定配置选项的值。例如，要设置用户的姓名配置，可以使用 <code>git config user.name &quot;Your Name&quot;</code>。</p>
</li>
<li><p><strong>全局配置</strong>：使用 <code>git config --global</code> 命令来设置全局配置选项。全局配置选项将应用于当前用户的所有 Git 仓库。例如，使用 <code>git config --global user.name &quot;Your Name&quot;</code> 来设置全局用户姓名。</p>
</li>
<li><p><strong>仓库配置</strong>：在 Git 仓库的根目录下，使用 <code>git config</code> 命令来设置仓库配置选项。这些配置选项将仅应用于当前仓库。例如，使用 <code>git config user.email &quot;your@example.com&quot;</code> 来设置仓库的用户邮箱。</p>
</li>
<li><p><strong>本地配置</strong>：对于某个特定的 Git 命令，你可以通过在命令后添加 <code>--local</code> 参数，将配置选项设置为本地级别。例如，使用 <code>git config --local core.ignorecase true</code> 来设置当前仓库的忽略文件大小写的配置。</p>
</li>
<li><p><strong>列出配置</strong>：使用 <code>git config --list</code> 命令列出当前仓库的所有配置选项及其对应的值。添加 <code>--global</code> 参数可以列出全局配置选项。</p>
</li>
<li><p><strong>编辑配置文件</strong>：使用 <code>git config --edit</code> 命令打开 Git 配置文件进行手动编辑。对于全局配置，会打开用户主目录下的 <code>.gitconfig</code> 文件，对于仓库配置，会打开仓库目录下的 <code>.git/config</code> 文件。</p>
</li>
</ol>
<p>这些是 <code>git config</code> 命令的一些常见用法和选项。通过适当配置 Git，你可以定制化和优化你的版本控制工作流程。</p>
<hr>
<h2 id="git-config-常用选项"><a href="#git-config-常用选项" class="headerlink" title="git config 常用选项"></a>git config 常用选项</h2><p>下面是一些常用的 <code>git config</code> 命令选项：</p>
<ol>
<li><p><strong>用户信息</strong>：</p>
<ul>
<li><code>user.name</code>：设置用户的姓名。</li>
<li><code>user.email</code>：设置用户的电子邮件地址。</li>
<li>例如：<code>git config --global user.name &quot;Your Name&quot;</code></li>
</ul>
</li>
<li><p><strong>文本编辑器</strong>：</p>
<ul>
<li><code>core.editor</code>：设置用于 Git 提交消息的文本编辑器。</li>
<li>例如：<code>git config --global core.editor &quot;vim&quot;</code></li>
</ul>
</li>
<li><p><strong>自动换行</strong>：</p>
<ul>
<li><code>core.autocrlf</code>：控制换行符的处理方式。<ul>
<li><code>true</code>：在提交时自动将换行符转换为 CRLF，检出时转换为 LF（适用于 Windows 系统）。</li>
<li><code>input</code>：在提交时将换行符转换为 LF，检出时不做转换（适用于 macOS 和 Linux 系统）。</li>
<li><code>false</code>：保持换行符不变。</li>
</ul>
</li>
<li>例如：<code>git config --global core.autocrlf true</code></li>
</ul>
</li>
<li><p><strong>忽略文件</strong>：</p>
<ul>
<li><code>core.excludesfile</code>：指定一个全局的忽略文件，用于列出不应受版本控制的文件和目录。</li>
<li>例如：<code>git config --global core.excludesfile ~/.gitignore_global</code></li>
</ul>
</li>
<li><p><strong>分支合并策略</strong>：</p>
<ul>
<li><code>merge.tool</code>：设置用于解决合并冲突的工具。</li>
<li>例如：<code>git config --global merge.tool kdiff3</code></li>
</ul>
</li>
<li><p><strong>查看提交历史</strong>：</p>
<ul>
<li><code>alias.log</code>：设置自定义的 <code>git log</code> 命令别名。</li>
<li>例如：<code>git config --global alias.log &quot;log --oneline --decorate&quot;</code></li>
</ul>
</li>
<li><p><strong>远程仓库</strong>：</p>
<ul>
<li><code>remote.origin.url</code>：设置远程仓库的 URL。</li>
<li><code>branch.&lt;branchname&gt;.remote</code>：设置分支与远程仓库的关联。</li>
<li>例如：<code>git config remote.origin.url &quot;https://github.com/username/repo.git&quot;</code></li>
</ul>
</li>
</ol>
<p>这些是一些常用的 <code>git config</code> 命令选项，你可以根据自己的需求进行配置。使用 <code>--global</code> 参数将选项设置为全局级别，省略该参数则为当前仓库级别的配置。</p>
<h2 id="git-tag-标签的使用"><a href="#git-tag-标签的使用" class="headerlink" title="git tag 标签的使用"></a>git tag 标签的使用</h2><h2 id="标签-tag-相关的常用命令"><a href="#标签-tag-相关的常用命令" class="headerlink" title="标签(tag)相关的常用命令"></a>标签(tag)相关的常用命令</h2><ul>
<li><code>git tag</code> 查看标签</li>
<li><code>git tag &lt;tag-name&gt;</code> 创建命名标签</li>
<li><code>git tag -a &lt;tag-name&gt; -m &lt;message&gt;</code> 添加一个注解标签</li>
<li><code>git tag &lt;tag-name&gt; &lt;commit-id&gt; -a -m &lt;message&gt;</code> 给过去提交记录创建标签</li>
<li><code>git push origin &lt;tag-name&gt;</code> 推送标签到远程仓库</li>
<li><code>git push origin --tags</code> 推送全部标签</li>
<li><code>git pull origin --tags</code> 远程拉取标签</li>
<li><code>git tag -d &lt;tag-name&gt;</code> 删除本地标签</li>
<li><code>git push origin :refs/tags/&lt;tag-name&gt;</code> 删除远程标签</li>
</ul>
<h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><ul>
<li><code>git remote</code>：用于管理远程仓库</li>
<li><code>git remote</code>：不带参数时可以查看远程仓库名称</li>
<li><code>git remote -v</code> : 可以查看远程仓库名称和网址</li>
<li><code>git remote add 仓库名 仓库地址</code> : 添加远程仓库，同时设置远程仓库的名字</li>
<li><code>git remote rm origin</code> : 删除名字为<code>origin</code>的远程仓库</li>
</ul>
<h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><ul>
<li><p><code>git branch</code> : 可以查看本地仓库的分支情况</p>
</li>
<li><p><code>git branch 分支名</code> : 创建分支</p>
</li>
<li><p><code>git checkout 分支名</code> : 切换到指定分支</p>
<ul>
<li>两个命令可以合成一个命令：<code>git checkout -b 分支名</code> ，相当于创建分支后切换到新建分支</li>
</ul>
</li>
<li><p><code>git branch -d 分支名</code> : 删除某个分支</p>
</li>
<li><p><code>git merge 分支名</code> : 合并某个分支到现在所处的分支</p>
</li>
<li><p><code>git branch -r</code> : 查看远程仓库的分支情况</p>
</li>
<li><p><code>git branch -a</code> : 查看所有分支的情况，即本地分支和远程分支（上面的部分是本地分支，下面红色的部分是远程的分支）</p>
</li>
<li><p>远程分支的创建不能通过<code>git branch</code>进行，而是在<code>git push</code>的时候默认执行</p>
</li>
<li><p>分支重命名：<code>git branch -m oldname newname</code></p>
</li>
</ul>
<h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><ul>
<li><p><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt; : &lt;远程分支名&gt;</code></p>
<ul>
<li>分支的推送顺序写法是：<code>&lt;来源地&gt;:&lt;目的地&gt;</code></li>
</ul>
</li>
<li><p>远程分支的删除也不能使用<code>git branch</code> , 同样采用<code>git push</code></p>
<ul>
<li><code>git push &lt;远程主机名&gt; --delete &lt;删除的分支名&gt;</code></li>
<li>或者：<code>git push &lt;远程主机名&gt; : &lt;远程分支名&gt;</code> ，省略了本地分支名相当于推送了一个空的本地分支到远程分支上，就相当于删除了远程分支</li>
</ul>
</li>
</ul>
<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><ul>
<li><code>git fetch</code>这个命令用于取回远程仓库上的更新到本地仓库，默认是取回远程仓库上的所有更新，</li>
<li>如果要取回执行分支上的内容，可以使用<code>git fetch &lt;远程仓库&gt; &lt;分支名&gt;</code>。这样取回的分支是不会影响本地仓库中的代码，通常用于查看他人进程，取回远程分支之后，可以在远程分支的基础上创建新的分支，也可以将远程分支和本地分支合并:<code>git merge origin/dev</code> or <code>git rebase origin/dev</code> ： 表示将当前分支与远程分支合并</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Docker/2024-05-22-docker_2_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Docker/2024-05-22-docker_2_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">docker_2_基础语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>docker基础语法</li>
</ul>
<h2 id="docker-inspect-详解"><a href="#docker-inspect-详解" class="headerlink" title="docker inspect 详解"></a>docker inspect 详解</h2><p><code>docker inspect</code> 命令用于查看 Docker 中的各种对象的详细信息，包括容器、镜像、网络、卷等。这个命令以 JSON 格式输出对象的配置和状态信息，可用于调试、监视和了解 Docker 对象的各个方面。下面是有关 <code>docker inspect</code> 命令的详细解释：</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] OBJECT [OBJECT...]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>OPTIONS</code>：可选，可以附加一些选项来控制输出格式和内容。</li>
<li><code>OBJECT</code>：必需，指定要检查的 Docker 对象的名称或 ID。</li>
</ul>
<p>以下是一些常见的用法和选项：</p>
<ol>
<li><p>查看容器详细信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect container_name_or_id</span><br></pre></td></tr></table></figure>

<p>这将输出指定容器的详细信息，包括容器的配置、状态、网络设置等等。</p>
</li>
<li><p>查看镜像详细信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect image_name_or_id</span><br></pre></td></tr></table></figure>

<p>这将输出指定镜像的详细信息，包括镜像的元数据、层信息等。</p>
</li>
<li><p>输出格式选项：</p>
<p>默认情况下，<code>docker inspect</code> 输出 JSON 格式的信息，但你可以使用 <code>--format</code> 选项来指定自定义输出格式。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format container_name_or_id</span><br></pre></td></tr></table></figure>

<p>这将仅输出容器的状态（运行、停止等）。</p>
</li>
<li><p>查看多个对象的信息：</p>
<p>你可以一次查看多个 Docker 对象的信息。例如，要查看多个容器的详细信息，可以列出它们的名称或 ID 并用空格分隔：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect container1 container2</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>--type</code> 选项过滤对象类型：</p>
<p>你可以使用 <code>--type</code> 选项来过滤要检查的 Docker 对象的类型。例如，要查看所有网络的详细信息，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --<span class="built_in">type</span> network</span><br></pre></td></tr></table></figure>

<p>这将列出所有网络的详细信息。</p>
</li>
<li><p>导出信息到文件：</p>
<p>如果你想将对象的详细信息保存到文件中，可以使用重定向操作符（<code>&gt;</code>）将输出重定向到文件。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect container_name_or_id &gt; container_info.json</span><br></pre></td></tr></table></figure>

<p>这将容器的详细信息保存到 <code>container_info.json</code> 文件中。</p>
</li>
</ol>
<p><code>docker inspect</code> 命令是一个非常有用的工具，可用于深入了解 Docker 对象的各个方面，从容器的配置到网络设置，以及镜像的元数据等等。通过查看这些信息，你可以更好地理解和管理你的 Docker 环境。</p>
<h2 id="docker-–network-net-详解"><a href="#docker-–network-net-详解" class="headerlink" title="docker –network(net) 详解"></a>docker –network(net) 详解</h2><p>在 Docker 中，网络是容器和其他容器或宿主机之间进行通信的基础。Docker 提供了多种网络模式和选项，可以根据不同的需求选择适当的网络配置。以下是 Docker 中一些常见的网络选项：</p>
<ol>
<li><p><code>--network</code>：这是一个全局选项，用于指定容器所属的网络。可以通过以下几种预定义的网络进行选择：</p>
<ul>
<li><p><code>bridge</code>：默认网络模式，Docker 在主机上创建一个名为 <code>bridge</code> 的虚拟网络，容器将连接到该网络，容器可以通过它与宿主机和其他容器通信。</p>
</li>
<li><p><code>host</code>：使用宿主机的网络命名空间，容器与宿主机共享网络栈，与宿主机拥有相同的网络接口和IP地址。适用于需要容器与宿主机共享网络的场景。</p>
</li>
<li><p><code>none</code>：不使用任何网络，容器将没有网络接口，只适用于特殊情况。</p>
</li>
<li><p><code>container:&lt;name|id&gt;</code>：使容器与指定名称或ID的另一个容器共享网络命名空间，从而实现容器之间的网络通信。</p>
</li>
<li><p>自定义网络：可以使用 <code>docker network create</code> 命令创建自定义网络，并将容器连接到该网络。</p>
</li>
</ul>
</li>
<li><p><code>--publish</code> 或 <code>-p</code>：这个选项用于将容器内部的端口映射到宿主机上，允许外部主机通过宿主机的IP和端口访问容器内部的服务。</p>
<p>例如：<code>docker run -p 8080:80 nginx</code> 将容器内部的80端口映射到宿主机的8080端口。</p>
</li>
<li><p><code>--expose</code>：用于将容器内部的端口暴露给与容器连接的其他容器，但不映射到宿主机。这只是一种文档工具，实际上并不会进行端口映射。</p>
</li>
<li><p><code>--link</code>：已经过时，不推荐使用。用于在容器之间创建链接，允许容器使用对方的环境变量进行通信。</p>
</li>
<li><p><code>--hostname</code>：指定容器的主机名。</p>
</li>
</ol>
<p>这些选项可以通过 <code>docker run</code> 命令进行设置，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --network=bridge -p 8080:80 --name my_container nginx</span><br></pre></td></tr></table></figure>

<p>上述命令将创建一个名为 <code>my_container</code> 的容器，连接到默认的 <code>bridge</code> 网络，并将容器内部的80端口映射到宿主机的8080端口，让外部可以通过宿主机的IP和端口访问容器内的NGINX服务。</p>
<p>请注意，Docker 的网络功能在不同版本之间可能会有一些变化，建议查阅最新的 Docker 文档以获得最准确的信息。</p>
<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><p>Docker Compose 是一个用于定义和管理多容器应用程序的工具，它使用一个单独的 YAML 文件来配置应用程序的服务、网络和卷等。</p>
<p>以下是一些常用的 Docker Compose 命令及其功能：</p>
<ol>
<li><p>启动和停止容器组：</p>
<ul>
<li>启动容器组：<code>docker-compose up</code> 或 <code>docker-compose start</code> 命令可以启动 Docker Compose 配置文件中定义的所有服务和容器。</li>
<li>停止容器组：<code>docker-compose stop</code> 命令可以停止 Docker Compose 配置文件中定义的所有服务和容器。</li>
</ul>
</li>
<li><p>构建和重建容器：</p>
<ul>
<li>构建容器：<code>docker-compose build</code> 命令可以根据 Docker Compose 配置文件中的定义，构建容器的镜像。</li>
<li>重建容器：<code>docker-compose up --build</code> 命令可以重建所有容器的镜像，并重新启动容器组。</li>
</ul>
</li>
<li><p>查看容器组状态：</p>
<ul>
<li>查看容器组状态：<code>docker-compose ps</code> 命令可以列出 Docker Compose 配置文件中定义的所有服务和容器的状态信息。</li>
</ul>
</li>
<li><p>执行命令：</p>
<ul>
<li>在容器内执行命令：<code>docker-compose exec &lt;service&gt; &lt;command&gt;</code> 命令可以在指定的服务容器内执行命令。</li>
</ul>
</li>
<li><p>清理容器和资源：</p>
<ul>
<li>删除容器：<code>docker-compose rm</code> 命令可以删除停止的容器。</li>
<li>清理资源：<code>docker-compose down</code> 命令可以停止并删除所有容器、网络和卷。</li>
</ul>
</li>
<li><p>查看日志：</p>
<ul>
<li>查看容器日志：<code>docker-compose logs</code> 命令可以查看 Docker Compose 配置文件中定义的所有服务和容器的日志。</li>
</ul>
</li>
</ol>
<p>这些是一些常见的 Docker Compose 命令及其功能。你可以根据需要使用这些命令来管理和操作 Docker Compose 配置文件中定义的容器组。</p>
<p>请注意，在使用 Docker Compose 命令之前，确保已经安装了 Docker Compose 工具，并在当前工作目录下存在正确的 Docker Compose 配置文件。</p>
<hr>
<h2 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h2><ul>
<li><p>简介：</p>
<ul>
<li>docker save 命令用于将 Docker 镜像保存为一个 tar 归档文件。这个归档文件可以方便地传输、备份或在其他 Docker 主机上加载和使用</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>OPTIONS：可选参数，用于指定额外的选项，如压缩级别等。</li>
<li>IMAGE：要保存为归档文件的 Docker 镜像名称或镜像 ID</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o myimage.tar myimage:latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述示例将名为 myimage:latest 的 Docker 镜像保存为 myimage.tar 归档文件。</li>
<li>要了解更多关于 docker save 命令的详细信息，你可以使用 docker save –help 查看帮助文档</li>
<li>使用 docker save 命令保存的归档文件可以使用 docker load 命令进行加载和导入。这样可以在其他 Docker 主机上使用相同的镜像，或者进行备份和共享镜像</li>
</ul>
</li>
</ul>
<h2 id="docker-system"><a href="#docker-system" class="headerlink" title="docker system"></a>docker system</h2><p><code>docker system</code> 命令用于管理和查看 Docker 系统资源的相关信息。它提供了一组子命令，可以用于获取关于 Docker 守护进程（Docker daemon）的状态、清理无用资源以及查看 Docker 系统的使用情况。下面是对 <code>docker system</code> 命令的一些常用子命令的详细解释：</p>
<ol>
<li><p>**<code>docker system df</code>**：显示 Docker 系统的磁盘使用情况，包括镜像、容器和卷的使用情况。</p>
</li>
<li><p>**<code>docker system events</code>**：实时显示 Docker 系统的事件流，包括容器的创建、启动、停止、删除等事件。</p>
</li>
<li><p>**<code>docker system info</code>**：显示 Docker 系统的详细信息，包括容器、镜像、存储驱动、内核版本等。</p>
</li>
<li><p>**<code>docker system prune</code>**：清理无用的 Docker 资源，包括未使用的镜像、停止的容器、未使用的网络等。</p>
</li>
<li><p>**<code>docker system resize</code>**：调整 Docker 容器终端的大小。</p>
</li>
</ol>
<p>这只是 <code>docker system</code> 命令的一些常见用法。你可以通过运行 <code>docker system --help</code> 或 <code>docker system &lt;子命令&gt; --help</code> 查看完整的帮助文档，以了解更多关于各个子命令的详细信息和使用方式。</p>
<p>请注意，<code>docker system</code> 命令需要在具有足够权限的环境中执行，例如在管理员或超级用户模式下执行。</p>
<h2 id="docker-system-prune"><a href="#docker-system-prune" class="headerlink" title="docker system prune"></a>docker system prune</h2><p><code>docker system prune</code> 命令用于清理无用的 Docker 资源，以释放磁盘空间。它会删除未使用的镜像、停止的容器、未使用的网络和未被任何容器引用的卷。这可以帮助你清理系统中的不必要资源，以避免占用过多的磁盘空间。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune [OPTIONS]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>OPTIONS</code>：可选参数，用于指定额外的选项。常见的选项包括：<ul>
<li><code>-a, --all</code>：清理所有未使用的资源，包括未使用的镜像、容器、网络和卷。</li>
<li><code>-f, --force</code>：强制执行清理操作，不需要用户进行确认。</li>
<li><code>--filter &lt;FILTER&gt;</code>：按照指定的条件过滤要清理的资源。</li>
<li><code>-v, --volumes</code>：同时清理未被容器引用的卷。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune -a</span><br></pre></td></tr></table></figure>

<p>上述示例将清理所有未使用的 Docker 资源，包括未使用的镜像、停止的容器、未使用的网络和未被任何容器引用的卷。</p>
<p>请注意，清理操作是不可逆的，一旦执行将无法恢复被删除的资源。在执行 <code>docker system prune</code> 命令之前，请确保你了解将要删除的资源，并确认没有重要的数据会被删除。</p>
<p>使用 <code>docker system prune</code> 命令可以帮助你管理 Docker 系统资源，提供更高效和规整的环境。</p>
<!-- + 语法：`docker system prune [options]`
+ 作用：清除缓存
+ `[options]`
  - `-all, -a` : 删除所有未使用的镜像，不只是闲置的。(Remove all unused images not just dangling ones)
  - `--filter` : 提供数值过滤，例如：`label=<key>=<value>`。(Provide filter values)
  - `--force, -f` : 不提示确认。(Do not prompt for confirmation)
  - `--volumes` : 清除卷。(Prune volumes)

+ `docker system prune --volumes`
+ 该命令清除：
  - 所有停止的容器
  - 所有不被任何一个容器使用的网络
  - 所有不被任何一个容器使用的volume
  - 所有无实例的镜像 -->

<h2 id="docker-system-df"><a href="#docker-system-df" class="headerlink" title="docker system df"></a>docker system df</h2><p><code>docker system df</code> 命令用于显示 Docker 系统的磁盘使用情况，包括镜像、容器和卷的使用情况。它可以帮助你了解 Docker 系统在磁盘上占用的空间，以便更好地管理和优化资源。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system <span class="built_in">df</span> [OPTIONS]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>OPTIONS</code>：可选参数，用于指定额外的选项。常见的选项包括：<ul>
<li><code>--no-trunc</code>：不截断输出的镜像和容器名称。</li>
<li><code>-v, --volumes</code>：同时显示卷的使用情况。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system <span class="built_in">df</span></span><br></pre></td></tr></table></figure>

<p>上述示例将显示 Docker 系统的磁盘使用情况，包括镜像、容器和卷的使用情况。</p>
<p>输出内容包括以下几个部分：</p>
<ul>
<li><code>IMAGE TYPE</code>：镜像类型（例如，镜像、容器或卷）。</li>
<li><code>TOTAL</code>：总大小。</li>
<li><code>USED</code>：已使用的大小。</li>
<li><code>SHARED</code>：共享的大小。</li>
<li><code>CACHE</code>：缓存的大小。</li>
<li><code>RECLAIMABLE</code>：可回收的大小。</li>
<li><code>PARENT</code>：父镜像的 ID。</li>
<li><code>TAG</code>：镜像的标签或容器的名称。</li>
<li><code>VIRTUAL SIZE</code>：虚拟大小。</li>
</ul>
<p>使用 <code>docker system df</code> 命令可以方便地查看 Docker 系统的磁盘使用情况，帮助你了解镜像和容器占用的空间。这有助于进行资源管理和优化，以确保磁盘空间得到合理利用。</p>
<!-- + 语法：`docker system df [options]`
+ 作用：显示docker磁盘的使用情况(show docker disk usage)
+ `options` :
  - `--format` : 使用go模板打印更好的图像
  - `--verbose, -v` : 显示空间使用的详细信息 -->

<h2 id="docker-system-info"><a href="#docker-system-info" class="headerlink" title="docker system info"></a>docker system info</h2><p><code>docker system info</code> 命令用于显示 Docker 系统的详细信息，包括容器、镜像、存储驱动、内核版本等。它提供了有关 Docker 守护进程（Docker daemon）和运行环境的相关信息。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system info</span><br></pre></td></tr></table></figure>

<p>示例输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Client:</span><br><span class="line"> Context:    default</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Plugins:</span><br><span class="line">  app: Docker App (Docker Inc., v0.9.1-beta3)</span><br><span class="line">  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 3</span><br><span class="line">  Running: 2</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 1</span><br><span class="line"> Images: 15</span><br><span class="line"> Server Version: 20.10.6</span><br><span class="line"> Storage Driver: overlay2</span><br><span class="line">  Backing Filesystem: extfs</span><br><span class="line">  Supports d_type: true</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>输出内容包括以下几个部分：</p>
<ul>
<li><code>Client</code>：客户端相关信息，如上下文和调试模式。</li>
<li><code>Plugins</code>：安装的插件列表。</li>
<li><code>Server</code>：Docker 守护进程相关信息，如容器数量、镜像数量、服务器版本等。</li>
<li><code>Storage Driver</code>：存储驱动信息，如使用的驱动类型、底层文件系统等。</li>
<li>其他相关信息，如操作系统类型、内核版本等。</li>
</ul>
<p>通过运行 <code>docker system info</code> 命令，你可以获得有关 Docker 系统的详细信息，帮助你了解 Docker 运行环境和配置。这对于故障排查、性能优化和了解 Docker 系统的状态非常有用。</p>
<!-- + 语法：`docker system info [options]`
+ 作用：显示全部系统的信息
+ `[options]`:
  - `--format, -f` : 以指定的go模板格式化输出 -->

<h2 id="docker-stats"><a href="#docker-stats" class="headerlink" title="docker stats"></a>docker stats</h2><p><code>docker stats</code> 命令用于实时监视 Docker 容器的资源使用情况，包括 CPU 使用率、内存使用量、网络 I&#x2F;O 等。它提供了一个实时的流式输出，可以帮助你了解正在运行的容器的性能和资源消耗情况。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats [OPTIONS] [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>OPTIONS</code>：可选参数，用于指定额外的选项。常见的选项包括：<ul>
<li><code>--all, -a</code>：显示所有的容器（包括停止的容器）。</li>
<li><code>--format</code>：自定义输出格式。</li>
<li><code>--no-stream</code>：只显示一次统计结果，然后退出。</li>
<li><code>--no-trunc</code>：不截断输出的容器名称。</li>
</ul>
</li>
<li><code>CONTAINER</code>：要监视的容器名称或容器 ID。如果不指定容器，则会监视所有正在运行的容器。</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats container1 container2</span><br></pre></td></tr></table></figure>

<p>上述示例将实时监视名为 <code>container1</code> 和 <code>container2</code> 的容器的资源使用情况。</p>
<p>输出内容包括以下几个部分：</p>
<ul>
<li><code>CONTAINER ID</code>：容器的 ID。</li>
<li><code>NAME</code>：容器的名称。</li>
<li><code>CPU %</code>：CPU 使用率。</li>
<li><code>MEM USAGE / LIMIT</code>：内存使用量和限制。</li>
<li><code>MEM %</code>：内存使用率。</li>
<li><code>NET I/O</code>：网络输入&#x2F;输出。</li>
<li><code>BLOCK I/O</code>：块设备输入&#x2F;输出。</li>
<li><code>PIDS</code>：进程 ID 数量。</li>
</ul>
<p>使用 <code>docker stats</code> 命令可以实时监视 Docker 容器的资源使用情况，帮助你了解容器的性能和资源消耗情况。这对于监控和优化容器的运行非常有用。请注意，<code>docker stats</code> 命令会持续输出监视结果，可以通过 Ctrl+C 终止命令的执行。</p>
<!-- + 显示容器资源的使用情况，包括：CPU，内存，网络I/O等
+ 语法：`docker stats [options] [container...]`
+ `[options]`:
  - `-all, -a` : 显示所有的容器，包括未运行的
  - `--format` : 指定返回值的模板文件
  - `-no-stream` : 展示当前状态就直接退出了，不再实时更新
  - `--no-trunc` : 不截断输出
+ 输出详情：
  - `CONTAINER ID` ， `NAME` : 容器ID，名称
  - `CPU%, MEM%` : 容器使用的CPU和内存的百分比
  - `MEM USAGE/LIMIT` : 容器正在使用的总内存，以及允许使用的内存总量
  - `NET I/O` : 容器通过其网络接口发送和接受的数据量
  - `BLOCK I/O` : 容器从主机上的块设备读取和写入的数据量
  - `PIDs` : 容器创建的进程或线程数 -->

<h2 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h2><p><code>docker history</code> 命令用于查看 Docker 镜像的历史记录，包括每个镜像层的创建步骤和相关信息。它可以帮助你了解镜像是如何构建的，每个镜像层的来源和变更，以及各个镜像层的大小。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> [OPTIONS] IMAGE</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>OPTIONS</code>：可选参数，用于指定额外的选项。常见的选项包括：<ul>
<li><code>--no-trunc</code>：显示完整的命令信息，不截断输出。</li>
<li><code>--quiet, -q</code>：仅显示镜像层的 ID。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> myimage:latest</span><br></pre></td></tr></table></figure>

<p>上述示例将显示名为 <code>myimage:latest</code> 的 Docker 镜像的历史记录。</p>
<p>输出内容包括以下几个部分：</p>
<ul>
<li><code>IMAGE ID</code>：镜像层的 ID。</li>
<li><code>CREATED</code>：镜像层的创建时间。</li>
<li><code>CREATED BY</code>：创建镜像层的命令或操作。</li>
<li><code>SIZE</code>：镜像层的大小。</li>
</ul>
<p><code>docker history</code> 命令按照镜像层的构建顺序列出了镜像的历史记录。每个镜像层都代表一个变更，它可以是一个 Dockerfile 中的一条指令或者基于其他镜像层的修改。通过查看镜像的历史记录，你可以了解镜像是如何构建的，每个步骤的细节和影响，以及镜像层的大小情况。</p>
<p>请注意，镜像历史记录中的每一行都会添加一个新的镜像层，并且每个镜像层都会占用磁盘空间。因此，构建过多的镜像层可能会增加镜像的大小和磁盘消耗。</p>
<!-- + 语法：`docker history [options] IMAGE`
+ 作用：显示一个镜像的历史
+ `[options]`:
  - `--format` : 使用go模板输出
  - `--human, -H` : 以人习惯的阅读方式输出
  - `--no-trunc` : 不截断输出
  - `--quiet, -q` : 仅显示镜像IDs -->

<h2 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h2><p><code>docker kill</code> 命令用于强制停止正在运行的 Docker 容器。它发送一个 SIGKILL 信号给容器的主进程，使容器立即停止运行，类似于使用 <code>kill -9</code> 命令终止进程。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>OPTIONS</code>：可选参数，用于指定额外的选项。常见的选项包括：<ul>
<li><code>-s, --signal</code>：指定要发送的信号。默认为 SIGKILL。</li>
</ul>
</li>
<li><code>CONTAINER</code>：要停止的容器名称或容器 ID。</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> mycontainer</span><br></pre></td></tr></table></figure>

<p>上述示例将停止名为 <code>mycontainer</code> 的 Docker 容器。</p>
<p>注意事项：</p>
<ul>
<li>使用 <code>docker kill</code> 命令会立即停止容器，不会触发容器的停止信号或执行容器的停止脚本。</li>
<li>如果你希望优雅地停止容器并触发容器的停止信号和脚本，可以使用 <code>docker stop</code> 命令。</li>
<li>使用 <code>docker kill</code> 命令强制停止容器可能导致数据丢失或不正常的容器状态，请谨慎使用。</li>
</ul>
<p><code>docker kill</code> 命令用于强制停止正在运行的容器，对于无法通过正常方式停止的容器，这是一种有效的方法。然而，它不是优雅停止容器的首选方法，因为容器没有机会进行清理操作。建议在必要时使用，并确保了解可能的副作用。</p>
<!-- + 语法：`docker kill [options] container [container...]`
+ 作用：杀死一个或者多个正在运行的容器
+ `[options]`
  - `--signal, -s` : 发送到容器的信号。(Signal to send to the container)
  - `SIGHUB` , 信号，网络编程 -->

<h2 id="docker-pause"><a href="#docker-pause" class="headerlink" title="docker pause"></a>docker pause</h2><p><code>docker pause</code> 命令用于暂停正在运行的 Docker 容器。它会暂停容器内所有的进程，使其停止在当前状态，直到恢复为止。暂停后的容器不会消耗 CPU 资源，但内存和磁盘资源仍然保留。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>CONTAINER</code>：要暂停的容器名称或容器 ID。</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause mycontainer</span><br></pre></td></tr></table></figure>

<p>上述示例将暂停名为 <code>mycontainer</code> 的 Docker 容器。</p>
<p>注意事项：</p>
<ul>
<li>暂停容器会暂停容器内的所有进程，包括正在运行的和后台运行的。</li>
<li>暂停后的容器可以使用 <code>docker unpause</code> 命令来恢复运行。</li>
<li>暂停容器并不会影响容器的网络连接，因此容器仍然可以接收网络流量。</li>
<li>只有在支持容器暂停功能的操作系统上才能使用 <code>docker pause</code> 命令。</li>
</ul>
<p>使用 <code>docker pause</code> 命令可以方便地暂停正在运行的容器，以便进行调试、维护或其他需要容器暂停的操作。请确保在使用此命令之前了解其影响，并谨慎操作以避免不必要的问题。</p>
<!-- + 语法：`docker pause container [container...]`
+ 作用：暂停一个或多个容器中的所有进程 -->

<h2 id="docker-unpause"><a href="#docker-unpause" class="headerlink" title="docker unpause"></a>docker unpause</h2><p><code>docker unpause</code> 命令用于恢复被暂停的 Docker 容器。它会使之前被暂停的容器继续运行，并恢复容器内的所有进程的执行。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>CONTAINER</code>：要恢复的容器名称或容器 ID。</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause mycontainer</span><br></pre></td></tr></table></figure>

<p>上述示例将恢复名为 <code>mycontainer</code> 的 Docker 容器。</p>
<p>注意事项：</p>
<ul>
<li>只有被暂停的容器才能使用 <code>docker unpause</code> 命令进行恢复。</li>
<li>恢复容器后，之前被暂停的进程会继续执行。</li>
<li>容器的网络连接不会受到 <code>docker unpause</code> 命令的影响。</li>
</ul>
<p>使用 <code>docker unpause</code> 命令可以恢复之前被暂停的容器，使其继续运行。这对于从暂停状态中恢复容器非常有用，例如在进行调试或维护操作后重新启动容器。请注意，只能对已暂停的容器执行 <code>docker unpause</code> 命令。</p>
<!-- + 语法：`docker unpause container [container...]`
+ 作用：不暂停一个或多个容器中的所有进程 -->

<h2 id="docker-rename"><a href="#docker-rename" class="headerlink" title="docker rename"></a>docker rename</h2><p><code>docker rename</code> 命令用于为 Docker 容器重命名。它可以修改容器的名称标识符，使其更符合你的需求或命名约定。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename CONTAINER NEW_NAME</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>CONTAINER</code>：要重命名的容器名称或容器 ID。</li>
<li><code>NEW_NAME</code>：新的容器名称。</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename mycontainer newname</span><br></pre></td></tr></table></figure>

<p>上述示例将名为 <code>mycontainer</code> 的 Docker 容器重命名为 <code>newname</code>。</p>
<p>注意事项：</p>
<ul>
<li>重命名容器只会修改容器的名称标识符，不会对容器内的运行进程或状态造成影响。</li>
<li>容器的新名称必须是唯一的，不得与现有容器名称重复。</li>
</ul>
<p>使用 <code>docker rename</code> 命令可以轻松地为 Docker 容器重新命名，以便更好地管理容器或与命名约定保持一致。请记住，在容器被重命名后，你需要使用新的名称来执行其他容器相关的操作。</p>
<!-- + 语法：`docker rename container new_name`
+ 作用：重命名一个容器 -->

<h2 id="builder"><a href="#builder" class="headerlink" title="builder"></a>builder</h2><ul>
<li>manage builds</li>
</ul>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><ul>
<li>命令：<code>docker builder build [OPTIONS] PATH | URL | -</code></li>
<li>简介：从Dockerfile创建一个镜像</li>
<li>选项：<ul>
<li><code>--add-host</code> : 添加一个自定义的主机到IP的映射（host:ip）</li>
<li><code>--build-arg</code> : 设置构建时的变量</li>
<li><code>--cache-from</code> : 考虑作为缓存来源的镜像</li>
<li><code>--cgroup-parent</code> : 容器的可选父级c组</li>
<li><code>--compress</code> : 使用gzip压缩构建环境</li>
<li><code>--cpu-period</code></li>
<li><code>--cpu-quota</code></li>
<li><code>--cpu-shares,-c</code></li>
<li><code>--cpuset-cpus</code></li>
<li><code>--cpuset-mems</code></li>
<li><code>--disable-content-true</code> : 跳过镜像验证，默认为true</li>
<li><code>--file,-f</code> : Dockerfile的名称，默认为PATH&#x2F;Dockerfile</li>
<li><code>--force-rm</code> : 始终移除中间的容器</li>
<li><code>--iidfile</code> : 将镜像的ID写入到文件中</li>
<li><code>--isolation</code> : 容器隔离技术</li>
<li><code>--label</code> : 设置镜像的元数据</li>
<li><code>--memory,-m</code> : 内存限制</li>
<li><code>--memory-swap</code> : 交换限制等于内存加交换：-1表示启用无限制交换。</li>
<li><code>--network</code> : 在构建过程中为RUN指令设置网络模式</li>
<li><code>--no-cache</code> : 在构建镜像的时候不要使用缓存</li>
<li><code>--platform</code> : 如果服务器是多平台的，则设置平台</li>
<li><code>--pull</code> : 始终尝试拉取一个较新版本的镜像</li>
<li><code>--quiet,-q</code> : 过滤构建镜像的输出，仅在成功时输出镜像的ID</li>
<li><code>--rm</code> : 构建成功后删除中间容器</li>
<li><code>--security-opt</code> : 安全选项</li>
<li><code>--shm-size</code> : &#x2F;dev&#x2F;shm的大小</li>
<li><code>--squash</code> : 将新建的层压成一个新的层</li>
<li><code>--tag,-t</code> : 名称和可选的标签，格式为name:tag</li>
<li><code>--target</code> : 设置目标构建阶段为构建。</li>
<li><code>--ulimit</code> : 限定选项</li>
</ul>
</li>
</ul>
<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><ul>
<li>命令：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></li>
<li>简介：docker run命令首先在指定的镜像上创建一个可写的容器层，然后用指定的命令启动它。也就是说，docker run相当于API中的&#x2F;containers&#x2F;create然后&#x2F;containers&#x2F;(id)&#x2F;start。一个停止的容器可以用docker start来重新启动，其之前的所有变化都是完整的。</li>
<li>选项：<ul>
<li><code>--add-host</code> : 添加一个自定义的主机到IP的映射（host:ip）</li>
<li><code>--attach,-a</code> : 附加到STDIN、STDOUT或STDERR上</li>
<li><code>--blkio-weight</code> : 区块IO（相对权重），在10和1000之间，或0表示禁用（默认为0）。</li>
<li><code>--blkio-weight-device</code> : 块状IO重量（相对设备重量）</li>
<li><code>--cap-add</code> : 	增加Linux功能</li>
<li><code>--cap-drop</code> : 	降低Linux的能力</li>
<li><code>--cgroup-parent</code> : 容器的可选父级c组</li>
<li><code>--cgroupns</code></li>
<li><code>--cidfile</code> : 将容器ID写到文件中</li>
<li><code>--cpu-count</code> : CPU计数，仅支持Windows</li>
<li><code>--cpu-percent</code> : </li>
<li><code>--cpu-period</code> </li>
<li><code>--cpu-quota</code></li>
<li><code>--cpu-rt-period</code></li>
<li><code>--cpu-rt-runtime</code></li>
<li><code>--cpu-shared,-c</code></li>
<li><code>--cpus</code> : cpu的数量</li>
<li><code>--cpuset-cpus</code></li>
<li><code>--cpuset-mems</code></li>
<li><code>--detach,-d</code> : 在后台运行容器并打印容器ID</li>
<li><code>--detach-keys</code> : 覆盖脱离容器的按键顺序</li>
<li><code>--device</code> : 在容器中添加一个主机设备</li>
<li><code>--device-cgroup-rule</code> : 在cgroup允许的设备列表中添加一条规则</li>
<li><code>--device-read-bps</code> : 限制从一个设备上的读取速率（每秒字节数）。</li>
<li><code>--device-read-iops</code> : 限制从一个设备的读取率（每秒的IO）。</li>
<li><code>--device-write-bps</code></li>
<li><code>--device-write-iops</code></li>
<li><code>--disable-content-trust</code> : 跳过镜像验证，默认为true</li>
<li><code>--dns</code> : 设置自定义的DNS服务器</li>
<li><code>--dns-option</code> : 设置DNS选项</li>
<li><code>--dns-search</code> : 设置自定义DNS搜索域</li>
<li><code>--domainname</code> : 容器NIS域名</li>
<li><code>--entrypoint</code> : 覆盖镜像的默认ENTRYPOINT</li>
<li><code>--env,-e</code> : 设置环境变量</li>
<li><code>--env-file</code> : 读取环境变量的文件</li>
<li><code>--expose</code> : 暴露一个端口或一系列的端口</li>
<li><code>--gpus</code> : 要添加到容器中的GPU设备（’全部’用于传递所有GPU）。</li>
<li><code>--group-add</code></li>
<li><code>--health-cmd</code> : 运行命令以检查健康状况</li>
<li><code>--health-interval</code> : 运行检查的间隔时间（ms|s|m|h）（默认为0s）。</li>
<li><code>--health-retries</code></li>
<li><code>--health-start-period</code></li>
<li><code>--health-timeout</code></li>
<li><code>--help</code> : 输出帮助信息</li>
<li><code>--hostname,-h</code> : 容器主机名称</li>
<li><code>--init</code> : 在容器内运行一个init，转发信号并收割进程</li>
<li><code>--interactive,-i</code> : 保持STDIN开放，即使没有连接</li>
<li><code>--io-maxbandwidth</code> : 系统驱动器的最大IO带宽限制（仅Windows）。</li>
<li><code>--io-maxiops</code> : 系统驱动器的最大IOps限制（仅Windows）。</li>
</ul>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h2 id="docker-images-docker-image-ls"><a href="#docker-images-docker-image-ls" class="headerlink" title="docker images, docker image ls"></a><code>docker images, docker image ls</code></h2><ul>
<li>列出本地主机上的镜像<ul>
<li><code>repository</code> : 表示镜像的仓库源</li>
<li><code>tag</code> : 镜像的标签</li>
<li><code>image id</code> : 镜像id</li>
<li><code>created</code> : 镜像创建时间</li>
<li><code>size</code> : 镜像大小</li>
</ul>
</li>
</ul>
<h2 id="docker-rmi-helloworld"><a href="#docker-rmi-helloworld" class="headerlink" title="docker rmi helloworld"></a><code>docker rmi helloworld</code></h2><ul>
<li>删除镜像</li>
</ul>
<h2 id="docker-run-it-ubuntu-bin-bash"><a href="#docker-run-it-ubuntu-bin-bash" class="headerlink" title="docker run -it ubuntu /bin/bash"></a><code>docker run -it ubuntu /bin/bash</code></h2><ul>
<li>使用ubuntu镜像启动一个容器,参数为以命令模式进入该容器<ul>
<li><code>-i</code> : 交互操作</li>
<li><code>-t</code> : 终端</li>
<li><code>ubuntu</code> : ubuntu镜像</li>
<li><code>/bin/bash</code> : 放在镜像名后的是命令,这里是希望有个交互式shell</li>
</ul>
</li>
</ul>
<h2 id="docker-run-itd-name-ubuntu-test-ubuntu-bin-bash"><a href="#docker-run-itd-name-ubuntu-test-ubuntu-bin-bash" class="headerlink" title="docker run -itd --name ubuntu-test ubuntu /bin/bash"></a><code>docker run -itd --name ubuntu-test ubuntu /bin/bash</code></h2><ul>
<li>后台运行容器<ul>
<li><code>-d</code> : 默认不会进入容器,想要进入容器需要使用指令<code>docker exec</code></li>
</ul>
</li>
</ul>
<h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a><code>docker ps</code></h2><ul>
<li>语法：<code>docker ps [options]</code></li>
<li>作用：列出容器</li>
<li><code>[options]</code><ul>
<li><code>--all, -a</code> : 显示所有容器(默认仅显示正在运行的)。(Show all containers(default shows just running))</li>
<li><code>--filter, -f</code> : 基于指定的条件过滤输出信息。(Filter output based on conditions provided)</li>
<li><code>--format</code> : 使用go模板输出</li>
<li><code>--last, -n</code> : 显示n个最后创建的容器。(Show n last created containers(includes all states))</li>
<li><code>--no-trunc</code> : 不截断输出。(Don’t truncate output)</li>
<li><code>--quiet, -q</code> : 仅显示容器ID。(Only display container IDs)</li>
<li><code>--size, -s</code> : 显示总文件大小。(Display total file sizes)</li>
</ul>
</li>
</ul>
<h2 id="docker-start-id"><a href="#docker-start-id" class="headerlink" title="docker start id"></a><code>docker start id</code></h2><ul>
<li>启动一个已停止的容器</li>
</ul>
<h2 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop"></a><code>docker stop</code></h2><ul>
<li>语法：<code>docker stop [options] container [container...]</code></li>
<li>作用：停止一个容器</li>
<li><code>[options]</code>:<ul>
<li><code>--time, -t</code> : 在杀死容器之前等待停止的时间，默认为10秒</li>
</ul>
</li>
</ul>
<h2 id="docker-restart-id"><a href="#docker-restart-id" class="headerlink" title="docker restart id"></a><code>docker restart id</code></h2><ul>
<li>重启一个容器</li>
</ul>
<h2 id="docker-attach-docker-exec"><a href="#docker-attach-docker-exec" class="headerlink" title="docker attach, docker exec"></a>docker attach, docker exec</h2><ul>
<li>进入容器:在使用<code>-d</code>参数时,容器启动后会进入后台,此时想要进入容器,通过以下指令:<ul>
<li>docker attach: <code>docker attach id</code></li>
<li>docker exec:推荐使用此命令,因为使用它退出容器终端,但是不会导致容器的停止,<code>docker exec -it id /bin/bash</code></li>
</ul>
</li>
</ul>
<h2 id="docker-export-docker-import-docker-commit"><a href="#docker-export-docker-import-docker-commit" class="headerlink" title="docker export, docker import, docker commit"></a>docker export, docker import, docker commit</h2><h2 id="docker-export"><a href="#docker-export" class="headerlink" title="docker export"></a>docker export</h2><ul>
<li><code>docker export</code>命令不会导出与容器关联的卷的内容。如果卷安装在容器中现有目录的顶部，则<code>docker export</code>将导出底层目录的内容，而不是卷的内容</li>
<li>功能：将容器的文件系统导出为tar存档</li>
<li><code>docker export 容器id &gt; 容器名称.tar , docker export 容器id --output 容器名称.tar</code><ul>
<li>导出本地某个容器到tar包</li>
</ul>
</li>
<li>参数<ul>
<li><code>--output, -o</code> : 写入一个文件，而不是<code>stdout</code></li>
</ul>
</li>
</ul>
<h2 id="docker-import"><a href="#docker-import" class="headerlink" title="docker import"></a>docker import</h2><ul>
<li>语法：<code>docker import [options] file|URL|- [REPOSITORY[:TAG]]</code></li>
<li>作用：从一个tar包导入文件数据并创建一个文件系统镜像</li>
<li><code>[options]</code> :<ul>
<li><code>--change, -c</code> : 应用于创建镜像的dockerfile 指示</li>
<li><code>--message, -m</code> : 为导入的镜像设置提交信息</li>
</ul>
</li>
<li><code>cat docker/ubuntu.tar | docker import - test/ubuntu:v1</code><ul>
<li>通过管道和标准输入的方式导入容器快照</li>
</ul>
</li>
</ul>
<h2 id="docker-load"><a href="#docker-load" class="headerlink" title="docker load"></a>docker load</h2><ul>
<li>导入镜像文件：<code>docker load --input imagePath</code></li>
</ul>
<h2 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h2><ul>
<li>更新镜像:通过命令<code>docker commit</code>来提交容器副本,Warning:使用此命令保存镜像，会以层的概念保存，每一次保存都会增加一层，镜像会越来越大<ul>
<li>示例:<code>docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</code></li>
<li>参数说明:<ul>
<li><code>-m</code>:提交的描述信息</li>
<li><code>-a</code>:指定镜像作者</li>
<li><code>e218edb10161</code> : 容器ID</li>
<li><code>runoob/ubuntu:v2</code> : 指定要创建的目标镜像名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h2><ul>
<li>修改镜像标签:<code>docker tag image-id name:tag</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Git/2024-05-22-git_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Git/2024-05-22-git_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">git_3_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Git常见的使用技巧</li>
</ul>
<h2 id="写了很多代码，发现写错了分支怎么办"><a href="#写了很多代码，发现写错了分支怎么办" class="headerlink" title="写了很多代码，发现写错了分支怎么办"></a>写了很多代码，发现写错了分支怎么办</h2><ul>
<li><p>未提交的情况下</p>
<ul>
<li>git add . (把所有改动暂存)</li>
<li>git stash (把暂存的文件提交到git的暂存栈)</li>
<li>git checkout 本该提交代码的分支</li>
<li>git stash pop (将暂存栈中的代码放出来)</li>
</ul>
</li>
<li><p>至于是继续改还是提交就随你了</p>
</li>
<li><p>已提交的情况下</p>
<ul>
<li>git checkout 不该提交代码提交了代码的分支</li>
<li>git reset HEAD~1 （最近一次提交放回暂存区, 并取消此次提交）</li>
<li>git stash (把暂存的文件提交到git的暂存栈)</li>
<li>git checkout 该提交代码的分支</li>
<li>git stash pop</li>
</ul>
</li>
<li><p>下面一顿操作随你猛了，等你把代码提交到了正确的分支后，再次切到刚刚错的分支</p>
</li>
</ul>
<h2 id="git-迭代拉取子项目"><a href="#git-迭代拉取子项目" class="headerlink" title="git 迭代拉取子项目"></a>git 迭代拉取子项目</h2><p>在 Git 中，如果你有一个父项目，而该项目包含了子项目，你可能希望在父项目中拉取或更新这些子项目。这种情况下，通常会使用 Git 的子模块（submodule）功能。子模块允许你在一个 Git 仓库中引用另一个仓库。</p>
<p>要拉取或更新子项目，可以按照以下步骤进行：</p>
<ol>
<li><p><strong>添加子模块</strong>：如果尚未添加子模块，可以使用以下命令将子模块添加到父项目中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add &lt;URL-of-submodule-repository&gt; &lt;path-to-store-submodule&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/example/submodule.git path/to/submodule</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化子模块</strong>：在克隆父项目后，子模块目录中可能还没有子模块的文件。要初始化子模块，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>更新子模块</strong>：一旦子模块被添加并初始化，你可以使用以下命令更新子模块到父项目所引用的特定版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure>
<p>这会将每个子模块更新到它们在父项目中所引用的最新提交。</p>
</li>
</ol>
<p>记住，当你拉取父项目时，子模块不会自动更新。你需要显式运行 <code>git submodule update --remote</code> 来更新子模块。</p>
<p>这些是用于在 Git 中迭代拉取子项目的基本步骤。</p>
<h2 id="git-仅检查指定项目-忽略子项目"><a href="#git-仅检查指定项目-忽略子项目" class="headerlink" title="git 仅检查指定项目 忽略子项目"></a>git 仅检查指定项目 忽略子项目</h2><p>在Git中，如果你想仅检查指定项目而忽略子项目，你可以使用<code>.gitignore</code>文件来指定哪些文件或目录应该被忽略。在<code>.gitignore</code>中，你可以列出你希望忽略的文件或目录的模式。</p>
<p>以下是一些建议：</p>
<ol>
<li><p><strong>创建.gitignore文件：</strong> 在你的项目根目录下创建一个名为<code>.gitignore</code>的文件。</p>
</li>
<li><p><strong>编辑.gitignore文件：</strong> 打开<code>.gitignore</code>文件并添加你希望忽略的文件或目录的模式。如果你想忽略所有子项目，你可以使用通配符（如<code>/*</code>）来匹配所有直接子目录。例如：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">!/指定项目/</span><br></pre></td></tr></table></figure>

<p> 这将忽略根目录下的所有内容，但允许<code>指定项目</code>目录被追踪。</p>
</li>
<li><p><strong>将.gitignore文件添加到版本控制：</strong> 确保将<code>.gitignore</code>文件添加到Git版本控制中，这样其他人克隆你的仓库时也会遵循这些规则。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .gitignore</span><br><span class="line">git commit -m &quot;Add .gitignore to ignore subprojects&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>更新.gitignore：</strong> 如果在项目的后续开发中需要调整忽略规则，只需更新<code>.gitignore</code>文件并提交更改即可。</p>
</li>
</ol>
<p>请记住，<code>.gitignore</code>文件中的模式是相对于<code>.gitignore</code>所在目录的相对路径的。确保你的规则符合你的项目结构。</p>
<h2 id="git-config-查看默认编辑器"><a href="#git-config-查看默认编辑器" class="headerlink" title="git config 查看默认编辑器"></a>git config 查看默认编辑器</h2><p>要查看 Git 的默认文本编辑器，可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor</span><br></pre></td></tr></table></figure>

<p>上述命令将显示全局配置中设置的默认编辑器。如果没有设置默认编辑器，它将不会返回任何输出。</p>
<p>如果你在命令行中看到了输出，它将是你当前配置的默认编辑器的名称或路径。常见的编辑器包括 Vim、Emacs、Nano、Sublime Text、Visual Studio Code 等。</p>
<h2 id="撤回本地修改"><a href="#撤回本地修改" class="headerlink" title="撤回本地修改"></a>撤回本地修改</h2><ul>
<li>放弃对本地已经修改，但是尚未提交的文件的修改，还原到其未修改前的状态</li>
<li>命令<ul>
<li>撤回对所有已经修改，但是未提交的文件的修改，但不包括新增的文件<ul>
<li><code>git checkout .</code></li>
</ul>
</li>
<li>撤回对指定文件的修改，<code>[filename]</code>为文件名<ul>
<li><code>git checkout [filename]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="git-reset-回退项目版本"><a href="#git-reset-回退项目版本" class="headerlink" title="git reset 回退项目版本"></a>git reset 回退项目版本</h2><ul>
<li>可以回退到任意已经提交过的版本，已经add, commit但是没有push的文件也适用</li>
<li>命令<ul>
<li><code>git reset --hard [commit-hashcode]</code></li>
</ul>
</li>
<li>参数：<ul>
<li><code>commit-hashcode</code> 是某个commit的哈希值，可以适用git log查看</li>
<li>因此，一般用法是先用git log 查看具体commit的哈希值，然后reset到那个版本</li>
</ul>
</li>
</ul>
<h2 id="对于新增文件"><a href="#对于新增文件" class="headerlink" title="对于新增文件"></a>对于新增文件</h2><ul>
<li>撤回本地修改和回退项目版本都不会对新增文件起作用。因为新增的文件是还未加到git的记录里面的，即属于未被<code>tracked</code>的状态，所以撤销修改和回退均对其不受影响。</li>
<li>解决方法：<ul>
<li>直接手动删除文件即可</li>
</ul>
</li>
</ul>
<h2 id="上游分支-upstream"><a href="#上游分支-upstream" class="headerlink" title="上游分支 upstream"></a>上游分支 upstream</h2><ul>
<li><p>upstream意为上游，即本地分支所对应的远程分支。</p>
</li>
<li><p>一般，本地分支如果是从clone或者fetch得到的，都在远程库有一个upstream分支。</p>
</li>
<li><p>设置upstream的方法有两种：</p>
<ul>
<li>在push的时候指定：<code>git push --set-upstream origin my_remote_branch_name</code></li>
<li>在新建分支的时候指定：<code>git branch --set-upstream my_local_branch_name origin/my_remote_branch_name</code>(错误)</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>在运行<code>git branch --set-upstream</code>命令时，出现错误(git –version: 2.17.1)</li>
<li><code>fatal: the &#39;--set-upstream&#39; option is no longer supported. Please use &#39;--track&#39; or &#39;--set-upstream-to&#39; instead.</code></li>
<li>设置方法：<code>git branch --set-upstream-to=origin/&lt;远程分支&gt; &lt;本地分支&gt;</code></li>
</ul>
</li>
<li><p>实际上，上述命令，就是在修改本地的.git&#x2F;config文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[branch &quot;my_local_branch_name&quot;]</span><br><span class="line">	remote = origin</span><br><span class="line">	merge = refs/heads/my_remote_branch_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消分支上游</p>
<ul>
<li><code>git branch --inset-upstream</code></li>
</ul>
</li>
<li><p>查看分支上游</p>
<ul>
<li><code>git status</code></li>
<li><code>git checkout &lt;分支&gt;</code></li>
<li><code>git branch -vv</code></li>
</ul>
</li>
<li><p>设置完upstream后，就可以直接用 <code>git push/pull</code> 来拉取或推送相应的分支了。</p>
</li>
</ul>
<h2 id="直接拉取远程分支"><a href="#直接拉取远程分支" class="headerlink" title="直接拉取远程分支"></a>直接拉取远程分支</h2><ul>
<li>新建分支分支并切换到指定分支<ul>
<li><code>git checkout -b dev origin/dev</code></li>
<li><code>git checkout -b 本地分支名 origin/远程分支名</code></li>
</ul>
</li>
<li>该命令可以将远程Git仓库里的指定分支拉取到本地，这样就在本地新建了一个dev分支，并和指定的远程分支<code>origin/dev</code>关联起来了。</li>
<li>示例：<ul>
<li><code>git checkout -b dev notes/dev</code> : 切换指定远程分支</li>
</ul>
</li>
</ul>
<h2 id="在本地使用指定提交id创建分支"><a href="#在本地使用指定提交id创建分支" class="headerlink" title="在本地使用指定提交id创建分支"></a>在本地使用指定提交id创建分支</h2><ul>
<li><p>查看远程分支最新的commitSHA，例如：<code>aa4339fbe90f68bc82901d976a7c11fe92179ef3</code></p>
</li>
<li><p>使用命令直接从指定的commit新建分支：</p>
<ul>
<li><code>git branch [branch-name] [commit-id]</code></li>
<li><code>git branch v1.x aa4339fbe90f68bc82901d976a7c11fe92179ef3</code></li>
</ul>
</li>
</ul>
<h2 id="使用标签的方式"><a href="#使用标签的方式" class="headerlink" title="使用标签的方式"></a>使用标签的方式</h2><ul>
<li><code>git clone [--branch tag-name/branch-name] &lt;git-url&gt; [dir]</code> 下载并绑定指定分支或下载指定标签</li>
</ul>
<h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ul>
<li><p>在本地仓库创建标签，并推送到远程：</p>
<ul>
<li><code>git tag -a v1.0 -m &quot;create tag&quot;</code></li>
<li><code>git push origin v1.0</code></li>
</ul>
</li>
<li><p>下载指定标签到本地：</p>
<ul>
<li><code>git clone --branch v1.0 http://192.169.4.28/zjy/clean_code.git</code></li>
</ul>
</li>
<li><p>下载标签之后，出现的提示：</p>
<ul>
<li>你处于分离的HEAD状态。您可以环顾四周，进行实验性更改并提交它们，您可以放弃在此状态下所做的任何提交，而不会通过执行另一次签出影响任何分支。</li>
<li>如果您想创建一个新的分支来保留您创建的提交，您可以(现在或以后)再次使用-b和chckout命令。</li>
</ul>
</li>
</ul>
<h2 id="git同步项目进度方法"><a href="#git同步项目进度方法" class="headerlink" title="git同步项目进度方法"></a>git同步项目进度方法</h2><ul>
<li><p>创建三个分支：</p>
<ul>
<li>master </li>
<li>dev</li>
<li>local</li>
</ul>
</li>
<li><p>master分支：</p>
<ul>
<li>存放稳定版本的代码，在这个分支上的项目，所有的功能都是经过测试，不再改动的</li>
<li>这个是对外发行的分支</li>
</ul>
</li>
<li><p>dev分支</p>
<ul>
<li>存放正在开发的代码，在这个分支上的项目，可能正在新加功能，需要经过反复修改的，或者是同步的</li>
<li>这个是面向所有开发者的</li>
<li>所有开发者通过拉取这个分支的代码来同步项目开发的进程</li>
</ul>
</li>
<li><p>local分支</p>
<ul>
<li>存放本地的项目的代码，在这个分支上的项目，随时都有可能修改</li>
<li>这个是存放在本地，面向的是自己</li>
<li>其作用是，自己开发的时候，都在这个本地分支上修改，需要推送到远程git上或者拉取远程git上最新的代码时，需要进行如下几步<ul>
<li>首先，将local分支的修改全部添加，并在本地提交</li>
<li>其次，切换到本地的dev分支，然后拉取远程git上最新的dev分支</li>
<li>最后，切换回local分支，将本地拉取到的最新的分支合并到local分支</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="git删除远程分支文件"><a href="#git删除远程分支文件" class="headerlink" title="git删除远程分支文件"></a>git删除远程分支文件</h2><ul>
<li>git删除远程分支文件包括两种情况：<ul>
<li>（1）仅仅删除远程分支文件，不删除本地的文件；</li>
<li>（2）删除远程分支文件的同时，删除本地的文件。</li>
</ul>
</li>
</ul>
<h2 id="仅仅删除远程分支文件，不删除本地文件"><a href="#仅仅删除远程分支文件，不删除本地文件" class="headerlink" title="仅仅删除远程分支文件，不删除本地文件"></a>仅仅删除远程分支文件，不删除本地文件</h2><ul>
<li><p>删除远程文件filename</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached filename</span><br><span class="line">git commit -m &quot;delete remote file filename &quot;</span><br><span class="line">git push -u origin master(此处是当前分支的名字)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除远程文件夹directoryname</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached directoryname</span><br><span class="line">git commit -m &quot;delete remote directory directoryname &quot;</span><br><span class="line">git push -u origin master(此处是当前分支的名字)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="删除本地文件与远程分支文件"><a href="#删除本地文件与远程分支文件" class="headerlink" title="删除本地文件与远程分支文件"></a>删除本地文件与远程分支文件</h2><ul>
<li><p>删除文件filename</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm filename</span><br><span class="line">git commit -m &quot;delete file filename &quot;</span><br><span class="line">git push -u origin master(此处是当前分支的名字)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件夹directoryname</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r directoryname</span><br><span class="line">git commit -m &quot;delete directory directoryname &quot;</span><br><span class="line">git push -u origin master(此处是当前分支的名字)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="git常见错误"><a href="#git常见错误" class="headerlink" title="git常见错误"></a>git常见错误</h2><h2 id="fatal-refusing-to-merge-unrelated-histories"><a href="#fatal-refusing-to-merge-unrelated-histories" class="headerlink" title="fatal:refusing to merge unrelated histories"></a><code>fatal:refusing to merge unrelated histories</code></h2><ul>
<li>在使用<code>git pull</code>命令拉取代码时出现这个错误</li>
<li>原因：本地仓库和远程仓库实际上时独立的两个仓库</li>
<li>解决方法：添加选项<code>--allow-unrelated-histories</code>解决问题<ul>
<li><code>git pull zhuoer dev --allow-unrelated-histories</code></li>
</ul>
</li>
</ul>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><ul>
<li><code>git clone &lt;url&gt;</code> : 克隆远程版本库</li>
<li><code>git init</code> : 初始化本地版本库</li>
</ul>
<h2 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h2><ul>
<li><code>git status</code> : 查看状态</li>
<li><code>git diff</code> : 查看变更内容</li>
<li><code>git add .</code> : 跟踪所有改动过的文件</li>
<li><code>git add &lt;file&gt;</code> : 跟踪指定的文件</li>
<li><code>git mv &lt;old&gt; &lt;new&gt;</code> : 文件改名</li>
<li><code>git rm &lt;file&gt;</code> : 删除文件</li>
<li><code>git commit -m &quot;commit message&quot;</code> : 提交所有更新过的文件</li>
<li><code>git commit --amend</code> : 修改最后一次提交</li>
</ul>
<h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><ul>
<li><code>git log</code> : 查看提交历史</li>
<li><code>git log -p &lt;file&gt;</code> : 查看指定文件的提交历史</li>
<li><code>git blame &lt;file&gt;</code> : 以列表方式查看指定文件的提交历史</li>
</ul>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul>
<li><code>git reset --     0  1.9G   0% /sys/fs/cgroup /dev/mmcblk0p7   16G   12G  3.1G  79% /data  HEAD</code> : 撤销工作目录中所有未提交文件的修改内容</li>
<li><code>git checkout HEAD &lt;file&gt;</code> : 撤销指定的未提交的修改内容</li>
<li><code>git revert &lt;commit&gt;</code> : 取消指定的提交</li>
</ul>
<h2 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h2><ul>
<li><code>git branch</code> : 显示所有本地分支</li>
<li><code>git checkout &lt;branch/tag&gt;</code> : 切换到指定分支或标签</li>
<li><code>git branch &lt;new-branch&gt;</code> : 创建新分支</li>
<li><code>git branch -d &lt;branch&gt;</code> : 删除本地分支</li>
<li><code>git tag</code> : 列出所有本地标签</li>
<li><code>git tag &lt;tagname&gt;</code> : 基于最新提交的创建标签</li>
<li><code>git tag -d &lt;tagname&gt;</code> : 删除标签</li>
<li><code>git checkout -b dev notes/dev</code> : 切换指定远程分支</li>
</ul>
<h2 id="合并和衍合"><a href="#合并和衍合" class="headerlink" title="合并和衍合"></a>合并和衍合</h2><ul>
<li><code>git merge &lt;branch&gt;</code> : 合并指定分支到当前分支</li>
<li><code>git rebase &lt;branch&gt;</code> : 衍合指定分支到当前分支</li>
</ul>
<h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><ul>
<li><code>git remote -v</code> : 查看远程版本库信息</li>
<li><code>git remote show &lt;remote&gt;</code> : 查看指定远程版本库信息</li>
<li><code>git remote add &lt;remote&gt; &lt;url&gt;</code> : 添加远程版本库</li>
<li><code>git fetch &lt;remote&gt;</code> : 从远程库获取代码</li>
<li><code>git pull &lt;remote&gt; &lt;branch&gt;</code> : 下载代码及快速合并</li>
<li><code>git push &lt;remote&gt; &lt;branch&gt;</code> : 上传代码及快速合并</li>
<li><code>git push &lt;remote&gt; :&lt;branch/tag-name&gt;</code> : 删除远程分支或标签</li>
<li><code>git push --tags</code> : 上传所有标签</li>
</ul>
<h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><ul>
<li><code>git pull origin master</code><ul>
<li><code>push</code> : 将本地仓库与远程仓库合并</li>
<li><code>-u</code> : 将本地仓库分支与远程仓库分支一起合并，就是说将master的分支也提交上去，这样就可以在远程仓库上看到在本地仓库的master中创建了多少分支。不加这个参数，只将当前的master与远程的合并，没有分支的历史纪录，也不能切换分支</li>
<li><code>origin</code> : 远程仓库的意思，如果这个仓库是远程的，那么必须使用这个选项</li>
<li><code>master</code> : 提交本地master分支仓库</li>
</ul>
</li>
</ul>
<h2 id="递归克隆"><a href="#递归克隆" class="headerlink" title="递归克隆"></a>递归克隆</h2><ul>
<li><code>git clone --recursive http://192.167.10.28/dagger/manager_node.git</code></li>
<li><code>recursive</code>选项会递归克隆项目下的所有git项目</li>
</ul>
<h2 id="撤销-git-add-并保留修改的方法"><a href="#撤销-git-add-并保留修改的方法" class="headerlink" title="撤销 git add 并保留修改的方法"></a>撤销 <code>git add</code> 并保留修改的方法</h2><ul>
<li><strong><code>git reset --mixed</code> – 撤销所有的已经<code>add</code>的文件</strong></li>
<li><code>git reset HEAD .</code> – 复制撤销某个文件或文件夹</li>
<li><code>git reset HEAD -filename</code> – 另外，可以使用<code>git status</code> ，git会告诉可以通过哪一个命令来执行操作</li>
</ul>
<h2 id="git从历史上的某一次提交处建立分支"><a href="#git从历史上的某一次提交处建立分支" class="headerlink" title="git从历史上的某一次提交处建立分支"></a>git从历史上的某一次提交处建立分支</h2><ul>
<li><code>git log --oneline --all --graph --decorate</code></li>
<li><code>git branch dev 3be5879</code></li>
</ul>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><ul>
<li><p><code>git remote add &lt;shortname&gt; &lt;url&gt;</code> ： 添加一个新的远程Git仓库，同时指定一个方便使用的简写.</p>
<ul>
<li><code>git remote add zhuoer http://192.167.10.28/dagger/zhuoer</code> ： 现在可以在命令行中使用字符串<code>zhuoer</code>来代替整个URL</li>
</ul>
</li>
<li><p><code>git fetch &lt;remote&gt;</code> : 从远程仓库中获得数据。这个命令会访问远程仓库，从中拉取所有还没有的数据。执行完成后，将会拥有那个远程仓库中所有分支的引用，可以随时合并或者查看。</p>
</li>
<li><p><strong>如果使用<code>clone</code>命令克隆了一个仓库，命令会自动将其添加为远程仓库并且默认以<code>origin</code>为简写</strong>。所以，<code>git fetch origin</code>会抓取克隆（或上一次抓取）后新推送的所有工作。</p>
<ul>
<li>注意：<code>git fetch</code>命令只会将数据下在到本地仓库，它并不会自动合并或者修改当前的工作，当准备好时，必须要手动将其合并入你的工作。</li>
</ul>
</li>
<li><p>如果当前分支设置了跟踪远程分支，那么可以使用<code>git pull</code>命令自动抓取后合并该远程分支到当前分支。</p>
</li>
<li><p>默认情况下，<code>git clone</code>命令会自动设置本地<code>master</code>分支跟踪克隆的远程仓库的<code>master</code>分支（或其他名字的默认分支）。运行<code>git pull</code>通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。）</p>
</li>
</ul>
<h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><ul>
<li><code>git push &lt;remote&gt; &lt;branch&gt;</code><ul>
<li>当你想要将<code>master</code>分支推送到<code>origin</code>服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器。</li>
</ul>
</li>
</ul>
<h2 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h2><ul>
<li><code>git remote show &lt;remote&gt;</code><ul>
<li>查看某一个远程仓库的更多信息</li>
<li>它同样会列出远程仓库的URL与跟踪分支的信息。它告诉你正在处于<code>master</code>分支，并且如果运行<code>git pull</code>，就会抓取所有的远程引用，然后将远程<code>master</code>分支合并到本地<code>master</code>分支，</li>
<li>它也会列出拉取到的所有远程引用。</li>
</ul>
</li>
</ul>
<h2 id="远程仓库的重命名与移除"><a href="#远程仓库的重命名与移除" class="headerlink" title="远程仓库的重命名与移除"></a>远程仓库的重命名与移除</h2><ul>
<li><p><code>git remote rename</code></p>
<ul>
<li>修改一个远程仓库的简写名</li>
<li>这个操作也会修改所有远程跟踪的分支名字</li>
</ul>
</li>
<li><p><code>git remote remove</code>或者<code>git remote rm</code></p>
<ul>
<li>移除一个远程仓库</li>
<li>一旦使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</li>
</ul>
</li>
</ul>
<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><ul>
<li><p><code>git tag</code></p>
<ul>
<li>在Git中列出已有的标签</li>
<li>按照通配符列出标签需要<code>-l</code>或者<code>--list</code>选项</li>
<li>如果只想要完整的标签列表，那么运行<code>git tag</code>就会默认假定你想要一个列表，它会直接列出来</li>
</ul>
</li>
<li><p>创建标签，Git支持两种标签：轻量标签(<code>lightweight</code>)与附注标签(<code>annotated</code>)</p>
<ul>
<li>轻量标签很像一个不会改变的分支–它只是某个特定提交的引用</li>
<li>附注标签是存储在Git数据库中的一个完整对象，它们是可以被校验的，其中包括打标签者的名字，电子邮件，地址，日期时间，此外还有一个标签信息，并且可以使用GNU Privacy Guard（GTG）签名并验证。</li>
</ul>
</li>
<li><p>通常会建议创建附注标签，这样可以拥有以上所有信息，但是如果只是想用一个临时的标签，或者因为某些原因不想要保存信息，那么也可以用轻量标签</p>
</li>
<li><p>附注标签的创建: <code>git tag -a v1.4 -m &quot;my version 1.4&quot;</code></p>
<ul>
<li><code>-m</code> : 指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会启动编辑其要求你输入信息</li>
</ul>
</li>
<li><p>推送标签</p>
<ul>
<li>git push origin v1.4</li>
</ul>
</li>
<li><p>轻量标签，本质上是将提交校验和存储到一个文件中–没有保存任何其他信息。</p>
</li>
<li><p>创建轻量标签，不需要使用<code>-a</code>, <code>-s</code>, <code>-m</code>选项，只需要提供标签名字：<code>git tag v1.4-lw</code></p>
</li>
<li><p>后期打标签</p>
<ul>
<li>要在提交上打标签，需要在命令的末尾指定提交的校验和（或部分校验和）</li>
<li><code>git tag -a v1.2 9fcaw1</code></li>
</ul>
</li>
<li><p>删除标签</p>
<ul>
<li>删除本地仓库上的标签，可以使用命令<code>git tag -d &lt;tagname&gt;</code><ul>
<li>注意：该命令并不会从任何远程仓库中移除这个标签，必须使用<code>git push &lt;remote&gt;:refs/tags/&lt;tagname&gt;</code>来更新远程仓库</li>
<li>第一种变体是：<code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code>，这种操作的含义是：将冒号前面的空值推送到远程标签名，从而高效地删除它</li>
<li>第二种更加直观的删除远程标签的方式是：<code>git push &lt;remote&gt; --delete &lt;tagname&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>通过使用<code>git show</code>可以看到标签信息和与之对应的提交信息</p>
</li>
</ul>
<h2 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h2><ul>
<li>Git并不会在输入部分命令时自动推断出想要的命令。如果不想每次都输入完整的Git命令，可以通过<code>git config</code>文件来轻松地为每一个命令设置一个别名。</li>
<li>例如：<ul>
<li><code>git config --global alias.co checkout</code></li>
<li><code>git config --global alias.br branch</code></li>
<li><code>git config --global alias.ci commit</code></li>
<li><code>git config --global alias.st status</code></li>
<li>这意味着，当要输入<code>git commit</code>时，只需要输入<code>git ci</code></li>
</ul>
</li>
<li>在创建认为应该存在的命令时，这个技术会很有用。<ul>
<li>例如：为了解决取消暂存文件的易用性问题，可以向Git中添加取消暂存别名,<code>git config --global alias.unstage &#39;reset HEAD --</code></li>
<li>通常也会添加一个<code>last</code>命令：<code>git config --global alias.last &#39;log -l HEAD</code>。这样，可以很轻松地看到最后一次提交</li>
</ul>
</li>
<li>Git只是简单地将别名替换为对应的命令。</li>
</ul>
<h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><ul>
<li><p>几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着可以把工作从开发主线上分离开来，以免影响开发主线。</p>
</li>
<li><p><strong>Git保存的不是文件的变化或者差异，而是一系列不同时刻的快照。</strong></p>
</li>
<li><p>Git的分支，其实质上仅仅是指向提交对象的可变指针。Git的默认分支名字是<code>master</code>，在多次提交操作之后，其实已经有一个指向最后哪个提交对象的<code>master</code>分支。<code>master</code>分支会在每次提交时自动向前移动。</p>
<ul>
<li>Git的<code>master</code>分支并不是一个特殊分支。它跟其他分支完全没有区别。之所以几乎每一个仓库都有<code>master</code>分支，是因为<code>git init</code>命令默认创建它，并且大多数人都懒得去改动它</li>
</ul>
</li>
<li><p><code>git branch testing</code> : 创建分支<code>testing</code>，这会在当前所在的提交对象上创建一个指针。那么，Git又是怎么知道当前在哪一个分支上呢？</p>
<ul>
<li>也很简单，它有一个名为<code>HEAD</code>的特殊指针。它是一个指针，指向当前所在的本地分支（可以把<code>HEAD</code>想象为当前分支的别名）</li>
<li>在本示例中，仍然在<code>master</code>分支上，因为<code>git branch</code>命令仅仅创建一个新分支，并不会自动切换到新分支中去</li>
</ul>
</li>
<li><p><code>git log --decorate</code> ： 查看各个分支当前所指的对象</p>
</li>
<li><p>分支切换:<code>git checkout testing</code>。如此以来，<code>HEAD</code>就指向<code>testing</code>分支了。</p>
</li>
<li><p>由于Git的分支实质上仅是包含所指对象校验和（长度为40的SHA-1值字符串）的文件，所以它的创建和销毁都异常高效</p>
</li>
</ul>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><ul>
<li><p>远程引用是对远程仓库的引用（指针），包括分支，标签等。</p>
</li>
<li><p>可以通过 <code>git ls-remote &lt;remote&gt;</code>来显示地获得远程引用的完整列表</p>
</li>
<li><p>或者通过<code>git remote show &lt;remote&gt;</code>获得远程分支的更多信息</p>
</li>
<li><p>更常见的做法是利用<strong>远程跟踪分支</strong>，远程跟踪分支是远程分支状态的引用，它们以<code>&lt;remote&gt;/&lt;branch&gt;</code>的形式命名</p>
<ul>
<li>例如：假设网络里由一个在<code>git.ourcompany.com</code>的Git服务器。如果从这里克隆，Git的<code>clone</code>命令会自动将其命名为<code>origin</code>，拉取它的所有数据，创建一个指向它的<code>master</code>分支的指针，并且在本地将其命名为<code>origin/master</code>。Git也会给你一个与<code>origin</code>的<code>master</code>分支在指向同一个地方的本地<code>master</code>分支，这样你就有工作的基础。</li>
<li><code>origin</code>并无特殊含义。远程仓库名字<code>origin</code>与分支名字<code>master</code>一样，在Git中并没有任何特别的含义一样。同时,<code>master</code>是当你运行<code>git init</code>时默认的起始分支名字。如果你运行<code>git clone -o booyah</code>，那么默认的远程分支名字将会是<code>booyah/master</code></li>
</ul>
</li>
<li><p><code>git push &lt;remote&gt; &lt;branch&gt;</code> ： 推送到某个分支</p>
</li>
<li><p>与给定的远程仓库同步数据，运行<code>git fetch &lt;remote&gt;</code>命令。</p>
<ul>
<li>示例：<code>git fetch a311d</code></li>
<li>这个命令查找<code>a311d</code>是哪一个服务器，从中抓取本地没有的数据，并且更新本地数据库，移动<code>a311d/master</code>指针到更新之后的位置。</li>
</ul>
</li>
<li><p><code>git pull</code> : 拉取</p>
<ul>
<li>当<code>git fetch</code>命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容，它只会获取数据然后让你自己合并</li>
<li><code>git pull</code>命令在大多数情况下它的含义是一个<code>git fetch</code>紧接着一个<code>git merge</code>命令</li>
</ul>
</li>
</ul>
<h2 id="如何避免每次输入密码"><a href="#如何避免每次输入密码" class="headerlink" title="如何避免每次输入密码"></a>如何避免每次输入密码</h2><ul>
<li>如果正在使用<code>HTTPS URL</code>来推送，Git服务器会询问用户名与密码。默认情况下它会在终端中提示服务器是否允许你进行推送</li>
<li>如果不想在每一个推送时都输入用户名与密码，可以设置一个<code>credential cache</code>。最简单的方式就是将其保存在内存中几分钟，可以简单地运行<code>git config --global credential.helper cache</code>来设置</li>
</ul>
<h2 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h2><ul>
<li>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。</li>
<li>跟踪分支是与远程分支有直接关系的本地分支。如果在一个跟踪分支上输入<code>git pull</code>，Git能够自动地识别去那个服务器上抓取，合并到哪个分支。</li>
<li>当克隆一个仓库时，它通常会自动地创建一个跟踪<code>origin/master</code>的<code>master</code>分支。</li>
<li>如果想设置其他的跟踪分支，或者是一个在其他远程仓库上的跟踪分支，简单的示例：<code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。这是一个十分常用的操作，所以Git提供了<code>--track</code>快捷方式</li>
<li>如果想要将本地分支与远程分支设置为不同的名字，可以使用命令<code>git checkout -b sf origin/serverfix</code></li>
</ul>
<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><ul>
<li>运行带有<code>--delete</code>选项的<code>git push</code>命令，用来删除一个远程分支，例如:<code>git push zhuoer --delete docker-mqtt</code></li>
<li>基本上这个命令做的只是从服务器上移除这个指针。Git服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</li>
</ul>
<h2 id="Git-子模块"><a href="#Git-子模块" class="headerlink" title="Git 子模块"></a>Git 子模块</h2><ul>
<li><p>使用场景：某个工作中的项目需要包含并使用另一个项目。也许是第三方库，或者独立开发的，用于多个父项目的库。现在问题是：把它们当作两个独立的项目，同时又想在一个项目中使用另一个</p>
</li>
<li><p>Git通过<strong>子模块</strong>来解决这个问题：子模块允许将一个Git仓库作为另一个Git仓库的子目录。它能够将另一个仓库克隆到自己的项目中，同时还可以保持提交的独立。</p>
</li>
<li><p>将一个已存在的Git仓库添加为正在工作的仓库的自模块：<code>git submodule add</code>命令后加上想要跟踪的项目的相对或者绝对URL来添加新的子模块。</p>
<ul>
<li>默认情况下，子模块会将子项目放到一个与仓库同名的目录中，如果想放到其他地方，可以在命令结尾添加一个不同的路径。</li>
</ul>
</li>
<li><p><code>.gitmodules</code>配置文件，保存了项目URL与已经拉取的本地目录之间的映射</p>
</li>
<li><p>我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。 你可以通过在 git submodule add 命令后面加上想要跟踪的项目的相对或绝对 URL 来添加新的子模块。 在本例中，我们将会添加一个名为 “DbConnector” 的库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule add https://github.com/chaconinc/DbConnector</span><br><span class="line">Cloning into <span class="string">&#x27;DbConnector&#x27;</span>...</span><br><span class="line">remote: Counting objects: 11, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (10/10), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure></li>
<li><p>默认情况下，子模块会将子项目放到一个与仓库同名的目录中，本例中是 “DbConnector”。 如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Eigen3/2024-05-22-Eigen_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Eigen3/2024-05-22-Eigen_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Eigen_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen3/" itemprop="url" rel="index"><span itemprop="name">Eigen3</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Eigen 第三方库基础知识</li>
<li>Eigen，仅包含头文件即可</li>
</ul>
<h2 id="eigen3-Eigen-MatrixBaseEigen-Vector3d-normalized-函数-详解"><a href="#eigen3-Eigen-MatrixBaseEigen-Vector3d-normalized-函数-详解" class="headerlink" title="eigen3 Eigen::MatrixBaseEigen::Vector3d::normalized()函数 详解"></a>eigen3 Eigen::MatrixBase<a href="Eigen::Vector3d">Eigen::Vector3d</a>::normalized()函数 详解</h2><p><code>Eigen::MatrixBase&lt;Eigen::Vector3d&gt;::normalized()</code> 函数用于返回一个单位向量，即输入向量的归一化版本。这个函数返回一个新的向量，该向量具有与原始向量相同的方向，但长度为1。</p>
<p>下面是一些关键的详解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Eigen::MatrixBase&lt;Eigen::Vector3d&gt;::<span class="built_in">normalized</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>返回类型：</strong> 返回类型是 <code>Eigen::MatrixBase&lt;Derived&gt;</code>，其中 <code>Derived</code> 表示输入矩阵或向量的派生类类型。</p>
</li>
<li><p><strong>用途：</strong> <code>normalized()</code> 函数用于将向量归一化，即将其缩放为单位长度。</p>
</li>
<li><p><strong>注意事项：</strong></p>
<ul>
<li>如果输入向量的长度为零，则 <code>normalized()</code> 会产生一个未定义的结果。</li>
<li>对于零向量，<code>normalized()</code> 返回与原始向量相同的零向量。</li>
<li><code>normalized()</code> 函数不会修改原始向量，而是返回一个新的归一化向量。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    Eigen::Vector3d normalized_v = v.<span class="built_in">normalized</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Normalized Vector: &quot;</span> &lt;&lt; normalized_v &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中，<code>normalized_v</code> 将包含 <code>v</code> 的单位向量。</p>
</li>
</ul>
<p>总的来说，<code>normalized()</code> 函数在Eigen库中是用于向量归一化的方便方法。归一化是在计算机图形学、机器学习和其他领域中经常使用的操作，它确保向量的长度为1，并保持原始向量的方向。</p>
<h2 id="Eigen-Isometry3d-类-详解"><a href="#Eigen-Isometry3d-类-详解" class="headerlink" title="Eigen::Isometry3d 类 详解"></a>Eigen::Isometry3d 类 详解</h2><p><code>Eigen::Isometry3d</code> 是Eigen库中的一个类，用于表示三维空间中的等距变换（Isometry Transformation），也称为刚体变换（Rigid Transformation）。等距变换包括平移和旋转，通常用于表示物体在三维空间中的姿态和位置。</p>
<p>以下是关于 <code>Eigen::Isometry3d</code> 类的详细信息：</p>
<p><strong>构造函数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Isometry3d transform = Eigen::Isometry3d::<span class="built_in">Identity</span>();</span><br></pre></td></tr></table></figure>

<p>构造函数用于创建一个等距变换，通常初始化为单位等距变换，表示物体的初始位置和姿态。</p>
<p><strong>成员函数</strong>：</p>
<ol>
<li><p><code>translation()</code>：<br>返回等距变换的平移部分，它是一个三维向量表示平移的位移。</p>
</li>
<li><p><code>translation()</code>（重载）：<br>设置等距变换的平移部分。</p>
</li>
<li><p><code>rotation()</code>：<br>返回等距变换的旋转部分，它是一个<code>Eigen::Matrix3d</code>表示旋转矩阵。</p>
</li>
<li><p><code>matrix()</code>：<br>返回等距变换的矩阵表示，是一个<code>Eigen::Matrix4d</code>矩阵。</p>
</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建等距变换，表示平移(1, 2, 3)并绕X轴旋转45度</span></span><br><span class="line">    Eigen::Isometry3d transform = Eigen::Isometry3d::<span class="built_in">Identity</span>();</span><br><span class="line">    transform.<span class="built_in">translation</span>() = Eigen::<span class="built_in">Vector3d</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line">    transform.<span class="built_in">rotate</span>(Eigen::<span class="built_in">AngleAxisd</span>(M_PI / <span class="number">4.0</span>, Eigen::Vector3d::<span class="built_in">UnitX</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取平移部分和旋转部分</span></span><br><span class="line">    Eigen::Vector3d translation = transform.<span class="built_in">translation</span>();</span><br><span class="line">    Eigen::Matrix3d rotation = transform.<span class="built_in">rotation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;平移部分：&quot;</span> &lt;&lt; translation.<span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;旋转部分：&quot;</span> &lt;&lt; std::endl &lt;&lt; rotation &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取等距变换的矩阵表示</span></span><br><span class="line">    Eigen::Matrix4d transform_matrix = transform.<span class="built_in">matrix</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;等距变换矩阵：&quot;</span> &lt;&lt; std::endl &lt;&lt; transform_matrix &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们创建了一个等距变换对象，并使用成员函数设置其平移部分和旋转部分。然后，我们分别获取了平移部分和旋转部分，并输出了等距变换的矩阵表示。</p>
<p><code>Eigen::Isometry3d</code> 类是Eigen库中用于表示三维等距变换的重要工具。它允许您方便地表示和操作物体在三维空间中的姿态和位置，这在机器人学、计算机图形学和仿真等领域中非常有用。</p>
<h2 id="Eigen-AngleAxisd-类-详解"><a href="#Eigen-AngleAxisd-类-详解" class="headerlink" title="Eigen::AngleAxisd 类 详解"></a>Eigen::AngleAxisd 类 详解</h2><p><code>Eigen::AngleAxisd</code> 是Eigen库中的一个类，用于表示轴角（Axis-Angle）形式的旋转。轴角表示是一种用于描述三维空间中的旋转的常见方式，它包括一个旋转轴和一个旋转角度。该类位于Eigen库的Eigen&#x2F;Geometry模块中。</p>
<p>以下是关于 <code>Eigen::AngleAxisd</code> 类的详细信息：</p>
<p><strong>构造函数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Eigen::<span class="built_in">AngleAxisd</span>(<span class="type">const</span> Scalar&amp; angle, <span class="type">const</span> Vector3d&amp; axis)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>angle</code>：旋转角度，以弧度表示。</li>
<li><code>axis</code>：旋转轴的单位向量。</li>
</ul>
<p>构造函数用于创建一个轴角表示的旋转，指定旋转角度和旋转轴。</p>
<p><strong>成员函数</strong>：</p>
<ol>
<li><p><code>angle()</code>：<br>返回轴角表示中的旋转角度（以弧度表示）。</p>
</li>
<li><p><code>axis()</code>：<br>返回轴角表示中的旋转轴，它是一个单位向量。</p>
</li>
<li><p><code>toRotationMatrix()</code>：<br>将轴角表示转换为旋转矩阵（<code>Eigen::Matrix3d</code>），这个矩阵可以用于执行坐标变换。</p>
</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Geometry&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建轴角表示的旋转（绕X轴旋转45度）</span></span><br><span class="line">    <span class="function">Eigen::AngleAxisd <span class="title">rotation</span><span class="params">(M_PI / <span class="number">4.0</span>, Eigen::Vector3d::UnitX())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取旋转角度和旋转轴</span></span><br><span class="line">    <span class="type">double</span> angle = rotation.<span class="built_in">angle</span>();</span><br><span class="line">    Eigen::Vector3d axis = rotation.<span class="built_in">axis</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;旋转角度 (弧度): &quot;</span> &lt;&lt; angle &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;旋转轴: &quot;</span> &lt;&lt; axis.<span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将轴角表示转换为旋转矩阵</span></span><br><span class="line">    Eigen::Matrix3d rotation_matrix = rotation.<span class="built_in">toRotationMatrix</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;旋转矩阵：&quot;</span> &lt;&lt; std::endl &lt;&lt; rotation_matrix &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们创建了一个轴角表示的旋转对象，并使用成员函数获取旋转角度和旋转轴。然后，我们使用 <code>toRotationMatrix()</code> 函数将轴角表示转换为旋转矩阵。</p>
<p><code>Eigen::AngleAxisd</code> 类是Eigen库中用于处理轴角旋转的重要工具，它使您能够方便地表示和操作旋转信息。您可以使用旋转矩阵来执行坐标变换，或将其与其他旋转进行组合。这对于机器人学、计算机图形学和仿真等领域非常有用。</p>
<h2 id="Eigen-Matrix3d-数据结构-详解"><a href="#Eigen-Matrix3d-数据结构-详解" class="headerlink" title="Eigen::Matrix3d 数据结构 详解"></a>Eigen::Matrix3d 数据结构 详解</h2><p><code>Eigen::Matrix3d</code> 是Eigen库中的一个数据结构，表示一个3x3的矩阵，其中<code>d</code>表示矩阵元素的数据类型为<code>double</code>。Eigen库是一个用于线性代数操作的C++库，提供了高性能的矩阵和向量运算，特别适用于数学和科学计算。</p>
<p><code>Eigen::Matrix3d</code> 可以用来表示各种线性代数和几何学中的3x3矩阵，如旋转矩阵、变换矩阵、协方差矩阵等。这个数据结构在计算机图形学、机器人学、物理模拟等领域中经常被使用。</p>
<p>以下是一些关于<code>Eigen::Matrix3d</code>的详细信息和常见操作：</p>
<ol>
<li><p><strong>构造函数</strong>：您可以使用多种构造函数创建<code>Eigen::Matrix3d</code>对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix3d mat1; <span class="comment">// 默认构造函数，创建零矩阵</span></span><br><span class="line"><span class="function">Eigen::Matrix3d <span class="title">mat2</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>)</span></span>; <span class="comment">// 从给定的元素创建矩阵</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>元素访问</strong>：您可以通过行和列索引来访问矩阵的元素。Eigen库支持使用<code>(i, j)</code>或<code>i</code>、<code>j</code>索引方式，其中<code>(i, j)</code>表示第<code>i</code>行、第<code>j</code>列的元素，<code>i</code>和<code>j</code>从0开始。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> element = <span class="built_in">mat2</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 访问第2行第3列的元素</span></span><br><span class="line"><span class="type">double</span> element_row_col = mat<span class="number">2.</span><span class="built_in">row</span>(<span class="number">1</span>)[<span class="number">2</span>]; <span class="comment">// 也可以使用行和列的方式访问</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>矩阵运算</strong>：您可以对<code>Eigen::Matrix3d</code>对象执行各种矩阵运算，如矩阵加法、矩阵乘法、矩阵转置等。Eigen库提供了丰富的运算符重载和成员函数来进行这些操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix3d result = mat1 + mat2; <span class="comment">// 矩阵加法</span></span><br><span class="line">Eigen::Matrix3d product = mat1 * mat2; <span class="comment">// 矩阵乘法</span></span><br><span class="line">Eigen::Matrix3d transposed = mat<span class="number">1.</span><span class="built_in">transpose</span>(); <span class="comment">// 矩阵转置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>单位矩阵</strong>：您可以使用<code>Eigen::Matrix3d::Identity()</code>来创建一个单位矩阵。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix3d identity = Eigen::Matrix3d::<span class="built_in">Identity</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>行和列操作</strong>：Eigen库提供了许多操作来处理矩阵的行和列，如获取行、列、设置行、列等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3d row_vector = mat<span class="number">2.</span><span class="built_in">row</span>(<span class="number">1</span>); <span class="comment">// 获取第2行</span></span><br><span class="line">Eigen::Vector3d col_vector = mat<span class="number">2.</span><span class="built_in">col</span>(<span class="number">2</span>); <span class="comment">// 获取第3列</span></span><br><span class="line">mat<span class="number">2.</span><span class="built_in">row</span>(<span class="number">0</span>) = Eigen::<span class="built_in">Vector3d</span>(<span class="number">10.0</span>, <span class="number">20.0</span>, <span class="number">30.0</span>); <span class="comment">// 设置第1行的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>其他操作</strong>：Eigen库还提供了许多其他操作，如求逆、行列式计算、特征值分解等。</p>
</li>
</ol>
<p><code>Eigen::Matrix3d</code> 是Eigen库中一个非常有用的数据结构，用于表示和处理3x3矩阵数据。您可以使用它来执行各种线性代数和几何计算。Eigen库还支持其他矩阵大小的数据结构，如<code>Eigen::Matrix4d</code>、<code>Eigen::MatrixXd</code>（动态大小矩阵）等，以满足不同的需求。</p>
<h2 id="Eigen-Vector3d-数据结构-详解"><a href="#Eigen-Vector3d-数据结构-详解" class="headerlink" title="Eigen::Vector3d  数据结构 详解"></a>Eigen::Vector3d  数据结构 详解</h2><p><code>Eigen::Vector3d</code> 是Eigen库中的一个数据结构，表示三维向量，其中<code>d</code>表示向量元素的数据类型为<code>double</code>。Eigen库是一个用于线性代数操作的C++库，提供了高性能的矩阵和向量运算，特别适用于数学和科学计算。</p>
<p><code>Eigen::Vector3d</code> 表示一个包含三个<code>double</code>类型元素的向量，通常用于表示三维空间中的位置、方向或其他三维向量数据。这个数据结构在机器人学、计算机图形学、物理模拟等领域中经常被使用。</p>
<p>以下是一些关于<code>Eigen::Vector3d</code>的详细信息和常见操作：</p>
<ol>
<li><p><strong>构造函数</strong>：您可以使用多种构造函数创建<code>Eigen::Vector3d</code>对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3d v1;           <span class="comment">// 默认构造函数，创建零向量 (0, 0, 0)</span></span><br><span class="line"><span class="function">Eigen::Vector3d <span class="title">v2</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>; <span class="comment">// 从给定的元素创建向量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>元素访问</strong>：您可以通过下标或成员函数来访问向量的元素。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = v2[<span class="number">0</span>]; <span class="comment">// 访问第一个元素（x坐标）</span></span><br><span class="line"><span class="type">double</span> y = v2[<span class="number">1</span>]; <span class="comment">// 访问第二个元素（y坐标）</span></span><br><span class="line"><span class="type">double</span> z = v2[<span class="number">2</span>]; <span class="comment">// 访问第三个元素（z坐标）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用成员函数</span></span><br><span class="line"><span class="type">double</span> x = v<span class="number">2.</span><span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> y = v<span class="number">2.</span><span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> z = v<span class="number">2.</span><span class="built_in">z</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>向量运算</strong>：您可以对<code>Eigen::Vector3d</code>对象执行各种向量运算，如加法、减法、点积、叉积等。Eigen库提供了丰富的运算符重载和成员函数来进行这些操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3d result = v1 + v2; <span class="comment">// 向量加法</span></span><br><span class="line">Eigen::Vector3d diff = v1 - v2;   <span class="comment">// 向量减法</span></span><br><span class="line"><span class="type">double</span> dot_product = v<span class="number">1.</span><span class="built_in">dot</span>(v2);  <span class="comment">// 点积</span></span><br><span class="line">Eigen::Vector3d cross_product = v<span class="number">1.</span><span class="built_in">cross</span>(v2); <span class="comment">// 叉积</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>归一化</strong>：您可以使用成员函数将向量归一化为单位向量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v<span class="number">2.</span><span class="built_in">normalize</span>(); <span class="comment">// 归一化v2为单位向量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>长度和距离</strong>：您可以使用成员函数计算向量的长度（模）或两个点之间的距离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> length = v<span class="number">2.</span><span class="built_in">norm</span>(); <span class="comment">// 向量的长度</span></span><br><span class="line"><span class="type">double</span> distance = (v1 - v2).<span class="built_in">norm</span>(); <span class="comment">// 两个点之间的距离</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>其他操作</strong>：Eigen库提供了许多其他操作，如向量的投影、反射、角度计算等。</p>
</li>
</ol>
<p><code>Eigen::Vector3d</code> 是Eigen库中一个非常有用的数据结构，用于表示和处理三维向量数据。您可以使用它来执行各种线性代数和几何计算。注意，Eigen库支持其他数据类型的向量，如<code>Eigen::Vector3f</code>（<code>float</code>类型元素）和<code>Eigen::Vector3i</code>（<code>int</code>类型元素）等，以满足不同的需求。</p>
<h2 id="Eigen-Vector3f-详解"><a href="#Eigen-Vector3f-详解" class="headerlink" title="Eigen::Vector3f 详解"></a>Eigen::Vector3f 详解</h2><p>在C++中，Eigen是一个开源的线性代数库，用于高效地进行矩阵和向量计算。<code>Eigen::Vector3f</code>是Eigen库中表示三维浮点数向量的数据类型。</p>
<p>下面是对<code>Eigen::Vector3f</code>的详细解释：</p>
<ol>
<li><p><strong>Eigen库</strong>：<br>Eigen是一个C++模板库，专注于线性代数运算。它提供了各种矩阵和向量操作，包括基本的线性代数运算、矩阵分解、特征值计算等。Eigen的设计目标是高性能和表达力，适用于各种科学计算和工程应用。</p>
</li>
<li><p><strong>Eigen::Vector3f</strong>：<br><code>Eigen::Vector3f</code>是Eigen库中的一个模板类，表示一个三维浮点数向量。这个向量类包含了三个浮点数字段，分别表示向量的 x、y 和 z 分量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3f v;  <span class="comment">// 声明一个三维浮点数向量</span></span><br><span class="line">v &lt;&lt; <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>; <span class="comment">// 设置向量的 x、y 和 z 分量</span></span><br></pre></td></tr></table></figure>

<p>在Eigen中，向量和矩阵都是模板类，它们提供了许多重载的操作符和函数，使得线性代数运算变得方便和高效。</p>
<p>使用<code>Eigen::Vector3f</code>时，您可以执行向量加法、减法、点积、叉积、标量乘法等操作，以及其他线性代数运算。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Eigen::Vector3f <span class="title">v1</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">v2</span><span class="params">(<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Eigen::Vector3f sum = v1 + v2;</span><br><span class="line"><span class="type">float</span> dotProduct = v<span class="number">1.</span><span class="built_in">dot</span>(v2);</span><br><span class="line">Eigen::Vector3f crossProduct = v<span class="number">1.</span><span class="built_in">cross</span>(v2);</span><br></pre></td></tr></table></figure>

<p>此外，Eigen还提供了丰富的线性代数函数，使您能够执行向量的归一化、取模、求距离、求角度等操作。</p>
</li>
</ol>
<p>总之，<code>Eigen::Vector3f</code>是Eigen库中用于表示三维浮点数向量的类型。它是Eigen库在处理线性代数运算时的基本构建块之一，方便高效地进行各种向量计算和分析。</p>
<h2 id="Eigen-是什么"><a href="#Eigen-是什么" class="headerlink" title="Eigen 是什么"></a>Eigen 是什么</h2><p>Eigen是一个用于线性代数运算的C++模板库。它提供了许多用于向量、矩阵、数组和其他线性代数对象的数学运算和操作。Eigen是一个开源库，具有高性能和易用性的特点，广泛用于科学计算、图形学、机器学习和机器人等领域。</p>
<p>以下是Eigen库的一些特点：</p>
<ol>
<li><p>高性能：Eigen通过使用表达式模板技术和编译时优化，能够生成高效的代码，提供快速的数值计算。</p>
</li>
<li><p>简洁易用：Eigen提供了简洁的API，使得进行线性代数运算变得直观和易于理解。它支持类似于数学符号的语法，使得代码更加清晰和可读。</p>
</li>
<li><p>丰富的功能：Eigen提供了广泛的线性代数运算功能，包括矩阵和向量的基本运算（如加法、乘法、转置等）、线性方程求解、特征值计算、奇异值分解、矩阵分解等。</p>
</li>
<li><p>跨平台支持：Eigen是一个纯头文件库，没有外部依赖，可以方便地在不同的操作系统和编译器上使用。</p>
</li>
<li><p>可扩展性：Eigen支持自定义类型和运算，可以与现有的代码和数据结构集成，并方便地扩展功能。</p>
</li>
</ol>
<p>Eigen的语法和用法类似于数学符号，使得编写线性代数相关的代码更加直观和易于维护。它被广泛应用于科学计算、机器学习、计算机图形学等领域，是C++中进行线性代数运算的常用工具库之一。</p>
<p>总结来说，Eigen是一个高性能、易用且功能丰富的C++线性代数库，用于进行矩阵、向量和其他线性代数对象的数学运算。</p>
<hr>
<h2 id="Eigen-详解"><a href="#Eigen-详解" class="headerlink" title="Eigen 详解"></a>Eigen 详解</h2><p>Eigen是一个C++模板库，用于进行线性代数运算和数值计算。它提供了丰富的线性代数功能，包括矩阵和向量的基本运算、线性方程求解、特征值计算、奇异值分解、矩阵分解等。以下是Eigen库的一些详细解释：</p>
<ol>
<li><p>数据结构：Eigen库通过模板类来定义不同类型的线性代数对象，如矩阵（Matrix）、向量（Vector）、数组（Array）等。这些对象可以具有不同的维度和数据类型，如动态大小或静态大小的矩阵。</p>
</li>
<li><p>数学运算：Eigen提供了大量的数学运算操作符和函数，使得进行线性代数运算变得方便和直观。例如，你可以使用运算符进行矩阵和向量的加法、减法、乘法和除法操作，还可以进行转置、逆矩阵、点积、叉积等运算。</p>
</li>
<li><p>线性方程求解：Eigen提供了多种方法来求解线性方程组，包括常规的LU分解、QR分解、Cholesky分解等。你可以使用这些方法来解决线性方程组、最小二乘问题和最小化问题等。</p>
</li>
<li><p>特征值和奇异值计算：Eigen支持计算矩阵的特征值和特征向量，以及奇异值分解。这些计算对于矩阵的分析和特征提取非常有用。</p>
</li>
<li><p>矩阵分解：Eigen提供了多种矩阵分解的方法，如LU分解、QR分解、Cholesky分解等。这些分解方法可以用于解决矩阵方程、计算矩阵的逆等问题。</p>
</li>
<li><p>数值计算性能：Eigen通过使用表达式模板技术和编译时优化，生成高效的代码，提供了出色的数值计算性能。它能够自动进行向量化和并行化处理，以充分利用现代计算机的硬件特性。</p>
</li>
<li><p>跨平台支持：Eigen是一个纯头文件库，没有外部依赖，可以在不同的操作系统和编译器上进行使用。它与标准的C++语法和库相容，易于集成到现有的C++项目中。</p>
</li>
</ol>
<p>Eigen是一个广泛应用于科学计算、机器学习、计算机图形学等领域的工具库。它提供了强大的线性代数功能和高性能的数值计算能力，使得进行复杂的数学运算变得更加简单和高效。</p>
<p>如果你需要更详细的信息和示例代码，可以参考Eigen官方文档和示例。</p>
<hr>
<h2 id="Eigen-官网"><a href="#Eigen-官网" class="headerlink" title="Eigen 官网"></a>Eigen 官网</h2><p>Eigen的官方网站是：<a target="_blank" rel="noopener" href="https://eigen.tuxfamily.org/">https://eigen.tuxfamily.org/</a></p>
<p>在Eigen官网上，你可以找到关于Eigen库的详细文档、示例代码、教程和其他资源。以下是一些在Eigen官网上可以找到的主要内容：</p>
<ol>
<li><p>文档：Eigen官网提供了全面的文档，包括用户手册、快速入门指南、API参考等。文档详细介绍了Eigen库的各个方面，包括使用方法、功能特性、使用示例等。</p>
</li>
<li><p>示例代码：Eigen官网提供了大量的示例代码，涵盖了各种线性代数运算和数值计算的常见用法。这些示例代码可以帮助你快速上手并理解Eigen库的使用方法。</p>
</li>
<li><p>教程：Eigen官网上提供了一些教程和指南，帮助你深入了解Eigen库的内部机制和高级功能。这些教程涵盖了Eigen的设计原理、性能优化技巧、高级数学运算等方面的内容。</p>
</li>
<li><p>下载和安装：Eigen官网提供了源代码的下载链接和安装指南。你可以根据自己的需要下载适合的版本，并按照安装指南进行配置和编译。</p>
</li>
<li><p>社区和支持：Eigen官网上有用户论坛和邮件列表，你可以在这里与其他用户交流经验、提问问题和寻求帮助。此外，官方网站还提供了联系开发团队的方式，以便于反馈bug、提供反馈和建议等。</p>
</li>
</ol>
<p>通过Eigen官方网站，你可以获取关于Eigen库的最新信息、更新、支持和社区交流。如果你对Eigen库有兴趣或需要使用它进行线性代数运算和数值计算，官方网站是一个很好的起点。</p>
<p>请注意，由于网站内容可能会有更新，建议你访问Eigen官方网站以获取最新的信息和资源。</p>
<hr>
<h2 id="Eigen-示例"><a href="#Eigen-示例" class="headerlink" title="Eigen 示例"></a>Eigen 示例</h2><p>以下是一个简单的示例，展示了Eigen库的基本用法和一些常见的线性代数运算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建矩阵</span></span><br><span class="line">    Eigen::Matrix3f A;</span><br><span class="line">    A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建向量</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解线性方程 Ax = b</span></span><br><span class="line">    Eigen::Vector3f x = A.<span class="built_in">lu</span>().<span class="built_in">solve</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Solution:\n&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算特征值和特征向量</span></span><br><span class="line">    <span class="function">Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix3f&gt; <span class="title">eigensolver</span><span class="params">(A)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (eigensolver.<span class="built_in">info</span>() != Eigen::Success) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to compute eigenvalues!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Eigenvalues:\n&quot;</span> &lt;&lt; eigensolver.<span class="built_in">eigenvalues</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Eigenvectors:\n&quot;</span> &lt;&lt; eigensolver.<span class="built_in">eigenvectors</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了一个3x3的矩阵A和一个3维向量b。然后，使用A.lu().solve(b)求解线性方程Ax &#x3D; b，得到解x。我们输出了解x的值。</p>
<p>接下来，我们使用Eigen库的SelfAdjointEigenSolver来计算矩阵A的特征值和特征向量。通过eigensolver.eigenvalues()和eigensolver.eigenvectors()，我们分别获取了特征值和特征向量，并将它们输出到控制台。</p>
<p>请确保在使用这个示例之前，已经正确安装了Eigen库，并将其包含路径配置正确。</p>
<p>这只是Eigen库的一个简单示例，Eigen库还提供了许多其他功能和操作，如矩阵乘法、逆矩阵、奇异值分解等。你可以在Eigen的官方文档和示例中找到更多详细的用法和示例代码。</p>
<hr>
<h2 id="Eigen-安装第三方库"><a href="#Eigen-安装第三方库" class="headerlink" title="Eigen 安装第三方库"></a>Eigen 安装第三方库</h2><p>在Linux系统上安装Eigen库可以按照以下步骤进行操作：</p>
<ol>
<li><p>打开终端，并确保你的系统已经安装了C++编译器和CMake工具。</p>
</li>
<li><p>下载Eigen库的源代码。你可以从Eigen的官方网站（<a target="_blank" rel="noopener" href="https://eigen.tuxfamily.org/%EF%BC%89%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9%E5%8C%85%EF%BC%8C%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8Git%E8%BF%9B%E8%A1%8C%E5%85%8B%E9%9A%86%E3%80%82">https://eigen.tuxfamily.org/）下载最新版本的源代码压缩包，或者使用Git进行克隆。</a></p>
<p>例如，使用Git进行克隆：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.com/libeigen/eigen.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入Eigen源代码的目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd eigen</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个用于构建Eigen库的目录，并进入该目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行CMake命令生成构建文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用make命令进行编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>（可选）运行make install命令将库安装到系统目录中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>注意：执行<code>make install</code>命令可能需要root权限。</p>
</li>
</ol>
<p>现在，你已经成功在Linux系统上安装了Eigen库。你可以在自己的C++项目中包含Eigen的头文件，并链接Eigen库进行使用。</p>
<p>例如，在你的C++源文件中，使用以下方式包含Eigen的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>然后，你就可以使用Eigen库提供的各种功能进行线性代数运算和数值计算了。</p>
<p>请注意，安装过程中的具体命令可能会因系统环境和Eigen库的版本而有所不同。建议在安装过程中仔细阅读Eigen的文档，并按照其中的指导进行操作。</p>
<p>另外，如果你使用的是特定的Linux发行版，也可以尝试通过包管理器安装Eigen库。例如，使用apt包管理器安装Eigen：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libeigen3-dev</span><br></pre></td></tr></table></figure>

<p>这将自动安装Eigen库及其相关的开发文件到系统中，使你能够在C++项目中直接使用Eigen库。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>在使用Eigen库时，你可以根据需要包含不同的头文件。以下是一些常用的Eigen头文件：</p>
<ol>
<li><p><code>Eigen/Dense</code>：包含了Eigen库的核心功能，如矩阵、向量和数组的定义和运算符重载。</p>
</li>
<li><p><code>Eigen/Core</code>：提供了Eigen库的基本功能和类型定义，是<code>Eigen/Dense</code>头文件的核心部分。</p>
</li>
<li><p><code>Eigen/Eigenvalues</code>：包含了计算矩阵特征值和特征向量的功能。</p>
</li>
<li><p><code>Eigen/SVD</code>：提供了奇异值分解（Singular Value Decomposition，SVD）的功能。</p>
</li>
<li><p><code>Eigen/QR</code>：提供了QR分解的功能。</p>
</li>
<li><p><code>Eigen/LU</code>：提供了LU分解的功能。</p>
</li>
<li><p><code>Eigen/Cholesky</code>：提供了Cholesky分解的功能。</p>
</li>
<li><p><code>Eigen/Geometry</code>：包含了用于几何计算的功能，如旋转矩阵、变换矩阵等。</p>
</li>
</ol>
<p>这只是一小部分常用的Eigen头文件。根据你的具体需求，你可能还需要包含其他特定的头文件。Eigen库的头文件结构清晰，你可以根据你的具体使用情况选择包含适当的头文件。</p>
<p>例如，在你的C++源文件中，你可以按照以下方式包含Eigen库的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span>          <span class="comment">// 包含核心功能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Eigenvalues&gt;</span>    <span class="comment">// 计算特征值和特征向量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/SVD&gt;</span>            <span class="comment">// 奇异值分解</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/QR&gt;</span>             <span class="comment">// QR分解</span></span></span><br></pre></td></tr></table></figure>

<p>请注意，在包含Eigen库的头文件之前，确保你已经正确安装并配置了Eigen库。同时，根据你的操作系统和安装方式，可能需要调整头文件的路径。</p>
<p>希望这些信息能帮助你使用Eigen库进行C++编程！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
