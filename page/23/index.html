<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/23/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/23/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_10_cstring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_10_cstring/" class="post-title-link" itemprop="url">C++_10_10_cstring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <cstring>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <cstring>标准库</h2><p><code>&lt;cstring&gt;</code> 是 C++ 标准库中的头文件，它提供了一系列对 C 风格字符串（以 null 结尾的字符数组）进行操作的函数和工具。</p>
<p>以下是 <code>&lt;cstring&gt;</code> 头文件中常见的函数及其功能：</p>
<ol>
<li><p><strong>字符串操作函数</strong>：</p>
<ul>
<li><code>strcpy()</code>：将一个字符串复制到另一个字符串中。</li>
<li><code>strncpy()</code>：将指定长度的字符串复制到另一个字符串中。</li>
<li><code>strcat()</code>：将一个字符串连接到另一个字符串的末尾。</li>
<li><code>strncat()</code>：将指定长度的字符串连接到另一个字符串的末尾。</li>
<li><code>strlen()</code>：返回字符串的长度。</li>
<li><code>strcmp()</code>：比较两个字符串。</li>
<li><code>strncmp()</code>：比较两个字符串的指定长度部分。</li>
<li><code>strchr()</code>：在字符串中查找指定字符的第一个出现位置。</li>
<li><code>strrchr()</code>：在字符串中查找指定字符的最后一个出现位置。</li>
<li><code>strstr()</code>：在字符串中查找子串的第一个出现位置。</li>
<li><code>strtok()</code>：将字符串分割成标记（token）。</li>
<li><code>strpbrk()</code>：在字符串中查找任意字符集中的任意字符第一次出现的位置。</li>
</ul>
</li>
<li><p><strong>字符串内存操作函数</strong>：</p>
<ul>
<li><code>memset()</code>：将内存块设置为指定的值。</li>
<li><code>memcpy()</code>：将一个内存区块的内容拷贝到另一个内存区块。</li>
<li><code>memmove()</code>：将内存区块的内容移动到另一个内存区块。</li>
<li><code>memcmp()</code>：比较两个内存区块。</li>
</ul>
</li>
</ol>
<p>这些函数提供了对字符串进行复制、连接、比较、搜索以及内存块操作等一系列常用操作的功能。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>以下是一个简单的示例，展示了 <code>&lt;cstring&gt;</code> 头文件中的一些函数的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝字符串</span></span><br><span class="line">    <span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(dest, str1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Copied string: &quot;</span> &lt;&lt; dest &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接字符串</span></span><br><span class="line">    std::<span class="built_in">strcat</span>(dest, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    std::<span class="built_in">strcat</span>(dest, str2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Concatenated string: &quot;</span> &lt;&lt; dest &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较字符串</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">strcmp</span>(str1, str2) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Strings are different.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找子串</span></span><br><span class="line">    <span class="type">char</span>* sub_str = std::<span class="built_in">strstr</span>(dest, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sub_str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found substring: &quot;</span> &lt;&lt; sub_str &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-strcpy"><a href="#std-strcpy" class="headerlink" title="std::strcpy()"></a>std::strcpy()</h2><p><code>std::strcpy()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于将一个字符串（以 null 结尾的字符数组）复制到另一个字符串中。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>dest</code>：指向目标字符数组的指针，接收源字符串的内容。要确保目标字符数组足够大，能够容纳源字符串的内容。</li>
<li><code>src</code>：指向源字符串的指针，要被复制到目标字符数组中的内容。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回一个指向目标字符数组 <code>dest</code> 的指针，即源字符串被复制后的字符串起始地址。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p><code>strcpy()</code> 函数将源字符串 <code>src</code> 的内容（包括结束符 <code>\0</code>）复制到目标字符数组 <code>dest</code> 中，直到遇到源字符串的结束符 <code>\0</code>。如果 <code>dest</code> 字符数组不够大，可能会导致缓冲区溢出，因此使用时需要确保目标字符数组足够大以容纳源字符串的内容。</p>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">strcpy</span>(destination, source);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Source string: &quot;</span> &lt;&lt; source &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destination string: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strcpy()</code> 函数被用来将 <code>source</code> 字符串的内容复制到 <code>destination</code> 字符数组中。复制后，<code>destination</code> 中存储了与 <code>source</code> 相同的字符串。</p>
<p>在此示例中，使用了一系列 <code>&lt;cstring&gt;</code> 中的函数来进行字符串的复制、拼接、比较和查找操作。<code>strcpy()</code> 用于复制字符串，<code>strcat()</code> 用于连接字符串，<code>strcmp()</code> 用于比较字符串，<code>strstr()</code> 用于在字符串中查找子串。</p>
<h2 id="std-strncpy"><a href="#std-strncpy" class="headerlink" title="std::strncpy()"></a>std::strncpy()</h2><p><code>std::strncpy()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于将一个字符串的指定长度复制到另一个字符串中。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strncpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>dest</code>：指向目标字符数组的指针，接收源字符串的内容。要确保目标字符数组足够大，能够容纳指定长度的源字符串内容。</li>
<li><code>src</code>：指向源字符串的指针，要被复制到目标字符数组中的内容。</li>
<li><code>count</code>：要复制的字符数，包括结束符 <code>\0</code>。如果 <code>count</code> 大于源字符串的长度，将在目标字符串中填充额外的 <code>\0</code> 以填满指定的长度。</li>
</ul>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回一个指向目标字符数组 <code>dest</code> 的指针，即源字符串的一部分被复制到了目标字符数组中。</li>
</ul>
<h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><p><code>strncpy()</code> 函数将源字符串 <code>src</code> 的指定长度（包括结束符 <code>\0</code>）复制到目标字符数组 <code>dest</code> 中。如果源字符串的长度小于 <code>count</code>，则剩余的部分将用 <code>\0</code> 填充，以确保目标字符数组的长度为 <code>count</code>。</p>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">strncpy</span>(destination, source, <span class="number">5</span>); <span class="comment">// 复制 source 中的前5个字符到 destination</span></span><br><span class="line"></span><br><span class="line">    destination[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 手动添加 null 结尾字符，确保字符串正确结束</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Source string: &quot;</span> &lt;&lt; source &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destination string: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strncpy()</code> 函数被用来将 <code>source</code> 字符串的前5个字符复制到 <code>destination</code> 字符数组中。最后一个字符被设置为 <code>\0</code>，以确保字符串正确结束。</p>
<h2 id="std-strcat"><a href="#std-strcat" class="headerlink" title="std::strcat()"></a>std::strcat()</h2><p><code>std::strcat()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于将一个字符串连接到另一个字符串的末尾。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>dest</code>：指向目标字符数组的指针，包含源字符串，并将要连接的字符串追加到此字符串的末尾。要确保目标字符数组足够大，能够容纳源字符串和要连接的字符串。</li>
<li><code>src</code>：指向源字符串的指针，要被连接到目标字符串的末尾。</li>
</ul>
<h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回一个指向目标字符数组 <code>dest</code> 的指针，即连接后的字符串起始地址。</li>
</ul>
<h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h3><p><code>strcat()</code> 函数将源字符串 <code>src</code> 的内容（不包括结束符 <code>\0</code>）连接到目标字符数组 <code>dest</code> 的末尾，并添加 <code>\0</code> 作为连接后字符串的结束符。</p>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">strcat</span>(str1, str2);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Concatenated string: &quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strcat()</code> 函数被用来将 <code>str2</code> 字符串连接到 <code>str1</code> 字符数组的末尾，得到一个新的字符串。最终输出的结果为连接后的字符串 <code>&quot;Hello, World!&quot;</code>。请注意，在使用 <code>strcat()</code> 连接字符串时，确保目标字符数组有足够的空间来容纳连接后的结果。</p>
<h2 id="std-strncat"><a href="#std-strncat" class="headerlink" title="std::strncat()"></a>std::strncat()</h2><p><code>std::strncat()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于将源字符串的指定长度连接到另一个字符串的末尾。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strncat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>dest</code>：指向目标字符数组的指针，包含源字符串，并将要连接的部分字符串追加到此字符串的末尾。要确保目标字符数组足够大，能够容纳源字符串和要连接的部分字符串。</li>
<li><code>src</code>：指向源字符串的指针，要被连接到目标字符串的末尾。</li>
<li><code>count</code>：要连接的字符数，最多追加 <code>count</code> 个字符到目标字符数组中。</li>
</ul>
<h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回一个指向目标字符数组 <code>dest</code> 的指针，即连接后的字符串起始地址。</li>
</ul>
<h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h3><p><code>strncat()</code> 函数将源字符串 <code>src</code> 的指定长度（不包括结束符 <code>\0</code>）连接到目标字符数组 <code>dest</code> 的末尾，并添加 <code>\0</code> 作为连接后字符串的结束符。该函数将最多连接 <code>count</code> 个字符，但如果 <code>src</code> 中的字符串长度小于 <code>count</code>，则会连接完整的 <code>src</code> 字符串。</p>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">strncat</span>(str1, str2, <span class="number">3</span>); <span class="comment">// 仅连接 str2 的前3个字符</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Concatenated string: &quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strncat()</code> 函数被用来将 <code>str2</code> 字符串的前3个字符连接到 <code>str1</code> 字符数组的末尾，得到一个新的字符串。最终输出的结果为连接后的字符串 <code>&quot;Hello, Wor&quot;</code>。请确保目标字符数组有足够的空间来容纳连接后的结果。</p>
<h2 id="std-strlen"><a href="#std-strlen" class="headerlink" title="std::strlen()"></a>std::strlen()</h2><p><code>std::strlen()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于计算以 null 结尾的 C 风格字符串的长度，即字符串中的字符数量，不包括结尾的 null 终止符 <code>\0</code>。</p>
<h3 id="函数签名：-4"><a href="#函数签名：-4" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-4"><a href="#参数：-4" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：指向以 null 结尾的 C 风格字符串的指针。</li>
</ul>
<h3 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回字符串的长度，即字符串中的字符数量，不包括结尾的 null 终止符 <code>\0</code>。</li>
</ul>
<h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h3><p><code>strlen()</code> 函数会扫描参数 <code>str</code> 指向的字符串，直到遇到字符串结尾的 null 终止符 <code>\0</code>，然后返回字符串的实际长度，不包括结尾的 null 终止符。</p>
<h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> length = std::<span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Length of the string: &quot;</span> &lt;&lt; length &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strlen()</code> 函数被用来计算字符串 <code>&quot;Hello, World!&quot;</code> 的长度，即输出结果为字符串的字符数量（不包括结尾的 null 终止符），最终输出结果为字符串的长度为 <code>13</code>。</p>
<h2 id="std-strcmp"><a href="#std-strcmp" class="headerlink" title="std::strcmp()"></a>std::strcmp()</h2><p><code>std::strcmp()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于比较两个字符串。</p>
<h3 id="函数签名：-5"><a href="#函数签名：-5" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-5"><a href="#参数：-5" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str1</code>：指向第一个要比较的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>str2</code>：指向第二个要比较的以 null 结尾的 C 风格字符串的指针。</li>
</ul>
<h3 id="返回值：-5"><a href="#返回值：-5" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果两个字符串相同，则返回 <code>0</code>；如果第一个不同于第二个，返回其 ASCII 值差；如果第一个小于第二个，则返回一个负值；如果第一个大于第二个，则返回一个正值。</li>
</ul>
<h3 id="功能：-5"><a href="#功能：-5" class="headerlink" title="功能："></a>功能：</h3><p><code>strcmp()</code> 函数对比两个字符串 <code>str1</code> 和 <code>str2</code>，并按照字典顺序进行比较。它逐个比较两个字符串对应位置的字符，直到发现不同的字符或者遇到其中一个字符串的结束符 <code>\0</code>。</p>
<h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = std::<span class="built_in">strcmp</span>(str1, str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Strings are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String 1 is less than String 2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String 1 is greater than String 2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strcmp()</code> 函数被用来比较两个字符串 <code>&quot;Hello&quot;</code> 和 <code>&quot;World&quot;</code>。由于 <code>&quot;Hello&quot;</code> 在字典中排在 <code>&quot;World&quot;</code> 之前，所以输出结果为 <code>&quot;String 1 is less than String 2.&quot;</code>。</p>
<h2 id="std-strncmp"><a href="#std-strncmp" class="headerlink" title="std::strncmp()"></a>std::strncmp()</h2><p><code>std::strncmp()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于比较两个字符串的指定长度部分。</p>
<h3 id="函数签名：-6"><a href="#函数签名：-6" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-6"><a href="#参数：-6" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str1</code>：指向第一个要比较的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>str2</code>：指向第二个要比较的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>count</code>：要比较的字符数，即指定要比较的字符串部分的长度。</li>
</ul>
<h3 id="返回值：-6"><a href="#返回值：-6" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果两个字符串相同，则返回 <code>0</code>；如果第一个不同于第二个，返回其 ASCII 值差；如果第一个小于第二个，则返回一个负值；如果第一个大于第二个，则返回一个正值。</li>
</ul>
<h3 id="功能：-6"><a href="#功能：-6" class="headerlink" title="功能："></a>功能：</h3><p><code>strncmp()</code> 函数与 <code>strcmp()</code> 类似，但是 <code>strncmp()</code> 比较的字符数是通过参数 <code>count</code> 指定的。它逐个比较两个字符串相应位置的字符，直到达到指定的字符数 <code>count</code>、发现不同的字符或者遇到其中一个字符串的结束符 <code>\0</code>。</p>
<h3 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str2 = <span class="string">&quot;Help&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = std::<span class="built_in">strncmp</span>(str1, str2, <span class="number">3</span>); <span class="comment">// 比较前3个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First 3 characters of strings are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First 3 characters of String 1 are less than String 2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First 3 characters of String 1 are greater than String 2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strncmp()</code> 函数被用来比较两个字符串的前3个字符。因为在比较范围内，<code>&#39;l&#39;</code>（来自 <code>&quot;Hello&quot;</code>）在字典顺序上大于 <code>&#39;p&#39;</code>（来自 <code>&quot;Help&quot;</code>），所以输出结果为 <code>&quot;First 3 characters of String 1 are greater than String 2.&quot;</code>。</p>
<h2 id="std-strchr"><a href="#std-strchr" class="headerlink" title="std::strchr()"></a>std::strchr()</h2><p><code>std::strchr()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于在字符串中查找指定字符的第一次出现位置。</p>
<h3 id="函数签名：-7"><a href="#函数签名：-7" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> character)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-7"><a href="#参数：-7" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：指向要搜索的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>character</code>：要在字符串中查找的字符，作为整数值传递。通常使用字符的 ASCII 值作为参数传递。</li>
</ul>
<h3 id="返回值：-7"><a href="#返回值：-7" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果找到指定的字符，则返回一个指向该字符首次出现的位置的指针；如果未找到，则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="功能：-7"><a href="#功能：-7" class="headerlink" title="功能："></a>功能：</h3><p><code>strchr()</code> 函数在给定字符串 <code>str</code> 中搜索指定的字符 <code>character</code>，并返回第一次出现的位置（指针）。它从给定字符串的开头开始搜索，直到找到指定的字符或者遇到字符串结束符 <code>\0</code>。</p>
<h3 id="示例：-8"><a href="#示例：-8" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* position = std::<span class="built_in">strchr</span>(str, ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First occurrence of &#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; at position: &quot;</span> &lt;&lt; position - str &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strchr()</code> 函数被用来查找字符串 <code>&quot;Hello, World!&quot;</code> 中字符 <code>&#39;o&#39;</code> 的第一次出现位置。因为 <code>&#39;o&#39;</code> 第一次出现在索引为 4 的位置（字符串索引从 0 开始），所以输出结果为 <code>&quot;First occurrence of &#39;o&#39; at position: 4&quot;</code>。</p>
<h2 id="std-strrchr"><a href="#std-strrchr" class="headerlink" title="std::strrchr()"></a>std::strrchr()</h2><p><code>std::strrchr()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于在字符串中查找指定字符的最后一次出现位置。</p>
<h3 id="函数签名：-8"><a href="#函数签名：-8" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> character)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-8"><a href="#参数：-8" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：指向要搜索的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>character</code>：要在字符串中查找的字符，作为整数值传递。通常使用字符的 ASCII 值作为参数传递。</li>
</ul>
<h3 id="返回值：-8"><a href="#返回值：-8" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果找到指定的字符，则返回一个指向该字符最后一次出现的位置的指针；如果未找到，则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="功能：-8"><a href="#功能：-8" class="headerlink" title="功能："></a>功能：</h3><p><code>strrchr()</code> 函数在给定字符串 <code>str</code> 中从后向前搜索指定的字符 <code>character</code>，并返回最后一次出现的位置（指针）。它从字符串的结尾向开头搜索，直到找到指定的字符或者遇到字符串起始位置。</p>
<h3 id="示例：-9"><a href="#示例：-9" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* position = std::<span class="built_in">strrchr</span>(str, ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Last occurrence of &#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; at position: &quot;</span> &lt;&lt; position - str &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strrchr()</code> 函数被用来查找字符串 <code>&quot;Hello, World!&quot;</code> 中字符 <code>&#39;o&#39;</code> 的最后一次出现位置。因为 <code>&#39;o&#39;</code> 最后一次出现在索引为 8 的位置（字符串索引从 0 开始），所以输出结果为 <code>&quot;Last occurrence of &#39;o&#39; at position: 8&quot;</code>。</p>
<h2 id="std-strstr"><a href="#std-strstr" class="headerlink" title="std::strstr()"></a>std::strstr()</h2><p><code>std::strstr()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于在字符串中查找子串的第一次出现位置。</p>
<h3 id="函数签名：-9"><a href="#函数签名：-9" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* substr)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-9"><a href="#参数：-9" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：指向要搜索的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>substr</code>：指向要查找的以 null 结尾的 C 风格子串的指针。</li>
</ul>
<h3 id="返回值：-9"><a href="#返回值：-9" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果找到子串，则返回一个指向字符串 <code>str</code> 中子串 <code>substr</code> 第一次出现的位置的指针；如果未找到，则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="功能：-9"><a href="#功能：-9" class="headerlink" title="功能："></a>功能：</h3><p><code>strstr()</code> 函数在给定字符串 <code>str</code> 中搜索子串 <code>substr</code>，并返回子串第一次出现的位置（指针）。如果找到了子串，则返回子串第一次出现的位置的指针；如果未找到，则返回 <code>nullptr</code>。</p>
<h3 id="示例：-10"><a href="#示例：-10" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* substr = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* position = std::<span class="built_in">strstr</span>(str, substr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Substring found at position: &quot;</span> &lt;&lt; position - str &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Substring not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strstr()</code> 函数被用来查找字符串 <code>&quot;Hello, World!&quot;</code> 中子串 <code>&quot;World&quot;</code> 的第一次出现位置。由于 <code>&quot;World&quot;</code> 子串第一次出现在索引为 7 的位置（字符串索引从 0 开始），所以输出结果为 <code>&quot;Substring found at position: 7&quot;</code>。</p>
<h2 id="std-strtok"><a href="#std-strtok" class="headerlink" title="std::strtok()"></a>std::strtok()</h2><p><code>std::strtok()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于将字符串分割成标记（token）。</p>
<h3 id="函数签名：-10"><a href="#函数签名：-10" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strtok</span><span class="params">(<span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* delimiters)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-10"><a href="#参数：-10" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要分割的字符串。第一次调用时，传入要分割的字符串；在后续调用时，传入 <code>nullptr</code>。如果 <code>str</code> 不是 <code>nullptr</code>，则函数会修改这个字符串，将找到的分隔标记替换为 null 终止符 <code>\0</code>。</li>
<li><code>delimiters</code>：作为分隔标记的字符集合，表示分割字符串的分隔符。</li>
</ul>
<h3 id="返回值：-10"><a href="#返回值：-10" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果找到标记，则返回标记的指针；如果字符串结束或者没有找到标记，则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="功能：-10"><a href="#功能：-10" class="headerlink" title="功能："></a>功能：</h3><p><code>strtok()</code> 函数用于将字符串 <code>str</code> 根据指定的分隔符 <code>delimiters</code> 进行分割，返回每个分割出来的标记。第一次调用时，<code>str</code> 指向要分割的字符串，后续调用时传入 <code>nullptr</code> 继续分割。每次调用会返回找到的下一个标记，直到字符串结束或者没有找到更多标记。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>strtok()</code> 函数是非线程安全的，因为它使用了静态变量来存储上次分割的位置。在多线程环境中，可以使用 <code>strtok_r()</code>（POSIX 函数）或者其他替代方案。</li>
</ul>
<h3 id="示例：-11"><a href="#示例：-11" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, World! This is a test.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* token = std::<span class="built_in">strtok</span>(str, <span class="string">&quot; ,.!&quot;</span>); <span class="comment">// 分割字符集为空格、逗号和句号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Token: &quot;</span> &lt;&lt; token &lt;&lt; std::endl;</span><br><span class="line">        token = std::<span class="built_in">strtok</span>(<span class="literal">nullptr</span>, <span class="string">&quot; ,.!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strtok()</code> 函数用于将字符串 <code>&quot;Hello, World! This is a test.&quot;</code> 按照空格、逗号和句号作为分隔符进行分割。通过循环调用 <code>strtok()</code>，分别获取分割出来的标记，并输出每个标记。</p>
<h2 id="std-strpbrk"><a href="#std-strpbrk" class="headerlink" title="std::strpbrk()"></a>std::strpbrk()</h2><p><code>std::strpbrk()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于在字符串中查找任意字符集中的任意字符第一次出现的位置。</p>
<h3 id="函数签名：-11"><a href="#函数签名：-11" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strpbrk</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* charset)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-11"><a href="#参数：-11" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要搜索的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>charset</code>：作为搜索字符集合的字符串，包含了要在 <code>str</code> 中查找的字符。</li>
</ul>
<h3 id="返回值：-11"><a href="#返回值：-11" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果找到任意字符集中的任意字符，则返回第一个匹配的字符的指针；如果未找到，则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="功能：-11"><a href="#功能：-11" class="headerlink" title="功能："></a>功能：</h3><p><code>strpbrk()</code> 函数在给定字符串 <code>str</code> 中搜索 <code>charset</code> 中的任意字符，返回第一次出现的位置（指针）。它会从字符串的开头开始搜索，直到找到任意字符集中的字符或者遇到字符串结束符 <code>\0</code>。</p>
<h3 id="示例：-12"><a href="#示例：-12" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* charset = <span class="string">&quot;od!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* position = std::<span class="built_in">strpbrk</span>(str, charset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character found at position: &quot;</span> &lt;&lt; position - str &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strpbrk()</code> 函数被用来查找字符串 <code>&quot;Hello, World!&quot;</code> 中字符集 <code>&quot;od!&quot;</code> 中的任意字符第一次出现的位置。由于其中字符 <code>&#39;o&#39;</code> 第一次出现在索引为 4 的位置（字符串索引从 0 开始），所以输出结果为 <code>&quot;Character found at position: 4&quot;</code>。</p>
<h2 id="std-memcpy"><a href="#std-memcpy" class="headerlink" title="std::memcpy"></a>std::memcpy</h2><p><code>std::memcpy</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中定义的函数，用于在内存块之间复制一定数量的字节。</p>
<p>其基本原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, std::<span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dest</code>：目标内存块的起始地址，数据将被复制到这个地址。</li>
<li><code>src</code>：源内存块的起始地址，数据将从这个地址复制到目标内存块。</li>
<li><code>count</code>：要复制的字节数。</li>
</ul>
<p><code>std::memcpy</code> 主要用于进行内存的原始字节级别的拷贝操作。它是一种直接的、快速的内存拷贝方式，通常用于复制大块的内存数据。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">memcpy</span>(destination, source, std::<span class="built_in">strlen</span>(source) + <span class="number">1</span>); <span class="comment">// 复制 source 到 destination</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Copied string: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::memcpy</code> 用于将源字符串 <code>source</code> 复制到目标字符串 <code>destination</code>，包括字符串结尾的 null 终止符。要确保目标内存块足够大以容纳源内存块的数据。</p>
<h2 id="std-memset"><a href="#std-memset" class="headerlink" title="std::memset()"></a>std::memset()</h2><p><code>std::memset()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中定义的函数，用于设置指定内存区域的内容为指定的值。</p>
<p>其基本原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memset</span><span class="params">(<span class="type">void</span>* dest, <span class="type">int</span> value, std::<span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dest</code>：要设置值的内存区域的起始地址。</li>
<li><code>value</code>：要设置的值，通常是一个整数（<code>int</code> 类型），会被转换为无符号字符进行设置。</li>
<li><code>count</code>：要设置的字节数。</li>
</ul>
<p><code>std::memset()</code> 将 <code>value</code> 的值复制到 <code>dest</code> 指向的内存区域的前 <code>count</code> 个字节。通常情况下，它用于初始化内存块为特定的值，比如初始化数组、清除缓冲区等。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">memset</span>(buffer, <span class="string">&#x27;A&#x27;</span>, <span class="built_in">sizeof</span>(buffer)); <span class="comment">// 将 buffer 内存区域的内容设置为字符 &#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Buffer after memset: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::memset()</code> 将字符 <code>&#39;A&#39;</code> 设置到 <code>buffer</code> 内存区域的每个字节中。要注意，<code>std::memset()</code> 是按字节进行操作，并不会处理字符数组或字符串的结尾 null 终止符。</p>
<h2 id="std-memmove"><a href="#std-memmove" class="headerlink" title="std::memmove()"></a>std::memmove()</h2><p><code>std::memmove()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于在内存块之间移动一定数量的字节，即使这两个内存块有重叠。</p>
<h3 id="函数签名：-12"><a href="#函数签名：-12" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memmove</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-12"><a href="#参数：-12" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>dest</code>：指向目标内存区域的指针，表示要移动数据的目标位置。</li>
<li><code>src</code>：指向源内存区域的指针，表示要从哪里复制数据。</li>
<li><code>count</code>：要移动的字节数。</li>
</ul>
<h3 id="返回值：-12"><a href="#返回值：-12" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回指向目标内存区域的指针。</li>
</ul>
<h3 id="功能：-12"><a href="#功能：-12" class="headerlink" title="功能："></a>功能：</h3><p><code>memmove()</code> 函数用于从源地址 <code>src</code> 复制 <code>count</code> 个字节的数据到目标地址 <code>dest</code>。这个函数可以处理源地址和目标地址的内存重叠情况，保证在复制数据时不会出错。</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>memmove()</code> 函数比 <code>memcpy()</code> 更安全，因为它可以正确处理内存区域的重叠。对于无重叠的内存区域，<code>memcpy()</code> 和 <code>memmove()</code> 的功能基本相同。</li>
</ul>
<h3 id="示例：-13"><a href="#示例：-13" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before memmove: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动字符串中的一部分数据，模拟向左移动6个字符</span></span><br><span class="line">    std::<span class="built_in">memmove</span>(str + <span class="number">5</span>, str + <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After memmove: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>memmove()</code> 函数被用来将字符串中的一部分数据向左移动了 6 个字符。原始字符串为 <code>&quot;Hello, World!&quot;</code>，经过 <code>memmove()</code> 处理后变为 <code>&quot;HelloWorld, World!&quot;</code>。</p>
<h2 id="std-memcmp"><a href="#std-memcmp" class="headerlink" title="std::memcmp()"></a>std::memcmp()</h2><p><code>std::memcmp()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于比较两个内存块的内容。</p>
<h3 id="函数签名：-13"><a href="#函数签名：-13" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* ptr1, <span class="type">const</span> <span class="type">void</span>* ptr2, <span class="type">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-13"><a href="#参数：-13" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>ptr1</code>：指向要比较的第一个内存块的指针。</li>
<li><code>ptr2</code>：指向要比较的第二个内存块的指针。</li>
<li><code>num</code>：要比较的字节数。</li>
</ul>
<h3 id="返回值：-13"><a href="#返回值：-13" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果两个内存块的内容相等，则返回 <code>0</code>。</li>
<li>如果第一个内存块的内容小于第二个内存块的内容，则返回负值。</li>
<li>如果第一个内存块的内容大于第二个内存块的内容，则返回正值。</li>
</ul>
<h3 id="功能：-13"><a href="#功能：-13" class="headerlink" title="功能："></a>功能：</h3><p><code>memcmp()</code> 函数用于按字节比较两个内存块的内容。它逐字节比较两个内存块的内容，直到比较完指定的字节数 <code>num</code> 或者发现第一个不相等的字节。返回比较结果。</p>
<h3 id="示例：-14"><a href="#示例：-14" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str3 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result1 = std::<span class="built_in">memcmp</span>(str1, str2, <span class="number">5</span>); <span class="comment">// 比较 str1 和 str2 的前5个字符</span></span><br><span class="line">    <span class="type">int</span> result2 = std::<span class="built_in">memcmp</span>(str1, str3, <span class="number">5</span>); <span class="comment">// 比较 str1 和 str3 的前5个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result1 == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str2 are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str2 are not equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result2 == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str3 are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str3 are not equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>memcmp()</code> 函数被用来比较字符串 <code>&quot;Hello&quot;</code> 和 <code>&quot;Hello&quot;</code> 以及 <code>&quot;Hello&quot;</code> 和 <code>&quot;World&quot;</code> 的前5个字符。由于前两个字符串相等，所以 <code>result1</code> 为 <code>0</code>，输出结果为 <code>&quot;str1 and str2 are equal.&quot;</code>；而第二个比较中，因为字符串不相等，所以 <code>result2</code> 不为 <code>0</code>，输出结果为 <code>&quot;str1 and str3 are not equal.&quot;</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_15_atomic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_15_atomic/" class="post-title-link" itemprop="url">C++_10_15_atomic</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <atomic>标准库</li>
</ul>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <atomic>标准库 详解</h2><p><code>&lt;atomic&gt;</code> 是 C++ 标准库中提供的用于原子操作的头文件，它提供了一组工具和类型，用于在多线程环境中执行原子操作。原子操作是指在执行过程中不会被中断的操作，它们能够确保多个线程同时访问共享数据时不会发生竞态条件（race condition）。</p>
<p>以下是 <code>&lt;atomic&gt;</code> 头文件中最常用的类和函数：</p>
<h3 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h3><ul>
<li><strong>std::atomic&lt;T&gt;</strong>: 这是模板类，提供了对类型 T 的原子访问。可以使用不同的基本数据类型（如整数、指针等）来实例化它。</li>
</ul>
<h3 id="原子操作函数"><a href="#原子操作函数" class="headerlink" title="原子操作函数"></a>原子操作函数</h3><ul>
<li><code>store()</code>: 将值存储到原子对象中。</li>
<li><code>load()</code>: 从原子对象中加载值。</li>
<li><code>exchange()</code>: 将新值存储到原子对象中，并返回先前的值。</li>
<li><code>compare_exchange_weak()</code> 和 <code>compare_exchange_strong()</code>: 比较原子对象的值与预期值，如果相等则修改。<code>compare_exchange_weak()</code> 可能会在比较失败时返回 <code>false</code>，而 <code>compare_exchange_strong()</code> 则保证了强一致性。</li>
<li><code>fetch_add()</code>, <code>fetch_sub()</code>, <code>fetch_and()</code>, <code>fetch_or()</code>, <code>fetch_xor()</code>: 执行原子的加法、减法、与操作、或操作和异或操作，并返回操作之前的值。</li>
</ul>
<h3 id="其他重要函数和特性"><a href="#其他重要函数和特性" class="headerlink" title="其他重要函数和特性"></a>其他重要函数和特性</h3><ul>
<li><code>is_lock_free()</code>: 检查给定类型的原子操作是否是无锁的，即是否可以在特定平台上以原子方式执行。</li>
<li>Memory Order（内存顺序）：这些是在原子操作中指定的参数，用于控制原子操作的顺序和可见性。<ul>
<li><code>memory_order_relaxed</code>: 最轻量级的内存顺序，没有顺序约束。</li>
<li><code>memory_order_acquire</code>, <code>memory_order_release</code>: 分别用于读操作和写操作的同步。</li>
<li><code>memory_order_consume</code>: 用于依赖关系。</li>
<li><code>memory_order_seq_cst</code>: 最严格的内存顺序，提供全序保证。</li>
</ul>
</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        atomic_counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(increment_counter)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(increment_counter)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    thread<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; atomic_counter.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个简单的示例，展示了如何使用 <code>&lt;atomic&gt;</code> 来确保在多线程环境中对共享变量进行原子操作。在这个例子中，两个线程分别调用 <code>increment_counter()</code> 函数来增加 <code>atomic_counter</code> 的值，最终输出其最终的值。</p>
<p>请注意，在使用原子操作时要小心避免出现数据竞争和不正确的同步问题。原子操作能够提供基本的线程安全保证，但仍需谨慎设计代码以避免更复杂的并发问题。</p>
<h2 id="C-标准库-常用类和函数"><a href="#C-标准库-常用类和函数" class="headerlink" title="C++ 标准库 常用类和函数"></a>C++ <atomic>标准库 常用类和函数</h2><p>在 C++ 标准库中的 <code>&lt;atomic&gt;</code> 头文件中，常用的类和函数如下：</p>
<h3 id="常用类："><a href="#常用类：" class="headerlink" title="常用类："></a>常用类：</h3><ol>
<li>**std::atomic&lt;T&gt;**：表示一个原子类型，用于执行对类型 <code>T</code> 的原子操作。<ul>
<li><code>store(val, order)</code>: 将值 <code>val</code> 存储到原子对象中，使用指定的内存顺序 <code>order</code>。</li>
<li><code>load(order)</code>: 从原子对象中加载值，使用指定的内存顺序 <code>order</code>。</li>
<li><code>exchange(val, order)</code>: 将新值 <code>val</code> 存储到原子对象中，并返回先前的值，使用指定的内存顺序 <code>order</code>。</li>
<li><code>compare_exchange_weak(expected, val, order_success, order_failure)</code>: 如果原子对象的值等于 <code>expected</code>，则将其设置为 <code>val</code>，并返回 <code>true</code>；否则，将 <code>expected</code> 更新为原子对象的当前值，并返回 <code>false</code>。该操作使用 <code>order_success</code> 和 <code>order_failure</code> 指定的内存顺序。</li>
<li><code>fetch_add(val, order)</code>, <code>fetch_sub(val, order)</code>, <code>fetch_and(val, order)</code>, <code>fetch_or(val, order)</code>, <code>fetch_xor(val, order)</code>: 执行原子的加法、减法、与操作、或操作和异或操作，并返回操作之前的值，使用指定的内存顺序 <code>order</code>。</li>
</ul>
</li>
</ol>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ol>
<li>**std::atomic_thread_fence(order)**：在当前线程执行内存屏障（memory fence），强制按照指定的内存顺序 <code>order</code> 来排序内存访问操作。</li>
<li>**std::atomic_signal_fence(order)**：在当前线程执行信号屏障（signal fence），强制按照指定的内存顺序 <code>order</code> 来排序内存访问操作，但不影响线程间的同步。</li>
<li>**std::atomic_is_lock_free(&amp;obj)**：检查给定的原子对象 <code>obj</code> 是否是无锁的，返回 <code>true</code> 表示原子类型在特定平台上支持无锁操作。</li>
</ol>
<h3 id="内存顺序（Memory-Order）："><a href="#内存顺序（Memory-Order）：" class="headerlink" title="内存顺序（Memory Order）："></a>内存顺序（Memory Order）：</h3><ul>
<li><code>std::memory_order_relaxed</code>：最轻量级的内存顺序，没有顺序约束。</li>
<li><code>std::memory_order_acquire</code>：用于读取操作，确保在这个操作之后的读取操作都不会被重新排序到这个操作之前。</li>
<li><code>std::memory_order_release</code>：用于写入操作，确保在这个操作之前的写入操作都不会被重新排序到这个操作之后。</li>
<li><code>std::memory_order_acq_rel</code>：同时包括 <code>acquire</code> 和 <code>release</code> 的特性。</li>
<li><code>std::memory_order_seq_cst</code>：最严格的内存顺序，提供全序保证。</li>
</ul>
<p>这些类和函数提供了一套原子操作的工具，使得在多线程环境中对共享数据进行操作时更加安全和可靠。在使用时，需要注意内存顺序和操作的原子性，以确保正确的并发行为。</p>
<h2 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h2><p><code>std::atomic</code> 是 C++ 标准库 <code>&lt;atomic&gt;</code> 中定义的模板类，用于执行原子操作，提供了多线程环境下对共享变量的安全访问。<code>std::atomic</code> 类型的变量可以保证其操作的原子性，即对它们的操作不会被中断。</p>
<h3 id="主要特性和操作："><a href="#主要特性和操作：" class="headerlink" title="主要特性和操作："></a>主要特性和操作：</h3><ol>
<li><p><strong>原子操作</strong>：<code>std::atomic</code> 类型的变量支持多种原子操作，包括读取、写入和各种算术和逻辑操作。这些操作保证在多线程环境中的原子性，不会被其他线程的操作中断。</p>
</li>
<li><p><strong>内存顺序（Memory Order）</strong>：原子操作可以指定内存顺序，即操作在多线程间的执行顺序，包括 <code>memory_order_relaxed</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code> 等。</p>
</li>
<li><p><strong>支持的操作</strong>：<code>std::atomic</code> 类型支持各种操作，如加载（load）、存储（store）、交换（exchange）、比较交换（compare_exchange_strong&#x2F;compare_exchange_weak）等。</p>
</li>
</ol>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">incrementCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed); <span class="comment">// 原子性地增加计数器值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(incrementCounter)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(incrementCounter)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl; <span class="comment">// 输出计数器的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::atomic&lt;int&gt;</code> 类型的 <code>counter</code> 变量用于在两个线程中增加一个计数器的值。<code>fetch_add()</code> 函数用于原子性地增加计数器的值，保证了多线程环境下的安全访问。最终输出的 <code>counter</code> 值应该是 <code>20000</code>，因为两个线程各自增加了 <code>10000</code> 次。</p>
<h2 id="std-atomic-store"><a href="#std-atomic-store" class="headerlink" title="std::atomic::store()"></a>std::atomic::store()</h2><p><code>std::atomic::store()</code> 是 <code>std::atomic</code> 类中的一个成员函数，用于将指定的值存储到原子对象中。这个函数是用于原子性地将新值存储到 <code>std::atomic</code> 对象中的方法之一。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span><span class="params">( T value, std::memory_order order = std::memory_order_seq_cst )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>value</code> 是要存储到原子对象中的新值。</li>
<li><code>order</code> 是可选的参数，表示存储操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    atomic_value.<span class="built_in">store</span>(<span class="number">42</span>); <span class="comment">// 将值 42 存储到 atomic_value 中，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value stored: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出存储后的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>store()</code> 将值 42 存储到 <code>atomic_value</code> 中，并通过 <code>load()</code> 方法加载并打印存储后的值。这些操作都是原子的，保证在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-load"><a href="#std-atomic-load" class="headerlink" title="std::atomic::load()"></a>std::atomic::load()</h2><p><code>std::atomic::load()</code> 是 <code>std::atomic</code> 类的成员函数，用于从原子对象中加载值并返回该值。它是用于原子地获取 <code>std::atomic</code> 对象的值的方法之一。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">load</span><span class="params">(std::memory_order order = std::memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>order</code> 是可选的参数，表示加载操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> loaded_value = atomic_value.<span class="built_in">load</span>(); <span class="comment">// 从 atomic_value 中加载值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value loaded: &quot;</span> &lt;&lt; loaded_value &lt;&lt; std::endl; <span class="comment">// 输出加载的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>load()</code> 方法从 <code>atomic_value</code> 中加载其当前的值，并将其赋给 <code>loaded_value</code> 变量。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-exchange"><a href="#std-atomic-exchange" class="headerlink" title="std::atomic::exchange()"></a>std::atomic::exchange()</h2><p><code>std::atomic::exchange()</code> 是 <code>std::atomic</code> 类的成员函数，用于将新值存储到原子对象中，并返回先前的值。这个函数允许原子地交换原子对象的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">exchange</span><span class="params">(T desired, std::memory_order order = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>desired</code> 是要存储到原子对象中的新值。</li>
<li><code>order</code> 是可选的参数，表示交换操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> old_value = atomic_value.<span class="built_in">exchange</span>(<span class="number">100</span>); <span class="comment">// 将值 100 存储到 atomic_value 中，并返回先前的值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Old value exchanged: &quot;</span> &lt;&lt; old_value &lt;&lt; std::endl; <span class="comment">// 输出交换前的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current value: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>exchange()</code> 方法将值 100 存储到 <code>atomic_value</code> 中，并将先前的值（42）返回并存储在 <code>old_value</code> 中。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-compare-exchange-weak"><a href="#std-atomic-compare-exchange-weak" class="headerlink" title="std::atomic::compare_exchange_weak()"></a>std::atomic::compare_exchange_weak()</h2><p><code>std::atomic::compare_exchange_weak()</code> 是 <code>std::atomic</code> 类的成员函数，用于原子地比较原子对象的值与预期值，如果相等，则修改为新值。它是一种 CAS（比较并交换）操作的弱保证版本，可能在比较失败时返回 <code>false</code>，但不会引发重试。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span><span class="params">(T&amp; expected, T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::memory_order success = std::memory_order_seq_cst,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::memory_order failure = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>expected</code> 是期望的值，如果原子对象的值与 <code>expected</code> 相等，则修改为 <code>desired</code>。</li>
<li><code>desired</code> 是要存储到原子对象中的新值。</li>
<li><code>success</code> 是可选参数，表示成功时使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>。</li>
<li><code>failure</code> 是可选参数，表示比较失败时使用的内存顺序，默认值也是 <code>std::memory_order_seq_cst</code>。</li>
</ul>
<p>该函数将比较预期值（<code>expected</code>）和原子对象的当前值，如果相等，则将原子对象的值设置为 <code>desired</code>，并返回 <code>true</code>；否则，将 <code>expected</code> 更新为原子对象的当前值，并返回 <code>false</code>。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> expected = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> desired = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> success = atomic_value.<span class="built_in">compare_exchange_weak</span>(expected, desired); <span class="comment">// 比较预期值与原子对象的值，若相等则修改为新值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value exchanged successfully!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value not exchanged. Expected: &quot;</span> &lt;&lt; expected &lt;&lt; <span class="string">&quot;, Actual: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>compare_exchange_weak()</code> 将比较 <code>atomic_value</code> 和 <code>expected</code>，若相等，则将其修改为 <code>desired</code>。成功时返回 <code>true</code>，并输出成功的消息，否则返回 <code>false</code>，并输出原子对象的当前值和预期值。</p>
<h2 id="std-atomic-fetch-add"><a href="#std-atomic-fetch-add" class="headerlink" title="std::atomic::fetch_add()"></a>std::atomic::fetch_add()</h2><p><code>std::atomic::fetch_add()</code> 是 <code>std::atomic</code> 类的成员函数，用于执行原子的加法操作，并返回操作之前的值。它是一种原子操作，用于对原子对象的值进行增加操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fetch_add</span><span class="params">(T arg, std::memory_order order = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg</code> 是要增加到原子对象中的值。</li>
<li><code>order</code> 是可选参数，表示操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>该函数将原子对象的值增加 <code>arg</code>，并返回增加前的值。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> previous_value = atomic_value.<span class="built_in">fetch_add</span>(<span class="number">5</span>); <span class="comment">// 将值 5 加到 atomic_value 中，并返回增加前的值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previous_value &lt;&lt; std::endl; <span class="comment">// 输出增加前的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current value: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>fetch_add()</code> 方法将值 5 加到 <code>atomic_value</code> 中，并返回增加前的值。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-fetch-sub"><a href="#std-atomic-fetch-sub" class="headerlink" title="std::atomic::fetch_sub()"></a>std::atomic::fetch_sub()</h2><p><code>std::atomic::fetch_sub()</code> 是 <code>std::atomic</code> 类的成员函数，用于执行原子的减法操作，并返回操作之前的值。它是一种原子操作，用于对原子对象的值进行减少操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fetch_sub</span><span class="params">(T arg, std::memory_order order = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg</code> 是要减少的值，会从原子对象中减去这个值。</li>
<li><code>order</code> 是可选参数，表示操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>该函数将原子对象的值减少 <code>arg</code>，并返回减少前的值。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> previous_value = atomic_value.<span class="built_in">fetch_sub</span>(<span class="number">7</span>); <span class="comment">// 从 atomic_value 中减去值 7，并返回减少前的值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previous_value &lt;&lt; std::endl; <span class="comment">// 输出减少前的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current value: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>fetch_sub()</code> 方法将值 7 从 <code>atomic_value</code> 中减去，并返回减少前的值。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-fetch-add-1"><a href="#std-atomic-fetch-add-1" class="headerlink" title="std::atomic::fetch_add()"></a>std::atomic::fetch_add()</h2><p><code>std::atomic::fetch_and()</code> 是 <code>std::atomic</code> 类的成员函数，用于执行原子的按位与（AND）操作，并返回操作之前的值。它是一种原子操作，用于对原子对象的值进行按位与操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fetch_and</span><span class="params">(T arg, std::memory_order order = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg</code> 是用于按位与运算的操作数，会与原子对象的值进行按位与操作。</li>
<li><code>order</code> 是可选参数，表示操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>该函数将原子对象的值与 <code>arg</code> 进行按位与运算，并返回按位与运算前的原子对象的值。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">0b1100</span>)</span></span>; <span class="comment">// 值为 12 (二进制 1100)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> previous_value = atomic_value.<span class="built_in">fetch_and</span>(<span class="number">0b1010</span>); <span class="comment">// 对 atomic_value 进行按位与操作，并返回按位与前的值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previous_value &lt;&lt; std::endl; <span class="comment">// 输出按位与前的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current value: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>fetch_and()</code> 方法将 <code>atomic_value</code> 的值与 0b1010 进行按位与操作，并返回按位与操作前的值。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-fetch-or"><a href="#std-atomic-fetch-or" class="headerlink" title="std::atomic::fetch_or()"></a>std::atomic::fetch_or()</h2><p><code>std::atomic::fetch_or()</code> 是 <code>std::atomic</code> 类的成员函数，用于执行原子的按位或（OR）操作，并返回操作之前的值。它是一种原子操作，用于对原子对象的值进行按位或操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fetch_or</span><span class="params">(T arg, std::memory_order order = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg</code> 是用于按位或运算的操作数，会与原子对象的值进行按位或操作。</li>
<li><code>order</code> 是可选参数，表示操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>该函数将原子对象的值与 <code>arg</code> 进行按位或运算，并返回按位或运算前的原子对象的值。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">0b1100</span>)</span></span>; <span class="comment">// 值为 12 (二进制 1100)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> previous_value = atomic_value.<span class="built_in">fetch_or</span>(<span class="number">0b1010</span>); <span class="comment">// 对 atomic_value 进行按位或操作，并返回按位或前的值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previous_value &lt;&lt; std::endl; <span class="comment">// 输出按位或前的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current value: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>fetch_or()</code> 方法将 <code>atomic_value</code> 的值与 0b1010 进行按位或操作，并返回按位或操作前的值。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-fetch-xor"><a href="#std-atomic-fetch-xor" class="headerlink" title="std::atomic::fetch_xor()"></a>std::atomic::fetch_xor()</h2><p><code>std::atomic::fetch_xor()</code> 是 <code>std::atomic</code> 类的成员函数，用于执行原子的按位异或（XOR）操作，并返回操作之前的值。它是一种原子操作，用于对原子对象的值进行按位异或操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fetch_xor</span><span class="params">(T arg, std::memory_order order = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg</code> 是用于按位异或运算的操作数，会与原子对象的值进行按位异或操作。</li>
<li><code>order</code> 是可选参数，表示操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>该函数将原子对象的值与 <code>arg</code> 进行按位异或运算，并返回按位异或运算前的原子对象的值。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">0b1100</span>)</span></span>; <span class="comment">// 值为 12 (二进制 1100)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> previous_value = atomic_value.<span class="built_in">fetch_xor</span>(<span class="number">0b1010</span>); <span class="comment">// 对 atomic_value 进行按位异或操作，并返回按位异或前的值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previous_value &lt;&lt; std::endl; <span class="comment">// 输出按位异或前的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current value: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>fetch_xor()</code> 方法将 <code>atomic_value</code> 的值与 0b1010 进行按位异或操作，并返回按位异或操作前的值。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-is-lock-free"><a href="#std-atomic-is-lock-free" class="headerlink" title="std::atomic::is_lock_free()"></a>std::atomic::is_lock_free()</h2><p><code>std::atomic::is_lock_free()</code> 是 <code>std::atomic</code> 类的成员函数，用于检查特定类型的原子操作是否是无锁（lock-free）的。这个函数返回一个布尔值，表示给定类型的原子操作是否可以在特定平台上以无锁方式执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">is_lock_free</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数是一个静态成员函数，可以在实例化 <code>std::atomic</code> 类之前使用。它在编译时确定，用于检查给定类型的原子操作是否可以在当前平台上以无锁方式执行。如果返回 <code>true</code>，表示该类型的原子操作在该平台上是无锁的；如果返回 <code>false</code>，则表示不是无锁的。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Atomic int is lock-free: &quot;</span> &lt;&lt; std::atomic&lt;<span class="type">int</span>&gt;::<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Atomic double is lock-free: &quot;</span> &lt;&lt; std::atomic&lt;<span class="type">double</span>&gt;::<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>is_lock_free()</code> 分别检查 <code>std::atomic&lt;int&gt;</code> 和 <code>std::atomic&lt;double&gt;</code> 是否是无锁的，并输出结果。这个函数对于确定特定类型的原子操作在给定平台上是否无锁非常有用。</p>
<h2 id="std-atomic-memory-order-relaxed"><a href="#std-atomic-memory-order-relaxed" class="headerlink" title="std::atomic::memory_order_relaxed()"></a>std::atomic::memory_order_relaxed()</h2><p>在C++中，<code>std::atomic</code> 的成员函数 <code>memory_order_relaxed</code> 是一个静态成员函数，它用于提供一个标志位（枚举类型）<code>std::memory_order_relaxed</code>，用于指示最轻松的内存顺序，它表示不对原子操作的顺序做出任何约束。</p>
<p><code>std::memory_order_relaxed</code> 并不是 <code>std::atomic</code> 类的函数，而是用于指定原子操作内存顺序的枚举类型。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    atomic_value.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed); <span class="comment">// 使用 relaxed 内存顺序进行存储操作</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> loaded_value = atomic_value.<span class="built_in">load</span>(std::memory_order_relaxed); <span class="comment">// 使用 relaxed 内存顺序进行加载操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value stored and loaded with relaxed order: &quot;</span> &lt;&lt; loaded_value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::memory_order_relaxed</code> 被用作 <code>store()</code> 和 <code>load()</code> 方法的参数，指定了这些原子操作的内存顺序是最轻松的，没有特定的顺序约束。</p>
<h2 id="std-memory-order-acquire"><a href="#std-memory-order-acquire" class="headerlink" title="std::memory_order_acquire"></a>std::memory_order_acquire</h2><p><code>std::memory_order_acquire</code> 是 C++ 标准库 <code>&lt;atomic&gt;</code> 头文件中定义的枚举常量之一，用于指定原子操作中的内存顺序，特别是用于读取操作的同步方式。</p>
<p>这个枚举类型属于 <code>std::memory_order</code> 枚举类，表示一种内存顺序，用于指定在某个原子操作中读取的同步方式。具体地说，<code>std::memory_order_acquire</code> 用于确保在当前读取操作之后，后续的读取操作不会被重排序到前面。</p>
<p>在实际编程中，可以将 <code>std::memory_order_acquire</code> 作为参数传递给原子操作的函数，例如 <code>load()</code> 函数，以指定该操作的内存顺序。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">shared_data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_data.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);</span><br><span class="line">    ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!ready.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 等待写者完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value read: &quot;</span> &lt;&lt; shared_data.<span class="built_in">load</span>(std::memory_order_relaxed) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">writer_thread</span><span class="params">(writer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">reader_thread</span><span class="params">(reader)</span></span>;</span><br><span class="line"></span><br><span class="line">    writer_thread.<span class="built_in">join</span>();</span><br><span class="line">    reader_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::memory_order_acquire</code> 被用作 <code>load()</code> 和 <code>store()</code> 方法的参数，确保在读取 <code>shared_data</code> 和设置 <code>ready</code> 的值时使用了正确的内存顺序，以确保线程间的同步。</p>
<h2 id="std-memory-order-release"><a href="#std-memory-order-release" class="headerlink" title="std::memory_order_release"></a>std::memory_order_release</h2><p><code>std::memory_order_release</code> 是 C++ 标准库 <code>&lt;atomic&gt;</code> 头文件中定义的枚举常量之一，用于指定原子操作中的内存顺序，特别是用于写入操作的同步方式。</p>
<p>这个枚举类型属于 <code>std::memory_order</code> 枚举类，表示一种内存顺序，用于指定在某个原子操作中写入的同步方式。具体地说，<code>std::memory_order_release</code> 用于确保在当前写入操作之前，前面的写入操作不会被重排序到后面。</p>
<p>在实际编程中，可以将 <code>std::memory_order_release</code> 作为参数传递给原子操作的函数，例如 <code>store()</code> 函数，以指定该操作的内存顺序。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">shared_data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_data.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);</span><br><span class="line">    ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!ready.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 等待写者完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value read: &quot;</span> &lt;&lt; shared_data.<span class="built_in">load</span>(std::memory_order_relaxed) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">writer_thread</span><span class="params">(writer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">reader_thread</span><span class="params">(reader)</span></span>;</span><br><span class="line"></span><br><span class="line">    writer_thread.<span class="built_in">join</span>();</span><br><span class="line">    reader_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::memory_order_release</code> 被用作 <code>store()</code> 和 <code>load()</code> 方法的参数，确保在写入 <code>shared_data</code> 和读取 <code>ready</code> 的值时使用了正确的内存顺序，以确保线程间的同步。</p>
<h2 id="std-memory-order-seq-cst"><a href="#std-memory-order-seq-cst" class="headerlink" title="std::memory_order_seq_cst"></a>std::memory_order_seq_cst</h2><p><code>std::memory_order_seq_cst</code> 是 C++ 标准库 <code>&lt;atomic&gt;</code> 头文件中定义的枚举常量之一，用于指定原子操作中的内存顺序。</p>
<p>这个枚举类型属于 <code>std::memory_order</code> 枚举类，表示顺序一致性内存顺序。具体地说，<code>std::memory_order_seq_cst</code> 表示全序（Total Ordering）保证，即对于所有线程来说，原子操作的执行顺序与其在代码中的顺序一致。</p>
<p>在实际编程中，<code>std::memory_order_seq_cst</code> 通常是默认的内存顺序，并被用作原子操作的函数参数，例如 <code>load()</code>、<code>store()</code>、<code>exchange()</code> 等，以指定原子操作的内存顺序。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">shared_data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_data.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_seq_cst); <span class="comment">// 使用 std::memory_order_seq_cst 内存顺序进行存储操作</span></span><br><span class="line">    ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst); <span class="comment">// 使用 std::memory_order_seq_cst 内存顺序进行存储操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!ready.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123; <span class="comment">// 使用 std::memory_order_seq_cst 内存顺序进行加载操作</span></span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 等待写者完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value read: &quot;</span> &lt;&lt; shared_data.<span class="built_in">load</span>(std::memory_order_seq_cst) &lt;&lt; std::endl; <span class="comment">// 使用 std::memory_order_seq_cst 内存顺序进行加载操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">writer_thread</span><span class="params">(writer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">reader_thread</span><span class="params">(reader)</span></span>;</span><br><span class="line"></span><br><span class="line">    writer_thread.<span class="built_in">join</span>();</span><br><span class="line">    reader_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::memory_order_seq_cst</code> 被用作 <code>load()</code>、<code>store()</code> 方法的参数，确保在读取 <code>shared_data</code> 和设置 <code>ready</code> 的值时使用了顺序一致性的内存顺序，以确保线程间的同步。</p>
<h2 id="C-std-atomic-compare-exchange-strong-函数-详解"><a href="#C-std-atomic-compare-exchange-strong-函数-详解" class="headerlink" title="C++ std::atomic::compare_exchange_strong() 函数 详解"></a>C++ std::atomic::compare_exchange_strong() 函数 详解</h2><p><code>std::atomic::compare_exchange_strong()</code> 是 C++ 标准库中 <code>std::atomic</code> 类提供的一个成员函数，用于原子比较和交换操作。它允许在多线程环境中安全地执行原子操作，确保在没有其他线程干扰的情况下执行比较和交换。</p>
<p>以下是该函数的详细解释：</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span><span class="params">(T&amp; expected, T desired, memory_order order = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><p><code>expected</code>：传入一个引用，表示当前的期望值。如果当前的值等于期望值，比较和交换操作将成功，并将 <code>desired</code> 的值写入 <code>std::atomic</code> 对象；否则，<code>expected</code> 保持不变。</p>
</li>
<li><p><code>desired</code>：传入一个新值，如果当前的值等于 <code>expected</code>，则用 <code>desired</code> 替换当前值。</p>
</li>
<li><p><code>order</code>：传入一个可选参数，表示内存顺序（memory order）的类型，默认是 <code>memory_order_seq_cst</code>。内存顺序用于控制不同线程之间的操作顺序，可以选择不同的内存顺序来权衡性能和一致性。</p>
</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><p>如果比较和交换成功（当前值等于期望值），则返回 <code>true</code>，并将 <code>desired</code> 的值写入 <code>std::atomic</code> 对象。</p>
</li>
<li><p>如果比较和交换失败（当前值不等于期望值），则返回 <code>false</code>，并将 <code>expected</code> 的值更新为当前的实际值。</p>
</li>
</ul>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> desired = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">compare_exchange_strong</span>(expected, desired)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exchange successful. New value: &quot;</span> &lt;&lt; data.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exchange failed. Current value: &quot;</span> &lt;&lt; data.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果 <code>data</code> 的当前值等于 <code>expected</code>（初始值为0），则将 <code>desired</code>（值为1）写入 <code>data</code>，并输出成功的消息。否则，输出失败的消息。</p>
<p>请注意，<code>compare_exchange_strong()</code> 函数是一个原子操作，因此可以在多线程环境中安全使用，确保在没有竞态条件的情况下执行比较和交换。</p>
<h2 id="C-std-atomic-compare-exchange-strong-函数对enum-class类型怎么处理"><a href="#C-std-atomic-compare-exchange-strong-函数对enum-class类型怎么处理" class="headerlink" title="C++ std::atomic::compare_exchange_strong() 函数对enum class类型怎么处理"></a>C++ std::atomic::compare_exchange_strong() 函数对enum class类型怎么处理</h2><p><code>std::atomic::compare_exchange_strong()</code> 函数对于 <code>enum class</code> 类型的处理与其他类型类似。这个函数用于原子地比较并交换值，确保在多线程环境中执行这个操作是安全的。</p>
<p>以下是 <code>compare_exchange_strong()</code> 函数的一般形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span><span class="params">(T&amp; expected, T desired, memory_order order = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>T</code> 是 <code>std::atomic</code> 包装的类型。对于 <code>enum class</code> 类型，你可以使用该函数进行原子比较和交换。</p>
<p>假设你有一个 <code>enum class</code> 类型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">MyEnum</span> &#123; Value1, Value2, Value3 &#125;;</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>std::atomic</code> 包装这个类型，并使用 <code>compare_exchange_strong()</code> 函数进行原子比较和交换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;MyEnum&gt; <span class="title">atomicEnum</span><span class="params">(MyEnum::Value1)</span></span>;</span><br><span class="line"></span><br><span class="line">    MyEnum expected = MyEnum::Value1;</span><br><span class="line">    MyEnum desired = MyEnum::Value2;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> success = atomicEnum.<span class="built_in">compare_exchange_strong</span>(expected, desired);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exchange successful. New value: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(desired) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exchange failed. Current value: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(atomicEnum.<span class="built_in">load</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>compare_exchange_strong()</code> 函数将 <code>atomicEnum</code> 的当前值与 <code>expected</code> 进行比较。如果它们相等，将 <code>desired</code> 值写入 <code>atomicEnum</code> 中，并返回 <code>true</code> 表示交换成功。否则，返回 <code>false</code> 表示交换失败，并将 <code>expected</code> 更新为当前的实际值。</p>
<p>需要注意的是，由于 <code>enum class</code> 类型的底层类型是整数，所以在打印时需要使用 <code>static_cast&lt;int&gt;</code> 进行强制转换。</p>
<p>总体来说，<code>compare_exchange_strong()</code> 函数对 <code>enum class</code> 类型的处理方式与其他类型相似，提供了一种在多线程环境中执行原子比较和交换的安全手段。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_16_regex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_16_regex/" class="post-title-link" itemprop="url">C++_10_16_regex</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <regex>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <regex>标准库</h2><p><code>&lt;regex&gt;</code> 是 C++11 标准库中提供的头文件，用于处理正则表达式。它提供了一系列类和函数，使得在 C++ 程序中可以进行正则表达式的匹配、搜索和替换等操作。</p>
<h3 id="主要类和函数："><a href="#主要类和函数：" class="headerlink" title="主要类和函数："></a>主要类和函数：</h3><ol>
<li><p><strong>std::regex</strong>：表示一个正则表达式对象。</p>
</li>
<li><p>**std::regex_match()**：用于检查整个字符串是否与正则表达式匹配。</p>
</li>
<li><p>**std::regex_search()**：在给定字符串中搜索正则表达式的匹配项。</p>
</li>
<li><p>**std::regex_replace()**：使用正则表达式进行替换操作。</p>
</li>
<li><p><strong>std::smatch</strong> 和 <strong>std::cmatch</strong>：表示正则表达式匹配结果的容器，分别用于 <code>std::string</code> 和 <code>const char*</code> 类型的字符串。</p>
</li>
<li><p><strong>std::regex_iterator</strong>：用于在字符串中迭代查找匹配的正则表达式。</p>
</li>
</ol>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;fox&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查整个字符串是否与正则表达式匹配</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match not found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用正则表达式进行替换操作</span></span><br><span class="line">    std::string replacedText = std::<span class="built_in">regex_replace</span>(text, pattern, <span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Replaced text: &quot;</span> &lt;&lt; replacedText &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>&lt;regex&gt;</code> 头文件中的函数和类被用于查找匹配的字符串并进行替换。<code>std::regex_search()</code> 用于检查是否存在匹配项，而 <code>std::regex_replace()</code> 则用于替换匹配的部分。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <regex>标准库 详解</h2><p>C++ 标准库中的 <code>&lt;regex&gt;</code> 头文件提供了对正则表达式的支持，允许进行字符串的匹配、搜索和替换等操作。在 C++11 标准中引入了正则表达式库，它提供了一系列类和函数用于处理正则表达式。</p>
<h3 id="主要类和函数：-1"><a href="#主要类和函数：-1" class="headerlink" title="主要类和函数："></a>主要类和函数：</h3><ol>
<li><p><strong>std::regex</strong>：表示一个正则表达式对象。可以创建一个 <code>std::regex</code> 对象，用于表示要匹配的正则表达式模式。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;your_pattern_here&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**std::regex_match()**：用于检查整个字符串是否与正则表达式模式匹配。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line"><span class="type">bool</span> isMatch = std::<span class="built_in">regex_match</span>(text, pattern);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**std::regex_search()**：在给定的字符串中搜索正则表达式模式的匹配项。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line"><span class="type">bool</span> isMatch = std::<span class="built_in">regex_search</span>(text, pattern);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**std::regex_replace()**：使用正则表达式模式进行替换操作。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line">std::string replacedText = std::<span class="built_in">regex_replace</span>(text, pattern, <span class="string">&quot;replacement_text&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::smatch</strong> 和 <strong>std::cmatch</strong>：表示正则表达式匹配结果的容器，分别用于 <code>std::string</code> 和 <code>const char*</code> 类型的字符串。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line">std::smatch match;</span><br><span class="line">std::<span class="built_in">regex_match</span>(text, match, pattern);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::regex_iterator</strong>：用于在字符串中迭代查找正则表达式模式的匹配项。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line"><span class="function">std::regex_iterator&lt;std::string::iterator&gt; <span class="title">it</span><span class="params">(text.begin(), text.end(), pattern)</span></span>;</span><br><span class="line">std::regex_iterator&lt;std::string::iterator&gt; end;</span><br><span class="line"><span class="keyword">for</span> (; it != end; ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Match found: &quot;</span> &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些函数和类提供了对正则表达式的基本支持，可以在 C++ 程序中执行各种与正则表达式相关的操作，包括匹配、搜索和替换等。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <regex>标准库 常用的类和函数</h2><p>C++ 标准库 <code>&lt;regex&gt;</code> 中包含了一些常用的类和函数，用于处理正则表达式。以下是其中一些主要的类和函数：</p>
<h3 id="主要类："><a href="#主要类：" class="headerlink" title="主要类："></a>主要类：</h3><ol>
<li><p><strong>std::regex</strong>：表示一个正则表达式对象。</p>
</li>
<li><p><strong>std::smatch</strong> 和 <strong>std::cmatch</strong>：表示正则表达式匹配结果的容器，分别用于 <code>std::string</code> 和 <code>const char*</code> 类型的字符串。</p>
</li>
<li><p><strong>std::regex_iterator</strong>：用于在字符串中迭代查找正则表达式的匹配项。</p>
</li>
</ol>
<h3 id="主要函数："><a href="#主要函数：" class="headerlink" title="主要函数："></a>主要函数：</h3><ol>
<li><p>**std::regex_match()**：用于检查整个字符串是否与正则表达式匹配。</p>
</li>
<li><p>**std::regex_search()**：在给定字符串中搜索正则表达式的匹配项。</p>
</li>
<li><p>**std::regex_replace()**：使用正则表达式进行替换操作。</p>
</li>
<li><p><strong>std::regex_constants</strong>：提供了一些常量，用于设置正则表达式的标志和选项。</p>
</li>
</ol>
<p>这些类和函数允许在 C++ 中对字符串执行正则表达式的匹配、搜索、替换等操作，为处理文本提供了强大的工具。</p>
<h2 id="std-regex"><a href="#std-regex" class="headerlink" title="std::regex"></a>std::regex</h2><p><code>std::regex</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的类，用于表示一个正则表达式对象。它允许在 C++ 程序中创建和使用正则表达式模式，并用于字符串的匹配、搜索和替换等操作。</p>
<h3 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h3><ol>
<li><p><strong>构造和使用正则表达式对象</strong>：<code>std::regex</code> 可以使用正则表达式字符串构造对象，表示要匹配的模式。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;your_pattern_here&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>匹配检查</strong>：<code>std::regex_match()</code> 函数用于检查整个字符串是否与正则表达式模式匹配。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line"><span class="type">bool</span> isMatch = std::<span class="built_in">regex_match</span>(text, pattern);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>搜索匹配项</strong>：<code>std::regex_search()</code> 函数在给定的字符串中搜索正则表达式模式的匹配项。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line"><span class="type">bool</span> isMatch = std::<span class="built_in">regex_search</span>(text, pattern);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>替换操作</strong>：<code>std::regex_replace()</code> 函数使用正则表达式模式进行替换操作。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line">std::string replacedText = std::<span class="built_in">regex_replace</span>(text, pattern, <span class="string">&quot;replacement_text&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>std::regex</code> 类提供了对正则表达式模式的支持，并允许在 C++ 中对字符串进行基于模式的匹配、搜索和替换等操作。</p>
<h2 id="std-smatch"><a href="#std-smatch" class="headerlink" title="std::smatch"></a>std::smatch</h2><p><code>std::smatch</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的类，用于存储正则表达式的匹配结果。它是一个模板类，用于存储 <code>std::string</code> 类型的匹配结果。</p>
<h3 id="主要特点和用法："><a href="#主要特点和用法：" class="headerlink" title="主要特点和用法："></a>主要特点和用法：</h3><ol>
<li><p><strong>存储匹配结果</strong>：<code>std::smatch</code> 类型的对象可以存储正则表达式匹配到的结果，以便进一步处理。</p>
</li>
<li><p><strong>作为 std::regex_match() 和 std::regex_search() 的参数</strong>：通常作为 <code>std::regex_match()</code> 和 <code>std::regex_search()</code> 函数的额外参数，用于存储匹配的结果。</p>
</li>
<li><p><strong>访问匹配子字符串</strong>：通过索引或迭代器等方式可以访问匹配到的子字符串。</p>
</li>
</ol>
<h3 id="示例用法：-1"><a href="#示例用法：-1" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\b\\w&#123;4&#125;\\b&quot;</span>)</span></span>; <span class="comment">// 匹配长度为4的单词</span></span><br><span class="line"></span><br><span class="line">    std::smatch match;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, match, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历匹配到的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = match.<span class="built_in">begin</span>(); it != match.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Matched substring: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::smatch</code> 类型的对象 <code>match</code> 用于存储正则表达式模式匹配到的结果。通过 <code>std::regex_search()</code> 函数将匹配结果存储在 <code>match</code> 对象中，并可以通过迭代器或索引访问匹配到的子字符串。</p>
<h2 id="std-cmatch"><a href="#std-cmatch" class="headerlink" title="std::cmatch"></a>std::cmatch</h2><p><code>std::cmatch</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的类，用于存储正则表达式的匹配结果。不同于 <code>std::smatch</code>，<code>std::cmatch</code> 专门用于存储匹配 C 风格字符串（<code>const char*</code> 类型）的结果。</p>
<h3 id="主要特点和用法：-1"><a href="#主要特点和用法：-1" class="headerlink" title="主要特点和用法："></a>主要特点和用法：</h3><ol>
<li><p><strong>存储匹配结果</strong>：<code>std::cmatch</code> 类型的对象可以存储正则表达式匹配到的 C 风格字符串（<code>const char*</code> 类型）的结果。</p>
</li>
<li><p><strong>作为 std::regex_match() 和 std::regex_search() 的参数</strong>：通常作为 <code>std::regex_match()</code> 和 <code>std::regex_search()</code> 函数的额外参数，用于存储匹配的结果。</p>
</li>
<li><p><strong>访问匹配子字符串</strong>：通过索引或迭代器等方式可以访问匹配到的子字符串。</p>
</li>
</ol>
<h3 id="示例用法：-2"><a href="#示例用法：-2" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\b\\w&#123;4&#125;\\b&quot;</span>)</span></span>; <span class="comment">// 匹配长度为4的单词</span></span><br><span class="line"></span><br><span class="line">    std::cmatch match;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, match, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历匹配到的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = match.<span class="built_in">begin</span>(); it != match.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Matched substring: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::cmatch</code> 类型的对象 <code>match</code> 用于存储正则表达式模式匹配到的 C 风格字符串的结果。通过 <code>std::regex_search()</code> 函数将匹配结果存储在 <code>match</code> 对象中，并可以通过迭代器或索引访问匹配到的子字符串。</p>
<h2 id="std-regex-iterator"><a href="#std-regex-iterator" class="headerlink" title="std::regex_iterator"></a>std::regex_iterator</h2><p><code>std::regex_iterator</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的类，用于在字符串中迭代查找正则表达式的匹配项。</p>
<h3 id="主要特点和用法：-2"><a href="#主要特点和用法：-2" class="headerlink" title="主要特点和用法："></a>主要特点和用法：</h3><ol>
<li><p><strong>在字符串中迭代查找匹配项</strong>：<code>std::regex_iterator</code> 可以在给定的字符串中按顺序迭代查找正则表达式的所有匹配项。</p>
</li>
<li><p><strong>作为 std::sregex_iterator 和 std::cregex_iterator 的实例</strong>：<code>std::regex_iterator</code> 实际上是 <code>std::sregex_iterator</code>（用于 <code>std::string</code>）和 <code>std::cregex_iterator</code>（用于 <code>const char*</code>）的实例。</p>
</li>
<li><p><strong>迭代器遍历匹配结果</strong>：通过迭代器可以逐个访问匹配的子字符串。</p>
</li>
</ol>
<h3 id="示例用法：-3"><a href="#示例用法：-3" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\b\\w&#123;4&#125;\\b&quot;</span>)</span></span>; <span class="comment">// 匹配长度为4的单词</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::sregex_iterator <span class="title">it</span><span class="params">(text.begin(), text.end(), pattern)</span></span>; <span class="comment">// 用于 std::string 的迭代器</span></span><br><span class="line">    std::sregex_iterator end; <span class="comment">// 结束迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; it != end; ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Matched substring: &quot;</span> &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::sregex_iterator</code> 被用来在给定的 <code>std::string</code> 中迭代查找正则表达式模式的匹配项。<code>std::sregex_iterator</code> 构造函数的参数是要进行匹配的字符串的迭代器范围和正则表达式模式，然后通过迭代器逐个访问匹配的子字符串。</p>
<h2 id="std-regex-match"><a href="#std-regex-match" class="headerlink" title="std::regex_match()"></a>std::regex_match()</h2><p><code>std::regex_match()</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的函数，用于检查整个字符串是否与给定的正则表达式模式匹配。</p>
<h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;quick&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isMatch = std::<span class="built_in">regex_match</span>(text, pattern);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isMatch) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Text matches the pattern!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>std::regex_match()</code> 函数接受两个参数：待匹配的字符串和正则表达式模式。</li>
<li>如果整个字符串完全匹配正则表达式模式，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li>此函数会尝试将整个输入字符串与模式进行匹配。如果整个字符串与模式匹配成功，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>需要注意的是，<code>std::regex_match()</code> 会尝试对整个输入字符串进行匹配，如果要在字符串中查找匹配的子序列，可以使用 <code>std::regex_search()</code>。</p>
<h2 id="std-regex-search"><a href="#std-regex-search" class="headerlink" title="std::regex_search()"></a>std::regex_search()</h2><p><code>std::regex_search()</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的函数，用于在给定的字符串中搜索正则表达式的匹配项。</p>
<h3 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\b\\w&#123;5&#125;\\b&quot;</span>)</span></span>; <span class="comment">// 匹配长度为5的单词</span></span><br><span class="line"></span><br><span class="line">    std::smatch match; <span class="comment">// 用于存储匹配结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, match, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历匹配到的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; m : match) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Matched substring: &quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>std::regex_search()</code> 函数接受三个参数：待搜索的字符串、存储匹配结果的容器（例如 <code>std::smatch</code>）和正则表达式模式。</li>
<li>它在给定的字符串中搜索匹配正则表达式模式的第一个子序列。</li>
<li>如果找到了匹配项，则返回 <code>true</code>，并将匹配结果存储在提供的容器中，否则返回 <code>false</code>。</li>
</ul>
<p>该函数会在字符串中搜索第一个匹配项并将其存储在给定的容器中，方便进一步处理匹配到的子序列。如果需要查找所有匹配项，可以使用 <code>std::regex_iterator</code> 进行迭代搜索。</p>
<h2 id="std-regex-replace"><a href="#std-regex-replace" class="headerlink" title="std::regex_replace()"></a>std::regex_replace()</h2><p><code>std::regex_replace()</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的函数，用于使用正则表达式模式对字符串进行替换操作。</p>
<h3 id="用法：-2"><a href="#用法：-2" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\b\\w&#123;4&#125;\\b&quot;</span>)</span></span>; <span class="comment">// 匹配长度为4的单词</span></span><br><span class="line"></span><br><span class="line">    std::string replacedText = std::<span class="built_in">regex_replace</span>(text, pattern, <span class="string">&quot;REPLACEMENT&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original text: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Replaced text: &quot;</span> &lt;&lt; replacedText &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>std::regex_replace()</code> 函数接受三个参数：待替换的字符串、正则表达式模式和替换的文本。</li>
<li>它会搜索字符串中与正则表达式模式匹配的部分，并用指定的文本进行替换。</li>
<li>替换后的新字符串被返回，原始字符串不会被修改。</li>
</ul>
<p>在示例中，<code>\\b\\w&#123;4&#125;\\b</code> 匹配长度为 4 的单词，然后将匹配到的单词替换为字符串 <code>&quot;REPLACEMENT&quot;</code>。注意，这里使用了双反斜杠来转义正则表达式中的特殊字符。</p>
<h2 id="std-regex-constants"><a href="#std-regex-constants" class="headerlink" title="std::regex_constants"></a>std::regex_constants</h2><p><code>std::regex_constants</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中定义的命名空间，提供了一些常量，用于设置正则表达式的标志和选项。</p>
<h3 id="主要的常量："><a href="#主要的常量：" class="headerlink" title="主要的常量："></a>主要的常量：</h3><ol>
<li><strong>std::regex_constants::icase</strong>：忽略大小写进行匹配。</li>
<li><strong>std::regex_constants::nosubs</strong>：不保存子匹配结果。</li>
<li><strong>std::regex_constants::optimize</strong>：优化正则表达式，提高匹配性能。</li>
<li><strong>std::regex_constants::collate</strong>：使用与语言相关的排序规则进行匹配。</li>
</ol>
<h3 id="用法示例："><a href="#用法示例：" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;quick&quot;</span>, std::regex_constants::icase)</span></span>; <span class="comment">// 使用忽略大小写进行匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，通过指定 <code>std::regex_constants::icase</code> 标志，创建的正则表达式模式将忽略大小写进行匹配。使用这些常量可以在创建正则表达式对象时设定不同的匹配选项，以满足特定的匹配需求。</p>
<h2 id="std-regex-constants-icase"><a href="#std-regex-constants-icase" class="headerlink" title="std::regex_constants::icase"></a>std::regex_constants::icase</h2><p><code>std::regex_constants::icase</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的一个常量，用于在创建正则表达式对象时设置忽略大小写的匹配模式。</p>
<p>当使用 <code>std::regex_constants::icase</code> 常量作为 <code>std::regex</code> 构造函数的第二个参数时，表示创建的正则表达式对象将以不区分大小写的方式进行匹配。</p>
<h3 id="用法示例：-1"><a href="#用法示例：-1" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The Quick Brown Fox&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;quick&quot;</span>, std::regex_constants::icase)</span></span>; <span class="comment">// 使用忽略大小写进行匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，正则表达式模式 <code>&quot;quick&quot;</code> 在文本中找不到精确的匹配项，但由于使用了 <code>std::regex_constants::icase</code>，它会忽略大小写进行查找，因此可以找到文本中的部分匹配项。</p>
<h2 id="std-regex-constants-nosubs"><a href="#std-regex-constants-nosubs" class="headerlink" title="std::regex_constants::nosubs"></a>std::regex_constants::nosubs</h2><p><code>std::regex_constants::nosubs</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的一个常量，用于在创建正则表达式对象时设置，表示不保存子匹配结果。</p>
<p>当使用 <code>std::regex_constants::nosubs</code> 常量作为 <code>std::regex</code> 构造函数的第二个参数时，表示创建的正则表达式对象将不保存子匹配的结果。</p>
<h3 id="用法示例：-2"><a href="#用法示例：-2" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The Quick Brown Fox&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;(\\w+)\\s(\\w+)&quot;</span>, std::regex_constants::nosubs)</span></span>; <span class="comment">// 不保存子匹配结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，正则表达式模式 <code>&quot;(\\w+)\\s(\\w+)&quot;</code> 匹配两个单词之间的空格，并使用 <code>std::regex_constants::nosubs</code> 标志创建了正则表达式对象。由于使用了 <code>nosubs</code>，正则表达式对象将不保存子匹配的结果，因此在搜索时只返回是否有整个模式的匹配，而不会保存子表达式的匹配结果。</p>
<h2 id="std-regex-constants-optimize"><a href="#std-regex-constants-optimize" class="headerlink" title="std::regex_constants::optimize"></a>std::regex_constants::optimize</h2><p><code>std::regex_constants::optimize</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的一个常量，用于在创建正则表达式对象时设置，表示优化正则表达式以提高匹配性能。</p>
<p>当使用 <code>std::regex_constants::optimize</code> 常量作为 <code>std::regex</code> 构造函数的第二个参数时，表示创建的正则表达式对象将进行优化，以提高匹配性能。</p>
<h3 id="用法示例：-3"><a href="#用法示例：-3" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The Quick Brown Fox&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;[a-z]+&quot;</span>, std::regex_constants::optimize)</span></span>; <span class="comment">// 优化正则表达式以提高匹配性能</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，正则表达式模式 <code>&quot;[a-z]+&quot;</code> 用于匹配小写字母序列。通过使用 <code>std::regex_constants::optimize</code> 常量作为参数创建正则表达式对象，正则表达式将进行优化，提高匹配性能，特别是对于复杂的模式可以提升匹配速度。</p>
<h2 id="std-regex-constants-collate"><a href="#std-regex-constants-collate" class="headerlink" title="std::regex_constants::collate"></a>std::regex_constants::collate</h2><p><code>std::regex_constants::collate</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的一个常量，用于在创建正则表达式对象时设置，表示使用与语言相关的排序规则进行匹配。</p>
<p>当使用 <code>std::regex_constants::collate</code> 常量作为 <code>std::regex</code> 构造函数的第二个参数时，表示创建的正则表达式对象将使用与语言相关的排序规则进行匹配。</p>
<h3 id="用法示例：-4"><a href="#用法示例：-4" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The Quick Brown Fox&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;quick&quot;</span>, std::regex_constants::icase | std::regex_constants::collate)</span></span>; <span class="comment">// 使用忽略大小写和与语言相关的排序规则进行匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，正则表达式模式 <code>&quot;quick&quot;</code> 使用了 <code>std::regex_constants::icase</code> 进行忽略大小写匹配，并且使用了 <code>std::regex_constants::collate</code>，表示使用与语言相关的排序规则进行匹配。这允许正则表达式引擎根据当前环境的语言规则对字符进行排序和匹配。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_14_condition_variable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_14_condition_variable/" class="post-title-link" itemprop="url">C++_10_14_condition_variable</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <condition_variable>标准库</li>
</ul>
<h2 id="condition-variable-介绍"><a href="#condition-variable-介绍" class="headerlink" title="condition_variable 介绍"></a>condition_variable 介绍</h2><ul>
<li><p>在C++11中，我们可以使用条件变量(condition_variable)实现多个线程间的同步操作；当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。</p>
</li>
<li><p>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：</p>
<ul>
<li>一个线程因等待 条件变量的条件成立 而挂起</li>
<li>另一个线程使 条件成立， 给出信号，从而唤醒被等待的线程。</li>
</ul>
</li>
<li><p>为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起；通常情况下这个锁是std::mutex并且管理这个锁只能是 std::unique_lock<a href="std::mutex">std::mutex</a> RAII模板类</p>
</li>
<li><p>上面提到的两个步骤，分别是使用以下两个方法实现的：</p>
<ul>
<li>等待条件成立使用的是 condition_variable 类成员wait, wait_for 或 wait_util</li>
<li>给出信号使用的是 condition_variable 类成员 notify_one 或者 notify_all 函数</li>
</ul>
</li>
</ul>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ul>
<li><p>在条件变量中只能使用 std::unique_lock<a href="std::mutex">std::mutex</a> 说明</p>
</li>
<li><p>unique_lock 和 lock_guard 都是管理锁的辅助工具，都是RAII风格；它们是在定义时获得锁，在析构时释放锁。</p>
</li>
<li><p>他们的主要区别在于 unique_lock 锁机制更加灵活。</p>
</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <condition_variable>标准库</h2><p><code>&lt;condition_variable&gt;</code> 是 C++ 标准库中的头文件，提供了多线程编程中用于线程同步的条件变量。条件变量用于线程之间的同步和通信，允许一个线程在某个特定条件下等待或被唤醒，以进行进一步的处理。</p>
<p>条件变量通常与互斥量（mutex）结合使用，以便线程可以安全地等待某个条件并在条件满足时被通知。</p>
<p>下面是一个简单的示例，演示了如何使用 <code>&lt;condition_variable&gt;</code> 进行线程间的同步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker: Data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: Starting worker thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: Worker signaled data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待工作线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，主线程等待工作线程完成一些任务并准备好数据。它通过条件变量 <code>cv</code> 和互斥量 <code>mtx</code> 来实现同步和通信。主线程在互斥量的保护下等待条件满足，而工作线程在完成工作后发送信号通知主线程条件已满足。</p>
<p><code>std::condition_variable</code> 允许线程在等待条件变为真时暂时阻塞，并在条件被满足时唤醒线程。它常与 <code>std::mutex</code> 和 <code>std::unique_lock</code> 一起使用，以确保线程安全并避免死锁。</p>
<p>条件变量是在多线程编程中实现线程同步的重要工具，它允许线程在特定条件下等待或被唤醒，并且能够准确地控制线程的执行流程。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <condition_variable>标准库 详解</h2><p><code>&lt;condition_variable&gt;</code> 是 C++ 标准库中提供的用于多线程编程的头文件之一，它包含了 <code>std::condition_variable</code> 类的定义，用于线程间的同步和通信。</p>
<h3 id="主要成员函数和功能："><a href="#主要成员函数和功能：" class="headerlink" title="主要成员函数和功能："></a>主要成员函数和功能：</h3><ol>
<li><p><code>wait()</code>：让线程等待直到满足某个特定条件。</p>
<ul>
<li>通过参数接受一个 <code>std::unique_lock</code> 对象和一个谓词（可以是 lambda 表达式），并在谓词返回 <code>true</code> 时解除阻塞，或者在收到通知时解除阻塞。</li>
<li>在等待时会释放锁，并在被唤醒后再次获取锁，允许其他线程修改被保护的数据。</li>
</ul>
</li>
<li><p><code>notify_one()</code>：唤醒等待在条件变量上的一个线程。</p>
<ul>
<li>如果有多个线程在等待，只会唤醒其中一个线程（不保证唤醒的是哪个线程）。</li>
</ul>
</li>
<li><p><code>notify_all()</code>：唤醒等待在条件变量上的所有线程。</p>
<ul>
<li>唤醒所有等待的线程，允许它们竞争锁并继续执行。</li>
</ul>
</li>
<li><p><code>std::condition_variable</code> 是与互斥量（<code>std::mutex</code>）一起使用的，通过配合 <code>std::unique_lock</code> 对象，使线程能够在等待某个条件变为真时暂时阻塞自己，等待其他线程通知并且在条件满足时继续执行。</p>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>下面是一个简单的示例，演示了条件变量的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data_ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker: Data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: Starting worker thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> data_ready; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: Worker signaled data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待工作线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，工作线程会等待一段时间模拟处理数据的操作，然后通知等待中的主线程。主线程在条件变量 <code>cv</code> 上等待，直到工作线程通知数据已准备就绪才会继续执行。</p>
<p>这个示例展示了如何使用 <code>std::condition_variable</code> 实现线程间的同步和通信，允许一个线程等待某个条件满足并在条件被满足时被通知。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <condition_variable>标准库 常用的类和函数</h2><p>在C++中，<code>&lt;condition_variable&gt;</code> 标准库提供了 <code>std::condition_variable</code> 类，以及与之配合使用的一些常用函数和类型。</p>
<h3 id="主要类和类型："><a href="#主要类和类型：" class="headerlink" title="主要类和类型："></a>主要类和类型：</h3><ol>
<li><p><strong>std::condition_variable</strong>：</p>
<ul>
<li>用于线程间的同步和通信。</li>
<li>允许一个或多个线程等待某个条件满足，并在满足条件时被通知。</li>
<li>主要成员函数有 <code>wait()</code>、<code>notify_one()</code>、<code>notify_all()</code>。</li>
<li>配合 <code>std::mutex</code> 和 <code>std::unique_lock</code> 一起使用，允许线程在等待条件满足时暂时阻塞自己。</li>
</ul>
</li>
<li><p><strong>std::mutex</strong>：</p>
<ul>
<li>互斥量，用于保护共享资源，防止多个线程同时访问。</li>
<li><code>std::unique_lock</code> 通常与 <code>std::mutex</code> 一起使用，用于在多线程环境中提供对共享资源的独占访问。</li>
</ul>
</li>
<li><p><strong>std::unique_lock</strong>：</p>
<ul>
<li>提供对互斥量的锁定和解锁操作。</li>
<li>可以通过构造函数进行锁定并在作用域结束时自动解锁。</li>
</ul>
</li>
</ol>
<h3 id="常用函数和成员方法："><a href="#常用函数和成员方法：" class="headerlink" title="常用函数和成员方法："></a>常用函数和成员方法：</h3><ol>
<li><p>**<code>wait(lock, pred)</code>**：</p>
<ul>
<li><code>std::condition_variable</code> 的成员函数。</li>
<li>让线程等待，直到某个特定条件满足或者收到通知。</li>
<li>参数 <code>lock</code> 是一个 <code>std::unique_lock</code> 对象（通常与互斥量一起使用），<code>pred</code> 是一个可调用对象，用于判断等待条件是否满足。</li>
</ul>
</li>
<li><p>**<code>notify_one()</code>**：</p>
<ul>
<li><code>std::condition_variable</code> 的成员函数。</li>
<li>唤醒一个等待在条件变量上的线程。</li>
</ul>
</li>
<li><p>**<code>notify_all()</code>**：</p>
<ul>
<li><code>std::condition_variable</code> 的成员函数。</li>
<li>唤醒所有等待在条件变量上的线程。</li>
</ul>
</li>
</ol>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data_ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker: Data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: Starting worker thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> data_ready; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: Worker signaled data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待工作线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::condition_variable</code> 如何与互斥量 <code>std::mutex</code> 结合使用，使得一个线程可以等待另一个线程满足某个条件后通知它。</p>
<h2 id="std-condition-variable"><a href="#std-condition-variable" class="headerlink" title="std::condition_variable"></a>std::condition_variable</h2><p><code>std::condition_variable</code> 是 C++ 标准库 <code>&lt;condition_variable&gt;</code> 中定义的类，用于线程间的条件变量通信和同步。</p>
<p>它通常与 <code>std::mutex</code> 结合使用，实现线程的等待和唤醒操作，以在多线程环境中进行同步和通信。</p>
<h3 id="主要操作和函数："><a href="#主要操作和函数：" class="headerlink" title="主要操作和函数："></a>主要操作和函数：</h3><ol>
<li><p>**wait()**：线程等待条件变量满足。在等待时，线程会释放与互斥量关联的锁，直到另一个线程通过 <code>notify_one()</code> 或 <code>notify_all()</code> 唤醒它。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">cv.<span class="built_in">wait</span>(lck); <span class="comment">// 等待条件变量满足</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**notify_one() 和 notify_all()**：用于唤醒一个或所有等待条件变量的线程。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line">cv.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒一个等待条件变量的线程</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">cv.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒所有等待条件变量的线程</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lck, [] &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件变量为 true</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is processing...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 执行工作...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(workerThread)</span></span>; <span class="comment">// 创建新线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做一些其他工作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待一段时间后，设置条件变量为 true</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒等待的线程</span></span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::condition_variable</code> 被用于在工作线程等待一个条件变量为 <code>true</code> 的信号，主线程在一定条件下唤醒工作线程。工作线程在等待期间会释放锁，只有当条件满足时才会被唤醒继续执行。主线程通过 <code>notify_one()</code> 唤醒等待的工作线程。</p>
<h2 id="std-condition-variable-wait"><a href="#std-condition-variable-wait" class="headerlink" title="std::condition_variable::wait()"></a>std::condition_variable::wait()</h2><p><code>std::condition_variable::wait()</code> 是 <code>std::condition_variable</code> 类的成员函数之一，用于让线程在条件变量上等待。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>lock</code>：一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象的引用，用于保护等待期间可能修改的共享数据。</li>
<li><code>pred</code>：一个谓词（函数或函数对象），用于检查条件是否满足。如果谓词返回 <code>false</code>，<code>wait()</code> 函数将阻塞当前线程，并在收到通知或条件变为 <code>true</code> 时解除阻塞。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul>
<li>当前线程在调用 <code>wait()</code> 时会释放 <code>lock</code> 引用的互斥量，并进入阻塞状态，直到另一个线程调用 <code>notify_one()</code> 或 <code>notify_all()</code> 通知或条件满足，将当前线程从阻塞状态唤醒。</li>
<li>在线程被唤醒后，<code>wait()</code> 函数会重新获取 <code>lock</code> 引用的互斥量，并检查条件谓词。如果条件谓词返回 <code>true</code> 或被通知唤醒，<code>wait()</code> 函数返回，线程继续执行。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data_ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker: Data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: Starting worker thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> data_ready; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: Worker signaled data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待工作线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>cv.wait(lock, pred)</code> 函数在等待期间会释放 <code>lock</code> 引用的互斥量，然后阻塞当前线程。当工作线程完成数据准备后，它会调用 <code>cv.notify_one()</code> 发送通知，唤醒主线程。主线程被唤醒后，重新获取互斥量，并检查 <code>data_ready</code> 变量，继续执行。</p>
<h2 id="td-condition-variable-notify-one"><a href="#td-condition-variable-notify-one" class="headerlink" title="td::condition_variable::notify_one()"></a>td::condition_variable::notify_one()</h2><p><code>std::condition_variable::notify_one()</code> 是 <code>std::condition_variable</code> 类的成员函数之一，用于唤醒等待在条件变量上的一个线程。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>notify_one()</code> 用于通知等待在条件变量上的一个线程，唤醒其中一个被阻塞的线程。</li>
<li>如果有多个线程在条件变量上等待，只有其中一个线程会被唤醒。哪个线程会被唤醒是不确定的，取决于操作系统的调度和实现。</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data_ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker: Data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: Starting worker thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> data_ready; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: Worker signaled data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待工作线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>cv.notify_one()</code> 在工作线程中被调用，它唤醒了一个等待在条件变量 <code>cv</code> 上的主线程，使其从 <code>cv.wait()</code> 阻塞状态解除，并继续执行。需要注意的是，如果有多个线程在条件变量上等待，<code>notify_one()</code> 只会唤醒其中一个线程。</p>
<h2 id="std-condition-variable-notify-all"><a href="#std-condition-variable-notify-all" class="headerlink" title="std::condition_variable::notify_all()"></a>std::condition_variable::notify_all()</h2><p><code>std::condition_variable::notify_all()</code> 是 <code>std::condition_variable</code> 类的成员函数之一，用于唤醒等待在条件变量上的所有线程。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>notify_all()</code> 用于通知等待在条件变量上的所有线程，唤醒所有被阻塞的线程。</li>
<li>调用 <code>notify_all()</code> 会使所有等待在条件变量上的线程都从等待状态解除，并尝试重新获取锁以继续执行。</li>
</ul>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data_ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker: Data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_all</span>(); <span class="comment">// 通知所有等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: Starting worker thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> data_ready; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: Worker signaled data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待工作线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>cv.notify_all()</code> 在工作线程中被调用，它唤醒了所有等待在条件变量 <code>cv</code> 上的主线程。所有等待的线程都会从 <code>cv.wait()</code> 阻塞状态解除，并尝试重新获取锁以继续执行。<code>notify_all()</code> 会唤醒所有线程，让它们竞争锁资源并继续执行。</p>
<h2 id="C-std-condition-variable-any-类-详解"><a href="#C-std-condition-variable-any-类-详解" class="headerlink" title="C++  std::condition_variable_any 类 详解"></a>C++ <condition_variable> std::condition_variable_any 类 详解</h2><p><code>std::condition_variable_any</code> 是 C++11 标准库中的一个同步原语，属于 <code>&lt;condition_variable&gt;</code> 头文件。它与 <code>std::condition_variable</code> 类似，但有所不同，主要在于它不要求条件变量与特定的锁类型（如 <code>std::mutex</code> 或 <code>std::unique_lock&lt;std::mutex&gt;</code>）绑定，因此更加灵活。</p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p><code>std::condition_variable_any</code> 是一个条件变量，允许多个线程基于某个共享状态进行等待或通知。与 <code>std::condition_variable</code> 不同的是，它的等待操作不依赖于特定的互斥锁类型。它可以与任何类型的锁配合使用，只要该锁能够提供对共享数据的互斥访问。</p>
<h3 id="2-std-condition-variable-any-和-std-condition-variable-的区别"><a href="#2-std-condition-variable-any-和-std-condition-variable-的区别" class="headerlink" title="2. std::condition_variable_any 和 std::condition_variable 的区别"></a>2. <code>std::condition_variable_any</code> 和 <code>std::condition_variable</code> 的区别</h3><ul>
<li><code>std::condition_variable</code> 只能与 <code>std::unique_lock&lt;std::mutex&gt;</code> 这种特定的锁类型配合使用。</li>
<li><code>std::condition_variable_any</code> 可以与任何类型的锁（只要提供互斥性）一起使用，包括 <code>std::mutex</code>、<code>std::shared_mutex</code>、<code>std::timed_mutex</code> 等。</li>
</ul>
<p>这使得 <code>std::condition_variable_any</code> 更加通用，但也要求用户更小心地管理锁的类型和行为。</p>
<h3 id="3-核心成员函数"><a href="#3-核心成员函数" class="headerlink" title="3. 核心成员函数"></a>3. 核心成员函数</h3><ul>
<li><p><strong><code>wait(std::unique_lock&lt;Lock&gt;&amp; lock)</code></strong><br>使当前线程在条件变量上等待，直到被通知并且 <code>lock</code> 被重新获得。<code>lock</code> 必须是一个 <code>std::unique_lock</code>，并且它的锁类型可以是任何提供互斥的类型。</p>
</li>
<li><p><strong><code>wait_for(std::unique_lock&lt;Lock&gt;&amp; lock, std::chrono::duration&lt;Rep, Period&gt; const&amp; rel_time)</code></strong><br>与 <code>wait</code> 类似，但是它会在给定的时间段内超时。如果在超时之前没有被通知，线程会自动继续执行。</p>
</li>
<li><p><strong><code>wait_until(std::unique_lock&lt;Lock&gt;&amp; lock, std::chrono::time_point&lt;Clock, Duration&gt; const&amp; abs_time)</code></strong><br>等待直到某个特定的时间点，或者直到通知为止。</p>
</li>
<li><p><strong><code>notify_one()</code></strong><br>通知一个等待中的线程。如果有多个线程在等待条件变量，只有一个会被唤醒。</p>
</li>
<li><p><strong><code>notify_all()</code></strong><br>通知所有等待中的线程。</p>
</li>
</ul>
<h3 id="4-使用示例"><a href="#4-使用示例" class="headerlink" title="4. 使用示例"></a>4. 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable_any cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_id</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lck);  <span class="comment">// Wait until ready is true</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();  <span class="comment">// Notify all waiting threads</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread threads[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Launch threads</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(print_id, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Preparing to launch threads...\n&quot;</span>;</span><br><span class="line">    <span class="built_in">go</span>();  <span class="comment">// Notify all threads to proceed</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) &#123;</span><br><span class="line">        th.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-std-condition-variable-any-的使用场景"><a href="#5-std-condition-variable-any-的使用场景" class="headerlink" title="5. std::condition_variable_any 的使用场景"></a>5. <code>std::condition_variable_any</code> 的使用场景</h3><p><code>std::condition_variable_any</code> 更适用于那些需要灵活选择锁类型的场景。比如，你可能使用 <code>std::shared_mutex</code> 来允许多个线程共享读访问，但仍然需要在某些时刻进行写访问控制。在这种情况下，<code>std::condition_variable_any</code> 会比 <code>std::condition_variable</code> 更适用。</p>
<h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul>
<li><strong>性能考量</strong>：<code>std::condition_variable_any</code> 在某些情况下可能会有更多的性能开销，因为它需要在底层提供更多的灵活性来支持不同类型的锁。</li>
<li><strong>锁的类型匹配</strong>：在使用时，你需要确保传入的锁类型能够正确地支持 <code>wait</code>、<code>wait_for</code> 和 <code>wait_until</code> 等操作。</li>
</ul>
<p>总结来说，<code>std::condition_variable_any</code> 提供了比 <code>std::condition_variable</code> 更强的灵活性，但也要求开发者更细致地考虑锁的类型和同步的复杂性。如果你只需要与 <code>std::mutex</code> 配合使用，通常使用 <code>std::condition_variable</code> 会更加简单和高效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C++_05_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ 相关的理论基础知识</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_18_cmath/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_18_cmath/" class="post-title-link" itemprop="url">C++_10_18_cmath</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <cmath>标准库</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_18_cmath/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_1_random/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_1_random/" class="post-title-link" itemprop="url">C++_10_1_random</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ random标准库笔记</li>
</ul>
<h2 id="C-random标准库是什么"><a href="#C-random标准库是什么" class="headerlink" title="C++ random标准库是什么"></a>C++ random标准库是什么</h2><p>C++ 标准库中的 <code>&lt;random&gt;</code> 头文件提供了用于生成随机数的工具和类。这个库提供了众多的随机数生成器和分布器，以支持高质量的随机数生成操作。使用 <code>&lt;random&gt;</code> 头文件可以生成各种类型的随机数，包括整数、浮点数以及其他分布的随机数。</p>
<p>以下是一些 <code>&lt;random&gt;</code> 头文件中常用的类和功能：</p>
<ol>
<li><p><strong>随机数引擎（Random Number Engines）</strong>：随机数引擎是一种生成随机数的算法。C++ 提供了几种不同的随机数引擎，例如 <code>std::default_random_engine</code>、<code>std::mt19937</code>（Mersenne Twister 引擎）等。</p>
</li>
<li><p><strong>分布器（Random Number Distributions）</strong>：分布器用于将随机数引擎生成的随机数映射到指定的分布上，如均匀分布、正态分布等。常见的分布器有 <code>std::uniform_int_distribution</code>（生成整数均匀分布）、<code>std::uniform_real_distribution</code>（生成浮点数均匀分布）等。</p>
</li>
<li><p><strong>随机设备（Random Devices）</strong>：<code>std::random_device</code> 是一个用于获取真随机数的设备，但其随机性取决于平台和实现。</p>
</li>
</ol>
<p>使用 <code>&lt;random&gt;</code> 头文件，可以轻松地生成随机数，并根据需要控制其分布特性。例如，以下是一个简单的示例，展示了如何使用随机数引擎和分布器生成随机整数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建随机数引擎和分布器</span></span><br><span class="line">    std::random_device rd; <span class="comment">// 随机设备</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>; <span class="comment">// Mersenne Twister 引擎</span></span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 生成1到100之间的均匀分布的随机整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">dis</span>(gen);</span><br><span class="line">        std::cout &lt;&lt; random_number &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例使用 Mersenne Twister 引擎和均匀整数分布器生成了10个1到100之间的随机整数。</p>
<p><code>&lt;random&gt;</code> 标准库提供了灵活和强大的工具，可用于各种需要随机性的应用程序，例如模拟、密码学、游戏开发等。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <random>标准库 详解</h2><p><code>&lt;random&gt;</code> 是 C++ 标准库中用于生成随机数的头文件。它提供了一组类和函数，用于生成高质量的随机数，并支持不同的随机数引擎和分布。</p>
<p>下面是 <code>&lt;random&gt;</code> 头文件中一些重要的类和函数：</p>
<ol>
<li><p><strong>随机数引擎（Random Number Engines）</strong>：随机数引擎是一个产生随机数序列的算法。C++ 提供了多种随机数引擎，例如 <code>std::default_random_engine</code>、<code>std::mt19937</code>（Mersenne Twister 引擎）、<code>std::minstd_rand</code>（线性同余法引擎）等。你可以根据需要选择不同的引擎。</p>
</li>
<li><p><strong>随机数分布器（Random Number Distributions）</strong>：随机数分布器用于将随机数引擎生成的随机数映射到指定的分布上。常用的分布器包括 <code>std::uniform_int_distribution</code>（生成整数均匀分布）、<code>std::uniform_real_distribution</code>（生成浮点数均匀分布）、<code>std::normal_distribution</code>（生成正态分布）、<code>std::poisson_distribution</code>（生成泊松分布）等。</p>
</li>
<li><p><strong>随机设备（Random Devices）</strong>：<code>std::random_device</code> 是一个用于获取真随机数的设备。它可能会提供硬件随机数或者伪随机数，具体取决于实现和平台。可以用它来初始化随机数引擎，提供更好的随机性。</p>
</li>
</ol>
<p>下面是一个简单示例，演示了如何使用 <code>&lt;random&gt;</code> 头文件生成随机数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建随机设备和引擎</span></span><br><span class="line">    std::random_device rd;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>; <span class="comment">// 使用 Mersenne Twister 引擎</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建均匀分布器并生成随机整数</span></span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 生成1到100之间的均匀分布的随机整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">dis</span>(gen);</span><br><span class="line">        std::cout &lt;&lt; random_number &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例使用 Mersenne Twister 引擎和均匀整数分布器生成了10个1到100之间的随机整数。</p>
<p><code>&lt;random&gt;</code> 头文件提供了灵活且高效的随机数生成工具，可以满足各种应用程序对随机性的需求。当你需要生成随机数时，可以根据自己的需求选择合适的引擎和分布器。</p>
<h2 id="C-std-random-device-是什么"><a href="#C-std-random-device-是什么" class="headerlink" title="C++ std::random_device 是什么"></a>C++ std::random_device 是什么</h2><p><code>std::random_device</code> 是 C++ 标准库提供的类，用于获取真随机数。它被设计为一个可用于产生高质量随机数种子的设备，可以提供来自硬件和操作系统的真随机数，也可以提供伪随机数。</p>
<p><code>std::random_device</code> 可以用作随机数引擎的种子（如 Mersenne Twister 引擎 <code>std::mt19937</code>）的初始化器，以提供更好的随机性。</p>
<p>然而，需要注意的是，<code>std::random_device</code> 并不是在所有平台和实现上都能提供真正的硬件随机数。在某些系统上，它可能会退化成伪随机数生成器，或者可能由于系统限制而无法提供高质量的随机数。</p>
<p>通常，<code>std::random_device</code> 是作为初始化随机数引擎的种子使用，而不是直接生成随机数序列。下面是一个简单的示例，演示了如何使用 <code>std::random_device</code> 初始化 Mersenne Twister 引擎：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建随机设备</span></span><br><span class="line">    std::random_device rd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用随机设备来初始化 Mersenne Twister 引擎</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建均匀分布器并生成随机整数</span></span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 生成1到100之间的均匀分布的随机整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">dis</span>(gen);</span><br><span class="line">        std::cout &lt;&lt; random_number &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::random_device</code> 用于初始化了 Mersenne Twister 引擎 <code>std::mt19937</code>，然后使用该引擎生成了10个1到100之间的随机整数。</p>
<h2 id="C-std-random-device详解"><a href="#C-std-random-device详解" class="headerlink" title="C++ std::random_device详解"></a>C++ std::random_device详解</h2><p><code>std::random_device</code> 是 C++ 标准库提供的类，用于获取随机数的设备。它旨在提供高质量的随机数种子，可用作随机数引擎的初始化器，以生成更好质量的随机数序列。</p>
<p>以下是关于 <code>std::random_device</code> 的详细说明：</p>
<ol>
<li><p><strong>随机性</strong>：</p>
<ul>
<li><code>std::random_device</code> 通常被设计为提供真随机数，但实现的随机性取决于底层操作系统和硬件设备的支持。</li>
<li>在大多数情况下，<code>std::random_device</code> 会尝试获取来自硬件设备或操作系统的真随机数。但有些平台可能会将其实现为伪随机数生成器，特别是当没有真正的硬件随机数可用时，或者由于平台限制而无法提供真随机性。</li>
</ul>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li>最常见的用途是作为随机数引擎的种子。它可以提供一个高质量的种子，用于初始化伪随机数生成器（如 Mersenne Twister 引擎 <code>std::mt19937</code>）。</li>
<li>在生成密码学安全的随机数时，<code>std::random_device</code> 通常用作种子。</li>
</ul>
</li>
<li><p><strong>生成随机数序列</strong>：</p>
<ul>
<li><code>std::random_device</code> 并不直接生成随机数序列，而是产生用于初始化随机数引擎的种子。</li>
<li>一般地，通过使用 <code>std::random_device</code> 初始化随机数引擎，然后再使用引擎生成随机数序列。</li>
</ul>
</li>
<li><p><strong>初始化引擎</strong>：</p>
<ul>
<li>初始化引擎时，通常将 <code>std::random_device</code> 作为种子参数传递给引擎构造函数或作为引擎对象的参数。</li>
<li>例如：<code>std::mt19937 gen(rd());</code>，其中 <code>rd</code> 是 <code>std::random_device</code> 的一个实例。</li>
</ul>
</li>
<li><p><strong>实现依赖性</strong>：</p>
<ul>
<li><code>std::random_device</code> 在不同的平台和编译器实现中可能表现不同，有些平台可能无法提供真随机数，或者提供的随机性不足。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>std::random_device</code> 是用于获取随机数种子的一种机制。在大多数情况下，它能够提供高质量的随机数种子，以供初始化伪随机数生成器。但在某些特定情况下，可能会受到平台限制或实现差异的影响。</p>
<h2 id="std-default-random-engine"><a href="#std-default-random-engine" class="headerlink" title="std::default_random_engine"></a>std::default_random_engine</h2><p><code>std::default_random_engine</code> 是 C++ 标准库中的一个类模板，用于生成伪随机数的引擎部分，位于 <code>&lt;random&gt;</code> 头文件中。它是 C++ 提供的一个伪随机数生成器（Pseudo-Random Number Generator，PRNG），能够生成一系列的随机数。</p>
<p>这个引擎的实现可能因不同的 C++ 标准库而异，但通常实现了某种伪随机数算法来生成随机数。在程序中使用 <code>std::default_random_engine</code> 可以生成随机数序列，通常需要与其他组件（例如分布器）结合使用来生成特定分布的随机数。</p>
<p>以下是一个简单的示例，演示了如何使用 <code>std::default_random_engine</code> 生成随机数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建默认随机数引擎</span></span><br><span class="line">    std::default_random_engine generator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成整数分布为[1, 6]的随机数</span></span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>使用 <code>std::default_random_engine</code> 创建了一个默认的随机数引擎。</li>
<li>使用 <code>std::uniform_int_distribution</code> 定义了一个整数分布，范围为 <code>[1, 6]</code>。</li>
<li>在循环中，<code>distribution(generator)</code> 使用 <code>generator</code> 引擎生成了指定范围内的随机数。</li>
</ul>
<p>需要注意的是，<code>std::default_random_engine</code> 可能会因实现的不同而有不同的特性和性能，对于一些需要高质量随机数的场景，可能需要选择更加复杂的随机数引擎或者特定算法来满足需求。</p>
<h2 id="std-mt19937"><a href="#std-mt19937" class="headerlink" title="std::mt19937"></a>std::mt19937</h2><p><code>std::mt19937</code> 是 C++ 标准库 <code>&lt;random&gt;</code> 头文件中定义的 Mersenne Twister 随机数引擎的一个特定实例。Mersenne Twister 是一种流行的伪随机数生成器 (PRNG) 算法，提供了高质量、高周期性的随机数序列。</p>
<p><code>std::mt19937</code> 使用 32 位整数作为状态空间，并且具有一个非常大的周期，通常为 2^19937-1。这种引擎在大多数情况下提供了良好的随机性和性能。</p>
<p>以下是一个使用 <code>std::mt19937</code> 的简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Mersenne Twister 引擎实例</span></span><br><span class="line">    std::mt19937 generator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义整数分布为[1, 100]范围内的随机数</span></span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">1</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>使用 <code>std::mt19937</code> 创建了一个 Mersenne Twister 引擎实例。</li>
<li>使用 <code>std::uniform_int_distribution</code> 定义了一个整数分布，范围为 <code>[1, 100]</code>。</li>
<li>在循环中，<code>distribution(generator)</code> 使用 <code>generator</code> 引擎生成了指定范围内的随机数。</li>
</ul>
<p><code>std::mt19937</code> 是一个常用的随机数引擎，通常能够满足大多数随机数生成的需求。然而，在一些特殊场景下，可能需要根据特定需求选择其他的随机数引擎或者更复杂的生成算法。</p>
<h2 id="std-uniform-int-distribution"><a href="#std-uniform-int-distribution" class="headerlink" title="std::uniform_int_distribution"></a>std::uniform_int_distribution</h2><p><code>std::uniform_int_distribution</code> 是 C++ 标准库 <code>&lt;random&gt;</code> 头文件中定义的类模板，用于产生指定范围内均匀分布的整数随机数。</p>
<p>该类模板允许您定义一个离散的整数分布，指定了随机数的范围。在生成随机数时，会根据指定的范围，以均匀分布的方式生成整数。</p>
<p>以下是一个使用 <code>std::uniform_int_distribution</code> 的简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Mersenne Twister 引擎实例</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">generator</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义整数分布为[1, 100]范围内的随机数</span></span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">1</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>使用 <code>std::mt19937</code> 创建了一个 Mersenne Twister 引擎实例，并使用 <code>std::random_device</code> 作为种子。</li>
<li>使用 <code>std::uniform_int_distribution</code> 定义了一个整数分布，范围为 <code>[1, 100]</code>。</li>
<li>在循环中，<code>distribution(generator)</code> 使用 <code>generator</code> 引擎生成了指定范围内的随机数。</li>
</ul>
<p><code>std::uniform_int_distribution</code> 是一个用于生成指定范围内均匀分布的整数随机数的实用工具，可以方便地生成各种整数范围内的随机数。</p>
<h2 id="std-uniform-real-distribution"><a href="#std-uniform-real-distribution" class="headerlink" title="std::uniform_real_distribution"></a>std::uniform_real_distribution</h2><p><code>std::uniform_real_distribution</code> 是 C++ 标准库 <code>&lt;random&gt;</code> 头文件中定义的类模板，用于产生指定范围内均匀分布的实数（浮点数）随机数。</p>
<p>该类模板允许您定义一个连续的均匀分布，指定了随机数的范围。在生成随机数时，会根据指定的范围，以均匀分布的方式生成浮点数。</p>
<p>以下是一个使用 <code>std::uniform_real_distribution</code> 的简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Mersenne Twister 引擎实例</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">generator</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义实数分布为[0.0, 1.0)范围内的随机数</span></span><br><span class="line">    <span class="function">std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>使用 <code>std::mt19937</code> 创建了一个 Mersenne Twister 引擎实例，并使用 <code>std::random_device</code> 作为种子。</li>
<li>使用 <code>std::uniform_real_distribution</code> 定义了一个实数分布，范围为 <code>[0.0, 1.0)</code>。</li>
<li>在循环中，<code>distribution(generator)</code> 使用 <code>generator</code> 引擎生成了指定范围内的随机数。</li>
</ul>
<p><code>std::uniform_real_distribution</code> 是一个用于生成指定范围内均匀分布的实数随机数的实用工具，可以方便地生成各种浮点数范围内的随机数。</p>
<h2 id="std-normal-distribution"><a href="#std-normal-distribution" class="headerlink" title="std::normal_distribution"></a>std::normal_distribution</h2><p><code>std::normal_distribution</code> 是 C++ 标准库 <code>&lt;random&gt;</code> 头文件中定义的类模板，用于产生指定均值和标准差的正态分布（高斯分布）的随机数。</p>
<p>正态分布是一种连续的概率分布，通常称为高斯分布，其形状呈钟形曲线，以均值为中心，并由标准差确定其宽度。<code>std::normal_distribution</code> 允许您生成服从正态分布的随机数。</p>
<p>以下是一个使用 <code>std::normal_distribution</code> 的简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Mersenne Twister 引擎实例</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">generator</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义正态分布，均值为 0，标准差为 1 的随机数</span></span><br><span class="line">    <span class="function">std::normal_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>使用 <code>std::mt19937</code> 创建了一个 Mersenne Twister 引擎实例，并使用 <code>std::random_device</code> 作为种子。</li>
<li>使用 <code>std::normal_distribution</code> 定义了一个正态分布，均值为 <code>0.0</code>，标准差为 <code>1.0</code>。</li>
<li>在循环中，<code>distribution(generator)</code> 使用 <code>generator</code> 引擎生成了符合指定正态分布的随机数。</li>
</ul>
<p><code>std::normal_distribution</code> 是一个用于生成指定均值和标准差的正态分布随机数的实用工具，可以方便地生成服从正态分布的随机数。</p>
<h2 id="std-poisson-distribution"><a href="#std-poisson-distribution" class="headerlink" title="std::poisson_distribution"></a>std::poisson_distribution</h2><p><code>std::poisson_distribution</code> 是 C++ 标准库 <code>&lt;random&gt;</code> 头文件中定义的类模板，用于生成服从泊松分布的随机整数。</p>
<p>泊松分布是一种描述在一定时间或空间范围内，事件发生次数的概率分布。它适用于描述在固定时间或空间区间内，事件发生的次数，如单位时间内接收到的电话数、一段时间内发生的交通事故次数等等。</p>
<p>以下是一个使用 <code>std::poisson_distribution</code> 的简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Mersenne Twister 引擎实例</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">generator</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义泊松分布，lambda 值为 2.0</span></span><br><span class="line">    <span class="function">std::poisson_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">2.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>使用 <code>std::mt19937</code> 创建了一个 Mersenne Twister 引擎实例，并使用 <code>std::random_device</code> 作为种子。</li>
<li>使用 <code>std::poisson_distribution</code> 定义了一个泊松分布，lambda 值为 <code>2.0</code>。</li>
<li>在循环中，<code>distribution(generator)</code> 使用 <code>generator</code> 引擎生成了服从指定泊松分布的随机整数。</li>
</ul>
<p><code>std::poisson_distribution</code> 是一个用于生成服从泊松分布的随机整数的实用工具，可以方便地生成符合泊松分布的随机数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_17_fstream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_17_fstream/" class="post-title-link" itemprop="url">C++_10_17_fstream</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <fstream>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <fstream>标准库</h2><p>在 C++ 中，<code>&lt;fstream&gt;</code> 是标准库中用于文件输入和输出的头文件。它提供了用于操作文件的类和函数，允许你以输入和输出的方式处理文件数据。</p>
<p>这个头文件定义了三个主要的类：</p>
<ol>
<li><code>std::ifstream</code>: 用于从文件中读取数据（输入文件流）。</li>
<li><code>std::ofstream</code>: 用于向文件写入数据（输出文件流）。</li>
<li><code>std::fstream</code>: 用于读写文件（输入输出文件流）。</li>
</ol>
<p>这些类都继承自 <code>std::istream</code>（用于输入）或 <code>std::ostream</code>（用于输出），因此它们具有类似于 <code>std::cin</code> 和 <code>std::cout</code> 的功能。</p>
<p>以下是一个简单的示例，展示了如何使用 <code>&lt;fstream&gt;</code> 头文件中的 <code>std::ifstream</code> 和 <code>std::ofstream</code> 类来读取和写入文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>; <span class="comment">// 创建一个输出文件流对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        outputFile &lt;&lt; <span class="string">&quot;Writing this to a file.\n&quot;</span>;</span><br><span class="line">        outputFile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件流</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to open file for writing!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>; <span class="comment">// 创建一个输入文件流对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::string line;</span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">getline</span>(inputFile, line)) &#123; <span class="comment">// 逐行读取文件内容</span></span><br><span class="line">            std::cout &lt;&lt; line &lt;&lt; std::endl; <span class="comment">// 输出到控制台</span></span><br><span class="line">        &#125;</span><br><span class="line">        inputFile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件流</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to open file for reading!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先使用 <code>std::ofstream</code> 打开一个文件输出流，并向文件 “output.txt” 写入一行数据。接着使用 <code>std::ifstream</code> 打开相同的文件作为输入流，并使用 <code>std::getline</code> 逐行读取文件内容，并输出到控制台。</p>
<p>这些文件流类提供了许多其他的功能，比如定位到文件特定位置、判断文件是否打开、错误处理等，可以根据需要在程序中使用。</p>
<h2 id="C-标准库-常用类和函数"><a href="#C-标准库-常用类和函数" class="headerlink" title="C++ 标准库 常用类和函数"></a>C++ <fstream>标准库 常用类和函数</h2><p>在 C++ 的 <code>&lt;fstream&gt;</code> 标准库中，常用的类和函数用于文件的输入和输出操作。以下是一些常用的类和函数：</p>
<h3 id="常用类："><a href="#常用类：" class="headerlink" title="常用类："></a>常用类：</h3><ol>
<li><p>**<code>std::ifstream</code>**：</p>
<ul>
<li>用于从文件中读取数据的输入文件流类。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;filename.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>std::ofstream</code>**：</p>
<ul>
<li>用于向文件写入数据的输出文件流类。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(<span class="string">&quot;filename.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>std::fstream</code>**：</p>
<ul>
<li>用于同时进行文件读写操作的输入输出文件流类。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::fstream <span class="title">file</span><span class="params">(<span class="string">&quot;filename.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ol>
<li><p>**<code>open()</code>**：</p>
<ul>
<li>打开文件，可以指定文件名和打开模式。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ifstream inputFile;</span><br><span class="line">inputFile.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>close()</code>**：</p>
<ul>
<li>关闭文件。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>is_open()</code>**：</p>
<ul>
<li>检查文件是否打开。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    <span class="comment">// 文件已打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>operator&lt;&lt;</code> 和 <code>operator&gt;&gt;</code>**：</p>
<ul>
<li>用于向文件写入数据和从文件读取数据。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outputFile &lt;&lt; <span class="string">&quot;Writing to file\n&quot;</span>;</span><br><span class="line">inputFile &gt;&gt; data;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>getline()</code>**：</p>
<ul>
<li>从文件中逐行读取数据。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string line;</span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(inputFile, line)) &#123;</span><br><span class="line">    <span class="comment">// 处理每一行数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>tellg()</code> 和 <code>seekg()</code>**（对于 <code>std::fstream</code>）：</p>
<ul>
<li><code>tellg()</code> 返回当前文件指针的位置。</li>
<li><code>seekg()</code> 设置文件指针到指定位置。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputFile.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg); <span class="comment">// 将文件指针移至文件开头</span></span><br><span class="line">std::streampos position = inputFile.<span class="built_in">tellg</span>(); <span class="comment">// 获取当前文件指针位置</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>这些是 <code>&lt;fstream&gt;</code> 头文件中最常用的类和函数。它们提供了强大的功能，允许你对文件进行读写操作，并且具有一些用于定位、判断文件状态、格式化输入输出等额外的功能。</p>
<h2 id="std-ifstream"><a href="#std-ifstream" class="headerlink" title="std::ifstream"></a>std::ifstream</h2><p><code>std::ifstream</code> 是 C++ 标准库中的类，用于从文件中读取数据。它是 <code>std::istream</code> 的派生类，提供了用于从文件读取数据的功能。</p>
<h3 id="创建-std-ifstream-对象："><a href="#创建-std-ifstream-对象：" class="headerlink" title="创建 std::ifstream 对象："></a>创建 <code>std::ifstream</code> 对象：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;filename.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件已成功打开</span></span><br><span class="line">        <span class="comment">// 可以使用 inputFile 对象进行读取操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件打开失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inputFile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要方法和功能："><a href="#主要方法和功能：" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ol>
<li><p>**<code>open()</code>**：用于打开文件，可以指定文件名和打开模式。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ifstream inputFile;</span><br><span class="line">inputFile.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>is_open()</code>**：检查文件是否成功打开。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    <span class="comment">// 文件已打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>close()</code>**：关闭文件。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>operator&gt;&gt;</code>**：从文件中读取数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data;</span><br><span class="line">inputFile &gt;&gt; data;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>getline()</code>**：从文件中逐行读取数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string line;</span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(inputFile, line)) &#123;</span><br><span class="line">    <span class="comment">// 处理每一行数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>tellg()</code> 和 <code>seekg()</code>**：用于获取和设置文件指针位置（对于 <code>std::ifstream</code> ）。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputFile.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg); <span class="comment">// 将文件指针移至文件开头</span></span><br><span class="line">std::streampos position = inputFile.<span class="built_in">tellg</span>(); <span class="comment">// 获取当前文件指针位置</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>std::ifstream</code> 允许你打开一个文件以供读取数据，并提供了许多方法来从文件中读取数据，包括按字节、按行等不同方式，使得文件读取操作非常灵活。</p>
<h2 id="std-ofstream"><a href="#std-ofstream" class="headerlink" title="std::ofstream"></a>std::ofstream</h2><p><code>std::ofstream</code> 是 C++ 标准库中的类，用于向文件中写入数据。它是 <code>std::ostream</code> 的派生类，提供了向文件写入数据的功能。</p>
<h3 id="创建-std-ofstream-对象："><a href="#创建-std-ofstream-对象：" class="headerlink" title="创建 std::ofstream 对象："></a>创建 <code>std::ofstream</code> 对象：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(<span class="string">&quot;filename.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (outputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件已成功打开</span></span><br><span class="line">        <span class="comment">// 可以使用 outputFile 对象进行写入操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件打开失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    outputFile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要方法和功能：-1"><a href="#主要方法和功能：-1" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ol>
<li><p>**<code>open()</code>**：用于打开文件，可以指定文件名和打开模式。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ofstream outputFile;</span><br><span class="line">outputFile.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>is_open()</code>**：检查文件是否成功打开。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (outputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    <span class="comment">// 文件已打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>close()</code>**：关闭文件。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>operator&lt;&lt;</code>**：向文件中写入数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputFile &lt;&lt; <span class="string">&quot;Writing this to the file.\n&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>std::ofstream</code> 允许你打开一个文件以供写入数据，并提供了 <code>operator&lt;&lt;</code> 等方法来向文件中写入数据。你可以使用这些方法将数据以文本或二进制形式写入文件中，完成各种文件写入操作。</p>
<h2 id="std-fstream"><a href="#std-fstream" class="headerlink" title="std::fstream"></a>std::fstream</h2><p><code>std::fstream</code> 是 C++ 标准库中的类，用于对文件进行读写操作。它是 <code>std::iostream</code> 的派生类，同时具有读取和写入文件的能力。</p>
<h3 id="创建-std-fstream-对象："><a href="#创建-std-fstream-对象：" class="headerlink" title="创建 std::fstream 对象："></a>创建 <code>std::fstream</code> 对象：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::fstream <span class="title">file</span><span class="params">(<span class="string">&quot;filename.txt&quot;</span>, std::ios::in | std::ios::out)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件已成功打开</span></span><br><span class="line">        <span class="comment">// 可以使用 file 对象进行读写操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件打开失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要方法和功能：-2"><a href="#主要方法和功能：-2" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ol>
<li><p>**<code>open()</code>**：用于打开文件，可以指定文件名和打开模式。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::fstream file;</span><br><span class="line">file.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, std::ios::in | std::ios::out);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>std::ios::in</code>：以读取模式打开文件。</li>
<li><code>std::ios::out</code>：以写入模式打开文件。</li>
<li><code>std::ios::app</code>：在文件末尾追加数据。</li>
</ul>
</li>
<li><p>**<code>is_open()</code>**：检查文件是否成功打开。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    <span class="comment">// 文件已打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>close()</code>**：关闭文件。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>operator&lt;&lt;</code> 和 <code>operator&gt;&gt;</code>**：用于向文件写入数据和从文件读取数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file &lt;&lt; <span class="string">&quot;Writing to file\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">file &gt;&gt; data;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>seekg()</code> 和 <code>tellg()</code></strong> 和 **<code>seekp()</code> 和 <code>tellp()</code>**：用于获取和设置文件指针位置。</p>
<ul>
<li><p>对于输入位置（<code>get</code>）：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg); <span class="comment">// 将文件指针移至文件开头</span></span><br><span class="line">std::streampos position = file.<span class="built_in">tellg</span>(); <span class="comment">// 获取当前文件指针位置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于输出位置（<code>put</code>）：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">seekp</span>(<span class="number">0</span>, std::ios::beg); <span class="comment">// 将文件指针移至文件开头</span></span><br><span class="line">std::streampos position = file.<span class="built_in">tellp</span>(); <span class="comment">// 获取当前文件指针位置</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><code>std::fstream</code> 可以用于同时进行文件读取和写入操作，提供了一些类似 <code>std::ifstream</code> 和 <code>std::ofstream</code> 的方法和功能，可以更灵活地对文件进行操作。</p>
<h2 id="std-fstream-open"><a href="#std-fstream-open" class="headerlink" title="std::fstream::open()"></a>std::fstream::open()</h2><p><code>std::fstream::open()</code> 是 C++ 标准库 <code>&lt;fstream&gt;</code> 头文件中 <code>std::fstream</code> 类的成员函数之一。它用于打开文件并将其与 <code>std::fstream</code> 对象关联，从而允许对文件进行读取或写入操作。</p>
<p>这是 <code>std::fstream::open()</code> 的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::fstream fileStream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个文件进行输入/输出操作</span></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, std::ios::in | std::ios::out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件成功打开，执行操作</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成操作后关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未能打开文件，处理错误</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>open()</code> 中使用的参数解释：</p>
<ul>
<li><code>&quot;filename.txt&quot;</code> 是要打开的文件名。</li>
<li><code>std::ios::in</code> 指定文件将用于输入操作。</li>
<li><code>std::ios::out</code> 指定文件将用于输出操作。</li>
<li><code>std::ios::in | std::ios::out</code> 是一个示例，使用按位 OR 运算符结合这些标志，允许在文件上进行输入和输出操作。根据所需的文件访问模式，可以使用其他标志（例如 <code>std::ios::app</code>、<code>std::ios::binary</code> 等）。</li>
</ul>
<p>在执行任何读取或写入操作之前，请确保使用 <code>is_open()</code> 检查文件是否成功打开。另外，在对文件执行操作后，最好使用 <code>close()</code> 成员函数关闭文件，以释放与文件关联的资源。</p>
<p>此外，应实现错误处理来处理无法打开文件的情况，例如文件不存在或程序没有足够的权限访问文件等情况。</p>
<h2 id="std-ios"><a href="#std-ios" class="headerlink" title="std::ios"></a>std::ios</h2><p><code>std::ios</code> 是 C++ 标准库中定义的一个位掩码枚举类型，用于指定流的状态和控制流的行为。它提供了一系列常量，用于在文件流或内存流中指定不同的行为和状态。</p>
<p>这些常量通常与流类（比如 <code>std::ifstream</code>、<code>std::ofstream</code>、<code>std::fstream</code> 等）的成员函数一起使用，例如 <code>open()</code>、<code>close()</code> 等。</p>
<p>以下是一些 <code>std::ios</code> 类型的常量：</p>
<ul>
<li><code>std::ios::in</code>：用于输入操作，允许从流中读取数据。</li>
<li><code>std::ios::out</code>：用于输出操作，允许向流中写入数据。</li>
<li><code>std::ios::binary</code>：指定以二进制模式打开文件，用于处理二进制数据。</li>
<li><code>std::ios::ate</code>：在打开文件时将文件指针移到文件末尾。</li>
<li><code>std::ios::app</code>：在打开文件时将文件指针移到文件末尾，并在写入时将数据追加到文件末尾。</li>
<li><code>std::ios::trunc</code>：如果文件已经存在，打开时将文件截断为零长度。</li>
</ul>
<p>这些常量可以通过按位 OR 运算符结合使用，以同时指定多个流状态。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ofstream fileStream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件进行输出操作，并在文件末尾追加数据</span></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, std::ios::out | std::ios::app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件成功打开，执行操作</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成操作后关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未能打开文件，处理错误</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>std::ios::out | std::ios::app</code> 将打开文件以允许输出操作，并在文件末尾追加数据。</p>
<p><code>std::ios</code> 类型提供了灵活的控制和配置流的能力，可以根据需要组合使用这些常量，以满足特定的文件读写需求。</p>
<h2 id="std-fstream-close"><a href="#std-fstream-close" class="headerlink" title="std::fstream::close()"></a>std::fstream::close()</h2><p><code>std::fstream::close()</code> 是 C++ 标准库中 <code>std::fstream</code> 类的成员函数之一。它用于关闭先前由 <code>std::fstream::open()</code> 打开的文件。</p>
<p>在对文件执行读取或写入操作后，通常应使用 <code>std::fstream::close()</code> 函数来关闭文件，以释放与该文件关联的资源并确保对文件所做的更改被保存。关闭文件可以防止数据丢失或文件损坏，并允许其他程序或进程访问该文件。</p>
<p>以下是 <code>std::fstream::close()</code> 的使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::fstream fileStream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件进行读取/写入操作</span></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, std::ios::in | std::ios::out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件成功打开，执行读取/写入操作</span></span><br><span class="line">        fileStream &lt;&lt; <span class="string">&quot;Hello, File!&quot;</span>; <span class="comment">// 写入数据到文件</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File closed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未能打开文件，处理错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to open the file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::fstream::close()</code> 在操作文件后调用，以关闭先前打开的文件。在关闭文件之前，任何对文件的操作都应该完成，以确保数据正确地写入文件。当文件不再需要时，最好及时关闭文件。</p>
<p>关闭文件的操作是一个良好的编程实践，有助于避免资源泄漏并确保文件的正确处理。</p>
<h2 id="std-fstream-is-open"><a href="#std-fstream-is-open" class="headerlink" title="std::fstream::is_open()"></a>std::fstream::is_open()</h2><p><code>std::fstream::is_open()</code> 是 <code>std::fstream</code> 类的成员函数之一，用于检查与 <code>std::fstream</code> 对象关联的文件是否成功打开。该函数返回一个 <code>bool</code> 类型的值，指示文件是否已打开。</p>
<p>以下是 <code>std::fstream::is_open()</code> 的基本用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::fstream fileStream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试打开文件进行读取/写入操作</span></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, std::ios::in | std::ios::out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件成功打开，执行读取/写入操作</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File is open.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未能打开文件，处理错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to open the file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::fstream::is_open()</code> 用于检查文件是否成功打开。如果文件成功打开，则输出 <code>&quot;File is open.&quot;</code>，否则输出 <code>&quot;Failed to open the file.&quot;</code>。这可以帮助您在执行读取或写入操作之前检查文件是否已正确打开，以避免在无法访问文件的情况下执行文件操作。</p>
<p>使用 <code>std::fstream::is_open()</code> 是一种良好的实践，可用于确保文件已正确打开并准备接受读取或写入操作。</p>
<h2 id="std-fstream-operator"><a href="#std-fstream-operator" class="headerlink" title="std::fstream::operator&lt;&lt;"></a>std::fstream::operator&lt;&lt;</h2><p><code>std::fstream::operator&lt;&lt;</code> 是用于向文件流 (<code>std::fstream</code>) 写入数据的操作符重载。它允许像使用 <code>&lt;&lt;</code> 操作符一样向文件中写入数据，类似于向 <code>std::cout</code> 输出流中写入数据一样。</p>
<p>这个操作符重载通常与文件流对象一起使用，允许将各种类型的数据写入到已打开的文件中。</p>
<p>以下是一个简单的示例，演示了如何使用 <code>std::fstream::operator&lt;&lt;</code> 将数据写入文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ofstream fileStream; <span class="comment">// 使用 ofstream，但也可以使用 fstream</span></span><br><span class="line"></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>); <span class="comment">// 打开文件进行写入操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">        <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">        std::string message = <span class="string">&quot;Hello, File!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向文件写入数据</span></span><br><span class="line">        fileStream &lt;&lt; <span class="string">&quot;An integer: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">        fileStream &lt;&lt; <span class="string">&quot;A double: &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">        fileStream &lt;&lt; <span class="string">&quot;A message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data written to file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to open the file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>fileStream &lt;&lt; &quot;An integer: &quot; &lt;&lt; number &lt;&lt; std::endl;</code> 将整数、浮点数和字符串写入了文件中。<code>&lt;&lt;</code> 操作符被用于串联不同类型的数据，并将它们写入到打开的文件流中。<code>std::endl</code> 用于在文件中插入换行符。</p>
<p>请注意，在使用 <code>std::fstream::operator&lt;&lt;</code> 之前，确保文件已经成功打开，并且操作完毕后，记得关闭文件流以释放资源。</p>
<h2 id="std-fstream-operator-1"><a href="#std-fstream-operator-1" class="headerlink" title="std::fstream::operator&gt;&gt;"></a>std::fstream::operator&gt;&gt;</h2><p><code>std::fstream::operator&gt;&gt;</code> 是 C++ 标准库中 <code>std::fstream</code> 类的成员函数之一，用于文件流的输入操作。它允许从文件流中读取数据，类似于从标准输入流 <code>std::cin</code> 中读取数据。</p>
<p>这个操作符重载通常用于从已打开的文件中读取数据，并根据不同的数据类型进行提取。它可以和 <code>std::ifstream</code> 或 <code>std::fstream</code> 对象一起使用，允许从文件中读取各种类型的数据。</p>
<p>以下是一个示例，演示了如何使用 <code>std::fstream::operator&gt;&gt;</code> 从文件中读取数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ifstream fileStream; <span class="comment">// 使用 ifstream 进行输入操作</span></span><br><span class="line"></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>); <span class="comment">// 打开文件进行读取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> number;</span><br><span class="line">        <span class="type">double</span> pi;</span><br><span class="line">        std::string message;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件中读取数据</span></span><br><span class="line">        fileStream &gt;&gt; number &gt;&gt; pi &gt;&gt; message;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示从文件中读取的数据</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Number: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pi: &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取完成后关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法打开文件。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>operator&gt;&gt;</code> 用于从文件流 (<code>fileStream</code>) 中提取整数、浮点数和字符串，并将它们存储到相应的变量中（<code>number</code>、<code>pi</code>、<code>message</code>）。然后，它将从文件中提取的数据显示在控制台上。</p>
<p>请确保在尝试从文件中读取数据之前，文件已经成功打开，并在读取完成后关闭文件流，释放相关资源。</p>
<h2 id="std-fstream-getline"><a href="#std-fstream-getline" class="headerlink" title="std::fstream::getline()"></a>std::fstream::getline()</h2><p><code>std::fstream::getline()</code> 是 <code>std::fstream</code> 类的成员函数之一，用于从文件中逐行读取数据并将其存储到字符串中。</p>
<p>这个函数通常与 <code>std::ifstream</code> 或 <code>std::fstream</code> 对象一起使用，用于从文件中读取文本数据，并将每行数据存储到字符串中。</p>
<p>以下是一个示例，演示了如何使用 <code>std::fstream::getline()</code> 从文件中逐行读取数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ifstream fileStream; <span class="comment">// 使用 ifstream 进行输入操作</span></span><br><span class="line"></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>); <span class="comment">// 打开文件进行读取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::string line;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐行读取文件中的数据</span></span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">getline</span>(fileStream, line)) &#123;</span><br><span class="line">            <span class="comment">// 处理每行读取的数据</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Line read: &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取完成后关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法打开文件。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::fstream::getline()</code> 用于从文件流 (<code>fileStream</code>) 中逐行读取数据，并将每行数据存储在名为 <code>line</code> 的字符串中。然后，每次读取一行后，它将该行数据显示在控制台上。</p>
<p>这是一个非常常用的方法，特别是当需要按行读取文本文件中的内容时。每次调用 <code>getline()</code> 函数时，它会读取文件的下一行，并将其存储到字符串中，直到文件结束或发生读取错误为止。</p>
<p>请确保文件已成功打开，并在读取完成后关闭文件流，以便释放相关资源。</p>
<h2 id="std-fstream-tellg"><a href="#std-fstream-tellg" class="headerlink" title="std::fstream::tellg()"></a>std::fstream::tellg()</h2><p><code>std::fstream::tellg()</code> 是 <code>std::fstream</code> 类的成员函数之一，用于返回当前文件读取位置的位置指针（stream position pointer）。</p>
<p>在 C++ 中，文件流有一个位置指针，用于标识当前读取或写入操作在文件中的位置。<code>tellg()</code> 用于获取当前位置指针的位置（以字节为单位），它返回一个 <code>std::streampos</code> 类型的值，表示文件流中当前的位置。</p>
<p>以下是一个示例，演示了如何使用 <code>std::fstream::tellg()</code> 来获取当前文件读取位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ifstream fileStream; <span class="comment">// 使用 ifstream 进行输入操作</span></span><br><span class="line"></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>, std::ios::ate); <span class="comment">// 打开文件并将文件指针移到文件末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 获取当前文件指针位置</span></span><br><span class="line">        std::streampos position = fileStream.<span class="built_in">tellg</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Current position in the file: &quot;</span> &lt;&lt; position &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法打开文件。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::fstream::tellg()</code> 被调用以获取当前文件读取位置。<code>std::ios::ate</code> 标志用于在打开文件时将文件指针移到文件末尾。获取位置指针后，它以字节为单位输出当前的文件指针位置。</p>
<p>请注意，在使用 <code>tellg()</code> 之前，通常会使用适当的打开模式打开文件，以便能够获取有效的位置。这个函数通常与其他文件定位和操作函数一起使用，用于了解当前的文件读取位置。</p>
<h2 id="std-fstream-seekg"><a href="#std-fstream-seekg" class="headerlink" title="std::fstream::seekg()"></a>std::fstream::seekg()</h2><p><code>std::fstream::seekg()</code> 是 <code>std::fstream</code> 类的成员函数之一，用于在文件流中定位读取位置。这个函数用于设置文件读取位置指针（stream position pointer）的位置，允许在文件中移动到特定的位置进行读取操作。</p>
<p>它有多种重载形式，允许您以不同的方式定位文件流的读取位置。一般情况下，它使用相对于某个位置的偏移量来移动文件读取位置指针。</p>
<p>以下是一个示例，演示了如何使用 <code>std::fstream::seekg()</code> 在文件中定位读取位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ifstream fileStream; <span class="comment">// 使用 ifstream 进行输入操作</span></span><br><span class="line"></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>); <span class="comment">// 打开文件进行读取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 移动文件读取位置指针到文件的第 10 个字节处（偏移量为 10）</span></span><br><span class="line">        fileStream.<span class="built_in">seekg</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取并显示从当前位置开始的文件内容</span></span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">while</span> (fileStream.<span class="built_in">get</span>(ch)) &#123;</span><br><span class="line">            std::cout &lt;&lt; ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法打开文件。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::fstream::seekg(10)</code> 将文件读取位置指针移动到文件的第 10 个字节处。然后使用 <code>fileStream.get(ch)</code> 从当前位置开始读取文件内容，并将其显示在控制台上。</p>
<p><code>seekg()</code> 函数的参数可以是一个偏移量（例如 <code>seekg(10)</code>），也可以使用其他形式的重载函数，例如 <code>seekg(10, std::ios::beg)</code> 来指定相对于文件开头的偏移量，或者 <code>seekg(-10, std::ios::end)</code> 来指定相对于文件末尾的偏移量。</p>
<p>这个函数对于需要定位并从文件中的特定位置开始读取数据的情况非常有用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_20_initializer_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_20_initializer_list/" class="post-title-link" itemprop="url">C++_10_20_initializer_list</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <initializer_list>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <initializer_list>标准库</h2><p><code>&lt;initializer_list&gt;</code> 是 C++11 引入的头文件，用于支持初始化列表（Initializer List）功能。它提供了一个模板类 <code>std::initializer_list</code>，用于表示一个初始化列表，允许在容器和其他类型中以类似数组的形式初始化对象。</p>
<h3 id="std-initializer-list-概述"><a href="#std-initializer-list-概述" class="headerlink" title="std::initializer_list 概述"></a>std::initializer_list 概述</h3><ul>
<li><code>std::initializer_list</code> 是一个模板类，定义在 <code>&lt;initializer_list&gt;</code> 头文件中。</li>
<li>它提供了一种轻便的语法，允许用花括号 <code>&#123;&#125;</code> 列表初始化特定类型的对象。</li>
<li>这个类是一个轻量级的封装器，可以在构造函数或函数参数中方便地传递初始化列表。</li>
</ul>
<h3 id="基本用法示例："><a href="#基本用法示例：" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : list) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::initializer_list&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 initializer_list 初始化对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialized list: &quot;</span>;</span><br><span class="line">    <span class="built_in">printList</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要特点和用途："><a href="#主要特点和用途：" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li>允许以列表初始化的方式传递多个值给函数或容器。</li>
<li>用于简化容器、类或函数的构造函数，使得初始化更为方便。</li>
<li>可用于自定义函数或类的构造函数，以便更轻松地处理多个参数的初始化。</li>
</ul>
<p><code>std::initializer_list</code> 的出现使得初始化更加简洁和灵活，它适用于许多场景，例如容器初始化、函数参数传递等，使得代码更具可读性和易用性。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <initializer_list>标准库 详解</h2><p><code>&lt;initializer_list&gt;</code> 是 C++11 引入的标准库头文件，其中定义了 <code>std::initializer_list</code> 类模板。它提供了初始化列表（initializer list）功能，允许以列表的形式初始化多个值，用于在构造函数或函数参数中传递多个值。</p>
<h3 id="std-initializer-list-概述："><a href="#std-initializer-list-概述：" class="headerlink" title="std::initializer_list 概述："></a><code>std::initializer_list</code> 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;initializer_list&gt;</code></li>
<li><strong>类模板：</strong> <code>std::initializer_list&lt;T&gt;</code></li>
</ul>
<h3 id="主要特点和用途：-1"><a href="#主要特点和用途：-1" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ol>
<li><p><strong>初始化列表的表示：</strong></p>
<ul>
<li><code>std::initializer_list</code> 是一个轻量级容器，用于保存多个同类型元素的列表。</li>
<li>使用花括号 <code>&#123;&#125;</code> 包围元素来构造初始化列表。</li>
</ul>
</li>
<li><p><strong>在函数参数中使用：</strong></p>
<ul>
<li>可以作为函数的参数，允许以初始化列表的形式传递多个值给函数。</li>
<li>通过此特性可以轻松传递多个参数给函数，方便进行函数调用。</li>
</ul>
</li>
<li><p><strong>类和容器中的应用：</strong></p>
<ul>
<li>类的构造函数可以接受 <code>std::initializer_list</code> 作为参数，允许通过初始化列表对类的成员进行初始化。</li>
<li>STL 容器如 <code>std::vector</code>、<code>std::array</code>、<code>std::map</code> 等也可以使用初始化列表来初始化元素。</li>
</ul>
</li>
<li><p><strong>用于范围迭代：</strong></p>
<ul>
<li>提供了 begin() 和 end() 方法，允许通过迭代器访问初始化列表的元素。</li>
</ul>
</li>
</ol>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接受 initializer_list 作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : list) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化列表示例</span></span><br><span class="line">    std::initializer_list&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 initializer_list 初始化对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialized list: &quot;</span>;</span><br><span class="line">    <span class="built_in">printList</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::initializer_list</code> 在 C++ 中提供了一种便捷的方式来处理初始化列表，使得在构造函数或函数参数中传递多个值变得更加方便和直观。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <initializer_list>标准库 常用的类和函数</h2><p>在 <code>&lt;initializer_list&gt;</code> 头文件中主要定义了 <code>std::initializer_list</code> 类模板，该模板提供了一些常用的函数和方法来操作初始化列表。下面是 <code>std::initializer_list</code> 常用的类和方法：</p>
<h3 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h3><ul>
<li><strong><code>std::initializer_list&lt;T&gt;</code>：</strong> 这是一个类模板，表示一个初始化列表，其中 <code>T</code> 是元素的类型。</li>
</ul>
<h3 id="主要方法和功能："><a href="#主要方法和功能：" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ul>
<li><p><strong>构造函数：</strong></p>
<ul>
<li><code>initializer_list</code> 的构造函数没有公开的构造函数。它是一个轻量级的容器类，由编译器隐式创建和管理。</li>
</ul>
</li>
<li><p><strong>成员函数：</strong></p>
<ul>
<li><strong><code>size()</code>：</strong> 返回初始化列表中元素的数量。</li>
<li><strong><code>begin()</code>：</strong> 返回指向初始化列表第一个元素的指针或迭代器。</li>
<li><strong><code>end()</code>：</strong> 返回指向初始化列表末尾（最后一个元素之后）的指针或迭代器。</li>
</ul>
</li>
</ul>
<h3 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> std::initializer_list&lt;<span class="type">int</span>&gt;&amp; list)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of list: &quot;</span> &lt;&lt; list.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::initializer_list&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 size() 方法获取初始化列表的大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of numbers: &quot;</span> &lt;&lt; numbers.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 begin() 和 end() 方法进行迭代</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements of numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数并传递初始化列表</span></span><br><span class="line">    <span class="built_in">printList</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>std::initializer_list</code> 的 <code>size()</code>、<code>begin()</code> 和 <code>end()</code> 成员函数来访问和操作初始化列表的元素。</p>
<h2 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h2><p><code>std::initializer_list</code> 是 C++ 标准库提供的模板类，位于 <code>&lt;initializer_list&gt;</code> 头文件中。它用于表示初始化列表，允许以列表的形式初始化多个值，通常用于构造函数或函数参数中传递多个值。</p>
<h3 id="std-initializer-list-概述：-1"><a href="#std-initializer-list-概述：-1" class="headerlink" title="std::initializer_list 概述："></a>std::initializer_list 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;initializer_list&gt;</code></li>
<li><strong>类模板：</strong> <code>std::initializer_list&lt;T&gt;</code></li>
</ul>
<h3 id="主要特点和用途：-2"><a href="#主要特点和用途：-2" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ol>
<li><p><strong>初始化列表的表示：</strong></p>
<ul>
<li><code>std::initializer_list</code> 是一个轻量级容器，用于保存多个同类型元素的列表。</li>
<li>使用花括号 <code>&#123;&#125;</code> 包围元素来构造初始化列表。</li>
</ul>
</li>
<li><p><strong>在函数参数中使用：</strong></p>
<ul>
<li>可以作为函数的参数，允许以初始化列表的形式传递多个值给函数。</li>
<li>通过此特性可以轻松传递多个参数给函数，方便进行函数调用。</li>
</ul>
</li>
<li><p><strong>类和容器中的应用：</strong></p>
<ul>
<li>类的构造函数可以接受 <code>std::initializer_list</code> 作为参数，允许通过初始化列表对类的成员进行初始化。</li>
<li>STL 容器如 <code>std::vector</code>、<code>std::array</code>、<code>std::map</code> 等也可以使用初始化列表来初始化元素。</li>
</ul>
</li>
<li><p><strong>用于范围迭代：</strong></p>
<ul>
<li>提供了 <code>begin()</code> 和 <code>end()</code> 方法，允许通过迭代器访问初始化列表的元素。</li>
</ul>
</li>
</ol>
<h3 id="示例代码：-2"><a href="#示例代码：-2" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : list) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化列表示例</span></span><br><span class="line">    std::initializer_list&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 initializer_list 初始化对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialized list: &quot;</span>;</span><br><span class="line">    <span class="built_in">printList</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::initializer_list</code> 在 C++ 中提供了一种便捷的方式来处理初始化列表，使得在构造函数或函数参数中传递多个值变得更加方便和直观。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_19_functional/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_19_functional/" class="post-title-link" itemprop="url">C++_10_19_functional</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <functional>标准库</li>
</ul>
<h2 id="C-std-mem-fn-函数-详解"><a href="#C-std-mem-fn-函数-详解" class="headerlink" title="C++ std::mem_fn() 函数 详解"></a>C++ std::mem_fn() 函数 详解</h2><p><code>std::mem_fn</code> 是 C++ 标准库 <code>&lt;functional&gt;</code> 头文件中的一个函数模板，用于生成可调用对象，绑定到成员函数或成员变量的指针。它主要用于函数式编程风格或与标准库算法配合使用。</p>
<hr>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><code>std::mem_fn</code> 接受一个成员函数指针或成员变量指针，生成一个可调用对象。生成的对象可以通过：</p>
<ol>
<li>绑定对象实例调用成员函数。</li>
<li>操作对象的成员变量。</li>
</ol>
<hr>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">mem_fn</span><span class="params">( T T::* pm )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>T</strong>：成员函数或成员变量所属的类。</li>
<li><strong>pm</strong>：成员函数指针或成员变量指针。</li>
</ul>
<hr>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回一个可调用对象，该对象可以通过不同的方式调用成员函数或访问成员变量。</p>
<hr>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><code>std::mem_fn</code> 的主要用途是将成员函数或成员变量指针适配为标准库算法（如 <code>std::for_each</code>）的需求，避免手动处理复杂的调用。</p>
<hr>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="1-绑定成员函数"><a href="#1-绑定成员函数" class="headerlink" title="1. 绑定成员函数"></a>1. 绑定成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;MyClass&gt; <span class="title">objects</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::mem_fn 绑定成员函数</span></span><br><span class="line">    std::for_each(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), std::<span class="built_in">mem_fn</span>(&amp;MyClass::print));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello from MyClass!</span><br><span class="line">Hello from MyClass!</span><br><span class="line">Hello from MyClass!</span><br></pre></td></tr></table></figure>

<h3 id="2-绑定成员变量"><a href="#2-绑定成员变量" class="headerlink" title="2. 绑定成员变量"></a>2. 绑定成员变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;MyClass&gt; objects = &#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::mem_fn 访问成员变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; obj : objects) &#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">mem_fn</span>(&amp;MyClass::value)(obj) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="3-与-std-bind-一起使用"><a href="#3-与-std-bind-一起使用" class="headerlink" title="3. 与 std::bind 一起使用"></a>3. 与 <code>std::bind</code> 一起使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 和 std::mem_fn</span></span><br><span class="line">    <span class="keyword">auto</span> boundFunc = std::<span class="built_in">bind</span>(std::<span class="built_in">mem_fn</span>(&amp;MyClass::greet), obj, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">boundFunc</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="built_in">boundFunc</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, Alice!</span><br><span class="line">Hello, Bob!</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><strong>对象类型</strong>：<code>std::mem_fn</code> 返回的可调用对象支持各种调用方式，包括：<ul>
<li>对象实例 (<code>obj.*pm</code> 或 <code>obj-&gt;*pm</code>)。</li>
<li>智能指针（如 <code>std::shared_ptr</code> 和 <code>std::unique_ptr</code>）。</li>
</ul>
</li>
<li><strong>线程安全</strong>：<code>std::mem_fn</code> 本身是线程安全的，但如果调用的成员函数或成员变量是非线程安全的，需要用户自行管理线程同步。</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>std::mem_fn</code> 是一个方便的工具，可以简化成员函数或成员变量指针的调用和与算法的集成，尤其是在函数式编程中与其他标准库工具（如 <code>std::bind</code> 或 <code>std::function</code>）配合使用时非常有用。</p>
<h2 id="引用包装器-std-ref"><a href="#引用包装器-std-ref" class="headerlink" title="引用包装器 std::ref"></a>引用包装器 std::ref</h2><ul>
<li><p>我们经常需要处理各种各样的对象和函数调用，其中一个常见的问题是如何高效地传递对象。如果不注意，很容易引入不必要的拷贝开销和性能损失</p>
</li>
<li><p>什么是std::ref</p>
<ul>
<li>std::ref是 C++11 标准库中的一个函数模板，用于生成一个引用包装器。引用包装器本质上是对一个对象的引用进行封装，使得在某些场景下能够更加方便的传递和使用引用。</li>
<li>例如，在标准库的算法和多线程库中，经常需要传递引用，而std::ref可以帮助我们简化这一过程。</li>
</ul>
</li>
</ul>
<h3 id="为什么需要引用包装器"><a href="#为什么需要引用包装器" class="headerlink" title="为什么需要引用包装器"></a>为什么需要引用包装器</h3><ul>
<li>在C++中，函数传参时有几种常见方式，每种方式都有其使用的场景和特点<ul>
<li>按值传递： 会创建参数对象的副本，可能带来额外的性能开销</li>
<li>按指针传递：需要显式的处理指针，可能导致代码复杂性增加</li>
<li>按引用传递：无需创建副本，性能较高，但是在某些场景下使用起来不够方便</li>
</ul>
</li>
<li>在需要保持对象的引用关系，但是又不想显示地使用指针或者引用时，引用包装器 std::ref 就派上用场了</li>
</ul>
<h3 id="如何使用std-ref"><a href="#如何使用std-ref" class="headerlink" title="如何使用std::ref"></a>如何使用std::ref</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 引入std::ref</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">    ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; f = std::<span class="built_in">bind</span>(increment, std::<span class="built_in">ref</span>(x));</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x after increment: &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出：x after increment: 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">call_increment</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，std::bind用于绑定函数increment和参数x，而std::ref确保传递的是x的引用，而不是副本。</li>
</ul>
<h3 id="std-ref在多线程中的应用"><a href="#std-ref在多线程中的应用" class="headerlink" title="std::ref在多线程中的应用"></a>std::ref在多线程中的应用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_counter</span><span class="params">(<span class="type">int</span>&amp; counter, <span class="type">int</span> num_iterations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_iterations; ++i) &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num_threads = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> num_iterations = <span class="number">1000</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(add_to_counter, std::<span class="built_in">ref</span>(counter), num_iterations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl; <span class="comment">// 输出：Final counter value: 10000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，我们创建了10个线程，每个线程对同一个counter变量进行了1000次累加<br>操作。通过使用std::ref，我们确保每个线程操作的是同一个counter引用，而不是副本。</li>
</ul>
<h3 id="std-ref-与-std-cref"><a href="#std-ref-与-std-cref" class="headerlink" title="std::ref 与 std::cref"></a>std::ref 与 std::cref</h3><ul>
<li>除了 std::ref，C++标准库还提供了 std::cref，用于生成常量引用的包装器。</li>
<li>std::cref的使用方式与std::ref类似，不同之处在于它生成的是const引用，确保被引用的对象在使用过程中不会被修改。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_value</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; f = std::<span class="built_in">bind</span>(print_value, std::<span class="built_in">cref</span>(x));</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：Value: 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在这个例子中，std::cref确保传递的是x的常量引用，print_value函数无法修改x的值。</li>
</ul>
<h3 id="std-ref的内部实现"><a href="#std-ref的内部实现" class="headerlink" title="std::ref的内部实现"></a>std::ref的内部实现</h3><ul>
<li>虽然我们平时使用std::ref时只需要调用它的接口，但了解其内部实现有助于我们更深入地理解它的工作原理。std::ref的内部实现实际上非常简单，它定义了一个模板类reference_wrapper，用于封装引用。下面是一个简化的实现版本：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">reference_wrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">reference_wrapper</span><span class="params">(T&amp; ref)</span> : ref_(std::addressof(ref)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> T&amp;() <span class="type">const</span> &#123; <span class="keyword">return</span> *ref_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *ref_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ref_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">reference_wrapper&lt;T&gt; <span class="title">ref</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reference_wrapper</span>&lt;T&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以看出，reference_wrapper通过保存一个指向引用对象的指针，实现了对引用的包装。</li>
<li>std::ref函数只是创建了一个reference_wrapper对象并且返回。</li>
</ul>
<h3 id="std-ref-小结"><a href="#std-ref-小结" class="headerlink" title="std::ref 小结"></a>std::ref 小结</h3><ul>
<li>std::ref 作为C++标准库中的一个小工具，虽然看似简单，但是在实际编程中却能够解决很多复杂的问题。</li>
<li>它不仅能够简化函数参数传递，还能在多线程编程中确保引用的正确传递，从而提升代码的性能和可读性。</li>
</ul>
<h2 id="什么是-std-function"><a href="#什么是-std-function" class="headerlink" title="什么是 std::function"></a>什么是 std::function</h2><ul>
<li><p>std::function 是C++11引入的一个函数包装器类型。它的主要作用是，将任何可调用实体(比如函数，lambda表达式，函数指针或者函数对象)都包装成一个统一的对象，从而可以统一的保存，传递和调用这些可调用实体。</p>
</li>
<li><p>简单的说，std::function就是一个可以容纳各种可调用实体的容器。我们可以将它看作是一个通用的函数指针，但是它比普通的函数指针更加灵活和强大。</p>
</li>
<li><p>std::function 提供了一种非常灵活和通用的方式来处理可调用实体，包括普通函数，lambda表达式以及函数对象。</p>
</li>
<li><p>它的主要优点包括</p>
<ul>
<li>统一的函数调用接口，简化了代码</li>
<li>可以存储在容器中，增强了代码的可扩展性</li>
<li>可以与std::bind()结合使用，实现参数绑定等高级功能</li>
</ul>
</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <functional>标准库</h2><p><code>&lt;functional&gt;</code> 标准库是 C++ 中的一个头文件，提供了函数对象（Function Object）的支持，包括了一些预定义的函数对象和函数适配器。它使得函数能够像对象一样被传递、存储、返回以及调用。</p>
<p>这个库中的重要组件包括：</p>
<h3 id="1-函数对象（Function-Objects）"><a href="#1-函数对象（Function-Objects）" class="headerlink" title="1. 函数对象（Function Objects）"></a>1. 函数对象（Function Objects）</h3><p>函数对象是可以像函数一样被调用的对象。在 <code>&lt;functional&gt;</code> 中有一些内置的函数对象，如：</p>
<ul>
<li><code>std::function</code>：用于封装可调用的目标，可以是函数指针、函数、成员函数、Lambda 表达式等，是一种通用的函数封装器。</li>
<li><code>std::bind</code>：用于创建函数对象，可绑定函数或者成员函数到指定的参数上。</li>
<li><code>std::placeholders</code>：用于占位符，在使用 <code>std::bind</code> 绑定函数时，指定部分参数留待后续提供。</li>
</ul>
<h3 id="2-函数适配器（Function-Adapters）"><a href="#2-函数适配器（Function-Adapters）" class="headerlink" title="2. 函数适配器（Function Adapters）"></a>2. 函数适配器（Function Adapters）</h3><p>函数适配器是用来修改函数行为的对象。常见的函数适配器有：</p>
<ul>
<li><code>std::bind</code>：上述已提到，可用于部分参数绑定和函数重组。</li>
<li><code>std::placeholders</code>：占位符，用于 <code>std::bind</code> 中占位某些参数的位置。</li>
<li><code>std::function</code>：用于封装可调用对象，提供了一种统一的处理方式。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function object example</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddFunctor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Using std::function with a lambda function</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; addFunction = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using std::bind to bind the first argument to 10</span></span><br><span class="line">    <span class="keyword">auto</span> addTen = std::<span class="built_in">bind</span>(addFunction, <span class="number">10</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using a function object</span></span><br><span class="line">    AddFunctor addObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using the function object</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of addObj: &quot;</span> &lt;&lt; <span class="built_in">addObj</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using std::function with std::bind</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of addFunction: &quot;</span> &lt;&lt; <span class="built_in">addFunction</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using std::bind function to add 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of addTen: &quot;</span> &lt;&lt; <span class="built_in">addTen</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用 <code>&lt;functional&gt;</code> 标准库中的函数对象和函数适配器。<code>std::function</code> 和 <code>std::bind</code> 是这个库中常用的工具，它们提供了更灵活和通用的函数操作方式。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <functional>标准库 详解</h2><p><code>&lt;functional&gt;</code> 标准库是 C++ 中提供函数对象（Function Objects）和函数适配器（Function Adapters）的头文件。这个库提供了许多功能，能够让函数像对象一样进行操作、传递和存储，以及改变函数的行为。</p>
<p>下面是 <code>&lt;functional&gt;</code> 标准库中一些重要的组件：</p>
<h3 id="1-函数对象（Function-Objects）-1"><a href="#1-函数对象（Function-Objects）-1" class="headerlink" title="1. 函数对象（Function Objects）"></a>1. 函数对象（Function Objects）</h3><p>函数对象是具有函数调用功能的对象，它可以像函数一样被调用。在 <code>&lt;functional&gt;</code> 中提供了以下函数对象：</p>
<ul>
<li><p><code>std::function</code>：是一个通用的函数封装器，可以封装可调用的目标，例如函数指针、函数、成员函数、Lambda 表达式等。可以用来存储和调用各种类型的可调用对象。</p>
</li>
<li><p>函数对象类：程序员可以自定义函数对象类，它们是类或结构体，重载了函数调用运算符 <code>operator()</code>，使得对象可以像函数一样被调用。</p>
</li>
</ul>
<h3 id="2-函数适配器（Function-Adapters）-1"><a href="#2-函数适配器（Function-Adapters）-1" class="headerlink" title="2. 函数适配器（Function Adapters）"></a>2. 函数适配器（Function Adapters）</h3><p>函数适配器是用于修改函数行为或调整函数参数的对象。其中常见的函数适配器有：</p>
<ul>
<li><p><code>std::bind</code>：用于创建函数对象，可以部分绑定函数或成员函数的参数。可以改变函数的参数个数或者顺序。</p>
</li>
<li><p><code>std::placeholders</code>：在使用 <code>std::bind</code> 绑定函数时，用于指定占位符，代表未指定的参数位置。</p>
</li>
</ul>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象示例</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MultiplyFunctor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::function 包装 Lambda 表达式</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; multiplyFunction = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 部分绑定参数</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyByTwo = std::<span class="built_in">bind</span>(multiplyFunction, std::placeholders::_1, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义函数对象</span></span><br><span class="line">    MultiplyFunctor multiplyObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义函数对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplyObj: &quot;</span> &lt;&lt; <span class="built_in">multiplyObj</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::function 调用 Lambda 函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplyFunction: &quot;</span> &lt;&lt; <span class="built_in">multiplyFunction</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定函数的参数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplyByTwo: &quot;</span> &lt;&lt; <span class="built_in">multiplyByTwo</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>&lt;functional&gt;</code> 标准库中的函数对象和函数适配器。<code>std::function</code> 提供了一种通用的函数封装器，<code>std::bind</code> 则用于创建函数对象并部分绑定参数。函数对象可以是 Lambda 表达式、函数指针或自定义的函数对象类。</p>
<h2 id="C-标准库-常用类和函数"><a href="#C-标准库-常用类和函数" class="headerlink" title="C++ 标准库 常用类和函数"></a>C++ <functional>标准库 常用类和函数</h2><p><code>&lt;functional&gt;</code> 标准库提供了许多有用的类和函数，使得函数能够像对象一样进行操作、传递和存储。以下是 <code>&lt;functional&gt;</code> 常用的类和函数：</p>
<h3 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h3><h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a><code>std::function</code></h4><ul>
<li>用于封装各种可调用对象，如函数指针、函数、成员函数、Lambda 表达式等。</li>
<li>提供了一种通用的函数封装器，能够在运行时存储和调用各种类型的可调用对象。</li>
</ul>
<h4 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a><code>std::bind</code></h4><ul>
<li>用于创建函数对象，能够绑定函数或成员函数的参数。</li>
<li>允许指定参数的顺序、部分绑定参数或者重新组织参数，生成一个新的可调用对象。</li>
</ul>
<h4 id="std-placeholders"><a href="#std-placeholders" class="headerlink" title="std::placeholders"></a><code>std::placeholders</code></h4><ul>
<li>用于指定占位符，配合 <code>std::bind</code> 使用，指定未指定的参数位置。</li>
<li>提供了占位符 <code>_1</code>、<code>_2</code>、<code>_3</code> 等，用于表示绑定时未指定的参数位置。</li>
</ul>
<h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h3><h4 id="算术函数："><a href="#算术函数：" class="headerlink" title="算术函数："></a>算术函数：</h4><ul>
<li><code>std::plus</code>：加法函数对象。</li>
<li><code>std::minus</code>：减法函数对象。</li>
<li><code>std::multiplies</code>：乘法函数对象。</li>
<li><code>std::divides</code>：除法函数对象。</li>
<li><code>std::modulus</code>：取模函数对象。</li>
</ul>
<h4 id="逻辑函数："><a href="#逻辑函数：" class="headerlink" title="逻辑函数："></a>逻辑函数：</h4><ul>
<li><code>std::logical_and</code>：逻辑与函数对象。</li>
<li><code>std::logical_or</code>：逻辑或函数对象。</li>
<li><code>std::logical_not</code>：逻辑非函数对象。</li>
</ul>
<h4 id="其他函数："><a href="#其他函数：" class="headerlink" title="其他函数："></a>其他函数：</h4><ul>
<li><code>std::negate</code>：一元取反函数对象。</li>
<li><code>std::not1</code>：一元谓词取反函数对象。</li>
<li><code>std::not2</code>：二元谓词取反函数对象。</li>
</ul>
<h3 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象示例</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MultiplyFunctor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::function 封装 Lambda 表达式</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; multiplyFunction = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定函数对象并部分绑定参数</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyByTwo = std::<span class="built_in">bind</span>(multiplyFunction, std::placeholders::_1, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义函数对象</span></span><br><span class="line">    MultiplyFunctor multiplyObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义函数对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplyObj: &quot;</span> &lt;&lt; <span class="built_in">multiplyObj</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::function 调用 Lambda 函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplyFunction: &quot;</span> &lt;&lt; <span class="built_in">multiplyFunction</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定函数对象的参数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplyByTwo: &quot;</span> &lt;&lt; <span class="built_in">multiplyByTwo</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>&lt;functional&gt;</code> 标准库中的一些常用函数和类的用法。<code>std::function</code> 可用于封装不同类型的可调用对象，<code>std::bind</code> 可用于创建函数对象并部分绑定参数，而函数对象可以是 Lambda 表达式、函数指针或自定义的函数对象类。</p>
<h2 id="std-function-1"><a href="#std-function-1" class="headerlink" title="std::function"></a>std::function</h2><p><code>std::function</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的一个类模板，用于封装可调用对象（函数、函数指针、成员函数、Lambda 表达式等），并提供一种通用的函数封装器。</p>
<h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::function&lt;return_type(args...)&gt; func_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>return_type</code>：函数或可调用对象返回类型。</li>
<li><code>args...</code>：函数或可调用对象的参数类型列表。</li>
</ul>
<h3 id="特点和用途："><a href="#特点和用途：" class="headerlink" title="特点和用途："></a>特点和用途：</h3><ul>
<li><code>std::function</code> 能够封装各种类型的可调用对象，提供了一种统一的处理方式。</li>
<li>可以在运行时动态地指定要调用的函数或对象，从而实现动态多态性。</li>
<li>可用作函数参数、返回值或容器内的元素类型，能够实现灵活的函数传递和存储。</li>
</ul>
<h3 id="示例代码：-2"><a href="#示例代码：-2" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 封装普通函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装 Lambda 表达式</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; lambdaFunc = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用封装的普通函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of add function: &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用封装的 Lambda 表达式</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of lambda function: &quot;</span> &lt;&lt; <span class="built_in">lambdaFunc</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::function</code> 分别封装了一个普通函数和一个 Lambda 表达式，并能够像函数一样调用这些封装的对象。<code>std::function</code> 提供了一种通用的函数封装器，能够灵活地封装各种可调用对象，并统一地调用它们。</p>
<h2 id="std-bind-1"><a href="#std-bind-1" class="headerlink" title="std::bind"></a>std::bind</h2><p><code>std::bind</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的一个函数模板，用于创建函数对象并进行参数绑定。</p>
<h3 id="基本语法：-1"><a href="#基本语法：-1" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(func_to_bind, args...);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>func_to_bind</code>：要绑定的函数、函数指针、成员函数指针或可调用对象。</li>
<li><code>args...</code>：要绑定的参数列表，可以包含占位符 <code>_1</code>, <code>_2</code>, <code>_3</code> 等，代表未指定的参数位置。</li>
</ul>
<h3 id="特点和用途：-1"><a href="#特点和用途：-1" class="headerlink" title="特点和用途："></a>特点和用途：</h3><ul>
<li><code>std::bind</code> 允许对函数或函数对象进行部分参数绑定、参数重排以及参数固定等操作，生成一个新的函数对象。</li>
<li>可以用来创建函数对象，将部分参数预先绑定，使得函数调用更加灵活。</li>
<li>创建了一个新的可调用对象，其参数列表为绑定参数后剩余的参数。</li>
</ul>
<h3 id="示例代码：-3"><a href="#示例代码：-3" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定参数的 add 函数</span></span><br><span class="line">    <span class="keyword">auto</span> addFive = std::<span class="built_in">bind</span>(add, <span class="number">5</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用绑定参数的 add 函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of addFive function: &quot;</span> &lt;&lt; <span class="built_in">addFive</span>(<span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::bind</code> 绑定了一个参数为 5 的 <code>add</code> 函数，并将第二个参数作为占位符 <code>_1</code> 留待后续提供。之后创建了一个新的函数对象 <code>addFive</code>，用于调用绑定了部分参数的 <code>add</code> 函数。<code>std::bind</code> 允许对函数进行部分参数绑定，生成一个新的可调用对象。</p>
<h2 id="std-placeholders-1"><a href="#std-placeholders-1" class="headerlink" title="std::placeholders"></a>std::placeholders</h2><p><code>std::placeholders</code> 是 <code>&lt;functional&gt;</code> 头文件中的一个命名空间，其中定义了一系列占位符，用于在使用 <code>std::bind</code> 时指示参数的位置。</p>
<h3 id="常用的占位符："><a href="#常用的占位符：" class="headerlink" title="常用的占位符："></a>常用的占位符：</h3><ul>
<li><code>_1</code>、<code>_2</code>、<code>_3</code>… <code>_n</code>：表示函数调用时的第一个、第二个、第三个… 第n个参数位置。</li>
</ul>
<p>这些占位符用于 <code>std::bind</code> 中，协助进行参数绑定。在 <code>std::bind</code> 中，使用这些占位符可以指定哪些参数是预先绑定的，哪些参数需要在调用时提供。</p>
<h3 id="示例代码：-4"><a href="#示例代码：-4" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printThree</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定函数并重新排列参数顺序</span></span><br><span class="line">    <span class="keyword">auto</span> printFunction = std::<span class="built_in">bind</span>(printThree, std::placeholders::_3, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用绑定函数</span></span><br><span class="line">    <span class="built_in">printFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::placeholders</code> 的占位符 <code>_1</code>、<code>_2</code>、<code>_3</code> 分别表示绑定的函数 <code>printThree</code> 的第三个、第一个和第二个参数的位置。<code>std::bind</code> 创建了一个新的函数对象 <code>printFunction</code>，并重新排列了参数顺序。在调用 <code>printFunction</code> 时，参数的顺序将被重新排列以匹配绑定的函数。</p>
<h2 id="std-plus"><a href="#std-plus" class="headerlink" title="std::plus"></a>std::plus</h2><p><code>std::plus</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行加法操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行加法操作。</p>
<h3 id="基本语法：-2"><a href="#基本语法：-2" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::plus&lt;T&gt; plus_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：加法操作的参数类型。</li>
</ul>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::plus</code> 对象可以像函数一样调用，用于执行加法操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<h3 id="示例代码：-5"><a href="#示例代码：-5" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::plus&lt;<span class="type">int</span>&gt; plusInt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">plusInt</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 执行加法操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of addition: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::plus</code> 实例化为 <code>std::plus&lt;int&gt;</code>，表示执行整数类型的加法操作。<code>plusInt</code> 对象被调用并传递两个参数，执行加法操作并返回结果。</p>
<h2 id="std-minus"><a href="#std-minus" class="headerlink" title="std::minus"></a>std::minus</h2><p><code>std::minus</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行减法操作。它也是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行减法操作。</p>
<h3 id="基本语法：-3"><a href="#基本语法：-3" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::minus&lt;T&gt; minus_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：减法操作的参数类型。</li>
</ul>
<h3 id="使用方法：-1"><a href="#使用方法：-1" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::minus</code> 对象可以像函数一样调用，用于执行减法操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<h3 id="示例代码：-6"><a href="#示例代码：-6" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::minus&lt;<span class="type">int</span>&gt; minusInt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">minusInt</span>(<span class="number">7</span>, <span class="number">4</span>); <span class="comment">// 执行减法操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of subtraction: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::minus</code> 实例化为 <code>std::minus&lt;int&gt;</code>，表示执行整数类型的减法操作。<code>minusInt</code> 对象被调用并传递两个参数，执行减法操作并返回结果。</p>
<h2 id="std-multiplies"><a href="#std-multiplies" class="headerlink" title="std::multiplies"></a>std::multiplies</h2><p><code>std::multiplies</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行乘法操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行乘法操作。</p>
<h3 id="基本语法：-4"><a href="#基本语法：-4" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::multiplies&lt;T&gt; multiplies_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：乘法操作的参数类型。</li>
</ul>
<h3 id="使用方法：-2"><a href="#使用方法：-2" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::multiplies</code> 对象可以像函数一样调用，用于执行乘法操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<h3 id="示例代码：-7"><a href="#示例代码：-7" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multiplies&lt;<span class="type">int</span>&gt; multipliesInt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">multipliesInt</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 执行乘法操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplication: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::multiplies</code> 实例化为 <code>std::multiplies&lt;int&gt;</code>，表示执行整数类型的乘法操作。<code>multipliesInt</code> 对象被调用并传递两个参数，执行乘法操作并返回结果。</p>
<h2 id="std-divides"><a href="#std-divides" class="headerlink" title="std::divides"></a>std::divides</h2><p><code>std::divides</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行除法操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行除法操作。</p>
<h3 id="基本语法：-5"><a href="#基本语法：-5" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::divides&lt;T&gt; divides_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：除法操作的参数类型。</li>
</ul>
<h3 id="使用方法：-3"><a href="#使用方法：-3" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::divides</code> 对象可以像函数一样调用，用于执行除法操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<h3 id="示例代码：-8"><a href="#示例代码：-8" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::divides&lt;<span class="type">double</span>&gt; dividesDouble;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">dividesDouble</span>(<span class="number">10.0</span>, <span class="number">2.0</span>); <span class="comment">// 执行除法操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of division: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::divides</code> 实例化为 <code>std::divides&lt;double&gt;</code>，表示执行双精度浮点数类型的除法操作。<code>dividesDouble</code> 对象被调用并传递两个参数，执行除法操作并返回结果。</p>
<h2 id="std-modulus"><a href="#std-modulus" class="headerlink" title="std::modulus"></a>std::modulus</h2><p><code>std::modulus</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行取模（取余）操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行取模操作。</p>
<h3 id="基本语法：-6"><a href="#基本语法：-6" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::modulus&lt;T&gt; modulus_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：取模操作的参数类型。</li>
</ul>
<h3 id="使用方法：-4"><a href="#使用方法：-4" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::modulus</code> 对象可以像函数一样调用，用于执行取模操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<h3 id="示例代码：-9"><a href="#示例代码：-9" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::modulus&lt;<span class="type">int</span>&gt; modulusInt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">modulusInt</span>(<span class="number">10</span>, <span class="number">3</span>); <span class="comment">// 执行取模操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of modulus: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::modulus</code> 实例化为 <code>std::modulus&lt;int&gt;</code>，表示执行整数类型的取模操作。<code>modulusInt</code> 对象被调用并传递两个参数，执行取模操作并返回结果。</p>
<h2 id="std-logical-and"><a href="#std-logical-and" class="headerlink" title="std::logical_and"></a>std::logical_and</h2><p><code>std::logical_and</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行逻辑与操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行逻辑与操作。</p>
<h3 id="基本语法：-7"><a href="#基本语法：-7" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::logical_and&lt;T&gt; logical_and_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：逻辑与操作的参数类型。</li>
</ul>
<h3 id="使用方法：-5"><a href="#使用方法：-5" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::logical_and</code> 对象可以像函数一样调用，用于执行逻辑与操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>bool</code> 等。</p>
<h3 id="示例代码：-10"><a href="#示例代码：-10" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::logical_and&lt;<span class="type">bool</span>&gt; logicalAndBool;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> result = <span class="built_in">logicalAndBool</span>(<span class="literal">true</span>, <span class="literal">false</span>); <span class="comment">// 执行逻辑与操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of logical AND: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::logical_and</code> 实例化为 <code>std::logical_and&lt;bool&gt;</code>，表示执行布尔类型的逻辑与操作。<code>logicalAndBool</code> 对象被调用并传递两个参数，执行逻辑与操作并返回结果。</p>
<h2 id="std-logical-or"><a href="#std-logical-or" class="headerlink" title="std::logical_or"></a>std::logical_or</h2><p><code>std::logical_or</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行逻辑或操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行逻辑或操作。</p>
<h3 id="基本语法：-8"><a href="#基本语法：-8" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::logical_or&lt;T&gt; logical_or_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：逻辑或操作的参数类型。</li>
</ul>
<h3 id="使用方法：-6"><a href="#使用方法：-6" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::logical_or</code> 对象可以像函数一样调用，用于执行逻辑或操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>bool</code> 等。</p>
<h3 id="示例代码：-11"><a href="#示例代码：-11" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::logical_or&lt;<span class="type">bool</span>&gt; logicalOrBool;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> result = <span class="built_in">logicalOrBool</span>(<span class="literal">true</span>, <span class="literal">false</span>); <span class="comment">// 执行逻辑或操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of logical OR: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::logical_or</code> 实例化为 <code>std::logical_or&lt;bool&gt;</code>，表示执行布尔类型的逻辑或操作。<code>logicalOrBool</code> 对象被调用并传递两个参数，执行逻辑或操作并返回结果。</p>
<h2 id="std-logical-not"><a href="#std-logical-not" class="headerlink" title="std::logical_not"></a>std::logical_not</h2><p><code>std::logical_not</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行逻辑非（取反）操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行逻辑非操作。</p>
<h3 id="基本语法：-9"><a href="#基本语法：-9" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::logical_not&lt;T&gt; logical_not_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：逻辑非操作的参数类型。</li>
</ul>
<h3 id="使用方法：-7"><a href="#使用方法：-7" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::logical_not</code> 对象可以像函数一样调用，用于执行逻辑非操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>bool</code> 等。</p>
<h3 id="示例代码：-12"><a href="#示例代码：-12" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::logical_not&lt;<span class="type">bool</span>&gt; logicalNotBool;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> result = <span class="built_in">logicalNotBool</span>(<span class="literal">true</span>); <span class="comment">// 执行逻辑非操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of logical NOT: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::logical_not</code> 实例化为 <code>std::logical_not&lt;bool&gt;</code>，表示执行布尔类型的逻辑非操作。<code>logicalNotBool</code> 对象被调用并传递一个参数，执行逻辑非操作并返回结果。</p>
<h2 id="std-negate"><a href="#std-negate" class="headerlink" title="std::negate"></a>std::negate</h2><p><code>std::negate</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行一元取反操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行一元取反操作。</p>
<h3 id="基本语法：-10"><a href="#基本语法：-10" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::negate&lt;T&gt; negate_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：取反操作的参数类型。</li>
</ul>
<h3 id="使用方法：-8"><a href="#使用方法：-8" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::negate</code> 对象可以像函数一样调用，用于执行一元取反操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<h3 id="示例代码：-13"><a href="#示例代码：-13" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::negate&lt;<span class="type">int</span>&gt; negateInt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">negateInt</span>(<span class="number">10</span>); <span class="comment">// 执行一元取反操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of unary negation: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::negate</code> 实例化为 <code>std::negate&lt;int&gt;</code>，表示执行整数类型的一元取反操作。<code>negateInt</code> 对象被调用并传递一个参数，执行一元取反操作并返回结果。</p>
<h2 id="std-not1"><a href="#std-not1" class="headerlink" title="std::not1"></a>std::not1</h2><p><code>std::not1</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象适配器，用于对一元谓词函数进行取反操作。它可用于构造一个函数对象，将传入的一元谓词函数对象的结果进行取反。</p>
<h3 id="基本语法：-11"><a href="#基本语法：-11" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::not1&lt;UnaryPredicate&gt; not1_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>UnaryPredicate</code>：一元谓词函数对象类型。</li>
</ul>
<h3 id="使用方法：-9"><a href="#使用方法：-9" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::not1</code> 可以用于对一元谓词函数对象进行取反操作。它接受一个一元谓词函数对象作为参数，并返回一个新的谓词函数对象，该对象对传入的谓词函数的返回值进行取反。</p>
<h3 id="示例代码：-14"><a href="#示例代码：-14" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greaterThanThree</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; pred = std::not1&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>)&gt;&gt;(greaterThanThree);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of not1: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">pred</span>(<span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// Result will be false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::not1</code> 对 <code>greaterThanThree</code> 函数对象进行取反操作。<code>pred</code> 对象被调用并传递一个参数，返回结果为传入参数的一元谓词函数的取反结果。</p>
<h2 id="std-not2"><a href="#std-not2" class="headerlink" title="std::not2"></a>std::not2</h2><p><code>std::not2</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象适配器，用于对二元谓词函数进行取反操作。它可用于构造一个函数对象，将传入的二元谓词函数对象的结果进行取反。</p>
<h3 id="基本语法：-12"><a href="#基本语法：-12" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::not2&lt;BinaryPredicate&gt; not2_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>BinaryPredicate</code>：二元谓词函数对象类型。</li>
</ul>
<h3 id="使用方法：-10"><a href="#使用方法：-10" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::not2</code> 可以用于对二元谓词函数对象进行取反操作。它接受一个二元谓词函数对象作为参数，并返回一个新的谓词函数对象，该对象对传入的谓词函数的返回值进行取反。</p>
<h3 id="示例代码：-15"><a href="#示例代码：-15" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lessThanOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;= y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; pred = std::not2&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt;(lessThanOrEqual);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of not2: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">pred</span>(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// Result will be false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::not2</code> 对 <code>lessThanOrEqual</code> 函数对象进行取反操作。<code>pred</code> 对象被调用并传递两个参数，返回结果为传入参数的二元谓词函数的取反结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_21_utility/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_21_utility/" class="post-title-link" itemprop="url">C++_10_21_utility</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <utility>标准库</li>
</ul>
<h2 id="pair工具类"><a href="#pair工具类" class="headerlink" title="pair工具类"></a>pair工具类</h2><ul>
<li>pair在<utility>头文件中定义，并将两个可能属于不同类型的值组合起来。可以通过first和second公共数据成员访问这两个值</li>
<li>在C++17引入对CTAD的支持之前，可以使用std::make_pair()工具函数模板，从两个值构造一个pair</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <utility>标准库</h2><p><code>&lt;utility&gt;</code> 是 C++ 标准库中的头文件，它包含了一些实用工具和通用功能，提供了一些模板类和函数。这个头文件定义了一些基本的工具类和函数，以支持各种通用编程需求。</p>
<p>以下是 <code>&lt;utility&gt;</code> 头文件中一些常见的功能和类：</p>
<h3 id="1-std-pair"><a href="#1-std-pair" class="headerlink" title="1. std::pair"></a>1. <code>std::pair</code></h3><ul>
<li><code>std::pair</code> 是一个模板类，用于存储一对值，类似于键值对的概念。</li>
<li>通常用于函数返回多个值或存储两个相关的值。</li>
</ul>
<h3 id="2-std-make-pair"><a href="#2-std-make-pair" class="headerlink" title="2. std::make_pair"></a>2. <code>std::make_pair</code></h3><ul>
<li><code>std::make_pair</code> 是一个模板函数，用于创建一个 <code>std::pair</code> 对象。</li>
<li>接受两个参数，自动推导类型并返回一个 <code>std::pair</code> 对象。</li>
</ul>
<h3 id="3-std-move"><a href="#3-std-move" class="headerlink" title="3. std::move"></a>3. <code>std::move</code></h3><ul>
<li><code>std::move</code> 是一个函数模板，用于将对象转移到新位置，通常与移动语义一起使用。</li>
<li>将对象转换为右值引用，以便在赋值后对象的状态可以改变，而不是复制。</li>
</ul>
<h3 id="4-std-forward"><a href="#4-std-forward" class="headerlink" title="4. std::forward"></a>4. <code>std::forward</code></h3><ul>
<li><code>std::forward</code> 是一个函数模板，用于完美转发（perfect forwarding）。</li>
<li>用于在函数模板中保留参数的引用类型，使其继续保持右值或左值属性。</li>
</ul>
<h3 id="5-其他工具和函数"><a href="#5-其他工具和函数" class="headerlink" title="5. 其他工具和函数"></a>5. 其他工具和函数</h3><ul>
<li><code>&lt;utility&gt;</code> 还包含其他一些小的工具函数和模板，比如 <code>std::swap</code> 用于交换两个值，以及一些用于元组访问和元编程的功能。</li>
</ul>
<p>这些工具和类都是用于提供一些通用的功能，可以在许多不同的情况下使用，从简单的值对存储到高级的模板转发等。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <utility>标准库 详解</h2><p><code>&lt;utility&gt;</code> 是 C++ 标准库中的头文件，提供了一些通用工具、类模板和函数，用于各种编程场景中的通用操作和工具性功能。以下是 <code>&lt;utility&gt;</code> 中一些主要的功能和类的详细解释：</p>
<h3 id="1-std-pair-1"><a href="#1-std-pair-1" class="headerlink" title="1. std::pair"></a>1. <code>std::pair</code></h3><ul>
<li><code>std::pair</code> 是一个模板类，用于存储一对值，即将两个值组合成一个对象。</li>
<li>通常用于函数返回多个值或需要将两个相关联的值作为一个单元处理的情况。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;<span class="type">int</span>, std::string&gt; myPair = std::<span class="built_in">make_pair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-std-make-pair-1"><a href="#2-std-make-pair-1" class="headerlink" title="2. std::make_pair"></a>2. <code>std::make_pair</code></h3><ul>
<li><code>std::make_pair</code> 是一个模板函数，用于创建 <code>std::pair</code> 对象。</li>
<li>它接受两个参数并自动推导类型，并返回一个对应类型的 <code>std::pair</code> 对象。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myPair = std::<span class="built_in">make_pair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-std-move-1"><a href="#3-std-move-1" class="headerlink" title="3. std::move"></a>3. <code>std::move</code></h3><ul>
<li><code>std::move</code> 是一个函数模板，用于将一个左值转换为对应的右值引用。</li>
<li>通常用于支持移动语义，在移动语义中，资源的所有权可以从一个对象转移到另一个对象，而无需进行深层复制。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = std::<span class="built_in">move</span>(str1); <span class="comment">// Move str1 to str2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-std-forward-1"><a href="#4-std-forward-1" class="headerlink" title="4. std::forward"></a>4. <code>std::forward</code></h3><ul>
<li><code>std::forward</code> 是一个模板函数，用于完美转发（perfect forwarding）。</li>
<li>通常在泛型编程中用于传递参数，并保持参数的原始左值或右值特性。</li>
<li>主要用于在泛型函数或模板中保留参数的原始引用类型。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">some_function</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-std-swap"><a href="#5-std-swap" class="headerlink" title="5. std::swap"></a>5. <code>std::swap</code></h3><ul>
<li><code>std::swap</code> 是一个函数模板，用于交换两个对象的值。</li>
<li>适用于大多数基本类型以及用户自定义类型的交换操作。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">std::<span class="built_in">swap</span>(a, b); <span class="comment">// Swap values of a and b</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>这些功能和类提供了通用的工具和操作，可用于各种不同的情况，从简单的值对组合到高级的模板转发。它们是 C++ 标准库提供的一些核心工具，为编写高效、通用的代码提供了便利。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <utility>标准库 常用的类和函数</h2><p><code>&lt;utility&gt;</code> 标准库提供了一些常用的类和函数，以下是其中一些主要的类和函数：</p>
<h3 id="1-std-pair-2"><a href="#1-std-pair-2" class="headerlink" title="1. std::pair"></a>1. <code>std::pair</code></h3><ul>
<li><code>std::pair</code> 是一个模板类，用于存储一对值（通常是不同类型的值），将两个值作为一个单元存储和访问。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;<span class="type">int</span>, std::string&gt; myPair = std::<span class="built_in">make_pair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-std-make-pair-2"><a href="#2-std-make-pair-2" class="headerlink" title="2. std::make_pair"></a>2. <code>std::make_pair</code></h3><ul>
<li><code>std::make_pair</code> 是一个模板函数，用于创建 <code>std::pair</code> 对象，根据传递的参数类型自动推导 <code>std::pair</code> 对象的类型。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myPair = std::<span class="built_in">make_pair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-std-move-2"><a href="#3-std-move-2" class="headerlink" title="3. std::move"></a>3. <code>std::move</code></h3><ul>
<li><code>std::move</code> 是一个函数模板，用于将左值转换为对应的右值引用，支持移动语义。</li>
<li>用于支持移动语义，提高资源的有效使用。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = std::<span class="built_in">move</span>(str1); <span class="comment">// Move str1 to str2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-std-forward-2"><a href="#4-std-forward-2" class="headerlink" title="4. std::forward"></a>4. <code>std::forward</code></h3><ul>
<li><code>std::forward</code> 是一个模板函数，用于完美转发（perfect forwarding）。</li>
<li>在泛型编程中用于传递参数，并保持参数的原始左值或右值特性。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">some_function</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-std-swap-1"><a href="#5-std-swap-1" class="headerlink" title="5. std::swap"></a>5. <code>std::swap</code></h3><ul>
<li><code>std::swap</code> 是一个函数模板，用于交换两个对象的值。</li>
<li>适用于大多数基本类型以及用户自定义类型的交换操作。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">std::<span class="built_in">swap</span>(a, b); <span class="comment">// Swap values of a and b</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>这些类和函数是 <code>&lt;utility&gt;</code> 头文件中最常用的，提供了许多方便的工具和功能，用于各种不同的编程场景中。使用它们可以简化代码，提高效率，并且支持泛型编程范式。</p>
<h2 id="std-pair"><a href="#std-pair" class="headerlink" title="std::pair"></a>std::pair</h2><p><code>std::pair</code> 是 C++ 标准库中的模板类，用于存储一对值。这两个值可以是不同类型的，通过 <code>std::pair</code> 可以将它们组合成一个单元，方便地对这两个值进行操作和传递。</p>
<h3 id="特点和用途："><a href="#特点和用途：" class="headerlink" title="特点和用途："></a>特点和用途：</h3><ul>
<li><strong>存储一对值：</strong> <code>std::pair</code> 允许存储两个值，可以是不同的类型。</li>
<li><strong>多用于函数返回值：</strong> 常用于函数需要返回两个值时，可以将这两个值打包成一个 <code>std::pair</code> 返回。</li>
<li><strong>作为映射容器的值类型：</strong> 在某些情况下，用于作为键值对存储在映射容器（如 <code>std::map</code>）中。</li>
</ul>
<h3 id="基本用法示例："><a href="#基本用法示例：" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>, std::string&gt; <span class="title">myPair</span><span class="params">(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First value: &quot;</span> &lt;&lt; myPair.first &lt;&lt; std::endl;   <span class="comment">// 访问第一个值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Second value: &quot;</span> &lt;&lt; myPair.second &lt;&lt; std::endl; <span class="comment">// 访问第二个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要成员函数："><a href="#主要成员函数：" class="headerlink" title="主要成员函数："></a>主要成员函数：</h3><ul>
<li><strong><code>first</code> 和 <code>second</code>：</strong> 分别用于访问存储的第一个值和第二个值。</li>
<li><strong><code>make_pair</code>：</strong> 用于创建 <code>std::pair</code> 对象。</li>
<li><strong><code>operator==</code> 和 <code>operator!=</code>：</strong> 用于比较两个 <code>std::pair</code> 对象是否相等或不相等。</li>
</ul>
<p><code>std::pair</code> 提供了一种便捷的方式来存储和操作一对值，特别是在函数需要返回多个值时，可以将这些值捆绑成一个 <code>std::pair</code> 返回，提高了代码的可读性和简洁性。</p>
<h2 id="std-make-pair"><a href="#std-make-pair" class="headerlink" title="std::make_pair()"></a>std::make_pair()</h2><p><code>std::make_pair()</code> 是一个模板函数，用于创建 <code>std::pair</code> 对象。它接受两个参数，并根据这两个参数的类型自动推导出 <code>std::pair</code> 对象的类型，然后返回这个新创建的 <code>std::pair</code> 对象。</p>
<h3 id="主要特点和用途："><a href="#主要特点和用途：" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>自动类型推导：</strong> <code>std::make_pair()</code> 会根据传入的参数类型自动推导出返回的 <code>std::pair</code> 对象的类型。</li>
<li><strong>便捷性：</strong> 方便创建和初始化 <code>std::pair</code> 对象，尤其适用于函数返回值或作为容器中的元素。</li>
</ul>
<h3 id="基本用法示例：-1"><a href="#基本用法示例：-1" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> myPair = std::<span class="built_in">make_pair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First value: &quot;</span> &lt;&lt; myPair.first &lt;&lt; std::endl;   <span class="comment">// 访问第一个值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Second value: &quot;</span> &lt;&lt; myPair.second &lt;&lt; std::endl; <span class="comment">// 访问第二个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::make_pair()</code> 接受一个整数和一个字符串作为参数，然后自动推导并返回一个 <code>std::pair&lt;int, const char*&gt;</code> 对象，将整数和字符串组合成一个对。这种自动推导减少了在代码中显式指定类型的需要，提高了代码的简洁性和可读性。</p>
<p>使用 <code>std::make_pair()</code> 可以方便地创建 <code>std::pair</code> 对象，并减少了手动指定模板参数的工作。</p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p><code>std::move</code> 是 C++ 标准库中的一个函数模板，用于将给定的左值强制转换为右值引用。它并不实际移动任何数据，而是允许程序员表达对某个值的“移动语义”。</p>
<h3 id="主要特点和用途：-1"><a href="#主要特点和用途：-1" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>支持移动语义：</strong> <code>std::move</code> 是 C++11 引入的一个重要工具，用于支持右值引用和移动语义。</li>
<li><strong>避免不必要的复制：</strong> 可以使用 <code>std::move</code> 将左值转换为右值引用，从而避免不必要的复制操作，在移动语义下可以更有效地管理资源。</li>
<li><strong>用于移动语义：</strong> 通常与移动构造函数和移动赋值运算符一起使用，支持对资源的高效转移，如避免资源的深层复制。</li>
</ul>
<h3 id="基本用法示例：-2"><a href="#基本用法示例：-2" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str2 = std::<span class="built_in">move</span>(str1); <span class="comment">// 转移 str1 的内容到 str2</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1 after move: &quot;</span> &lt;&lt; str1 &lt;&lt; std::endl; <span class="comment">// 注意：此处 str1 可能已经为空</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2 after move: &quot;</span> &lt;&lt; str2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::move</code> 将 <code>str1</code> 转换为右值引用，允许将 <code>str1</code> 的内容有效地移动到 <code>str2</code> 中。移动操作不会复制数据，而是“窃取”了 <code>str1</code> 的资源，因此在输出 <code>str1</code> 的内容时，它可能为空。</p>
<p><strong>注意：</strong> 使用 <code>std::move</code> 后，原来的左值变量（这里是 <code>str1</code>）可能不再包含有效的数据，因此需要谨慎使用移动语义，以避免悬空引用和使用无效数据。</p>
<h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h2><p><code>std::forward</code> 是一个模板函数，通常与模板和引用折叠相关，用于完美转发（perfect forwarding）。</p>
<h3 id="主要特点和用途：-2"><a href="#主要特点和用途：-2" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>完美转发：</strong> 在泛型编程中，<code>std::forward</code> 用于在函数模板中正确地保持传递参数的值类别（左值或右值）。</li>
<li><strong>保留参数类型：</strong> 将传递给函数的参数的值类别（左值或右值）转发到另一个函数，以保留参数的原始引用类型。</li>
<li><strong>配合模板参数推导：</strong> 通常与函数模板一起使用，避免参数传递过程中的值类别转换。</li>
</ul>
<h3 id="基本用法示例：-3"><a href="#基本用法示例：-3" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个函数模板，使用 std::forward 进行完美转发</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">some_function</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(value); <span class="comment">// 参数是左值</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">100</span>);   <span class="comment">// 参数是右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::forward</code> 用于将 <code>wrapper</code> 函数模板中的参数 <code>arg</code> 以原始的引用类型传递给 <code>some_function</code>。这有助于避免参数传递过程中的多余的值类别转换，实现完美转发，保持参数的原始引用类型。</p>
<p><code>std::forward</code> 在实现泛型函数和模板函数时非常有用，可以正确地将参数的左值或右值特性转发给另一个函数，以实现参数值的有效传递。</p>
<h2 id="std-swap"><a href="#std-swap" class="headerlink" title="std::swap()"></a>std::swap()</h2><p><code>std::swap()</code> 是 C++ 标准库中的一个函数模板，用于交换两个对象的值。它可以用于大多数基本类型和用户自定义类型的对象交换操作。</p>
<h3 id="主要特点和用途：-3"><a href="#主要特点和用途：-3" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>交换值：</strong> <code>std::swap()</code> 允许交换两个对象的值，无论对象是基本类型还是自定义类型。</li>
<li><strong>泛型：</strong> 是一个泛型函数模板，适用于各种类型的对象交换。</li>
<li><strong>支持自定义类型：</strong> 对于自定义类型，需要实现该类型的 <code>swap()</code> 成员函数或者提供全局的 <code>swap()</code> 重载函数。</li>
</ul>
<h3 id="基本用法示例：-4"><a href="#基本用法示例：-4" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    std::<span class="built_in">swap</span>(a, b); <span class="comment">// 交换 a 和 b 的值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a after swap: &quot;</span> &lt;&lt; a &lt;&lt; std::endl; <span class="comment">// 输出已交换后的 a</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b after swap: &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// 输出已交换后的 b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中展示了 <code>std::swap()</code> 函数如何交换两个整数变量 <code>a</code> 和 <code>b</code> 的值。对于基本类型，<code>std::swap()</code> 能够直接进行交换操作，但对于自定义类型，需要提供相应的 <code>swap()</code> 函数实现。</p>
<p>对于自定义类型，通常应该提供一个 <code>swap()</code> 成员函数或全局的 <code>swap()</code> 重载函数，以实现该类型对象的交换操作，从而使 <code>std::swap()</code> 能够正确工作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如，自定义类型的 swap() 函数实现：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 自定义类型的 swap() 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(MyClass&amp; other)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(value, other.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="comment">// 自定义类型的 swap() 全局重载函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(MyClass&amp; first, MyClass&amp; second)</span> </span>&#123;</span><br><span class="line">        first.<span class="built_in">swap</span>(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过提供适当的 <code>swap()</code> 函数，可以确保 <code>std::swap()</code> 在对自定义类型的对象进行交换时正常工作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_22_tuple/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_22_tuple/" class="post-title-link" itemprop="url">C++_10_22_tuple</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <tuple>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <tuple>标准库</h2><p><code>&lt;tuple&gt;</code> 是 C++ 标准库中的头文件，提供了 <code>std::tuple</code> 类模板和相关函数，用于创建和操作元组（Tuple）。</p>
<h3 id="std-tuple-概述："><a href="#std-tuple-概述：" class="headerlink" title="std::tuple 概述："></a>std::tuple 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;tuple&gt;</code></li>
<li><strong>类模板：</strong> <code>std::tuple</code></li>
</ul>
<h3 id="元组（Tuple）的特点："><a href="#元组（Tuple）的特点：" class="headerlink" title="元组（Tuple）的特点："></a>元组（Tuple）的特点：</h3><ul>
<li><strong>有序集合：</strong> 元组是一个固定大小的、有序的集合，可以包含多个不同类型的元素。</li>
<li><strong>类似于数组：</strong> 类似于数组，但元组中的元素可以是不同的类型，并且元素数量固定。</li>
<li><strong>元素访问：</strong> 元组中的元素可以通过索引或 <code>std::get</code> 函数进行访问。</li>
<li><strong>用于函数返回多个值：</strong> 常用于函数需要返回多个值时，可以将这些值组织成元组进行返回。</li>
</ul>
<h3 id="基本操作和示例："><a href="#基本操作和示例：" class="headerlink" title="基本操作和示例："></a>基本操作和示例：</h3><ul>
<li><p><strong>创建元组：</strong> 使用 <code>std::make_tuple</code> 或直接使用构造函数创建元组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myTuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; <span class="title">myTuple</span><span class="params">(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问元组元素：</strong> 使用 <code>std::get</code> 函数或 <code>std::tie</code> 函数进行元素的访问或解包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple); <span class="comment">// 访问第一个元素</span></span><br><span class="line">std::string str = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple); <span class="comment">// 访问第二个元素</span></span><br><span class="line"><span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple); <span class="comment">// 访问第三个元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解包元组：</strong> 使用 <code>std::tie</code> 将元组解包为多个变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">std::string y;</span><br><span class="line"><span class="type">double</span> z;</span><br><span class="line">std::<span class="built_in">tie</span>(x, y, z) = myTuple; <span class="comment">// 将元组解包为 x, y, z 三个变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>元组大小：</strong> 使用 <code>std::tuple_size</code> 获取元组的大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> tupleSize = std::tuple_size&lt;<span class="keyword">decltype</span>(myTuple)&gt;::value;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>std::tuple</code> 提供了一种方便的方式来组织和操作多个不同类型的值，并且可以在函数返回多个值时使用。通过元组，可以在不使用结构体的情况下返回多个相关联的值，提高了代码的灵活性和可读性。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <tuple>标准库 详解</h2><p><code>&lt;tuple&gt;</code> 标准库提供了 <code>std::tuple</code> 类模板和一些相关的函数，用于创建、操作和处理元组（Tuple）。元组是一个固定大小、有序的集合，可以容纳不同类型的元素。</p>
<h3 id="std-tuple-概览："><a href="#std-tuple-概览：" class="headerlink" title="std::tuple 概览："></a>std::tuple 概览：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;tuple&gt;</code></li>
<li><strong>类模板：</strong> <code>std::tuple</code></li>
</ul>
<h3 id="主要特点和用途："><a href="#主要特点和用途：" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>组织多个值：</strong> 元组用于组织多个不同类型的值，并且长度是固定的。</li>
<li><strong>多种构造方式：</strong> 可以使用 <code>std::make_tuple</code>、直接使用构造函数等多种方式创建元组。</li>
<li><strong>元素访问：</strong> 可以使用 <code>std::get</code> 获取元组中的元素，也可以通过解包或结构绑定方式访问元素。</li>
<li><strong>函数返回多个值：</strong> 在需要返回多个相关联的值时，可以使用元组。</li>
</ul>
<h3 id="基本用法示例："><a href="#基本用法示例：" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建元组</span></span><br><span class="line">    <span class="keyword">auto</span> myTuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元组元素</span></span><br><span class="line">    <span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple); <span class="comment">// 访问第一个元素</span></span><br><span class="line">    std::string str = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple); <span class="comment">// 访问第二个元素</span></span><br><span class="line">    <span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple); <span class="comment">// 访问第三个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解包元组</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    std::<span class="built_in">tie</span>(x, y, z) = myTuple; <span class="comment">// 解包元组为 x, y, z 三个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元组大小</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> tupleSize = std::tuple_size&lt;<span class="keyword">decltype</span>(myTuple)&gt;::value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元组是一个强大的工具，允许将多个值组织在一起，而不需要使用自定义结构体。它能够帮助编写更灵活、更通用的代码，尤其是在需要返回多个相关值的情况下，提高了代码的可读性和简洁性。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <tuple>标准库 常用的类和函数</h2><p><code>&lt;tuple&gt;</code> 标准库中常用的类和函数包括 <code>std::tuple</code> 类模板以及一些与元组相关的操作函数。</p>
<h3 id="1-std-tuple-类模板"><a href="#1-std-tuple-类模板" class="headerlink" title="1. std::tuple 类模板"></a>1. std::tuple 类模板</h3><ul>
<li><code>std::tuple</code> 是一个类模板，用于表示一个固定大小的有序集合，可以存储不同类型的元素。</li>
<li>用于组织多个值，并以元组的形式进行传递和处理。</li>
</ul>
<h3 id="2-std-make-tuple"><a href="#2-std-make-tuple" class="headerlink" title="2. std::make_tuple"></a>2. std::make_tuple</h3><ul>
<li><code>std::make_tuple</code> 是一个模板函数，用于创建 <code>std::tuple</code> 对象。</li>
<li>接受一系列参数，并根据参数类型推导出相应的 <code>std::tuple</code> 对象。</li>
</ul>
<h3 id="3-std-get"><a href="#3-std-get" class="headerlink" title="3. std::get"></a>3. std::get</h3><ul>
<li><code>std::get</code> 是一个模板函数，用于访问元组中指定位置的元素。</li>
<li>可以通过索引来获取元组中的元素，以实现对元组内容的访问。</li>
</ul>
<h3 id="4-std-tie"><a href="#4-std-tie" class="headerlink" title="4. std::tie"></a>4. std::tie</h3><ul>
<li><code>std::tie</code> 是一个模板函数，用于解包元组并将元组的元素绑定到变量上。</li>
<li>可以将元组中的值解包为多个变量，并将这些变量绑定到元组的相应位置。</li>
</ul>
<h3 id="5-std-tuple-size"><a href="#5-std-tuple-size" class="headerlink" title="5. std::tuple_size"></a>5. std::tuple_size</h3><ul>
<li><code>std::tuple_size</code> 是一个模板类，用于获取元组的大小（元素数量）。</li>
<li>通过该类模板可以获取元组的大小，通常与模板参数一起使用。</li>
</ul>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建元组</span></span><br><span class="line">    <span class="keyword">auto</span> myTuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元组元素</span></span><br><span class="line">    <span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple); <span class="comment">// 访问第一个元素</span></span><br><span class="line">    std::string str = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple); <span class="comment">// 访问第二个元素</span></span><br><span class="line">    <span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple); <span class="comment">// 访问第三个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解包元组</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    std::<span class="built_in">tie</span>(x, y, z) = myTuple; <span class="comment">// 解包元组为 x, y, z 三个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元组大小</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> tupleSize = std::tuple_size&lt;<span class="keyword">decltype</span>(myTuple)&gt;::value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些类和函数是 <code>&lt;tuple&gt;</code> 头文件中最常用的，用于创建、访问和处理元组。它们提供了一种方便的方式来组织和操作多个不同类型的值，可以在不使用结构体的情况下返回多个相关联的值，提高了代码的灵活性和可读性。</p>
<h2 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a>std::tuple</h2><p><code>std::tuple</code> 是 C++ 标准库中的一个模板类，用于表示一个固定数量、固定顺序的元素集合，这些元素可以是不同类型的。<code>std::tuple</code> 类模板允许以元组的形式存储和操作多个值。</p>
<h3 id="主要特点和用途：-1"><a href="#主要特点和用途：-1" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>有序集合：</strong> <code>std::tuple</code> 以有序集合的形式存储一组值，值的数量和类型是固定的。</li>
<li><strong>不同类型元素：</strong> 允许存储不同类型的元素，支持任意数量的不同类型值的组合。</li>
<li><strong>多用途：</strong> 用于函数返回多个值，传递多个参数，或者用于在不使用结构体的情况下组织多个值。</li>
</ul>
<h3 id="基本操作和示例：-1"><a href="#基本操作和示例：-1" class="headerlink" title="基本操作和示例："></a>基本操作和示例：</h3><h4 id="创建元组："><a href="#创建元组：" class="headerlink" title="创建元组："></a>创建元组：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用std::make_tuple创建元组</span></span><br><span class="line"><span class="keyword">auto</span> myTuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="comment">// 使用tuple的构造函数创建元组</span></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; <span class="title">myTuple</span><span class="params">(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="访问元组元素："><a href="#访问元组元素：" class="headerlink" title="访问元组元素："></a>访问元组元素：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple); <span class="comment">// 访问第一个元素</span></span><br><span class="line">std::string str = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple); <span class="comment">// 访问第二个元素</span></span><br><span class="line"><span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple); <span class="comment">// 访问第三个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="解包元组："><a href="#解包元组：" class="headerlink" title="解包元组："></a>解包元组：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">std::string y;</span><br><span class="line"><span class="type">double</span> z;</span><br><span class="line">std::<span class="built_in">tie</span>(x, y, z) = myTuple; <span class="comment">// 将元组解包为 x, y, z 三个变量</span></span><br></pre></td></tr></table></figure>

<h4 id="获取元组大小："><a href="#获取元组大小：" class="headerlink" title="获取元组大小："></a>获取元组大小：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> tupleSize = std::tuple_size&lt;<span class="keyword">decltype</span>(myTuple)&gt;::value; <span class="comment">// 获取元组大小</span></span><br></pre></td></tr></table></figure>

<p><code>std::tuple</code> 是一个灵活且功能强大的工具，特别适用于需要返回多个相关联的值的情况。它可以提高代码的可读性和灵活性，同时也减少了在函数参数和返回值方面的代码复杂度。</p>
<h2 id="std-make-tuple"><a href="#std-make-tuple" class="headerlink" title="std::make_tuple"></a>std::make_tuple</h2><p><code>std::make_tuple</code> 是一个模板函数，用于创建 <code>std::tuple</code> 对象。它允许您通过传递一系列参数来创建一个元组对象，并自动推导出元组的类型。</p>
<h3 id="主要特点和用途：-2"><a href="#主要特点和用途：-2" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>自动类型推导：</strong> <code>std::make_tuple</code> 根据传递的参数类型自动推导出返回的 <code>std::tuple</code> 对象的类型。</li>
<li><strong>便捷性：</strong> 方便地创建和初始化元组，尤其适用于函数返回值或作为容器中的元素。</li>
</ul>
<h3 id="基本用法示例：-1"><a href="#基本用法示例：-1" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> myTuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple); <span class="comment">// 获取第一个元素</span></span><br><span class="line">    std::string str = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple); <span class="comment">// 获取第二个元素</span></span><br><span class="line">    <span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple); <span class="comment">// 获取第三个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::make_tuple</code> 接受三个参数并自动推导出一个 <code>std::tuple&lt;int, const char*, double&gt;</code> 类型的元组对象。使用 <code>std::get</code> 可以方便地访问元组中的各个元素。</p>
<p><code>std::make_tuple</code> 的优势在于提供了一种更简洁和易读的方式来创建元组对象，无需显式指定模板参数类型，编译器会根据传入的参数类型自动推导出正确的元组类型。</p>
<h2 id="std-get"><a href="#std-get" class="headerlink" title="std::get"></a>std::get</h2><p><code>std::get</code> 是用于从 <code>std::tuple</code> 中获取特定位置的元素值的模板函数。它提供了一种访问元组中特定位置元素的方式，允许您根据索引访问元组的元素。</p>
<h3 id="主要特点和用途：-3"><a href="#主要特点和用途：-3" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>访问元组元素：</strong> <code>std::get</code> 用于检索元组中特定索引位置的元素。</li>
<li><strong>参数化访问：</strong> 该函数模板使用一个整数模板参数来指定要访问的元素位置。</li>
<li><strong>安全性检查：</strong> 通过编译时索引进行访问，因此可以在编译时捕获索引错误。</li>
</ul>
<h3 id="基本用法示例：-2"><a href="#基本用法示例：-2" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; <span class="title">myTuple</span><span class="params">(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple); <span class="comment">// 获取第一个元素</span></span><br><span class="line">    std::string str = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple); <span class="comment">// 获取第二个元素</span></span><br><span class="line">    <span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple); <span class="comment">// 获取第三个元素</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::get&lt;index&gt;(myTuple)</code> 用于检索元组 <code>myTuple</code> 中指定索引位置（使用 <code>index</code>）的元素。元组索引从0开始，<code>std::get&lt;0&gt;(myTuple)</code> 获取第一个元素，<code>std::get&lt;1&gt;(myTuple)</code> 获取第二个元素，以此类推。</p>
<p>使用 <code>std::get</code> 可以方便地访问元组中特定位置的元素，并在编译时进行索引错误的检查，确保访问的元素位置是有效的。</p>
<h2 id="std-tie"><a href="#std-tie" class="headerlink" title="std::tie"></a>std::tie</h2><p><code>std::tie</code> 是一个模板函数，用于将元组的元素解包（unpack）并将其绑定到指定的变量上。这种操作常用于从函数返回多个值或者进行多个变量的赋值操作。</p>
<h3 id="主要特点和用途：-4"><a href="#主要特点和用途：-4" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>解包元组：</strong> <code>std::tie</code> 允许将元组中的元素解包为多个变量。</li>
<li><strong>多变量绑定：</strong> 可以将元组的元素按顺序绑定到一系列变量上，无需一个个分别赋值。</li>
</ul>
<h3 id="基本用法示例：-3"><a href="#基本用法示例：-3" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; <span class="title">myTuple</span><span class="params">(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 std::tie 解包元组并绑定到变量</span></span><br><span class="line">    std::<span class="built_in">tie</span>(x, y, z) = myTuple;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::tie</code> 将 <code>myTuple</code> 元组中的元素解包，并将其依次绑定到变量 <code>x</code>、<code>y</code> 和 <code>z</code> 上。这样就能够直接从元组中获取值并赋给变量，而无需手动调用 <code>std::get</code>。</p>
<p><code>std::tie</code> 对于函数返回多个值时特别有用，可以让您一次性获取多个值并将它们分别赋给变量，提高代码的可读性和简洁性。</p>
<h2 id="std-tuple-size"><a href="#std-tuple-size" class="headerlink" title="std::tuple_size"></a>std::tuple_size</h2><p><code>std::tuple_size</code> 是一个模板类，用于获取元组的大小（也就是元组中元素的数量）。它通常与 <code>std::tuple</code> 一起使用，以在编译时获取元组的大小信息。</p>
<h3 id="主要特点和用途：-5"><a href="#主要特点和用途：-5" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>获取元组大小：</strong> <code>std::tuple_size</code> 用于获取元组类型的大小（元素数量）。</li>
<li><strong>编译时确定：</strong> 该类模板返回一个 <code>constexpr</code> 值，可以在编译时计算出元组的大小。</li>
</ul>
<h3 id="基本用法示例：-4"><a href="#基本用法示例：-4" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; myTuple;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::tuple_size 获取元组的大小</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> tupleSize = std::tuple_size&lt;<span class="keyword">decltype</span>(myTuple)&gt;::value;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Tuple size: &quot;</span> &lt;&lt; tupleSize &lt;&lt; std::endl; <span class="comment">// 输出元组的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::tuple_size</code> 类模板被用来获取 <code>myTuple</code> 元组对象的大小。使用 <code>decltype</code> 获取 <code>myTuple</code> 的类型，并使用 <code>::value</code> 获取元组大小的 <code>constexpr</code> 值。</p>
<p><code>std::tuple_size</code> 可以让您在编译时获取元组的大小，这在某些情况下可以用来进行一些特定的编译时优化和检查。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_23_cstdint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_23_cstdint/" class="post-title-link" itemprop="url">C++_10_23_cstdint</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <cstdint>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <cstdint>标准库</h2><p><code>&lt;cstdint&gt;</code> 是 C++ 标准库中的头文件，提供了固定大小的整数类型。它定义了一系列的整数类型，确保这些类型在不同平台上有固定的大小，以增强代码的可移植性。</p>
<h3 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h3><ul>
<li><strong>整数类型：</strong> 提供了带有明确大小的整数类型，例如 <code>int8_t</code>、<code>uint8_t</code>、<code>int16_t</code>、<code>uint16_t</code> 等。</li>
<li><strong>最小值和最大值：</strong> 定义了每种固定大小整数类型的最小值和最大值。</li>
<li><strong>位宽有符号和无符号整数：</strong> 提供了有符号和无符号整数类型，其位宽是确定的。</li>
</ul>
<h3 id="常用类型："><a href="#常用类型：" class="headerlink" title="常用类型："></a>常用类型：</h3><p>以下是一些常用的整数类型，它们保证了固定的大小和有符号&#x2F;无符号特性：</p>
<ul>
<li><code>int8_t</code>, <code>uint8_t</code>: 8 位整数类型</li>
<li><code>int16_t</code>, <code>uint16_t</code>: 16 位整数类型</li>
<li><code>int32_t</code>, <code>uint32_t</code>: 32 位整数类型</li>
<li><code>int64_t</code>, <code>uint64_t</code>: 64 位整数类型</li>
</ul>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int8_t</span> myInt8 = <span class="number">127</span>;</span><br><span class="line">    <span class="type">uint16_t</span> myUInt16 = <span class="number">65535</span>;</span><br><span class="line">    <span class="type">int32_t</span> myInt32 = <span class="number">-2147483647</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int8_t value: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(myInt8) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;uint16_t value: &quot;</span> &lt;&lt; myUInt16 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int32_t value: &quot;</span> &lt;&lt; myInt32 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;cstdint&gt;</code> 头文件提供了确定大小和有符号&#x2F;无符号特性的整数类型，确保了整数类型在各种平台上的可移植性和一致性。这些类型通常用于需要确切大小和精确位宽的数据表示的场景。</p>
<h2 id="C-标准库-常用类型和函数"><a href="#C-标准库-常用类型和函数" class="headerlink" title="C++ 标准库 常用类型和函数"></a>C++ <cstdint>标准库 常用类型和函数</h2><p><code>&lt;cstdint&gt;</code> 标准库提供了一组固定大小的整数类型和与整数类型相关的函数，以增强代码的可移植性和可读性。</p>
<h3 id="常用类型：-1"><a href="#常用类型：-1" class="headerlink" title="常用类型："></a>常用类型：</h3><ol>
<li><p><strong>有符号整数类型：</strong></p>
<ul>
<li><code>int8_t</code>: 8 位带符号整数类型</li>
<li><code>int16_t</code>: 16 位带符号整数类型</li>
<li><code>int32_t</code>: 32 位带符号整数类型</li>
<li><code>int64_t</code>: 64 位带符号整数类型</li>
</ul>
</li>
<li><p><strong>无符号整数类型：</strong></p>
<ul>
<li><code>uint8_t</code>: 8 位无符号整数类型</li>
<li><code>uint16_t</code>: 16 位无符号整数类型</li>
<li><code>uint32_t</code>: 32 位无符号整数类型</li>
<li><code>uint64_t</code>: 64 位无符号整数类型</li>
</ul>
</li>
<li><p><strong>最小值和最大值常量：</strong></p>
<ul>
<li><code>INT8_MIN</code>, <code>INT8_MAX</code>: <code>int8_t</code> 的最小值和最大值</li>
<li><code>UINT8_MAX</code>: <code>uint8_t</code> 的最大值</li>
<li>以此类推，每种固定大小整数类型都有相应的最小值和最大值常量。</li>
</ul>
</li>
</ol>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ol>
<li><p><strong>宏定义：</strong></p>
<ul>
<li><code>INT8_C</code>, <code>UINT8_C</code>: 用于创建带符号和无符号整数常量，例如 <code>INT8_C(5)</code> 表示带符号 8 位整数的常量 5。</li>
</ul>
</li>
<li><p><strong>最小宽度宏定义：</strong></p>
<ul>
<li><code>INT_LEAST8_MIN</code>, <code>INT_LEAST8_MAX</code>: <code>int_least8_t</code> 的最小值和最大值</li>
<li><code>UINT_LEAST8_MAX</code>: <code>uint_least8_t</code> 的最大值</li>
<li>以此类推，最小宽度整数类型都有对应的最小值和最大值常量。</li>
</ul>
</li>
<li><p><strong>快速宽度宏定义：</strong></p>
<ul>
<li><code>INT_FAST8_MIN</code>, <code>INT_FAST8_MAX</code>: <code>int_fast8_t</code> 的最小值和最大值</li>
<li><code>UINT_FAST8_MAX</code>: <code>uint_fast8_t</code> 的最大值</li>
<li>同样适用于其他固定大小整数类型。</li>
</ul>
</li>
<li><p><strong>其他函数：</strong></p>
<ul>
<li><code>INTPTR_MIN</code>, <code>INTPTR_MAX</code>: <code>intptr_t</code> 的最小值和最大值</li>
<li><code>UINTPTR_MAX</code>: <code>uintptr_t</code> 的最大值</li>
<li><code>INTMAX_MIN</code>, <code>INTMAX_MAX</code>: <code>intmax_t</code> 的最小值和最大值</li>
<li><code>UINTMAX_MAX</code>: <code>uintmax_t</code> 的最大值</li>
</ul>
</li>
</ol>
<p>这些常用类型和函数提供了在特定位宽下确定大小和精确度的整数类型，同时还提供了这些类型的最小值和最大值常量以及用于创建整数常量的宏定义。这些工具通常用于需要确切大小和精确位宽的数据表示的场景。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_25_forward_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_25_forward_list/" class="post-title-link" itemprop="url">C++_10_25_forward_list</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <forward_list>标准库</li>
</ul>
<h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h2><ul>
<li>与list类似，区别在于forward_list是单链表，而list是双链表，这意味着forward_list只支持前向迭代。</li>
<li>C++标准要求forward_list最小化其内存使用，这就是没有size()方法的原因，因为不提供它，就不需要存储列表的大小。</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <forward_list>标准库</h2><p><code>&lt;forward_list&gt;</code> 是 C++ 标准库中的头文件，定义了单向链表（singly linked list）的模板类 <code>std::forward_list</code>。与 <code>std::list</code> 不同，<code>std::forward_list</code> 是单向链表，每个元素只保留指向下一个元素的指针。</p>
<h3 id="std-forward-list-概述："><a href="#std-forward-list-概述：" class="headerlink" title="std::forward_list 概述："></a>std::forward_list 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;forward_list&gt;</code></li>
<li><strong>容器类型：</strong> <code>std::forward_list</code> 是标准库中的容器类型之一，实现了单向链表。</li>
<li><strong>特点：</strong><ul>
<li>每个元素只保留指向下一个元素的指针，只能从前往后遍历。</li>
<li>支持高效的插入和删除操作，但对于随机访问效率较低。</li>
<li>没有 <code>size()</code> 函数，需要手动计算元素数量。</li>
</ul>
</li>
</ul>
<h3 id="主要操作和用法："><a href="#主要操作和用法：" class="headerlink" title="主要操作和用法："></a>主要操作和用法：</h3><ul>
<li><strong>插入和删除操作：</strong><ul>
<li><code>push_front()</code>, <code>pop_front()</code>: 在链表头部插入或删除元素。</li>
<li><code>insert_after()</code>, <code>erase_after()</code>: 在指定位置后插入或删除元素。</li>
</ul>
</li>
<li><strong>迭代器操作：</strong><ul>
<li><code>before_begin()</code>, <code>begin()</code>, <code>end()</code>: 获取链表迭代器。</li>
</ul>
</li>
<li><strong>大小操作：</strong><ul>
<li><code>empty()</code>: 判断链表是否为空。</li>
</ul>
</li>
<li><strong>其他操作：</strong><ul>
<li><code>remove()</code>: 移除链表中所有与给定值相等的元素。</li>
<li><code>reverse()</code>: 反转链表</li>
</ul>
</li>
</ul>
<p>由于技术问题，可能导致消息不完整。让我知道您是否需要更多关于 <code>&lt;forward_list&gt;</code> 的信息或者其他方面的帮助。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <forward_list>标准库 详解</h2><p><code>&lt;forward_list&gt;</code> 是 C++ 标准库中的头文件，定义了单向链表的模板类 <code>std::forward_list</code>。与 <code>std::list</code> 不同，<code>std::forward_list</code> 是单向链表，每个元素只保留指向下一个元素的指针。</p>
<h3 id="std-forward-list-概述：-1"><a href="#std-forward-list-概述：-1" class="headerlink" title="std::forward_list 概述："></a>std::forward_list 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;forward_list&gt;</code></li>
<li><strong>容器类型：</strong> <code>std::forward_list</code> 是标准库中的容器类型之一，实现了单向链表。</li>
<li><strong>特点：</strong><ul>
<li>每个元素只保留指向下一个元素的指针，只能从前往后遍历。</li>
<li>支持高效的插入和删除操作，但对于随机访问效率较低。</li>
<li>没有 <code>size()</code> 函数，需要手动计算元素数量。</li>
</ul>
</li>
</ul>
<h3 id="主要操作和用法：-1"><a href="#主要操作和用法：-1" class="headerlink" title="主要操作和用法："></a>主要操作和用法：</h3><ul>
<li><strong>插入和删除操作：</strong><ul>
<li><code>push_front()</code>, <code>pop_front()</code>: 在链表头部插入或删除元素。</li>
<li><code>insert_after()</code>, <code>erase_after()</code>: 在指定位置后插入或删除元素。</li>
</ul>
</li>
<li><strong>迭代器操作：</strong><ul>
<li><code>before_begin()</code>, <code>begin()</code>, <code>end()</code>: 获取链表迭代器。</li>
</ul>
</li>
<li><strong>大小操作：</strong><ul>
<li><code>empty()</code>: 判断链表是否为空。</li>
</ul>
</li>
<li><strong>其他操作：</strong><ul>
<li><code>remove()</code>: 移除链表中所有与给定值相等的元素。</li>
<li><code>reverse()</code>: 反转链表。</li>
</ul>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">// 在链表头部插入元素</span></span><br><span class="line">    myList.<span class="built_in">pop_front</span>(); <span class="comment">// 删除链表头部的元素</span></span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">insert_after</span>(myList.<span class="built_in">begin</span>(), <span class="number">4</span>); <span class="comment">// 在第一个元素后插入元素</span></span><br><span class="line">    myList.<span class="built_in">erase_after</span>(myList.<span class="built_in">begin</span>()); <span class="comment">// 删除第一个元素后的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">remove</span>(<span class="number">2</span>); <span class="comment">// 移除所有值为 2 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">reverse</span>(); <span class="comment">// 反转链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::forward_list</code> 提供了一系列方法来操作单向链表，这些方法包括在链表头尾插入或删除元素、访问元素、迭代器操作、大小操作、移除指定元素和反转链表。通过这些函数，可以方便地对链表进行操作和管理。</p>
<h2 id="std-forward-list-reverse"><a href="#std-forward-list-reverse" class="headerlink" title="std::forward_list::reverse()"></a>std::forward_list::reverse()</h2><p>在 C++ 中，<code>std::forward_list::reverse()</code> 是 <code>std::forward_list</code> 类提供的成员函数之一，用于颠倒（反转）单向链表中元素的顺序。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数作用："><a href="#函数作用：" class="headerlink" title="函数作用："></a>函数作用：</h3><ul>
<li><code>reverse()</code> 函数将单向链表中的元素顺序颠倒，即将链表元素的顺序反转。</li>
</ul>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>std::forward_list</code> 是单向链表，它只能从前往后遍历。因此，颠倒链表元素的唯一方法就是重新排列链表中元素的指针，以颠倒其顺序。</li>
<li>由于单向链表只能从前往后遍历，因此颠倒链表需要遍历整个链表，时间复杂度为 O(n)。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original forward_list: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">reverse</span>(); <span class="comment">// 反转单向链表中的元素顺序</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reversed forward_list: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myList.reverse()</code> 将 <code>myList</code> 单向链表中的元素顺序颠倒。最终输出将展示原始链表和反转后的链表的元素顺序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_26_deque/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_26_deque/" class="post-title-link" itemprop="url">C++_10_26_deque</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <deque>标准库</li>
</ul>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><ul>
<li>deque(double-ended queue的简称)几乎和vector是等同的，但是用的更少</li>
<li>主要区别如下<ul>
<li>不要求元素保存在连续内存中</li>
<li>deque支持首尾两端常量时间的插入和删除操作(vecto只支持尾端的常量时间)</li>
<li>在开头和末尾插入元素时，deque未使迭代器失效</li>
</ul>
</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <deque>标准库</h2><p><code>&lt;deque&gt;</code> 是 C++ 标准库中的头文件，定义了双端队列（double-ended queue）的模板类 <code>std::deque</code>。</p>
<h3 id="std-deque-概述："><a href="#std-deque-概述：" class="headerlink" title="std::deque 概述："></a>std::deque 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;deque&gt;</code></li>
<li><strong>容器类型：</strong> <code>std::deque</code> 是标准库中的容器类型之一，表示双端队列。</li>
<li><strong>特点：</strong><ul>
<li>可以在两端高效地执行插入和删除操作，支持快速的随机访问。</li>
<li>与 <code>std::vector</code> 相似，但在两端插入和删除的操作效率更高，但随机访问的效率稍低。</li>
<li>内部使用多个固定大小的连续存储块来存储数据，允许在两端进行快速插入和删除。</li>
</ul>
</li>
</ul>
<h3 id="主要操作和用法："><a href="#主要操作和用法：" class="headerlink" title="主要操作和用法："></a>主要操作和用法：</h3><ul>
<li><strong>插入和删除操作：</strong><ul>
<li><code>push_front()</code>, <code>push_back()</code>: 在队列的前端或后端插入元素。</li>
<li><code>pop_front()</code>, <code>pop_back()</code>: 从队列的前端或后端删除元素。</li>
</ul>
</li>
<li><strong>随机访问：</strong><ul>
<li>支持 <code>operator[]</code> 和 <code>at()</code> 等方法进行随机访问元素。</li>
</ul>
</li>
<li><strong>大小操作：</strong><ul>
<li><code>size()</code>, <code>empty()</code>: 获取队列的大小和判断是否为空。</li>
</ul>
</li>
<li><strong>其他操作：</strong><ul>
<li><code>front()</code>, <code>back()</code>: 获取队列的第一个和最后一个元素。</li>
<li><code>insert()</code>, <code>erase()</code>: 在指定位置插入或删除元素。</li>
</ul>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; myDeque = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myDeque.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">// 在前端插入元素</span></span><br><span class="line">    myDeque.<span class="built_in">push_back</span>(<span class="number">4</span>); <span class="comment">// 在后端插入元素</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of deque: &quot;</span> &lt;&lt; myDeque.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front element: &quot;</span> &lt;&lt; myDeque.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back element: &quot;</span> &lt;&lt; myDeque.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myDeque.<span class="built_in">pop_front</span>(); <span class="comment">// 删除前端元素</span></span><br><span class="line">    myDeque.<span class="built_in">pop_back</span>(); <span class="comment">// 删除后端元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myDeque) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::deque</code> 的基本操作，包括在队列的前端和后端插入元素、获取队列的大小和头尾元素、删除前后端元素，并且遍历输出了队列中的元素。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <deque>标准库 详解</h2><p><code>&lt;deque&gt;</code> 头文件定义了 C++ 标准库中的 <code>std::deque</code>（双端队列）模板类。Deque（双端队列）是一种数据结构，允许在两端进行高效地插入和删除操作。</p>
<h3 id="std-deque-概述：-1"><a href="#std-deque-概述：-1" class="headerlink" title="std::deque 概述："></a>std::deque 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;deque&gt;</code></li>
<li><strong>容器类型：</strong> <code>std::deque</code> 是标准库中的容器类型之一，表示双端队列。</li>
<li><strong>特点：</strong><ul>
<li>可以在两端高效地执行插入和删除操作，支持快速的随机访问。</li>
<li>与 <code>std::vector</code> 相似，但在两端插入和删除的操作效率更高，但随机访问的效率稍低。</li>
<li>内部使用多个固定大小的连续存储块来存储数据，允许在两端进行快速插入和删除。</li>
</ul>
</li>
</ul>
<h3 id="std-deque-的主要操作和用法："><a href="#std-deque-的主要操作和用法：" class="headerlink" title="std::deque 的主要操作和用法："></a>std::deque 的主要操作和用法：</h3><ul>
<li><strong>插入和删除操作：</strong><ul>
<li><code>push_front()</code>, <code>push_back()</code>: 在队列的前端或后端插入元素。</li>
<li><code>pop_front()</code>, <code>pop_back()</code>: 从队列的前端或后端删除元素。</li>
</ul>
</li>
<li><strong>随机访问：</strong><ul>
<li>支持 <code>operator[]</code> 和 <code>at()</code> 等方法进行随机访问元素。</li>
</ul>
</li>
<li><strong>大小操作：</strong><ul>
<li><code>size()</code>, <code>empty()</code>: 获取队列的大小和判断是否为空。</li>
</ul>
</li>
<li><strong>其他操作：</strong><ul>
<li><code>front()</code>, <code>back()</code>: 获取队列的第一个和最后一个元素。</li>
<li><code>insert()</code>, <code>erase()</code>: 在指定位置插入或删除元素。</li>
</ul>
</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; myDeque = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myDeque.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">// 在前端插入元素</span></span><br><span class="line">    myDeque.<span class="built_in">push_back</span>(<span class="number">4</span>); <span class="comment">// 在后端插入元素</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of deque: &quot;</span> &lt;&lt; myDeque.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front element: &quot;</span> &lt;&lt; myDeque.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back element: &quot;</span> &lt;&lt; myDeque.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myDeque.<span class="built_in">pop_front</span>(); <span class="comment">// 删除前端元素</span></span><br><span class="line">    myDeque.<span class="built_in">pop_back</span>(); <span class="comment">// 删除后端元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myDeque) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::deque</code> 的基本操作，包括在队列的前端和后端插入元素、获取队列的大小和头尾元素、删除前后端元素，并且遍历输出了队列中的元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_24_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_24_list/" class="post-title-link" itemprop="url">C++_10_24_list</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <list>标准库</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul>
<li>list，是一种标准的双链表。list支持链表中任意位置常量时间的元素插入和删除操作，但访问单独元素的速度较慢(线性时间)</li>
<li>list不支持元素的随机访问。list提供的访问元素的方法仅有front()和back()。这两个方法的时间复杂度都是常量时间。对其他元素的访问都必须通过迭代器进行。</li>
<li>list迭代器是双向的，不像vector迭代器那样提供随机访问，这意味着list迭代器之间不能进行加减操作和其他指针运算。例如，如果p是一个list迭代器，那么可以通过++p或–p遍历链表，但是不能使用加减运算符，p+n和p-n都是不可以的</li>
<li>list大小与deque一样，但是和vector不同，list不暴露底层的内存模型，因此，list支持size(), empty()和resize(),但是不支持reserve()和capacity()。</li>
<li>需要注意的是，list的size()方法具有常量时间复杂度。</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <list>标准库</h2><p><code>&lt;list&gt;</code> 是 C++ 标准库中的头文件，定义了双向链表（doubly linked list）的模板类 <code>std::list</code>。双向链表是一种动态数据结构，允许在常量时间内在两端进行插入、删除操作。</p>
<h3 id="std-list-概述："><a href="#std-list-概述：" class="headerlink" title="std::list 概述："></a>std::list 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;list&gt;</code></li>
<li><strong>容器类型：</strong> <code>std::list</code> 是标准库中的容器类型之一，实现了双向链表。</li>
<li><strong>特点：</strong><ul>
<li>元素按插入顺序存储。</li>
<li>支持高效的插入和删除操作，但对于随机访问效率较低。</li>
<li>不支持直接随机访问元素，需要使用迭代器进行访问。</li>
</ul>
</li>
</ul>
<h3 id="主要操作和用法："><a href="#主要操作和用法：" class="headerlink" title="主要操作和用法："></a>主要操作和用法：</h3><ul>
<li><strong>插入和删除操作：</strong> <code>push_back()</code>, <code>push_front()</code>, <code>pop_back()</code>, <code>pop_front()</code> 用于在列表两端插入或删除元素。</li>
<li><strong>迭代器操作：</strong> 使用迭代器进行元素访问、遍历和操作。</li>
<li><strong>大小操作：</strong> <code>size()</code>, <code>empty()</code> 获取列表的大小和判断是否为空。</li>
<li><strong>其他操作：</strong> <code>insert()</code>, <code>erase()</code>, <code>splice()</code> 等用于在指定位置插入、删除、合并列表等操作。</li>
</ul>
<h3 id="基本示例："><a href="#基本示例：" class="headerlink" title="基本示例："></a>基本示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第一个元素</span></span><br><span class="line">    myList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">next</span>(myList.<span class="built_in">begin</span>()); <span class="comment">// 获取迭代器</span></span><br><span class="line">    myList.<span class="built_in">insert</span>(it, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定元素</span></span><br><span class="line">    myList.<span class="built_in">remove</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出剩余元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::list</code> 是一个有用的容器，特别适合在需要频繁插入和删除元素而不需要进行随机访问的场景下使用。通过使用迭代器，您可以在列表中执行各种操作，例如插入、删除和遍历元素，而无需关心内部细节。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <list>标准库 详解</h2><p><code>&lt;list&gt;</code> 是 C++ 标准库中的头文件，定义了双向链表的模板类 <code>std::list</code>。双向链表是一种动态数据结构，允许在两端进行常量时间内的插入和删除操作。</p>
<h3 id="std-list-概述：-1"><a href="#std-list-概述：-1" class="headerlink" title="std::list 概述："></a>std::list 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;list&gt;</code></li>
<li><strong>容器类型：</strong> <code>std::list</code> 是标准库中的容器类型之一，实现了双向链表。</li>
<li><strong>特点：</strong><ul>
<li>元素按插入顺序存储。</li>
<li>支持高效的插入和删除操作，但对于随机访问效率较低。</li>
<li>提供了迭代器支持，允许对链表中的元素进行顺序访问和操作。</li>
</ul>
</li>
</ul>
<h3 id="主要操作和用法：-1"><a href="#主要操作和用法：-1" class="headerlink" title="主要操作和用法："></a>主要操作和用法：</h3><ul>
<li><strong>插入和删除操作：</strong><ul>
<li><code>push_back()</code>, <code>push_front()</code>, <code>pop_back()</code>, <code>pop_front()</code> 用于在列表两端插入或删除元素。</li>
</ul>
</li>
<li><strong>迭代器操作：</strong><ul>
<li>使用迭代器进行元素访问、遍历和操作。</li>
</ul>
</li>
<li><strong>大小操作：</strong><ul>
<li><code>size()</code>, <code>empty()</code> 获取列表的大小和判断是否为空。</li>
</ul>
</li>
<li><strong>插入、删除和移动元素：</strong><ul>
<li><code>insert()</code>, <code>erase()</code>, <code>splice()</code> 等用于在指定位置插入、删除、合并列表等操作。</li>
</ul>
</li>
<li><strong>搜索和修改操作：</strong><ul>
<li><code>find()</code>, <code>remove()</code>, <code>reverse()</code>, <code>sort()</code> 等用于搜索、移除、反转和排序列表中的元素。</li>
</ul>
</li>
</ul>
<h3 id="详细示例："><a href="#详细示例：" class="headerlink" title="详细示例："></a>详细示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第一个元素</span></span><br><span class="line">    myList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">next</span>(myList.<span class="built_in">begin</span>()); <span class="comment">// 获取迭代器</span></span><br><span class="line">    myList.<span class="built_in">insert</span>(it, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定元素</span></span><br><span class="line">    myList.<span class="built_in">remove</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出剩余元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::list</code> 是一个有用的容器，适合在需要频繁插入和删除元素而不需要进行随机访问的场景下使用。通过使用迭代器，您可以在列表中执行各种操作，例如插入、删除和遍历元素，而无需关心内部细节。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <list>标准库 常用的类和函数</h2><p>在C++标准库的<code>&lt;list&gt;</code>头文件中，提供了一些常用的类和函数，主要用于操作双向链表 <code>std::list</code>。</p>
<h3 id="常用的类："><a href="#常用的类：" class="headerlink" title="常用的类："></a>常用的类：</h3><ul>
<li><strong><code>std::list</code>：</strong> 双向链表的模板类，允许在常量时间内在两端进行插入、删除操作。</li>
</ul>
<h3 id="常用的函数和操作："><a href="#常用的函数和操作：" class="headerlink" title="常用的函数和操作："></a>常用的函数和操作：</h3><ul>
<li><strong>插入和删除操作：</strong><ul>
<li><code>push_back()</code>, <code>push_front()</code>: 在链表的尾部或头部插入元素。</li>
<li><code>pop_back()</code>, <code>pop_front()</code>: 从链表的尾部或头部删除元素。</li>
</ul>
</li>
<li><strong>访问元素和迭代器操作：</strong><ul>
<li><code>begin()</code>, <code>end()</code>: 返回指向链表起始和结束的迭代器。</li>
<li><code>front()</code>, <code>back()</code>: 返回链表头部和尾部的元素。</li>
<li><code>insert()</code>, <code>erase()</code>: 在指定位置插入或删除元素。</li>
<li><code>clear()</code>: 清空链表中的所有元素。</li>
</ul>
</li>
<li><strong>大小操作：</strong><ul>
<li><code>size()</code>: 返回链表中元素的数量。</li>
<li><code>empty()</code>: 判断链表是否为空。</li>
</ul>
</li>
<li><strong>其他操作：</strong><ul>
<li><code>remove()</code>: 移除链表中所有与给定值相等的元素。</li>
<li><code>sort()</code>: 对链表中的元素进行排序。</li>
<li><code>merge()</code>: 合并两个已排序的链表。</li>
<li><code>splice()</code>: 将另一个链表的元素移动到当前链表的指定位置。</li>
</ul>
</li>
</ul>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">pop_front</span>();</span><br><span class="line">    myList.<span class="built_in">insert</span>(++myList.<span class="built_in">begin</span>(), <span class="number">4</span>);</span><br><span class="line">    myList.<span class="built_in">remove</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;list&gt;</code> 提供了一系列方法来操作双向链表，这些方法包括在链表头尾插入或删除元素、访问元素、迭代器操作、大小操作、移除指定元素等。通过这些函数，可以方便地对链表进行操作和管理。</p>
<h2 id="std-list-remove"><a href="#std-list-remove" class="headerlink" title="std::list::remove()"></a>std::list::remove()</h2><p><code>std::list::remove()</code> 是 <code>std::list</code> 类提供的成员函数之一，用于移除链表中所有与指定值相等的元素。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span> <span class="params">(<span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>val</code>：要从链表中移除的值。</li>
</ul>
<h3 id="函数作用："><a href="#函数作用：" class="headerlink" title="函数作用："></a>函数作用：</h3><ul>
<li><code>remove()</code> 会在链表中查找与指定值相等的元素，并将它们全部移除。</li>
</ul>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>此函数会一次性移除链表中所有与指定值相等的元素。</li>
<li>移除过程中不会改变链表中元素的相对顺序。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">remove</span>(<span class="number">2</span>); <span class="comment">// 移除所有值为 2 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myList.remove(2)</code> 将移除链表中所有值为 <code>2</code> 的元素。最终输出的链表内容将不包含值为 <code>2</code> 的元素。</p>
<h2 id="std-list-sort"><a href="#std-list-sort" class="headerlink" title="std::list::sort()"></a>std::list::sort()</h2><p><code>std::list::sort()</code> 是 <code>std::list</code> 类提供的成员函数之一，用于对链表中的元素进行排序操作。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数作用：-1"><a href="#函数作用：-1" class="headerlink" title="函数作用："></a>函数作用：</h3><ul>
<li><code>sort()</code> 函数将链表中的元素按升序进行排序。如果链表包含自定义类型的元素，则需要保证该类型支持比较操作符（<code>&lt;</code>）。</li>
</ul>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>由于 <code>std::list</code> 是双向链表，而非连续存储的序列，它采用的排序算法可能与 <code>std::sort</code>（用于连续序列的排序）使用的算法不同。</li>
<li>对于具有较大规模的数据集，<code>std::list::sort()</code> 可能会比 <code>std::sort</code> 慢，因为它的排序复杂度取决于链表的大小，而不是像 <code>std::sort</code> 那样可以使用更高效的排序算法。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">sort</span>(); <span class="comment">// 对链表元素进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myList.sort()</code> 对链表中的整数元素进行升序排序。最终输出的链表内容将按照升序排列。</p>
<h2 id="std-list-merge"><a href="#std-list-merge" class="headerlink" title="std::list::merge()"></a>std::list::merge()</h2><p><code>std::list::merge()</code> 是 <code>std::list</code> 类提供的成员函数之一，用于将两个已排序的链表合并成一个排序链表。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span> <span class="params">(std::list&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>x</code>：另一个已排序链表，将其合并到调用函数的链表中。</li>
</ul>
<h3 id="函数作用：-2"><a href="#函数作用：-2" class="headerlink" title="函数作用："></a>函数作用：</h3><ul>
<li><code>merge()</code> 函数将调用它的链表与参数中的链表 <code>x</code> 合并成一个排序链表。</li>
<li>合并完成后，调用函数的链表将包含原链表和参数链表的所有元素，并按升序排序。</li>
</ul>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>需要保证两个链表都已经按升序排序。</li>
<li>合并完成后，参数链表 <code>x</code> 将为空，并且被合并到调用函数的链表中。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList1 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList2 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myList<span class="number">1.</span><span class="built_in">merge</span>(myList2); <span class="comment">// 将 myList2 合并到 myList1 中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList1) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myList2 size: &quot;</span> &lt;&lt; myList<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myList1.merge(myList2)</code> 将 <code>myList2</code> 合并到 <code>myList1</code> 中。最终输出的 <code>myList1</code> 将包含合并后的所有元素，并且按升序排序。<code>myList2</code> 在合并后将为空。</p>
<h2 id="std-list-splice"><a href="#std-list-splice" class="headerlink" title="std::list::splice()"></a>std::list::splice()</h2><p><code>std::list::splice()</code> 是 <code>std::list</code> 类提供的成员函数之一，用于在两个 <code>std::list</code> 之间移动或合并元素。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator pos, std::list&amp; other)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator pos, std::list&amp; other, iterator it)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator pos, std::list&amp; other, iterator first, iterator last)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pos</code>：指定插入位置的迭代器。</li>
<li><code>other</code>：另一个 <code>std::list</code>。</li>
<li><code>it</code>：另一个 <code>std::list</code> 的迭代器。</li>
<li><code>first</code>, <code>last</code>：另一个 <code>std::list</code> 中指定范围的迭代器。</li>
</ul>
<h3 id="函数作用：-3"><a href="#函数作用：-3" class="headerlink" title="函数作用："></a>函数作用：</h3><ul>
<li>第一个函数将整个 <code>other</code> 链表的元素移动到调用函数的链表中的 <code>pos</code> 位置。</li>
<li>第二个函数将 <code>other</code> 链表中迭代器 <code>it</code> 所指向的元素移动到调用函数的链表中的 <code>pos</code> 位置。</li>
<li>第三个函数将 <code>other</code> 链表中位于 <code>[first, last)</code> 范围内的元素移动到调用函数的链表中的 <code>pos</code> 位置。</li>
</ul>
<h3 id="注意事项：-3"><a href="#注意事项：-3" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>被移动的元素会从 <code>other</code> 链表中删除，并插入到调用函数的链表中指定的位置。</li>
<li>被移动的元素保持它们的相对顺序。</li>
<li>被合并的链表中元素的顺序在移动后将改变。</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = ++myList<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">    myList<span class="number">1.</span><span class="built_in">splice</span>(myList<span class="number">1.</span><span class="built_in">begin</span>(), myList2); <span class="comment">// 将 myList2 整个链表合并到 myList1 的开头</span></span><br><span class="line">    myList<span class="number">1.</span><span class="built_in">splice</span>(myList<span class="number">1.</span><span class="built_in">end</span>(), myList2, it); <span class="comment">// 将 myList2 中的第二个元素插入到 myList1 的末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList1) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList2) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myList1.splice(myList1.begin(), myList2)</code> 将整个 <code>myList2</code> 链表合并到 <code>myList1</code> 的开头，然后 <code>myList1.splice(myList1.end(), myList2, it)</code> 将 <code>myList2</code> 中的第二个元素（通过迭代器 <code>it</code> 定位）插入到 <code>myList1</code> 的末尾。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_27_span/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_27_span/" class="post-title-link" itemprop="url">C++_10_27_span</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <span>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <span>标准库</h2><p>在 C++ 标准库中并没有名为 <code>&lt;span&gt;</code> 的标准头文件或容器。<code>&lt;span&gt;</code> 并不是 C++ 标准库的一部分，而是从 C++20 开始引入的用于表示连续内存区域的非拥有式引用的类模板。其主要用途是对连续内存块进行引用和操作，而不拥有这些内存。</p>
<p><code>&lt;span&gt;</code>通常用于在不拥有内存的情况下表示数据的连续区间，类似于指针和长度的组合。它提供了对这个区间的安全访问，例如遍历、查找等操作，但并不负责内存的生命周期。</p>
<p>C++ 标准库中提供了 <code>std::span</code> 类来实现这个概念，它在 <code>&lt;span&gt;</code> 头文件中定义。</p>
<p>以下是一个简单的示例演示 <code>std::span</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::span&lt;<span class="type">int</span>&gt; <span class="title">mySpan</span><span class="params">(arr, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySpan) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>std::span</code> 被用来引用数组 <code>arr</code> 中的元素。<code>std::span</code> 对这段连续的内存区域提供了一种非拥有式的引用，允许你对这个区间进行安全的遍历和访问操作，但不管理这段内存的生命周期。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_29_stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_29_stack/" class="post-title-link" itemprop="url">C++_10_29_stack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <stack>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <stack>标准库</h2><p><code>&lt;stack&gt;</code> 是 C++ 标准库中的头文件，定义了栈容器适配器 <code>std::stack</code>。</p>
<h3 id="std-stack："><a href="#std-stack：" class="headerlink" title="std::stack："></a>std::stack：</h3><ul>
<li><code>std::stack</code> 是一个基于其他容器（默认使用 <code>std::deque</code>）的封装，提供了栈（LIFO，后进先出）的功能。</li>
<li>栈是一种具有特定限制的容器，只允许在栈顶进行插入和删除操作。</li>
<li>主要特点：<ul>
<li><code>push(const T&amp; val)</code>: 将元素 <code>val</code> 压入栈顶。</li>
<li><code>pop()</code>: 弹出栈顶元素。</li>
<li><code>top()</code>: 返回栈顶元素的引用。</li>
<li><code>empty()</code>: 判断栈是否为空。</li>
<li><code>size()</code>: 返回栈中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; myStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入元素</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of stack: &quot;</span> &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">    myStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出栈中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例展示了 <code>std::stack</code> 的基本使用方法，包括压入元素、访问栈顶元素、弹出栈顶元素，并且遍历输出了栈中的元素。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库  详解"></a>C++ <stack>标准库  详解</h2><p><code>&lt;stack&gt;</code> 是 C++ 标准库中的头文件，定义了栈容器适配器 <code>std::stack</code>，它提供了栈（LIFO，后进先出）数据结构的功能。</p>
<h3 id="std-stack：-1"><a href="#std-stack：-1" class="headerlink" title="std::stack："></a>std::stack：</h3><ul>
<li><code>std::stack</code> 是一个封装了其他容器（默认使用 <code>std::deque</code>）的适配器，实现了栈的功能。</li>
<li>栈是一种限制性的数据结构，只允许在栈顶进行插入（push）和删除（pop）操作。</li>
<li>主要特点：<ul>
<li><code>push(const T&amp; val)</code>: 将元素 <code>val</code> 压入栈顶。</li>
<li><code>pop()</code>: 弹出栈顶元素。</li>
<li><code>top()</code>: 返回栈顶元素的引用。</li>
<li><code>empty()</code>: 判断栈是否为空。</li>
<li><code>size()</code>: 返回栈中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; myStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入元素</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of stack: &quot;</span> &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">    myStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出栈中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，展示了 <code>std::stack</code> 的基本用法，包括压入元素、访问栈顶元素、弹出栈顶元素，并且遍历输出了栈中的元素。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <stack>标准库 常用的类和函数</h2><p>在 C++ <code>&lt;stack&gt;</code> 标准库中，主要的类是 <code>std::stack</code>，而该类主要包含以下常用函数和方法：</p>
<h3 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h3><ol>
<li><strong>std::stack</strong>：<ul>
<li>栈容器适配器类，基于其他容器（默认使用 <code>std::deque</code>）封装而成。</li>
<li>主要特点：<ul>
<li><code>push(const T&amp; val)</code>: 将元素 <code>val</code> 压入栈顶。</li>
<li><code>pop()</code>: 弹出栈顶元素。</li>
<li><code>top()</code>: 返回栈顶元素的引用。</li>
<li><code>empty()</code>: 判断栈是否为空。</li>
<li><code>size()</code>: 返回栈中元素的数量。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="常用函数和方法："><a href="#常用函数和方法：" class="headerlink" title="常用函数和方法："></a>常用函数和方法：</h3><ul>
<li><code>push(const T&amp; val)</code>: 将元素 <code>val</code> 压入栈顶。</li>
<li><code>pop()</code>: 弹出栈顶元素。</li>
<li><code>top()</code>: 返回栈顶元素的引用。</li>
<li><code>empty()</code>: 判断栈是否为空。</li>
<li><code>size()</code>: 返回栈中元素的数量。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; myStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入元素</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of stack: &quot;</span> &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">    myStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出栈中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::stack</code> 的基本使用方法，包括压入元素、访问栈顶元素、弹出栈顶元素，并且遍历输出了栈中的元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_28_queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_28_queue/" class="post-title-link" itemprop="url">C++_10_28_queue</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <queue>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <queue>标准库</h2><p><code>&lt;queue&gt;</code> 是 C++ 标准库中的头文件，定义了队列容器适配器 <code>std::queue</code>、优先队列 <code>std::priority_queue</code>，以及辅助队列的基本操作。</p>
<h3 id="std-queue："><a href="#std-queue：" class="headerlink" title="std::queue："></a>std::queue：</h3><ul>
<li><code>std::queue</code> 是一个基于队列的容器适配器，底层使用其他容器（默认使用 <code>std::deque</code>）实现。</li>
<li>队列是一种先进先出（FIFO）的数据结构，允许在队列的末尾（back）插入元素，从队列的前端（front）删除元素。</li>
<li>主要操作：<ul>
<li><code>push()</code>: 在队尾插入元素。</li>
<li><code>pop()</code>: 从队首删除元素。</li>
<li><code>front()</code>: 访问队首元素。</li>
<li><code>back()</code>: 访问队尾元素。</li>
<li><code>empty()</code>: 判断队列是否为空。</li>
<li><code>size()</code>: 获取队列中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="std-priority-queue："><a href="#std-priority-queue：" class="headerlink" title="std::priority_queue："></a>std::priority_queue：</h3><ul>
<li><code>std::priority_queue</code> 是一个基于堆的优先队列容器适配器，底层使用堆来管理元素。</li>
<li>优先队列是一种特殊的队列，它保证了每次弹出元素时都是优先级最高（根据默认的比较器或自定义的比较器）的元素。</li>
<li>主要操作：<ul>
<li><code>push()</code>: 插入元素。</li>
<li><code>pop()</code>: 弹出优先级最高的元素。</li>
<li><code>top()</code>: 访问优先级最高的元素。</li>
<li><code>empty()</code>: 判断优先队列是否为空。</li>
<li><code>size()</code>: 获取优先队列中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::queue</span></span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; myQueue;</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问队首元素</span></span><br><span class="line">        myQueue.<span class="built_in">pop</span>(); <span class="comment">// 弹出队首元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::priority_queue</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; myPriorityQueue;</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myPriorityQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myPriorityQueue.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问优先级最高的元素</span></span><br><span class="line">        myPriorityQueue.<span class="built_in">pop</span>(); <span class="comment">// 弹出优先级最高的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>std::queue</code> 和 <code>std::priority_queue</code>。<code>std::queue</code> 用于创建基本的先进先出队列，而 <code>std::priority_queue</code> 则创建一个基于堆的优先队列。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <queue>标准库 详解</h2><p><code>&lt;queue&gt;</code> 是 C++ 标准库中的头文件，提供了队列容器适配器 <code>std::queue</code> 和优先队列容器适配器 <code>std::priority_queue</code>。</p>
<h3 id="std-queue：-1"><a href="#std-queue：-1" class="headerlink" title="std::queue："></a>std::queue：</h3><ul>
<li><code>std::queue</code> 是一个基于队列的容器适配器，用于实现先进先出（FIFO）的数据结构。</li>
<li>默认使用 <code>std::deque</code> 作为其底层容器，但也可以使用其他支持 <code>front()</code>, <code>back()</code>, <code>push_back()</code>, <code>pop_front()</code> 操作的容器。</li>
<li>主要特点：<ul>
<li><code>push()</code>: 在队列的末尾插入元素。</li>
<li><code>pop()</code>: 从队列的开头删除元素。</li>
<li><code>front()</code>: 访问队列的第一个元素。</li>
<li><code>back()</code>: 访问队列的最后一个元素。</li>
<li><code>empty()</code>: 判断队列是否为空。</li>
<li><code>size()</code>: 返回队列中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="std-priority-queue：-1"><a href="#std-priority-queue：-1" class="headerlink" title="std::priority_queue："></a>std::priority_queue：</h3><ul>
<li><code>std::priority_queue</code> 是基于堆的优先队列容器适配器。</li>
<li>它与普通的队列不同，其中的元素按照特定的比较器（默认为 <code>std::less</code>）以堆排序的方式进行管理。</li>
<li>主要特点：<ul>
<li><code>push()</code>: 插入元素。</li>
<li><code>pop()</code>: 弹出优先级最高的元素。</li>
<li><code>top()</code>: 访问优先级最高的元素。</li>
<li><code>empty()</code>: 判断优先队列是否为空。</li>
<li><code>size()</code>: 返回优先队列中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::queue</span></span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; myQueue;</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front of queue: &quot;</span> &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; std::endl; <span class="comment">// 访问队首元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back of queue: &quot;</span> &lt;&lt; myQueue.<span class="built_in">back</span>() &lt;&lt; std::endl; <span class="comment">// 访问队尾元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问队首元素</span></span><br><span class="line">        myQueue.<span class="built_in">pop</span>(); <span class="comment">// 弹出队首元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::priority_queue</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; myPriorityQueue;</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myPriorityQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myPriorityQueue.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问优先级最高的元素</span></span><br><span class="line">        myPriorityQueue.<span class="built_in">pop</span>(); <span class="comment">// 弹出优先级最高的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用 <code>std::queue</code> 和 <code>std::priority_queue</code> 进行基本操作。<code>std::queue</code> 用于创建基本的先进先出队列，而 <code>std::priority_queue</code> 用于创建一个基于堆的优先队列。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <queue>标准库 常用的类和函数</h2><p>在 <code>&lt;queue&gt;</code> 标准库中，常用的类包括 <code>std::queue</code> 和 <code>std::priority_queue</code>，以及与这两个类相关的函数。</p>
<h3 id="常用类："><a href="#常用类：" class="headerlink" title="常用类："></a>常用类：</h3><ol>
<li><p><strong>std::queue</strong>：</p>
<ul>
<li>定义：基于队列的容器适配器，实现了先进先出（FIFO）的数据结构。</li>
<li>主要操作：<ul>
<li><code>push()</code>: 在队尾插入元素。</li>
<li><code>pop()</code>: 从队首删除元素。</li>
<li><code>front()</code>: 访问队首元素。</li>
<li><code>back()</code>: 访问队尾元素。</li>
<li><code>empty()</code>: 判断队列是否为空。</li>
<li><code>size()</code>: 返回队列中元素的数量。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>std::priority_queue</strong>：</p>
<ul>
<li>定义：基于堆的优先队列容器适配器，元素以堆排序方式管理。</li>
<li>主要操作：<ul>
<li><code>push()</code>: 插入元素。</li>
<li><code>pop()</code>: 弹出优先级最高的元素。</li>
<li><code>top()</code>: 访问优先级最高的元素。</li>
<li><code>empty()</code>: 判断优先队列是否为空。</li>
<li><code>size()</code>: 返回优先队列中元素的数量。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ul>
<li>除了类自身的成员函数外，<code>&lt;queue&gt;</code> 还提供了一些与队列和优先队列相关的方法。主要是 <code>std::make_heap</code>、<code>std::push_heap</code>、<code>std::pop_heap</code> 和 <code>std::sort_heap</code>，这些函数用于堆操作，可以用于处理堆数据结构。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::queue</span></span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; myQueue;</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front of queue: &quot;</span> &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back of queue: &quot;</span> &lt;&lt; myQueue.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myQueue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::priority_queue</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; myPriorityQueue;</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myPriorityQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myPriorityQueue.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myPriorityQueue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例演示了 <code>std::queue</code> 和 <code>std::priority_queue</code> 的基本使用方法，以及它们的一些常用操作。</p>
<h2 id="std-queue"><a href="#std-queue" class="headerlink" title="std::queue"></a>std::queue</h2><p><code>std::queue</code> 是 C++ 标准库中定义的队列容器适配器，通常基于其他容器（默认使用 <code>std::deque</code>）来实现队列的功能。</p>
<h3 id="主要特点和操作："><a href="#主要特点和操作：" class="headerlink" title="主要特点和操作："></a>主要特点和操作：</h3><ul>
<li><strong>特点：</strong><ul>
<li>实现了先进先出（FIFO）的数据结构。</li>
<li>提供了简单的接口，对底层容器进行了封装，使其行为像一个队列。</li>
</ul>
</li>
<li><strong>主要操作：</strong><ul>
<li><code>push(const T&amp; val)</code>: 将元素 <code>val</code> 插入队尾。</li>
<li><code>pop()</code>: 移除队首元素。</li>
<li><code>front()</code>: 返回队首元素的引用。</li>
<li><code>back()</code>: 返回队尾元素的引用。</li>
<li><code>empty()</code>: 判断队列是否为空。</li>
<li><code>size()</code>: 返回队列中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; myQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问队首和队尾元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front of queue: &quot;</span> &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back of queue: &quot;</span> &lt;&lt; myQueue.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除队首元素</span></span><br><span class="line">    myQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出队列中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myQueue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，展示了 <code>std::queue</code> 的基本用法，包括插入元素、访问队首和队尾元素、移除队首元素，并且遍历输出了队列中的元素。</p>
<h2 id="std-priority-queue"><a href="#std-priority-queue" class="headerlink" title="std::priority_queue"></a>std::priority_queue</h2><p><code>std::priority_queue</code> 是 C++ 标准库中定义的优先队列容器适配器，基于堆的数据结构实现。</p>
<h3 id="主要特点和操作：-1"><a href="#主要特点和操作：-1" class="headerlink" title="主要特点和操作："></a>主要特点和操作：</h3><ul>
<li><strong>特点：</strong><ul>
<li>实现了优先队列的功能，元素按照特定的比较器（默认为 <code>std::less</code>，通常为大顶堆）以堆排序方式管理。</li>
<li>元素的弹出和插入操作具有特定的优先级，最高优先级元素始终处于队列的顶部。</li>
</ul>
</li>
<li><strong>主要操作：</strong><ul>
<li><code>push(const T&amp; val)</code>: 插入元素 <code>val</code> 到优先队列中。</li>
<li><code>pop()</code>: 移除优先级最高的元素。</li>
<li><code>top()</code>: 返回优先级最高的元素的引用。</li>
<li><code>empty()</code>: 判断优先队列是否为空。</li>
<li><code>size()</code>: 返回优先队列中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; myPriorityQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问优先级最高的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of priority queue: &quot;</span> &lt;&lt; myPriorityQueue.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除优先级最高的元素</span></span><br><span class="line">    myPriorityQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出优先队列中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!myPriorityQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myPriorityQueue.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myPriorityQueue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例展示了 <code>std::priority_queue</code> 的基本用法，包括插入元素、访问优先级最高的元素、移除优先级最高的元素，并且遍历输出了优先队列中的元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_2_algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_2_algorithm/" class="post-title-link" itemprop="url">C++_10_2_algorithm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><algorithm>标准库学习笔记</li>
</ul>
<h2 id="algorithm-中所有算法"><a href="#algorithm-中所有算法" class="headerlink" title="algorithm 中所有算法"></a>algorithm 中所有算法</h2><ul>
<li>名称                    描述</li>
<li>adjacent_find	            搜索相等或满足指定条件的两个相邻元素。</li>
<li>all_of	                当给定范围中的每个元素均满足条件时返回 true。</li>
<li>any_of	                当指定元素范围中至少有一个元素满足条件时返回 true。</li>
<li>binary_search	            测试已排序的范围中是否有等于指定值的元素，或在二元谓词指定的意义上与指定值等效的元素。</li>
<li>clamp	    </li>
<li>copy	                    将一个源范围中的元素值分配到目标范围，循环访问元素的源序列并将它们分配在一个向前方向的新位置。</li>
<li>copy_backward	            将一个源范围中的元素值分配到目标范围，循环访问元素的源序列并将它们分配在一个向后方向的新位置。</li>
<li>copy_if	                复制给定范围中对于指定条件为 true 的所有元素。</li>
<li>copy_n	                复制指定数量的元素。</li>
<li>count	                    返回范围中其值与指定值匹配的元素的数量。</li>
<li>count_if	                返回范围中其值与指定条件匹配的元素的数量。</li>
<li>equal	                    逐个元素比较两个范围是否相等或是否在二元谓词指定的意义上等效。</li>
<li>equal_range	            在排序的范围中查找符合以下条件的位置对：第一个位置小于或等效于指定元素的位置，第二个位置大于此元素位置，等效意义或用于在序列中建立位置的排序可通过二元谓词指定。</li>
<li>fill	                    将相同的新值分配给指定范围中的每个元素。</li>
<li>fill_n	                将新值分配给以特定元素开始的范围中的指定数量的元素。</li>
<li>find	                    在范围中找到具有指定值的元素的第一个匹配项位置。</li>
<li>find_end	                在范围中查找与指定序列相同的最后一个序列，或在二元谓词指定的意义上等效的最后一个序列。</li>
<li>find_first_of	            在目标范围中搜索若干值中任意值的第一个匹配项，或搜索在二元谓词指定的意义上等效于指定元素集的若干元素中任意元素的第一个匹配项。</li>
<li>find_if	                在范围中找到满足指定条件的元素的第一个匹配项位置。</li>
<li>find_if_not	            返回指示的范围中不满足条件的第一个元素。</li>
<li>for_each	                将指定的函数对象按向前顺序应用于范围中的每个元素并返回此函数对象。</li>
<li>for_each_n	    </li>
<li>generate	                将函数对象生成的值分配给范围中的每个元素。</li>
<li>generate_n	            将函数对象生成的值分配给范围中指定数量的元素，并返回到超出最后一个分配值的下一位置。</li>
<li>includes	                测试一个排序的范围是否包含另一排序范围中的所有元素，其中元素之间的排序或等效条件可通过二元谓词指定。</li>
<li>inplace_merge	            将两个连续的排序范围中的元素合并为一个排序范围，其中排序条件可通过二元谓词指定。</li>
<li>is_heap	                如果指定范围中的元素形成堆，则返回 true。</li>
<li>is_heap_until	            如果指定范围形成直到最后一个元素的堆，则返回 true。</li>
<li>is_partitioned	        如果给定范围中对某个条件测试为 true 的所有元素在测试为 true 的所有元素之前，则返回 false。</li>
<li>is_permutation	        确定给定范围的元素是否形成有效排列。</li>
<li>is_sorted	                如果指定范围中的元素按顺序排序，则返回 true。</li>
<li>is_sorted_until	        如果指定范围中的元素按顺序排序，则返回 true。</li>
<li>iter_swap	                交换由一对指定迭代器引用的两个值。</li>
<li>lexicographical_compare	逐个元素比较两个序列以确定其中的较小序列。</li>
<li>lower_bound	            在排序的范围中查找其值大于或等效于指定值的第一个元素的位置，其中排序条件可通过二元谓词指定。</li>
<li>make_heap	                将指定范围中的元素转换到第一个元素是最大元素的堆中，其中排序条件可通过二元谓词指定。</li>
<li>max	                    比较两个对象并返回较大对象，其中排序条件可通过二元谓词指定。</li>
<li>max_element	            在指定范围中查找最大元素的第一个匹配项，其中排序条件可通过二元谓词指定。</li>
<li>merge	                    将两个排序的源范围中的所有元素合并为一个排序的目标范围，其中排序条件可通过二元谓词指定。</li>
<li>min	                    比较两个对象并返回较小对象，其中排序条件可通过二元谓词指定。</li>
<li>min_element	            在指定范围中查找最小元素的第一个匹配项，其中排序条件可通过二元谓词指定。</li>
<li>minmax	                比较两个输入参数，并按最小到最大的顺序将它们作为参数对返回。</li>
<li>minmax_element	        在一次调用中执行由 min_element 和 max_element 执行的操作。</li>
<li>mismatch	                逐个元素比较两个范围是否相等或是否在二元谓词指定的意义上等效，并找到出现不同的第一个位置。</li>
<li><alg> move	            移动与指定范围关联的元素。</li>
<li>move_backward	            将一个迭代器的元素移动到另一迭代器。 移动从指定范围的最后一个元素开始，并在此范围的第一个元素结束。</li>
<li>next_permutation	        重新排序范围中的元素，以便使用按字典顺序的下一个更大排列（如果有）替换原有排序，其中“下一个”的意义可通过二元谓词指定。</li>
<li>none_of	                当给定范围中没有元素满足条件时返回 true。</li>
<li>nth_element	            对范围内的元素分区，正确找到范围中序列的第 n 个元素，以使序列中位于此元素之前的所有元素小于或等于此元素，位于此元素之后的所有元素大于或等于此元素。</li>
<li>partial_sort	            将范围中指定数量的较小元素按非降序顺序排列，或根据二元谓词指定的排序条件排列。</li>
<li>partial_sort_copy	        将源范围中的元素复制到目标范围，其中源元素按降序或二元谓词指定的其他顺序排序。</li>
<li>partition	                将范围中的元素分为两个不相交的集，满足一元谓词的元素在不满足一元谓词的元素之前。</li>
<li>partition_copy	        将条件为 true 的元素复制到一个目标，将条件为 false 的元素复制到另一目标。 元素必须来自于指定范围。</li>
<li>partition_point	        返回给定范围中不满足条件的第一个元素。 元素经过排序，满足条件的元素在不满足条件的元素之前。</li>
<li>pop_heap	                移除从堆顶到范围中倒数第二个位置之间的最大元素，然后将剩余元素形成新堆。</li>
<li>prev_permutation	        重新排序范围中的元素，以便使用按字典顺序的下一个更大排列（如果有）替换原有排序，其中“下一个”的意义可通过二元谓词指定。</li>
<li>push_heap	                将范围末尾的元素添加到包括范围中前面元素的现有堆中。</li>
<li>random_shuffle	        将范围中 N 个元素的序列重新排序为随机 N! 种序列中的 可能排列之一。</li>
<li>remove	                从给定范围中消除指定值，而不影响剩余元素的顺序，并返回不包含指定值的新范围的末尾。</li>
<li>remove_copy	            将源范围中的元素复制到目标范围（不复制具有指定值的元素），而不影响剩余元素的顺序，并返回新目标范围的末尾。</li>
<li>remove_copy_if	        将源范围中的元素复制到目标范围（不复制满足谓词的元素），而不影响剩余元素的顺序，并返回新目标范围的末尾。</li>
<li>remove_if	                从给定范围中消除满足谓词的元素，而不影响剩余元素的顺序，并返回不包含指定值的新范围的末尾。</li>
<li>replace	                检查范围中的每个元素，并替换与指定值匹配的元素。</li>
<li>replace_copy	            检查源范围中的每个元素，并替换与指定值匹配的元素，同时将结果复制到新的目标范围。</li>
<li>replace_copy_if	        检查源范围中的每个元素，并替换满足指定谓词的元素，同时将结果复制到新的目标范围。</li>
<li>replace_if	            检查范围中的每个元素，并替换满足指定谓词的元素。</li>
<li>reverse	                反转范围中元素的顺序。</li>
<li>reverse_copy	            反转源范围中元素的顺序，同时将这些元素复制到目标范围</li>
<li>rotate	                交换两个相邻范围中的元素。</li>
<li>rotate_copy	            交换源范围中两个相邻范围内的元素，并将结果复制到目标范围。</li>
<li>sample	</li>
<li>search	                在目标范围中搜索其元素与给定序列中的元素相等或在二元谓词指定的意义上等效于给定序列中的元素的序列的第一个匹配项。</li>
<li>search_n	                在范围中搜索具有特定值或按二元谓词的指定与此值相关的指定数量的元素。</li>
<li>set_difference	        将属于一个排序的源范围、但不属于另一排序的源范围的所有元素相并到一个排序的目标范围，其中排序条件可通过二元谓词指定。</li>
<li>set_intersection	        将属于两个排序的源范围的所有元素相并为一个排序的目标范围，其中排序条件可通过二元谓词指定。</li>
<li>set_symmetric_difference	将属于一个而不是两个排序的源范围的所有元素相并为一个排序的目标范围，其中排序条件可通过二元谓词指定。</li>
<li>set_union	                将至少属于两个排序的源范围之一的所有元素相并为一个排序的目标范围，其中排序条件可通过二元谓词指定。</li>
<li>sort	                    将指定范围中的元素按非降序顺序排列，或根据二元谓词指定的排序条件排列。</li>
<li>shuffle	                使用随机数生成器重新排列给定范围中的元素。</li>
<li>sort_heap	                将堆转换为排序的范围。</li>
<li>stable_partition	        将范围中的元素分为两个不相交的集，满足一元谓词的元素在不满足一元谓词的元素之前，并保留等效元素的相对顺序。</li>
<li>stable_sort	            将指定范围中的元素按非降序顺序排列，或根据二元谓词指定的排序条件排列，并保留等效元素的相对顺序。</li>
<li>swap	                    在两种类型的对象之间交换元素值，将第一个对象的内容分配给第二个对象，将第二个对象的内容分配给第一个对象。</li>
<li>swap_ranges	            将一个范围中的元素与另一大小相等的范围中的元素交换。</li>
<li>transform	                将指定的函数对象应用于源范围中的每个元素或两个源范围中的元素对，并将函数对象的返回值复制到目标范围。</li>
<li>unique	                移除指定范围中彼此相邻的重复元素。</li>
<li>unique_copy	            将源范围中的元素复制到目标范围，彼此相邻的重复元素除外。</li>
<li>upper_bound	            在排序的范围中查找其值大于指定值的第一个元素的位置，其中排序条件可通过二元谓词指定。</li>
</ul>
<h2 id="C-是什么"><a href="#C-是什么" class="headerlink" title="C++ 是什么"></a>C++ <algorithm>是什么</h2><p><code>&lt;algorithm&gt;</code> 是 C++ 标准库中提供了一系列泛型算法的头文件。这些算法可以用于对数据结构（如数组、容器、迭代器等）执行各种操作，包括搜索、排序、合并、变换等。</p>
<p>这个头文件包含了许多标准的算法，这些算法都是泛型的，意味着它们不仅适用于特定类型的数据，而且可以用于不同的数据类型。这些算法可以直接用于标准容器（如 vector、list、deque 等）中，也可以用于普通数组、迭代器等容器类型。</p>
<p>以下是 <code>&lt;algorithm&gt;</code> 头文件中一些常用的算法：</p>
<ol>
<li><p><strong>排序算法</strong>：如 <code>std::sort</code>、<code>std::stable_sort</code>、<code>std::partial_sort</code>、<code>std::nth_element</code> 等，用于对元素序列进行排序。</p>
</li>
<li><p><strong>搜索算法</strong>：例如 <code>std::find</code>、<code>std::binary_search</code>、<code>std::lower_bound</code>、<code>std::upper_bound</code> 等，用于在序列中查找元素。</p>
</li>
<li><p><strong>数值算法</strong>：如 <code>std::accumulate</code>、<code>std::count</code>、<code>std::min</code>、<code>std::max</code>、<code>std::accumulate</code> 等，用于对数值序列执行操作。</p>
</li>
<li><p><strong>集合算法</strong>：包括 <code>std::merge</code>、<code>std::set_intersection</code>、<code>std::set_union</code>、<code>std::set_difference</code> 等，用于对集合执行操作。</p>
</li>
<li><p><strong>变换算法</strong>：例如 <code>std::transform</code>、<code>std::copy</code>、<code>std::reverse</code>、<code>std::rotate</code> 等，用于对序列执行变换。</p>
</li>
<li><p><strong>比较和交换算法</strong>：如 <code>std::swap</code>、<code>std::swap_ranges</code>、<code>std::equal</code>、<code>std::lexicographical_compare</code> 等，用于比较和交换元素。</p>
</li>
</ol>
<p>这些算法提供了许多常见的操作，可以方便地对数据进行处理和操作。使用 <code>&lt;algorithm&gt;</code> 中的这些函数，可以使得编写 C++ 代码更加简洁、高效和易于理解。</p>
<h2 id="STL-常用算法"><a href="#STL-常用算法" class="headerlink" title="STL 常用算法"></a>STL 常用算法</h2><p>STL（Standard Template Library）提供了许多常用的算法，这些算法分为多个类别，涵盖了各种操作，包括查找、排序、转换等。下面是一些常用的STL算法：</p>
<ol>
<li><p><strong>非修改序列操作</strong>：</p>
<ul>
<li><code>std::for_each</code>: 对容器中的每个元素执行指定操作。</li>
<li><code>std::count</code>: 统计容器中满足指定条件的元素个数。</li>
<li><code>std::find</code>: 在容器中查找指定元素，并返回第一个匹配到的位置。</li>
<li><code>std::count_if</code>: 统计容器中满足指定条件的元素个数。</li>
</ul>
</li>
<li><p><strong>修改序列操作</strong>：</p>
<ul>
<li><code>std::copy</code>: 将一个容器中的元素复制到另一个容器中。</li>
<li><code>std::transform</code>: 对容器中的元素应用指定的操作，并将结果存储到另一个容器中。</li>
<li><code>std::replace</code>: 将容器中的指定值替换为另一个值。</li>
<li><code>std::fill</code>: 将容器中的元素设置为指定值。</li>
</ul>
</li>
<li><p><strong>排序和查找操作</strong>：</p>
<ul>
<li><code>std::sort</code>: 对容器中的元素进行排序。</li>
<li><code>std::binary_search</code>: 在已排序的容器中进行二分查找。</li>
<li><code>std::merge</code>: 合并两个已排序的序列到一个新序列中。</li>
</ul>
</li>
<li><p><strong>数值操作</strong>：</p>
<ul>
<li><code>std::accumulate</code>: 对容器中的元素进行累积操作。</li>
<li><code>std::min_element</code> &#x2F; <code>std::max_element</code>: 找到容器中最小或最大的元素。</li>
<li><code>std::inner_product</code>: 计算两个容器的内积。</li>
</ul>
</li>
</ol>
<p>这些算法仅是STL提供的众多算法中的一部分。它们都在 <code>&lt;algorithm&gt;</code> 头文件中定义。通过使用这些算法，可以简化代码并提高程序的效率，因为它们提供了可靠且经过优化的实现。</p>
<h2 id="C-罗列出所有的算法"><a href="#C-罗列出所有的算法" class="headerlink" title="C++  罗列出所有的算法"></a>C++ <algorithm> 罗列出所有的算法</h2><p><code>&lt;algorithm&gt;</code> 头文件中包含的算法非常多，以下是其中的一部分。请注意，这里列举的不是所有的算法，仅是一些常用的算法。具体的算法列表和详细描述可以参考 C++ 标准文档。</p>
<ol>
<li><p><strong>查找算法：</strong></p>
<ul>
<li><code>std::find</code></li>
<li><code>std::find_if</code></li>
<li><code>std::find_if_not</code></li>
<li><code>std::find_end</code></li>
<li><code>std::find_first_of</code></li>
<li><code>std::adjacent_find</code></li>
<li><code>std::binary_search</code></li>
<li><code>std::lower_bound</code></li>
<li><code>std::upper_bound</code></li>
<li><code>std::equal_range</code></li>
</ul>
</li>
<li><p><strong>排序算法：</strong></p>
<ul>
<li><code>std::sort</code></li>
<li><code>std::stable_sort</code></li>
<li><code>std::partial_sort</code></li>
<li><code>std::partial_sort_copy</code></li>
<li><code>std::is_sorted</code></li>
<li><code>std::is_sorted_until</code></li>
<li><code>std::nth_element</code></li>
</ul>
</li>
<li><p><strong>排列组合算法：</strong></p>
<ul>
<li><code>std::next_permutation</code></li>
<li><code>std::prev_permutation</code></li>
<li><code>std::rotate</code></li>
<li><code>std::rotate_copy</code></li>
</ul>
</li>
<li><p><strong>算术运算算法：</strong></p>
<ul>
<li><code>std::accumulate</code></li>
<li><code>std::inner_product</code></li>
<li><code>std::partial_sum</code></li>
<li><code>std::exclusive_scan</code></li>
<li><code>std::inclusive_scan</code></li>
<li><code>std::transform</code></li>
</ul>
</li>
<li><p><strong>集合操作算法：</strong></p>
<ul>
<li><code>std::merge</code></li>
<li><code>std::set_union</code></li>
<li><code>std::set_intersection</code></li>
<li><code>std::set_difference</code></li>
<li><code>std::set_symmetric_difference</code></li>
</ul>
</li>
<li><p><strong>删除和替换算法：</strong></p>
<ul>
<li><code>std::remove</code></li>
<li><code>std::remove_if</code></li>
<li><code>std::remove_copy</code></li>
<li><code>std::replace</code></li>
<li><code>std::replace_if</code></li>
<li><code>std::replace_copy</code></li>
<li><code>std::swap_ranges</code></li>
<li><code>std::unique</code></li>
<li><code>std::unique_copy</code></li>
</ul>
</li>
<li><p><strong>操作范围算法：</strong></p>
<ul>
<li><code>std::copy</code></li>
<li><code>std::copy_if</code></li>
<li><code>std::copy_n</code></li>
<li><code>std::copy_backward</code></li>
<li><code>std::move</code></li>
<li><code>std::move_backward</code></li>
<li><code>std::fill</code></li>
<li><code>std::fill_n</code></li>
<li><code>std::generate</code></li>
<li><code>std::generate_n</code></li>
</ul>
</li>
<li><p><strong>其他算法：</strong></p>
<ul>
<li><code>std::reverse</code></li>
<li><code>std::reverse_copy</code></li>
<li><code>std::rotate</code></li>
<li><code>std::rotate_copy</code></li>
<li><code>std::shuffle</code></li>
<li><code>std::random_shuffle</code></li>
<li><code>std::count</code></li>
<li><code>std::count_if</code></li>
<li><code>std::for_each</code></li>
</ul>
</li>
</ol>
<p>这只是其中的一小部分，还有很多其他算法。详细信息和用法可以参考 C++ 标准文档。</p>
<h2 id="C-标准库-std-sort-详解"><a href="#C-标准库-std-sort-详解" class="headerlink" title="C++ 标准库 std::sort 详解"></a>C++ <algorithm>标准库 std::sort 详解</h2><p><code>std::sort</code> 是 C++ 标准库 <code>&lt;algorithm&gt;</code> 中的一个函数，用于对指定范围内的元素进行排序。它采用快速排序（Quick Sort）或者其他高效的排序算法来实现。</p>
<p>以下是 <code>std::sort</code> 函数的详细说明：</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>first</code>：要排序范围的起始位置（可以是迭代器）。</li>
<li><code>last</code>：要排序范围的结束位置（不包括结束位置的元素）。</li>
<li><code>comp</code>（可选）：可选的比较函数对象，用于定义排序顺序。如果不提供此参数，则默认使用 <code>&lt;</code> 运算符进行元素比较。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><p><code>std::sort</code> 函数用于对迭代器范围 <code>[first, last)</code> 中的元素进行排序。该函数可以用于数组或标准库容器（如 vector、deque、list 等）。</p>
</li>
<li><p>默认情况下，<code>std::sort</code> 会按升序对元素进行排序，但也可以通过传递自定义的比较函数对象来定义其他排序顺序。</p>
</li>
</ul>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); <span class="comment">// 默认按升序排序</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>std::sort</code> 函数可以对整数、浮点数、字符串、自定义类型等元素进行排序。</li>
<li>对于自定义类型，如果没有提供自定义的比较函数，需要确保该类型的 <code>&lt;</code> 操作符或者提供了可供 <code>std::sort</code> 使用的比较函数。</li>
<li>对于自定义排序顺序，可以传递一个自定义的比较函数对象作为 <code>comp</code> 参数。</li>
</ul>
<p><code>std::sort</code> 是一个高效的排序算法，其时间复杂度通常为 O(n log n)，对大多数情况下的排序操作都能提供较好的性能。</p>
<h2 id="C-标准库-std-sort-自定义类型排序"><a href="#C-标准库-std-sort-自定义类型排序" class="headerlink" title="C++ 标准库 std::sort 自定义类型排序"></a>C++ <algorithm>标准库 std::sort 自定义类型排序</h2><p>当你想要对自定义类型的对象进行排序时，你可以通过提供比较函数或者重载对象的 <code>&lt;</code> 操作符来告诉 <code>std::sort</code> 如何进行排序。下面是一个示例，展示了如何在自定义类中使用 <code>std::sort</code> 进行排序：</p>
<p>假设有一个自定义的 <code>Person</code> 类，具有姓名和年龄字段，你想按照年龄对 <code>Person</code> 对象进行排序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Person 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载小于运算符，按照年龄升序排序</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Person&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age &lt; other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Person 对象的 vector</span></span><br><span class="line">    std::vector&lt;Person&gt; people = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;David&quot;</span>, <span class="number">22</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Order: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; person : people) &#123;</span><br><span class="line">        std::cout &lt;&lt; person.name &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; person.age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::sort 对 Person 对象按年龄升序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSorted by Age: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; person : people) &#123;</span><br><span class="line">        std::cout &lt;&lt; person.name &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; person.age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>Person</code> 类中重载了 <code>&lt;</code> 操作符，根据 <code>age</code> 成员变量的值进行比较。然后在 <code>main</code> 函数中，使用 <code>std::sort</code> 对 <code>Person</code> 对象的 <code>std::vector</code> 按照年龄进行排序。</p>
<p>这个示例展示了如何使用 <code>std::sort</code> 进行自定义类型的对象排序，只需确保提供了适当的比较方法，无论是重载 <code>&lt;</code> 运算符还是提供自定义的比较函数对象。</p>
<h2 id="C-标准库-std-sort-自定义类型排序-提供比较函数"><a href="#C-标准库-std-sort-自定义类型排序-提供比较函数" class="headerlink" title="C++ 标准库 std::sort 自定义类型排序 提供比较函数"></a>C++ <algorithm>标准库 std::sort 自定义类型排序 提供比较函数</h2><p>当使用 <code>std::sort</code> 对自定义类型进行排序时，你可以通过提供一个自定义的比较函数来定义排序规则。这个自定义的比较函数将告诉 <code>std::sort</code> 如何比较两个自定义类型的对象。下面是一个示例，展示了如何使用比较函数对自定义类型进行排序：</p>
<p>假设有一个自定义的 <code>Book</code> 类，包含书名和出版年份字段，你想按照出版年份对 <code>Book</code> 对象进行排序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Book 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string title;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Book</span>(<span class="type">const</span> std::string&amp; t, <span class="type">int</span> y) : <span class="built_in">title</span>(t), <span class="built_in">year</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数，按照出版年份升序排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareByYear</span><span class="params">(<span class="type">const</span> Book&amp; a, <span class="type">const</span> Book&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.year &lt; b.year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Book 对象的 vector</span></span><br><span class="line">    std::vector&lt;Book&gt; books = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Book A&quot;</span>, <span class="number">2000</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Book B&quot;</span>, <span class="number">1995</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Book C&quot;</span>, <span class="number">2010</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Book D&quot;</span>, <span class="number">1980</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Order: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; book : books) &#123;</span><br><span class="line">        std::cout &lt;&lt; book.title &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; book.year &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::sort 对 Book 对象按出版年份升序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>(), compareByYear);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSorted by Year: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; book : books) &#123;</span><br><span class="line">        std::cout &lt;&lt; book.title &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; book.year &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们定义了一个 <code>compareByYear</code> 比较函数，该函数接受两个 <code>Book</code> 对象并根据它们的出版年份进行比较。然后在 <code>main</code> 函数中，我们使用 <code>std::sort</code> 对 <code>Book</code> 对象的 <code>std::vector</code> 按照出版年份进行排序，并将 <code>compareByYear</code> 函数作为第三个参数传递给 <code>std::sort</code>。</p>
<p>这个示例展示了如何使用比较函数对自定义类型的对象进行排序，只需提供一个符合条件的比较函数，即可告诉 <code>std::sort</code> 如何排序这些对象。</p>
<h2 id="std-for-each"><a href="#std-for-each" class="headerlink" title="std::for_each"></a>std::for_each</h2><p><code>std::for_each</code> 是C++ STL提供的算法之一，用于对容器中的每个元素执行指定的操作。它允许你指定一个函数或者函数对象（也称为函数符或仿函数），然后对容器中的每个元素都应用这个函数。</p>
<p><code>std::for_each</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数对象（仿函数），用于输出容器中的元素</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Print</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> elem)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::for_each 对容器中的每个元素应用 Print 函数对象</span></span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="built_in">Print</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Print</code> 是一个函数对象（仿函数），它重载了<code>operator()</code>来实现对容器中元素的输出操作。然后，<code>std::for_each</code> 将容器<code>numbers</code>中的每个元素传递给<code>Print()</code>，即函数对象的实例，最终实现对每个元素的输出。</p>
<p>你也可以使用 lambda 表达式作为 <code>std::for_each</code> 的参数，而无需定义函数对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> elem) &#123;</span><br><span class="line">    std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>std::for_each</code> 提供了一种简洁而有效的方式来对容器中的元素进行操作，适用于许多不同的场景，能够更轻松地处理容器元素。</p>
<h2 id="std-count"><a href="#std-count" class="headerlink" title="std::count"></a>std::count</h2><p><code>std::count</code> 是C++ STL中的一个算法，用于计算容器中满足特定条件的元素个数。它接受两个迭代器参数，表示要进行计数的范围，以及一个要匹配的特定值。</p>
<p><code>std::count</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算容器中值为 2 的元素个数</span></span><br><span class="line">    <span class="type">int</span> countOfTwos = std::<span class="built_in">count</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The count of 2s in the vector: &quot;</span> &lt;&lt; countOfTwos &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::count</code> 被用来计算容器 <code>numbers</code> 中值为 2 的元素个数。它接收了三个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，以及要计数的特定值 2。最后，它返回匹配特定值的元素数量。</p>
<p>除了基本的数值比较外，<code>std::count</code> 也可以通过 lambda 表达式实现更加灵活的条件计数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算容器中大于 3 的元素个数</span></span><br><span class="line"><span class="type">int</span> countGreaterThanThree = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这将返回容器 <code>numbers</code> 中大于 3 的元素的数量。<code>std::count_if</code> 允许你通过 lambda 表达式指定更复杂的条件来计数满足特定条件的元素个数。</p>
<h2 id="std-find"><a href="#std-find" class="headerlink" title="std::find"></a>std::find</h2><p><code>std::find</code> 是C++ STL中的一个算法，用于在容器中查找特定值，并返回指向第一个匹配到的元素的迭代器。如果未找到匹配的元素，则返回指向容器末尾的迭代器。</p>
<p><code>std::find</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在容器中查找值为 3 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::find</code> 被用来查找容器 <code>numbers</code> 中值为 3 的元素。它接收了三个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，以及要查找的特定值 3。如果找到了值为 3 的元素，<code>std::find</code> 将返回指向这个元素的迭代器；如果未找到匹配的元素，它将返回指向容器末尾的迭代器。</p>
<p>除了基本的数值比较外，<code>std::find</code> 也可以通过 lambda 表达式实现更加灵活的查找条件，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 lambda 表达式查找容器中大于 3 的第一个元素</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这将返回容器 <code>numbers</code> 中第一个大于 3 的元素的迭代器。<code>std::find_if</code> 允许你通过 lambda 表达式指定更复杂的条件来查找满足特定条件的元素。</p>
<h2 id="std-find-if"><a href="#std-find-if" class="headerlink" title="std::find_if"></a>std::find_if</h2><p><code>std::find_if</code> 是 C++ STL 中的一个算法，用于在给定范围内查找满足特定条件的第一个元素。</p>
<p>其函数签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> UnaryPredicate &gt;</span></span><br><span class="line"><span class="function">InputIt <span class="title">find_if</span><span class="params">( InputIt first, InputIt last, UnaryPredicate p )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>first</code> 和 <code>last</code> 是指定范围的迭代器，表示要查找的元素范围。</li>
<li><code>p</code> 是一个谓词（UnaryPredicate），它是一个函数或函数对象，用于指定查找的条件。</li>
</ul>
<p><code>std::find_if</code> 函数从给定范围 <code>[first, last)</code> 中查找第一个满足条件 <code>p</code> 的元素，并返回指向该元素的迭代器。如果没有找到满足条件的元素，则返回 <code>last</code>。</p>
<p>以下是一个简单的示例说明如何使用 <code>std::find_if</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>&#125;; <span class="comment">// 示例数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个偶数</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), isEven);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到第一个偶数: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到满足条件的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>isEven</code> 是一个谓词函数，用于检查一个整数是否为偶数。<code>std::find_if</code> 函数被调用来在 <code>numbers</code> 容器中查找第一个偶数，如果找到了，则输出该元素的值，否则输出未找到满足条件的提示。</p>
<h2 id="std-count-if"><a href="#std-count-if" class="headerlink" title="std::count_if"></a>std::count_if</h2><p><code>std::count_if</code> 是C++ STL中的一个算法，用于计算容器中满足特定条件的元素个数。它接受两个迭代器参数，表示要进行计数的范围，并使用一个谓词（predicate）作为条件。</p>
<p><code>std::count_if</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算容器中大于 3 的元素个数</span></span><br><span class="line">    <span class="type">int</span> countGreaterThanThree = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">3</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count of elements greater than 3: &quot;</span> &lt;&lt; countGreaterThanThree &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::count_if</code> 被用来计算容器 <code>numbers</code> 中大于 3 的元素个数。它接收了三个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，以及一个 lambda 表达式作为谓词。这个 lambda 表达式定义了条件，即判断元素是否大于 3。</p>
<p><code>std::count_if</code> 将遍历容器中的每个元素，并使用指定的谓词对每个元素进行判断，然后返回满足条件的元素个数。</p>
<p>通过提供不同的谓词（即 lambda 表达式或者其他可调用对象），可以实现各种复杂的条件来计算满足特定条件的元素个数。</p>
<h2 id="std-copy"><a href="#std-copy" class="headerlink" title="std::copy"></a>std::copy</h2><p><code>std::copy</code> 是C++ STL中的一个算法，用于将一个容器中的元素复制到另一个容器中。它接受两个迭代器参数，表示要进行复制的范围，并将元素复制到目标容器的指定位置。</p>
<p><code>std::copy</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::copy 将 source 容器中的元素复制到 destination 容器中</span></span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(destination));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出目标容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : destination) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::copy</code> 被用来将容器 <code>source</code> 中的元素复制到容器 <code>destination</code> 中。它接收了三个参数：<code>source.begin()</code> 表示要复制的范围的起始迭代器，<code>source.end()</code> 表示范围的结束迭代器，以及目标容器的迭代器，使用 <code>std::back_inserter</code> 插入器将元素插入到目标容器的末尾。</p>
<p><code>std::copy</code> 将遍历源容器中的元素，并将它们复制到目标容器中，最终完成元素的复制操作。</p>
<p><code>std::copy</code> 使得在不同容器之间进行元素复制变得非常方便，可以在不同类型的容器之间灵活地进行数据传输。</p>
<h2 id="std-transform"><a href="#std-transform" class="headerlink" title="std::transform"></a>std::transform</h2><p><code>std::transform</code> 是C++ STL中的一个算法，用于将容器中的元素按照指定的操作进行转换，并将结果存储到另一个容器中。它接受两个源容器的迭代器作为输入范围，并使用一个目标容器的迭代器指定输出位置。此外，它还接受一个函数或函数对象，用于定义转换操作。</p>
<p><code>std::transform</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::transform 将 source 容器中的元素加倍后存储到 destination 容器中</span></span><br><span class="line">    std::<span class="built_in">transform</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(destination), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出目标容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : destination) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::transform</code> 被用来将容器 <code>source</code> 中的元素加倍后存储到容器 <code>destination</code> 中。它接收了四个参数：<code>source.begin()</code> 表示要转换的范围的起始迭代器，<code>source.end()</code> 表示范围的结束迭代器，<code>std::back_inserter(destination)</code> 表示目标容器的迭代器，使用 <code>std::back_inserter</code> 插入器将转换后的元素插入到目标容器的末尾，以及一个 lambda 表达式作为转换操作。</p>
<p><code>std::transform</code> 将遍历源容器中的每个元素，并使用指定的操作（在这里是 lambda 表达式中的乘以 2 操作），将转换后的结果存储到目标容器中。</p>
<p><code>std::transform</code> 提供了一种方便的方式来对容器中的元素进行转换，并将结果存储到另一个容器中，非常适用于需要对元素进行变换操作的场景。</p>
<h2 id="std-replace"><a href="#std-replace" class="headerlink" title="std::replace"></a>std::replace</h2><p><code>std::replace</code> 是C++ STL中的一个算法，用于在容器中将指定值替换为另一个值。它接受两个迭代器参数，表示要进行替换的范围，并使用要替换的值和替换后的新值作为参数。</p>
<p><code>std::replace</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::replace 将容器中的值为 3 的元素替换为 10</span></span><br><span class="line">    std::<span class="built_in">replace</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出替换后的容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::replace</code> 被用来将容器 <code>numbers</code> 中的值为 3 的元素替换为 10。它接收了四个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，要被替换的旧值 3，以及替换后的新值 10。</p>
<p><code>std::replace</code> 将遍历容器中的每个元素，并将与旧值相匹配的元素替换为新值。</p>
<p><code>std::replace</code> 提供了一种简单而有效的方法，用于在容器中执行值的替换操作。</p>
<h2 id="std-fill"><a href="#std-fill" class="headerlink" title="std::fill"></a>std::fill</h2><p><code>std::fill</code> 是C++ STL中的一个算法，用于将容器中的所有元素都设置为指定的值。它接受两个迭代器参数，表示要进行填充的范围，并使用要填充的值作为参数。</p>
<p><code>std::fill</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">numbers</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 创建一个包含5个元素的向量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::fill 将向量中的所有元素设置为值为 10</span></span><br><span class="line">    std::<span class="built_in">fill</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出填充后的向量中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::fill</code> 被用来将向量 <code>numbers</code> 中的所有元素设置为值为 10。它接收了三个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，以及要填充的新值 10。</p>
<p><code>std::fill</code> 将遍历容器中的每个元素，并将每个元素设置为指定的新值。</p>
<p><code>std::fill</code> 提供了一种便捷的方法，用于将容器中的所有元素都设置为特定的值，非常适用于需要初始化容器的情况。</p>
<h2 id="std-sort"><a href="#std-sort" class="headerlink" title="std::sort"></a>std::sort</h2><p><code>std::sort</code> 是C++ STL中的一个算法，用于对容器中的元素进行排序。它接受两个迭代器参数，表示要进行排序的范围，并按照默认的升序方式对这个范围内的元素进行排序。</p>
<p><code>std::sort</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::sort 对向量中的元素进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序后的向量中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::sort</code> 被用来对向量 <code>numbers</code> 中的元素进行排序。它接收了两个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器。</p>
<p><code>std::sort</code> 将对容器中的元素按照默认的升序方式进行排序。如果你想要进行自定义的排序方式，可以传入一个自定义的比较函数作为第三个参数。</p>
<p><code>std::sort</code> 是一个高效的排序算法，在处理各种数据结构和数据类型时都能够提供良好的性能。</p>
<h2 id="std-stable-sort"><a href="#std-stable-sort" class="headerlink" title="std::stable_sort"></a>std::stable_sort</h2><p><code>std::stable_sort</code> 是 C++ 标准库中的一个函数，用于对容器中的元素进行排序。与 <code>std::sort</code> 不同，<code>std::stable_sort</code> 是一种稳定排序算法，它能够保持相等元素的相对位置不变。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stable_sort</span><span class="params">( RandomIt first, RandomIt last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stable_sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first</code> 是一个指向容器要排序部分的起始位置的迭代器；</li>
<li><code>last</code> 是一个指向容器结束位置的迭代器；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::stable_sort</code> 对范围 <code>[first, last)</code> 中的元素进行排序，保持相等元素的相对位置不变。这意味着如果两个元素在排序前相等，那么在排序后，它们的相对顺序将保持不变。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">stable_sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码将 <code>numbers</code> 容器中的元素使用 <code>std::stable_sort</code> 进行排序。排序后，输出的结果将会按升序排列，并且相等元素的相对位置将保持不变。</p>
<p><code>std::stable_sort</code> 在需要稳定排序的情况下非常有用，特别是当需要保持相等元素的相对顺序时。这对于处理某些特定的数据结构或算法非常重要。</p>
<p>总的来说，<code>std::stable_sort</code> 是一个强大的排序函数，可以对容器中的元素进行排序，并保持相等元素的相对位置不变。</p>
<h2 id="std-partial-sort"><a href="#std-partial-sort" class="headerlink" title="std::partial_sort"></a>std::partial_sort</h2><p><code>std::partial_sort</code> 是 C++ 标准库中的一个函数，用于对容器中的部分元素进行排序。它能够在排序过程中保持部分元素的顺序，将指定范围内的元素部分排序为序列中最小（或最大）的一部分。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partial_sort</span><span class="params">( RandomIt first, RandomIt middle, RandomIt last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partial_sort</span><span class="params">( RandomIt first, RandomIt middle, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first</code> 是一个指向容器要排序部分的起始位置的迭代器；</li>
<li><code>middle</code> 是一个指向容器的中间位置的迭代器；</li>
<li><code>last</code> 是一个指向容器结束位置的迭代器；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::partial_sort</code> 将容器从 <code>first</code> 到 <code>middle</code> 的元素部分排序，使得 <code>middle - first</code> 个元素是序列中最小（或最大）的一部分，但并不保证这些元素之间的顺序。而剩余的元素，即从 <code>middle</code> 到 <code>last</code> 的范围内，可能在序列中以任意顺序出现，不做排序。</p>
<p>这个函数通常在需要获取序列中最小或最大的一部分元素时非常有用，而不需要完全对整个序列进行排序。这有助于节省计算资源，特别是当只对部分数据感兴趣时。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">partial_sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">begin</span>() + <span class="number">4</span>, numbers.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码将 <code>numbers</code> 容器的前四个元素进行部分排序，使得前四个元素是序列中最小的一部分，而后续元素可能在序列中以任意顺序出现。</p>
<p><code>std::partial_sort</code> 在处理大型数据集时能够提供更高的效率，因为它只对部分元素进行排序而不需要对整个序列进行排序。</p>
<p>总之，<code>std::partial_sort</code> 是一个有用的函数，适用于在部分排序情况下获取序列中最小（或最大）的一部分元素。</p>
<h2 id="std-nth-element"><a href="#std-nth-element" class="headerlink" title="std::nth_element"></a>std::nth_element</h2><p><code>std::nth_element</code> 是 C++ 标准库中的一个函数，用于在容器中找到第 n 个顺序统计量，即第 n 小或第 n 大的元素，而不必对整个序列进行排序。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">( RandomIt first, RandomIt nth, RandomIt last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">( RandomIt first, RandomIt nth, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first</code> 是一个指向容器要排序部分的起始位置的迭代器；</li>
<li><code>nth</code> 是一个指向容器中要找到的第 n 个元素的迭代器；</li>
<li><code>last</code> 是一个指向容器结束位置的迭代器；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::nth_element</code> 将容器 <code>[first, last)</code> 中的元素重新排列，使得位于位置 <code>nth</code> 的元素是序列中第 n 小（或第 n 大）的元素，并且在它之前的元素小于或等于它，在它之后的元素大于或等于它。但并不保证 <code>nth</code> 之前或之后的元素是有序的。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">nth_element</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">begin</span>() + <span class="number">4</span>, numbers.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The fifth smallest element is: &quot;</span> &lt;&lt; numbers[<span class="number">4</span>] &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码将 <code>numbers</code> 容器中的元素使用 <code>std::nth_element</code> 进行部分排序，找到序列中第五小的元素。在输出中，<code>numbers[4]</code> 将是第五小的元素，但在它之前或之后的元素不一定是有序的。</p>
<p><code>std::nth_element</code> 是在需要找到第 n 个顺序统计量而无需完全排序整个序列时非常有用的。它的时间复杂度是线性的，而不是完全排序所需的时间复杂度。</p>
<p>总的来说，<code>std::nth_element</code> 是一个用于在容器中找到第 n 个顺序统计量的高效算法，可以在部分排序的情况下找到指定位置的元素。</p>
<h2 id="std-lower-bound"><a href="#std-lower-bound" class="headerlink" title="std::lower_bound"></a>std::lower_bound</h2><p><code>std::lower_bound</code> 是 C++ 标准库中的一个算法函数，用于在已排序的序列中查找第一个大于或等于某个值的元素的位置（也就是说，它返回大于或等于指定值的第一个元素的迭代器位置），如果不存在这样的元素，则返回序列末尾的迭代器。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first</code> 是一个指向容器或数组开始位置的迭代器；</li>
<li><code>last</code> 是一个指向容器或数组结束位置的迭代器；</li>
<li><code>value</code> 是要查找的值；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::lower_bound</code> 在一个已排序的序列 <code>[first, last)</code> 中查找大于或等于 <code>value</code> 的第一个元素。如果找到了匹配的元素，则返回指向该元素的迭代器；如果没有找到匹配的元素，则返回指向序列中第一个大于 <code>value</code> 的元素位置的迭代器，如果不存在大于 <code>value</code> 的元素，则返回 <code>last</code>。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 std::lower_bound 查找第一个大于或等于 5 的元素位置</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First element greater than or equal to 5 is: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element greater than or equal to 5 found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>std::lower_bound</code> 在已排序的 <code>numbers</code> 容器中查找第一个大于或等于 5 的元素位置，并输出找到的元素值。如果没有找到大于或等于 5 的元素，则输出相应的信息。</p>
<p><code>std::lower_bound</code> 在需要在已排序序列中快速查找大于或等于某个值的元素位置时非常有用。注意，对于无序序列，<code>std::lower_bound</code> 不会返回正确的结果，因为它要求输入序列是有序的才能保证正确性。</p>
<h2 id="std-upper-bound"><a href="#std-upper-bound" class="headerlink" title="std::upper_bound"></a>std::upper_bound</h2><p><code>std::upper_bound</code> 是 C++ 标准库中的一个算法函数，用于在已排序的序列中查找第一个大于某个值的元素的位置（也就是说，它返回大于指定值的第一个元素的迭代器位置），如果不存在这样的元素，则返回序列末尾的迭代器。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first</code> 是一个指向容器或数组开始位置的迭代器；</li>
<li><code>last</code> 是一个指向容器或数组结束位置的迭代器；</li>
<li><code>value</code> 是要查找的值；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::upper_bound</code> 在一个已排序的序列 <code>[first, last)</code> 中查找大于 <code>value</code> 的第一个元素。如果找到了匹配的元素，则返回指向下一个元素的迭代器；如果没有找到匹配的元素，则返回指向序列中第一个大于 <code>value</code> 的元素位置的迭代器，如果不存在大于 <code>value</code> 的元素，则返回 <code>last</code>。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 std::upper_bound 查找第一个大于 5 的元素位置</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First element greater than 5 is: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element greater than 5 found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>std::upper_bound</code> 在已排序的 <code>numbers</code> 容器中查找第一个大于 5 的元素位置，并输出找到的元素值。如果没有找到大于 5 的元素，则输出相应的信息。</p>
<p><code>std::upper_bound</code> 在需要在已排序序列中快速查找大于某个值的元素位置时非常有用。注意，对于无序序列，<code>std::upper_bound</code> 不会返回正确的结果，因为它要求输入序列是有序的才能保证正确性。</p>
<h2 id="std-binary-search"><a href="#std-binary-search" class="headerlink" title="std::binary_search"></a>std::binary_search</h2><p><code>std::binary_search</code> 是C++ STL中的一个算法，用于在已排序的序列（例如数组或有序容器）中进行二分查找。它接受两个迭代器参数，表示要进行查找的范围，并返回一个布尔值，指示是否找到了指定的元素。</p>
<p><code>std::binary_search</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> target = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::binary_search 在有序向量中查找元素</span></span><br><span class="line">    <span class="type">bool</span> isFound = std::<span class="built_in">binary_search</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFound) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; not found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::binary_search</code> 被用来在已排序的向量 <code>numbers</code> 中查找元素 6。它接收了三个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，以及要查找的目标值 6。</p>
<p><code>std::binary_search</code> 返回一个布尔值，指示是否在容器中找到了指定的元素。如果找到了元素，则返回 <code>true</code>；否则返回 <code>false</code>。</p>
<p><code>std::binary_search</code> 使用二分查找算法来检查序列是否包含指定的值。在已排序的序列中，这个算法提供了较快的查找速度。</p>
<h2 id="std-merge"><a href="#std-merge" class="headerlink" title="std::merge"></a>std::merge</h2><p><code>std::merge</code> 是C++ STL中的一个算法，用于将两个已排序的序列合并成一个新的已排序序列。它接受四个迭代器参数，分别表示两个待合并序列的起始和结束位置，以及一个目标序列的起始位置。</p>
<p><code>std::merge</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; first = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; second = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(first.size() + second.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::merge 合并两个有序向量，并将结果存储到 result 向量中</span></span><br><span class="line">    std::<span class="built_in">merge</span>(first.<span class="built_in">begin</span>(), first.<span class="built_in">end</span>(), second.<span class="built_in">begin</span>(), second.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出合并后的向量中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::merge</code> 被用来将两个已排序的向量 <code>first</code> 和 <code>second</code> 合并成一个新的有序向量 <code>result</code>。它接收了五个参数：<code>first.begin()</code> 和 <code>first.end()</code> 表示第一个待合并序列的范围，<code>second.begin()</code> 和 <code>second.end()</code> 表示第二个待合并序列的范围，以及目标向量 <code>result</code> 的起始迭代器。</p>
<p><code>std::merge</code> 将按照递增的顺序将两个已排序的序列合并到目标序列中。合并后的序列保持有序状态。</p>
<p><code>std::merge</code> 是一个在合并已排序序列时非常有用的算法，它能够高效地合并两个有序序列到一个新的有序序列中。</p>
<h2 id="std-set-intersection"><a href="#std-set-intersection" class="headerlink" title="std::set_intersection"></a>std::set_intersection</h2><p><code>std::set_intersection</code> 是 C++ 标准库中的一个算法函数，用于在两个有序集合（或有序范围）中找到并计算交集，并将结果存储到另一个集合（或指定的输出范围）中。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">OutputIt</span>&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_intersection</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                          InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                          OutputIt d_first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">OutputIt</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_intersection</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                          InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                          OutputIt d_first, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first1</code> 和 <code>last1</code> 表示第一个有序集合（或范围）的起始和结束位置；</li>
<li><code>first2</code> 和 <code>last2</code> 表示第二个有序集合（或范围）的起始和结束位置；</li>
<li><code>d_first</code> 表示输出的目标位置，即存储交集的容器或输出范围的起始位置；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::set_intersection</code> 找到两个有序集合（或范围）的交集，并将结果存储到目标容器或输出范围中。返回值是一个指向输出范围的末尾的迭代器，指示了存储交集后的结束位置。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; intersection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取两个集合的交集</span></span><br><span class="line">    std::<span class="built_in">set_intersection</span>(set<span class="number">1.</span><span class="built_in">begin</span>(), set<span class="number">1.</span><span class="built_in">end</span>(),</span><br><span class="line">                          set<span class="number">2.</span><span class="built_in">begin</span>(), set<span class="number">2.</span><span class="built_in">end</span>(),</span><br><span class="line">                          std::<span class="built_in">back_inserter</span>(intersection));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出交集</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Intersection: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : intersection) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::set_intersection</code> 将 <code>set1</code> 和 <code>set2</code> 两个有序集合的交集计算出来，并将结果存储到 <code>intersection</code> 容器中。最后输出了交集的内容。</p>
<p><code>std::set_intersection</code> 对于处理两个有序集合的交集非常有用。它要求输入的两个集合（或范围）都是有序的，以保证正确的交集计算。</p>
<h2 id="std-set-union"><a href="#std-set-union" class="headerlink" title="std::set_union"></a>std::set_union</h2><p><code>std::set_union</code> 是 C++ 标准库中的一个算法函数，用于计算两个有序集合（或有序范围）的并集，并将结果存储到另一个集合（或指定的输出范围）中。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">OutputIt</span>&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_union</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                   InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                   OutputIt d_first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">OutputIt</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_union</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                   InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                   OutputIt d_first, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first1</code> 和 <code>last1</code> 表示第一个有序集合（或范围）的起始和结束位置；</li>
<li><code>first2</code> 和 <code>last2</code> 表示第二个有序集合（或范围）的起始和结束位置；</li>
<li><code>d_first</code> 表示输出的目标位置，即存储并集的容器或输出范围的起始位置；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::set_union</code> 找到两个有序集合（或范围）的并集，并将结果存储到目标容器或输出范围中。返回值是一个指向输出范围的末尾的迭代器，指示了存储并集后的结束位置。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; union_set;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取两个集合的并集</span></span><br><span class="line">    std::<span class="built_in">set_union</span>(set<span class="number">1.</span><span class="built_in">begin</span>(), set<span class="number">1.</span><span class="built_in">end</span>(),</span><br><span class="line">                   set<span class="number">2.</span><span class="built_in">begin</span>(), set<span class="number">2.</span><span class="built_in">end</span>(),</span><br><span class="line">                   std::<span class="built_in">back_inserter</span>(union_set));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出并集</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Union: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : union_set) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>std::set_union</code> 将 <code>set1</code> 和 <code>set2</code> 两个有序集合的并集计算出来，并将结果存储到 <code>union_set</code> 容器中。最后输出了并集的内容。</p>
<p><code>std::set_union</code> 对于处理两个有序集合的并集非常有用。它要求输入的两个集合（或范围）都是有序的，以保证正确的并集计算。</p>
<h2 id="std-set-difference"><a href="#std-set-difference" class="headerlink" title="std::set_difference"></a>std::set_difference</h2><p><code>std::set_difference</code> 是 C++ 标准库中的一个算法函数，用于计算两个有序集合（或有序范围）的差集，并将结果存储到另一个集合（或指定的输出范围）中。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">OutputIt</span>&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_difference</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                        OutputIt d_first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">OutputIt</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_difference</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                        OutputIt d_first, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first1</code> 和 <code>last1</code> 表示第一个有序集合（或范围）的起始和结束位置；</li>
<li><code>first2</code> 和 <code>last2</code> 表示第二个有序集合（或范围）的起始和结束位置；</li>
<li><code>d_first</code> 表示输出的目标位置，即存储差集的容器或输出范围的起始位置；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::set_difference</code> 找到两个有序集合（或范围）的差集，并将结果存储到目标容器或输出范围中。返回值是一个指向输出范围的末尾的迭代器，指示了存储差集后的结束位置。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; difference_set;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取两个集合的差集</span></span><br><span class="line">    std::<span class="built_in">set_difference</span>(set<span class="number">1.</span><span class="built_in">begin</span>(), set<span class="number">1.</span><span class="built_in">end</span>(),</span><br><span class="line">                        set<span class="number">2.</span><span class="built_in">begin</span>(), set<span class="number">2.</span><span class="built_in">end</span>(),</span><br><span class="line">                        std::<span class="built_in">back_inserter</span>(difference_set));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出差集</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Difference: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : difference_set) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>std::set_difference</code> 将 <code>set1</code> 和 <code>set2</code> 两个有序集合的差集计算出来，并将结果存储到 <code>difference_set</code> 容器中。最后输出了差集的内容。<br>1</p>
<p><code>std::set_difference</code> 对于处理两个有序集合的差集非常有用。它要求输入的两个集合（或范围）都是有序的，以保证正确的差集计算。</p>
<h2 id="std-accumulate"><a href="#std-accumulate" class="headerlink" title="std::accumulate"></a>std::accumulate</h2><p><code>std::accumulate</code> 是C++ STL中的一个算法，用于对容器中的元素进行累加操作。它接受三个参数：范围的起始和结束迭代器，以及一个初始值，用于指定累加的起始值。</p>
<p><code>std::accumulate</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::accumulate 对向量中的元素进行累加</span></span><br><span class="line">    <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of elements: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::accumulate</code> 被用来对向量 <code>numbers</code> 中的所有元素进行累加操作。它接收了三个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，以及初始值 0 作为累加的起始值。</p>
<p><code>std::accumulate</code> 将对范围内的所有元素进行累加，返回最终的累加结果。</p>
<p>除了简单的累加外，<code>std::accumulate</code> 也可以执行其他操作，如乘法累积、自定义操作等。它提供了灵活性，使得在容器中对元素进行各种累积操作变得非常方便。</p>
<h2 id="std-accumulate-自定义操作"><a href="#std-accumulate-自定义操作" class="headerlink" title="std::accumulate 自定义操作"></a>std::accumulate 自定义操作</h2><p>当使用 <code>std::accumulate</code> 时，你可以提供一个自定义的二元函数来执行特定的累积操作。这个函数可以是加法、乘法、逻辑运算或任何你需要的二元操作。</p>
<p>以下是一个示例，展示了如何使用 <code>std::accumulate</code> 执行自定义操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数：将两个元素相乘</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">customMultiply</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::accumulate 对向量中的元素进行自定义的累积操作</span></span><br><span class="line">    <span class="type">int</span> product = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">1</span>, customMultiply);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Product of elements: &quot;</span> &lt;&lt; product &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::accumulate</code> 用于计算向量 <code>numbers</code> 中所有元素的乘积。<code>customMultiply</code> 是一个自定义的函数，用于定义累积操作。<code>std::accumulate</code> 接受了四个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，初始值为 1（因为乘法操作的初始值为 1），以及自定义的乘法函数 <code>customMultiply</code>。</p>
<p>这个示例中使用了乘法操作，但你可以根据需要提供不同的自定义函数来执行各种不同的累积操作。<code>std::accumulate</code> 的灵活性使得在容器中执行各种自定义操作变得非常方便。</p>
<h2 id="std-inner-product"><a href="#std-inner-product" class="headerlink" title="std::inner_product"></a>std::inner_product</h2><p><code>std::inner_product</code> 是C++ STL中的一个算法，用于计算两个序列的内积（dot product）。它接受四个迭代器参数，分别表示两个序列的起始和结束位置，以及两个序列的初始值。</p>
<p><code>std::inner_product</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; first = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; second = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::inner_product 计算两个向量的内积</span></span><br><span class="line">    <span class="type">int</span> result = std::<span class="built_in">inner_product</span>(first.<span class="built_in">begin</span>(), first.<span class="built_in">end</span>(), second.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inner product of the vectors: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::inner_product</code> 被用来计算两个向量 <code>first</code> 和 <code>second</code> 的内积。它接收了四个参数：<code>first.begin()</code> 和 <code>first.end()</code> 表示第一个序列的范围，<code>second.begin()</code> 表示第二个序列的范围，以及初始值为 0。</p>
<p><code>std::inner_product</code> 将对两个序列中对应位置的元素进行相乘并相加，最终得到内积的结果。</p>
<p>除了默认的内积计算外，<code>std::inner_product</code> 还可以接受自定义的二元函数来执行其他类型的累积操作。这使得它非常灵活，能够进行各种不同类型的序列计算。</p>
<h2 id="std-generate"><a href="#std-generate" class="headerlink" title="std::generate"></a>std::generate</h2><p><code>std::generate()</code> 是 C++ STL 中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于生成指定范围内的值，并将这些值放置到容器或数组中。</p>
<p>该函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> Generator &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate</span><span class="params">(ForwardIt first, ForwardIt last, Generator g)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个范围 <code>[first, last)</code>，并使用生成器函数 <code>g</code> 来生成值，将这些值依次赋值给范围内的元素。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">numbers</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> counter = <span class="number">1</span>;</span><br><span class="line">    std::<span class="built_in">generate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [&amp;counter]() &#123;</span><br><span class="line">        <span class="keyword">return</span> counter++;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Generated Numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generated Numbers: 1 2 3 4 5 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::generate()</code> 函数使用 lambda 表达式作为生成器函数，从1开始生成值并填充到 <code>numbers</code> 容器中。这里利用了 lambda 表达式来捕获并递增 <code>counter</code> 变量的值，并将递增后的值赋给容器中的元素。</p>
<h2 id="std-make-heap"><a href="#std-make-heap" class="headerlink" title="std::make_heap"></a>std::make_heap</h2><p><code>std::make_heap()</code> 是 C++ STL 中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于将一个范围内的元素重新组织为一个堆数据结构。</p>
<p>堆是一种特殊的二叉树结构，其中每个父节点的值都大于或等于其子节点的值（最大堆），或每个父节点的值都小于或等于其子节点的值（最小堆）。STL 中的堆通常使用数组来表示。</p>
<p><code>std::make_heap()</code> 函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_heap</span><span class="params">( RandomIt first, RandomIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个范围 <code>[first, last)</code>，其中的元素将会被重新组织成一个堆。默认情况下，这个函数会将范围 <code>[first, last)</code> 中的元素转换为最大堆。如果需要创建最小堆，可以使用 <code>std::make_heap(first, last, comp)</code> 并提供一个比较函数 <code>comp</code>。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">make_heap</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Heapified Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Original Vector: 3 1 4 1 5 9 2 6 </span><br><span class="line">Heapified Vector: 9 5 4 6 1 3 2 1 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::make_heap()</code> 函数将 <code>numbers</code> 容器转换为最大堆。<code>make_heap()</code> 函数会对范围 <code>[first, last)</code> 中的元素进行重新排列，使其满足堆的性质。</p>
<h2 id="std-push-heap"><a href="#std-push-heap" class="headerlink" title="std::push_heap"></a>std::push_heap</h2><p><code>std::push_heap()</code> 是 C++ STL 中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于将堆中的元素范围扩展，添加一个新元素，并保持堆的性质不变。</p>
<p>堆是一种特殊的二叉树结构，其中每个父节点的值都大于或等于其子节点的值（最大堆），或每个父节点的值都小于或等于其子节点的值（最小堆）。</p>
<p><code>std::push_heap()</code> 函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_heap</span><span class="params">( RandomIt first, RandomIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个范围 <code>[first, last-1]</code>，表示已经形成了一个堆（[first, last-1]是一个有效的堆），然后将 <code>*(last-1)</code> 添加到堆中，并保持堆的性质。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">make_heap</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Heapified Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个新元素到堆中</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    std::<span class="built_in">push_heap</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Heapified Vector after push_heap: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Original Vector: 3 1 4 1 5 9 </span><br><span class="line">Heapified Vector: 9 5 4 1 1 3 </span><br><span class="line">Heapified Vector after push_heap: 9 6 4 5 1 3 1 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::push_heap()</code> 函数将一个新元素 <code>6</code> 添加到 <code>numbers</code> 容器的末尾，并将其保持为最大堆。<code>push_heap()</code> 函数确保堆的性质仍然得到维护。</p>
<h2 id="std-pop-heap"><a href="#std-pop-heap" class="headerlink" title="std::pop_heap"></a>std::pop_heap</h2><p><code>std::pop_heap()</code> 是 C++ STL 中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于将堆中的最大（或最小）元素移到范围的末尾，并且在范围的前部保持一个堆。</p>
<p>堆是一种特殊的二叉树结构，其中每个父节点的值都大于或等于其子节点的值（最大堆），或每个父节点的值都小于或等于其子节点的值（最小堆）。</p>
<p><code>std::pop_heap()</code> 函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_heap</span><span class="params">( RandomIt first, RandomIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个范围 <code>[first, last]</code>，其中 <code>[first, last-1]</code> 应该表示一个有效的堆。然后它将堆中的最大元素（对于最大堆）或最小元素（对于最小堆）移到范围的末尾，并将 <code>[first, last-1]</code> 调整为一个新的堆。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">make_heap</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Heapified Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除堆中的最大元素（在此为 9）</span></span><br><span class="line">    std::<span class="built_in">pop_heap</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Heap after pop_heap: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Original Vector: 3 1 4 1 5 9 </span><br><span class="line">Heapified Vector: 9 5 4 1 1 3 </span><br><span class="line">Heap after pop_heap: 5 1 4 1 3 9 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::pop_heap()</code> 函数将 <code>numbers</code> 容器的第一个元素（即最大元素）移到了范围的末尾，并且重新将 <code>[first, last-1]</code> 调整为一个新的最大堆。</p>
<h2 id="std-min"><a href="#std-min" class="headerlink" title="std::min"></a>std::min</h2><p>在 C++ 标准库中，<code>std::min()</code> 是一个模板函数，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于比较两个值并返回其中较小的那个。</p>
<p><code>std::min()</code> 有多个重载形式，可以接受不同类型的参数：</p>
<ol>
<li><p><strong>两个参数形式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">min</span><span class="params">( <span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个版本接受两个相同类型的参数 <code>a</code> 和 <code>b</code>，并返回其中较小的值。</p>
</li>
<li><p><strong>初始化列表形式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">( std::initializer_list&lt;T&gt; ilist )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个版本接受一个初始化列表，并返回列表中的最小值。</p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> smaller = std::<span class="built_in">min</span>(x, y); <span class="comment">// 返回较小的值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The smaller value is: &quot;</span> &lt;&lt; smaller &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The smaller value is: 3</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::min()</code> 被用于比较 <code>x</code> 和 <code>y</code> 的值，并将较小的值赋给变量 <code>smaller</code>。根据参数的类型，<code>std::min()</code> 将返回一个具有较小值的变量或元素。</p>
<h2 id="std-max"><a href="#std-max" class="headerlink" title="std::max"></a>std::max</h2><p>在 C++ 标准库中，<code>std::max()</code> 是一个模板函数，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于比较两个值并返回其中较大的那个。</p>
<p><code>std::max()</code> 有多个重载形式，可以接受不同类型的参数：</p>
<ol>
<li><p><strong>两个参数形式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">max</span><span class="params">( <span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个版本接受两个相同类型的参数 <code>a</code> 和 <code>b</code>，并返回其中较大的值。</p>
</li>
<li><p><strong>初始化列表形式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">( std::initializer_list&lt;T&gt; ilist )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个版本接受一个初始化列表，并返回列表中的最大值。</p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> larger = std::<span class="built_in">max</span>(x, y); <span class="comment">// 返回较大的值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The larger value is: &quot;</span> &lt;&lt; larger &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The larger value is: 5</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::max()</code> 被用于比较 <code>x</code> 和 <code>y</code> 的值，并将较大的值赋给变量 <code>larger</code>。根据参数的类型，<code>std::max()</code> 将返回一个具有较大值的变量或元素。</p>
<h2 id="std-reverse"><a href="#std-reverse" class="headerlink" title="std::reverse"></a>std::reverse</h2><p><code>std::reverse()</code> 是 C++ 标准库中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于将指定范围内的元素进行反转。</p>
<p>这个函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> BidirIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">( BidirIt first, BidirIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>std::reverse()</code> 接受一个范围 <code>[first, last)</code>，并将该范围内的元素进行反转。这个范围应该是一个双向迭代器范围，例如 <code>std::vector</code>、<code>std::list</code>、<code>std::deque</code> 等容器。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">reverse</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reversed Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Original Vector: 1 2 3 4 5 </span><br><span class="line">Reversed Vector: 5 4 3 2 1 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::reverse()</code> 函数被用于反转 <code>numbers</code> 容器中的元素顺序。注意，<code>std::reverse()</code> 只是简单地颠倒元素的顺序，并不会改变容器中的元素值。</p>
<h2 id="std-rotate"><a href="#std-rotate" class="headerlink" title="std::rotate"></a>std::rotate</h2><p><code>std::rotate()</code> 是 C++ 标准库中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于将容器中的元素按照指定的位置进行循环左旋。</p>
<p>这个函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">rotate</span><span class="params">( ForwardIt first, ForwardIt n_first, ForwardIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>std::rotate()</code> 接受三个迭代器参数：<code>first</code>、<code>n_first</code> 和 <code>last</code>。它会将位于范围 <code>[first, last)</code> 中的元素从位置 <code>first</code> 开始，循环左旋到新的位置 <code>n_first</code>。也就是说，<code>n_first</code> 将成为新的起始位置。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">rotate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">begin</span>() + <span class="number">2</span>, numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rotated Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Original Vector: 1 2 3 4 5 </span><br><span class="line">Rotated Vector: 3 4 5 1 2 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::rotate()</code> 函数被用于对 <code>numbers</code> 容器中的元素进行循环左旋。参数 <code>numbers.begin() + 2</code> 指定了旋转的新起始位置，将原来前两个元素移到了容器末尾。</p>
<h2 id="std-swap"><a href="#std-swap" class="headerlink" title="std::swap"></a>std::swap</h2><p><code>std::swap</code> 是 C++ 标准库中的一个函数，用于交换两个对象的值。这个函数位于 <code>&lt;algorithm&gt;</code> 头文件中。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>a</code> 和 <code>b</code> 是要交换值的两个对象的引用。</p>
<p><code>std::swap</code> 函数交换了两个对象的值，无论这些对象的类型是什么。它通过使用临时变量来实现值的交换。这个函数对于标准数据类型（例如整数、浮点数等）以及自定义类型都是适用的。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::swap 交换 a 和 b 的值</span></span><br><span class="line">    std::<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::swap</code> 函数被用于交换变量 <code>a</code> 和 <code>b</code> 的值。经过交换后，<code>a</code> 的值变为原来 <code>b</code> 的值，<code>b</code> 的值变为原来 <code>a</code> 的值。</p>
<p><code>std::swap</code> 是一个通用的交换值的函数，可以在很多场景下用于交换各种类型的对象，非常方便。需要注意的是，在进行交换时，对于某些类类型对象，最好实现了合适的交换操作，以提高性能。</p>
<h2 id="std-swap-ranges"><a href="#std-swap-ranges" class="headerlink" title="std::swap_ranges"></a>std::swap_ranges</h2><p><code>std::swap_ranges</code> 是 C++ 标准库中的一个算法函数，用于交换两个范围内的元素值。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIt1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIt2</span>&gt;</span><br><span class="line"><span class="function">ForwardIt2 <span class="title">swap_ranges</span><span class="params">(ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first1</code> 和 <code>last1</code> 表示第一个范围的起始和结束位置；</li>
<li><code>first2</code> 表示第二个范围的起始位置；</li>
<li>返回值为第二个范围的结束位置。</li>
</ul>
<p><code>std::swap_ranges</code> 函数用于交换两个范围内的元素值，即将范围 <code>[first1, last1)</code> 中的元素与范围以 <code>first2</code> 为起始位置的另一个范围的元素进行逐个交换。第一个范围的元素数量必须与第二个范围相同。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swapping:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : vec2) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::swap_ranges 交换两个向量的元素</span></span><br><span class="line">    std::<span class="built_in">swap_ranges</span>(vec<span class="number">1.</span><span class="built_in">begin</span>(), vec<span class="number">1.</span><span class="built_in">end</span>(), vec<span class="number">2.</span><span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swapping:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : vec2) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::swap_ranges</code> 函数被用于交换两个向量 <code>vec1</code> 和 <code>vec2</code> 中的元素。经过交换后，<code>vec1</code> 中的元素变为原来 <code>vec2</code> 中的元素，<code>vec2</code> 中的元素变为原来 <code>vec1</code> 中的元素。</p>
<p><code>std::swap_ranges</code> 对于交换两个范围内的元素值非常有用。它能够方便地交换两个范围中对应位置的元素值，而不需要手动编写交换的逻辑。</p>
<h2 id="std-adjacent-difference"><a href="#std-adjacent-difference" class="headerlink" title="std::adjacent_difference"></a>std::adjacent_difference</h2><p><code>std::adjacent_difference</code> 是 C++ STL 中的一个函数，用于计算一个序列中相邻元素的差值，并将结果存储到另一个序列中。</p>
<p>其函数签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> OutputIt &gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">adjacent_difference</span><span class="params">( InputIt first, InputIt last, OutputIt d_first )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>first</code> 和 <code>last</code> 是输入序列的迭代器范围，表示要进行差值计算的元素范围。</li>
<li><code>d_first</code> 是输出序列的起始位置迭代器，用于存储相邻元素之间的差值结果。</li>
</ul>
<p>以下是一个简单的示例说明 <code>std::adjacent_difference</code> 函数的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;; <span class="comment">// 示例数据</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">differences</span><span class="params">(numbers.size())</span></span>; <span class="comment">// 用于存储相邻元素差值的容器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算相邻元素的差值</span></span><br><span class="line">    std::<span class="built_in">adjacent_difference</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), differences.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;相邻元素的差值：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; diff : differences) &#123;</span><br><span class="line">        std::cout &lt;&lt; diff &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::adjacent_difference</code> 函数计算了 <code>numbers</code> 中相邻元素的差值，并将结果存储在 <code>differences</code> 容器中。最后，通过迭代输出了相邻元素的差值。</p>
<p>需要注意的是，<code>std::adjacent_difference</code> 函数对于输入序列中的第一个元素会直接复制到输出序列中，而后续元素则会存储与前一个元素的差值。</p>
<h2 id="std-equal"><a href="#std-equal" class="headerlink" title="std::equal"></a>std::equal</h2><p><code>std::equal()</code> 是 C++ 标准模板库中的一个算法，用于检查两个序列是否相等。它比较两个序列中的对应元素，如果两个序列在相同位置上的元素都相等，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2 &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">( InputIt1 first1, InputIt1 last1, InputIt2 first2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2, <span class="keyword">class</span> BinaryPredicate &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">( InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>first1</code> 和 <code>last1</code> 是第一个序列的起始和结束迭代器。</li>
<li><code>first2</code> 是第二个序列的起始迭代器。</li>
<li><code>p</code> 是一个可选的谓词（函数对象或函数指针），用于比较两个元素。</li>
</ul>
<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>first1</code>、<code>last1</code>：定义了第一个序列的范围，包括 <code>first1</code>，但不包括 <code>last1</code>。</li>
<li><code>first2</code>：定义了第二个序列的起始位置。</li>
<li><code>p</code>：如果提供了这个参数，将会用它来比较元素，否则将使用元素类型的 <code>operator==</code> 进行比较。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果两个序列在范围 <code>[first1, last1)</code> 中的相应元素都相等，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isEqual = std::<span class="built_in">equal</span>(vec<span class="number">1.</span><span class="built_in">begin</span>(), vec<span class="number">1.</span><span class="built_in">end</span>(), vec<span class="number">2.</span><span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEqual) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;两个序列相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;两个序列不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::equal()</code> 用于比较两个 <code>std::vector</code> 是否相等。由于它们包含相同的元素且相同顺序，因此会输出 “两个序列相等”。</p>
<h2 id="C-std-equal-自定义操作"><a href="#C-std-equal-自定义操作" class="headerlink" title="C++ std::equal 自定义操作"></a>C++ std::equal 自定义操作</h2><p><code>std::equal</code> 可以接受一个自定义的操作（谓词），以便进行元素的比较。这个谓词可以是一个函数对象或者函数指针，用于执行元素间的自定义比较。</p>
<h3 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2, <span class="keyword">class</span> BinaryPredicate &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">( InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>first1</code> 和 <code>last1</code> 是第一个序列的起始和结束迭代器。</li>
<li><code>first2</code> 是第二个序列的起始迭代器。</li>
<li><code>p</code> 是一个二元谓词，用于比较两个元素。它接受两个参数，分别是两个要比较的元素，返回 <code>bool</code> 类型的结果。</li>
</ul>
<h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>first1</code>、<code>last1</code>：定义了第一个序列的范围，包括 <code>first1</code>，但不包括 <code>last1</code>。</li>
<li><code>first2</code>：定义了第二个序列的起始位置。</li>
<li><code>p</code>：用于比较两个元素的自定义二元谓词。</li>
</ul>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果两个序列在范围 <code>[first1, last1)</code> 中的相应元素使用谓词 <code>p</code> 进行比较都返回 <code>true</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义谓词，比较元素是否相差1</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">customPredicate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a - b == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isEqual = std::<span class="built_in">equal</span>(vec<span class="number">1.</span><span class="built_in">begin</span>(), vec<span class="number">1.</span><span class="built_in">end</span>(), vec<span class="number">2.</span><span class="built_in">begin</span>(), customPredicate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEqual) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;两个序列中对应元素相差1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;两个序列中对应元素不相差1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::equal()</code> 使用了自定义的谓词 <code>customPredicate</code> 来比较两个序列的元素是否相差1。如果两个序列中对应位置的元素相差1，则输出 “两个序列中对应元素相差1”，否则输出 “两个序列中对应元素不相差1”。</p>
<h2 id="std-lexicographical-compare"><a href="#std-lexicographical-compare" class="headerlink" title="std::lexicographical_compare"></a>std::lexicographical_compare</h2><p><code>std::lexicographical_compare</code> 是 C++ 标准库中的一个算法函数，用于比较两个范围的字典序大小关系。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lexicographical_compare</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                             InputIt2 first2, InputIt2 last2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lexicographical_compare</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                             InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first1</code> 和 <code>last1</code> 表示第一个范围的起始和结束位置；</li>
<li><code>first2</code> 和 <code>last2</code> 表示第二个范围的起始和结束位置；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::lexicographical_compare</code> 函数按照字典序对两个范围进行比较。它逐个比较两个范围中的元素，并返回一个布尔值，指示了这两个范围的大小关系。如果第一个范围在字典序上小于第二个范围，则返回 <code>true</code>；如果第一个范围大于等于第二个范围，则返回 <code>false</code>。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个向量的字典序大小关系</span></span><br><span class="line">    <span class="type">bool</span> result = std::<span class="built_in">lexicographical_compare</span>(vec<span class="number">1.</span><span class="built_in">begin</span>(), vec<span class="number">1.</span><span class="built_in">end</span>(), vec<span class="number">2.</span><span class="built_in">begin</span>(), vec<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vec1 is lexicographically less than vec2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vec1 is lexicographically greater than or equal to vec2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::lexicographical_compare</code> 函数被用于比较两个向量 <code>vec1</code> 和 <code>vec2</code> 的字典序大小关系。根据返回的布尔值，输出了两个范围的大小关系。</p>
<p><code>std::lexicographical_compare</code> 对于比较两个范围的字典序关系非常有用。它可用于排序算法的实现，也可用于确定两个序列的顺序关系。</p>
<h2 id="std-remove"><a href="#std-remove" class="headerlink" title="std::remove"></a>std::remove</h2><p><code>std::remove</code> 是 C++ 标准库中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中，用于从序列中移除特定的元素并将其移到序列末尾。但需要注意的是，<code>std::remove</code> 并不会真正删除元素，它只是将要删除的元素移到序列的末尾，并返回一个指向新末尾之后第一个元素的迭代器。</p>
<h3 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">remove</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>first</code>：指向要处理的序列的起始位置的迭代器。</li>
<li><code>last</code>：指向要处理的序列的末尾位置的迭代器（不包含在处理范围内）。</li>
<li><code>value</code>：要移除的特定元素的值。</li>
</ul>
<h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h3><p>返回一个迭代器，指向移除元素后的新的逻辑结尾位置。该位置之后的元素可能是无效值或者是移除元素之前的值。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::remove 移除向量中的值为 2 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> newEnd = std::<span class="built_in">remove</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际删除元素前，可以通过 [numbers.begin(), newEnd) 的范围来访问有效元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;移除元素后的向量内容为: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != newEnd; ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行此代码会输出：<code>移除元素后的向量内容为: 1 3 4 5 6 </code>。在这个例子中，<code>std::remove</code> 用于移除向量中的值为 2 的元素，并返回一个新的逻辑结尾位置的迭代器，指向有效元素的末尾。</p>
<p>注意，<code>std::remove</code> 并不会真正删除元素，而是将要删除的元素移到末尾。如果需要删除这些元素，可以使用向量的成员函数 <code>erase()</code>。</p>
<h2 id="std-unique"><a href="#std-unique" class="headerlink" title="std::unique"></a>std::unique</h2><p><code>std::unique</code> 是 C++ 标准库中 <code>&lt;algorithm&gt;</code> 头文件提供的一个函数，用于在范围中移除连续的重复元素。这个函数的行为是将相邻的重复元素移到范围的末尾，并返回一个指向新的范围末尾的迭代器。之后，可以使用这个迭代器来擦除重复元素。</p>
<p>以下是 <code>std::unique</code> 的详解：</p>
<h3 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIt</span>&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">unique</span><span class="params">(ForwardIt first, ForwardIt last)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>first</code>: 范围的起始位置的迭代器。</li>
<li><code>last</code>: 范围的结束位置的迭代器。</li>
</ul>
<h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h3><p><code>std::unique</code> 返回一个迭代器，指向新范围的末尾。在这个新范围中，不再包含相邻的重复元素。</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>std::unique</code> 只能去除相邻的重复元素。如果要移除所有重复元素，通常需要先使用 <code>std::sort</code> 对范围进行排序。</li>
</ul>
<h3 id="使用示例：-1"><a href="#使用示例：-1" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::unique 移除相邻的重复元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">unique</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 erase 擦除重复元素</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(it, numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::unique</code> 被用于移除相邻的重复元素，然后通过 <code>erase</code> 函数擦除这些元素。最终，输出的结果是不包含相邻重复元素的向量 <code>[1, 2, 3, 4, 5]</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/22/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/24/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
