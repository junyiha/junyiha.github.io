<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/23/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/23/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_26_deque/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_26_deque/" class="post-title-link" itemprop="url">C++_10_26_deque</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <deque>标准库</li>
</ul>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><ul>
<li>deque(double-ended queue的简称)几乎和vector是等同的，但是用的更少</li>
<li>主要区别如下<ul>
<li>不要求元素保存在连续内存中</li>
<li>deque支持首尾两端常量时间的插入和删除操作(vecto只支持尾端的常量时间)</li>
<li>在开头和末尾插入元素时，deque未使迭代器失效</li>
</ul>
</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <deque>标准库</h2><p><code>&lt;deque&gt;</code> 是 C++ 标准库中的头文件，定义了双端队列（double-ended queue）的模板类 <code>std::deque</code>。</p>
<h3 id="std-deque-概述："><a href="#std-deque-概述：" class="headerlink" title="std::deque 概述："></a>std::deque 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;deque&gt;</code></li>
<li><strong>容器类型：</strong> <code>std::deque</code> 是标准库中的容器类型之一，表示双端队列。</li>
<li><strong>特点：</strong><ul>
<li>可以在两端高效地执行插入和删除操作，支持快速的随机访问。</li>
<li>与 <code>std::vector</code> 相似，但在两端插入和删除的操作效率更高，但随机访问的效率稍低。</li>
<li>内部使用多个固定大小的连续存储块来存储数据，允许在两端进行快速插入和删除。</li>
</ul>
</li>
</ul>
<h3 id="主要操作和用法："><a href="#主要操作和用法：" class="headerlink" title="主要操作和用法："></a>主要操作和用法：</h3><ul>
<li><strong>插入和删除操作：</strong><ul>
<li><code>push_front()</code>, <code>push_back()</code>: 在队列的前端或后端插入元素。</li>
<li><code>pop_front()</code>, <code>pop_back()</code>: 从队列的前端或后端删除元素。</li>
</ul>
</li>
<li><strong>随机访问：</strong><ul>
<li>支持 <code>operator[]</code> 和 <code>at()</code> 等方法进行随机访问元素。</li>
</ul>
</li>
<li><strong>大小操作：</strong><ul>
<li><code>size()</code>, <code>empty()</code>: 获取队列的大小和判断是否为空。</li>
</ul>
</li>
<li><strong>其他操作：</strong><ul>
<li><code>front()</code>, <code>back()</code>: 获取队列的第一个和最后一个元素。</li>
<li><code>insert()</code>, <code>erase()</code>: 在指定位置插入或删除元素。</li>
</ul>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; myDeque = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myDeque.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">// 在前端插入元素</span></span><br><span class="line">    myDeque.<span class="built_in">push_back</span>(<span class="number">4</span>); <span class="comment">// 在后端插入元素</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of deque: &quot;</span> &lt;&lt; myDeque.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front element: &quot;</span> &lt;&lt; myDeque.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back element: &quot;</span> &lt;&lt; myDeque.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myDeque.<span class="built_in">pop_front</span>(); <span class="comment">// 删除前端元素</span></span><br><span class="line">    myDeque.<span class="built_in">pop_back</span>(); <span class="comment">// 删除后端元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myDeque) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::deque</code> 的基本操作，包括在队列的前端和后端插入元素、获取队列的大小和头尾元素、删除前后端元素，并且遍历输出了队列中的元素。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <deque>标准库 详解</h2><p><code>&lt;deque&gt;</code> 头文件定义了 C++ 标准库中的 <code>std::deque</code>（双端队列）模板类。Deque（双端队列）是一种数据结构，允许在两端进行高效地插入和删除操作。</p>
<h3 id="std-deque-概述：-1"><a href="#std-deque-概述：-1" class="headerlink" title="std::deque 概述："></a>std::deque 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;deque&gt;</code></li>
<li><strong>容器类型：</strong> <code>std::deque</code> 是标准库中的容器类型之一，表示双端队列。</li>
<li><strong>特点：</strong><ul>
<li>可以在两端高效地执行插入和删除操作，支持快速的随机访问。</li>
<li>与 <code>std::vector</code> 相似，但在两端插入和删除的操作效率更高，但随机访问的效率稍低。</li>
<li>内部使用多个固定大小的连续存储块来存储数据，允许在两端进行快速插入和删除。</li>
</ul>
</li>
</ul>
<h3 id="std-deque-的主要操作和用法："><a href="#std-deque-的主要操作和用法：" class="headerlink" title="std::deque 的主要操作和用法："></a>std::deque 的主要操作和用法：</h3><ul>
<li><strong>插入和删除操作：</strong><ul>
<li><code>push_front()</code>, <code>push_back()</code>: 在队列的前端或后端插入元素。</li>
<li><code>pop_front()</code>, <code>pop_back()</code>: 从队列的前端或后端删除元素。</li>
</ul>
</li>
<li><strong>随机访问：</strong><ul>
<li>支持 <code>operator[]</code> 和 <code>at()</code> 等方法进行随机访问元素。</li>
</ul>
</li>
<li><strong>大小操作：</strong><ul>
<li><code>size()</code>, <code>empty()</code>: 获取队列的大小和判断是否为空。</li>
</ul>
</li>
<li><strong>其他操作：</strong><ul>
<li><code>front()</code>, <code>back()</code>: 获取队列的第一个和最后一个元素。</li>
<li><code>insert()</code>, <code>erase()</code>: 在指定位置插入或删除元素。</li>
</ul>
</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; myDeque = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myDeque.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">// 在前端插入元素</span></span><br><span class="line">    myDeque.<span class="built_in">push_back</span>(<span class="number">4</span>); <span class="comment">// 在后端插入元素</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of deque: &quot;</span> &lt;&lt; myDeque.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front element: &quot;</span> &lt;&lt; myDeque.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back element: &quot;</span> &lt;&lt; myDeque.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myDeque.<span class="built_in">pop_front</span>(); <span class="comment">// 删除前端元素</span></span><br><span class="line">    myDeque.<span class="built_in">pop_back</span>(); <span class="comment">// 删除后端元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myDeque) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::deque</code> 的基本操作，包括在队列的前端和后端插入元素、获取队列的大小和头尾元素、删除前后端元素，并且遍历输出了队列中的元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_24_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_24_list/" class="post-title-link" itemprop="url">C++_10_24_list</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <list>标准库</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul>
<li>list，是一种标准的双链表。list支持链表中任意位置常量时间的元素插入和删除操作，但访问单独元素的速度较慢(线性时间)</li>
<li>list不支持元素的随机访问。list提供的访问元素的方法仅有front()和back()。这两个方法的时间复杂度都是常量时间。对其他元素的访问都必须通过迭代器进行。</li>
<li>list迭代器是双向的，不像vector迭代器那样提供随机访问，这意味着list迭代器之间不能进行加减操作和其他指针运算。例如，如果p是一个list迭代器，那么可以通过++p或–p遍历链表，但是不能使用加减运算符，p+n和p-n都是不可以的</li>
<li>list大小与deque一样，但是和vector不同，list不暴露底层的内存模型，因此，list支持size(), empty()和resize(),但是不支持reserve()和capacity()。</li>
<li>需要注意的是，list的size()方法具有常量时间复杂度。</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <list>标准库</h2><p><code>&lt;list&gt;</code> 是 C++ 标准库中的头文件，定义了双向链表（doubly linked list）的模板类 <code>std::list</code>。双向链表是一种动态数据结构，允许在常量时间内在两端进行插入、删除操作。</p>
<h3 id="std-list-概述："><a href="#std-list-概述：" class="headerlink" title="std::list 概述："></a>std::list 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;list&gt;</code></li>
<li><strong>容器类型：</strong> <code>std::list</code> 是标准库中的容器类型之一，实现了双向链表。</li>
<li><strong>特点：</strong><ul>
<li>元素按插入顺序存储。</li>
<li>支持高效的插入和删除操作，但对于随机访问效率较低。</li>
<li>不支持直接随机访问元素，需要使用迭代器进行访问。</li>
</ul>
</li>
</ul>
<h3 id="主要操作和用法："><a href="#主要操作和用法：" class="headerlink" title="主要操作和用法："></a>主要操作和用法：</h3><ul>
<li><strong>插入和删除操作：</strong> <code>push_back()</code>, <code>push_front()</code>, <code>pop_back()</code>, <code>pop_front()</code> 用于在列表两端插入或删除元素。</li>
<li><strong>迭代器操作：</strong> 使用迭代器进行元素访问、遍历和操作。</li>
<li><strong>大小操作：</strong> <code>size()</code>, <code>empty()</code> 获取列表的大小和判断是否为空。</li>
<li><strong>其他操作：</strong> <code>insert()</code>, <code>erase()</code>, <code>splice()</code> 等用于在指定位置插入、删除、合并列表等操作。</li>
</ul>
<h3 id="基本示例："><a href="#基本示例：" class="headerlink" title="基本示例："></a>基本示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第一个元素</span></span><br><span class="line">    myList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">next</span>(myList.<span class="built_in">begin</span>()); <span class="comment">// 获取迭代器</span></span><br><span class="line">    myList.<span class="built_in">insert</span>(it, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定元素</span></span><br><span class="line">    myList.<span class="built_in">remove</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出剩余元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::list</code> 是一个有用的容器，特别适合在需要频繁插入和删除元素而不需要进行随机访问的场景下使用。通过使用迭代器，您可以在列表中执行各种操作，例如插入、删除和遍历元素，而无需关心内部细节。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <list>标准库 详解</h2><p><code>&lt;list&gt;</code> 是 C++ 标准库中的头文件，定义了双向链表的模板类 <code>std::list</code>。双向链表是一种动态数据结构，允许在两端进行常量时间内的插入和删除操作。</p>
<h3 id="std-list-概述：-1"><a href="#std-list-概述：-1" class="headerlink" title="std::list 概述："></a>std::list 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;list&gt;</code></li>
<li><strong>容器类型：</strong> <code>std::list</code> 是标准库中的容器类型之一，实现了双向链表。</li>
<li><strong>特点：</strong><ul>
<li>元素按插入顺序存储。</li>
<li>支持高效的插入和删除操作，但对于随机访问效率较低。</li>
<li>提供了迭代器支持，允许对链表中的元素进行顺序访问和操作。</li>
</ul>
</li>
</ul>
<h3 id="主要操作和用法：-1"><a href="#主要操作和用法：-1" class="headerlink" title="主要操作和用法："></a>主要操作和用法：</h3><ul>
<li><strong>插入和删除操作：</strong><ul>
<li><code>push_back()</code>, <code>push_front()</code>, <code>pop_back()</code>, <code>pop_front()</code> 用于在列表两端插入或删除元素。</li>
</ul>
</li>
<li><strong>迭代器操作：</strong><ul>
<li>使用迭代器进行元素访问、遍历和操作。</li>
</ul>
</li>
<li><strong>大小操作：</strong><ul>
<li><code>size()</code>, <code>empty()</code> 获取列表的大小和判断是否为空。</li>
</ul>
</li>
<li><strong>插入、删除和移动元素：</strong><ul>
<li><code>insert()</code>, <code>erase()</code>, <code>splice()</code> 等用于在指定位置插入、删除、合并列表等操作。</li>
</ul>
</li>
<li><strong>搜索和修改操作：</strong><ul>
<li><code>find()</code>, <code>remove()</code>, <code>reverse()</code>, <code>sort()</code> 等用于搜索、移除、反转和排序列表中的元素。</li>
</ul>
</li>
</ul>
<h3 id="详细示例："><a href="#详细示例：" class="headerlink" title="详细示例："></a>详细示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第一个元素</span></span><br><span class="line">    myList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">next</span>(myList.<span class="built_in">begin</span>()); <span class="comment">// 获取迭代器</span></span><br><span class="line">    myList.<span class="built_in">insert</span>(it, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定元素</span></span><br><span class="line">    myList.<span class="built_in">remove</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出剩余元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::list</code> 是一个有用的容器，适合在需要频繁插入和删除元素而不需要进行随机访问的场景下使用。通过使用迭代器，您可以在列表中执行各种操作，例如插入、删除和遍历元素，而无需关心内部细节。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <list>标准库 常用的类和函数</h2><p>在C++标准库的<code>&lt;list&gt;</code>头文件中，提供了一些常用的类和函数，主要用于操作双向链表 <code>std::list</code>。</p>
<h3 id="常用的类："><a href="#常用的类：" class="headerlink" title="常用的类："></a>常用的类：</h3><ul>
<li><strong><code>std::list</code>：</strong> 双向链表的模板类，允许在常量时间内在两端进行插入、删除操作。</li>
</ul>
<h3 id="常用的函数和操作："><a href="#常用的函数和操作：" class="headerlink" title="常用的函数和操作："></a>常用的函数和操作：</h3><ul>
<li><strong>插入和删除操作：</strong><ul>
<li><code>push_back()</code>, <code>push_front()</code>: 在链表的尾部或头部插入元素。</li>
<li><code>pop_back()</code>, <code>pop_front()</code>: 从链表的尾部或头部删除元素。</li>
</ul>
</li>
<li><strong>访问元素和迭代器操作：</strong><ul>
<li><code>begin()</code>, <code>end()</code>: 返回指向链表起始和结束的迭代器。</li>
<li><code>front()</code>, <code>back()</code>: 返回链表头部和尾部的元素。</li>
<li><code>insert()</code>, <code>erase()</code>: 在指定位置插入或删除元素。</li>
<li><code>clear()</code>: 清空链表中的所有元素。</li>
</ul>
</li>
<li><strong>大小操作：</strong><ul>
<li><code>size()</code>: 返回链表中元素的数量。</li>
<li><code>empty()</code>: 判断链表是否为空。</li>
</ul>
</li>
<li><strong>其他操作：</strong><ul>
<li><code>remove()</code>: 移除链表中所有与给定值相等的元素。</li>
<li><code>sort()</code>: 对链表中的元素进行排序。</li>
<li><code>merge()</code>: 合并两个已排序的链表。</li>
<li><code>splice()</code>: 将另一个链表的元素移动到当前链表的指定位置。</li>
</ul>
</li>
</ul>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">pop_front</span>();</span><br><span class="line">    myList.<span class="built_in">insert</span>(++myList.<span class="built_in">begin</span>(), <span class="number">4</span>);</span><br><span class="line">    myList.<span class="built_in">remove</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;list&gt;</code> 提供了一系列方法来操作双向链表，这些方法包括在链表头尾插入或删除元素、访问元素、迭代器操作、大小操作、移除指定元素等。通过这些函数，可以方便地对链表进行操作和管理。</p>
<h2 id="std-list-remove"><a href="#std-list-remove" class="headerlink" title="std::list::remove()"></a>std::list::remove()</h2><p><code>std::list::remove()</code> 是 <code>std::list</code> 类提供的成员函数之一，用于移除链表中所有与指定值相等的元素。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span> <span class="params">(<span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>val</code>：要从链表中移除的值。</li>
</ul>
<h3 id="函数作用："><a href="#函数作用：" class="headerlink" title="函数作用："></a>函数作用：</h3><ul>
<li><code>remove()</code> 会在链表中查找与指定值相等的元素，并将它们全部移除。</li>
</ul>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>此函数会一次性移除链表中所有与指定值相等的元素。</li>
<li>移除过程中不会改变链表中元素的相对顺序。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">remove</span>(<span class="number">2</span>); <span class="comment">// 移除所有值为 2 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myList.remove(2)</code> 将移除链表中所有值为 <code>2</code> 的元素。最终输出的链表内容将不包含值为 <code>2</code> 的元素。</p>
<h2 id="std-list-sort"><a href="#std-list-sort" class="headerlink" title="std::list::sort()"></a>std::list::sort()</h2><p><code>std::list::sort()</code> 是 <code>std::list</code> 类提供的成员函数之一，用于对链表中的元素进行排序操作。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数作用：-1"><a href="#函数作用：-1" class="headerlink" title="函数作用："></a>函数作用：</h3><ul>
<li><code>sort()</code> 函数将链表中的元素按升序进行排序。如果链表包含自定义类型的元素，则需要保证该类型支持比较操作符（<code>&lt;</code>）。</li>
</ul>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>由于 <code>std::list</code> 是双向链表，而非连续存储的序列，它采用的排序算法可能与 <code>std::sort</code>（用于连续序列的排序）使用的算法不同。</li>
<li>对于具有较大规模的数据集，<code>std::list::sort()</code> 可能会比 <code>std::sort</code> 慢，因为它的排序复杂度取决于链表的大小，而不是像 <code>std::sort</code> 那样可以使用更高效的排序算法。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">sort</span>(); <span class="comment">// 对链表元素进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myList.sort()</code> 对链表中的整数元素进行升序排序。最终输出的链表内容将按照升序排列。</p>
<h2 id="std-list-merge"><a href="#std-list-merge" class="headerlink" title="std::list::merge()"></a>std::list::merge()</h2><p><code>std::list::merge()</code> 是 <code>std::list</code> 类提供的成员函数之一，用于将两个已排序的链表合并成一个排序链表。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span> <span class="params">(std::list&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>x</code>：另一个已排序链表，将其合并到调用函数的链表中。</li>
</ul>
<h3 id="函数作用：-2"><a href="#函数作用：-2" class="headerlink" title="函数作用："></a>函数作用：</h3><ul>
<li><code>merge()</code> 函数将调用它的链表与参数中的链表 <code>x</code> 合并成一个排序链表。</li>
<li>合并完成后，调用函数的链表将包含原链表和参数链表的所有元素，并按升序排序。</li>
</ul>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>需要保证两个链表都已经按升序排序。</li>
<li>合并完成后，参数链表 <code>x</code> 将为空，并且被合并到调用函数的链表中。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList1 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList2 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myList<span class="number">1.</span><span class="built_in">merge</span>(myList2); <span class="comment">// 将 myList2 合并到 myList1 中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList1) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myList2 size: &quot;</span> &lt;&lt; myList<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myList1.merge(myList2)</code> 将 <code>myList2</code> 合并到 <code>myList1</code> 中。最终输出的 <code>myList1</code> 将包含合并后的所有元素，并且按升序排序。<code>myList2</code> 在合并后将为空。</p>
<h2 id="std-list-splice"><a href="#std-list-splice" class="headerlink" title="std::list::splice()"></a>std::list::splice()</h2><p><code>std::list::splice()</code> 是 <code>std::list</code> 类提供的成员函数之一，用于在两个 <code>std::list</code> 之间移动或合并元素。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator pos, std::list&amp; other)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator pos, std::list&amp; other, iterator it)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator pos, std::list&amp; other, iterator first, iterator last)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pos</code>：指定插入位置的迭代器。</li>
<li><code>other</code>：另一个 <code>std::list</code>。</li>
<li><code>it</code>：另一个 <code>std::list</code> 的迭代器。</li>
<li><code>first</code>, <code>last</code>：另一个 <code>std::list</code> 中指定范围的迭代器。</li>
</ul>
<h3 id="函数作用：-3"><a href="#函数作用：-3" class="headerlink" title="函数作用："></a>函数作用：</h3><ul>
<li>第一个函数将整个 <code>other</code> 链表的元素移动到调用函数的链表中的 <code>pos</code> 位置。</li>
<li>第二个函数将 <code>other</code> 链表中迭代器 <code>it</code> 所指向的元素移动到调用函数的链表中的 <code>pos</code> 位置。</li>
<li>第三个函数将 <code>other</code> 链表中位于 <code>[first, last)</code> 范围内的元素移动到调用函数的链表中的 <code>pos</code> 位置。</li>
</ul>
<h3 id="注意事项：-3"><a href="#注意事项：-3" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>被移动的元素会从 <code>other</code> 链表中删除，并插入到调用函数的链表中指定的位置。</li>
<li>被移动的元素保持它们的相对顺序。</li>
<li>被合并的链表中元素的顺序在移动后将改变。</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = ++myList<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">    myList<span class="number">1.</span><span class="built_in">splice</span>(myList<span class="number">1.</span><span class="built_in">begin</span>(), myList2); <span class="comment">// 将 myList2 整个链表合并到 myList1 的开头</span></span><br><span class="line">    myList<span class="number">1.</span><span class="built_in">splice</span>(myList<span class="number">1.</span><span class="built_in">end</span>(), myList2, it); <span class="comment">// 将 myList2 中的第二个元素插入到 myList1 的末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList1) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList2) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myList1.splice(myList1.begin(), myList2)</code> 将整个 <code>myList2</code> 链表合并到 <code>myList1</code> 的开头，然后 <code>myList1.splice(myList1.end(), myList2, it)</code> 将 <code>myList2</code> 中的第二个元素（通过迭代器 <code>it</code> 定位）插入到 <code>myList1</code> 的末尾。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_27_span/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_27_span/" class="post-title-link" itemprop="url">C++_10_27_span</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <span>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <span>标准库</h2><p>在 C++ 标准库中并没有名为 <code>&lt;span&gt;</code> 的标准头文件或容器。<code>&lt;span&gt;</code> 并不是 C++ 标准库的一部分，而是从 C++20 开始引入的用于表示连续内存区域的非拥有式引用的类模板。其主要用途是对连续内存块进行引用和操作，而不拥有这些内存。</p>
<p><code>&lt;span&gt;</code>通常用于在不拥有内存的情况下表示数据的连续区间，类似于指针和长度的组合。它提供了对这个区间的安全访问，例如遍历、查找等操作，但并不负责内存的生命周期。</p>
<p>C++ 标准库中提供了 <code>std::span</code> 类来实现这个概念，它在 <code>&lt;span&gt;</code> 头文件中定义。</p>
<p>以下是一个简单的示例演示 <code>std::span</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::span&lt;<span class="type">int</span>&gt; <span class="title">mySpan</span><span class="params">(arr, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySpan) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>std::span</code> 被用来引用数组 <code>arr</code> 中的元素。<code>std::span</code> 对这段连续的内存区域提供了一种非拥有式的引用，允许你对这个区间进行安全的遍历和访问操作，但不管理这段内存的生命周期。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_29_stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_29_stack/" class="post-title-link" itemprop="url">C++_10_29_stack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <stack>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <stack>标准库</h2><p><code>&lt;stack&gt;</code> 是 C++ 标准库中的头文件，定义了栈容器适配器 <code>std::stack</code>。</p>
<h3 id="std-stack："><a href="#std-stack：" class="headerlink" title="std::stack："></a>std::stack：</h3><ul>
<li><code>std::stack</code> 是一个基于其他容器（默认使用 <code>std::deque</code>）的封装，提供了栈（LIFO，后进先出）的功能。</li>
<li>栈是一种具有特定限制的容器，只允许在栈顶进行插入和删除操作。</li>
<li>主要特点：<ul>
<li><code>push(const T&amp; val)</code>: 将元素 <code>val</code> 压入栈顶。</li>
<li><code>pop()</code>: 弹出栈顶元素。</li>
<li><code>top()</code>: 返回栈顶元素的引用。</li>
<li><code>empty()</code>: 判断栈是否为空。</li>
<li><code>size()</code>: 返回栈中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; myStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入元素</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of stack: &quot;</span> &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">    myStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出栈中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例展示了 <code>std::stack</code> 的基本使用方法，包括压入元素、访问栈顶元素、弹出栈顶元素，并且遍历输出了栈中的元素。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库  详解"></a>C++ <stack>标准库  详解</h2><p><code>&lt;stack&gt;</code> 是 C++ 标准库中的头文件，定义了栈容器适配器 <code>std::stack</code>，它提供了栈（LIFO，后进先出）数据结构的功能。</p>
<h3 id="std-stack：-1"><a href="#std-stack：-1" class="headerlink" title="std::stack："></a>std::stack：</h3><ul>
<li><code>std::stack</code> 是一个封装了其他容器（默认使用 <code>std::deque</code>）的适配器，实现了栈的功能。</li>
<li>栈是一种限制性的数据结构，只允许在栈顶进行插入（push）和删除（pop）操作。</li>
<li>主要特点：<ul>
<li><code>push(const T&amp; val)</code>: 将元素 <code>val</code> 压入栈顶。</li>
<li><code>pop()</code>: 弹出栈顶元素。</li>
<li><code>top()</code>: 返回栈顶元素的引用。</li>
<li><code>empty()</code>: 判断栈是否为空。</li>
<li><code>size()</code>: 返回栈中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; myStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入元素</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of stack: &quot;</span> &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">    myStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出栈中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，展示了 <code>std::stack</code> 的基本用法，包括压入元素、访问栈顶元素、弹出栈顶元素，并且遍历输出了栈中的元素。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <stack>标准库 常用的类和函数</h2><p>在 C++ <code>&lt;stack&gt;</code> 标准库中，主要的类是 <code>std::stack</code>，而该类主要包含以下常用函数和方法：</p>
<h3 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h3><ol>
<li><strong>std::stack</strong>：<ul>
<li>栈容器适配器类，基于其他容器（默认使用 <code>std::deque</code>）封装而成。</li>
<li>主要特点：<ul>
<li><code>push(const T&amp; val)</code>: 将元素 <code>val</code> 压入栈顶。</li>
<li><code>pop()</code>: 弹出栈顶元素。</li>
<li><code>top()</code>: 返回栈顶元素的引用。</li>
<li><code>empty()</code>: 判断栈是否为空。</li>
<li><code>size()</code>: 返回栈中元素的数量。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="常用函数和方法："><a href="#常用函数和方法：" class="headerlink" title="常用函数和方法："></a>常用函数和方法：</h3><ul>
<li><code>push(const T&amp; val)</code>: 将元素 <code>val</code> 压入栈顶。</li>
<li><code>pop()</code>: 弹出栈顶元素。</li>
<li><code>top()</code>: 返回栈顶元素的引用。</li>
<li><code>empty()</code>: 判断栈是否为空。</li>
<li><code>size()</code>: 返回栈中元素的数量。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; myStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入元素</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of stack: &quot;</span> &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">    myStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出栈中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!myStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::stack</code> 的基本使用方法，包括压入元素、访问栈顶元素、弹出栈顶元素，并且遍历输出了栈中的元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_28_queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_28_queue/" class="post-title-link" itemprop="url">C++_10_28_queue</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <queue>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <queue>标准库</h2><p><code>&lt;queue&gt;</code> 是 C++ 标准库中的头文件，定义了队列容器适配器 <code>std::queue</code>、优先队列 <code>std::priority_queue</code>，以及辅助队列的基本操作。</p>
<h3 id="std-queue："><a href="#std-queue：" class="headerlink" title="std::queue："></a>std::queue：</h3><ul>
<li><code>std::queue</code> 是一个基于队列的容器适配器，底层使用其他容器（默认使用 <code>std::deque</code>）实现。</li>
<li>队列是一种先进先出（FIFO）的数据结构，允许在队列的末尾（back）插入元素，从队列的前端（front）删除元素。</li>
<li>主要操作：<ul>
<li><code>push()</code>: 在队尾插入元素。</li>
<li><code>pop()</code>: 从队首删除元素。</li>
<li><code>front()</code>: 访问队首元素。</li>
<li><code>back()</code>: 访问队尾元素。</li>
<li><code>empty()</code>: 判断队列是否为空。</li>
<li><code>size()</code>: 获取队列中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="std-priority-queue："><a href="#std-priority-queue：" class="headerlink" title="std::priority_queue："></a>std::priority_queue：</h3><ul>
<li><code>std::priority_queue</code> 是一个基于堆的优先队列容器适配器，底层使用堆来管理元素。</li>
<li>优先队列是一种特殊的队列，它保证了每次弹出元素时都是优先级最高（根据默认的比较器或自定义的比较器）的元素。</li>
<li>主要操作：<ul>
<li><code>push()</code>: 插入元素。</li>
<li><code>pop()</code>: 弹出优先级最高的元素。</li>
<li><code>top()</code>: 访问优先级最高的元素。</li>
<li><code>empty()</code>: 判断优先队列是否为空。</li>
<li><code>size()</code>: 获取优先队列中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::queue</span></span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; myQueue;</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问队首元素</span></span><br><span class="line">        myQueue.<span class="built_in">pop</span>(); <span class="comment">// 弹出队首元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::priority_queue</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; myPriorityQueue;</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myPriorityQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myPriorityQueue.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问优先级最高的元素</span></span><br><span class="line">        myPriorityQueue.<span class="built_in">pop</span>(); <span class="comment">// 弹出优先级最高的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>std::queue</code> 和 <code>std::priority_queue</code>。<code>std::queue</code> 用于创建基本的先进先出队列，而 <code>std::priority_queue</code> 则创建一个基于堆的优先队列。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <queue>标准库 详解</h2><p><code>&lt;queue&gt;</code> 是 C++ 标准库中的头文件，提供了队列容器适配器 <code>std::queue</code> 和优先队列容器适配器 <code>std::priority_queue</code>。</p>
<h3 id="std-queue：-1"><a href="#std-queue：-1" class="headerlink" title="std::queue："></a>std::queue：</h3><ul>
<li><code>std::queue</code> 是一个基于队列的容器适配器，用于实现先进先出（FIFO）的数据结构。</li>
<li>默认使用 <code>std::deque</code> 作为其底层容器，但也可以使用其他支持 <code>front()</code>, <code>back()</code>, <code>push_back()</code>, <code>pop_front()</code> 操作的容器。</li>
<li>主要特点：<ul>
<li><code>push()</code>: 在队列的末尾插入元素。</li>
<li><code>pop()</code>: 从队列的开头删除元素。</li>
<li><code>front()</code>: 访问队列的第一个元素。</li>
<li><code>back()</code>: 访问队列的最后一个元素。</li>
<li><code>empty()</code>: 判断队列是否为空。</li>
<li><code>size()</code>: 返回队列中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="std-priority-queue：-1"><a href="#std-priority-queue：-1" class="headerlink" title="std::priority_queue："></a>std::priority_queue：</h3><ul>
<li><code>std::priority_queue</code> 是基于堆的优先队列容器适配器。</li>
<li>它与普通的队列不同，其中的元素按照特定的比较器（默认为 <code>std::less</code>）以堆排序的方式进行管理。</li>
<li>主要特点：<ul>
<li><code>push()</code>: 插入元素。</li>
<li><code>pop()</code>: 弹出优先级最高的元素。</li>
<li><code>top()</code>: 访问优先级最高的元素。</li>
<li><code>empty()</code>: 判断优先队列是否为空。</li>
<li><code>size()</code>: 返回优先队列中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::queue</span></span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; myQueue;</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front of queue: &quot;</span> &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; std::endl; <span class="comment">// 访问队首元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back of queue: &quot;</span> &lt;&lt; myQueue.<span class="built_in">back</span>() &lt;&lt; std::endl; <span class="comment">// 访问队尾元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问队首元素</span></span><br><span class="line">        myQueue.<span class="built_in">pop</span>(); <span class="comment">// 弹出队首元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::priority_queue</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; myPriorityQueue;</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myPriorityQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myPriorityQueue.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 访问优先级最高的元素</span></span><br><span class="line">        myPriorityQueue.<span class="built_in">pop</span>(); <span class="comment">// 弹出优先级最高的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用 <code>std::queue</code> 和 <code>std::priority_queue</code> 进行基本操作。<code>std::queue</code> 用于创建基本的先进先出队列，而 <code>std::priority_queue</code> 用于创建一个基于堆的优先队列。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <queue>标准库 常用的类和函数</h2><p>在 <code>&lt;queue&gt;</code> 标准库中，常用的类包括 <code>std::queue</code> 和 <code>std::priority_queue</code>，以及与这两个类相关的函数。</p>
<h3 id="常用类："><a href="#常用类：" class="headerlink" title="常用类："></a>常用类：</h3><ol>
<li><p><strong>std::queue</strong>：</p>
<ul>
<li>定义：基于队列的容器适配器，实现了先进先出（FIFO）的数据结构。</li>
<li>主要操作：<ul>
<li><code>push()</code>: 在队尾插入元素。</li>
<li><code>pop()</code>: 从队首删除元素。</li>
<li><code>front()</code>: 访问队首元素。</li>
<li><code>back()</code>: 访问队尾元素。</li>
<li><code>empty()</code>: 判断队列是否为空。</li>
<li><code>size()</code>: 返回队列中元素的数量。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>std::priority_queue</strong>：</p>
<ul>
<li>定义：基于堆的优先队列容器适配器，元素以堆排序方式管理。</li>
<li>主要操作：<ul>
<li><code>push()</code>: 插入元素。</li>
<li><code>pop()</code>: 弹出优先级最高的元素。</li>
<li><code>top()</code>: 访问优先级最高的元素。</li>
<li><code>empty()</code>: 判断优先队列是否为空。</li>
<li><code>size()</code>: 返回优先队列中元素的数量。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ul>
<li>除了类自身的成员函数外，<code>&lt;queue&gt;</code> 还提供了一些与队列和优先队列相关的方法。主要是 <code>std::make_heap</code>、<code>std::push_heap</code>、<code>std::pop_heap</code> 和 <code>std::sort_heap</code>，这些函数用于堆操作，可以用于处理堆数据结构。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::queue</span></span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; myQueue;</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front of queue: &quot;</span> &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back of queue: &quot;</span> &lt;&lt; myQueue.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myQueue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::priority_queue</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; myPriorityQueue;</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!myPriorityQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myPriorityQueue.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myPriorityQueue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例演示了 <code>std::queue</code> 和 <code>std::priority_queue</code> 的基本使用方法，以及它们的一些常用操作。</p>
<h2 id="std-queue"><a href="#std-queue" class="headerlink" title="std::queue"></a>std::queue</h2><p><code>std::queue</code> 是 C++ 标准库中定义的队列容器适配器，通常基于其他容器（默认使用 <code>std::deque</code>）来实现队列的功能。</p>
<h3 id="主要特点和操作："><a href="#主要特点和操作：" class="headerlink" title="主要特点和操作："></a>主要特点和操作：</h3><ul>
<li><strong>特点：</strong><ul>
<li>实现了先进先出（FIFO）的数据结构。</li>
<li>提供了简单的接口，对底层容器进行了封装，使其行为像一个队列。</li>
</ul>
</li>
<li><strong>主要操作：</strong><ul>
<li><code>push(const T&amp; val)</code>: 将元素 <code>val</code> 插入队尾。</li>
<li><code>pop()</code>: 移除队首元素。</li>
<li><code>front()</code>: 返回队首元素的引用。</li>
<li><code>back()</code>: 返回队尾元素的引用。</li>
<li><code>empty()</code>: 判断队列是否为空。</li>
<li><code>size()</code>: 返回队列中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; myQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问队首和队尾元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front of queue: &quot;</span> &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back of queue: &quot;</span> &lt;&lt; myQueue.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除队首元素</span></span><br><span class="line">    myQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出队列中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myQueue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，展示了 <code>std::queue</code> 的基本用法，包括插入元素、访问队首和队尾元素、移除队首元素，并且遍历输出了队列中的元素。</p>
<h2 id="std-priority-queue"><a href="#std-priority-queue" class="headerlink" title="std::priority_queue"></a>std::priority_queue</h2><p><code>std::priority_queue</code> 是 C++ 标准库中定义的优先队列容器适配器，基于堆的数据结构实现。</p>
<h3 id="主要特点和操作：-1"><a href="#主要特点和操作：-1" class="headerlink" title="主要特点和操作："></a>主要特点和操作：</h3><ul>
<li><strong>特点：</strong><ul>
<li>实现了优先队列的功能，元素按照特定的比较器（默认为 <code>std::less</code>，通常为大顶堆）以堆排序方式管理。</li>
<li>元素的弹出和插入操作具有特定的优先级，最高优先级元素始终处于队列的顶部。</li>
</ul>
</li>
<li><strong>主要操作：</strong><ul>
<li><code>push(const T&amp; val)</code>: 插入元素 <code>val</code> 到优先队列中。</li>
<li><code>pop()</code>: 移除优先级最高的元素。</li>
<li><code>top()</code>: 返回优先级最高的元素的引用。</li>
<li><code>empty()</code>: 判断优先队列是否为空。</li>
<li><code>size()</code>: 返回优先队列中元素的数量。</li>
</ul>
</li>
</ul>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; myPriorityQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问优先级最高的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top of priority queue: &quot;</span> &lt;&lt; myPriorityQueue.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除优先级最高的元素</span></span><br><span class="line">    myPriorityQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出优先队列中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!myPriorityQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; myPriorityQueue.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myPriorityQueue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例展示了 <code>std::priority_queue</code> 的基本用法，包括插入元素、访问优先级最高的元素、移除优先级最高的元素，并且遍历输出了优先队列中的元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_2_algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_2_algorithm/" class="post-title-link" itemprop="url">C++_10_2_algorithm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><algorithm>标准库学习笔记</li>
</ul>
<h2 id="algorithm-中所有算法"><a href="#algorithm-中所有算法" class="headerlink" title="algorithm 中所有算法"></a>algorithm 中所有算法</h2><ul>
<li>名称                    描述</li>
<li>adjacent_find	            搜索相等或满足指定条件的两个相邻元素。</li>
<li>all_of	                当给定范围中的每个元素均满足条件时返回 true。</li>
<li>any_of	                当指定元素范围中至少有一个元素满足条件时返回 true。</li>
<li>binary_search	            测试已排序的范围中是否有等于指定值的元素，或在二元谓词指定的意义上与指定值等效的元素。</li>
<li>clamp	    </li>
<li>copy	                    将一个源范围中的元素值分配到目标范围，循环访问元素的源序列并将它们分配在一个向前方向的新位置。</li>
<li>copy_backward	            将一个源范围中的元素值分配到目标范围，循环访问元素的源序列并将它们分配在一个向后方向的新位置。</li>
<li>copy_if	                复制给定范围中对于指定条件为 true 的所有元素。</li>
<li>copy_n	                复制指定数量的元素。</li>
<li>count	                    返回范围中其值与指定值匹配的元素的数量。</li>
<li>count_if	                返回范围中其值与指定条件匹配的元素的数量。</li>
<li>equal	                    逐个元素比较两个范围是否相等或是否在二元谓词指定的意义上等效。</li>
<li>equal_range	            在排序的范围中查找符合以下条件的位置对：第一个位置小于或等效于指定元素的位置，第二个位置大于此元素位置，等效意义或用于在序列中建立位置的排序可通过二元谓词指定。</li>
<li>fill	                    将相同的新值分配给指定范围中的每个元素。</li>
<li>fill_n	                将新值分配给以特定元素开始的范围中的指定数量的元素。</li>
<li>find	                    在范围中找到具有指定值的元素的第一个匹配项位置。</li>
<li>find_end	                在范围中查找与指定序列相同的最后一个序列，或在二元谓词指定的意义上等效的最后一个序列。</li>
<li>find_first_of	            在目标范围中搜索若干值中任意值的第一个匹配项，或搜索在二元谓词指定的意义上等效于指定元素集的若干元素中任意元素的第一个匹配项。</li>
<li>find_if	                在范围中找到满足指定条件的元素的第一个匹配项位置。</li>
<li>find_if_not	            返回指示的范围中不满足条件的第一个元素。</li>
<li>for_each	                将指定的函数对象按向前顺序应用于范围中的每个元素并返回此函数对象。</li>
<li>for_each_n	    </li>
<li>generate	                将函数对象生成的值分配给范围中的每个元素。</li>
<li>generate_n	            将函数对象生成的值分配给范围中指定数量的元素，并返回到超出最后一个分配值的下一位置。</li>
<li>includes	                测试一个排序的范围是否包含另一排序范围中的所有元素，其中元素之间的排序或等效条件可通过二元谓词指定。</li>
<li>inplace_merge	            将两个连续的排序范围中的元素合并为一个排序范围，其中排序条件可通过二元谓词指定。</li>
<li>is_heap	                如果指定范围中的元素形成堆，则返回 true。</li>
<li>is_heap_until	            如果指定范围形成直到最后一个元素的堆，则返回 true。</li>
<li>is_partitioned	        如果给定范围中对某个条件测试为 true 的所有元素在测试为 true 的所有元素之前，则返回 false。</li>
<li>is_permutation	        确定给定范围的元素是否形成有效排列。</li>
<li>is_sorted	                如果指定范围中的元素按顺序排序，则返回 true。</li>
<li>is_sorted_until	        如果指定范围中的元素按顺序排序，则返回 true。</li>
<li>iter_swap	                交换由一对指定迭代器引用的两个值。</li>
<li>lexicographical_compare	逐个元素比较两个序列以确定其中的较小序列。</li>
<li>lower_bound	            在排序的范围中查找其值大于或等效于指定值的第一个元素的位置，其中排序条件可通过二元谓词指定。</li>
<li>make_heap	                将指定范围中的元素转换到第一个元素是最大元素的堆中，其中排序条件可通过二元谓词指定。</li>
<li>max	                    比较两个对象并返回较大对象，其中排序条件可通过二元谓词指定。</li>
<li>max_element	            在指定范围中查找最大元素的第一个匹配项，其中排序条件可通过二元谓词指定。</li>
<li>merge	                    将两个排序的源范围中的所有元素合并为一个排序的目标范围，其中排序条件可通过二元谓词指定。</li>
<li>min	                    比较两个对象并返回较小对象，其中排序条件可通过二元谓词指定。</li>
<li>min_element	            在指定范围中查找最小元素的第一个匹配项，其中排序条件可通过二元谓词指定。</li>
<li>minmax	                比较两个输入参数，并按最小到最大的顺序将它们作为参数对返回。</li>
<li>minmax_element	        在一次调用中执行由 min_element 和 max_element 执行的操作。</li>
<li>mismatch	                逐个元素比较两个范围是否相等或是否在二元谓词指定的意义上等效，并找到出现不同的第一个位置。</li>
<li><alg> move	            移动与指定范围关联的元素。</li>
<li>move_backward	            将一个迭代器的元素移动到另一迭代器。 移动从指定范围的最后一个元素开始，并在此范围的第一个元素结束。</li>
<li>next_permutation	        重新排序范围中的元素，以便使用按字典顺序的下一个更大排列（如果有）替换原有排序，其中“下一个”的意义可通过二元谓词指定。</li>
<li>none_of	                当给定范围中没有元素满足条件时返回 true。</li>
<li>nth_element	            对范围内的元素分区，正确找到范围中序列的第 n 个元素，以使序列中位于此元素之前的所有元素小于或等于此元素，位于此元素之后的所有元素大于或等于此元素。</li>
<li>partial_sort	            将范围中指定数量的较小元素按非降序顺序排列，或根据二元谓词指定的排序条件排列。</li>
<li>partial_sort_copy	        将源范围中的元素复制到目标范围，其中源元素按降序或二元谓词指定的其他顺序排序。</li>
<li>partition	                将范围中的元素分为两个不相交的集，满足一元谓词的元素在不满足一元谓词的元素之前。</li>
<li>partition_copy	        将条件为 true 的元素复制到一个目标，将条件为 false 的元素复制到另一目标。 元素必须来自于指定范围。</li>
<li>partition_point	        返回给定范围中不满足条件的第一个元素。 元素经过排序，满足条件的元素在不满足条件的元素之前。</li>
<li>pop_heap	                移除从堆顶到范围中倒数第二个位置之间的最大元素，然后将剩余元素形成新堆。</li>
<li>prev_permutation	        重新排序范围中的元素，以便使用按字典顺序的下一个更大排列（如果有）替换原有排序，其中“下一个”的意义可通过二元谓词指定。</li>
<li>push_heap	                将范围末尾的元素添加到包括范围中前面元素的现有堆中。</li>
<li>random_shuffle	        将范围中 N 个元素的序列重新排序为随机 N! 种序列中的 可能排列之一。</li>
<li>remove	                从给定范围中消除指定值，而不影响剩余元素的顺序，并返回不包含指定值的新范围的末尾。</li>
<li>remove_copy	            将源范围中的元素复制到目标范围（不复制具有指定值的元素），而不影响剩余元素的顺序，并返回新目标范围的末尾。</li>
<li>remove_copy_if	        将源范围中的元素复制到目标范围（不复制满足谓词的元素），而不影响剩余元素的顺序，并返回新目标范围的末尾。</li>
<li>remove_if	                从给定范围中消除满足谓词的元素，而不影响剩余元素的顺序，并返回不包含指定值的新范围的末尾。</li>
<li>replace	                检查范围中的每个元素，并替换与指定值匹配的元素。</li>
<li>replace_copy	            检查源范围中的每个元素，并替换与指定值匹配的元素，同时将结果复制到新的目标范围。</li>
<li>replace_copy_if	        检查源范围中的每个元素，并替换满足指定谓词的元素，同时将结果复制到新的目标范围。</li>
<li>replace_if	            检查范围中的每个元素，并替换满足指定谓词的元素。</li>
<li>reverse	                反转范围中元素的顺序。</li>
<li>reverse_copy	            反转源范围中元素的顺序，同时将这些元素复制到目标范围</li>
<li>rotate	                交换两个相邻范围中的元素。</li>
<li>rotate_copy	            交换源范围中两个相邻范围内的元素，并将结果复制到目标范围。</li>
<li>sample	</li>
<li>search	                在目标范围中搜索其元素与给定序列中的元素相等或在二元谓词指定的意义上等效于给定序列中的元素的序列的第一个匹配项。</li>
<li>search_n	                在范围中搜索具有特定值或按二元谓词的指定与此值相关的指定数量的元素。</li>
<li>set_difference	        将属于一个排序的源范围、但不属于另一排序的源范围的所有元素相并到一个排序的目标范围，其中排序条件可通过二元谓词指定。</li>
<li>set_intersection	        将属于两个排序的源范围的所有元素相并为一个排序的目标范围，其中排序条件可通过二元谓词指定。</li>
<li>set_symmetric_difference	将属于一个而不是两个排序的源范围的所有元素相并为一个排序的目标范围，其中排序条件可通过二元谓词指定。</li>
<li>set_union	                将至少属于两个排序的源范围之一的所有元素相并为一个排序的目标范围，其中排序条件可通过二元谓词指定。</li>
<li>sort	                    将指定范围中的元素按非降序顺序排列，或根据二元谓词指定的排序条件排列。</li>
<li>shuffle	                使用随机数生成器重新排列给定范围中的元素。</li>
<li>sort_heap	                将堆转换为排序的范围。</li>
<li>stable_partition	        将范围中的元素分为两个不相交的集，满足一元谓词的元素在不满足一元谓词的元素之前，并保留等效元素的相对顺序。</li>
<li>stable_sort	            将指定范围中的元素按非降序顺序排列，或根据二元谓词指定的排序条件排列，并保留等效元素的相对顺序。</li>
<li>swap	                    在两种类型的对象之间交换元素值，将第一个对象的内容分配给第二个对象，将第二个对象的内容分配给第一个对象。</li>
<li>swap_ranges	            将一个范围中的元素与另一大小相等的范围中的元素交换。</li>
<li>transform	                将指定的函数对象应用于源范围中的每个元素或两个源范围中的元素对，并将函数对象的返回值复制到目标范围。</li>
<li>unique	                移除指定范围中彼此相邻的重复元素。</li>
<li>unique_copy	            将源范围中的元素复制到目标范围，彼此相邻的重复元素除外。</li>
<li>upper_bound	            在排序的范围中查找其值大于指定值的第一个元素的位置，其中排序条件可通过二元谓词指定。</li>
</ul>
<h2 id="C-是什么"><a href="#C-是什么" class="headerlink" title="C++ 是什么"></a>C++ <algorithm>是什么</h2><p><code>&lt;algorithm&gt;</code> 是 C++ 标准库中提供了一系列泛型算法的头文件。这些算法可以用于对数据结构（如数组、容器、迭代器等）执行各种操作，包括搜索、排序、合并、变换等。</p>
<p>这个头文件包含了许多标准的算法，这些算法都是泛型的，意味着它们不仅适用于特定类型的数据，而且可以用于不同的数据类型。这些算法可以直接用于标准容器（如 vector、list、deque 等）中，也可以用于普通数组、迭代器等容器类型。</p>
<p>以下是 <code>&lt;algorithm&gt;</code> 头文件中一些常用的算法：</p>
<ol>
<li><p><strong>排序算法</strong>：如 <code>std::sort</code>、<code>std::stable_sort</code>、<code>std::partial_sort</code>、<code>std::nth_element</code> 等，用于对元素序列进行排序。</p>
</li>
<li><p><strong>搜索算法</strong>：例如 <code>std::find</code>、<code>std::binary_search</code>、<code>std::lower_bound</code>、<code>std::upper_bound</code> 等，用于在序列中查找元素。</p>
</li>
<li><p><strong>数值算法</strong>：如 <code>std::accumulate</code>、<code>std::count</code>、<code>std::min</code>、<code>std::max</code>、<code>std::accumulate</code> 等，用于对数值序列执行操作。</p>
</li>
<li><p><strong>集合算法</strong>：包括 <code>std::merge</code>、<code>std::set_intersection</code>、<code>std::set_union</code>、<code>std::set_difference</code> 等，用于对集合执行操作。</p>
</li>
<li><p><strong>变换算法</strong>：例如 <code>std::transform</code>、<code>std::copy</code>、<code>std::reverse</code>、<code>std::rotate</code> 等，用于对序列执行变换。</p>
</li>
<li><p><strong>比较和交换算法</strong>：如 <code>std::swap</code>、<code>std::swap_ranges</code>、<code>std::equal</code>、<code>std::lexicographical_compare</code> 等，用于比较和交换元素。</p>
</li>
</ol>
<p>这些算法提供了许多常见的操作，可以方便地对数据进行处理和操作。使用 <code>&lt;algorithm&gt;</code> 中的这些函数，可以使得编写 C++ 代码更加简洁、高效和易于理解。</p>
<h2 id="STL-常用算法"><a href="#STL-常用算法" class="headerlink" title="STL 常用算法"></a>STL 常用算法</h2><p>STL（Standard Template Library）提供了许多常用的算法，这些算法分为多个类别，涵盖了各种操作，包括查找、排序、转换等。下面是一些常用的STL算法：</p>
<ol>
<li><p><strong>非修改序列操作</strong>：</p>
<ul>
<li><code>std::for_each</code>: 对容器中的每个元素执行指定操作。</li>
<li><code>std::count</code>: 统计容器中满足指定条件的元素个数。</li>
<li><code>std::find</code>: 在容器中查找指定元素，并返回第一个匹配到的位置。</li>
<li><code>std::count_if</code>: 统计容器中满足指定条件的元素个数。</li>
</ul>
</li>
<li><p><strong>修改序列操作</strong>：</p>
<ul>
<li><code>std::copy</code>: 将一个容器中的元素复制到另一个容器中。</li>
<li><code>std::transform</code>: 对容器中的元素应用指定的操作，并将结果存储到另一个容器中。</li>
<li><code>std::replace</code>: 将容器中的指定值替换为另一个值。</li>
<li><code>std::fill</code>: 将容器中的元素设置为指定值。</li>
</ul>
</li>
<li><p><strong>排序和查找操作</strong>：</p>
<ul>
<li><code>std::sort</code>: 对容器中的元素进行排序。</li>
<li><code>std::binary_search</code>: 在已排序的容器中进行二分查找。</li>
<li><code>std::merge</code>: 合并两个已排序的序列到一个新序列中。</li>
</ul>
</li>
<li><p><strong>数值操作</strong>：</p>
<ul>
<li><code>std::accumulate</code>: 对容器中的元素进行累积操作。</li>
<li><code>std::min_element</code> &#x2F; <code>std::max_element</code>: 找到容器中最小或最大的元素。</li>
<li><code>std::inner_product</code>: 计算两个容器的内积。</li>
</ul>
</li>
</ol>
<p>这些算法仅是STL提供的众多算法中的一部分。它们都在 <code>&lt;algorithm&gt;</code> 头文件中定义。通过使用这些算法，可以简化代码并提高程序的效率，因为它们提供了可靠且经过优化的实现。</p>
<h2 id="C-罗列出所有的算法"><a href="#C-罗列出所有的算法" class="headerlink" title="C++  罗列出所有的算法"></a>C++ <algorithm> 罗列出所有的算法</h2><p><code>&lt;algorithm&gt;</code> 头文件中包含的算法非常多，以下是其中的一部分。请注意，这里列举的不是所有的算法，仅是一些常用的算法。具体的算法列表和详细描述可以参考 C++ 标准文档。</p>
<ol>
<li><p><strong>查找算法：</strong></p>
<ul>
<li><code>std::find</code></li>
<li><code>std::find_if</code></li>
<li><code>std::find_if_not</code></li>
<li><code>std::find_end</code></li>
<li><code>std::find_first_of</code></li>
<li><code>std::adjacent_find</code></li>
<li><code>std::binary_search</code></li>
<li><code>std::lower_bound</code></li>
<li><code>std::upper_bound</code></li>
<li><code>std::equal_range</code></li>
</ul>
</li>
<li><p><strong>排序算法：</strong></p>
<ul>
<li><code>std::sort</code></li>
<li><code>std::stable_sort</code></li>
<li><code>std::partial_sort</code></li>
<li><code>std::partial_sort_copy</code></li>
<li><code>std::is_sorted</code></li>
<li><code>std::is_sorted_until</code></li>
<li><code>std::nth_element</code></li>
</ul>
</li>
<li><p><strong>排列组合算法：</strong></p>
<ul>
<li><code>std::next_permutation</code></li>
<li><code>std::prev_permutation</code></li>
<li><code>std::rotate</code></li>
<li><code>std::rotate_copy</code></li>
</ul>
</li>
<li><p><strong>算术运算算法：</strong></p>
<ul>
<li><code>std::accumulate</code></li>
<li><code>std::inner_product</code></li>
<li><code>std::partial_sum</code></li>
<li><code>std::exclusive_scan</code></li>
<li><code>std::inclusive_scan</code></li>
<li><code>std::transform</code></li>
</ul>
</li>
<li><p><strong>集合操作算法：</strong></p>
<ul>
<li><code>std::merge</code></li>
<li><code>std::set_union</code></li>
<li><code>std::set_intersection</code></li>
<li><code>std::set_difference</code></li>
<li><code>std::set_symmetric_difference</code></li>
</ul>
</li>
<li><p><strong>删除和替换算法：</strong></p>
<ul>
<li><code>std::remove</code></li>
<li><code>std::remove_if</code></li>
<li><code>std::remove_copy</code></li>
<li><code>std::replace</code></li>
<li><code>std::replace_if</code></li>
<li><code>std::replace_copy</code></li>
<li><code>std::swap_ranges</code></li>
<li><code>std::unique</code></li>
<li><code>std::unique_copy</code></li>
</ul>
</li>
<li><p><strong>操作范围算法：</strong></p>
<ul>
<li><code>std::copy</code></li>
<li><code>std::copy_if</code></li>
<li><code>std::copy_n</code></li>
<li><code>std::copy_backward</code></li>
<li><code>std::move</code></li>
<li><code>std::move_backward</code></li>
<li><code>std::fill</code></li>
<li><code>std::fill_n</code></li>
<li><code>std::generate</code></li>
<li><code>std::generate_n</code></li>
</ul>
</li>
<li><p><strong>其他算法：</strong></p>
<ul>
<li><code>std::reverse</code></li>
<li><code>std::reverse_copy</code></li>
<li><code>std::rotate</code></li>
<li><code>std::rotate_copy</code></li>
<li><code>std::shuffle</code></li>
<li><code>std::random_shuffle</code></li>
<li><code>std::count</code></li>
<li><code>std::count_if</code></li>
<li><code>std::for_each</code></li>
</ul>
</li>
</ol>
<p>这只是其中的一小部分，还有很多其他算法。详细信息和用法可以参考 C++ 标准文档。</p>
<h2 id="C-标准库-std-sort-详解"><a href="#C-标准库-std-sort-详解" class="headerlink" title="C++ 标准库 std::sort 详解"></a>C++ <algorithm>标准库 std::sort 详解</h2><p><code>std::sort</code> 是 C++ 标准库 <code>&lt;algorithm&gt;</code> 中的一个函数，用于对指定范围内的元素进行排序。它采用快速排序（Quick Sort）或者其他高效的排序算法来实现。</p>
<p>以下是 <code>std::sort</code> 函数的详细说明：</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>first</code>：要排序范围的起始位置（可以是迭代器）。</li>
<li><code>last</code>：要排序范围的结束位置（不包括结束位置的元素）。</li>
<li><code>comp</code>（可选）：可选的比较函数对象，用于定义排序顺序。如果不提供此参数，则默认使用 <code>&lt;</code> 运算符进行元素比较。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><p><code>std::sort</code> 函数用于对迭代器范围 <code>[first, last)</code> 中的元素进行排序。该函数可以用于数组或标准库容器（如 vector、deque、list 等）。</p>
</li>
<li><p>默认情况下，<code>std::sort</code> 会按升序对元素进行排序，但也可以通过传递自定义的比较函数对象来定义其他排序顺序。</p>
</li>
</ul>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); <span class="comment">// 默认按升序排序</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>std::sort</code> 函数可以对整数、浮点数、字符串、自定义类型等元素进行排序。</li>
<li>对于自定义类型，如果没有提供自定义的比较函数，需要确保该类型的 <code>&lt;</code> 操作符或者提供了可供 <code>std::sort</code> 使用的比较函数。</li>
<li>对于自定义排序顺序，可以传递一个自定义的比较函数对象作为 <code>comp</code> 参数。</li>
</ul>
<p><code>std::sort</code> 是一个高效的排序算法，其时间复杂度通常为 O(n log n)，对大多数情况下的排序操作都能提供较好的性能。</p>
<h2 id="C-标准库-std-sort-自定义类型排序"><a href="#C-标准库-std-sort-自定义类型排序" class="headerlink" title="C++ 标准库 std::sort 自定义类型排序"></a>C++ <algorithm>标准库 std::sort 自定义类型排序</h2><p>当你想要对自定义类型的对象进行排序时，你可以通过提供比较函数或者重载对象的 <code>&lt;</code> 操作符来告诉 <code>std::sort</code> 如何进行排序。下面是一个示例，展示了如何在自定义类中使用 <code>std::sort</code> 进行排序：</p>
<p>假设有一个自定义的 <code>Person</code> 类，具有姓名和年龄字段，你想按照年龄对 <code>Person</code> 对象进行排序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Person 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载小于运算符，按照年龄升序排序</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Person&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age &lt; other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Person 对象的 vector</span></span><br><span class="line">    std::vector&lt;Person&gt; people = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;David&quot;</span>, <span class="number">22</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Order: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; person : people) &#123;</span><br><span class="line">        std::cout &lt;&lt; person.name &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; person.age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::sort 对 Person 对象按年龄升序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSorted by Age: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; person : people) &#123;</span><br><span class="line">        std::cout &lt;&lt; person.name &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; person.age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>Person</code> 类中重载了 <code>&lt;</code> 操作符，根据 <code>age</code> 成员变量的值进行比较。然后在 <code>main</code> 函数中，使用 <code>std::sort</code> 对 <code>Person</code> 对象的 <code>std::vector</code> 按照年龄进行排序。</p>
<p>这个示例展示了如何使用 <code>std::sort</code> 进行自定义类型的对象排序，只需确保提供了适当的比较方法，无论是重载 <code>&lt;</code> 运算符还是提供自定义的比较函数对象。</p>
<h2 id="C-标准库-std-sort-自定义类型排序-提供比较函数"><a href="#C-标准库-std-sort-自定义类型排序-提供比较函数" class="headerlink" title="C++ 标准库 std::sort 自定义类型排序 提供比较函数"></a>C++ <algorithm>标准库 std::sort 自定义类型排序 提供比较函数</h2><p>当使用 <code>std::sort</code> 对自定义类型进行排序时，你可以通过提供一个自定义的比较函数来定义排序规则。这个自定义的比较函数将告诉 <code>std::sort</code> 如何比较两个自定义类型的对象。下面是一个示例，展示了如何使用比较函数对自定义类型进行排序：</p>
<p>假设有一个自定义的 <code>Book</code> 类，包含书名和出版年份字段，你想按照出版年份对 <code>Book</code> 对象进行排序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Book 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string title;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Book</span>(<span class="type">const</span> std::string&amp; t, <span class="type">int</span> y) : <span class="built_in">title</span>(t), <span class="built_in">year</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数，按照出版年份升序排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareByYear</span><span class="params">(<span class="type">const</span> Book&amp; a, <span class="type">const</span> Book&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.year &lt; b.year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Book 对象的 vector</span></span><br><span class="line">    std::vector&lt;Book&gt; books = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Book A&quot;</span>, <span class="number">2000</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Book B&quot;</span>, <span class="number">1995</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Book C&quot;</span>, <span class="number">2010</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Book D&quot;</span>, <span class="number">1980</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Order: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; book : books) &#123;</span><br><span class="line">        std::cout &lt;&lt; book.title &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; book.year &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::sort 对 Book 对象按出版年份升序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>(), compareByYear);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSorted by Year: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; book : books) &#123;</span><br><span class="line">        std::cout &lt;&lt; book.title &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; book.year &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们定义了一个 <code>compareByYear</code> 比较函数，该函数接受两个 <code>Book</code> 对象并根据它们的出版年份进行比较。然后在 <code>main</code> 函数中，我们使用 <code>std::sort</code> 对 <code>Book</code> 对象的 <code>std::vector</code> 按照出版年份进行排序，并将 <code>compareByYear</code> 函数作为第三个参数传递给 <code>std::sort</code>。</p>
<p>这个示例展示了如何使用比较函数对自定义类型的对象进行排序，只需提供一个符合条件的比较函数，即可告诉 <code>std::sort</code> 如何排序这些对象。</p>
<h2 id="std-for-each"><a href="#std-for-each" class="headerlink" title="std::for_each"></a>std::for_each</h2><p><code>std::for_each</code> 是C++ STL提供的算法之一，用于对容器中的每个元素执行指定的操作。它允许你指定一个函数或者函数对象（也称为函数符或仿函数），然后对容器中的每个元素都应用这个函数。</p>
<p><code>std::for_each</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数对象（仿函数），用于输出容器中的元素</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Print</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> elem)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::for_each 对容器中的每个元素应用 Print 函数对象</span></span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="built_in">Print</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Print</code> 是一个函数对象（仿函数），它重载了<code>operator()</code>来实现对容器中元素的输出操作。然后，<code>std::for_each</code> 将容器<code>numbers</code>中的每个元素传递给<code>Print()</code>，即函数对象的实例，最终实现对每个元素的输出。</p>
<p>你也可以使用 lambda 表达式作为 <code>std::for_each</code> 的参数，而无需定义函数对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> elem) &#123;</span><br><span class="line">    std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>std::for_each</code> 提供了一种简洁而有效的方式来对容器中的元素进行操作，适用于许多不同的场景，能够更轻松地处理容器元素。</p>
<h2 id="std-count"><a href="#std-count" class="headerlink" title="std::count"></a>std::count</h2><p><code>std::count</code> 是C++ STL中的一个算法，用于计算容器中满足特定条件的元素个数。它接受两个迭代器参数，表示要进行计数的范围，以及一个要匹配的特定值。</p>
<p><code>std::count</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算容器中值为 2 的元素个数</span></span><br><span class="line">    <span class="type">int</span> countOfTwos = std::<span class="built_in">count</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The count of 2s in the vector: &quot;</span> &lt;&lt; countOfTwos &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::count</code> 被用来计算容器 <code>numbers</code> 中值为 2 的元素个数。它接收了三个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，以及要计数的特定值 2。最后，它返回匹配特定值的元素数量。</p>
<p>除了基本的数值比较外，<code>std::count</code> 也可以通过 lambda 表达式实现更加灵活的条件计数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算容器中大于 3 的元素个数</span></span><br><span class="line"><span class="type">int</span> countGreaterThanThree = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这将返回容器 <code>numbers</code> 中大于 3 的元素的数量。<code>std::count_if</code> 允许你通过 lambda 表达式指定更复杂的条件来计数满足特定条件的元素个数。</p>
<h2 id="std-find"><a href="#std-find" class="headerlink" title="std::find"></a>std::find</h2><p><code>std::find</code> 是C++ STL中的一个算法，用于在容器中查找特定值，并返回指向第一个匹配到的元素的迭代器。如果未找到匹配的元素，则返回指向容器末尾的迭代器。</p>
<p><code>std::find</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在容器中查找值为 3 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::find</code> 被用来查找容器 <code>numbers</code> 中值为 3 的元素。它接收了三个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，以及要查找的特定值 3。如果找到了值为 3 的元素，<code>std::find</code> 将返回指向这个元素的迭代器；如果未找到匹配的元素，它将返回指向容器末尾的迭代器。</p>
<p>除了基本的数值比较外，<code>std::find</code> 也可以通过 lambda 表达式实现更加灵活的查找条件，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 lambda 表达式查找容器中大于 3 的第一个元素</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这将返回容器 <code>numbers</code> 中第一个大于 3 的元素的迭代器。<code>std::find_if</code> 允许你通过 lambda 表达式指定更复杂的条件来查找满足特定条件的元素。</p>
<h2 id="std-find-if"><a href="#std-find-if" class="headerlink" title="std::find_if"></a>std::find_if</h2><p><code>std::find_if</code> 是 C++ STL 中的一个算法，用于在给定范围内查找满足特定条件的第一个元素。</p>
<p>其函数签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> UnaryPredicate &gt;</span></span><br><span class="line"><span class="function">InputIt <span class="title">find_if</span><span class="params">( InputIt first, InputIt last, UnaryPredicate p )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>first</code> 和 <code>last</code> 是指定范围的迭代器，表示要查找的元素范围。</li>
<li><code>p</code> 是一个谓词（UnaryPredicate），它是一个函数或函数对象，用于指定查找的条件。</li>
</ul>
<p><code>std::find_if</code> 函数从给定范围 <code>[first, last)</code> 中查找第一个满足条件 <code>p</code> 的元素，并返回指向该元素的迭代器。如果没有找到满足条件的元素，则返回 <code>last</code>。</p>
<p>以下是一个简单的示例说明如何使用 <code>std::find_if</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>&#125;; <span class="comment">// 示例数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个偶数</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), isEven);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;找到第一个偶数: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到满足条件的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>isEven</code> 是一个谓词函数，用于检查一个整数是否为偶数。<code>std::find_if</code> 函数被调用来在 <code>numbers</code> 容器中查找第一个偶数，如果找到了，则输出该元素的值，否则输出未找到满足条件的提示。</p>
<h2 id="std-count-if"><a href="#std-count-if" class="headerlink" title="std::count_if"></a>std::count_if</h2><p><code>std::count_if</code> 是C++ STL中的一个算法，用于计算容器中满足特定条件的元素个数。它接受两个迭代器参数，表示要进行计数的范围，并使用一个谓词（predicate）作为条件。</p>
<p><code>std::count_if</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算容器中大于 3 的元素个数</span></span><br><span class="line">    <span class="type">int</span> countGreaterThanThree = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">3</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count of elements greater than 3: &quot;</span> &lt;&lt; countGreaterThanThree &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::count_if</code> 被用来计算容器 <code>numbers</code> 中大于 3 的元素个数。它接收了三个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，以及一个 lambda 表达式作为谓词。这个 lambda 表达式定义了条件，即判断元素是否大于 3。</p>
<p><code>std::count_if</code> 将遍历容器中的每个元素，并使用指定的谓词对每个元素进行判断，然后返回满足条件的元素个数。</p>
<p>通过提供不同的谓词（即 lambda 表达式或者其他可调用对象），可以实现各种复杂的条件来计算满足特定条件的元素个数。</p>
<h2 id="std-copy"><a href="#std-copy" class="headerlink" title="std::copy"></a>std::copy</h2><p><code>std::copy</code> 是C++ STL中的一个算法，用于将一个容器中的元素复制到另一个容器中。它接受两个迭代器参数，表示要进行复制的范围，并将元素复制到目标容器的指定位置。</p>
<p><code>std::copy</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::copy 将 source 容器中的元素复制到 destination 容器中</span></span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(destination));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出目标容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : destination) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::copy</code> 被用来将容器 <code>source</code> 中的元素复制到容器 <code>destination</code> 中。它接收了三个参数：<code>source.begin()</code> 表示要复制的范围的起始迭代器，<code>source.end()</code> 表示范围的结束迭代器，以及目标容器的迭代器，使用 <code>std::back_inserter</code> 插入器将元素插入到目标容器的末尾。</p>
<p><code>std::copy</code> 将遍历源容器中的元素，并将它们复制到目标容器中，最终完成元素的复制操作。</p>
<p><code>std::copy</code> 使得在不同容器之间进行元素复制变得非常方便，可以在不同类型的容器之间灵活地进行数据传输。</p>
<h2 id="std-transform"><a href="#std-transform" class="headerlink" title="std::transform"></a>std::transform</h2><p><code>std::transform</code> 是C++ STL中的一个算法，用于将容器中的元素按照指定的操作进行转换，并将结果存储到另一个容器中。它接受两个源容器的迭代器作为输入范围，并使用一个目标容器的迭代器指定输出位置。此外，它还接受一个函数或函数对象，用于定义转换操作。</p>
<p><code>std::transform</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::transform 将 source 容器中的元素加倍后存储到 destination 容器中</span></span><br><span class="line">    std::<span class="built_in">transform</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(destination), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出目标容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : destination) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::transform</code> 被用来将容器 <code>source</code> 中的元素加倍后存储到容器 <code>destination</code> 中。它接收了四个参数：<code>source.begin()</code> 表示要转换的范围的起始迭代器，<code>source.end()</code> 表示范围的结束迭代器，<code>std::back_inserter(destination)</code> 表示目标容器的迭代器，使用 <code>std::back_inserter</code> 插入器将转换后的元素插入到目标容器的末尾，以及一个 lambda 表达式作为转换操作。</p>
<p><code>std::transform</code> 将遍历源容器中的每个元素，并使用指定的操作（在这里是 lambda 表达式中的乘以 2 操作），将转换后的结果存储到目标容器中。</p>
<p><code>std::transform</code> 提供了一种方便的方式来对容器中的元素进行转换，并将结果存储到另一个容器中，非常适用于需要对元素进行变换操作的场景。</p>
<h2 id="std-replace"><a href="#std-replace" class="headerlink" title="std::replace"></a>std::replace</h2><p><code>std::replace</code> 是C++ STL中的一个算法，用于在容器中将指定值替换为另一个值。它接受两个迭代器参数，表示要进行替换的范围，并使用要替换的值和替换后的新值作为参数。</p>
<p><code>std::replace</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::replace 将容器中的值为 3 的元素替换为 10</span></span><br><span class="line">    std::<span class="built_in">replace</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出替换后的容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::replace</code> 被用来将容器 <code>numbers</code> 中的值为 3 的元素替换为 10。它接收了四个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，要被替换的旧值 3，以及替换后的新值 10。</p>
<p><code>std::replace</code> 将遍历容器中的每个元素，并将与旧值相匹配的元素替换为新值。</p>
<p><code>std::replace</code> 提供了一种简单而有效的方法，用于在容器中执行值的替换操作。</p>
<h2 id="std-fill"><a href="#std-fill" class="headerlink" title="std::fill"></a>std::fill</h2><p><code>std::fill</code> 是C++ STL中的一个算法，用于将容器中的所有元素都设置为指定的值。它接受两个迭代器参数，表示要进行填充的范围，并使用要填充的值作为参数。</p>
<p><code>std::fill</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">numbers</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 创建一个包含5个元素的向量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::fill 将向量中的所有元素设置为值为 10</span></span><br><span class="line">    std::<span class="built_in">fill</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出填充后的向量中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::fill</code> 被用来将向量 <code>numbers</code> 中的所有元素设置为值为 10。它接收了三个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，以及要填充的新值 10。</p>
<p><code>std::fill</code> 将遍历容器中的每个元素，并将每个元素设置为指定的新值。</p>
<p><code>std::fill</code> 提供了一种便捷的方法，用于将容器中的所有元素都设置为特定的值，非常适用于需要初始化容器的情况。</p>
<h2 id="std-sort"><a href="#std-sort" class="headerlink" title="std::sort"></a>std::sort</h2><p><code>std::sort</code> 是C++ STL中的一个算法，用于对容器中的元素进行排序。它接受两个迭代器参数，表示要进行排序的范围，并按照默认的升序方式对这个范围内的元素进行排序。</p>
<p><code>std::sort</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::sort 对向量中的元素进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出排序后的向量中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::sort</code> 被用来对向量 <code>numbers</code> 中的元素进行排序。它接收了两个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器。</p>
<p><code>std::sort</code> 将对容器中的元素按照默认的升序方式进行排序。如果你想要进行自定义的排序方式，可以传入一个自定义的比较函数作为第三个参数。</p>
<p><code>std::sort</code> 是一个高效的排序算法，在处理各种数据结构和数据类型时都能够提供良好的性能。</p>
<h2 id="std-stable-sort"><a href="#std-stable-sort" class="headerlink" title="std::stable_sort"></a>std::stable_sort</h2><p><code>std::stable_sort</code> 是 C++ 标准库中的一个函数，用于对容器中的元素进行排序。与 <code>std::sort</code> 不同，<code>std::stable_sort</code> 是一种稳定排序算法，它能够保持相等元素的相对位置不变。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stable_sort</span><span class="params">( RandomIt first, RandomIt last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stable_sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first</code> 是一个指向容器要排序部分的起始位置的迭代器；</li>
<li><code>last</code> 是一个指向容器结束位置的迭代器；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::stable_sort</code> 对范围 <code>[first, last)</code> 中的元素进行排序，保持相等元素的相对位置不变。这意味着如果两个元素在排序前相等，那么在排序后，它们的相对顺序将保持不变。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">stable_sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码将 <code>numbers</code> 容器中的元素使用 <code>std::stable_sort</code> 进行排序。排序后，输出的结果将会按升序排列，并且相等元素的相对位置将保持不变。</p>
<p><code>std::stable_sort</code> 在需要稳定排序的情况下非常有用，特别是当需要保持相等元素的相对顺序时。这对于处理某些特定的数据结构或算法非常重要。</p>
<p>总的来说，<code>std::stable_sort</code> 是一个强大的排序函数，可以对容器中的元素进行排序，并保持相等元素的相对位置不变。</p>
<h2 id="std-partial-sort"><a href="#std-partial-sort" class="headerlink" title="std::partial_sort"></a>std::partial_sort</h2><p><code>std::partial_sort</code> 是 C++ 标准库中的一个函数，用于对容器中的部分元素进行排序。它能够在排序过程中保持部分元素的顺序，将指定范围内的元素部分排序为序列中最小（或最大）的一部分。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partial_sort</span><span class="params">( RandomIt first, RandomIt middle, RandomIt last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partial_sort</span><span class="params">( RandomIt first, RandomIt middle, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first</code> 是一个指向容器要排序部分的起始位置的迭代器；</li>
<li><code>middle</code> 是一个指向容器的中间位置的迭代器；</li>
<li><code>last</code> 是一个指向容器结束位置的迭代器；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::partial_sort</code> 将容器从 <code>first</code> 到 <code>middle</code> 的元素部分排序，使得 <code>middle - first</code> 个元素是序列中最小（或最大）的一部分，但并不保证这些元素之间的顺序。而剩余的元素，即从 <code>middle</code> 到 <code>last</code> 的范围内，可能在序列中以任意顺序出现，不做排序。</p>
<p>这个函数通常在需要获取序列中最小或最大的一部分元素时非常有用，而不需要完全对整个序列进行排序。这有助于节省计算资源，特别是当只对部分数据感兴趣时。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">partial_sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">begin</span>() + <span class="number">4</span>, numbers.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码将 <code>numbers</code> 容器的前四个元素进行部分排序，使得前四个元素是序列中最小的一部分，而后续元素可能在序列中以任意顺序出现。</p>
<p><code>std::partial_sort</code> 在处理大型数据集时能够提供更高的效率，因为它只对部分元素进行排序而不需要对整个序列进行排序。</p>
<p>总之，<code>std::partial_sort</code> 是一个有用的函数，适用于在部分排序情况下获取序列中最小（或最大）的一部分元素。</p>
<h2 id="std-nth-element"><a href="#std-nth-element" class="headerlink" title="std::nth_element"></a>std::nth_element</h2><p><code>std::nth_element</code> 是 C++ 标准库中的一个函数，用于在容器中找到第 n 个顺序统计量，即第 n 小或第 n 大的元素，而不必对整个序列进行排序。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">( RandomIt first, RandomIt nth, RandomIt last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">( RandomIt first, RandomIt nth, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first</code> 是一个指向容器要排序部分的起始位置的迭代器；</li>
<li><code>nth</code> 是一个指向容器中要找到的第 n 个元素的迭代器；</li>
<li><code>last</code> 是一个指向容器结束位置的迭代器；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::nth_element</code> 将容器 <code>[first, last)</code> 中的元素重新排列，使得位于位置 <code>nth</code> 的元素是序列中第 n 小（或第 n 大）的元素，并且在它之前的元素小于或等于它，在它之后的元素大于或等于它。但并不保证 <code>nth</code> 之前或之后的元素是有序的。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">nth_element</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">begin</span>() + <span class="number">4</span>, numbers.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The fifth smallest element is: &quot;</span> &lt;&lt; numbers[<span class="number">4</span>] &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码将 <code>numbers</code> 容器中的元素使用 <code>std::nth_element</code> 进行部分排序，找到序列中第五小的元素。在输出中，<code>numbers[4]</code> 将是第五小的元素，但在它之前或之后的元素不一定是有序的。</p>
<p><code>std::nth_element</code> 是在需要找到第 n 个顺序统计量而无需完全排序整个序列时非常有用的。它的时间复杂度是线性的，而不是完全排序所需的时间复杂度。</p>
<p>总的来说，<code>std::nth_element</code> 是一个用于在容器中找到第 n 个顺序统计量的高效算法，可以在部分排序的情况下找到指定位置的元素。</p>
<h2 id="std-lower-bound"><a href="#std-lower-bound" class="headerlink" title="std::lower_bound"></a>std::lower_bound</h2><p><code>std::lower_bound</code> 是 C++ 标准库中的一个算法函数，用于在已排序的序列中查找第一个大于或等于某个值的元素的位置（也就是说，它返回大于或等于指定值的第一个元素的迭代器位置），如果不存在这样的元素，则返回序列末尾的迭代器。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first</code> 是一个指向容器或数组开始位置的迭代器；</li>
<li><code>last</code> 是一个指向容器或数组结束位置的迭代器；</li>
<li><code>value</code> 是要查找的值；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::lower_bound</code> 在一个已排序的序列 <code>[first, last)</code> 中查找大于或等于 <code>value</code> 的第一个元素。如果找到了匹配的元素，则返回指向该元素的迭代器；如果没有找到匹配的元素，则返回指向序列中第一个大于 <code>value</code> 的元素位置的迭代器，如果不存在大于 <code>value</code> 的元素，则返回 <code>last</code>。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 std::lower_bound 查找第一个大于或等于 5 的元素位置</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First element greater than or equal to 5 is: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element greater than or equal to 5 found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>std::lower_bound</code> 在已排序的 <code>numbers</code> 容器中查找第一个大于或等于 5 的元素位置，并输出找到的元素值。如果没有找到大于或等于 5 的元素，则输出相应的信息。</p>
<p><code>std::lower_bound</code> 在需要在已排序序列中快速查找大于或等于某个值的元素位置时非常有用。注意，对于无序序列，<code>std::lower_bound</code> 不会返回正确的结果，因为它要求输入序列是有序的才能保证正确性。</p>
<h2 id="std-upper-bound"><a href="#std-upper-bound" class="headerlink" title="std::upper_bound"></a>std::upper_bound</h2><p><code>std::upper_bound</code> 是 C++ 标准库中的一个算法函数，用于在已排序的序列中查找第一个大于某个值的元素的位置（也就是说，它返回大于指定值的第一个元素的迭代器位置），如果不存在这样的元素，则返回序列末尾的迭代器。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first</code> 是一个指向容器或数组开始位置的迭代器；</li>
<li><code>last</code> 是一个指向容器或数组结束位置的迭代器；</li>
<li><code>value</code> 是要查找的值；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::upper_bound</code> 在一个已排序的序列 <code>[first, last)</code> 中查找大于 <code>value</code> 的第一个元素。如果找到了匹配的元素，则返回指向下一个元素的迭代器；如果没有找到匹配的元素，则返回指向序列中第一个大于 <code>value</code> 的元素位置的迭代器，如果不存在大于 <code>value</code> 的元素，则返回 <code>last</code>。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 std::upper_bound 查找第一个大于 5 的元素位置</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First element greater than 5 is: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No element greater than 5 found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>std::upper_bound</code> 在已排序的 <code>numbers</code> 容器中查找第一个大于 5 的元素位置，并输出找到的元素值。如果没有找到大于 5 的元素，则输出相应的信息。</p>
<p><code>std::upper_bound</code> 在需要在已排序序列中快速查找大于某个值的元素位置时非常有用。注意，对于无序序列，<code>std::upper_bound</code> 不会返回正确的结果，因为它要求输入序列是有序的才能保证正确性。</p>
<h2 id="std-binary-search"><a href="#std-binary-search" class="headerlink" title="std::binary_search"></a>std::binary_search</h2><p><code>std::binary_search</code> 是C++ STL中的一个算法，用于在已排序的序列（例如数组或有序容器）中进行二分查找。它接受两个迭代器参数，表示要进行查找的范围，并返回一个布尔值，指示是否找到了指定的元素。</p>
<p><code>std::binary_search</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> target = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::binary_search 在有序向量中查找元素</span></span><br><span class="line">    <span class="type">bool</span> isFound = std::<span class="built_in">binary_search</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFound) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; not found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::binary_search</code> 被用来在已排序的向量 <code>numbers</code> 中查找元素 6。它接收了三个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，以及要查找的目标值 6。</p>
<p><code>std::binary_search</code> 返回一个布尔值，指示是否在容器中找到了指定的元素。如果找到了元素，则返回 <code>true</code>；否则返回 <code>false</code>。</p>
<p><code>std::binary_search</code> 使用二分查找算法来检查序列是否包含指定的值。在已排序的序列中，这个算法提供了较快的查找速度。</p>
<h2 id="std-merge"><a href="#std-merge" class="headerlink" title="std::merge"></a>std::merge</h2><p><code>std::merge</code> 是C++ STL中的一个算法，用于将两个已排序的序列合并成一个新的已排序序列。它接受四个迭代器参数，分别表示两个待合并序列的起始和结束位置，以及一个目标序列的起始位置。</p>
<p><code>std::merge</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; first = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; second = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(first.size() + second.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::merge 合并两个有序向量，并将结果存储到 result 向量中</span></span><br><span class="line">    std::<span class="built_in">merge</span>(first.<span class="built_in">begin</span>(), first.<span class="built_in">end</span>(), second.<span class="built_in">begin</span>(), second.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出合并后的向量中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::merge</code> 被用来将两个已排序的向量 <code>first</code> 和 <code>second</code> 合并成一个新的有序向量 <code>result</code>。它接收了五个参数：<code>first.begin()</code> 和 <code>first.end()</code> 表示第一个待合并序列的范围，<code>second.begin()</code> 和 <code>second.end()</code> 表示第二个待合并序列的范围，以及目标向量 <code>result</code> 的起始迭代器。</p>
<p><code>std::merge</code> 将按照递增的顺序将两个已排序的序列合并到目标序列中。合并后的序列保持有序状态。</p>
<p><code>std::merge</code> 是一个在合并已排序序列时非常有用的算法，它能够高效地合并两个有序序列到一个新的有序序列中。</p>
<h2 id="std-set-intersection"><a href="#std-set-intersection" class="headerlink" title="std::set_intersection"></a>std::set_intersection</h2><p><code>std::set_intersection</code> 是 C++ 标准库中的一个算法函数，用于在两个有序集合（或有序范围）中找到并计算交集，并将结果存储到另一个集合（或指定的输出范围）中。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">OutputIt</span>&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_intersection</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                          InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                          OutputIt d_first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">OutputIt</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_intersection</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                          InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                          OutputIt d_first, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first1</code> 和 <code>last1</code> 表示第一个有序集合（或范围）的起始和结束位置；</li>
<li><code>first2</code> 和 <code>last2</code> 表示第二个有序集合（或范围）的起始和结束位置；</li>
<li><code>d_first</code> 表示输出的目标位置，即存储交集的容器或输出范围的起始位置；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::set_intersection</code> 找到两个有序集合（或范围）的交集，并将结果存储到目标容器或输出范围中。返回值是一个指向输出范围的末尾的迭代器，指示了存储交集后的结束位置。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; intersection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取两个集合的交集</span></span><br><span class="line">    std::<span class="built_in">set_intersection</span>(set<span class="number">1.</span><span class="built_in">begin</span>(), set<span class="number">1.</span><span class="built_in">end</span>(),</span><br><span class="line">                          set<span class="number">2.</span><span class="built_in">begin</span>(), set<span class="number">2.</span><span class="built_in">end</span>(),</span><br><span class="line">                          std::<span class="built_in">back_inserter</span>(intersection));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出交集</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Intersection: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : intersection) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::set_intersection</code> 将 <code>set1</code> 和 <code>set2</code> 两个有序集合的交集计算出来，并将结果存储到 <code>intersection</code> 容器中。最后输出了交集的内容。</p>
<p><code>std::set_intersection</code> 对于处理两个有序集合的交集非常有用。它要求输入的两个集合（或范围）都是有序的，以保证正确的交集计算。</p>
<h2 id="std-set-union"><a href="#std-set-union" class="headerlink" title="std::set_union"></a>std::set_union</h2><p><code>std::set_union</code> 是 C++ 标准库中的一个算法函数，用于计算两个有序集合（或有序范围）的并集，并将结果存储到另一个集合（或指定的输出范围）中。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">OutputIt</span>&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_union</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                   InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                   OutputIt d_first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">OutputIt</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_union</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                   InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                   OutputIt d_first, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first1</code> 和 <code>last1</code> 表示第一个有序集合（或范围）的起始和结束位置；</li>
<li><code>first2</code> 和 <code>last2</code> 表示第二个有序集合（或范围）的起始和结束位置；</li>
<li><code>d_first</code> 表示输出的目标位置，即存储并集的容器或输出范围的起始位置；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::set_union</code> 找到两个有序集合（或范围）的并集，并将结果存储到目标容器或输出范围中。返回值是一个指向输出范围的末尾的迭代器，指示了存储并集后的结束位置。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; union_set;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取两个集合的并集</span></span><br><span class="line">    std::<span class="built_in">set_union</span>(set<span class="number">1.</span><span class="built_in">begin</span>(), set<span class="number">1.</span><span class="built_in">end</span>(),</span><br><span class="line">                   set<span class="number">2.</span><span class="built_in">begin</span>(), set<span class="number">2.</span><span class="built_in">end</span>(),</span><br><span class="line">                   std::<span class="built_in">back_inserter</span>(union_set));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出并集</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Union: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : union_set) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>std::set_union</code> 将 <code>set1</code> 和 <code>set2</code> 两个有序集合的并集计算出来，并将结果存储到 <code>union_set</code> 容器中。最后输出了并集的内容。</p>
<p><code>std::set_union</code> 对于处理两个有序集合的并集非常有用。它要求输入的两个集合（或范围）都是有序的，以保证正确的并集计算。</p>
<h2 id="std-set-difference"><a href="#std-set-difference" class="headerlink" title="std::set_difference"></a>std::set_difference</h2><p><code>std::set_difference</code> 是 C++ 标准库中的一个算法函数，用于计算两个有序集合（或有序范围）的差集，并将结果存储到另一个集合（或指定的输出范围）中。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">OutputIt</span>&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_difference</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                        OutputIt d_first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">OutputIt</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_difference</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                        OutputIt d_first, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first1</code> 和 <code>last1</code> 表示第一个有序集合（或范围）的起始和结束位置；</li>
<li><code>first2</code> 和 <code>last2</code> 表示第二个有序集合（或范围）的起始和结束位置；</li>
<li><code>d_first</code> 表示输出的目标位置，即存储差集的容器或输出范围的起始位置；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::set_difference</code> 找到两个有序集合（或范围）的差集，并将结果存储到目标容器或输出范围中。返回值是一个指向输出范围的末尾的迭代器，指示了存储差集后的结束位置。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; difference_set;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取两个集合的差集</span></span><br><span class="line">    std::<span class="built_in">set_difference</span>(set<span class="number">1.</span><span class="built_in">begin</span>(), set<span class="number">1.</span><span class="built_in">end</span>(),</span><br><span class="line">                        set<span class="number">2.</span><span class="built_in">begin</span>(), set<span class="number">2.</span><span class="built_in">end</span>(),</span><br><span class="line">                        std::<span class="built_in">back_inserter</span>(difference_set));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出差集</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Difference: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : difference_set) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>std::set_difference</code> 将 <code>set1</code> 和 <code>set2</code> 两个有序集合的差集计算出来，并将结果存储到 <code>difference_set</code> 容器中。最后输出了差集的内容。<br>1</p>
<p><code>std::set_difference</code> 对于处理两个有序集合的差集非常有用。它要求输入的两个集合（或范围）都是有序的，以保证正确的差集计算。</p>
<h2 id="std-accumulate"><a href="#std-accumulate" class="headerlink" title="std::accumulate"></a>std::accumulate</h2><p><code>std::accumulate</code> 是C++ STL中的一个算法，用于对容器中的元素进行累加操作。它接受三个参数：范围的起始和结束迭代器，以及一个初始值，用于指定累加的起始值。</p>
<p><code>std::accumulate</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::accumulate 对向量中的元素进行累加</span></span><br><span class="line">    <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of elements: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::accumulate</code> 被用来对向量 <code>numbers</code> 中的所有元素进行累加操作。它接收了三个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，以及初始值 0 作为累加的起始值。</p>
<p><code>std::accumulate</code> 将对范围内的所有元素进行累加，返回最终的累加结果。</p>
<p>除了简单的累加外，<code>std::accumulate</code> 也可以执行其他操作，如乘法累积、自定义操作等。它提供了灵活性，使得在容器中对元素进行各种累积操作变得非常方便。</p>
<h2 id="std-accumulate-自定义操作"><a href="#std-accumulate-自定义操作" class="headerlink" title="std::accumulate 自定义操作"></a>std::accumulate 自定义操作</h2><p>当使用 <code>std::accumulate</code> 时，你可以提供一个自定义的二元函数来执行特定的累积操作。这个函数可以是加法、乘法、逻辑运算或任何你需要的二元操作。</p>
<p>以下是一个示例，展示了如何使用 <code>std::accumulate</code> 执行自定义操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数：将两个元素相乘</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">customMultiply</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::accumulate 对向量中的元素进行自定义的累积操作</span></span><br><span class="line">    <span class="type">int</span> product = std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">1</span>, customMultiply);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Product of elements: &quot;</span> &lt;&lt; product &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::accumulate</code> 用于计算向量 <code>numbers</code> 中所有元素的乘积。<code>customMultiply</code> 是一个自定义的函数，用于定义累积操作。<code>std::accumulate</code> 接受了四个参数：<code>numbers.begin()</code> 表示范围的起始迭代器，<code>numbers.end()</code> 表示范围的结束迭代器，初始值为 1（因为乘法操作的初始值为 1），以及自定义的乘法函数 <code>customMultiply</code>。</p>
<p>这个示例中使用了乘法操作，但你可以根据需要提供不同的自定义函数来执行各种不同的累积操作。<code>std::accumulate</code> 的灵活性使得在容器中执行各种自定义操作变得非常方便。</p>
<h2 id="std-inner-product"><a href="#std-inner-product" class="headerlink" title="std::inner_product"></a>std::inner_product</h2><p><code>std::inner_product</code> 是C++ STL中的一个算法，用于计算两个序列的内积（dot product）。它接受四个迭代器参数，分别表示两个序列的起始和结束位置，以及两个序列的初始值。</p>
<p><code>std::inner_product</code> 的基本语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; first = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; second = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::inner_product 计算两个向量的内积</span></span><br><span class="line">    <span class="type">int</span> result = std::<span class="built_in">inner_product</span>(first.<span class="built_in">begin</span>(), first.<span class="built_in">end</span>(), second.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inner product of the vectors: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::inner_product</code> 被用来计算两个向量 <code>first</code> 和 <code>second</code> 的内积。它接收了四个参数：<code>first.begin()</code> 和 <code>first.end()</code> 表示第一个序列的范围，<code>second.begin()</code> 表示第二个序列的范围，以及初始值为 0。</p>
<p><code>std::inner_product</code> 将对两个序列中对应位置的元素进行相乘并相加，最终得到内积的结果。</p>
<p>除了默认的内积计算外，<code>std::inner_product</code> 还可以接受自定义的二元函数来执行其他类型的累积操作。这使得它非常灵活，能够进行各种不同类型的序列计算。</p>
<h2 id="std-generate"><a href="#std-generate" class="headerlink" title="std::generate"></a>std::generate</h2><p><code>std::generate()</code> 是 C++ STL 中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于生成指定范围内的值，并将这些值放置到容器或数组中。</p>
<p>该函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> Generator &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate</span><span class="params">(ForwardIt first, ForwardIt last, Generator g)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个范围 <code>[first, last)</code>，并使用生成器函数 <code>g</code> 来生成值，将这些值依次赋值给范围内的元素。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">numbers</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> counter = <span class="number">1</span>;</span><br><span class="line">    std::<span class="built_in">generate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [&amp;counter]() &#123;</span><br><span class="line">        <span class="keyword">return</span> counter++;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Generated Numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generated Numbers: 1 2 3 4 5 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::generate()</code> 函数使用 lambda 表达式作为生成器函数，从1开始生成值并填充到 <code>numbers</code> 容器中。这里利用了 lambda 表达式来捕获并递增 <code>counter</code> 变量的值，并将递增后的值赋给容器中的元素。</p>
<h2 id="std-make-heap"><a href="#std-make-heap" class="headerlink" title="std::make_heap"></a>std::make_heap</h2><p><code>std::make_heap()</code> 是 C++ STL 中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于将一个范围内的元素重新组织为一个堆数据结构。</p>
<p>堆是一种特殊的二叉树结构，其中每个父节点的值都大于或等于其子节点的值（最大堆），或每个父节点的值都小于或等于其子节点的值（最小堆）。STL 中的堆通常使用数组来表示。</p>
<p><code>std::make_heap()</code> 函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_heap</span><span class="params">( RandomIt first, RandomIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个范围 <code>[first, last)</code>，其中的元素将会被重新组织成一个堆。默认情况下，这个函数会将范围 <code>[first, last)</code> 中的元素转换为最大堆。如果需要创建最小堆，可以使用 <code>std::make_heap(first, last, comp)</code> 并提供一个比较函数 <code>comp</code>。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">make_heap</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Heapified Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Original Vector: 3 1 4 1 5 9 2 6 </span><br><span class="line">Heapified Vector: 9 5 4 6 1 3 2 1 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::make_heap()</code> 函数将 <code>numbers</code> 容器转换为最大堆。<code>make_heap()</code> 函数会对范围 <code>[first, last)</code> 中的元素进行重新排列，使其满足堆的性质。</p>
<h2 id="std-push-heap"><a href="#std-push-heap" class="headerlink" title="std::push_heap"></a>std::push_heap</h2><p><code>std::push_heap()</code> 是 C++ STL 中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于将堆中的元素范围扩展，添加一个新元素，并保持堆的性质不变。</p>
<p>堆是一种特殊的二叉树结构，其中每个父节点的值都大于或等于其子节点的值（最大堆），或每个父节点的值都小于或等于其子节点的值（最小堆）。</p>
<p><code>std::push_heap()</code> 函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_heap</span><span class="params">( RandomIt first, RandomIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个范围 <code>[first, last-1]</code>，表示已经形成了一个堆（[first, last-1]是一个有效的堆），然后将 <code>*(last-1)</code> 添加到堆中，并保持堆的性质。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">make_heap</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Heapified Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个新元素到堆中</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    std::<span class="built_in">push_heap</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Heapified Vector after push_heap: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Original Vector: 3 1 4 1 5 9 </span><br><span class="line">Heapified Vector: 9 5 4 1 1 3 </span><br><span class="line">Heapified Vector after push_heap: 9 6 4 5 1 3 1 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::push_heap()</code> 函数将一个新元素 <code>6</code> 添加到 <code>numbers</code> 容器的末尾，并将其保持为最大堆。<code>push_heap()</code> 函数确保堆的性质仍然得到维护。</p>
<h2 id="std-pop-heap"><a href="#std-pop-heap" class="headerlink" title="std::pop_heap"></a>std::pop_heap</h2><p><code>std::pop_heap()</code> 是 C++ STL 中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于将堆中的最大（或最小）元素移到范围的末尾，并且在范围的前部保持一个堆。</p>
<p>堆是一种特殊的二叉树结构，其中每个父节点的值都大于或等于其子节点的值（最大堆），或每个父节点的值都小于或等于其子节点的值（最小堆）。</p>
<p><code>std::pop_heap()</code> 函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_heap</span><span class="params">( RandomIt first, RandomIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个范围 <code>[first, last]</code>，其中 <code>[first, last-1]</code> 应该表示一个有效的堆。然后它将堆中的最大元素（对于最大堆）或最小元素（对于最小堆）移到范围的末尾，并将 <code>[first, last-1]</code> 调整为一个新的堆。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">make_heap</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Heapified Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除堆中的最大元素（在此为 9）</span></span><br><span class="line">    std::<span class="built_in">pop_heap</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Heap after pop_heap: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Original Vector: 3 1 4 1 5 9 </span><br><span class="line">Heapified Vector: 9 5 4 1 1 3 </span><br><span class="line">Heap after pop_heap: 5 1 4 1 3 9 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::pop_heap()</code> 函数将 <code>numbers</code> 容器的第一个元素（即最大元素）移到了范围的末尾，并且重新将 <code>[first, last-1]</code> 调整为一个新的最大堆。</p>
<h2 id="std-min"><a href="#std-min" class="headerlink" title="std::min"></a>std::min</h2><p>在 C++ 标准库中，<code>std::min()</code> 是一个模板函数，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于比较两个值并返回其中较小的那个。</p>
<p><code>std::min()</code> 有多个重载形式，可以接受不同类型的参数：</p>
<ol>
<li><p><strong>两个参数形式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">min</span><span class="params">( <span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个版本接受两个相同类型的参数 <code>a</code> 和 <code>b</code>，并返回其中较小的值。</p>
</li>
<li><p><strong>初始化列表形式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">( std::initializer_list&lt;T&gt; ilist )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个版本接受一个初始化列表，并返回列表中的最小值。</p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> smaller = std::<span class="built_in">min</span>(x, y); <span class="comment">// 返回较小的值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The smaller value is: &quot;</span> &lt;&lt; smaller &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The smaller value is: 3</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::min()</code> 被用于比较 <code>x</code> 和 <code>y</code> 的值，并将较小的值赋给变量 <code>smaller</code>。根据参数的类型，<code>std::min()</code> 将返回一个具有较小值的变量或元素。</p>
<h2 id="std-max"><a href="#std-max" class="headerlink" title="std::max"></a>std::max</h2><p>在 C++ 标准库中，<code>std::max()</code> 是一个模板函数，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于比较两个值并返回其中较大的那个。</p>
<p><code>std::max()</code> 有多个重载形式，可以接受不同类型的参数：</p>
<ol>
<li><p><strong>两个参数形式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">max</span><span class="params">( <span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个版本接受两个相同类型的参数 <code>a</code> 和 <code>b</code>，并返回其中较大的值。</p>
</li>
<li><p><strong>初始化列表形式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">( std::initializer_list&lt;T&gt; ilist )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个版本接受一个初始化列表，并返回列表中的最大值。</p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> larger = std::<span class="built_in">max</span>(x, y); <span class="comment">// 返回较大的值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The larger value is: &quot;</span> &lt;&lt; larger &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The larger value is: 5</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::max()</code> 被用于比较 <code>x</code> 和 <code>y</code> 的值，并将较大的值赋给变量 <code>larger</code>。根据参数的类型，<code>std::max()</code> 将返回一个具有较大值的变量或元素。</p>
<h2 id="std-reverse"><a href="#std-reverse" class="headerlink" title="std::reverse"></a>std::reverse</h2><p><code>std::reverse()</code> 是 C++ 标准库中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于将指定范围内的元素进行反转。</p>
<p>这个函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> BidirIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">( BidirIt first, BidirIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>std::reverse()</code> 接受一个范围 <code>[first, last)</code>，并将该范围内的元素进行反转。这个范围应该是一个双向迭代器范围，例如 <code>std::vector</code>、<code>std::list</code>、<code>std::deque</code> 等容器。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">reverse</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reversed Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Original Vector: 1 2 3 4 5 </span><br><span class="line">Reversed Vector: 5 4 3 2 1 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::reverse()</code> 函数被用于反转 <code>numbers</code> 容器中的元素顺序。注意，<code>std::reverse()</code> 只是简单地颠倒元素的顺序，并不会改变容器中的元素值。</p>
<h2 id="std-rotate"><a href="#std-rotate" class="headerlink" title="std::rotate"></a>std::rotate</h2><p><code>std::rotate()</code> 是 C++ 标准库中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中。它用于将容器中的元素按照指定的位置进行循环左旋。</p>
<p>这个函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">rotate</span><span class="params">( ForwardIt first, ForwardIt n_first, ForwardIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>std::rotate()</code> 接受三个迭代器参数：<code>first</code>、<code>n_first</code> 和 <code>last</code>。它会将位于范围 <code>[first, last)</code> 中的元素从位置 <code>first</code> 开始，循环左旋到新的位置 <code>n_first</code>。也就是说，<code>n_first</code> 将成为新的起始位置。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">rotate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">begin</span>() + <span class="number">2</span>, numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rotated Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Original Vector: 1 2 3 4 5 </span><br><span class="line">Rotated Vector: 3 4 5 1 2 </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::rotate()</code> 函数被用于对 <code>numbers</code> 容器中的元素进行循环左旋。参数 <code>numbers.begin() + 2</code> 指定了旋转的新起始位置，将原来前两个元素移到了容器末尾。</p>
<h2 id="std-swap"><a href="#std-swap" class="headerlink" title="std::swap"></a>std::swap</h2><p><code>std::swap</code> 是 C++ 标准库中的一个函数，用于交换两个对象的值。这个函数位于 <code>&lt;algorithm&gt;</code> 头文件中。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>a</code> 和 <code>b</code> 是要交换值的两个对象的引用。</p>
<p><code>std::swap</code> 函数交换了两个对象的值，无论这些对象的类型是什么。它通过使用临时变量来实现值的交换。这个函数对于标准数据类型（例如整数、浮点数等）以及自定义类型都是适用的。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::swap 交换 a 和 b 的值</span></span><br><span class="line">    std::<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::swap</code> 函数被用于交换变量 <code>a</code> 和 <code>b</code> 的值。经过交换后，<code>a</code> 的值变为原来 <code>b</code> 的值，<code>b</code> 的值变为原来 <code>a</code> 的值。</p>
<p><code>std::swap</code> 是一个通用的交换值的函数，可以在很多场景下用于交换各种类型的对象，非常方便。需要注意的是，在进行交换时，对于某些类类型对象，最好实现了合适的交换操作，以提高性能。</p>
<h2 id="std-swap-ranges"><a href="#std-swap-ranges" class="headerlink" title="std::swap_ranges"></a>std::swap_ranges</h2><p><code>std::swap_ranges</code> 是 C++ 标准库中的一个算法函数，用于交换两个范围内的元素值。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIt1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIt2</span>&gt;</span><br><span class="line"><span class="function">ForwardIt2 <span class="title">swap_ranges</span><span class="params">(ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first1</code> 和 <code>last1</code> 表示第一个范围的起始和结束位置；</li>
<li><code>first2</code> 表示第二个范围的起始位置；</li>
<li>返回值为第二个范围的结束位置。</li>
</ul>
<p><code>std::swap_ranges</code> 函数用于交换两个范围内的元素值，即将范围 <code>[first1, last1)</code> 中的元素与范围以 <code>first2</code> 为起始位置的另一个范围的元素进行逐个交换。第一个范围的元素数量必须与第二个范围相同。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swapping:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : vec2) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::swap_ranges 交换两个向量的元素</span></span><br><span class="line">    std::<span class="built_in">swap_ranges</span>(vec<span class="number">1.</span><span class="built_in">begin</span>(), vec<span class="number">1.</span><span class="built_in">end</span>(), vec<span class="number">2.</span><span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swapping:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : vec2) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::swap_ranges</code> 函数被用于交换两个向量 <code>vec1</code> 和 <code>vec2</code> 中的元素。经过交换后，<code>vec1</code> 中的元素变为原来 <code>vec2</code> 中的元素，<code>vec2</code> 中的元素变为原来 <code>vec1</code> 中的元素。</p>
<p><code>std::swap_ranges</code> 对于交换两个范围内的元素值非常有用。它能够方便地交换两个范围中对应位置的元素值，而不需要手动编写交换的逻辑。</p>
<h2 id="std-adjacent-difference"><a href="#std-adjacent-difference" class="headerlink" title="std::adjacent_difference"></a>std::adjacent_difference</h2><p><code>std::adjacent_difference</code> 是 C++ STL 中的一个函数，用于计算一个序列中相邻元素的差值，并将结果存储到另一个序列中。</p>
<p>其函数签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> OutputIt &gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">adjacent_difference</span><span class="params">( InputIt first, InputIt last, OutputIt d_first )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>first</code> 和 <code>last</code> 是输入序列的迭代器范围，表示要进行差值计算的元素范围。</li>
<li><code>d_first</code> 是输出序列的起始位置迭代器，用于存储相邻元素之间的差值结果。</li>
</ul>
<p>以下是一个简单的示例说明 <code>std::adjacent_difference</code> 函数的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;; <span class="comment">// 示例数据</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">differences</span><span class="params">(numbers.size())</span></span>; <span class="comment">// 用于存储相邻元素差值的容器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算相邻元素的差值</span></span><br><span class="line">    std::<span class="built_in">adjacent_difference</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), differences.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;相邻元素的差值：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; diff : differences) &#123;</span><br><span class="line">        std::cout &lt;&lt; diff &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::adjacent_difference</code> 函数计算了 <code>numbers</code> 中相邻元素的差值，并将结果存储在 <code>differences</code> 容器中。最后，通过迭代输出了相邻元素的差值。</p>
<p>需要注意的是，<code>std::adjacent_difference</code> 函数对于输入序列中的第一个元素会直接复制到输出序列中，而后续元素则会存储与前一个元素的差值。</p>
<h2 id="std-equal"><a href="#std-equal" class="headerlink" title="std::equal"></a>std::equal</h2><p><code>std::equal()</code> 是 C++ 标准模板库中的一个算法，用于检查两个序列是否相等。它比较两个序列中的对应元素，如果两个序列在相同位置上的元素都相等，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2 &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">( InputIt1 first1, InputIt1 last1, InputIt2 first2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2, <span class="keyword">class</span> BinaryPredicate &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">( InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>first1</code> 和 <code>last1</code> 是第一个序列的起始和结束迭代器。</li>
<li><code>first2</code> 是第二个序列的起始迭代器。</li>
<li><code>p</code> 是一个可选的谓词（函数对象或函数指针），用于比较两个元素。</li>
</ul>
<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>first1</code>、<code>last1</code>：定义了第一个序列的范围，包括 <code>first1</code>，但不包括 <code>last1</code>。</li>
<li><code>first2</code>：定义了第二个序列的起始位置。</li>
<li><code>p</code>：如果提供了这个参数，将会用它来比较元素，否则将使用元素类型的 <code>operator==</code> 进行比较。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果两个序列在范围 <code>[first1, last1)</code> 中的相应元素都相等，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isEqual = std::<span class="built_in">equal</span>(vec<span class="number">1.</span><span class="built_in">begin</span>(), vec<span class="number">1.</span><span class="built_in">end</span>(), vec<span class="number">2.</span><span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEqual) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;两个序列相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;两个序列不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::equal()</code> 用于比较两个 <code>std::vector</code> 是否相等。由于它们包含相同的元素且相同顺序，因此会输出 “两个序列相等”。</p>
<h2 id="C-std-equal-自定义操作"><a href="#C-std-equal-自定义操作" class="headerlink" title="C++ std::equal 自定义操作"></a>C++ std::equal 自定义操作</h2><p><code>std::equal</code> 可以接受一个自定义的操作（谓词），以便进行元素的比较。这个谓词可以是一个函数对象或者函数指针，用于执行元素间的自定义比较。</p>
<h3 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2, <span class="keyword">class</span> BinaryPredicate &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">( InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>first1</code> 和 <code>last1</code> 是第一个序列的起始和结束迭代器。</li>
<li><code>first2</code> 是第二个序列的起始迭代器。</li>
<li><code>p</code> 是一个二元谓词，用于比较两个元素。它接受两个参数，分别是两个要比较的元素，返回 <code>bool</code> 类型的结果。</li>
</ul>
<h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>first1</code>、<code>last1</code>：定义了第一个序列的范围，包括 <code>first1</code>，但不包括 <code>last1</code>。</li>
<li><code>first2</code>：定义了第二个序列的起始位置。</li>
<li><code>p</code>：用于比较两个元素的自定义二元谓词。</li>
</ul>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果两个序列在范围 <code>[first1, last1)</code> 中的相应元素使用谓词 <code>p</code> 进行比较都返回 <code>true</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义谓词，比较元素是否相差1</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">customPredicate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a - b == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isEqual = std::<span class="built_in">equal</span>(vec<span class="number">1.</span><span class="built_in">begin</span>(), vec<span class="number">1.</span><span class="built_in">end</span>(), vec<span class="number">2.</span><span class="built_in">begin</span>(), customPredicate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEqual) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;两个序列中对应元素相差1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;两个序列中对应元素不相差1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::equal()</code> 使用了自定义的谓词 <code>customPredicate</code> 来比较两个序列的元素是否相差1。如果两个序列中对应位置的元素相差1，则输出 “两个序列中对应元素相差1”，否则输出 “两个序列中对应元素不相差1”。</p>
<h2 id="std-lexicographical-compare"><a href="#std-lexicographical-compare" class="headerlink" title="std::lexicographical_compare"></a>std::lexicographical_compare</h2><p><code>std::lexicographical_compare</code> 是 C++ 标准库中的一个算法函数，用于比较两个范围的字典序大小关系。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lexicographical_compare</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                             InputIt2 first2, InputIt2 last2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lexicographical_compare</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                             InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>first1</code> 和 <code>last1</code> 表示第一个范围的起始和结束位置；</li>
<li><code>first2</code> 和 <code>last2</code> 表示第二个范围的起始和结束位置；</li>
<li><code>comp</code> 是一个可选的比较函数，用于定义元素之间的比较方式。如果不提供比较函数，则默认使用 <code>&lt;</code> 运算符来进行比较。</li>
</ul>
<p><code>std::lexicographical_compare</code> 函数按照字典序对两个范围进行比较。它逐个比较两个范围中的元素，并返回一个布尔值，指示了这两个范围的大小关系。如果第一个范围在字典序上小于第二个范围，则返回 <code>true</code>；如果第一个范围大于等于第二个范围，则返回 <code>false</code>。</p>
<p>以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个向量的字典序大小关系</span></span><br><span class="line">    <span class="type">bool</span> result = std::<span class="built_in">lexicographical_compare</span>(vec<span class="number">1.</span><span class="built_in">begin</span>(), vec<span class="number">1.</span><span class="built_in">end</span>(), vec<span class="number">2.</span><span class="built_in">begin</span>(), vec<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vec1 is lexicographically less than vec2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vec1 is lexicographically greater than or equal to vec2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::lexicographical_compare</code> 函数被用于比较两个向量 <code>vec1</code> 和 <code>vec2</code> 的字典序大小关系。根据返回的布尔值，输出了两个范围的大小关系。</p>
<p><code>std::lexicographical_compare</code> 对于比较两个范围的字典序关系非常有用。它可用于排序算法的实现，也可用于确定两个序列的顺序关系。</p>
<h2 id="std-remove"><a href="#std-remove" class="headerlink" title="std::remove"></a>std::remove</h2><p><code>std::remove</code> 是 C++ 标准库中的一个算法，位于 <code>&lt;algorithm&gt;</code> 头文件中，用于从序列中移除特定的元素并将其移到序列末尾。但需要注意的是，<code>std::remove</code> 并不会真正删除元素，它只是将要删除的元素移到序列的末尾，并返回一个指向新末尾之后第一个元素的迭代器。</p>
<h3 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">remove</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>first</code>：指向要处理的序列的起始位置的迭代器。</li>
<li><code>last</code>：指向要处理的序列的末尾位置的迭代器（不包含在处理范围内）。</li>
<li><code>value</code>：要移除的特定元素的值。</li>
</ul>
<h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h3><p>返回一个迭代器，指向移除元素后的新的逻辑结尾位置。该位置之后的元素可能是无效值或者是移除元素之前的值。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::remove 移除向量中的值为 2 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> newEnd = std::<span class="built_in">remove</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际删除元素前，可以通过 [numbers.begin(), newEnd) 的范围来访问有效元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;移除元素后的向量内容为: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != newEnd; ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行此代码会输出：<code>移除元素后的向量内容为: 1 3 4 5 6 </code>。在这个例子中，<code>std::remove</code> 用于移除向量中的值为 2 的元素，并返回一个新的逻辑结尾位置的迭代器，指向有效元素的末尾。</p>
<p>注意，<code>std::remove</code> 并不会真正删除元素，而是将要删除的元素移到末尾。如果需要删除这些元素，可以使用向量的成员函数 <code>erase()</code>。</p>
<h2 id="std-unique"><a href="#std-unique" class="headerlink" title="std::unique"></a>std::unique</h2><p><code>std::unique</code> 是 C++ 标准库中 <code>&lt;algorithm&gt;</code> 头文件提供的一个函数，用于在范围中移除连续的重复元素。这个函数的行为是将相邻的重复元素移到范围的末尾，并返回一个指向新的范围末尾的迭代器。之后，可以使用这个迭代器来擦除重复元素。</p>
<p>以下是 <code>std::unique</code> 的详解：</p>
<h3 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIt</span>&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">unique</span><span class="params">(ForwardIt first, ForwardIt last)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>first</code>: 范围的起始位置的迭代器。</li>
<li><code>last</code>: 范围的结束位置的迭代器。</li>
</ul>
<h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h3><p><code>std::unique</code> 返回一个迭代器，指向新范围的末尾。在这个新范围中，不再包含相邻的重复元素。</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>std::unique</code> 只能去除相邻的重复元素。如果要移除所有重复元素，通常需要先使用 <code>std::sort</code> 对范围进行排序。</li>
</ul>
<h3 id="使用示例：-1"><a href="#使用示例：-1" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::unique 移除相邻的重复元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">unique</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 erase 擦除重复元素</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(it, numbers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::unique</code> 被用于移除相邻的重复元素，然后通过 <code>erase</code> 函数擦除这些元素。最终，输出的结果是不包含相邻重复元素的向量 <code>[1, 2, 3, 4, 5]</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_30_set/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_30_set/" class="post-title-link" itemprop="url">C++_10_30_set</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <set>标准库</li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul>
<li>set容器定义在<set>头文件中，和map非常相似。</li>
<li>区别在于set保存的不是键值对，在set中本身就是键。如果信息没有显式的键，且希望进行排序(不包含重复)以便快速的执行插入，查找和删除，就可以考虑使用set容器存储此类信息。</li>
<li>不能修改set中元素的键值，因为修改容器中的set元素会破坏顺序。</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <set>标准库</h2><p><code>&lt;set&gt;</code> 是 C++ 标准库中的头文件，定义了一组容器类模板，用于实现集合（Set）和关联容器的功能。</p>
<h3 id="std-set："><a href="#std-set：" class="headerlink" title="std::set："></a>std::set：</h3><ul>
<li><code>std::set</code> 是一个关联容器，用于存储一组唯一的、已排序的元素。</li>
<li>内部元素按照某个严格弱顺序排列（默认是升序），并且元素值是唯一的。</li>
<li>主要特点：<ul>
<li>自动排序：元素按照某个严格弱顺序（由比较函数或默认的 <code>&lt;</code> 运算符决定）自动排序。</li>
<li>唯一性：不允许重复的元素存在。</li>
<li>查找、插入和删除操作的时间复杂度为 O(log n)。</li>
</ul>
</li>
<li>主要操作：<ul>
<li><code>insert(const value_type&amp; val)</code>: 插入元素 <code>val</code>。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const value_type&amp; val)</code>: 查找元素 <code>val</code> 的位置。</li>
<li><code>size()</code>: 返回集合中元素的数量。</li>
<li><code>empty()</code>: 判断集合是否为空。</li>
</ul>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出集合中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::set</code> 的基本使用方法，包括插入元素、查找元素、删除元素以及遍历输出集合中的元素。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <set>标准库 详解</h2><p><code>&lt;set&gt;</code> 是 C++ 标准库中的头文件，提供了实现关联容器中集合（Set）的类模板。这些集合类模板允许用户存储一组唯一的、已排序的元素。</p>
<h3 id="std-set-和-std-multiset："><a href="#std-set-和-std-multiset：" class="headerlink" title="std::set 和 std::multiset："></a>std::set 和 std::multiset：</h3><ul>
<li><code>std::set</code> 和 <code>std::multiset</code> 都是关联容器。</li>
<li><code>std::set</code> 存储一组唯一的已排序元素，每个元素只能出现一次。</li>
<li><code>std::multiset</code> 存储一组已排序的元素，允许元素重复出现。</li>
</ul>
<h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>有序性：</strong> 内部元素按照某个严格弱顺序（默认是升序）排列。</li>
<li><strong>唯一性：</strong> <code>std::set</code> 中的元素是唯一的，而 <code>std::multiset</code> 允许重复元素存在。</li>
<li><strong>自动排序：</strong> 插入新元素时会自动按照严格弱顺序进行排序。</li>
<li><strong>底层实现：</strong> 通常使用平衡二叉树（红黑树）来实现。</li>
</ul>
<h3 id="主要操作："><a href="#主要操作：" class="headerlink" title="主要操作："></a>主要操作：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入元素。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const value_type&amp; val)</code>: 查找元素。</li>
<li><code>size()</code>: 返回集合中元素的数量。</li>
<li><code>empty()</code>: 判断集合是否为空。</li>
<li>迭代器支持：可以使用迭代器遍历集合中的元素。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::set</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>); <span class="comment">// 重复元素不会被插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出集合中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此示例演示了 <code>std::set</code> 的基本用法，包括创建、插入、删除、查找元素以及遍历输出集合中的元素。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <set>标准库 常用的类和函数</h2><p>在 C++ <code>&lt;set&gt;</code> 标准库中，最常用的类包括 <code>std::set</code> 和 <code>std::multiset</code>，它们提供了操作集合的常用函数和方法。</p>
<h3 id="主要类："><a href="#主要类：" class="headerlink" title="主要类："></a>主要类：</h3><ol>
<li><p><strong>std::set</strong>：</p>
<ul>
<li>用于存储一组唯一的、已排序的元素。</li>
<li>特点：<ul>
<li>内部元素按照严格弱顺序（默认升序）排列。</li>
<li>元素是唯一的，不允许重复。</li>
</ul>
</li>
<li>主要方法：<ul>
<li><code>insert(const value_type&amp; val)</code>: 插入元素。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const value_type&amp; val)</code>: 查找元素。</li>
<li><code>size()</code>: 返回集合中元素的数量。</li>
<li><code>empty()</code>: 判断集合是否为空。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>std::multiset</strong>：</p>
<ul>
<li>用于存储一组已排序的元素，允许元素重复。</li>
<li>特点：<ul>
<li>内部元素按照严格弱顺序（默认升序）排列。</li>
<li>元素允许重复出现。</li>
</ul>
</li>
<li>主要方法与 <code>std::set</code> 类似。</li>
</ul>
</li>
</ol>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 将元素 <code>val</code> 插入集合。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const value_type&amp; val)</code>: 查找元素 <code>val</code>。</li>
<li><code>size()</code>: 返回集合中元素的数量。</li>
<li><code>empty()</code>: 判断集合是否为空。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; myMultiSet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">    myMultiSet.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">    myMultiSet.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in set:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; elem;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in multiset:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myMultiSet) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; elem;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::set</code> 和 <code>std::multiset</code> 的基本用法，包括插入、删除、查找元素以及遍历输出集合中的元素。</p>
<h2 id="std-set"><a href="#std-set" class="headerlink" title="std::set"></a>std::set</h2><p><code>std::set</code> 是 C++ 标准库中定义的关联容器，用于存储一组唯一的、已排序的元素。</p>
<h3 id="主要特点：-1"><a href="#主要特点：-1" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>有序性：</strong> 内部元素按照某个严格弱顺序（默认是升序）排列。</li>
<li><strong>唯一性：</strong> <code>std::set</code> 中的元素是唯一的，不允许重复。</li>
<li><strong>自动排序：</strong> 插入新元素时会自动按照严格弱顺序进行排序。</li>
<li><strong>底层实现：</strong> 通常使用平衡二叉树（红黑树）来实现。</li>
</ul>
<h3 id="主要操作：-1"><a href="#主要操作：-1" class="headerlink" title="主要操作："></a>主要操作：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入元素。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const value_type&amp; val)</code>: 查找元素。</li>
<li><code>size()</code>: 返回集合中元素的数量。</li>
<li><code>empty()</code>: 判断集合是否为空。</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>); <span class="comment">// 重复元素不会被插入</span></span><br><span class="line"></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，展示了 <code>std::set</code> 的基本使用方法，包括创建、插入、删除、查找元素以及遍历输出集合中的元素。</p>
<h2 id="std-set-find"><a href="#std-set-find" class="headerlink" title="std::set::find()"></a>std::set::find()</h2><p><code>std::set::find()</code> 是用于在 <code>std::set</code> 集合中查找特定元素的成员函数。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>key</code>：要查找的元素的键值。</li>
<li>返回值：如果找到匹配的元素，则返回指向该元素的迭代器；如果未找到匹配的元素，则返回指向集合末尾的迭代器 <code>end()</code>。</li>
</ul>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in set: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element not found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = mySet.<span class="built_in">find</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in set: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element not found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::set::find()</code> 用于查找集合中的特定元素。如果找到匹配的元素，则返回指向该元素的迭代器；否则返回 <code>end()</code>。</p>
<h2 id="std-multiset"><a href="#std-multiset" class="headerlink" title="std::multiset"></a>std::multiset</h2><p><code>std::multiset</code> 是 C++ 标准库中定义的关联容器，类似于 <code>std::set</code>，但允许元素重复出现。</p>
<h3 id="主要特点：-2"><a href="#主要特点：-2" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>有序性：</strong> 内部元素按照某个严格弱顺序（默认是升序）排列。</li>
<li><strong>允许重复：</strong> <code>std::multiset</code> 中的元素可以重复出现，即允许存储相同的元素。</li>
<li><strong>自动排序：</strong> 插入新元素时会自动按照严格弱顺序进行排序。</li>
<li><strong>底层实现：</strong> 通常使用平衡二叉树（红黑树）来实现。</li>
</ul>
<h3 id="主要操作：-2"><a href="#主要操作：-2" class="headerlink" title="主要操作："></a>主要操作：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入元素。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const value_type&amp; val)</code>: 查找元素。</li>
<li><code>size()</code>: 返回集合中元素的数量。</li>
<li><code>empty()</code>: 判断集合是否为空。</li>
</ul>
<h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; myMultiSet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myMultiSet.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">    myMultiSet.<span class="built_in">insert</span>(<span class="number">2</span>); <span class="comment">// 允许重复元素插入</span></span><br><span class="line"></span><br><span class="line">    myMultiSet.<span class="built_in">erase</span>(<span class="number">2</span>); <span class="comment">// 删除一个 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myMultiSet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMultiSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in multiset&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myMultiSet) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了 <code>std::multiset</code> 的基本用法，包括创建、插入、删除、查找元素以及遍历输出集合中的元素。与 <code>std::set</code> 不同的是，<code>std::multiset</code> 允许重复元素的存在。</p>
<h2 id="std-multiset-find"><a href="#std-multiset-find" class="headerlink" title="std::multiset::find()"></a>std::multiset::find()</h2><p><code>std::multiset::find()</code> 是用于在 <code>std::multiset</code> 多重集合中查找特定元素的成员函数。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>key</code>：要查找的元素的键值。</li>
<li>返回值：如果找到匹配的元素，则返回指向该元素的迭代器；如果未找到匹配的元素，则返回指向集合末尾的迭代器 <code>end()</code>。</li>
</ul>
<h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; myMultiSet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myMultiSet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMultiSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in multiset: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element not found in multiset&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = myMultiSet.<span class="built_in">find</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMultiSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in multiset: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element not found in multiset&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::multiset::find()</code> 用于查找多重集合中的特定元素。如果找到匹配的元素，则返回指向该元素的迭代器；否则返回 <code>end()</code>。与 <code>std::set</code> 不同，<code>std::multiset</code> 允许元素重复，因此可能会返回多个匹配的元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_31_map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_31_map/" class="post-title-link" itemprop="url">C++_10_31_map</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <map>标准库</li>
</ul>
<h2 id="C-std-map-两个值作为一个map中的键"><a href="#C-std-map-两个值作为一个map中的键" class="headerlink" title="C++ std::map 两个值作为一个map中的键"></a>C++ std::map 两个值作为一个map中的键</h2><p>在 C++ 中，如果你想要使用两个值作为 <code>std::map</code> 的键，可以通过定义一个 <code>std::pair</code> 来实现。<code>std::pair</code> 能够将两个值组合成一个键，同时也支持字典序的比较，因此可以很好地用作 <code>std::map</code> 的键。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// std::pair</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::pair 作为键，int 作为值</span></span><br><span class="line">    std::map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    myMap[&#123;<span class="number">1</span>, <span class="number">2</span>&#125;] = <span class="number">100</span>;</span><br><span class="line">    myMap[&#123;<span class="number">3</span>, <span class="number">4</span>&#125;] = <span class="number">200</span>;</span><br><span class="line">    myMap[&#123;<span class="number">1</span>, <span class="number">3</span>&#125;] = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历和访问元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: (&quot;</span> &lt;&lt; entry.first.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; entry.first.second </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;) -&gt; Value: &quot;</span> &lt;&lt; entry.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找特定键</span></span><br><span class="line">    std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; key = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (myMap.<span class="built_in">find</span>(key) != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value for key (1, 2): &quot;</span> &lt;&lt; myMap[key] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>在这个例子中，<code>myMap</code> 的键类型是 <code>std::pair&lt;int, int&gt;</code>，值类型是 <code>int</code>。</li>
<li>通过 <code>&#123;1, 2&#125;</code> 这样的语法，可以直接构造 <code>std::pair&lt;int, int&gt;</code> 并作为键插入到 <code>std::map</code> 中。</li>
<li><code>std::map</code> 会根据键的字典序进行排序，即先比较第一个元素，再比较第二个元素。</li>
</ul>
<h3 id="自定义比较"><a href="#自定义比较" class="headerlink" title="自定义比较"></a>自定义比较</h3><p>如果你希望使用自定义的排序规则，也可以通过定义一个自定义的比较器类并传入 <code>std::map</code> 构造函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomCompare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义排序逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (a.first == b.first) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>, CustomCompare&gt; customMap;</span><br></pre></td></tr></table></figure>

<h2 id="有序关联容器"><a href="#有序关联容器" class="headerlink" title="有序关联容器"></a>有序关联容器</h2><ul>
<li>与顺序关联容器不同，有序关联容器不采用线性方式保存元素。相反，有序关联容器将键映射到值。通常情况下，有序关联容器的插入，删除和查找时间是相等的。</li>
<li>标准库提供的4个有序关联容器分别为: map, multimap, set, multiset。</li>
<li>每种有序关联容器都将元素保存在类似于树的有序数据结构。</li>
<li>还有4个无序关联容器: unordered_map, unordered_multimap, unordered_set, unordered_multiset</li>
</ul>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>map定义在<map>头文件中，它保存的是键&#x2F;值对，而不是只保存值</li>
<li>插入，查找和删除操作都是基于键的，值只不过是附属品。从概念上讲，map这个术语源于容器将键映射到值</li>
<li>当需要根据键保存或获取元素时，以及需要按照特定顺序保存元素时，应该使用map</li>
</ul>
<h3 id="构建map"><a href="#构建map" class="headerlink" title="构建map"></a>构建map</h3><ul>
<li>map类模板接受4种类型: 键类型，值类型，比较类型以及分配器类型</li>
<li>如果忽略比较参数和分配器参数，那么map的构建和vector或list的构建是一样的，区别在于模板实例化中需要分别指定键和值的类型。</li>
<li>例如构建一个map，使用int值作为键，Data类的对象作为值，map&lt;int, Data&gt; dataMap;在内部，dataMap为map中的每个元素存储一个pair&lt;int, Data&gt;</li>
</ul>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><ul>
<li><p>向顺序容器(例如vector和list)插入元素时，总是需要指定要插入元素的位置，而map不一样，它和其他关联容器都不需要指定插入位置。</p>
</li>
<li><p>map的内部实现会决定要保存新元素的位置，只需要提供键和值即可。</p>
</li>
<li><p>insert()方法。</p>
</li>
<li><p>可以使用insert()方法向map添加元素，它有一个好处：允许判断键是否已经存在。insert()方法的一个问题是必须将键&#x2F;值对指定为pair对象或initializer_list。</p>
</li>
<li><p>insert()的基本形式的返回类型是迭代器和布尔值组成的pair。返回类型这么复杂的原因是：</p>
<ul>
<li>如果指定的键已经存在，那么insert()不会改写元素值。返回的pair中的bool元素指出insert()是否真的插入了新的键&#x2F;值对。</li>
<li>迭代器引用是map中带有指定键的元素(根据插入成功与否这个键对应的值可能是新值或旧值)</li>
</ul>
</li>
<li><p>operator[]</p>
</li>
<li><p>向map插入元素的另一种方法是通过重载的operator[]。这种方法的区别主要在于语法：键和值分别是指定的。</p>
</li>
<li><p>此外，operator[]总是成功的。如果给定键没有对应的元素值，那么就会创建带有对应键值的新元素。如果具有给定键的元素已经存在，operator[]会将元素值替换为新指定的值。</p>
</li>
<li><p>不过operator[]有一点要注意：</p>
<ul>
<li>它总会构建一个新的值对象，即并不需要使用这个值对象，也同样如此。</li>
<li>因为需要为元素提供一个默认的构造函数，这样可能会比insert()的效率低</li>
</ul>
</li>
<li><p>emplace方法</p>
</li>
<li><p>map支持emplace()和emplace_hint()，从而在原位置构建元素，这与vector的emplace方法类似。</p>
</li>
<li><p>还有一个try_emplace()方法，如果给定的键还不存在，那么它将在原位置插入元素；如果map中 已经存在相应的键，则什么也不做。</p>
</li>
</ul>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><ul>
<li>map可根据指定的键查找元素，时间复杂度为指数时间</li>
<li>如果只想指导在map中是否存在具有给定键的元素，那么可以使用count()成员函数。这个函数返回map中给定键的元素个数。对于map来说，这个函数返回的结果不是0就是1,因为map中不允许具有重复键的元素。</li>
</ul>
<h2 id="C-std-map-find-函数-详解"><a href="#C-std-map-find-函数-详解" class="headerlink" title="C++ std::map::find() 函数 详解"></a>C++ std::map::find() 函数 详解</h2><p><code>std::map::find()</code> 是 C++ 标准模板库（STL）中 <code>std::map</code> 类的成员函数之一，用于在 map 中查找给定键的位置。以下是该函数的详细解释：</p>
<p><strong>函数签名：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><code>k</code>：要查找的键值。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>如果找到了给定键，则返回指向该键值对的迭代器；</li>
<li>如果未找到，则返回指向 <code>end()</code> 的迭代器。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一些键值对</span></span><br><span class="line">    myMap[<span class="number">1</span>] = <span class="string">&quot;One&quot;</span>;</span><br><span class="line">    myMap[<span class="number">2</span>] = <span class="string">&quot;Two&quot;</span>;</span><br><span class="line">    myMap[<span class="number">3</span>] = <span class="string">&quot;Three&quot;</span>;</span><br><span class="line">    myMap[<span class="number">4</span>] = <span class="string">&quot;Four&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键为2的位置</span></span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查结果</span></span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key found: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试查找不存在的键</span></span><br><span class="line">    it = myMap.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查结果</span></span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key found: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用 <code>myMap.find(2)</code> 查找键为2的位置，并输出结果。然后，我们尝试使用 <code>myMap.find(5)</code> 查找不存在的键，并输出结果。通过使用 <code>find</code> 函数，我们可以有效地检查某个键是否存在于 <code>std::map</code> 中，以及在存在的情况下获取相应的值。</p>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <map>标准库</h2><p><code>&lt;map&gt;</code> 是 C++ 标准库中的头文件，定义了一组容器类模板，用于实现键-值对形式的关联容器。</p>
<h3 id="std-map："><a href="#std-map：" class="headerlink" title="std::map："></a>std::map：</h3><ul>
<li><code>std::map</code> 是一个关联容器，用于存储一组键值对（key-value pairs）。</li>
<li>每个元素都是一个键值对，其中键（key）唯一，用于索引和快速查找值（value）。</li>
<li>内部元素按照键的严格弱顺序（默认是升序）排列。</li>
<li>主要特点：<ul>
<li>键值对按照键的严格弱顺序排列。</li>
<li>键是唯一的，不允许重复。</li>
<li>支持快速的查找、插入和删除操作。</li>
</ul>
</li>
</ul>
<h3 id="主要操作："><a href="#主要操作：" class="headerlink" title="主要操作："></a>主要操作：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入键值对。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const key_type&amp; key)</code>: 查找键对应的值。</li>
<li><code>size()</code>: 返回 map 中元素的数量。</li>
<li><code>empty()</code>: 判断 map 是否为空。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    myMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob&#x27;s age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob not found in map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 map 中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::map</code> 的基本使用方法，包括插入键值对、查找元素、遍历输出 map 中的键值对等操作。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <map>标准库 详解</h2><p><code>&lt;map&gt;</code> 是 C++ 标准库中的头文件，定义了一组容器类模板，用于实现关联容器，允许存储一组唯一键和对应的值。主要包括 <code>std::map</code> 和 <code>std::multimap</code>。</p>
<h3 id="std-map：-1"><a href="#std-map：-1" class="headerlink" title="std::map："></a>std::map：</h3><ul>
<li><code>std::map</code> 是一个关联容器，存储键值对，其中每个键都是唯一的，用于快速查找对应的值。</li>
<li>主要特点：<ul>
<li>键值对是按照键的严格弱顺序（默认是升序）排列。</li>
<li>键是唯一的，不允许重复。</li>
</ul>
</li>
<li>主要操作：<ul>
<li><code>insert(const value_type&amp; val)</code>: 插入键值对。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const key_type&amp; key)</code>: 查找键对应的值。</li>
<li><code>size()</code>: 返回 map 中元素的数量。</li>
<li><code>empty()</code>: 判断 map 是否为空。</li>
</ul>
</li>
</ul>
<h3 id="std-multimap："><a href="#std-multimap：" class="headerlink" title="std::multimap："></a>std::multimap：</h3><ul>
<li><code>std::multimap</code> 与 <code>std::map</code> 类似，但允许键重复出现。</li>
<li>主要特点：<ul>
<li>键值对是按照键的严格弱顺序（默认是升序）排列。</li>
<li>键允许重复。</li>
</ul>
</li>
<li>主要操作与 <code>std::map</code> 类似。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    myMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob&#x27;s age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob not found in map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了 <code>std::map</code> 的基本用法，包括插入键值对、查找元素、遍历输出 map 中的键值对等操作。<code>std::multimap</code> 的使用与此类似，但允许键重复出现。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <map>标准库 常用的类和函数</h2><p>在 C++ <code>&lt;map&gt;</code> 标准库中，最常用的类是 <code>std::map</code> 和 <code>std::multimap</code>，它们提供了操作键-值对集合的常用函数和方法。</p>
<h3 id="主要类："><a href="#主要类：" class="headerlink" title="主要类："></a>主要类：</h3><ol>
<li><p><strong>std::map</strong>：</p>
<ul>
<li>用于存储一组唯一的键值对，其中每个键是唯一的。</li>
<li>特点：<ul>
<li>键值对按照键的严格弱顺序（默认是升序）排列。</li>
<li>键是唯一的，不允许重复。</li>
</ul>
</li>
<li>主要方法：<ul>
<li><code>insert(const value_type&amp; val)</code>: 插入键值对。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const key_type&amp; key)</code>: 查找键对应的值。</li>
<li><code>size()</code>: 返回 map 中元素的数量。</li>
<li><code>empty()</code>: 判断 map 是否为空。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>std::multimap</strong>：</p>
<ul>
<li>与 <code>std::map</code> 类似，但允许键重复出现。</li>
<li>特点：<ul>
<li>键值对按照键的严格弱顺序（默认是升序）排列。</li>
<li>键允许重复。</li>
</ul>
</li>
<li>主要方法与 <code>std::map</code> 类似。</li>
</ul>
</li>
</ol>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入键值对。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const key_type&amp; key)</code>: 查找键对应的值。</li>
<li><code>size()</code>: 返回 map 中元素的数量。</li>
<li><code>empty()</code>: 判断 map 是否为空。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    myMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob&#x27;s age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob not found in map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::map</code> 的基本用法，包括插入键值对、查找元素、遍历输出 map 中的键值对等操作。<code>std::multimap</code> 的使用与此类似，但允许键重复出现。</p>
<h2 id="std-map"><a href="#std-map" class="headerlink" title="std::map"></a>std::map</h2><p><code>std::map</code> 是 C++ 标准库中的关联容器，用于存储一组键值对（key-value pairs）。每个键都是唯一的，可以快速查找对应的值。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><strong>有序性：</strong> 内部元素按照键的严格弱顺序（默认是升序）排列。</li>
<li><strong>唯一键：</strong> 键是唯一的，每个键对应一个值，不允许键的重复。</li>
<li><strong>底层实现：</strong> 通常使用平衡二叉树（红黑树）来实现。</li>
</ul>
<h3 id="主要操作：-1"><a href="#主要操作：-1" class="headerlink" title="主要操作："></a>主要操作：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入键值对。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const key_type&amp; key)</code>: 查找键对应的值。</li>
<li><code>size()</code>: 返回 map 中键值对的数量。</li>
<li><code>empty()</code>: 判断 map 是否为空。</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    myMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob&#x27;s age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob not found in map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::map</code> 的基本用法，包括插入键值对、查找元素、遍历输出 map 中的键值对等操作。</p>
<h2 id="std-multimap"><a href="#std-multimap" class="headerlink" title="std::multimap"></a>std::multimap</h2><p><code>std::multimap</code> 是 C++ 标准库中的关联容器，类似于 <code>std::map</code>，但允许键重复出现。</p>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><strong>有序性：</strong> 内部元素按照键的严格弱顺序（默认是升序）排列。</li>
<li><strong>允许重复键：</strong> <code>std::multimap</code> 中的键允许重复出现，即允许多个键对应不同的值。</li>
<li><strong>底层实现：</strong> 通常使用平衡二叉树（红黑树）来实现。</li>
</ul>
<h3 id="主要操作：-2"><a href="#主要操作：-2" class="headerlink" title="主要操作："></a>主要操作：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入键值对。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const key_type&amp; key)</code>: 查找键对应的值。</li>
<li><code>size()</code>: 返回 multimap 中键值对的数量。</li>
<li><code>empty()</code>: 判断 multimap 是否为空。</li>
</ul>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multimap&lt;std::string, <span class="type">int</span>&gt; myMultiMap;</span><br><span class="line"></span><br><span class="line">    myMultiMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    myMultiMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>));</span><br><span class="line">    myMultiMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>));</span><br><span class="line">    myMultiMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">32</span>)); <span class="comment">// 允许重复键</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myMultiMap.<span class="built_in">find</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMultiMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob&#x27;s age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob not found in multimap&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMultiMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::multimap</code> 的基本用法，包括插入键值对、查找元素、遍历输出 multimap 中的键值对等操作。与 <code>std::map</code> 不同，<code>std::multimap</code> 允许多个键对应不同的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_32_iomanip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_32_iomanip/" class="post-title-link" itemprop="url">C++_10_32_iomanip</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <iomanip>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <iomanip>标准库</h2><p><code>&lt;iomanip&gt;</code> 是 C++ 标准库中的头文件，提供了与格式化输入输出相关的工具和操作符。这个头文件主要包含了用于控制输入输出格式的类和函数。</p>
<h3 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h3><ol>
<li><p><strong>操纵符（Manipulators）：</strong></p>
<ul>
<li><code>std::setw(int n)</code>: 设置域宽（用于下一个输出项）。</li>
<li><code>std::setprecision(int n)</code>: 设置浮点数的精度。</li>
<li><code>std::setfill(char c)</code>: 设置填充字符。</li>
<li><code>std::left</code>, <code>std::right</code>, <code>std::internal</code>: 控制输出对齐方式。</li>
<li><code>std::boolalpha</code>: 将布尔值输出为 “true” 或 “false”。</li>
<li><code>std::hex</code>, <code>std::dec</code>, <code>std::oct</code>: 控制输出的进制。</li>
<li>等等。</li>
</ul>
</li>
<li><p><strong>流控制：</strong></p>
<ul>
<li><code>std::fixed</code>, <code>std::scientific</code>: 控制浮点数输出的格式。</li>
<li><code>std::showpoint</code>: 总是显示小数点。</li>
<li><code>std::noshowpoint</code>: 不显示小数点。</li>
<li><code>std::uppercase</code>: 使用大写字母表示科学计数法中的指数。</li>
<li><code>std::nouppercase</code>: 使用小写字母表示科学计数法中的指数。</li>
<li>等等。</li>
</ul>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 设置域宽为 10</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; pi &lt;&lt; std::endl; <span class="comment">// 设置浮点数的精度为 3</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 设置域宽为 8，填充字符为 &#x27;*&#x27;</span></span><br><span class="line">    std::cout &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 左对齐</span></span><br><span class="line">    std::cout &lt;&lt; std::scientific &lt;&lt; pi &lt;&lt; std::endl; <span class="comment">// 科学计数法输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>&lt;iomanip&gt;</code> 中一些常用的格式化输出操作，如设置域宽、设置精度、设置填充字符、对齐方式、科学计数法输出等。这些操作可用于控制输入输出的格式，使输出更易读、更美观。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <iomanip>标准库 详解</h2><p><code>&lt;iomanip&gt;</code> 是 C++ 标准库中的头文件，提供了用于格式化输入输出的工具和操作符。它包含了多种操纵符（manipulators）、流控制器（stream control）、标志（flags）和函数，用于调整输出的格式以及控制流的行为。</p>
<h3 id="主要内容：-1"><a href="#主要内容：-1" class="headerlink" title="主要内容："></a>主要内容：</h3><ol>
<li><p><strong>操纵符（Manipulators）：</strong></p>
<ul>
<li><code>std::setw(int n)</code>: 设置下一个输出项的宽度。</li>
<li><code>std::setprecision(int n)</code>: 设置浮点数的输出精度。</li>
<li><code>std::setfill(char c)</code>: 设置填充字符。</li>
<li><code>std::left</code>, <code>std::right</code>, <code>std::internal</code>: 控制对齐方式。</li>
<li><code>std::boolalpha</code>: 将布尔值以文本形式输出。</li>
<li><code>std::hex</code>, <code>std::dec</code>, <code>std::oct</code>: 控制整数的输出进制。</li>
<li>等等。</li>
</ul>
</li>
<li><p><strong>流控制器（Stream Control）：</strong></p>
<ul>
<li><code>std::fixed</code>, <code>std::scientific</code>: 控制浮点数的输出格式。</li>
<li><code>std::showpoint</code>: 总是显示小数点。</li>
<li><code>std::noshowpoint</code>: 不显示小数点。</li>
<li><code>std::uppercase</code>: 使用大写字母表示科学计数法中的指数部分。</li>
<li><code>std::nouppercase</code>: 使用小写字母表示科学计数法中的指数部分。</li>
<li>等等。</li>
</ul>
</li>
<li><p><strong>标志（Flags）：</strong></p>
<ul>
<li><code>std::ios::fmtflags</code>: 标志位，用于控制输入输出流的格式状态。</li>
<li><code>std::ios::flags()</code>: 设置或查询格式标志位。</li>
<li><code>std::ios::setf()</code>, <code>std::ios::unsetf()</code>: 设置或取消设置格式标志位。</li>
<li>等等。</li>
</ul>
</li>
<li><p><strong>函数：</strong></p>
<ul>
<li><code>std::setiosflags()</code>, <code>std::resetiosflags()</code>: 设置或重置格式标志位。</li>
<li><code>std::get_money()</code>, <code>std::put_money()</code>: 对货币值进行输入输出。</li>
<li><code>std::get_time()</code>, <code>std::put_time()</code>: 对时间进行输入输出。</li>
<li>等等。</li>
</ul>
</li>
</ol>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">    std::chrono::system_clock::time_point now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::<span class="type">time_t</span> time = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 设置域宽为 10</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; pi &lt;&lt; std::endl; <span class="comment">// 设置浮点数的精度为 3</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 设置域宽为 8，填充字符为 &#x27;*&#x27;</span></span><br><span class="line">    std::cout &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 左对齐</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;time), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl; <span class="comment">// 输出时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例展示了 <code>&lt;iomanip&gt;</code> 头文件中一些常用操作的使用方法，如设置域宽、设置精度、设置填充字符、对齐方式、时间输出等。这些操作可以用于调整输出格式以及处理特定类型的输入输出。</p>
<h2 id="C-标准库-常用类和函数"><a href="#C-标准库-常用类和函数" class="headerlink" title="C++ 标准库 常用类和函数"></a>C++ <iomanip>标准库 常用类和函数</h2><p><code>&lt;iomanip&gt;</code> 标准库提供了多种类和函数，用于格式化输入输出。以下是其中一些常用的类和函数：</p>
<h3 id="常用操纵符（Manipulators）："><a href="#常用操纵符（Manipulators）：" class="headerlink" title="常用操纵符（Manipulators）："></a>常用操纵符（Manipulators）：</h3><ul>
<li>**<code>std::setw(int n)</code>**：设置下一个输出项的宽度为 <code>n</code>。</li>
<li>**<code>std::setprecision(int n)</code>**：设置浮点数的输出精度为 <code>n</code>。</li>
<li>**<code>std::setfill(char c)</code>**：设置填充字符为 <code>c</code>。</li>
<li>**<code>std::left</code>, <code>std::right</code>, <code>std::internal</code>**：控制对齐方式。</li>
<li>**<code>std::boolalpha</code>**：以文本形式输出布尔值（true&#x2F;false）。</li>
<li>**<code>std::hex</code>, <code>std::dec</code>, <code>std::oct</code>**：控制整数的输出进制。</li>
<li>**<code>std::fixed</code>, <code>std::scientific</code>**：控制浮点数的输出格式。</li>
<li>**<code>std::showpoint</code>**：总是显示小数点。</li>
<li>**<code>std::uppercase</code>**：使用大写字母表示科学计数法中的指数。</li>
<li>等等。</li>
</ul>
<h3 id="流控制器（Stream-Control）："><a href="#流控制器（Stream-Control）：" class="headerlink" title="流控制器（Stream Control）："></a>流控制器（Stream Control）：</h3><ul>
<li>**<code>std::ios::fmtflags</code>**：用于控制输入输出流的格式状态。</li>
<li>**<code>std::ios::flags()</code>**：设置或查询格式标志位。</li>
<li>**<code>std::ios::setf()</code>, <code>std::ios::unsetf()</code>**：设置或取消设置格式标志位。</li>
<li>**<code>std::setiosflags()</code>, <code>std::resetiosflags()</code>**：设置或重置格式标志位。</li>
<li>等等。</li>
</ul>
<h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><ul>
<li><strong><code>std::get_money()</code></strong>, <strong><code>std::put_money()</code></strong>: 对货币值进行输入输出。</li>
<li><strong><code>std::get_time()</code></strong>, <strong><code>std::put_time()</code></strong>: 对时间进行输入输出。</li>
<li>等等。</li>
</ul>
<p>这些类和函数可用于控制输入输出流的格式，包括对宽度、精度、对齐方式、填充字符、数字格式、时间格式等进行设置和调整。</p>
<h2 id="std-setw"><a href="#std-setw" class="headerlink" title="std::setw()"></a>std::setw()</h2><p><code>std::setw()</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于设置下一个输出项的宽度。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">setw</span>(<span class="type">int</span> n);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>n</code>：整数值，用于设置下一个输出项的宽度为 <code>n</code>。</li>
<li>返回值：<code>std::setw()</code> 不返回任何值。</li>
</ul>
<h3 id="用法示例："><a href="#用法示例：" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置域宽为 10</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::setw(10)</code> 用于设置输出项的宽度为 10。这意味着下一个输出的内容将在占用的字符宽度上占据 10 个字符位置。如果实际内容不足以填充这个宽度，空格将被用作填充字符。</p>
<h2 id="std-setprecision"><a href="#std-setprecision" class="headerlink" title="std::setprecision()"></a>std::setprecision()</h2><p><code>std::setprecision()</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于设置浮点数的输出精度。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">setprecision</span>(<span class="type">int</span> n);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>n</code>：整数值，用于设置浮点数的输出精度为 <code>n</code>。</li>
<li>返回值：<code>std::setprecision()</code> 不返回任何值。</li>
</ul>
<h3 id="用法示例：-1"><a href="#用法示例：-1" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置浮点数的输出精度为 3</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::setprecision(3)</code> 用于设置输出浮点数的小数位精度为 3。这意味着浮点数在输出时将只显示到小数点后 3 位。</p>
<h2 id="std-setfill"><a href="#std-setfill" class="headerlink" title="std::setfill()"></a>std::setfill()</h2><p><code>std::setfill()</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于设置填充字符。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">setfill</span>(<span class="type">char</span> c);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>c</code>：字符类型，表示要设置的填充字符。</li>
<li>返回值：<code>std::setfill()</code> 不返回任何值。</li>
</ul>
<h3 id="用法示例：-2"><a href="#用法示例：-2" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置填充字符为 &#x27;*&#x27;</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::setfill(&#39;*&#39;)</code> 用于设置填充字符为星号 <code>*</code>，而 <code>std::setw(8)</code> 则用于设置输出项的宽度为 8。这意味着如果实际输出项的字符数少于 8 个，则用星号填充空余位置。</p>
<h2 id="std-left"><a href="#std-left" class="headerlink" title="std::left()"></a>std::left()</h2><p><code>std::left</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于左对齐输出。</p>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::left</span><br></pre></td></tr></table></figure>

<p><code>std::left</code> 被应用于输出流之后，将使得后续的输出项（例如使用 <code>std::setw()</code> 设置宽度后的输出）左对齐显示。</p>
<h3 id="用法示例：-3"><a href="#用法示例：-3" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左对齐输出</span></span><br><span class="line">    std::cout &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::left</code> 用于设置输出的左对齐。<code>std::setw(8)</code> 则用于设置输出项的宽度为 8，如果实际输出项的字符数少于 8 个，则在右侧填充空余位置以保持左对齐输出。</p>
<h2 id="std-right"><a href="#std-right" class="headerlink" title="std::right()"></a>std::right()</h2><p><code>std::right</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于右对齐输出。</p>
<h3 id="使用方法：-1"><a href="#使用方法：-1" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::right</span><br></pre></td></tr></table></figure>

<p><code>std::right</code> 被应用于输出流之后，将使得后续的输出项（例如使用 <code>std::setw()</code> 设置宽度后的输出）右对齐显示。</p>
<h3 id="用法示例：-4"><a href="#用法示例：-4" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右对齐输出</span></span><br><span class="line">    std::cout &lt;&lt; std::right &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::right</code> 用于设置输出的右对齐。<code>std::setw(8)</code> 则用于设置输出项的宽度为 8，如果实际输出项的字符数少于 8 个，则在左侧填充空余位置以保持右对齐输出。</p>
<h2 id="std-internal"><a href="#std-internal" class="headerlink" title="std::internal()"></a>std::internal()</h2><p><code>std::internal</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于内部对齐输出。</p>
<h3 id="使用方法：-2"><a href="#使用方法：-2" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::internal</span><br></pre></td></tr></table></figure>

<p><code>std::internal</code> 被应用于输出流之后，将使得后续的输出项（例如使用 <code>std::setw()</code> 设置宽度后的输出）在输出时，数字等内部对齐。</p>
<h3 id="用法示例：-5"><a href="#用法示例：-5" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">-123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部对齐输出</span></span><br><span class="line">    std::cout &lt;&lt; std::internal &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::internal</code> 用于设置输出的内部对齐。<code>std::setw(8)</code> 用于设置输出项的宽度为 8。对于带有符号的整数，使用内部对齐时，会在数字之前打印符号，并将数字右对齐。</p>
<h2 id="std-boolalpha"><a href="#std-boolalpha" class="headerlink" title="std::boolalpha()"></a>std::boolalpha()</h2><p><code>std::boolalpha</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于控制布尔值的输出格式。</p>
<h3 id="使用方法：-3"><a href="#使用方法：-3" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::boolalpha</span><br></pre></td></tr></table></figure>

<p><code>std::boolalpha</code> 被应用于输出流之后，将使得后续的布尔值输出为文本形式，即 <code>true</code> 或 <code>false</code>，而非默认的整数值输出（1 或 0）。</p>
<h3 id="用法示例：-6"><a href="#用法示例：-6" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> status = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置布尔值的输出为文本形式</span></span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; status &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::boolalpha</code> 被用于设置布尔值的输出为文本形式，所以 <code>status</code> 的值 <code>true</code> 将以文本形式输出。</p>
<h2 id="std-hex"><a href="#std-hex" class="headerlink" title="std::hex()"></a>std::hex()</h2><p><code>std::hex</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于控制整数输出的进制为十六进制。</p>
<h3 id="使用方法：-4"><a href="#使用方法：-4" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::hex</span><br></pre></td></tr></table></figure>

<p><code>std::hex</code> 被应用于输出流之后，将使得后续的整数输出为十六进制形式。</p>
<h3 id="用法示例：-7"><a href="#用法示例：-7" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置整数输出为十六进制形式</span></span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::hex</code> 被用于设置整数输出为十六进制形式，所以 <code>num</code> 的值 255 将以十六进制形式输出为 <code>ff</code>。</p>
<h2 id="std-dex"><a href="#std-dex" class="headerlink" title="std::dex()"></a>std::dex()</h2><p><code>std::dec</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于将整数的输出进制设置为十进制。</p>
<h3 id="使用方法：-5"><a href="#使用方法：-5" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::dec</span><br></pre></td></tr></table></figure>

<p><code>std::dec</code> 被应用于输出流之后，将使得后续的整数输出为十进制形式。</p>
<h3 id="用法示例：-8"><a href="#用法示例：-8" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置整数输出为十六进制形式</span></span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置整数输出为十进制形式</span></span><br><span class="line">    std::cout &lt;&lt; std::dec &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，首先使用 <code>std::hex</code> 将整数输出设置为十六进制形式输出 <code>num</code> 的值为 <code>ff</code>，然后使用 <code>std::dec</code> 将整数输出设置回十进制形式输出 <code>num</code> 的值为 <code>255</code>。</p>
<h2 id="std-oct"><a href="#std-oct" class="headerlink" title="std::oct()"></a>std::oct()</h2><p><code>std::oct</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于将整数输出的进制设置为八进制。</p>
<h3 id="使用方法：-6"><a href="#使用方法：-6" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::oct</span><br></pre></td></tr></table></figure>

<p><code>std::oct</code> 被应用于输出流之后，将使得后续的整数输出为八进制形式。</p>
<h3 id="用法示例：-9"><a href="#用法示例：-9" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置整数输出为八进制形式</span></span><br><span class="line">    std::cout &lt;&lt; std::oct &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::oct</code> 被用于设置整数输出为八进制形式，所以 <code>num</code> 的值 <code>255</code> 将以八进制形式输出为 <code>377</code>。</p>
<h2 id="std-fixed"><a href="#std-fixed" class="headerlink" title="std::fixed()"></a>std::fixed()</h2><p><code>std::fixed</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于控制浮点数的输出格式为固定点表示法（fixed-point notation）。</p>
<h3 id="使用方法：-7"><a href="#使用方法：-7" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::fixed</span><br></pre></td></tr></table></figure>

<p><code>std::fixed</code> 被应用于输出流之后，将使得后续的浮点数输出使用固定的小数点位数（小数部分不会自动省略）。</p>
<h3 id="用法示例：-10"><a href="#用法示例：-10" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">123.456789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置浮点数输出为固定点表示法</span></span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::fixed</code> 被用于设置浮点数的输出格式为固定点表示法，因此 <code>value</code> 的值 <code>123.456789</code> 将以固定的小数点位数输出为 <code>123.456789</code>。</p>
<h2 id="std-scientific"><a href="#std-scientific" class="headerlink" title="std::scientific"></a>std::scientific</h2><p><code>std::scientific</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于控制浮点数的输出格式为科学计数法（scientific notation）。</p>
<h3 id="使用方法：-8"><a href="#使用方法：-8" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::scientific</span><br></pre></td></tr></table></figure>

<p><code>std::scientific</code> 被应用于输出流之后，将使得后续的浮点数输出使用科学计数法表示。</p>
<h3 id="用法示例：-11"><a href="#用法示例：-11" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">123456.789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置浮点数输出为科学计数法</span></span><br><span class="line">    std::cout &lt;&lt; std::scientific &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::scientific</code> 被用于设置浮点数的输出格式为科学计数法，因此 <code>value</code> 的值 <code>123456.789</code> 将以科学计数法形式输出为 <code>1.234568e+05</code>。</p>
<h2 id="std-showpoint"><a href="#std-showpoint" class="headerlink" title="std::showpoint()"></a>std::showpoint()</h2><p><code>std::showpoint()</code> 是 C++ 中用于控制输出浮点数的标志之一。它用于在输出浮点数时始终显示小数点，并显示末尾的零。在使用它后，无论小数部分是否为零，都会显示小数点和末尾的零。</p>
<p>在中文中，<code>std::showpoint()</code> 可以翻译为 “显示小数点”，用于指示程序在输出浮点数时应始终显示小数点及其后的零。</p>
<h2 id="std-noshowpoint"><a href="#std-noshowpoint" class="headerlink" title="std::noshowpoint()"></a>std::noshowpoint()</h2><p><code>std::noshowpoint()</code> 是 C++ 中用于控制浮点数输出的标志之一。它用于取消使用 <code>std::showpoint()</code> 设置，即停止在输出浮点数时始终显示小数点及其后的零。</p>
<p>在中文中，<code>std::noshowpoint()</code> 可以翻译为 “不显示小数点”，用于指示程序在输出浮点数时不显示小数点及其后的零。</p>
<h2 id="std-uppercase"><a href="#std-uppercase" class="headerlink" title="std::uppercase"></a>std::uppercase</h2><p><code>std::uppercase</code> 是 C++ 中用于控制输出的标志之一，它用于设置输出中的字母部分为大写字母。通常，它与输出十六进制数字时一起使用，以确保字母部分以大写形式显示。</p>
<p>例如，当使用输出操作符 <code>&lt;&lt;</code> 将整数以十六进制格式输出时，设置了 <code>std::uppercase</code> 标志后，输出的字母部分（A-F）将以大写字母显示。</p>
<p>在中文中，<code>std::uppercase</code> 可以翻译为 “大写”，表示将输出转换为大写形式。</p>
<h2 id="std-nouppercase"><a href="#std-nouppercase" class="headerlink" title="std::nouppercase"></a>std::nouppercase</h2><p><code>std::nouppercase</code> 是 C++ 中用于控制输出的标志之一，它用于取消设置输出中字母部分为大写字母的状态，即停止将输出的字母部分强制转换为大写形式。</p>
<p>通常情况下，<code>std::nouppercase</code> 用于取消之前设置的 <code>std::uppercase</code> 标志，使得输出的字母部分恢复到默认的小写形式。</p>
<p>在中文中，<code>std::nouppercase</code> 可以翻译为 “不大写”，表示取消将输出转换为大写形式的设置。</p>
<h2 id="std-ios-fmtflags"><a href="#std-ios-fmtflags" class="headerlink" title="std::ios::fmtflags"></a>std::ios::fmtflags</h2><p><code>std::ios::fmtflags</code> 是 C++ 中的一种数据类型，用于表示输入&#x2F;输出流的格式标志。它是 <code>std::ios</code> 类的一部分，用于存储各种控制输出格式的标志位，比如用于控制流的各种格式设置，如对齐、小数点精度、数制、浮点数的显示方式等等。</p>
<p>这个类型通常用于控制输出格式的相关设置，例如 <code>std::ios::hex</code> 用于设置输出流的进制为十六进制，<code>std::ios::scientific</code> 用于设置输出流的科学计数法等等。</p>
<p>它是一个位掩码枚举类型，意味着它的值可以是多个位的组合。通过将各种格式标志进行按位或操作，可以创建包含多个格式标志的组合。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::fmtflags flags = std::cout.<span class="built_in">flags</span>(); <span class="comment">// 获取当前输出流的格式标志</span></span><br><span class="line"></span><br><span class="line">    flags |= std::ios::hex; <span class="comment">// 设置输出流的进制为十六进制</span></span><br><span class="line">    flags &amp;= ~std::ios::dec; <span class="comment">// 取消输出流的十进制设置</span></span><br><span class="line"></span><br><span class="line">    std::cout.<span class="built_in">flags</span>(flags); <span class="comment">// 应用新的格式标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>std::ios::fmtflags</code> 用于存储输出流的格式标志，可以随后使用按位操作符进行修改，并通过 <code>std::cout.flags()</code> 和 <code>std::cout.flags(flags)</code> 方法来获取和设置流的格式标志。</p>
<h2 id="std-ios-flags"><a href="#std-ios-flags" class="headerlink" title="std::ios::flags"></a>std::ios::flags</h2><p><code>std::ios::flags</code> 是 C++ 中的一个成员函数，而非数据类型。这个函数用于设置流的格式标志（flags），它属于 <code>std::ios</code> 类的一部分，用于控制输入&#x2F;输出流的格式。</p>
<p>这个成员函数的作用是设置流的格式控制标志。它接受一个参数，该参数是一个 <code>std::ios::fmtflags</code> 类型的值，这个值包含了要设置的格式标志的组合。</p>
<p>例如，可以使用 <code>std::ios::hex</code> 标志将输出流的进制设置为十六进制。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout.<span class="built_in">setf</span>(std::ios::hex); <span class="comment">// 设置输出流的进制为十六进制</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的十六进制表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::cout.setf(std::ios::hex)</code> 用于设置输出流的格式标志为十六进制格式。接下来的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 将以十六进制形式输出整数 255。</p>
<p><code>std::ios::flags</code> 函数主要用于设置输出流的格式标志，以控制输出流的显示格式，比如控制进制、对齐方式、浮点数的显示方式等等。</p>
<h2 id="std-ios-setf"><a href="#std-ios-setf" class="headerlink" title="std::ios::setf()"></a>std::ios::setf()</h2><p><code>std::ios::setf()</code> 是 C++ 中用于设置流的格式标志的成员函数之一。它属于 <code>std::ios</code> 类的一部分，用于控制输入&#x2F;输出流的格式。</p>
<p>这个函数允许你设置指定的格式标志，接受一个参数，即格式标志的组合。你可以使用这个函数来设置需要的格式标志，例如设置浮点数的显示方式、数制、对齐方式等等。</p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout.<span class="built_in">setf</span>(std::ios::hex); <span class="comment">// 设置输出流的进制为十六进制</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的十六进制表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::cout.setf(std::ios::hex)</code> 被用来设置输出流的格式标志为十六进制格式。接下来的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 将以十六进制形式输出整数 255。</p>
<p><code>std::ios::setf()</code> 函数是 <code>std::ios</code> 类中用于设置格式标志的函数之一，用于控制输出流的显示格式。</p>
<h2 id="std-ios-unsetf"><a href="#std-ios-unsetf" class="headerlink" title="std::ios::unsetf()"></a>std::ios::unsetf()</h2><p><code>std::unsetf()</code> 是 C++ 中用于取消流的格式标志的成员函数之一，属于 <code>std::ios</code> 类的一部分。它允许你取消特定的格式标志，将其从流的当前格式状态中移除。</p>
<p>这个函数接受一个参数，即要取消的格式标志。它可以取消先前通过 <code>std::ios::setf()</code> 或其他设置格式标志的方式设置的标志。</p>
<p>示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout.<span class="built_in">setf</span>(std::ios::hex); <span class="comment">// 设置输出流的进制为十六进制</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的十六进制表示</span></span><br><span class="line"></span><br><span class="line">    std::cout.<span class="built_in">unsetf</span>(std::ios::hex); <span class="comment">// 取消输出流的十六进制格式标志</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的默认十进制表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，首先使用 <code>std::cout.setf(std::ios::hex)</code> 设置了输出流的格式标志为十六进制格式。接下来的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 输出了整数 255 的十六进制表示。</p>
<p>然后使用 <code>std::cout.unsetf(std::ios::hex)</code> 取消了输出流的十六进制格式标志。最后的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 输出了整数 255 的默认十进制表示，因为已取消了十六进制格式标志。</p>
<p><code>std::ios::unsetf()</code> 函数用于取消先前设置的特定格式标志，以便在输出流的格式状态中移除该标志。</p>
<h2 id="std-setiosflags"><a href="#std-setiosflags" class="headerlink" title="std::setiosflags()"></a>std::setiosflags()</h2><p><code>std::setiosflags()</code> 是 C++ 中用于设置流格式标志的函数之一，用于控制输入&#x2F;输出流的格式。这个函数可以设置指定的格式标志，其效果类似于 <code>std::ios::setf()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setiosflags</span>(std::ios::hex); <span class="comment">// 设置输出流的进制为十六进制</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的十六进制表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::setiosflags(std::ios::hex)</code> 被用来设置输出流的格式标志为十六进制格式。接下来的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 将以十六进制形式输出整数 255。</p>
<p><code>std::setiosflags()</code> 可以用于设置指定的格式标志，与 <code>std::ios::setf()</code> 类似，允许控制输出流的显示格式。</p>
<h2 id="std-resetiosflags"><a href="#std-resetiosflags" class="headerlink" title="std::resetiosflags()"></a>std::resetiosflags()</h2><p><code>std::resetiosflags()</code> 是 C++ 中用于重置流的格式标志的函数之一，用于控制输入&#x2F;输出流的格式。它的作用是取消指定的格式标志，将其从流的当前格式状态中移除。</p>
<p>这个函数接受一个参数，即要重置的格式标志。它可以用来取消先前通过 <code>std::ios::setf()</code>、<code>std::setiosflags()</code> 或其他设置格式标志的方式设置的标志。</p>
<p>示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout.<span class="built_in">setf</span>(std::ios::hex); <span class="comment">// 设置输出流的进制为十六进制</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的十六进制表示</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">resetiosflags</span>(std::ios::hex); <span class="comment">// 重置输出流的十六进制格式标志</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的默认十进制表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，首先使用 <code>std::cout.setf(std::ios::hex)</code> 设置了输出流的格式标志为十六进制格式。接下来的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 输出了整数 255 的十六进制表示。</p>
<p>然后使用 <code>std::cout &lt;&lt; std::resetiosflags(std::ios::hex)</code> 重置了输出流的十六进制格式标志。最后的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 输出了整数 255 的默认十进制表示，因为已经重置了十六进制格式标志。</p>
<p><code>std::resetiosflags()</code> 函数用于取消先前设置的特定格式标志，以便从输出流的格式状态中移除该标志。</p>
<h2 id="std-get-money"><a href="#std-get-money" class="headerlink" title="std::get_money()"></a>std::get_money()</h2><p><code>std::get_money()</code> 是 C++ 标准库 <code>&lt;iomanip&gt;</code> 头文件中提供的一个函数，用于将字符串解析为货币值，并将其存储到 <code>std::money_get</code> 类型对象返回的结果中。它通常与 <code>std::put_money()</code> 一起使用，后者用于将货币值以指定的格式输出到输出流中。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::money_get&lt;charT, InputIterator&gt; <span class="title">get_money</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    T &amp;val, <span class="type">bool</span> intl = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>charT</code> 是字符类型。</li>
<li><code>InputIterator</code> 是输入迭代器类型。</li>
<li><code>val</code> 是要存储货币值的对象。</li>
<li><code>intl</code> 是一个布尔值，指示货币值是否采用国际化格式（如果为 <code>true</code>，则表示使用国际化货币格式）。</li>
</ul>
<p>例如，可以使用 <code>std::get_money()</code> 将字符串解析为货币值，然后将其输出到输出流中。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string input = <span class="string">&quot;123.45&quot;</span>; <span class="comment">// 要解析的字符串</span></span><br><span class="line">    <span class="function">std::stringstream <span class="title">ss</span><span class="params">(input)</span></span>; <span class="comment">// 创建字符串流</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line">    <span class="function">std::locale <span class="title">loc</span><span class="params">(std::locale(), <span class="keyword">new</span> std::moneypunct&lt;<span class="type">char</span>, <span class="literal">false</span>&gt;)</span></span>;</span><br><span class="line">    std::moneypunct_byname&lt;<span class="type">char</span>, <span class="literal">false</span>&gt; <span class="type">const</span>&amp; mpunct = std::use_facet&lt;std::moneypunct_byname&lt;<span class="type">char</span>, <span class="literal">false</span>&gt;&gt;(loc);</span><br><span class="line"></span><br><span class="line">    std::ios_base::iostate err;</span><br><span class="line">    ss.<span class="built_in">imbue</span>(loc);</span><br><span class="line">    ss &gt;&gt; std::<span class="built_in">get_money</span>(value, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ss.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parsing failed\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parsed value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，字符串 “123.45” 被解析为货币值，存储在 <code>value</code> 中，并输出到标准输出流中。需要注意的是，这是一个简化的示例，实际的用法可能涉及更多的设置和错误处理。</p>
<h2 id="std-put-money"><a href="#std-put-money" class="headerlink" title="std::put_money()"></a>std::put_money()</h2><p><code>std::put_money()</code> 是 C++ 标准库 <code>&lt;iomanip&gt;</code> 头文件中提供的一个函数，用于将货币值以指定的格式输出到输出流中。通常与 <code>std::get_money()</code> 一起使用，后者用于将字符串解析为货币值。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::money_put&lt;charT, OutputIterator&gt; <span class="title">put_money</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::basic_ostream&lt;charT&gt;&amp; os, <span class="type">bool</span> intl, T val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>charT</code> 是字符类型。</li>
<li><code>OutputIterator</code> 是输出迭代器类型。</li>
<li><code>os</code> 是要写入的输出流。</li>
<li><code>intl</code> 是一个布尔值，指示货币值是否采用国际化格式（如果为 <code>true</code>，则表示使用国际化货币格式）。</li>
<li><code>val</code> 是要输出的货币值。</li>
</ul>
<p>例如，可以使用 <code>std::put_money()</code> 将货币值以指定的格式输出到输出流中。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">123.45</span>; <span class="comment">// 要输出的货币值</span></span><br><span class="line"></span><br><span class="line">    std::cout.<span class="built_in">imbue</span>(std::<span class="built_in">locale</span>(<span class="string">&quot;en_US.UTF-8&quot;</span>)); <span class="comment">// 设置本地化信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Formatted output: &quot;</span> &lt;&lt; std::<span class="built_in">put_money</span>(value, <span class="literal">true</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，货币值 123.45 被以国际化的货币格式输出到标准输出流中。这是一个简化的示例，实际的用法可能涉及更多的设置和本地化信息的处理。</p>
<h2 id="std-get-time"><a href="#std-get-time" class="headerlink" title="std::get_time()"></a>std::get_time()</h2><p><code>std::get_time()</code> 是 C++ 中 <code>&lt;iomanip&gt;</code> 头文件中提供的函数，用于将字符串解析为时间对象 <code>std::tm</code>。这个函数允许你从字符串中提取日期和时间信息，并将其存储在 <code>std::tm</code> 结构中。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::istreambuf_iterator&lt;charT&gt; <span class="title">get_time</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::istreambuf_iterator&lt;charT&gt;&amp; s,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> charT* fmt,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::tm* tmb)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>charT</code> 是字符类型。</li>
<li><code>s</code> 是指向输入流的迭代器。</li>
<li><code>fmt</code> 是描述日期和时间格式的 C 字符串。</li>
<li><code>tmb</code> 是指向 <code>std::tm</code> 结构的指针，用于存储解析后的日期和时间信息。</li>
</ul>
<p>示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::tm tmb;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">ss</span><span class="params">(<span class="string">&quot;2023-12-09 15:30:00&quot;</span>)</span></span>; <span class="comment">// 要解析的时间字符串</span></span><br><span class="line">    ss &gt;&gt; std::<span class="built_in">get_time</span>(&amp;tmb, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>); <span class="comment">// 解析时间字符串并存储到 std::tm 结构中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ss.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parsing failed\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parsed date and time: &quot;</span></span><br><span class="line">                  &lt;&lt; std::<span class="built_in">put_time</span>(&amp;tmb, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，字符串 “2023-12-09 15:30:00” 被解析为时间对象 <code>std::tm</code>，并存储在 <code>tmb</code> 中。然后，<code>std::put_time()</code> 被用于格式化输出解析后的日期和时间信息。如果解析失败，将输出 “Parsing failed”。这是一个简化的示例，实际的用法可能涉及更多的错误处理和格式化字符串。</p>
<h2 id="std-put-time"><a href="#std-put-time" class="headerlink" title="std::put_time()"></a>std::put_time()</h2><p><code>std::put_time()</code> 是 C++ 中 <code>&lt;iomanip&gt;</code> 头文件中提供的一个函数，用于将时间对象 <code>std::tm</code> 按照指定的格式输出为字符串。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ostreambuf_iterator&lt;charT&gt; <span class="title">put_time</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::tm* tmb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> charT* fmt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>tmb</code> 是指向 <code>std::tm</code> 结构的指针，包含要格式化的时间信息。</li>
<li><code>fmt</code> 是描述日期和时间格式的 C 字符串。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::tm timeinfo = &#123;&#125;; <span class="comment">// 初始化时间结构</span></span><br><span class="line">    timeinfo.tm_year = <span class="number">2023</span> - <span class="number">1900</span>; <span class="comment">// 年份减去1900</span></span><br><span class="line">    timeinfo.tm_mon = <span class="number">11</span>; <span class="comment">// 月份，0-11 表示一月到十二月</span></span><br><span class="line">    timeinfo.tm_mday = <span class="number">9</span>; <span class="comment">// 日</span></span><br><span class="line">    timeinfo.tm_hour = <span class="number">15</span>; <span class="comment">// 时</span></span><br><span class="line">    timeinfo.tm_min = <span class="number">30</span>; <span class="comment">// 分</span></span><br><span class="line">    timeinfo.tm_sec = <span class="number">0</span>; <span class="comment">// 秒</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Formatted time: &quot;</span> &lt;&lt; std::<span class="built_in">put_time</span>(&amp;timeinfo, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::put_time()</code> 被用于格式化输出 <code>std::tm</code> 结构中的时间信息。指定的格式字符串 <code>&quot;%Y-%m-%d %H:%M:%S&quot;</code> 代表了年月日时分秒的格式。这样的调用将会把时间信息格式化为字符串，并输出到标准输出流中。</p>
<p>需要注意的是，<code>std::put_time()</code> 在 C++11 中引入，用于便捷地格式化时间信息并输出为字符串。</p>
<h2 id="C-std-put-time-函数返回值存储到字符串"><a href="#C-std-put-time-函数返回值存储到字符串" class="headerlink" title="C++  std::put_time() 函数返回值存储到字符串"></a>C++ <chrono> std::put_time() 函数返回值存储到字符串</h2><p>你可以使用<code>std::put_time()</code>函数结合<code>std::stringstream</code>将格式化后的时间存储到字符串中。下面是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间点</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将时间点转换为时间结构体</span></span><br><span class="line">    std::<span class="type">time_t</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::tm* now_tm = std::<span class="built_in">localtime</span>(&amp;now_c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::put_time 格式化时间</span></span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(now_tm, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将格式化后的时间存储到字符串中</span></span><br><span class="line">    std::string formatted_time = ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出格式化后的时间字符串</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Formatted Time: &quot;</span> &lt;&lt; formatted_time &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，<code>std::put_time()</code>函数用于将时间结构体格式化为指定格式的字符串。然后，使用<code>std::stringstream</code>来存储这个格式化后的字符串，最后将其转换为<code>std::string</code>类型。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_33_sstream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_33_sstream/" class="post-title-link" itemprop="url">C++_10_33_sstream</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <sstream>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <sstream>标准库</h2><p><code>&lt;sstream&gt;</code> 是 C++ 标准库中的头文件，它提供了对内存中字符串流的支持。它包含了用于操作内存中字符串流的类，如 <code>std::stringstream</code>、<code>std::ostringstream</code> 和 <code>std::istringstream</code>。</p>
<p>以下是这些类的简要介绍：</p>
<ul>
<li><p><strong>std::stringstream</strong>：这个类提供了一个用于读写内存中字符串的流。可以像使用输入输出流一样使用它，从中读取数据或将数据写入到内存中的字符串。它可以实现将字符串和其他数据类型（如整数、浮点数等）之间的转换。</p>
</li>
<li><p><strong>std::ostringstream</strong>：这个类是 <code>std::stringstream</code> 的派生类，用于输出数据到字符串。它专注于输出，不支持从字符串中读取数据。通常用于构建字符串，将各种数据类型转换为字符串形式。</p>
</li>
<li><p><strong>std::istringstream</strong>：这个类也是 <code>std::stringstream</code> 的派生类，用于从字符串中读取数据。它专注于输入，允许从已有的字符串中读取数据，并按照需要进行解析和处理。</p>
</li>
</ul>
<p>这些类都提供了与输入输出流类似的接口，包括 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符，用于将数据插入或提取到流中，以及各种成员函数用于流操作，例如 <code>str()</code>、<code>clear()</code>、<code>tellg()</code>、<code>tellp()</code> 等等。</p>
<p>这些字符串流类在实际编程中很有用，可以方便地进行字符串的读写和转换操作，尤其是在需要从字符串中提取数据或将数据转换为字符串形式时。例如，将数字转换为字符串、将多个字符串拼接成一个字符串、或者从一个字符串中提取特定的数据等。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <sstream>标准库 详解</h2><p><code>&lt;sstream&gt;</code> 标准库提供了对字符串流的支持，使得可以在内存中对字符串进行输入和输出操作。这个标准库包含了以下三个主要的类：</p>
<ol>
<li><p><strong>std::stringstream</strong>：这个类提供了一个用于读写内存中字符串的流。它可以将数据转换为字符串或从字符串提取数据。主要用途包括将不同类型的数据转换为字符串或从字符串中提取特定类型的数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">std::stringstream ss;</span><br><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;The answer is: &quot;</span> &lt;&lt; num;</span><br><span class="line">std::string result = ss.<span class="built_in">str</span>(); <span class="comment">// 获取 stringstream 中的字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::ostringstream</strong>：这个类是 <code>std::stringstream</code> 的派生类，专门用于字符串输出。它允许将各种数据类型转换为字符串并存储在内存中的字符串中。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">std::ostringstream oss;</span><br><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;The answer is: &quot;</span> &lt;&lt; num;</span><br><span class="line">std::string result = oss.<span class="built_in">str</span>(); <span class="comment">// 获取 ostringstream 中的字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::istringstream</strong>：这个类也是 <code>std::stringstream</code> 的派生类，专门用于从字符串中读取数据。它允许从内存中的字符串中提取数据并进行解析。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">std::string data = <span class="string">&quot;123 456&quot;</span>;</span><br><span class="line"><span class="function">std::istringstream <span class="title">iss</span><span class="params">(data)</span></span>;</span><br><span class="line"><span class="type">int</span> num1, num2;</span><br><span class="line">iss &gt;&gt; num1 &gt;&gt; num2; <span class="comment">// 从字符串中提取两个整数</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些类都具有类似于输入输出流的接口，例如 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符，用于向流中插入或提取数据。此外，它们还提供了一些成员函数，例如 <code>str()</code> 用于获取字符串流的内容，<code>clear()</code> 用于清除流的状态，<code>tellg()</code> 和 <code>tellp()</code> 用于获取流指针的位置等。</p>
<p>字符串流可以在很多场景下非常有用，例如将数字转换为字符串、将多个字符串合并成一个字符串、从字符串中提取特定类型的数据等。它们在处理字符串数据时提供了灵活且方便的方式，尤其在需要对字符串中的数据进行处理、转换或解析时。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <sstream>标准库 常用的类和函数</h2><p><code>&lt;sstream&gt;</code> 标准库提供了对字符串流的支持，其中包含一些常用的类和函数，主要有三个核心类：<code>std::stringstream</code>、<code>std::ostringstream</code> 和 <code>std::istringstream</code>。以下是一些常用的类和函数：</p>
<ol>
<li><p><strong>std::stringstream</strong>：用于读写内存中的字符串流。它可以将数据转换为字符串或从字符串中提取数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::stringstream ss; <span class="comment">// 创建字符串流对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向字符串流中插入数据</span></span><br><span class="line">ss &lt;&lt; <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">ss &lt;&lt; <span class="number">42</span>;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot; World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串流中获取字符串</span></span><br><span class="line">std::string result = ss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::ostringstream</strong>：用于将数据输出到字符串流中。主要用于将不同类型的数据转换为字符串并存储在内存中的字符串中。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::ostringstream oss; <span class="comment">// 创建输出字符串流对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向输出字符串流中插入数据</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;The answer is: &quot;</span>;</span><br><span class="line">oss &lt;&lt; <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从输出字符串流中获取字符串</span></span><br><span class="line">std::string result = oss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::istringstream</strong>：用于从字符串中读取数据。它允许从内存中的字符串中提取数据并进行解析。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string data = <span class="string">&quot;123 456&quot;</span>;</span><br><span class="line"><span class="function">std::istringstream <span class="title">iss</span><span class="params">(data)</span></span>; <span class="comment">// 创建输入字符串流对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num1, num2;</span><br><span class="line">iss &gt;&gt; num1 &gt;&gt; num2; <span class="comment">// 从字符串流中提取两个整数</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>常用的成员函数：</p>
<ul>
<li>**<code>str()</code>**：用于获取字符串流中的字符串内容。</li>
<li>**<code>clear()</code>**：用于清除流的状态。</li>
<li><strong><code>tellg()</code></strong> 和 **<code>tellp()</code>**：分别用于获取输入流和输出流的当前位置。</li>
<li><strong><code>seekg()</code></strong> 和 **<code>seekp()</code>**：分别用于设置输入流和输出流的读写位置。</li>
</ul>
<p>这些类和函数可以用于将不同类型的数据转换为字符串、将多个字符串拼接为一个字符串、从字符串中提取特定类型的数据等操作。在处理字符串时，字符串流提供了灵活和便捷的方式，特别是在需要对字符串中的数据进行处理、转换或解析时非常有用。</p>
<h2 id="C-std-stringbuf-详解-中文"><a href="#C-std-stringbuf-详解-中文" class="headerlink" title="C++ std::stringbuf 详解 中文"></a>C++ std::stringbuf 详解 中文</h2><p><code>std::stringbuf</code> 是 C++ 标准库提供的一个类，允许在基于字符串的缓冲区上进行输入和输出操作。它是 <code>&lt;sstream&gt;</code> 头文件的一部分。这个类通常与其他 I&#x2F;O 类（如 <code>std::stringstream</code>）一起使用。</p>
<p>以下是 <code>std::stringbuf</code> 的详细解释：</p>
<ol>
<li><p><strong>构造和析构</strong>：</p>
<ul>
<li><code>explicit basic_stringbuf( std::ios_base::openmode which = std::ios_base::in | std::ios_base::out )</code>：使用指定的模式构造一个 <code>std::stringbuf</code> 对象。默认模式是 <code>in|out</code>。</li>
<li><code>virtual ~basic_stringbuf()</code>：析构函数。</li>
</ul>
</li>
<li><p><strong>成员函数</strong>：</p>
<ul>
<li><code>str()</code>：返回底层字符串的副本。</li>
<li><code>str(const std::basic_string&lt;charT,traits,Allocator&gt;&amp; str)</code>：将底层字符串设置为指定字符串的副本。</li>
<li><code>protected</code>：通常，像 <code>underflow()</code>、<code>overflow()</code>、<code>sync()</code> 等函数是受保护的，并由派生类重写。</li>
</ul>
</li>
<li><p><strong>类型定义</strong>：</p>
<ul>
<li><code>char_type</code>：字符的类型（默认为 <code>char</code>）。</li>
<li><code>int_type</code>：表示每个字符的整数类型（通常为 <code>int</code>）。</li>
<li><code>pos_type</code>：表示缓冲区中位置的类型。</li>
<li><code>off_type</code>：表示缓冲区中偏移量的类型。</li>
</ul>
</li>
<li><p><strong>继承</strong>：</p>
<ul>
<li><code>std::basic_streambuf</code>：<code>std::stringbuf</code> 继承自 <code>std::basic_streambuf</code>，使其与流 I&#x2F;O 操作兼容。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>sputc</code>：将字符放入流中。</li>
<li><code>sputn</code>：将一系列字符放入流中。</li>
<li><code>sbumpc</code>、<code>sgetc</code>、<code>sgetn</code>：从流中读取字符。</li>
<li><code>seekoff</code>、<code>seekpos</code>：将获取和&#x2F;或放置指针移动到指定位置。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<ul>
<li><code>std::stringbuf</code> 经常被用作从字符串读取或写入的缓冲区。</li>
<li>它通常与 <code>std::stringstream</code> 结合使用，以对字符串执行格式化的输入&#x2F;输出操作。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stringbuf buf;</span><br><span class="line">    <span class="function">std::ostream <span class="title">os</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line"></span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; buf.<span class="built_in">str</span>() &lt;&lt; std::endl; <span class="comment">// 输出：Hello, world!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>std::stringbuf</code> 对象，将它用作输出的缓冲区，然后使用 <code>str()</code> 方法检索缓冲区的内容。</p>
<h2 id="std-stringstream"><a href="#std-stringstream" class="headerlink" title="std::stringstream"></a>std::stringstream</h2><p><code>std::stringstream</code> 是 C++ 标准库中的一个类，位于 <code>&lt;sstream&gt;</code> 头文件中，提供了对字符串进行输入输出操作的功能。它是基于内存缓冲区的流类，允许像操作标准输入输出流（<code>std::cin</code> 和 <code>std::cout</code>）一样操作字符串数据。</p>
<h3 id="主要功能和用途："><a href="#主要功能和用途：" class="headerlink" title="主要功能和用途："></a>主要功能和用途：</h3><ol>
<li><strong>输入输出操作</strong>：允许像标准输入输出流一样对字符串进行输入输出操作。</li>
<li><strong>数据类型转换</strong>：可以方便地将不同类型的数据转换为字符串或从字符串中提取出不同类型的数据。</li>
<li><strong>格式化</strong>：支持格式化输出和输入，可以使用流操作符和 manipulators（例如 <code>std::setw</code>、<code>std::setprecision</code>）对数据进行格式化操作。</li>
</ol>
<h3 id="主要成员函数和用法："><a href="#主要成员函数和用法：" class="headerlink" title="主要成员函数和用法："></a>主要成员函数和用法：</h3><h4 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h4><ul>
<li><strong>默认构造函数</strong>：<code>std::stringstream ss;</code> 创建一个空的 <code>std::stringstream</code> 对象。</li>
</ul>
<h4 id="输入输出操作："><a href="#输入输出操作：" class="headerlink" title="输入输出操作："></a>输入输出操作：</h4><ul>
<li><strong><code>&lt;&lt;</code> 运算符</strong>：用于将数据写入到 <code>std::stringstream</code> 对象中，例如 <code>ss &lt;&lt; &quot;Hello&quot; &lt;&lt; 42;</code> 将字符串 “Hello” 和整数 42 写入流中。</li>
<li><strong><code>&gt;&gt;</code> 运算符</strong>：用于从 <code>std::stringstream</code> 对象中读取数据，例如 <code>ss &gt;&gt; str &gt;&gt; num;</code> 从流中提取字符串和数字。</li>
</ul>
<h4 id="其他操作："><a href="#其他操作：" class="headerlink" title="其他操作："></a>其他操作：</h4><ul>
<li><strong><code>str()</code> 方法</strong>：返回当前流中的字符串副本，例如 <code>std::string content = ss.str();</code>。</li>
<li><strong><code>clear()</code> 方法</strong>：用于清除流的状态。</li>
<li><strong><code>str(const std::string&amp;)</code> 方法</strong>：用于设置流中的字符串。</li>
</ul>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据到流中</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    std::string str;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从流中读取数据</span></span><br><span class="line">    ss &gt;&gt; str &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取流中的字符串</span></span><br><span class="line">    std::string content = ss.<span class="built_in">str</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stream content: &quot;</span> &lt;&lt; content &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>在使用 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符时，流中的数据会按照空格（空格、制表符、换行符等）分隔。</li>
<li>使用流之前，请确保清除流状态（<code>ss.clear()</code>）以及设置&#x2F;重置需要操作的字符串内容（<code>ss.str(&quot;&quot;)</code>）。</li>
</ul>
<p><code>std::stringstream</code> 提供了方便的方法来处理字符串数据，使得将数据从字符串中读取和写入变得更加简单和灵活。</p>
<h2 id="std-ostringstream"><a href="#std-ostringstream" class="headerlink" title="std::ostringstream"></a>std::ostringstream</h2><p><code>std::ostringstream</code> 是 C++ 标准库中 <code>&lt;sstream&gt;</code> 头文件中提供的一个类，它是 <code>std::stringstream</code> 的派生类之一，专门用于输出数据到字符串流中。<code>std::ostringstream</code> 主要用于将各种数据类型转换为字符串并存储在内存中的字符串中。</p>
<p>它与 <code>std::stringstream</code> 类似，但专注于输出，不支持从字符串中读取数据。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ostringstream oss; <span class="comment">// 创建输出字符串流对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向输出字符串流中插入数据</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;The answer is: &quot;</span>;</span><br><span class="line">    oss &lt;&lt; <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从输出字符串流中获取字符串</span></span><br><span class="line">    std::string result = oss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出结果字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>std::ostringstream</code> 对象 <code>oss</code>，然后使用 <code>&lt;&lt;</code> 操作符将字符串和整数插入到输出字符串流中。最后使用 <code>oss.str()</code> 获取整个输出字符串流的内容，并将其赋值给 <code>result</code>，最终输出结果字符串。</p>
<p><code>std::ostringstream</code> 在需要将数据转换为字符串并存储在内存中的场景中非常有用，例如将日志信息组合成一条字符串、将数据转换为特定格式的字符串等。</p>
<h2 id="std-istringstream"><a href="#std-istringstream" class="headerlink" title="std::istringstream"></a>std::istringstream</h2><p><code>std::istringstream</code> 是 C++ 标准库中 <code>&lt;sstream&gt;</code> 头文件中提供的一个类，它是 <code>std::stringstream</code> 的派生类之一，专门用于从字符串中读取数据。<code>std::istringstream</code> 主要用于从内存中的字符串中提取数据并进行解析。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string data = <span class="string">&quot;123 456&quot;</span>;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(data)</span></span>; <span class="comment">// 创建输入字符串流对象</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    iss &gt;&gt; num1 &gt;&gt; num2; <span class="comment">// 从字符串流中提取两个整数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Numbers extracted: &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>std::istringstream</code> 对象 <code>iss</code>，并将字符串 “123 456” 作为输入传递给它。然后使用 <code>&gt;&gt;</code> 操作符从输入字符串流中提取两个整数，并将其分别存储在 <code>num1</code> 和 <code>num2</code> 中。最后将这两个整数输出到控制台。</p>
<p><code>std::istringstream</code> 对于需要从字符串中提取特定类型的数据并进行解析的情况非常有用，例如从文件读取数据并解析、处理用户输入的字符串等场景。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_34_future/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_34_future/" class="post-title-link" itemprop="url">C++_10_34_future</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <future>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <future>标准库</h2><p><code>&lt;future&gt;</code> 标准库是 C++ 中用于支持异步编程的头文件。它提供了 <code>std::future</code>、<code>std::promise</code>、<code>std::packaged_task</code> 等类，以及一些与异步任务相关的函数，如 <code>std::async</code>、<code>std::async</code>、<code>std::packaged_task</code> 等。</p>
<p>以下是 <code>&lt;future&gt;</code> 标准库中常用的类和函数：</p>
<h3 id="1-std-future"><a href="#1-std-future" class="headerlink" title="1. std::future"></a>1. <code>std::future</code></h3><p><code>std::future</code> 是一个模板类，用于存储异步任务的结果。它提供了 <code>.get()</code> 方法来获取异步任务的结果，并且可以检查任务是否已完成。</p>
<h3 id="2-std-promise"><a href="#2-std-promise" class="headerlink" title="2. std::promise"></a>2. <code>std::promise</code></h3><p><code>std::promise</code> 允许在一个线程中设置一个值或异常，并在另一个线程中通过 <code>std::future</code> 获取该值或异常。它通常用于异步任务间的通信。</p>
<h3 id="3-std-packaged-task"><a href="#3-std-packaged-task" class="headerlink" title="3. std::packaged_task"></a>3. <code>std::packaged_task</code></h3><p><code>std::packaged_task</code> 将可调用对象和 <code>std::future</code> 结合在一起，允许你在一个线程中异步执行可调用对象，并在其他线程中通过 <code>std::future</code> 获取结果。</p>
<h3 id="4-std-async"><a href="#4-std-async" class="headerlink" title="4. std::async"></a>4. <code>std::async</code></h3><p><code>std::async</code> 是一个函数，用于异步执行一个函数或可调用对象，并返回一个 <code>std::future</code> 对象，以便获取异步任务的结果。</p>
<h3 id="5-then-方法"><a href="#5-then-方法" class="headerlink" title="5. .then() 方法"></a>5. <code>.then()</code> 方法</h3><p>C++23 标准中引入的 <code>.then()</code> 方法允许将多个异步操作连接起来，以便在前一个操作完成后执行另一个操作。</p>
<p>这些类和函数提供了一种方便的方法来处理异步编程，允许程序在执行耗时的操作时不被阻塞，并在操作完成后获取结果或执行进一步的处理。</p>
<p>下面是一个简单示例，演示了如何使用 <code>std::future</code> 和 <code>std::promise</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_value</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; fut)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = fut.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">print_thread</span><span class="params">(print_value, std::ref(fut))</span></span>;</span><br><span class="line"></span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    print_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::promise</code> 用于设置一个值，并通过 <code>std::future</code> 获取该值。<code>print_value</code> 函数在另一个线程中通过 <code>fut.get()</code> 获取值，并在主线程中调用 <code>prom.set_value()</code> 来设置这个值。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <future>标准库 详解</h2><p><code>&lt;future&gt;</code> 标准库提供了一系列用于异步编程的工具和类，包括 <code>std::future</code>、<code>std::promise</code>、<code>std::packaged_task</code> 等，以及一些与异步任务相关的函数，例如 <code>std::async</code>、<code>std::launch</code> 等。</p>
<h3 id="1-std-future-1"><a href="#1-std-future-1" class="headerlink" title="1. std::future"></a>1. <code>std::future</code></h3><p><code>std::future</code> 是一个模板类，表示异步操作的结果。它允许在一个线程中计算结果，并在另一个线程中等待获取这个结果。可以通过 <code>.get()</code> 方法获取结果值，或者通过 <code>.wait_for()</code> 和 <code>.wait_until()</code> 方法等待结果的完成。</p>
<h3 id="2-std-promise-1"><a href="#2-std-promise-1" class="headerlink" title="2. std::promise"></a>2. <code>std::promise</code></h3><p><code>std::promise</code> 允许在一个线程中设置一个值或异常，并在另一个线程中通过相关联的 <code>std::future</code> 获取该值或异常。通常用于线程间通信，其中一个线程设置结果，另一个线程等待获取结果。</p>
<h3 id="3-std-packaged-task-1"><a href="#3-std-packaged-task-1" class="headerlink" title="3. std::packaged_task"></a>3. <code>std::packaged_task</code></h3><p><code>std::packaged_task</code> 将可调用对象（函数、函数指针、仿函数等）与 <code>std::future</code> 结合起来，允许你在一个线程中异步执行可调用对象，并在其他线程中获取结果。</p>
<h3 id="4-std-async-1"><a href="#4-std-async-1" class="headerlink" title="4. std::async"></a>4. <code>std::async</code></h3><p><code>std::async</code> 是一个函数模板，用于在异步执行一个函数或可调用对象，并返回一个 <code>std::future</code> 对象以便获取异步任务的结果。它可以使用不同的策略来指定任务的执行方式。</p>
<h3 id="5-std-launch"><a href="#5-std-launch" class="headerlink" title="5. std::launch"></a>5. <code>std::launch</code></h3><p><code>std::launch</code> 枚举类型定义了在 <code>std::async</code> 中启动异步任务的不同策略，如 <code>std::launch::async</code> 表示立即启动一个新线程执行任务，而 <code>std::launch::deferred</code> 则推迟任务的执行，直到调用 <code>std::future</code> 对象的 <code>.get()</code> 方法时才执行。</p>
<p>这些类和函数提供了一种方便的方式来处理异步编程，允许程序在执行耗时的操作时不被阻塞，并在操作完成后获取结果或执行进一步的处理。异步编程使得在多线程和并发环境中更容易进行任务处理和线程间通信。</p>
<p>需要注意的是，异步编程需要谨慎处理，正确地管理资源和线程间通信，以避免出现竞态条件或死锁等问题。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <future>标准库 常用的类和函数</h2><p>C++ <code>&lt;future&gt;</code> 标准库提供了一些常用的类和函数，用于支持异步编程。以下是一些常用的类和函数：</p>
<h3 id="1-类："><a href="#1-类：" class="headerlink" title="1. 类："></a>1. 类：</h3><h4 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a><code>std::future</code></h4><ul>
<li>表示异步操作的结果。</li>
<li>方法：<code>.get()</code> 用于获取结果，<code>.wait_for()</code> 和 <code>.wait_until()</code> 用于等待结果完成，<code>.valid()</code> 用于检查 <code>future</code> 对象是否有效。</li>
</ul>
<h4 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a><code>std::promise</code></h4><ul>
<li>允许在一个线程中设置一个值或异常，并在另一个线程中通过 <code>std::future</code> 获取该值或异常。</li>
</ul>
<h4 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a><code>std::packaged_task</code></h4><ul>
<li>将可调用对象与 <code>std::future</code> 结合在一起，允许在一个线程中异步执行可调用对象，并在其他线程中获取结果。</li>
</ul>
<h3 id="2-函数："><a href="#2-函数：" class="headerlink" title="2. 函数："></a>2. 函数：</h3><h4 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a><code>std::async</code></h4><ul>
<li>用于异步执行函数或可调用对象，并返回一个 <code>std::future</code> 对象，以便获取异步任务的结果。</li>
<li>可以指定不同的启动策略 (<code>std::launch::async</code> 或 <code>std::launch::deferred</code>)。</li>
</ul>
<h4 id="then-方法（C-23-引入）"><a href="#then-方法（C-23-引入）" class="headerlink" title=".then() 方法（C++23 引入）"></a><code>.then()</code> 方法（C++23 引入）</h4><ul>
<li>允许将多个异步操作连接起来，在一个操作完成后执行另一个操作。</li>
</ul>
<p>这些类和函数提供了一种便捷的方式来处理异步编程，允许程序在执行耗时操作时不被阻塞，并在操作完成后获取结果或执行进一步的处理。异步编程是多线程和并发编程的重要组成部分，能够提高程序的性能和响应性。</p>
<h2 id="std-future-1"><a href="#std-future-1" class="headerlink" title="std::future"></a>std::future</h2><p><code>std::future</code> 是 C++ 标准库 <code>&lt;future&gt;</code> 中的一个模板类，用于表示异步操作的结果。它是一种通用的机制，允许你在一个线程中计算结果，并在另一个线程中等待获取这个结果。<code>std::future</code> 提供了一组方法来获取、等待、检查和处理异步操作的结果。</p>
<p>以下是 <code>std::future</code> 的一些主要特点和常用方法：</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><strong>表示异步操作的结果：</strong> <code>std::future</code> 允许在一个线程中计算某个结果，并在另一个线程中等待获取这个结果。</li>
<li><strong>延迟获取结果：</strong> 当你创建一个异步任务时，可以在未来的某个时间点获取其结果。</li>
<li><strong>线程间通信：</strong> 允许线程之间共享结果，一个线程可以计算结果，另一个线程可以等待并获取结果。</li>
</ul>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li><strong><code>.get()</code>:</strong> 获取异步操作的结果。它是一个阻塞方法，会阻塞当前线程直到结果准备就绪并返回结果值。</li>
<li><strong><code>.wait_for()</code>:</strong> 等待异步操作完成一段指定时间，如果在指定时间内操作完成则返回 <code>std::future_status::ready</code>。</li>
<li><strong><code>.wait_until()</code>:</strong> 等待异步操作完成直到指定的时间点，如果在指定时间点前操作完成则返回 <code>std::future_status::ready</code>。</li>
<li><strong><code>.valid()</code>:</strong> 检查 <code>std::future</code> 对象是否与异步操作相关联，如果 <code>std::future</code> 对象有效则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>以下是一个简单示例，展示了如何使用 <code>std::future</code> 获取异步操作的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">performAsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动异步任务</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, performAsyncTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中进行其他操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在执行其他任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> asyncResult = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;异步任务的结果是: &quot;</span> &lt;&lt; asyncResult &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::future&lt;int&gt;</code> 对象 <code>result</code> 表示异步任务的结果，通过 <code>.get()</code> 方法获取结果。<code>performAsyncTask()</code> 函数是一个简单的模拟耗时操作的函数。在主线程中，执行其他任务后，通过 <code>result.get()</code> 等待异步任务完成并获取其结果。</p>
<h2 id="std-promise-1"><a href="#std-promise-1" class="headerlink" title="std::promise"></a>std::promise</h2><p><code>std::promise</code> 是 C++ 标准库 <code>&lt;future&gt;</code> 中的一个类模板，用于在一个线程中设置某个值或异常，并在另一个线程中通过相关联的 <code>std::future</code> 获取该值或异常。它允许一个线程设定某个值或异常，并且允许另一个线程在未来的某个时间点获取这个值或异常。</p>
<h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>线程间通信：</strong> <code>std::promise</code> 提供了一种线程间通信的方式，一个线程设置值或异常，另一个线程等待获取它。</li>
<li><strong>延迟设置结果：</strong> 允许一个线程在未来某个时间点设置值，而另一个线程在需要时获取该值。</li>
<li><strong>异常传递：</strong> 可以设置异常，使得等待的线程能够获取异常而不是一个值。</li>
</ul>
<h3 id="常用方法：-1"><a href="#常用方法：-1" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li><strong><code>std::promise::get_future()</code>:</strong> 返回一个关联的 <code>std::future</code> 对象，允许其他线程获取该 <code>promise</code> 对象的值或异常。</li>
<li><strong><code>std::promise::set_value()</code>:</strong> 设置值，使得关联的 <code>std::future</code> 对象能够获取这个值。</li>
<li><strong><code>std::promise::set_exception()</code>:</strong> 设置异常，使得等待的 <code>std::future</code> 对象能够获取异常。</li>
</ul>
<p>以下是一个简单示例，演示了 <code>std::promise</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; prom)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟延迟设置值</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">setterThread</span><span class="params">(setValue, std::ref(prom))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中进行其他操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在执行其他任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待设置值并获取结果</span></span><br><span class="line">    <span class="type">int</span> value = fut.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;获取到的值为: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    setterThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::promise&lt;int&gt;</code> 对象 <code>prom</code> 允许一个线程通过 <code>prom.set_value()</code> 设置值，并通过 <code>prom.get_future()</code> 获取与 <code>prom</code> 相关联的 <code>std::future&lt;int&gt;</code> 对象 <code>fut</code>。在主线程中，通过 <code>fut.get()</code> 方法等待获取这个值。另一个线程通过 <code>setValue()</code> 函数设置值。</p>
<h2 id="std-packaged-task-1"><a href="#std-packaged-task-1" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h2><p><code>std::packaged_task</code> 是 C++ 标准库 <code>&lt;future&gt;</code> 中提供的一个类模板，它将可调用对象（函数、函数指针、仿函数等）与 <code>std::future</code> 结合在一起，允许你在一个线程中异步执行可调用对象，并在其他线程中获取结果。</p>
<h3 id="主要特点：-1"><a href="#主要特点：-1" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>任务封装：</strong> <code>std::packaged_task</code> 封装了一个可调用对象，可以是函数、函数指针或者仿函数。</li>
<li><strong>异步执行：</strong> 可以在一个线程中异步执行封装的任务。</li>
<li><strong>关联 <code>std::future</code>：</strong> 每个 <code>std::packaged_task</code> 对象都与一个 <code>std::future</code> 对象关联，允许获取任务的结果。</li>
</ul>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于执行一些操作，并返回结果</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">performTask</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 packaged_task 对象，并关联一个函数</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(performTask)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取与 packaged_task 关联的 future</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个新线程执行 packaged_task</span></span><br><span class="line">    <span class="function">std::thread <span class="title">taskThread</span><span class="params">(std::move(task), <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> result = fut.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;任务的结果是: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    taskThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::packaged_task&lt;int(int, int)&gt; task(performTask);</code> 创建了一个 <code>std::packaged_task</code> 对象，并与 <code>performTask</code> 函数关联起来。通过 <code>task.get_future()</code> 获取与 <code>std::packaged_task</code> 对象关联的 <code>std::future</code> 对象。然后，通过 <code>std::thread</code> 启动一个新线程执行 <code>std::packaged_task</code> 对象，传递参数 <code>10</code> 和 <code>20</code> 给 <code>performTask</code> 函数。最后，通过 <code>fut.get()</code> 获取异步任务的结果。</p>
<p><code>std::packaged_task</code> 可以用于将任务和 <code>std::future</code> 结合在一起，使得在一个线程中执行任务，并在其他线程中获取结果变得更加方便。</p>
<h2 id="std-async-1"><a href="#std-async-1" class="headerlink" title="std::async"></a>std::async</h2><p><code>std::async</code> 是 C++ 标准库 <code>&lt;future&gt;</code> 中提供的一个函数模板，用于创建异步任务并返回一个 <code>std::future</code> 对象，以便获取异步任务的结果。</p>
<h3 id="主要特点：-2"><a href="#主要特点：-2" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>异步执行：</strong> <code>std::async</code> 可以异步执行一个函数或可调用对象，并返回一个 <code>std::future</code> 对象，用于获取异步任务的结果。</li>
<li><strong>灵活性：</strong> 允许指定不同的启动策略，例如 <code>std::launch::async</code> 表示立即启动一个新线程执行任务，而 <code>std::launch::deferred</code> 则推迟任务的执行，直到调用 <code>std::future</code> 对象的 <code>.get()</code> 方法时才执行。</li>
<li><strong>返回结果：</strong> 返回一个 <code>std::future</code> 对象，允许在未来的某个时间点获取异步任务的结果。</li>
</ul>
<h3 id="使用方法：-1"><a href="#使用方法：-1" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">performAsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动异步任务</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, performAsyncTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中进行其他操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在执行其他任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> asyncResult = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;异步任务的结果是: &quot;</span> &lt;&lt; asyncResult &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::async</code> 函数启动一个异步任务来执行 <code>performAsyncTask()</code> 函数，使用 <code>std::launch::async</code> 策略，它表示立即在新线程中执行任务。在主线程中，执行其他操作后，通过 <code>result.get()</code> 方法等待异步任务完成并获取其结果。</p>
<p><code>std::async</code> 函数是一个非常方便的工具，可以用于创建异步任务，并且使得异步编程更加简单。通过指定不同的启动策略，可以灵活控制任务的执行方式。</p>
<h2 id="std-launch"><a href="#std-launch" class="headerlink" title="std::launch"></a>std::launch</h2><p><code>std::launch</code> 是一个枚举类型，用于指定 <code>std::async</code> 启动异步任务的策略。它允许你控制异步任务的执行方式。</p>
<p>主要的枚举值有两个：</p>
<h3 id="1-std-launch-async"><a href="#1-std-launch-async" class="headerlink" title="1. std::launch::async"></a>1. <code>std::launch::async</code></h3><ul>
<li>这个策略表示在调用 <code>std::async</code> 时立即启动一个新的线程来执行任务。</li>
<li>调用 <code>std::async</code> 时使用 <code>std::launch::async</code> 策略，会导致任务立即在一个新线程中执行，除非系统资源不足，否则不会推迟执行。</li>
</ul>
<h3 id="2-std-launch-deferred"><a href="#2-std-launch-deferred" class="headerlink" title="2. std::launch::deferred"></a>2. <code>std::launch::deferred</code></h3><ul>
<li>这个策略表示推迟任务的执行，直到调用 <code>std::future</code> 对象的 <code>.get()</code> 方法时才执行。</li>
<li>使用 <code>std::launch::deferred</code> 策略调用 <code>std::async</code> 时，不会立即执行任务，而是在调用返回的 <code>std::future</code> 对象的 <code>.get()</code> 方法时才执行任务，且在调用 <code>.get()</code> 之前不会创建新线程。</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">performTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;执行任务&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut_async = std::<span class="built_in">async</span>(std::launch::async, performTask);</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut_deferred = std::<span class="built_in">async</span>(std::launch::deferred, performTask);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;其他操作...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result_async = fut_async.<span class="built_in">get</span>();</span><br><span class="line">    <span class="type">int</span> result_deferred = fut_deferred.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::async(std::launch::async, performTask)</code> 使用 <code>std::launch::async</code> 策略启动了一个异步任务，而 <code>std::async(std::launch::deferred, performTask)</code> 使用 <code>std::launch::deferred</code> 策略推迟了任务的执行。在主线程中执行其他操作后，通过 <code>fut_async.get()</code> 和 <code>fut_deferred.get()</code> 获取了异步任务的结果。请注意，对于 <code>std::launch::deferred</code> 策略，任务会在调用 <code>.get()</code> 时执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_35_bitset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_35_bitset/" class="post-title-link" itemprop="url">C++_10_35_bitset</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <bitset>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <bitset>标准库</h2><p><code>&lt;bitset&gt;</code> 标准库是 C++ 中用于处理固定大小位集的头文件。它提供了 <code>std::bitset</code> 类模板，用于表示固定长度的位序列，并允许对其进行操作。</p>
<h3 id="std-bitset-类"><a href="#std-bitset-类" class="headerlink" title="std::bitset 类"></a><code>std::bitset</code> 类</h3><p><code>std::bitset</code> 是一个固定大小的位集容器。它允许你以比特的形式存储和操作位（0 或 1）。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ol>
<li><p><strong>构造函数</strong>: 可以使用多种方式初始化 <code>std::bitset</code>。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::bitset&lt;8&gt; bits1; <span class="comment">// 初始化一个包含8位的位集，默认所有位都是0</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bits2</span><span class="params">(<span class="number">42</span>)</span></span>; <span class="comment">// 使用整数初始化位集</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bits3</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 使用字符串表示初始化位集</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>位操作</strong>: 可以执行位操作如设置、清除、翻转和获取位的值。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bits<span class="number">1.</span><span class="built_in">set</span>(<span class="number">3</span>, <span class="literal">true</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">bits<span class="number">2.</span><span class="built_in">reset</span>(<span class="number">4</span>); <span class="comment">// 清除第4位</span></span><br><span class="line">bits<span class="number">3.f</span>lip(<span class="number">1</span>); <span class="comment">// 翻转第1位的值</span></span><br><span class="line"><span class="type">bool</span> value = bits<span class="number">1.</span><span class="built_in">test</span>(<span class="number">2</span>); <span class="comment">// 获取第2位的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转换与访问</strong>: 可以将位集转换为其他数据类型或者访问其内部表示。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ulong_val = bits<span class="number">1.</span><span class="built_in">to_ulong</span>(); <span class="comment">// 将位集转换为无符号长整型</span></span><br><span class="line">std::string str_val = bits<span class="number">2.</span><span class="built_in">to_string</span>(); <span class="comment">// 将位集转换为字符串表示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运算符重载</strong>: <code>std::bitset</code> 支持多种位运算符的重载，例如 <code>&amp;</code>、<code>|</code>、<code>^</code> 等，可以进行位与、位或和位异或等操作。</p>
</li>
<li><p><strong>大小和操作</strong>: <code>std::bitset</code> 提供了一些成员函数来获取位集的大小和进行操作，如 <code>size()</code> 返回位集的大小，<code>count()</code> 返回位集中设置为 1 的位的数量。</p>
</li>
</ol>
<h4 id="限制和注意事项"><a href="#限制和注意事项" class="headerlink" title="限制和注意事项"></a>限制和注意事项</h4><ul>
<li><code>std::bitset</code> 的大小必须在编译时确定，并且是固定的。</li>
<li>对于大尺寸的位集，可能会占用较多的内存空间。</li>
</ul>
<p>这个标准库头文件 <code>&lt;bitset&gt;</code> 提供了一些简单而强大的功能，可用于位级操作和处理。使用 <code>std::bitset</code> 可以方便地进行位操作，这在一些需要位级别控制的情况下非常有用。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <bitset>标准库 详解</h2><p><code>&lt;bitset&gt;</code> 是 C++ 标准库中用于处理固定大小位集合的头文件。它提供了 <code>std::bitset</code> 类，用于表示固定长度的位序列，并允许对其进行各种操作。以下是 <code>&lt;bitset&gt;</code> 标准库的详细解释：</p>
<h3 id="std-bitset-类-1"><a href="#std-bitset-类-1" class="headerlink" title="std::bitset 类"></a><code>std::bitset</code> 类</h3><p><code>std::bitset</code> 是一个固定大小的位集容器，每个位的状态可以是 0 或 1。它提供了许多函数和操作符，允许对位集进行各种操作。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li><p><strong>默认构造函数</strong>: <code>std::bitset</code> 可以使用默认构造函数创建，位集中的所有位都被初始化为 0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::bitset&lt;8&gt; bits1; <span class="comment">// 初始化一个包含8位的位集，默认所有位都是0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>整数和字符串构造函数</strong>: <code>std::bitset</code> 可以使用整数或字符串来初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bits2</span><span class="params">(<span class="number">42</span>)</span></span>; <span class="comment">// 使用整数初始化位集</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bits3</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 使用字符串表示初始化位集</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><p><code>std::bitset</code> 提供了一系列用于位操作的成员函数：</p>
<ul>
<li><p><strong>set()</strong>: 将指定位置的位设置为指定值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bits<span class="number">1.</span><span class="built_in">set</span>(<span class="number">3</span>, <span class="literal">true</span>); <span class="comment">// 设置第3位为1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>reset()</strong>: 将指定位置的位重置为0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bits<span class="number">2.</span><span class="built_in">reset</span>(<span class="number">4</span>); <span class="comment">// 清除第4位</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>flip()</strong>: 翻转指定位置的位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bits<span class="number">3.f</span>lip(<span class="number">1</span>); <span class="comment">// 翻转第1位的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>test()</strong>: 检查指定位置的位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> value = bits<span class="number">1.</span><span class="built_in">test</span>(<span class="number">2</span>); <span class="comment">// 获取第2位的值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="转换和访问"><a href="#转换和访问" class="headerlink" title="转换和访问"></a>转换和访问</h4><p><code>std::bitset</code> 支持将位集转换为其他类型，并访问其内部表示：</p>
<ul>
<li><p><strong>to_ulong()</strong>: 将位集转换为无符号长整型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ulong_val = bits<span class="number">1.</span><span class="built_in">to_ulong</span>(); <span class="comment">// 将位集转换为无符号长整型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>to_string()</strong>: 将位集转换为字符串表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str_val = bits<span class="number">2.</span><span class="built_in">to_string</span>(); <span class="comment">// 将位集转换为字符串表示</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p><code>std::bitset</code> 支持多种位运算符的重载，如 <code>&amp;</code>、<code>|</code>、<code>^</code> 等，可以进行位与、位或和位异或等操作。</p>
<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><ul>
<li><p><strong>size()</strong>: 获取位集的大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> size = bits<span class="number">1.</span><span class="built_in">size</span>(); <span class="comment">// 获取位集的大小</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>count()</strong>: 获取位集中设置为 1 的位的数量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> count = bits<span class="number">2.</span><span class="built_in">count</span>(); <span class="comment">// 获取位集中设置为1的位的数量</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>std::bitset</code> 在进行位级操作时非常有用，它提供了一种简单且高效的方式来处理固定大小的位序列。通过这个类，可以执行各种位操作，如设置、清除、翻转和获取位的值，以及进行位级运算等。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <bitset>标准库 常用的类和函数</h2><p>在 <code>&lt;bitset&gt;</code> 标准库中，最主要和常用的类就是 <code>std::bitset</code>。这个类提供了一系列方法和操作符，用于处理固定大小的位集合。以下是 <code>std::bitset</code> 常用的一些类成员函数和操作符：</p>
<h3 id="std-bitset-常用的成员函数："><a href="#std-bitset-常用的成员函数：" class="headerlink" title="std::bitset 常用的成员函数："></a><code>std::bitset</code> 常用的成员函数：</h3><h4 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h4><ul>
<li><code>std::bitset&lt;size&gt;</code>：默认构造函数，创建一个包含 <code>size</code> 位的位集，默认所有位都是0。</li>
</ul>
<h4 id="操作函数："><a href="#操作函数：" class="headerlink" title="操作函数："></a>操作函数：</h4><ul>
<li><code>set(pos, value)</code>：将指定位置 <code>pos</code> 的位设置为 <code>value</code>。</li>
<li><code>reset(pos)</code>：将指定位置 <code>pos</code> 的位重置为0。</li>
<li><code>flip(pos)</code>：翻转指定位置 <code>pos</code> 的位。</li>
</ul>
<h4 id="查询函数："><a href="#查询函数：" class="headerlink" title="查询函数："></a>查询函数：</h4><ul>
<li><code>test(pos)</code>：检查指定位置 <code>pos</code> 的位。</li>
</ul>
<h4 id="转换函数："><a href="#转换函数：" class="headerlink" title="转换函数："></a>转换函数：</h4><ul>
<li><code>to_ulong()</code>：将位集转换为无符号长整型。</li>
<li><code>to_ullong()</code>：将位集转换为无符号长长整型。</li>
<li><code>to_string()</code>：将位集转换为字符串表示。</li>
</ul>
<h4 id="运算符重载："><a href="#运算符重载：" class="headerlink" title="运算符重载："></a>运算符重载：</h4><p><code>std::bitset</code> 支持多种位运算符的重载，可以进行位与 <code>&amp;</code>、位或 <code>|</code>、位异或 <code>^</code> 等操作。</p>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;8&gt; bits; <span class="comment">// 创建一个8位的位集，默认所有位都是0</span></span><br><span class="line"></span><br><span class="line">    bits.<span class="built_in">set</span>(<span class="number">3</span>, <span class="literal">true</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">    bits.<span class="built_in">reset</span>(<span class="number">4</span>); <span class="comment">// 清除第4位</span></span><br><span class="line">    bits.<span class="built_in">flip</span>(<span class="number">1</span>); <span class="comment">// 翻转第1位的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> value = bits.<span class="built_in">test</span>(<span class="number">2</span>); <span class="comment">// 获取第2位的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulong_val = bits.<span class="built_in">to_ulong</span>(); <span class="comment">// 将位集转换为无符号长整型</span></span><br><span class="line">    std::string str_val = bits.<span class="built_in">to_string</span>(); <span class="comment">// 将位集转换为字符串表示</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bitset: &quot;</span> &lt;&lt; bits &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at position 2: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to unsigned long: &quot;</span> &lt;&lt; ulong_val &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to string: &quot;</span> &lt;&lt; str_val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::bitset</code> 的常用函数和运算符的用法。你可以使用这些方法来进行位级操作，查询位的值，将位集转换为其他类型等操作。</p>
<h2 id="std-bitset"><a href="#std-bitset" class="headerlink" title="std::bitset"></a>std::bitset</h2><p><code>std::bitset</code> 是 C++ 标准库中用于表示固定大小位集的类。它允许你以位（0 或 1）的形式存储和操作固定长度的二进制数据。</p>
<h3 id="特点和功能："><a href="#特点和功能：" class="headerlink" title="特点和功能："></a>特点和功能：</h3><ol>
<li><p><strong>固定长度的位集合：</strong> <code>std::bitset</code> 表示一个固定大小的位序列，位的数量在编译时即确定。</p>
</li>
<li><p><strong>初始化方式：</strong> 可以使用整数、字符串或默认构造函数来初始化 <code>std::bitset</code> 对象。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::bitset&lt;8&gt; bits1; <span class="comment">// 初始化一个包含8位的位集，默认所有位都是0</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bits2</span><span class="params">(<span class="number">42</span>)</span></span>; <span class="comment">// 使用整数初始化位集</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bits3</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 使用字符串表示初始化位集</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>位操作函数：</strong> 提供了一系列的函数来操作位，如设置、清除、翻转和检查位的状态。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bits<span class="number">1.</span><span class="built_in">set</span>(<span class="number">3</span>, <span class="literal">true</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">bits<span class="number">2.</span><span class="built_in">reset</span>(<span class="number">4</span>); <span class="comment">// 清除第4位</span></span><br><span class="line">bits<span class="number">3.f</span>lip(<span class="number">1</span>); <span class="comment">// 翻转第1位的值</span></span><br><span class="line"><span class="type">bool</span> value = bits<span class="number">1.</span><span class="built_in">test</span>(<span class="number">2</span>); <span class="comment">// 获取第2位的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转换函数：</strong> 可以将位集转换为其他数据类型，如整数或字符串。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ulong_val = bits<span class="number">1.</span><span class="built_in">to_ulong</span>(); <span class="comment">// 将位集转换为无符号长整型</span></span><br><span class="line">std::string str_val = bits<span class="number">2.</span><span class="built_in">to_string</span>(); <span class="comment">// 将位集转换为字符串表示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>位运算符重载：</strong> 支持多种位运算符的重载，如 <code>&amp;</code>、<code>|</code>、<code>^</code> 等，可以进行位与、位或和位异或等操作。</p>
</li>
</ol>
<h3 id="示例用法：-1"><a href="#示例用法：-1" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;8&gt; bits; <span class="comment">// 创建一个8位的位集，默认所有位都是0</span></span><br><span class="line"></span><br><span class="line">    bits.<span class="built_in">set</span>(<span class="number">3</span>, <span class="literal">true</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">    bits.<span class="built_in">reset</span>(<span class="number">4</span>); <span class="comment">// 清除第4位</span></span><br><span class="line">    bits.<span class="built_in">flip</span>(<span class="number">1</span>); <span class="comment">// 翻转第1位的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> value = bits.<span class="built_in">test</span>(<span class="number">2</span>); <span class="comment">// 获取第2位的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulong_val = bits.<span class="built_in">to_ulong</span>(); <span class="comment">// 将位集转换为无符号长整型</span></span><br><span class="line">    std::string str_val = bits.<span class="built_in">to_string</span>(); <span class="comment">// 将位集转换为字符串表示</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bitset: &quot;</span> &lt;&lt; bits &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at position 2: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to unsigned long: &quot;</span> &lt;&lt; ulong_val &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to string: &quot;</span> &lt;&lt; str_val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::bitset</code> 的常用功能。通过 <code>std::bitset</code>，你可以轻松进行位级操作，并将位集转换为其他数据类型，如整数或字符串。</p>
<h2 id="std-bitset-set"><a href="#std-bitset-set" class="headerlink" title="std::bitset::set"></a>std::bitset::set</h2><p><code>std::bitset::set</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于设置位集中指定位置的位为指定的值（0 或 1）。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">bool</span> value = <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>pos</code>：要设置的位的位置，从 0 开始计数。</li>
<li><code>value</code>：要设置的值，默认为 <code>true</code>，表示设置该位为 1；若设置为 <code>false</code>，则表示设置该位为 0。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>set</code> 函数用于将 <code>std::bitset</code> 中指定位置 <code>pos</code> 的位设置为指定的值 <code>value</code>。当 <code>value</code> 被设置为 <code>true</code> 时，默认将该位设置为 1；当 <code>value</code> 被设置为 <code>false</code> 时，则将该位设置为 0。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;8&gt; bits; <span class="comment">// 创建一个8位的位集，默认所有位都是0</span></span><br><span class="line"></span><br><span class="line">    bits.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">    bits.<span class="built_in">set</span>(<span class="number">4</span>, <span class="literal">false</span>); <span class="comment">// 设置第4位为0</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bitset after setting bit 3 and clearing bit 4: &quot;</span> &lt;&lt; bits &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits.set(3)</code> 将第3位设置为1，<code>bits.set(4, false)</code> 将第4位设置为0。最终输出位集中的状态。</p>
<h2 id="std-bitset-reset"><a href="#std-bitset-reset" class="headerlink" title="std::bitset::reset"></a>std::bitset::reset</h2><p><code>std::bitset::reset</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于将位集中指定位置的位重置为 0。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">size_t</span> pos)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>pos</code>：要重置的位的位置，从 0 开始计数。</li>
</ul>
<h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>reset</code> 函数将 <code>std::bitset</code> 中指定位置 <code>pos</code> 的位重置为 0。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;8&gt; bits; <span class="comment">// 创建一个8位的位集，默认所有位都是0</span></span><br><span class="line"></span><br><span class="line">    bits.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">    bits.<span class="built_in">reset</span>(<span class="number">4</span>); <span class="comment">// 清除第4位</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bitset after setting bit 3 and clearing bit 4: &quot;</span> &lt;&lt; bits &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits.set(3)</code> 将第3位设置为1，<code>bits.reset(4)</code> 清除（重置为0）了第4位。最终输出位集中的状态。</p>
<h2 id="std-bitset-flip"><a href="#std-bitset-flip" class="headerlink" title="std::bitset::flip"></a>std::bitset::flip</h2><p><code>std::bitset::flip</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于翻转位集中指定位置的位（将 0 变为 1，将 1 变为 0）。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">size_t</span> pos)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>pos</code>：要翻转的位的位置，从 0 开始计数。</li>
</ul>
<h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>flip</code> 函数将 <code>std::bitset</code> 中指定位置 <code>pos</code> 的位进行翻转，即将 0 变为 1，将 1 变为 0。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;8&gt; bits; <span class="comment">// 创建一个8位的位集，默认所有位都是0</span></span><br><span class="line"></span><br><span class="line">    bits.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">    bits.<span class="built_in">flip</span>(<span class="number">4</span>); <span class="comment">// 翻转第4位</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bitset after setting bit 3 and flipping bit 4: &quot;</span> &lt;&lt; bits &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits.set(3)</code> 将第3位设置为1，<code>bits.flip(4)</code> 对第4位进行翻转操作。最终输出位集中的状态。</p>
<h2 id="std-bitset-test"><a href="#std-bitset-test" class="headerlink" title="std::bitset::test"></a>std::bitset::test</h2><p><code>std::bitset::test</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于检查位集中指定位置的位的状态。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">size_t</span> pos)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>pos</code>：要检查的位的位置，从 0 开始计数。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>bool</code>：如果指定位置 <code>pos</code> 的位为 1，则返回 <code>true</code>；如果为 0，则返回 <code>false</code>。</li>
</ul>
<h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>test</code> 函数用于检查 <code>std::bitset</code> 中指定位置 <code>pos</code> 的位的状态。</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bits</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 初始化一个8位的位集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> value1 = bits.<span class="built_in">test</span>(<span class="number">2</span>); <span class="comment">// 获取第2位的值</span></span><br><span class="line">    <span class="type">bool</span> value2 = bits.<span class="built_in">test</span>(<span class="number">5</span>); <span class="comment">// 获取第5位的值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at position 2: &quot;</span> &lt;&lt; value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at position 5: &quot;</span> &lt;&lt; value2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits</code> 是一个包含 8 位的位集。<code>bits.test(2)</code> 检查第2位的值，<code>bits.test(5)</code> 检查第5位的值，并将结果输出。</p>
<h2 id="std-bitset-to-ulong"><a href="#std-bitset-to-ulong" class="headerlink" title="std::bitset::to_ulong"></a>std::bitset::to_ulong</h2><p><code>std::bitset::to_ulong</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于将位集转换为对应的无符号长整型（<code>unsigned long</code>）数值。</p>
<h3 id="函数签名：-4"><a href="#函数签名：-4" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">to_ulong</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>unsigned long</code>：位集表示的无符号长整型数值。</li>
</ul>
<h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>to_ulong</code> 函数用于将 <code>std::bitset</code> 中存储的二进制位序列转换为对应的无符号长整型数值。这个函数会将位集中的二进制位转换为对应的整数值。</li>
</ul>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>如果 <code>std::bitset</code> 的大小超过了 <code>unsigned long</code> 的位数，将会抛出 <code>std::overflow_error</code> 异常。</li>
</ul>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bits</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 初始化一个8位的位集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulong_val = bits.<span class="built_in">to_ulong</span>(); <span class="comment">// 将位集转换为无符号长整型数值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to unsigned long: &quot;</span> &lt;&lt; ulong_val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits</code> 是一个包含 8 位的位集。<code>bits.to_ulong()</code> 将位集转换为对应的无符号长整型数值，并将结果输出。</p>
<h2 id="std-bitset-to-string"><a href="#std-bitset-to-string" class="headerlink" title="std::bitset::to_string"></a>std::bitset::to_string</h2><p><code>std::bitset::to_string</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于将位集转换为对应的字符串表示形式。</p>
<h3 id="函数签名：-5"><a href="#函数签名：-5" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>std::string</code>：表示位集的字符串。</li>
</ul>
<h3 id="功能：-5"><a href="#功能：-5" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>to_string</code> 函数用于将 <code>std::bitset</code> 中存储的二进制位序列转换为字符串表示形式。这个函数会返回一个字符串，其中包含了位集的二进制表示。</li>
</ul>
<h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bits</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 初始化一个8位的位集</span></span><br><span class="line"></span><br><span class="line">    std::string str_val = bits.<span class="built_in">to_string</span>(); <span class="comment">// 将位集转换为字符串表示形式</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to string: &quot;</span> &lt;&lt; str_val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits</code> 是一个包含 8 位的位集。<code>bits.to_string()</code> 将位集转换为对应的字符串表示，并将结果输出。</p>
<h2 id="std-bitset-size"><a href="#std-bitset-size" class="headerlink" title="std::bitset::size"></a>std::bitset::size</h2><p><code>std::bitset::size</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于获取位集的大小，即位集中包含的位数。</p>
<h3 id="函数签名：-6"><a href="#函数签名：-6" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>size_t</code>：位集中包含的位数。</li>
</ul>
<h3 id="功能：-6"><a href="#功能：-6" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>size</code> 函数用于获取 <code>std::bitset</code> 中包含的位数，即位集的大小。返回值为 <code>size_t</code> 类型，表示位集中的位数。</li>
</ul>
<h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;8&gt; bits; <span class="comment">// 创建一个8位的位集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> bits_size = bits.<span class="built_in">size</span>(); <span class="comment">// 获取位集的大小</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of the bitset: &quot;</span> &lt;&lt; bits_size &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits</code> 是一个包含 8 位的位集。<code>bits.size()</code> 获取位集的大小，并将结果输出。</p>
<h2 id="std-bitset-count"><a href="#std-bitset-count" class="headerlink" title="std::bitset::count"></a>std::bitset::count</h2><p><code>std::bitset::count</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于计算位集中被设置为 1 的位的数量。</p>
<h3 id="函数签名：-7"><a href="#函数签名：-7" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>size_t</code>：位集中被设置为 1 的位的数量。</li>
</ul>
<h3 id="功能：-7"><a href="#功能：-7" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>count</code> 函数用于计算 <code>std::bitset</code> 中被设置为 1 的位的数量，即统计位集中值为 1 的位的个数。</li>
</ul>
<h3 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bits</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 初始化一个8位的位集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> count_of_ones = bits.<span class="built_in">count</span>(); <span class="comment">// 计算位集中被设置为1的位的数量</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count of ones in the bitset: &quot;</span> &lt;&lt; count_of_ones &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits</code> 是一个包含 8 位的位集。<code>bits.count()</code> 统计位集中被设置为 1 的位的数量，并将结果输出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_36_ratio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_36_ratio/" class="post-title-link" itemprop="url">C++_10_36_ratio</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <ratio>标准库</li>
</ul>
<h2 id="C-是什么"><a href="#C-是什么" class="headerlink" title="C++ 是什么"></a>C++ <ratio>是什么</h2><p>在C++中，<code>&lt;ratio&gt;</code> 是一个头文件，定义了用于表示有理数的模板类 <code>std::ratio</code>。这个头文件引入了与比例相关的模板类，允许在编译时进行精确的有理数计算，通常用于 <code>&lt;chrono&gt;</code> 头文件中，用于定义时间单位。</p>
<h3 id="std-ratio-模板类"><a href="#std-ratio-模板类" class="headerlink" title="std::ratio 模板类"></a><code>std::ratio</code> 模板类</h3><p><code>std::ratio</code> 是一个用于表示有理数的模板类，它的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">intmax_t</span> Num, std::<span class="type">intmax_t</span> Den = <span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> ratio;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>Num</code> 表示有理数的分子，默认为 1。</li>
<li><code>Den</code> 表示有理数的分母，默认为 1。</li>
</ul>
<p>这个模板类用于表示编译时常量的比率，通常用于 <code>&lt;chrono&gt;</code> 中，定义了时间单位的比例。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个简单的示例，展示如何使用 <code>std::ratio</code> 来表示一个比例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示比例为 2:3</span></span><br><span class="line">    std::ratio&lt;<span class="number">2</span>, <span class="number">3</span>&gt; myRatio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取分子和分母</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Numerator: &quot;</span> &lt;&lt; myRatio.num &lt;&lt; std::endl;   <span class="comment">// 输出 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Denominator: &quot;</span> &lt;&lt; myRatio.den &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::ratio&lt;2, 3&gt;</code> 表示比例为 2:3 的有理数。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><code>std::ratio</code> 的主要用途之一是在 <code>&lt;chrono&gt;</code> 头文件中，用于定义 <code>std::chrono::duration</code> 类型的时间单位。例如，<code>std::ratio&lt;1, 1000&gt;</code> 表示毫秒，<code>std::ratio&lt;60&gt;</code> 表示分钟，等等。这种有理数表示方式在编译时提供了更高的精确度，尤其在需要进行时间单位转换和计算的场景中非常有用。</p>
<h2 id="C-std-ratio详解"><a href="#C-std-ratio详解" class="headerlink" title="C++ std::ratio详解"></a>C++ std::ratio详解</h2><p><code>std::ratio</code> 是 C++11 标准引入的一个模板类，用于表示有理数。它定义在 <code>&lt;ratio&gt;</code> 头文件中。这个模板类非常简单，只有两个整数模板参数，分别表示有理数的分子和分母。</p>
<p>以下是关于 <code>std::ratio</code> 的详细解释：</p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">intmax_t</span> Num, std::<span class="type">intmax_t</span> Den = <span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> ratio;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Num</code>：表示有理数的分子。</li>
<li><code>Den</code>：表示有理数的分母，默认为 1。</li>
</ul>
<h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示比例为 2:3</span></span><br><span class="line">    std::ratio&lt;<span class="number">2</span>, <span class="number">3</span>&gt; myRatio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取分子和分母</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Numerator: &quot;</span> &lt;&lt; myRatio.num &lt;&lt; std::endl;   <span class="comment">// 输出 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Denominator: &quot;</span> &lt;&lt; myRatio.den &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-成员变量"><a href="#3-成员变量" class="headerlink" title="3. 成员变量"></a>3. 成员变量</h3><ul>
<li><code>num</code>：表示有理数的分子。</li>
<li><code>den</code>：表示有理数的分母。</li>
</ul>
<h3 id="4-成员函数"><a href="#4-成员函数" class="headerlink" title="4. 成员函数"></a>4. 成员函数</h3><p><code>std::ratio</code> 提供了一些用于执行在编译时进行的算术运算的静态成员函数，例如：</p>
<ul>
<li><code>add&lt;R1, R2&gt;</code>：将两个有理数相加。</li>
<li><code>subtract&lt;R1, R2&gt;</code>：将一个有理数减去另一个有理数。</li>
<li><code>multiply&lt;R1, R2&gt;</code>：将两个有理数相乘。</li>
<li><code>divide&lt;R1, R2&gt;</code>：将一个有理数除以另一个有理数。</li>
</ul>
<p>这些函数返回的都是新的 <code>std::ratio</code> 类型。</p>
<h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h3><p><code>std::ratio</code> 主要用于在编译时执行精确的比例运算，特别适用于模板元编程或其他需要在编译时进行常量计算的场景。通过使用 <code>std::ratio</code>，可以避免运行时计算的误差，并在编译时得到准确的结果。</p>
<h3 id="6-示例：编译时计算"><a href="#6-示例：编译时计算" class="headerlink" title="6. 示例：编译时计算"></a>6. 示例：编译时计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> r1 = std::ratio&lt;<span class="number">2</span>, <span class="number">3</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> r2 = std::ratio&lt;<span class="number">3</span>, <span class="number">4</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个有理数的乘积在编译时得到结果</span></span><br><span class="line">    <span class="keyword">using</span> result_ratio = std::ratio_multiply&lt;r1, r2&gt;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result Numerator: &quot;</span> &lt;&lt; result_ratio::num &lt;&lt; std::endl;   <span class="comment">// 输出 6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result Denominator: &quot;</span> &lt;&lt; result_ratio::den &lt;&lt; std::endl; <span class="comment">// 输出 12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个简单的示例，展示了如何在编译时计算两个有理数的乘积。这种编译时计算可以用于优化和精确控制程序的行为。</p>
<h2 id="C-chrono标准库中使用std-ratio表示秒"><a href="#C-chrono标准库中使用std-ratio表示秒" class="headerlink" title="C++ chrono标准库中使用std::ratio表示秒"></a>C++ chrono标准库中使用std::ratio表示秒</h2><p>在C++标准库中，<code>std::chrono</code> 提供了一种灵活的方式来表示时间间隔，并且可以使用 <code>std::ratio</code> 来指定时间单位。对于秒的表示，可以使用 <code>std::ratio</code> 中的 <code>std::ratio&lt;1, 1&gt;</code>，因为默认情况下，<code>std::ratio</code> 的分子和分母都是1。</p>
<p>以下是一个示例，演示如何使用 <code>std::chrono</code> 表示秒：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示 2 秒的时间间隔</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">int</span>&gt; <span class="title">duration_seconds</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration in seconds: &quot;</span> &lt;&lt; duration_seconds.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::chrono::duration&lt;int&gt;</code> 表示了一个时间间隔为 2 秒的对象，其中 <code>std::ratio&lt;1, 1&gt;</code> 被用作时间单位，表示秒。因为 <code>std::ratio</code> 是一个通用的模板类，你可以根据需要选择不同的分子和分母来表示其他时间单位。例如，使用 <code>std::ratio&lt;1, 1000&gt;</code> 表示毫秒，或者 <code>std::ratio&lt;60&gt;</code> 表示分钟。这种灵活性使得 <code>std::chrono</code> 非常适合处理各种时间单位和精度。</p>
<h2 id="C-std-chrono-duration-和-std-ratio"><a href="#C-std-chrono-duration-和-std-ratio" class="headerlink" title="C++ std::chrono::duration 和 std::ratio"></a>C++ std::chrono::duration 和 std::ratio</h2><p>在C++中，<code>std::chrono::duration</code> 和 <code>std::ratio</code> 是与时间相关的两个重要的组件，用于实现时间单位和时间间隔的表示。</p>
<h3 id="1-std-ratio"><a href="#1-std-ratio" class="headerlink" title="1. std::ratio"></a>1. <code>std::ratio</code></h3><p><code>std::ratio</code> 是一个用于表示有理数的模板类，定义在 <code>&lt;ratio&gt;</code> 头文件中。它通常用于定义时间单位的比率。例如，秒、毫秒、微秒等时间单位可以通过不同的 <code>std::ratio</code> 实例来表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示比例为 1:1000，用于表示毫秒</span></span><br><span class="line">    <span class="keyword">using</span> milli = std::ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::chrono::duration 表示 5 毫秒</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">int</span>, milli&gt; <span class="title">duration</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration in milliseconds: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-std-chrono-duration"><a href="#2-std-chrono-duration" class="headerlink" title="2. std::chrono::duration"></a>2. <code>std::chrono::duration</code></h3><p><code>std::chrono::duration</code> 是一个模板类，定义在 <code>&lt;chrono&gt;</code> 头文件中。它表示时间间隔，可以用不同的时间单位来表示。<code>std::chrono::duration</code> 接受两个模板参数：第一个表示时间的数值类型，第二个表示时间单位的类型（通常是 <code>std::ratio</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示 5 秒的时间间隔</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">int</span>&gt; <span class="title">duration_seconds</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示 500 毫秒的时间间隔</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">int</span>, std::milli&gt; <span class="title">duration_milliseconds</span><span class="params">(<span class="number">500</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration in seconds: &quot;</span> &lt;&lt; duration_seconds.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration in milliseconds: &quot;</span> &lt;&lt; duration_milliseconds.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-关系"><a href="#3-关系" class="headerlink" title="3. 关系"></a>3. 关系</h3><p><code>std::ratio</code> 用于定义时间单位的比率，而 <code>std::chrono::duration</code> 使用这些比率来表示时间间隔。在 <code>std::chrono::duration</code> 中，时间单位是通过 <code>std::ratio</code> 实例来指定的。这种结合可以使得时间的表示更加灵活和精确。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示 2.5 秒的时间间隔</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">double</span>&gt; <span class="title">duration_seconds</span><span class="params">(<span class="number">2.5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示 2500 毫秒的时间间隔</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">double</span>, std::milli&gt; <span class="title">duration_milliseconds</span><span class="params">(<span class="number">2500</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration in seconds: &quot;</span> &lt;&lt; duration_seconds.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration in milliseconds: &quot;</span> &lt;&lt; duration_milliseconds.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::ratio</code> 用于表示秒和毫秒之间的比率，而 <code>std::chrono::duration</code> 使用这个比率来表示时间间隔。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_37_iterator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_37_iterator/" class="post-title-link" itemprop="url">C++_10_37_iterator</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><iterator>标准库</li>
</ul>
<h2 id="C-是什么"><a href="#C-是什么" class="headerlink" title="C++ 是什么"></a>C++ <iterator>是什么</h2><p>在C++中，<code>&lt;iterator&gt;</code> 是一个标准库头文件，提供了与迭代器相关的功能和模板类。该头文件定义了许多与迭代器操作和适配器相关的模板类和函数，使得对各种容器和序列的操作更加方便和统一。</p>
<p>以下是 <code>&lt;iterator&gt;</code> 头文件中一些常见的内容：</p>
<h3 id="1-迭代器标签"><a href="#1-迭代器标签" class="headerlink" title="1. 迭代器标签"></a>1. 迭代器标签</h3><ul>
<li><code>std::input_iterator_tag</code>：输入迭代器标签。</li>
<li><code>std::output_iterator_tag</code>：输出迭代器标签。</li>
<li><code>std::forward_iterator_tag</code>：前向迭代器标签。</li>
<li><code>std::bidirectional_iterator_tag</code>：双向迭代器标签。</li>
<li><code>std::random_access_iterator_tag</code>：随机访问迭代器标签。</li>
</ul>
<p>这些标签用于指定迭代器的类型，以便在泛型编程中选择适当的算法。</p>
<h3 id="2-迭代器类别"><a href="#2-迭代器类别" class="headerlink" title="2. 迭代器类别"></a>2. 迭代器类别</h3><ul>
<li><code>std::iterator_traits</code>：模板类，提供有关迭代器类型的信息。</li>
</ul>
<h3 id="3-迭代器操作"><a href="#3-迭代器操作" class="headerlink" title="3. 迭代器操作"></a>3. 迭代器操作</h3><ul>
<li><code>std::advance</code>：将迭代器前进指定的步数。</li>
<li><code>std::distance</code>：计算两个迭代器之间的距离。</li>
</ul>
<h3 id="4-插入迭代器"><a href="#4-插入迭代器" class="headerlink" title="4. 插入迭代器"></a>4. 插入迭代器</h3><ul>
<li><code>std::back_inserter</code>：用于在容器尾部插入元素的迭代器适配器。</li>
<li><code>std::front_inserter</code>：用于在容器头部插入元素的迭代器适配器。</li>
<li><code>std::inserter</code>：用于在指定位置插入元素的迭代器适配器。</li>
</ul>
<h3 id="5-流迭代器"><a href="#5-流迭代器" class="headerlink" title="5. 流迭代器"></a>5. 流迭代器</h3><ul>
<li><code>std::istream_iterator</code>：输入流迭代器。</li>
<li><code>std::ostream_iterator</code>：输出流迭代器。</li>
</ul>
<p>这些迭代器适配器使得可以将输入流和输出流与迭代器接口一致地结合使用。</p>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h3><p>还有其他一些辅助功能和模板类，用于处理迭代器和序列的各种操作。</p>
<p>通过使用 <code>&lt;iterator&gt;</code> 头文件中提供的这些功能，开发者可以更方便地进行迭代器的操作、适配和处理，从而提高代码的灵活性和可维护性。</p>
<h2 id="C-详解"><a href="#C-详解" class="headerlink" title="C++ 详解"></a>C++ <iterator>详解</h2><p><code>&lt;iterator&gt;</code> 是C++标准库中的头文件，提供了许多与迭代器相关的工具、类和函数。这个头文件包含了一系列功能，用于支持通用的迭代器操作和适配器。以下是 <code>&lt;iterator&gt;</code> 头文件的主要内容：</p>
<h3 id="1-迭代器标签-1"><a href="#1-迭代器标签-1" class="headerlink" title="1. 迭代器标签"></a>1. 迭代器标签</h3><ul>
<li><code>std::input_iterator_tag</code>：输入迭代器标签。</li>
<li><code>std::output_iterator_tag</code>：输出迭代器标签。</li>
<li><code>std::forward_iterator_tag</code>：前向迭代器标签。</li>
<li><code>std::bidirectional_iterator_tag</code>：双向迭代器标签。</li>
<li><code>std::random_access_iterator_tag</code>：随机访问迭代器标签。</li>
</ul>
<p>这些标签用于表示迭代器的不同特性，以便在泛型算法中根据迭代器的类型选择适当的算法。</p>
<h3 id="2-迭代器类别-1"><a href="#2-迭代器类别-1" class="headerlink" title="2. 迭代器类别"></a>2. 迭代器类别</h3><ul>
<li><code>std::iterator_traits</code>：模板类，提供有关迭代器类型的信息，如迭代器的标签、值类型、指针类型等。</li>
</ul>
<h3 id="3-迭代器操作-1"><a href="#3-迭代器操作-1" class="headerlink" title="3. 迭代器操作"></a>3. 迭代器操作</h3><ul>
<li><code>std::advance</code>：用于将迭代器前进指定的步数。</li>
<li><code>std::distance</code>：用于计算两个迭代器之间的距离。</li>
</ul>
<h3 id="4-插入迭代器-1"><a href="#4-插入迭代器-1" class="headerlink" title="4. 插入迭代器"></a>4. 插入迭代器</h3><ul>
<li><code>std::back_inserter</code>：迭代器适配器，用于在容器尾部插入元素。</li>
<li><code>std::front_inserter</code>：迭代器适配器，用于在容器头部插入元素。</li>
<li><code>std::inserter</code>：迭代器适配器，用于在指定位置插入元素。</li>
</ul>
<p>这些插入迭代器适配器允许将算法应用于容器而无需关心具体插入的位置。</p>
<h3 id="5-流迭代器-1"><a href="#5-流迭代器-1" class="headerlink" title="5. 流迭代器"></a>5. 流迭代器</h3><ul>
<li><code>std::istream_iterator</code>：输入流迭代器，用于从输入流中读取数据。</li>
<li><code>std::ostream_iterator</code>：输出流迭代器，用于向输出流中写入数据。</li>
</ul>
<p>这些迭代器适配器允许将输入流和输出流与迭代器接口一致地结合使用。</p>
<h3 id="6-std-begin-和-std-end"><a href="#6-std-begin-和-std-end" class="headerlink" title="6. std::begin 和 std::end"></a>6. <code>std::begin</code> 和 <code>std::end</code></h3><ul>
<li><code>std::begin</code>：用于获取容器的起始迭代器。</li>
<li><code>std::end</code>：用于获取容器的结束迭代器。</li>
</ul>
<p>这两个函数允许以通用的方式获得容器的起始和结束迭代器。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个简单的示例，展示了 <code>&lt;iterator&gt;</code> 头文件中的一些功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器适配器将元素复制到输出流</span></span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(numbers), std::<span class="built_in">end</span>(numbers), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子使用了 <code>std::begin</code> 和 <code>std::end</code> 获取容器的起始和结束迭代器，并使用 <code>std::copy</code> 将容器中的元素复制到输出流中。还使用了 <code>std::ostream_iterator</code> 来实现输出流迭代器。</p>
<h2 id="C-std-prev-函数-详解"><a href="#C-std-prev-函数-详解" class="headerlink" title="C++  std::prev()函数 详解"></a>C++ <iterator> std::prev()函数 详解</h2><p><code>std::prev()</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的函数之一。它的作用是返回一个迭代器，指向指定迭代器之前的位置。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> BidirIt &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> BidirIt <span class="title">prev</span><span class="params">( BidirIt it, <span class="keyword">typename</span> std::iterator_traits&lt;BidirIt&gt;::difference_type n = <span class="number">1</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>BidirIt</code> 是双向迭代器的类型。</li>
<li><code>it</code> 是要移动的迭代器。</li>
<li><code>n</code> 是要向前移动的步数，默认为1。</li>
</ul>
<p><code>std::prev()</code> 函数返回一个新的迭代器，该迭代器指向传入迭代器的前面。如果没有指定步数 <code>n</code>，默认向前移动一个位置。如果指定了步数 <code>n</code>，则向前移动 <code>n</code> 个位置。</p>
<p>以下是一个简单的例子，演示了 <code>std::prev()</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器指向第四个元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::prev() 向前移动两个位置</span></span><br><span class="line">    <span class="keyword">auto</span> prevIt = std::<span class="built_in">prev</span>(it, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current iterator position: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Iterator position after std::prev(): &quot;</span> &lt;&lt; *prevIt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>it</code> 指向第四个元素，然后使用 <code>std::prev()</code> 向前移动两个位置，得到的 <code>prevIt</code> 指向第二个元素。</p>
<h2 id="C-std-advance-函数-详解"><a href="#C-std-advance-函数-详解" class="headerlink" title="C++  std::advance()函数 详解"></a>C++ <iterator> std::advance()函数 详解</h2><p><code>std::advance()</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的函数之一。它的作用是将迭代器前移（或后移）指定的步数。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> Distance &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">advance</span><span class="params">( InputIt&amp; it, Distance n )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>InputIt</code> 是输入迭代器的类型。</li>
<li><code>it</code> 是要移动的迭代器（传入的是引用）。</li>
<li><code>n</code> 是要移动的步数。</li>
</ul>
<p><code>std::advance()</code> 函数将迭代器 <code>it</code> 前移 <code>n</code> 步。如果 <code>n</code> 为正数，则迭代器向前移动；如果 <code>n</code> 为负数，则迭代器向后移动。</p>
<p>以下是一个简单的例子，演示了 <code>std::advance()</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器指向第二个元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::advance() 向前移动两个位置</span></span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Iterator position after std::advance(): &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>it</code> 指向第二个元素，然后使用 <code>std::advance()</code> 向前移动两个位置，最终 <code>it</code> 指向第四个元素。</p>
<h2 id="C-std-distance-函数-详解"><a href="#C-std-distance-函数-详解" class="headerlink" title="C++  std::distance()函数 详解"></a>C++ <iterator> std::distance()函数 详解</h2><p><code>std::distance()</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的函数之一。它的作用是计算两个迭代器之间的距离（元素个数）。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">InputIt</span> &gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIt&gt;::<span class="function">difference_type <span class="title">distance</span><span class="params">( InputIt first, InputIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>InputIt</code> 是输入迭代器的类型。</li>
<li><code>first</code> 是第一个迭代器。</li>
<li><code>last</code> 是第二个迭代器。</li>
</ul>
<p><code>std::distance()</code> 函数返回两个迭代器之间的距离，即 <code>last - first</code>。结果的类型是由迭代器的 <code>difference_type</code> 决定的。</p>
<p>以下是一个简单的例子，演示了 <code>std::distance()</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取两个迭代器分别指向第二个和第四个元素</span></span><br><span class="line">    <span class="keyword">auto</span> first = numbers.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> last = numbers.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::distance() 计算它们之间的距离</span></span><br><span class="line">    std::<span class="type">ptrdiff_t</span> distance = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Distance between iterators: &quot;</span> &lt;&lt; distance &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>first</code> 和 <code>last</code> 分别指向第二个和第四个元素，然后使用 <code>std::distance()</code> 计算它们之间的距离，最终输出结果为 <code>2</code>。</p>
<h2 id="C-std-back-inserter-详解"><a href="#C-std-back-inserter-详解" class="headerlink" title="C++  std::back_inserter 详解"></a>C++ <iterator> std::back_inserter 详解</h2><p><code>std::back_inserter</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的一个函数模板，它创建一个用于在容器尾部插入元素的插入迭代器。</p>
<p>这个函数模板的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Container &gt;</span></span><br><span class="line"><span class="function">std::back_insert_iterator&lt;Container&gt; <span class="title">back_inserter</span><span class="params">( Container&amp; c )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Container</code> 是容器的类型。</li>
</ul>
<p><code>std::back_inserter</code> 返回一个 <code>std::back_insert_iterator</code> 对象，它是一个迭代器，允许通过 <code>operator++</code> 和 <code>operator*</code> 在容器的尾部插入元素。</p>
<p>以下是一个简单的例子，演示了 <code>std::back_inserter</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::back_inserter 创建插入迭代器</span></span><br><span class="line">    std::back_insert_iterator&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">backInserter</span>(destination);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::copy 将 source 中的元素插入到 destination 的尾部</span></span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), backInserter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destination vector after insertion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : destination) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::back_inserter</code> 用于创建一个插入迭代器，然后使用 <code>std::copy</code> 将 <code>source</code> 容器中的元素插入到 <code>destination</code> 容器的尾部。最终输出结果为 <code>Destination vector after insertion: 1 2 3 4 5</code>。</p>
<h2 id="C-std-front-inserter-详解"><a href="#C-std-front-inserter-详解" class="headerlink" title="C++  std::front_inserter 详解"></a>C++ <iterator> std::front_inserter 详解</h2><p>在 C++ 标准库的 <code>&lt;iterator&gt;</code> 头文件中，<code>std::front_inserter</code> 是一个函数模板，用于创建一个插入迭代器，该迭代器允许在容器的开头插入元素。这通常用于在容器的前部执行插入操作。</p>
<p>下面是 <code>std::front_inserter</code> 的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Container &gt;</span></span><br><span class="line"><span class="function">std::front_insert_iterator&lt;Container&gt; <span class="title">front_inserter</span><span class="params">( Container&amp; c )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Container</code> 是容器的类型。</li>
</ul>
<p><code>std::front_inserter</code> 返回一个 <code>std::front_insert_iterator</code> 对象，该对象可以通过 <code>operator++</code> 和 <code>operator*</code> 来在容器的开头插入元素。</p>
<p>以下是一个简单的例子，演示了 <code>std::front_inserter</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::front_inserter 创建插入迭代器</span></span><br><span class="line">    std::front_insert_iterator&lt;std::list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">frontInserter</span>(destination);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::copy 将 source 中的元素插入到 destination 的开头</span></span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), frontInserter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destination list after insertion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : destination) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::front_inserter</code> 用于创建一个插入迭代器，然后使用 <code>std::copy</code> 将 <code>source</code> 容器中的元素插入到 <code>destination</code> 容器的开头。最终输出结果为 <code>Destination list after insertion: 5 4 3 2 1</code>。</p>
<h2 id="C-std-inserter-详解"><a href="#C-std-inserter-详解" class="headerlink" title="C++  std::inserter 详解"></a>C++ <iterator> std::inserter 详解</h2><p><code>std::inserter</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的一个函数模板，用于创建一个插入迭代器，该迭代器允许在容器的任意位置插入元素。与 <code>std::back_inserter</code> 和 <code>std::front_inserter</code> 不同，<code>std::inserter</code> 允许指定插入位置。</p>
<p>这个函数模板的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Container, <span class="keyword">class</span> Iterator &gt;</span></span><br><span class="line"><span class="function">std::insert_iterator&lt;Container&gt; <span class="title">inserter</span><span class="params">( Container&amp; c, Iterator p )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Container</code> 是容器的类型。</li>
<li><code>Iterator</code> 是指定插入位置的迭代器。</li>
</ul>
<p><code>std::inserter</code> 返回一个 <code>std::insert_iterator</code> 对象，该对象可以通过 <code>operator++</code> 和 <code>operator*</code> 来在指定位置插入元素。</p>
<p>以下是一个简单的例子，演示了 <code>std::inserter</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 destination 中的迭代器指向第一个元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = destination.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::inserter 创建插入迭代器，指定插入位置为 it</span></span><br><span class="line">    std::insert_iterator&lt;std::set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">inserter</span>(destination, it);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::copy 将 source 中的元素插入到 destination 的指定位置</span></span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), inserter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destination set after insertion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : destination) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::inserter</code> 用于创建一个插入迭代器，指定插入位置为 <code>it</code>，然后使用 <code>std::copy</code> 将 <code>source</code> 容器中的元素插入到 <code>destination</code> 容器的指定位置。最终输出结果为 <code>Destination set after insertion: 1 2 3 4 5</code>。</p>
<h2 id="C-std-istream-iterator-详解"><a href="#C-std-istream-iterator-详解" class="headerlink" title="C++  std::istream_iterator 详解"></a>C++ <iterator> std::istream_iterator 详解</h2><p><code>std::istream_iterator</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的一个模板类，用于创建一个输入迭代器，该迭代器从输入流中读取数据。</p>
<p>这个模板类的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">CharT</span> = <span class="type">char</span>, <span class="keyword">class</span> Traits = std::char_traits&lt;CharT&gt;, <span class="keyword">class</span> Distance = std::<span class="type">ptrdiff_t</span> &gt;</span><br><span class="line"><span class="keyword">class</span> istream_iterator;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code> 是迭代器指向的元素类型。</li>
<li><code>CharT</code> 是字符类型，默认为 <code>char</code>。</li>
<li><code>Traits</code> 是字符特性，用于处理字符操作，默认为 <code>std::char_traits&lt;CharT&gt;</code>。</li>
<li><code>Distance</code> 是迭代器之间的距离类型，默认为 <code>std::ptrdiff_t</code>。</li>
</ul>
<p><code>std::istream_iterator</code> 的对象通过输入流（如 <code>std::cin</code>）进行初始化，并通过 <code>operator++</code> 和 <code>operator*</code> 来读取输入流中的数据。</p>
<p>以下是一个简单的例子，演示了 <code>std::istream_iterator</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::istream_iterator 从标准输入流读取整数</span></span><br><span class="line">    <span class="function">std::istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">it</span><span class="params">(std::cin)</span></span>;</span><br><span class="line">    std::istream_iterator&lt;<span class="type">int</span>&gt; end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::vector 存储从输入流读取的整数</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">numbers</span><span class="params">(it, end)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Numbers entered: &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::istream_iterator</code> 用于从标准输入流中读取整数，然后使用 <code>std::vector</code> 存储这些整数，最终输出结果为用户输入的整数序列。</p>
<h2 id="C-std-ostream-iterator-详解"><a href="#C-std-ostream-iterator-详解" class="headerlink" title="C++  std::ostream_iterator 详解"></a>C++ <iterator> std::ostream_iterator 详解</h2><p><code>std::ostream_iterator</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的一个模板类，用于创建一个输出迭代器，该迭代器将数据写入输出流。</p>
<p>这个模板类的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">CharT</span> = <span class="type">char</span>, <span class="keyword">class</span> Traits = std::char_traits&lt;CharT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> ostream_iterator;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code> 是迭代器指向的元素类型。</li>
<li><code>CharT</code> 是字符类型，默认为 <code>char</code>。</li>
<li><code>Traits</code> 是字符特性，用于处理字符操作，默认为 <code>std::char_traits&lt;CharT&gt;</code>。</li>
</ul>
<p><code>std::ostream_iterator</code> 的对象通过输出流（如 <code>std::cout</code>）进行初始化，并通过 <code>operator++</code> 和 <code>operator*</code> 来将数据写入输出流。</p>
<p>以下是一个简单的例子，演示了 <code>std::ostream_iterator</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::ostream_iterator 将整数输出到标准输出流</span></span><br><span class="line">    <span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">outputIterator</span><span class="params">(std::cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::copy 将 vector 中的整数写入到输出流</span></span><br><span class="line">    std::<span class="built_in">copy</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), outputIterator);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::ostream_iterator</code> 用于将整数输出到标准输出流，并通过 <code>std::copy</code> 将 <code>numbers</code> 容器中的整数写入到输出流。最终输出结果为 <code>1 2 3 4 5</code>。</p>
<h2 id="C-std-begin-函数-详解"><a href="#C-std-begin-函数-详解" class="headerlink" title="C++  std::begin()函数 详解"></a>C++ <iterator> std::begin()函数 详解</h2><p><code>std::begin()</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的一个函数模板，用于获取容器的起始迭代器。</p>
<p>这个函数模板的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Container &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">begin</span><span class="params">( <span class="type">const</span> Container&amp; cont )</span> -&gt; <span class="title">decltype</span><span class="params">(cont.begin())</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Container</code> 是容器类型。</li>
</ul>
<p><code>std::begin()</code> 接受一个容器作为参数，返回该容器的起始迭代器。它是用于支持范围迭代的标准库函数。</p>
<p>以下是一个简单的例子，演示了 <code>std::begin()</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::begin() 获取 vector 的起始迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">begin</span>(numbers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element of the vector: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::begin()</code> 用于获取 <code>numbers</code> 容器的起始迭代器，然后通过迭代器 <code>it</code> 输出 vector 的第一个元素。最终输出结果为 <code>First element of the vector: 1</code>。</p>
<h2 id="C-std-end-函数-详解"><a href="#C-std-end-函数-详解" class="headerlink" title="C++  std::end()函数 详解"></a>C++ <iterator> std::end()函数 详解</h2><p><code>std::end()</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的一个函数模板，用于获取容器的结束迭代器。</p>
<p>这个函数模板的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Container &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">end</span><span class="params">( <span class="type">const</span> Container&amp; cont )</span> -&gt; <span class="title">decltype</span><span class="params">(cont.end())</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Container</code> 是容器类型。</li>
</ul>
<p><code>std::end()</code> 接受一个容器作为参数，返回该容器的结束迭代器。它是用于支持范围迭代的标准库函数。</p>
<p>以下是一个简单的例子，演示了 <code>std::end()</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::end() 获取 vector 的结束迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">end</span>(numbers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Iterator pointing beyond the last element: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::end()</code> 用于获取 <code>numbers</code> 容器的结束迭代器，然后通过迭代器 <code>it</code> 输出 vector 结束位置的元素（由于 <code>it</code> 指向容器的结束位置，解引用操作是未定义行为，这里只是演示目的）。最终输出结果为 “Iterator pointing beyond the last element”。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_38_unordered_map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_38_unordered_map/" class="post-title-link" itemprop="url">C++_10_38_unordered_map</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>unordered_map 标准库</li>
</ul>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <unordered_map>标准库 详解</h2><p>在C++中，<code>&lt;unordered_map&gt;</code> 标准库提供了无序关联容器 <code>std::unordered_map</code>，它是一个键值对的容器，类似于有序关联容器 <code>std::map</code>，但 <code>std::unordered_map</code> 中的元素没有特定的顺序。它使用哈希表来实现快速的元素检索。</p>
<p>以下是一些 <code>std::unordered_map</code> 的重要特性和用法：</p>
<h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个std::unordered_map</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    myMap[<span class="number">1</span>] = <span class="string">&quot;One&quot;</span>;</span><br><span class="line">    myMap[<span class="number">2</span>] = <span class="string">&quot;Two&quot;</span>;</span><br><span class="line">    myMap[<span class="number">3</span>] = <span class="string">&quot;Three&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value for key 2: &quot;</span> &lt;&lt; myMap[<span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-插入和删除元素"><a href="#2-插入和删除元素" class="headerlink" title="2. 插入和删除元素"></a>2. 插入和删除元素</h3><p>使用 <code>insert</code> 函数可以插入元素，使用 <code>erase</code> 函数可以删除元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(&#123;<span class="number">4</span>, <span class="string">&quot;Four&quot;</span>&#125;);</span><br><span class="line">myMap[<span class="number">5</span>] = <span class="string">&quot;Five&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">myMap.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-查找元素"><a href="#3-查找元素" class="headerlink" title="3. 查找元素"></a>3. 查找元素</h3><p>使用 <code>find</code> 函数可以在 <code>std::unordered_map</code> 中查找元素，如果元素存在，返回指向该元素的迭代器，否则返回 <code>end()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element found: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-哈希函数和键比较"><a href="#4-哈希函数和键比较" class="headerlink" title="4. 哈希函数和键比较"></a>4. 哈希函数和键比较</h3><p>为了使用自定义类型作为键，你需要提供一个哈希函数和一个相等比较函数。这可以通过定义这两个函数或使用标准库中的 <code>std::hash</code> 和 <code>std::equal_to</code> 来完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyKey</span> &#123;</span><br><span class="line">    <span class="type">int</span> value1;</span><br><span class="line">    <span class="type">int</span> value2;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyKey&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (value1 == other.value1) &amp;&amp; (value2 == other.value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;MyKey&gt; &#123;</span><br><span class="line">        <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> MyKey&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 自定义哈希函数</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(key.value1) ^ std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(key.value2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;MyKey, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    MyKey key1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    myMap[key1] = <span class="string">&quot;Value&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码演示了如何定义自己的哈希函数和相等比较函数，以便将自定义类型 <code>MyKey</code> 用作 <code>std::unordered_map</code> 的键。</p>
<p>总的来说，<code>std::unordered_map</code> 提供了一个快速的无序关联容器，适用于需要高效查找和插入元素的场景。注意，与有序关联容器相比，无序关联容器不会维护元素的特定顺序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_3_vector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_3_vector/" class="post-title-link" itemprop="url">C++_10_3_vector</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><vector>标准库相关笔记</li>
</ul>
<h2 id="C-std-vector和C风格数据互相转换"><a href="#C-std-vector和C风格数据互相转换" class="headerlink" title="C++ std::vector和C风格数据互相转换"></a>C++ std::vector和C风格数据互相转换</h2><p>在C++中，<code>std::vector</code> 是一个动态数组，而C风格的数据通常是指使用指针和数组来管理数据。在实际开发中，有时需要在 <code>std::vector</code> 和 C 风格数组之间进行互相转换。下面是具体的转换方式：</p>
<h3 id="1-从-C-风格数组转换为-std-vector"><a href="#1-从-C-风格数组转换为-std-vector" class="headerlink" title="1. 从 C 风格数组转换为 std::vector"></a>1. 从 C 风格数组转换为 <code>std::vector</code></h3><p>假设有一个C风格的数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c_array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>要将它转换为 <code>std::vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(std::begin(c_array), std::end(c_array))</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>使用 <code>std::begin()</code> 和 <code>std::end()</code> 来获取数组的首尾指针（或使用 <code>&amp;c_array[0]</code> 和 <code>&amp;c_array[size]</code>）。</li>
<li>如果知道数组的长度，你可以直接指定长度：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(c_array, c_array + size)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-从-std-vector-转换为-C-风格数组"><a href="#2-从-std-vector-转换为-C-风格数组" class="headerlink" title="2. 从 std::vector 转换为 C 风格数组"></a>2. 从 <code>std::vector</code> 转换为 C 风格数组</h3><p>假设有一个 <code>std::vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>要将其转换为 C 风格的数组，你可以获取 <code>vector</code> 的内部数据指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* c_array = vec.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>vec.data()</code> 返回一个指向 <code>std::vector</code> 内部存储数据的指针，该数据是连续的，与C风格数组类似。</li>
<li>注意：不要手动释放这个指针，因为它是由 <code>std::vector</code> 管理的。</li>
</ul>
<h3 id="3-完整示例"><a href="#3-完整示例" class="headerlink" title="3. 完整示例"></a>3. 完整示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从C风格数组转换为std::vector</span></span><br><span class="line">    <span class="type">int</span> c_array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(std::begin(c_array), std::end(c_array))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出std::vector的内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从std::vector转换为C风格数组</span></span><br><span class="line">    <span class="type">int</span>* c_array_from_vec = vec.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出C风格数组的内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;C array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; c_array_from_vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>当从 <code>std::vector</code> 获取到 C 风格的指针时，不要手动释放内存，因为 <code>std::vector</code> 会自动管理其内存。</li>
<li>从 C 风格数组转换为 <code>std::vector</code> 时，尽量使用 <code>std::begin()</code> 和 <code>std::end()</code> 来避免出错。</li>
</ul>
<p>通过这些方法，你可以轻松地在C++的 <code>std::vector</code> 和C风格数据之间进行转换。</p>
<h2 id="vector-内存分配方案"><a href="#vector-内存分配方案" class="headerlink" title="vector 内存分配方案"></a>vector 内存分配方案</h2><ul>
<li>vector会自动分配内存来保存插入的元素。vector要求必须放在连续的内存中。由于不可能请求在当前的内存块的尾部添加内存，因此每次vector申请更多内存时，都一定要在另一个位置分配一块新的，更大的内存块，然后将所有元素复制&#x2F;移动到新的内存块。</li>
<li>这个过程非常耗时，因此vector的实现在执行重分配时，会分配此次所需内存更多的内存，以尽量避免这个复制转移的过程。通过这种方式，vector可避免在每次插入元素时都重新重新分配内存。</li>
</ul>
<h2 id="C-标准库是什么"><a href="#C-标准库是什么" class="headerlink" title="C++ 标准库是什么"></a>C++ <vector>标准库是什么</h2><p><code>&lt;vector&gt;</code> 是 C++ 标准库提供的头文件之一，用于包含 C++ 标准库中的向量（<code>vector</code>）容器类的定义。向量是一个动态数组，它能够以连续的内存空间存储元素，并提供了灵活的大小调整和高效的随机访问。</p>
<p><code>std::vector</code> 是一个模板类，可以存储任意类型的元素，并具有以下特性：</p>
<ol>
<li><strong>动态大小：</strong> 向量可以根据需要动态增长或缩小其大小，可以通过 <code>push_back</code>、<code>pop_back</code> 等方法在尾部添加或删除元素。</li>
<li><strong>随机访问：</strong> 支持通过索引快速访问和修改元素，时间复杂度为 O(1)。</li>
<li><strong>连续内存存储：</strong> 向量的元素在内存中是连续存储的，这有助于提高数据的访问速度。</li>
<li><strong>尾部插入和删除的高效性：</strong> 在尾部插入或删除元素的操作通常是高效的，时间复杂度为平摊 O(1)。</li>
</ol>
<p>以下是一个简单的示例，演示了如何使用 <code>&lt;vector&gt;</code> 头文件中的 <code>std::vector</code> 类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个整数向量</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在向量尾部添加元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历输出向量中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector Elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;vector&gt;</code> 头文件中的 <code>std::vector</code> 类是 C++ 中常用的标准容器之一，它提供了方便的动态数组功能，并且在许多情况下都是一种方便且高效的数据结构选择。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <vector>标准库 详解</h2><p><code>&lt;vector&gt;</code> 是 C++ 标准库提供的头文件之一，包含了 <code>std::vector</code> 类的定义，这是 C++ 中最常用的容器之一。</p>
<h3 id="std-vector-类"><a href="#std-vector-类" class="headerlink" title="std::vector 类"></a><code>std::vector</code> 类</h3><p><code>std::vector</code> 是一个动态数组，它能够存储一系列同类型的元素，并且可以动态地调整其大小。以下是 <code>std::vector</code> 类的一些重要特性和函数：</p>
<ol>
<li><p><strong>动态大小：</strong> 向量的大小可以根据需要动态增长或缩小。通过 <code>push_back()</code> 在尾部添加元素、<code>pop_back()</code> 删除尾部元素，或者直接使用 <code>resize()</code> 调整大小。</p>
</li>
<li><p><strong>随机访问：</strong> 可以通过索引快速访问和修改向量中的元素，支持使用 <code>operator[]</code> 实现随机访问。</p>
</li>
<li><p><strong>连续内存存储：</strong> 向量中的元素在内存中是连续存储的，因此支持高效的随机访问，并且迭代器可用于遍历元素。</p>
</li>
<li><p><strong>内存管理：</strong> 向量会自动处理内存的分配和释放，使得在尾部插入或删除元素的操作通常是高效的。</p>
</li>
<li><p><strong>元素访问：</strong> 提供了 <code>at()</code> 方法和 <code>operator[]</code>，<code>front()</code> 和 <code>back()</code> 方法用于访问首尾元素。</p>
</li>
<li><p><strong>迭代器支持：</strong> 支持使用迭代器进行遍历，如 <code>begin()</code> 和 <code>end()</code> 返回的迭代器用于遍历容器元素。</p>
</li>
<li><p><strong>其他方法：</strong> 包括 <code>empty()</code>、<code>size()</code>、<code>clear()</code>、<code>erase()</code> 等方法用于检查空、获取大小、清空内容和删除元素等。</p>
</li>
</ol>
<p>下面是一个简单示例，展示了如何使用 <code>&lt;vector&gt;</code> 中的 <code>std::vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个整数向量并初始化</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在向量尾部添加元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历输出向量中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector Elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;vector&gt;</code> 头文件提供了 <code>std::vector</code> 类，它是一个常用的容器，能够满足动态数组的需求，支持高效的元素访问、插入和删除操作，是 C++ 中非常实用的数据结构之一。</p>
<h2 id="C-标准库中-std-vector模板类详解"><a href="#C-标准库中-std-vector模板类详解" class="headerlink" title="C++ 标准库中 std::vector模板类详解"></a>C++ <vector>标准库中 std::vector模板类详解</h2><p><code>std::vector</code> 是 C++ 标准库提供的动态数组容器，属于序列容器的一种。它以连续的内存空间存储元素，并支持动态增长和收缩。以下是 <code>std::vector</code> 的一些重要特性和使用方法：</p>
<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ol>
<li><p><strong>动态大小：</strong> <code>std::vector</code> 允许在运行时根据需要动态地增加或减少其大小。通过 <code>push_back()</code> 在尾部添加元素，<code>pop_back()</code> 删除尾部元素，或者直接使用 <code>resize()</code> 调整大小。</p>
</li>
<li><p><strong>随机访问：</strong> 可以通过索引快速访问和修改向量中的元素。支持使用 <code>operator[]</code> 实现随机访问，其时间复杂度为 O(1)。</p>
</li>
<li><p><strong>连续内存存储：</strong> 向量的元素在内存中是连续存储的，这有助于提高数据的访问速度，并且迭代器可用于遍历元素。</p>
</li>
<li><p><strong>尾部插入和删除的高效性：</strong> 在尾部插入或删除元素的操作通常是高效的，时间复杂度为平摊 O(1)。</p>
</li>
<li><p><strong>迭代器支持：</strong> 提供了迭代器，如 <code>begin()</code> 和 <code>end()</code> 返回的迭代器用于遍历容器元素。</p>
</li>
<li><p><strong>元素访问：</strong> 可以使用 <code>at()</code> 方法、<code>operator[]</code>、<code>front()</code> 和 <code>back()</code> 方法来访问元素。</p>
</li>
<li><p><strong>其他方法：</strong> 包括 <code>empty()</code>、<code>size()</code>、<code>clear()</code>、<code>erase()</code> 等方法，用于检查空、获取大小、清空内容和删除元素等。</p>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个整数向量并初始化</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在向量尾部添加元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历输出向量中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector Elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码演示了 <code>std::vector</code> 的一些常见操作，包括初始化、在尾部添加元素、迭代器遍历输出元素等。<code>std::vector</code> 是 C++ 标准库中常用的容器之一，提供了便捷且高效的动态数组功能。</p>
<h2 id="C-标准库中-std-vector模板类所有成员函数"><a href="#C-标准库中-std-vector模板类所有成员函数" class="headerlink" title="C++ 标准库中 std::vector模板类所有成员函数"></a>C++ <vector>标准库中 std::vector模板类所有成员函数</h2><p><code>std::vector</code> 类是 C++ 标准库中的动态数组容器，提供了许多成员函数用于管理其内部的元素。以下是 <code>std::vector</code> 类的一些主要成员函数：</p>
<h3 id="容量相关操作："><a href="#容量相关操作：" class="headerlink" title="容量相关操作："></a>容量相关操作：</h3><ul>
<li><strong><code>size()</code>：</strong> 返回向量中元素的个数。</li>
<li><strong><code>capacity()</code>：</strong> 返回当前向量的容量（即分配的内存大小）。</li>
<li><strong><code>empty()</code>：</strong> 检查向量是否为空。</li>
<li><strong><code>reserve(size_type new_cap)</code>：</strong> 尝试预分配足够的内存以存储指定数量的元素。</li>
</ul>
<h3 id="访问元素操作："><a href="#访问元素操作：" class="headerlink" title="访问元素操作："></a>访问元素操作：</h3><ul>
<li><strong><code>operator[]</code>：</strong> 通过索引访问向量中的元素。</li>
<li><strong><code>at(size_type pos)</code>：</strong> 通过索引访问向量中的元素，提供了边界检查。</li>
<li><strong><code>front()</code>：</strong> 返回向量中第一个元素的引用。</li>
<li><strong><code>back()</code>：</strong> 返回向量中最后一个元素的引用。</li>
<li><strong><code>data()</code>：</strong> 返回指向向量内部数组的指针。</li>
</ul>
<h3 id="修改容器内容操作："><a href="#修改容器内容操作：" class="headerlink" title="修改容器内容操作："></a>修改容器内容操作：</h3><ul>
<li><strong><code>push_back(const T&amp; value)</code>：</strong> 在向量尾部添加一个元素。</li>
<li><strong><code>pop_back()</code>：</strong> 删除向量中最后一个元素。</li>
<li><strong><code>insert(iterator pos, const T&amp; value)</code>：</strong> 在指定位置插入一个元素。</li>
<li><strong><code>erase(iterator pos)</code>：</strong> 删除指定位置的元素。</li>
<li><strong><code>clear()</code>：</strong> 删除向量中的所有元素。</li>
</ul>
<h3 id="其他操作："><a href="#其他操作：" class="headerlink" title="其他操作："></a>其他操作：</h3><ul>
<li><strong><code>swap(vector&amp; other)</code>：</strong> 交换两个向量的内容。</li>
<li><strong><code>assign(count, value)</code>：</strong> 用新值替换向量的内容。</li>
<li><strong><code>resize(size_type new_size)</code>：</strong> 改变向量的大小。</li>
<li><strong><code>shrink_to_fit()</code>：</strong> 要求释放多余的容量。</li>
</ul>
<p>此外，<code>std::vector</code> 还具有迭代器相关的成员函数，如 <code>begin()</code>、<code>end()</code> 用于迭代访问容器的元素。以上列出的成员函数并非全部，但是是 <code>std::vector</code> 常用的一些成员函数，能够对向量的大小、容量、元素访问和修改等进行有效管理。</p>
<h2 id="C-std-vector-swap-函数-详解"><a href="#C-std-vector-swap-函数-详解" class="headerlink" title="C++ std::vector::swap() 函数 详解"></a>C++ std::vector::swap() 函数 详解</h2><p><code>std::vector::swap()</code> 是 C++ 标准库中 <code>std::vector</code> 类的成员函数，用于交换两个 vector 的内容，即交换它们所包含的元素。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(std::vector&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>x</code>：另一个 <code>std::vector</code> 对象，其内容将与调用该函数的 vector 对象进行交换。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>std::vector::swap()</code> 函数用于交换两个 vector 对象的元素内容，使得调用该函数的 vector 与参数 <code>x</code> 所包含的元素互换。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector 1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector 2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec2) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    vec<span class="number">1.</span><span class="built_in">swap</span>(vec2); <span class="comment">// 交换两个 vector 的内容</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAfter Swap:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector 1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector 2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec2) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>std::vector::swap()</code> 函数非常高效，因为它只是交换了两个 vector 内部的数据结构指针，而不是复制每个元素。</li>
<li>交换后，两个 vector 对象的大小和容量可能会发生变化，但其所包含的元素会完全交换。</li>
<li>该函数是 <code>std::vector</code> 类的成员函数，所以需要使用一个已经存在的 vector 对象来调用该函数。</li>
</ul>
<p><code>std::vector::swap()</code> 是一个很有用的函数，特别是在需要交换两个 vector 的元素内容时，可以避免进行元素的逐个复制。</p>
<h2 id="std-vector-size"><a href="#std-vector-size" class="headerlink" title="std::vector::size()"></a>std::vector::size()</h2><p><code>std::vector::size()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于返回 <code>std::vector</code> 容器中当前存储元素的数量（大小）。</p>
<p>在 C++ 中，<code>std::vector</code> 是一个动态数组，它能够自动调整大小，可以根据需要动态地增加或减少存储在其中的元素数量。<code>size()</code> 函数返回的是当前 <code>std::vector</code> 中的元素数量，即容器中元素的个数。</p>
<p>下面是一个简单的示例演示了如何使用 <code>std::vector::size()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 std::vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向容器中添加一些元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中元素的数量（大小）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector的大小为：&quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>push_back</code> 方法向容器中添加了三个整数元素。</li>
<li>通过 <code>vec.size()</code> 获取了 <code>vec</code> 容器中元素的数量，并将结果打印出来。</li>
</ul>
<p><code>std::vector::size()</code> 对于获取 <code>std::vector</code> 中元素数量非常方便，它可以帮助你确定容器中元素的个数，从而进行后续的操作或逻辑处理。</p>
<h2 id="std-vector-capacity"><a href="#std-vector-capacity" class="headerlink" title="std::vector::capacity()"></a>std::vector::capacity()</h2><p><code>std::vector::capacity()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于返回当前 <code>std::vector</code> 容器的容量大小。</p>
<p>在 C++ 中，<code>std::vector</code> 是一个动态数组，它能够自动调整大小，可以根据需要动态地增加或减少存储在其中的元素数量。<code>capacity()</code> 函数返回的是当前 <code>std::vector</code> 内部所分配内存空间的大小，即该容器在不分配新的内存的情况下能够容纳的元素数量。</p>
<p>下面是一个简单的示例演示了如何使用 <code>std::vector::capacity()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 std::vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向容器中添加一些元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; Capacity: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>push_back</code> 方法向容器中循环添加了十个整数元素，并在每次添加后打印了当前容器的大小和容量。</li>
</ul>
<p><code>std::vector::capacity()</code> 是一个重要的函数，它可以用来观察 <code>std::vector</code> 容器当前的内存分配情况。当 <code>std::vector</code> 中的元素数量超过当前分配的容量时，<code>std::vector</code> 会自动重新分配更大的内存空间以容纳更多的元素，这个过程可能会导致容器大小和容量之间的不同步。</p>
<h2 id="std-vector-empty"><a href="#std-vector-empty" class="headerlink" title="std::vector::empty()"></a>std::vector::empty()</h2><p><code>std::vector::empty()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于检查 <code>std::vector</code> 容器是否为空。</p>
<p>当 <code>std::vector</code> 容器中不含有任何元素时，即容器的大小为零时，<code>empty()</code> 函数将返回 <code>true</code>；否则，如果容器中包含至少一个元素，则返回 <code>false</code>。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::empty()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 std::vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;容器为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;容器不为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向容器中添加一个元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;容器为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;容器不为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>vec.empty()</code> 检查容器是否为空，并根据返回结果打印相应的消息。</li>
<li>使用 <code>push_back</code> 方法向容器中添加了一个整数元素。</li>
<li>再次使用 <code>vec.empty()</code> 检查容器是否为空，并根据返回结果打印相应的消息。</li>
</ul>
<p><code>std::vector::empty()</code> 是一个简单而常用的函数，用于确定 <code>std::vector</code> 容器是否为空，可以在需要检查容器是否含有元素时使用。</p>
<h2 id="std-vector-reserve"><a href="#std-vector-reserve" class="headerlink" title="std::vector::reserve()"></a>std::vector::reserve()</h2><p><code>std::vector::reserve()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于预留 <code>std::vector</code> 容器的存储空间，但不会改变容器中元素的数量。</p>
<p>当你预先知道 <code>std::vector</code> 将要存储大量元素时，可以使用 <code>reserve()</code> 函数来预留足够的内存空间，避免多次重新分配内存，从而提高程序的性能。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::reserve()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 std::vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器当前的大小和容量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前大小: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; 当前容量: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预留容器存储空间为 10 个元素</span></span><br><span class="line">    vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印预留后的容器当前的大小和容量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;预留后大小: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; 预留后容量: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>vec.reserve(10)</code> 预留了容器的存储空间为 10 个元素。</li>
<li>打印了预留前后容器的大小和容量。</li>
</ul>
<p>需要注意的是，<code>reserve()</code> 函数只是预留了足够的存储空间，并没有改变容器的实际大小，容器的大小仍然是 0。容器的大小由实际插入的元素个数决定，而容器的容量则是实际分配的内存大小，<code>reserve()</code> 仅仅是为容器预留了更多的内存空间，以备将来的使用。</p>
<p>这个函数通常在你已经知道将要存储大量元素的情况下使用，以减少因重新分配内存而引起的开销。</p>
<h2 id="std-vector-at"><a href="#std-vector-at" class="headerlink" title="std::vector::at()"></a>std::vector::at()</h2><p><code>std::vector::at()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于访问 <code>std::vector</code> 容器中指定位置的元素，并提供了边界检查。</p>
<p>与 <code>operator[]</code> 不同，<code>at()</code> 函数在访问容器元素时提供了边界检查，如果指定的位置超出了容器的范围，则会抛出 <code>std::out_of_range</code> 异常。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::at()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 at() 访问容器中的元素</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素 at(2): &quot;</span> &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 访问索引为 2 的元素</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素 at(5): &quot;</span> &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 尝试访问超出范围的索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; ex) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;发生异常: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; std::endl; <span class="comment">// 捕获并打印 out_of_range 异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.at(2)</code> 获取了索引为 2 的元素值，并正常打印出来。</li>
<li>然后尝试使用 <code>vec.at(5)</code> 访问超出容器范围的索引，这会导致 <code>std::out_of_range</code> 异常被抛出，并被 <code>catch</code> 语句捕获并处理。</li>
</ul>
<p>总的来说，<code>std::vector::at()</code> 是一个安全的访问元素的方法，可以在需要对访问进行边界检查的情况下使用，以防止意外访问超出容器范围的索引位置。</p>
<h2 id="std-vector-front"><a href="#std-vector-front" class="headerlink" title="std::vector::front()"></a>std::vector::front()</h2><p><code>std::vector::front()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于返回 <code>std::vector</code> 容器中第一个元素的引用。</p>
<p>它提供了对 <code>std::vector</code> 容器中第一个元素的访问，类似于数组的第一个元素。如果 <code>std::vector</code> 容器为空，则调用 <code>front()</code> 函数将会导致未定义行为。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::front()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问容器中的第一个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素是: &quot;</span> &lt;&lt; vec.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.front()</code> 获取了容器中的第一个元素值，并将其打印出来。</li>
</ul>
<p>需要注意的是，调用 <code>std::vector::front()</code> 函数时，应确保 <code>std::vector</code> 容器不为空，否则在空容器上调用 <code>front()</code> 将导致未定义行为。因此，在调用 <code>front()</code> 函数之前，最好先检查 <code>std::vector</code> 是否包含元素，可以通过 <code>empty()</code> 函数进行检查。</p>
<h2 id="std-vector-back"><a href="#std-vector-back" class="headerlink" title="std::vector::back()"></a>std::vector::back()</h2><p><code>std::vector::back()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于返回 <code>std::vector</code> 容器中最后一个元素的引用。</p>
<p>它提供了对 <code>std::vector</code> 容器中最后一个元素的访问。如果 <code>std::vector</code> 容器为空，则调用 <code>back()</code> 函数将会导致未定义行为。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::back()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问容器中的最后一个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最后一个元素是: &quot;</span> &lt;&lt; vec.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.back()</code> 获取了容器中的最后一个元素值，并将其打印出来。</li>
</ul>
<p>需要注意的是，调用 <code>std::vector::back()</code> 函数时，应确保 <code>std::vector</code> 容器不为空，否则在空容器上调用 <code>back()</code> 将导致未定义行为。因此，在调用 <code>back()</code> 函数之前，最好先检查 <code>std::vector</code> 是否包含元素，可以通过 <code>empty()</code> 函数进行检查。</p>
<h2 id="std-vector-data"><a href="#std-vector-data" class="headerlink" title="std::vector::data()"></a>std::vector::data()</h2><p><code>std::vector::data()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于返回指向 <code>std::vector</code> 容器内部存储元素的指针。</p>
<p>这个函数返回一个指向 <code>std::vector</code> 内部数据存储区的指针，该指针可以用于直接访问容器中的元素。如果 <code>std::vector</code> 容器为空，则返回的指针可能为空指针。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::data()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指向容器数据的指针</span></span><br><span class="line">    <span class="type">int</span>* ptr = vec.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印指针指向的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素是: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.data()</code> 获取了指向容器数据存储区的指针，并将其赋值给 <code>ptr</code>。</li>
<li>打印了指针所指向的第一个元素的值。</li>
</ul>
<p>需要注意的是，<code>std::vector::data()</code> 返回的指针可以用于直接访问容器中的元素，但在修改容器中的元素时应格外小心，确保不会越界或者引起其它未定义的行为。此外，如果 <code>std::vector</code> 容器为空，则返回的指针可能为 <code>nullptr</code>。</p>
<h2 id="std-vector-push-back"><a href="#std-vector-push-back" class="headerlink" title="std::vector::push_back()"></a>std::vector::push_back()</h2><p><code>std::vector::push_back()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于在 <code>std::vector</code> 容器的末尾添加一个新的元素。</p>
<p>这个函数将新的元素添加到 <code>std::vector</code> 容器的末尾，并使容器的大小增加 1。如果 <code>std::vector</code> 的容量不足以容纳新元素，则会自动重新分配更大的内存空间以适应新的元素。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::push_back()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 std::vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向容器中添加一些元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>push_back()</code> 方法向容器中分别添加了三个整数元素。</li>
<li>使用循环遍历容器中的元素，并将它们打印出来。</li>
</ul>
<p><code>std::vector::push_back()</code> 是一个常用的函数，用于向 <code>std::vector</code> 容器的末尾添加新的元素，非常方便实用。</p>
<h2 id="std-vector-pop-back"><a href="#std-vector-pop-back" class="headerlink" title="std::vector::pop_back()"></a>std::vector::pop_back()</h2><p><code>std::vector::pop_back()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于移除 <code>std::vector</code> 容器中的最后一个元素。</p>
<p>该函数会将 <code>std::vector</code> 容器中最后一个元素移除，并且减少容器的大小（size）1。如果 <code>std::vector</code> 容器为空，则调用 <code>pop_back()</code> 函数将导致未定义行为。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::pop_back()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除容器中的最后一个元素</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;移除后的容器中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.pop_back()</code> 移除了容器中的最后一个元素。</li>
<li>使用循环遍历容器中的元素，并将它们打印出来。</li>
</ul>
<p>需要注意的是，调用 <code>std::vector::pop_back()</code> 之前最好检查容器是否为空，以避免在空容器上调用该函数而导致的未定义行为。这个函数通常用于从 <code>std::vector</code> 容器的末尾删除元素，可以方便地实现栈（stack）等数据结构的功能。</p>
<h2 id="std-vector-insert"><a href="#std-vector-insert" class="headerlink" title="std::vector::insert()"></a>std::vector::insert()</h2><p><code>std::vector::insert()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于在指定位置插入一个或多个元素到 <code>std::vector</code> 容器中。</p>
<p>这个函数允许在指定位置插入一个元素或一组元素。插入操作可能会导致所有在指定位置之后的元素被移动，因为 <code>std::vector</code> 是一个连续存储的容器。</p>
<p>下面是 <code>std::vector::insert()</code> 函数的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(iterator position, <span class="type">const</span> T&amp; val)</span></span>; <span class="comment">// 在 position 位置插入 val</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(iterator position, size_type n, <span class="type">const</span> T&amp; val)</span></span>; <span class="comment">// 在 position 位置插入 n 个 val</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(iterator position, InputIterator first, InputIterator last)</span></span>; <span class="comment">// 在 position 位置插入区间 [first, last) 内的元素</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>position</code> 参数是一个迭代器，指示了插入元素的位置。<code>val</code> 是要插入的元素值，<code>n</code> 是要插入的元素数量，<code>first</code> 和 <code>last</code> 是表示要插入的元素范围的迭代器。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::insert()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在容器的第二个位置插入一个元素 25</span></span><br><span class="line">    <span class="keyword">auto</span> it = vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在容器的末尾插入两个元素，值分别为 40 和 50</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">end</span>(), &#123;<span class="number">40</span>, <span class="number">50</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.insert(vec.begin() + 1, 25)</code> 在容器的第二个位置插入了一个值为 25 的元素。</li>
<li>使用 <code>vec.insert(vec.end(), &#123;40, 50&#125;)</code> 在容器的末尾插入了两个值为 40 和 50 的元素。</li>
<li>使用循环遍历容器中的元素，并将它们打印出来。</li>
</ul>
<p><code>std::vector::insert()</code> 函数允许在 <code>std::vector</code> 容器的指定位置插入一个或多个元素，提供了灵活且方便的插入操作。</p>
<h2 id="std-vector-erase"><a href="#std-vector-erase" class="headerlink" title="std::vector::erase()"></a>std::vector::erase()</h2><p><code>std::vector::erase()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于从 <code>std::vector</code> 容器中移除一个或一段元素。</p>
<p>这个函数有多种用法，它可以删除单个元素，也可以删除一个范围内的元素。删除操作可能会导致被移除元素后面的元素向前移动，因为 <code>std::vector</code> 是一个连续存储的容器。</p>
<p>下面是 <code>std::vector::erase()</code> 函数的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator position)</span></span>; <span class="comment">// 移除指定位置的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator first, iterator last)</span></span>; <span class="comment">// 移除位于 [first, last) 区间的元素</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>position</code> 是要移除的元素的位置的迭代器，<code>first</code> 和 <code>last</code> 表示一个范围，用来移除这个范围内的所有元素。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::erase()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除容器中的第二个元素</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除容器中的第三个到第四个元素（迭代器范围 [vec.begin() + 2, vec.begin() + 4)）</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">2</span>, vec.<span class="built_in">begin</span>() + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.erase(vec.begin() + 1)</code> 移除了容器中的第二个元素。</li>
<li>使用 <code>vec.erase(vec.begin() + 2, vec.begin() + 4)</code> 移除了容器中的第三个到第四个元素。</li>
<li>使用循环遍历容器中的元素，并将它们打印出来。</li>
</ul>
<p><code>std::vector::erase()</code> 函数允许从 <code>std::vector</code> 容器中移除指定位置或指定范围内的元素，提供了便捷的删除操作。</p>
<h2 id="std-vector-clear"><a href="#std-vector-clear" class="headerlink" title="std::vector::clear()"></a>std::vector::clear()</h2><p><code>std::vector::clear()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于清空 <code>std::vector</code> 容器中的所有元素。</p>
<p>当调用 <code>clear()</code> 函数时，<code>std::vector</code> 容器的大小变为零，即移除了容器中的所有元素。容器的内存空间不会被释放，但容器中的元素数量将变为零，即容器会变为空。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::clear()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印清空前容器中的元素数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;清空前容器的大小: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空容器</span></span><br><span class="line">    vec.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印清空后容器中的元素数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;清空后容器的大小: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.size()</code> 打印了清空前容器中的元素数量。</li>
<li>使用 <code>vec.clear()</code> 清空了容器中的所有元素。</li>
<li>再次使用 <code>vec.size()</code> 打印了清空后容器中的元素数量，这时应该为 0。</li>
</ul>
<p><code>std::vector::clear()</code> 函数是一种快速清空 <code>std::vector</code> 容器中的元素的方法，但并不释放容器的内存空间，仅将容器的大小设置为零，使得容器变为空。</p>
<h2 id="std-vector-swap"><a href="#std-vector-swap" class="headerlink" title="std::vector::swap()"></a>std::vector::swap()</h2><p><code>std::vector::swap()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于交换两个 <code>std::vector</code> 容器的内容。</p>
<p>这个函数接受另一个 <code>std::vector</code> 容器作为参数，并将调用它的容器和传入的容器进行内容交换。交换操作将使得两个容器中的元素互相交换，但它们的内存空间不会发生改变。</p>
<p>以下是 <code>std::vector::swap()</code> 函数的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&amp; other)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>other</code> 是另一个 <code>std::vector</code> 容器，它的内容将与调用函数的容器进行交换。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::swap()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个 std::vector 容器，并分别向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印交换前两个容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交换前 vec1 中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交换前 vec2 中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec2) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 swap() 函数交换两个容器的内容</span></span><br><span class="line">    vec<span class="number">1.</span><span class="built_in">swap</span>(vec2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印交换后两个容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交换后 vec1 中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交换后 vec2 中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec2) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了两个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec1</code> 和 <code>vec2</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec1.swap(vec2)</code> 对两个容器的内容进行了交换。</li>
<li>分别打印了交换前后两个容器中的元素。</li>
</ul>
<p><code>std::vector::swap()</code> 函数提供了一种快速交换两个 <code>std::vector</code> 容器内容的方法，不需要复制元素，只需交换指针。这对于需要在两个容器间交换数据时非常有用。</p>
<h2 id="std-vector-assign"><a href="#std-vector-assign" class="headerlink" title="std::vector::assign()"></a>std::vector::assign()</h2><p><code>std::vector::assign()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于重新分配 <code>std::vector</code> 容器的内容。</p>
<p>这个函数可以使用多种方式重新设置 <code>std::vector</code> 容器的内容：可以用新值替换已有的内容，也可以设置容器中的元素数量，或者使用一个范围内的值替换容器中的元素。</p>
<p>以下是 <code>std::vector::assign()</code> 函数的不同形式及其基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(size_type count, <span class="type">const</span> T&amp; value)</span></span>; <span class="comment">// 设置容器中元素的数量为 count，并用 value 值替换所有元素 (1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(InputIterator first, InputIterator last)</span></span>; <span class="comment">// 使用区间 [first, last) 内的元素替换容器的内容 (2)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(std::initializer_list&lt;T&gt; il)</span></span>; <span class="comment">// 使用初始化列表 il 内的元素替换容器的内容 (3)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数</p>
<ul>
<li>count - 容器的新大小</li>
<li>value - 用以初始化容器元素的值</li>
<li>first, last - 复制来源元素的范围</li>
<li>ilist - 复制值来源的initializer_list</li>
</ul>
</li>
<li><p>复杂度</p>
<ul>
<li>1 与count呈线性</li>
<li>2 与first和last间的距离呈线性</li>
<li>3 与il.size()呈线性</li>
</ul>
</li>
</ul>
<p>这里的 <code>count</code> 表示新的元素数量，<code>value</code> 是要赋给新元素的值。<code>first</code> 和 <code>last</code> 是迭代器，表示一个范围，用来替换容器的内容。<code>il</code> 是一个初始化列表，用来替换容器的内容。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::assign()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; characters;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> print_list = [&amp;]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : characters)</span><br><span class="line">            std::cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    characters.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">print_list</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">const</span> std::string <span class="title">extra</span><span class="params">(<span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>)</span></span>;</span><br><span class="line">    characters.<span class="built_in">assign</span>(extra.<span class="built_in">begin</span>(), extra.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print_list</span>();</span><br><span class="line"> </span><br><span class="line">    characters.<span class="built_in">assign</span>(&#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;);</span><br><span class="line">    <span class="built_in">print_list</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>vec.assign(5, 10)</code> 设置容器中的元素数量为 5，并用值 10 替换了所有元素。</li>
<li>使用循环遍历容器中的元素，并将它们打印出来。</li>
</ul>
<p><code>std::vector::assign()</code> 函数提供了多种方式来重新设置 <code>std::vector</code> 容器的内容，使得容器可以被不同类型的数据重新填充。</p>
<h2 id="std-vector-resize"><a href="#std-vector-resize" class="headerlink" title="std::vector::resize()"></a>std::vector::resize()</h2><p><code>std::vector::resize()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于改变 <code>std::vector</code> 容器中的元素数量。</p>
<p>这个函数允许你改变 <code>std::vector</code> 容器中元素的数量。如果新的大小比当前大小大，将会增加元素数量并用默认构造函数的值初始化新的元素。如果新的大小比当前大小小，将会删除超出新大小的元素。</p>
<p>以下是 <code>std::vector::resize()</code> 函数的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type count)</span></span>; <span class="comment">// 设置容器中的元素数量为 count</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type count, <span class="type">const</span> value_type&amp; value)</span></span>; <span class="comment">// 设置容器中的元素数量为 count，并用 value 值初始化新元素</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>count</code> 是指定的新的元素数量，<code>value</code> 是可选的值，用于初始化新添加的元素。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::resize()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 std::vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 resize() 设置容器中的元素数量为 5</span></span><br><span class="line">    vec.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 resize() 设置容器中的元素数量为 8，并用值 100 初始化新添加的元素</span></span><br><span class="line">    vec.<span class="built_in">resize</span>(<span class="number">8</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次打印容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;调整大小后的容器中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>vec.resize(5)</code> 设置容器中的元素数量为 5，默认使用默认构造函数进行初始化。</li>
<li>使用 <code>vec.resize(8, 100)</code> 将容器中的元素数量增加到 8，并用值 100 初始化新添加的元素。</li>
<li>分别使用循环遍历容器中的元素，并将它们打印出来。</li>
</ul>
<p><code>std::vector::resize()</code> 函数允许你在运行时动态调整 <code>std::vector</code> 容器的大小，并可以选择性地使用特定的值初始化新添加的元素。</p>
<h2 id="std-vector-shrink-to-fit"><a href="#std-vector-shrink-to-fit" class="headerlink" title="std::vector::shrink_to_fit()"></a>std::vector::shrink_to_fit()</h2><p><code>std::vector::shrink_to_fit()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于要求 <code>std::vector</code> 容器减小其容量，使其容量和大小相匹配。</p>
<p><code>std::vector</code> 容器会根据需要分配更多的内存空间以容纳新的元素。然而，当一些元素被删除后，<code>std::vector</code> 容器的实际大小可能小于其容量。<code>shrink_to_fit()</code> 函数就是用来释放容器多余的内存空间，将容器的容量减小到与其大小相匹配。</p>
<p>以下是 <code>std::vector::shrink_to_fit()</code> 函数的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数没有参数，调用它将使 <code>std::vector</code> 容器的容量减小到和当前元素数量相匹配的大小。但并不保证一定会成功减小容器的容量，因为具体实现可能会有所不同。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::shrink_to_fit()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除容器中的最后两个元素</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 shrink_to_fit() 函数将容器的容量减小到与其大小相匹配</span></span><br><span class="line">    vec.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器的大小和容量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器的大小: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器的容量: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>pop_back()</code> 移除了容器中的最后两个元素。</li>
<li>使用 <code>shrink_to_fit()</code> 函数将容器的容量减小到与其大小相匹配。</li>
<li>使用 <code>size()</code> 和 <code>capacity()</code> 分别打印了容器的大小和容量。</li>
</ul>
<p><code>std::vector::shrink_to_fit()</code> 函数提供了一种手段来释放 <code>std::vector</code> 容器内多余的内存空间，使得容器的实际容量与其大小相匹配。但并不保证一定会成功减小容器的容量，具体情况取决于实现。</p>
<h2 id="std-vector-emplace-back-函数-详解"><a href="#std-vector-emplace-back-函数-详解" class="headerlink" title="std::vector::emplace_back() 函数 详解"></a>std::vector::emplace_back() 函数 详解</h2><p><code>std::vector::emplace_back()</code> 是 C++ 中 <code>std::vector</code> 容器提供的一个函数，用于在容器的末尾直接构造元素，而不是先创建一个临时对象再进行拷贝或移动操作。这个函数允许你在容器中就地构造对象，从而避免额外的拷贝或移动开销。</p>
<p>以下是 <code>std::vector::emplace_back()</code> 的详细解释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace std</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>emplace_back</code> 函数接受任意数量的参数，并将这些参数传递给容器中元素的构造函数，用于在容器的末尾直接构造一个新元素。</p>
</li>
<li><p>参数 <code>Args&amp;&amp;... args</code> 是一个可变参数模板，可以接受任意数量的参数。</p>
</li>
</ul>
<p>使用 <code>emplace_back</code> 的典型用法是，直接在容器末尾构造一个元素，而不需要在代码中创建临时对象。这对于避免额外的拷贝或移动操作特别有用。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructing MyClass with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;MyClass&gt; myVector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 emplace_back 直接在容器末尾构造元素</span></span><br><span class="line">    myVector.<span class="built_in">emplace_back</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 emplace_back 可以避免额外的拷贝或移动操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>emplace_back</code> 直接在 <code>std::vector</code> 的末尾构造了一个 <code>MyClass</code> 对象，而不需要先创建一个临时对象再进行拷贝操作。这样可以提高效率，特别是对于那些不支持移动语义的类。</p>
<h2 id="C-std-vector-拷贝构造函数-详解"><a href="#C-std-vector-拷贝构造函数-详解" class="headerlink" title="C++ std::vector 拷贝构造函数 详解"></a>C++ std::vector 拷贝构造函数 详解</h2><p>在 C++ 中，<code>std::vector</code> 是一个动态数组，它提供了在运行时大小可以动态变化的数组容器。拷贝构造函数是一种特殊的构造函数，用于创建一个对象的副本。<code>std::vector</code> 的拷贝构造函数用于创建一个新的 <code>std::vector</code> 对象，其元素与另一个 <code>std::vector</code> 对象完全相同。</p>
<p>以下是 <code>std::vector</code> 的拷贝构造函数的详细解释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&amp; other);</span><br></pre></td></tr></table></figure>

<p>拷贝构造函数采用另一个 <code>std::vector</code> 对象作为参数，并创建一个新的 <code>std::vector</code> 对象，其中包含与参数相同的元素。这个构造函数通过复制另一个 <code>std::vector</code> 对象的所有元素来构造新的对象。</p>
<p>拷贝构造函数通常在以下情况下被调用：</p>
<ol>
<li>用一个 <code>std::vector</code> 对象初始化另一个 <code>std::vector</code> 对象。</li>
<li>作为函数参数传递 <code>std::vector</code> 对象。</li>
<li>从函数返回 <code>std::vector</code> 对象时。</li>
</ol>
<p>下面是一个简单的示例，展示了如何使用拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个原始的 std::vector 对象</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; originalVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用拷贝构造函数创建一个新的 std::vector 对象</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">copiedVector</span><span class="params">(originalVector)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出新的 std::vector 对象的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : copiedVector) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>copiedVector</code> 对象使用了原始向量 <code>originalVector</code> 的拷贝构造函数创建了一个副本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_40_variant/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_40_variant/" class="post-title-link" itemprop="url">C++_10_40_variant</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <variant>标准库</li>
</ul>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <variant>标准库 详解</h2><p><code>std::variant</code> 是 C++17 标准库中引入的一种类型，用于在一组指定的类型中存储一个值。它提供了一种类型安全的方式来处理联合类型（Union Types）。在许多情况下，<code>std::variant</code> 可以替代传统的 C 风格联合体（union），并提供更多的类型安全性和便利性。</p>
<p>以下是关于 <code>std::variant</code> 的详细解释：</p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul>
<li><strong>替代性</strong>：<code>std::variant</code> 类型可以持有一组指定的类型中的任何一个，但一次只能持有其中一个。</li>
<li><strong>类型安全</strong>：编译器在编译时会检查 <code>std::variant</code> 中的值是否与预期的类型匹配，从而提供更好的类型安全性。</li>
<li><strong>异常安全</strong>：<code>std::variant</code> 提供了异常安全性，可以确保在异常抛出时不会出现资源泄漏或不一致的状态。</li>
</ul>
<h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h3><h4 id="2-1-创建-std-variant-对象"><a href="#2-1-创建-std-variant-对象" class="headerlink" title="2.1 创建 std::variant 对象"></a>2.1 创建 <code>std::variant</code> 对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; myVariant;</span><br><span class="line">    myVariant = <span class="number">10</span>; <span class="comment">// 存储 int 类型</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(myVariant) &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-访问-std-variant-中的值"><a href="#2-2-访问-std-variant-中的值" class="headerlink" title="2.2 访问 std::variant 中的值"></a>2.2 访问 <code>std::variant</code> 中的值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; myVariant;</span><br><span class="line">    myVariant = <span class="number">10</span>; <span class="comment">// 存储 int 类型</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">int</span>&gt;(myVariant)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The variant holds an int.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(myVariant) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">double</span>&gt;(myVariant)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The variant holds a double.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(myVariant) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;std::string&gt;(myVariant)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The variant holds a string.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(myVariant) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-访问可能引发异常的值"><a href="#2-3-访问可能引发异常的值" class="headerlink" title="2.3 访问可能引发异常的值"></a>2.3 访问可能引发异常的值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; myVariant;</span><br><span class="line">    myVariant = <span class="number">10</span>; <span class="comment">// 存储 int 类型</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> value = std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(myVariant);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_variant_access&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p><code>std::variant</code> 提供了一种更安全和灵活的方式来处理多种类型的值，特别适用于函数返回多种类型值的情况，以及需要类型安全的联合类型操作的场景。使用 <code>std::variant</code> 可以避免传统联合体带来的类型不安全性和编程错误，提高了代码的可读性和健壮性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_41_optional/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_41_optional/" class="post-title-link" itemprop="url">C++_10_41_optional</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <optional>标准库</li>
</ul>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++  标准库 详解"></a>C++ <optional> 标准库 详解</h2><p><code>&lt;optional&gt;</code> 是 C++17 引入的标准头文件，其中定义了 <code>std::optional</code> 类模板。<code>std::optional</code> 提供了一种表示可能为空的值的机制，允许程序员在需要时将值包装在可选容器中，以便更安全地处理可能存在的缺失情况。</p>
<p>以下是 <code>&lt;optional&gt;</code> 标准库的一些重要特性和用法：</p>
<ol>
<li><p><strong>表示可能缺失的值</strong>：<code>std::optional</code> 是一种包装器，它可以容纳一个可能缺失的值。与裸指针或引用相比，<code>std::optional</code> 提供了更安全和更明确的语义，因为它明确表达了值的可选性。</p>
</li>
<li><p><strong>安全的值访问</strong>：通过使用 <code>std::optional</code> 提供的 <code>value()</code> 成员函数，你可以安全地访问被包装的值。如果值不存在，则调用 <code>value()</code> 会引发 <code>std::bad_optional_access</code> 异常。此外，<code>std::optional</code> 还提供了 <code>value_or()</code> 成员函数，允许你指定一个默认值，以在值不存在时返回。</p>
</li>
<li><p><strong>条件化的赋值</strong>：你可以将一个值赋给 <code>std::optional</code> 对象，这样如果被赋值的值为空，则 <code>std::optional</code> 也将为空。你也可以使用 <code>reset()</code> 成员函数显式地将 <code>std::optional</code> 设置为空。</p>
</li>
<li><p><strong>空值检查</strong>：通过调用 <code>has_value()</code> 成员函数，你可以检查 <code>std::optional</code> 是否包含了值。</p>
</li>
<li><p><strong>与标准算法的兼容性</strong>：<code>std::optional</code> 与标准库的算法完全兼容，你可以将 <code>std::optional</code> 用作容器中的元素，也可以将其作为算法的参数或返回值。</p>
</li>
<li><p><strong>性能开销</strong>：<code>std::optional</code> 的性能开销通常很小，因为它通常只包装了一个值，并且只有在值存在时才分配存储空间。</p>
</li>
</ol>
<p>使用 <code>std::optional</code> 可以让你的代码更加安全和清晰，因为它提供了一种明确和类型安全的方式来处理可能缺失的值。它是现代 C++ 中处理可选值的首选工具之一。</p>
<h2 id="C-std-optional-详解"><a href="#C-std-optional-详解" class="headerlink" title="C++ std::optional 详解"></a>C++ std::optional 详解</h2><p><code>std::optional</code> 是 C++17 引入的标准库类型，用于表示一个可能包含值的可选对象。它提供了一种方式来处理可能为空的值，而不需要使用指针或特殊的值来表示缺失。<code>std::optional</code> 是一个模板类，可以包含任何类型的值。</p>
<p>以下是 <code>std::optional</code> 的一些主要特性和用法：</p>
<ol>
<li><p><strong>表示可能为空的值</strong>：<code>std::optional</code> 允许你声明一个可能为空的值，这样就可以避免使用裸指针或特殊值来表示缺失。这有助于提高代码的安全性和可读性。</p>
</li>
<li><p><strong>避免空指针异常</strong>：使用 <code>std::optional</code> 可以避免空指针异常，因为它明确表示了值的可能缺失，并提供了相应的处理机制。</p>
</li>
<li><p><strong>安全地访问值</strong>：你可以使用 <code>std::optional</code> 提供的成员函数 <code>value()</code> 来访问值，它会在值为空时抛出异常，或者使用 <code>std::optional</code> 提供的成员函数 <code>value_or()</code> 来获取值或者指定的默认值。</p>
</li>
<li><p><strong>支持空值检查</strong>：你可以使用 <code>std::optional</code> 的成员函数 <code>has_value()</code> 来检查是否包含了值。</p>
</li>
<li><p><strong>条件化的赋值</strong>：可以使用赋值运算符将值分配给 <code>std::optional</code>，如果被分配的值为空，则 <code>std::optional</code> 也将变为空。</p>
</li>
<li><p><strong>与标准库算法的兼容性</strong>：<code>std::optional</code> 与标准库算法完全兼容，可以在容器中使用，也可以作为算法的参数或返回值。</p>
</li>
<li><p><strong>性能开销</strong>：<code>std::optional</code> 的性能开销通常很小，因为它通常是一个类似于指针的轻量级对象，只有在有值时才会分配存储空间。</p>
</li>
</ol>
<p>下面是一个简单的示例，演示了如何使用 <code>std::optional</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; optValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assigning a value</span></span><br><span class="line">    optValue = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optValue.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; optValue.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No value assigned.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using value_or() to get the value or a default value</span></span><br><span class="line">    <span class="type">int</span> val = optValue.<span class="built_in">value_or</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value or default: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，<code>std::optional</code> 提供了一种方便、安全和灵活的方式来处理可能为空的值，是现代 C++ 中处理可选值的首选工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_39_locale/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_39_locale/" class="post-title-link" itemprop="url">C++_10_39_locale</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <locale>标准库</li>
</ul>
<h2 id="C-标准库-是什么"><a href="#C-标准库-是什么" class="headerlink" title="C++ 标准库 是什么"></a>C++ <locale>标准库 是什么</h2><p>C++ 标准库中的 <code>&lt;locale&gt;</code> 头文件提供了对本地化和文化特定信息的支持。本地化是指根据用户的区域设置和语言首选项来适应软件的行为和输出。<code>&lt;locale&gt;</code> 提供了一种方法来根据用户的偏好格式化数字、货币、日期和时间等信息。</p>
<p>以下是 <code>&lt;locale&gt;</code> 标准库的一些主要功能和概念：</p>
<ol>
<li><p>**本地化对象 (<code>std::locale</code>)**：<code>std::locale</code> 类表示一个特定的本地化环境，可以包含一组本地化设置，例如货币符号、日期格式等。程序可以使用 <code>std::locale</code> 对象来控制输出的格式。</p>
</li>
<li><p>**全局本地化对象 (<code>std::locale::global()</code>)**：<code>std::locale::global()</code> 函数用于设置全局本地化环境。这样设置后，所有的标准 I&#x2F;O 操作和其他与本地化相关的操作都会遵循指定的本地化环境。</p>
</li>
<li><p>**本地化特定的 <code>std::facet</code>**：<code>std::facet</code> 是一种抽象类，用于定义与特定本地化相关的行为，例如日期格式、货币格式等。C++ 标准库提供了一些预定义的 <code>std::facet</code> 类，也允许用户定义自己的本地化特定行为。</p>
</li>
<li><p><strong>本地化特定的 <code>std::locale::facet()</code> 函数</strong>：<code>std::locale::facet()</code> 函数用于获取给定本地化环境中特定类型的 <code>std::facet</code> 对象。</p>
</li>
<li><p><strong>本地化特定的输入&#x2F;输出流 (<code>std::iostream</code>) 操作符重载</strong>：C++ 标准库中的输入&#x2F;输出流操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 被重载以支持本地化环境。例如，使用 <code>std::cout</code> 输出数字时，可以根据本地化环境的设置自动格式化数字。</p>
</li>
<li><p>**本地化相关的 <code>std::time_get</code> 和 <code>std::time_put</code>**：这些类用于在不同的本地化环境中解析和格式化日期和时间。</p>
</li>
</ol>
<p>通过使用 <code>&lt;locale&gt;</code> 标准库，程序可以根据用户的偏好和环境设置自动调整输出的格式，使得软件可以在不同的国家和语言环境中以合适的方式显示信息。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <locale>标准库 详解</h2><p><code>&lt;locale&gt;</code> 标准库提供了对本地化（Localization）和国际化（Internationalization）的支持，使得 C++ 程序能够根据用户的地区、语言等偏好来调整输出的格式，包括数字、日期、时间、货币等。下面是对 <code>&lt;locale&gt;</code> 标准库的详细解析：</p>
<h3 id="1-std-locale-类"><a href="#1-std-locale-类" class="headerlink" title="1. std::locale 类"></a>1. <code>std::locale</code> 类</h3><p><code>std::locale</code> 类表示一个特定的本地化环境，包含了一系列本地化设置，如货币符号、日期格式、数字格式等。通过创建 <code>std::locale</code> 对象，可以设置程序的本地化环境。</p>
<h3 id="2-全局本地化设置"><a href="#2-全局本地化设置" class="headerlink" title="2. 全局本地化设置"></a>2. 全局本地化设置</h3><p>使用 <code>std::locale::global()</code> 函数可以设置全局的本地化环境，这样在程序的其他地方就可以自动使用该本地化环境的设置了。</p>
<h3 id="3-std-locale-facet-类"><a href="#3-std-locale-facet-类" class="headerlink" title="3. std::locale::facet 类"></a>3. <code>std::locale::facet</code> 类</h3><p><code>std::locale::facet</code> 是一个抽象基类，用于定义与特定本地化相关的行为。标准库提供了许多预定义的 <code>std::facet</code> 类，如 <code>std::numpunct</code>（用于数字格式化）、<code>std::time_get</code>（用于时间解析）等。</p>
<h3 id="4-std-locale-facet-函数"><a href="#4-std-locale-facet-函数" class="headerlink" title="4. std::locale::facet() 函数"></a>4. <code>std::locale::facet()</code> 函数</h3><p>通过调用 <code>std::locale::facet()</code> 函数可以获取给定本地化环境中特定类型的 <code>std::facet</code> 对象。</p>
<h3 id="5-本地化的输入-输出流操作符重载"><a href="#5-本地化的输入-输出流操作符重载" class="headerlink" title="5. 本地化的输入&#x2F;输出流操作符重载"></a>5. 本地化的输入&#x2F;输出流操作符重载</h3><p>C++ 标准库中的输入&#x2F;输出流操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 被重载以支持本地化环境。例如，使用 <code>std::cout</code> 输出数字时，可以根据本地化环境的设置自动格式化数字。</p>
<h3 id="6-std-use-facet-模板函数"><a href="#6-std-use-facet-模板函数" class="headerlink" title="6. std::use_facet 模板函数"></a>6. <code>std::use_facet</code> 模板函数</h3><p><code>std::use_facet</code> 函数用于从 <code>std::locale</code> 对象中获取指定类型的 <code>std::facet</code> 对象，以便对本地化环境进行更详细的定制。</p>
<h3 id="7-std-time-get-和-std-time-put-类"><a href="#7-std-time-get-和-std-time-put-类" class="headerlink" title="7. std::time_get 和 std::time_put 类"></a>7. <code>std::time_get</code> 和 <code>std::time_put</code> 类</h3><p>这些类用于在不同的本地化环境中解析和格式化日期和时间。</p>
<h3 id="8-其他相关类和函数"><a href="#8-其他相关类和函数" class="headerlink" title="8. 其他相关类和函数"></a>8. 其他相关类和函数</h3><p>除了上述提到的类和函数外，<code>&lt;locale&gt;</code> 标准库还提供了许多其他与本地化相关的类和函数，如 <code>std::collate</code>（用于字符串排序）、<code>std::ctype</code>（用于字符分类和转换）、<code>std::messages</code>（用于多语言消息处理）等。</p>
<p>通过 <code>&lt;locale&gt;</code> 标准库，C++ 程序可以更容易地支持不同地区和语言环境下的本地化需求，提高了程序的灵活性和用户体验。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_4_chrono/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_4_chrono/" class="post-title-link" itemprop="url">C++_10_4_chrono</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><chrono>标准库相关笔记</li>
</ul>
<h2 id="std-chrono-duration-时间段转为时分秒的形式输出"><a href="#std-chrono-duration-时间段转为时分秒的形式输出" class="headerlink" title="std::chrono::duration 时间段转为时分秒的形式输出"></a>std::chrono::duration 时间段转为时分秒的形式输出</h2><p>在 C++ 中，<code>std::chrono::duration</code> 表示一个时间间隔，你可以将其转换为时、分、秒的形式进行输出。下面是具体方法：</p>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><ol>
<li>**使用 <code>std::chrono::duration_cast</code> 将 <code>duration</code> 转换为 <code>hours</code>、<code>minutes</code> 和 <code>seconds</code>**。</li>
<li><strong>使用取模运算 (<code>%</code>) 计算去掉小时后的分钟数，去掉分钟后的秒数</strong>。</li>
</ol>
<hr>
<h2 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_duration</span><span class="params">(std::chrono::seconds duration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取小时、分钟、秒</span></span><br><span class="line">    <span class="keyword">auto</span> h = <span class="built_in">duration_cast</span>&lt;hours&gt;(duration);</span><br><span class="line">    <span class="keyword">auto</span> m = <span class="built_in">duration_cast</span>&lt;minutes&gt;(duration % <span class="built_in">hours</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="built_in">duration_cast</span>&lt;seconds&gt;(duration % <span class="built_in">minutes</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    std::cout &lt;&lt; h.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;h &quot;</span></span><br><span class="line">              &lt;&lt; m.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;m &quot;</span></span><br><span class="line">              &lt;&lt; s.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="function">chrono::seconds <span class="title">duration</span><span class="params">(<span class="number">3665</span>)</span></span>; <span class="comment">// 3665秒 = 1小时 1分 5秒</span></span><br><span class="line">    <span class="built_in">print_duration</span>(duration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1h 1m 5s</span><br></pre></td></tr></table></figure>

<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><ul>
<li><code>duration_cast&lt;std::chrono::hours&gt;(duration)</code> 计算完整的小时数。</li>
<li><code>duration % std::chrono::hours(1)</code> 获取去掉小时后剩余的时间，然后转换为分钟。</li>
<li><code>duration % std::chrono::minutes(1)</code> 获取去掉分钟后剩余的秒数。</li>
</ul>
<p>这样，你可以把任何 <code>std::chrono::duration</code> 转换为 <code>hh:mm:ss</code> 的格式！</p>
<h2 id="持续时间的表示-Duration-Representation"><a href="#持续时间的表示-Duration-Representation" class="headerlink" title="持续时间的表示(Duration Representation)"></a>持续时间的表示(Duration Representation)</h2><ul>
<li>持续时间在std::chrono中是以一种非常直观的方式表示的，它反映了我们对时间的基本理解：时间是连续的，并且可以以不同的单位来衡量。在std::chrono中，持续时间是通过两个模板参数来定义的：一个是用于存储时间值的底层类型（如int64_t），另一个是时间单位（如秒、毫秒）。</li>
</ul>
<h2 id="C-标准库是什么"><a href="#C-标准库是什么" class="headerlink" title="C++ 标准库是什么"></a>C++ <chrono>标准库是什么</h2><p>C++ 标准库中的 <code>&lt;chrono&gt;</code> 是用于处理时间相关操作的头文件，提供了时间点（<code>time_point</code>）和持续时间（<code>duration</code>）的类模板，以及用于操作时间的各种函数和工具。</p>
<p>主要包括以下内容：</p>
<h3 id="时间点（time-point）和持续时间（duration）："><a href="#时间点（time-point）和持续时间（duration）：" class="headerlink" title="时间点（time_point）和持续时间（duration）："></a>时间点（<code>time_point</code>）和持续时间（<code>duration</code>）：</h3><ul>
<li><strong><code>std::chrono::time_point</code>：</strong> 代表时间的点，通常表示自某个特定时钟起的时间。例如，<code>std::chrono::system_clock::time_point</code> 表示系统时钟的时间点。</li>
<li><strong><code>std::chrono::duration</code>：</strong> 表示时间间隔的持续时间，可以用于表示一段时间的长度。例如，<code>std::chrono::duration&lt;int&gt;</code> 表示以整数单位的时间段。</li>
</ul>
<h3 id="时钟（Clocks）："><a href="#时钟（Clocks）：" class="headerlink" title="时钟（Clocks）："></a>时钟（Clocks）：</h3><ul>
<li><strong><code>std::chrono::system_clock</code>：</strong> 代表系统时钟，提供了从 Epoch（通常是 1970 年 1 月 1 日）起的时间点。</li>
<li><strong><code>std::chrono::steady_clock</code>：</strong> 代表一个单调递增的时钟，不受系统时间调整影响，适合测量时间间隔。</li>
<li><strong><code>std::chrono::high_resolution_clock</code>：</strong> 代表一个高分辨率的时钟，提供了更高精度的计时。</li>
</ul>
<h3 id="时间相关工具和函数："><a href="#时间相关工具和函数：" class="headerlink" title="时间相关工具和函数："></a>时间相关工具和函数：</h3><ul>
<li><strong>时间单位转换：</strong> 提供了 <code>duration_cast</code> 函数用于不同时间单位之间的转换。</li>
<li><strong>时间点的算术运算：</strong> 可以对时间点进行加减运算。</li>
<li><strong>定时器操作：</strong> 可以用于实现定时器，比如 <code>std::this_thread::sleep_for</code> 和 <code>std::this_thread::sleep_until</code>。</li>
<li><strong>时钟的特性和属性：</strong> 可以获取时钟的特性，如时钟的最小精度、是否稳定等。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间点</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间点转换为时间戳</span></span><br><span class="line">    std::<span class="type">time_t</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current time: &quot;</span> &lt;&lt; std::<span class="built_in">ctime</span>(&amp;now_c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建持续时间并延迟一段时间</span></span><br><span class="line">    std::<span class="function">chrono::milliseconds <span class="title">delay</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(delay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;chrono&gt;</code> 提供了一种标准化的时间处理方式，可用于测量和管理时间，执行定时操作以及进行时间单位转换。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <chrono>标准库 详解</h2><p><code>&lt;chrono&gt;</code> 是 C++ 标准库中用于处理时间相关操作的头文件，自 C++11 起引入。它提供了时间点（<code>time_point</code>）、持续时间（<code>duration</code>）、时钟（<code>clock</code>）以及与时间相关的函数和工具，使得在 C++ 中对时间进行精确测量和处理变得更加方便和标准化。</p>
<h3 id="重要的类型和类："><a href="#重要的类型和类：" class="headerlink" title="重要的类型和类："></a>重要的类型和类：</h3><ul>
<li><strong><code>std::chrono::time_point</code>：</strong> 表示时间的点，在特定时钟下的时间。例如，<code>std::chrono::system_clock::time_point</code> 表示系统时钟的时间点。</li>
<li><strong><code>std::chrono::duration</code>：</strong> 表示时间间隔的持续时间，可以用于表示一段时间的长度。例如，<code>std::chrono::duration&lt;int&gt;</code> 表示以整数单位的时间段。</li>
</ul>
<h3 id="重要的时钟（Clocks）："><a href="#重要的时钟（Clocks）：" class="headerlink" title="重要的时钟（Clocks）："></a>重要的时钟（Clocks）：</h3><ul>
<li><strong><code>std::chrono::system_clock</code>：</strong> 代表系统时钟，提供了从 Epoch（通常是 1970 年 1 月 1 日）起的时间点。</li>
<li><strong><code>std::chrono::steady_clock</code>：</strong> 代表一个单调递增的时钟，不受系统时间调整影响，适合测量时间间隔。</li>
<li><strong><code>std::chrono::high_resolution_clock</code>：</strong> 代表一个高分辨率的时钟，提供了更高精度的计时。</li>
</ul>
<h3 id="主要函数和工具："><a href="#主要函数和工具：" class="headerlink" title="主要函数和工具："></a>主要函数和工具：</h3><ul>
<li><strong>时间单位转换：</strong> 提供了 <code>std::chrono::duration_cast</code> 函数用于不同时间单位之间的转换。</li>
<li><strong>时间点的算术运算：</strong> 可以对时间点进行加减运算。</li>
<li><strong>定时器操作：</strong> 可以用于实现定时器，比如 <code>std::this_thread::sleep_for</code> 和 <code>std::this_thread::sleep_until</code>。</li>
<li><strong>获取时间点：</strong> 提供了 <code>std::chrono::system_clock::now()</code> 用于获取当前时间点。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间点</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间点转换为时间戳</span></span><br><span class="line">    std::<span class="type">time_t</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current time: &quot;</span> &lt;&lt; std::<span class="built_in">ctime</span>(&amp;now_c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建持续时间并延迟一段时间</span></span><br><span class="line">    std::<span class="function">chrono::milliseconds <span class="title">delay</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(delay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;chrono&gt;</code> 提供了一种标准化的时间处理方式，可用于测量和管理时间，执行定时操作以及进行时间单位转换。它的引入使得在 C++ 中对时间进行处理更加方便和跨平台。</p>
<h2 id="C-标准库-常用函数"><a href="#C-标准库-常用函数" class="headerlink" title="C++ 标准库 常用函数"></a>C++ <chrono>标准库 常用函数</h2><p>C++ <code>&lt;chrono&gt;</code> 标准库提供了用于处理时间的功能，包括时间点（time points）、时间间隔（durations）、时钟（clocks）等。以下是一些 <code>&lt;chrono&gt;</code> 标准库中常用的函数和类：</p>
<h3 id="类和类型"><a href="#类和类型" class="headerlink" title="类和类型"></a>类和类型</h3><ol>
<li><p>**<code>std::chrono::duration</code>**：表示时间间隔的类型。例如 <code>std::chrono::duration&lt;int&gt;</code> 表示以整数秒为单位的时间间隔。</p>
</li>
<li><p>**<code>std::chrono::time_point</code>**：表示特定时钟的时间点。它由时钟和持续时间构成。</p>
</li>
<li><p>**<code>std::chrono::system_clock</code>**：提供当前时间，并使用 UNIX 时间（1970 年 1 月 1 日午夜起的秒数）作为其时间起点。</p>
</li>
<li><p>**<code>std::chrono::steady_clock</code>**：提供一个稳定的时钟，用于测量时间间隔，不受系统时间调整的影响。</p>
</li>
<li><p>**<code>std::chrono::high_resolution_clock</code>**：提供高分辨率时钟，尽可能提供最高精度的计时，但其精度因平台而异。</p>
</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li><p>**<code>std::chrono::duration_cast</code>**：用于将一个时间间隔类型转换为另一个时间间隔类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::minutes&gt;(some_duration);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>std::chrono::time_point_cast</code>**：用于将一个时间点类型转换为另一个时间点类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::hours&gt;(some_time_point);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>std::chrono::system_clock::now</code>**：获取当前时间点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> current_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>std::chrono::steady_clock::now</code>**：获取当前稳定时钟的时间点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> current_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>std::chrono::duration</code> 中的各种算术运算</strong>：例如加法、减法、乘法和除法，用于处理时间间隔之间的运算。</p>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前系统时间点</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一段程序执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 做一些计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结束时间点</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算程序执行时间间隔</span></span><br><span class="line">    <span class="keyword">auto</span> duration = end_time - start_time;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program execution time: &quot;</span> &lt;&lt; std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; milliseconds\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是 C++ <code>&lt;chrono&gt;</code> 标准库中一些常用的函数和类，可以用于时间点和时间间隔的操作和管理。</p>
<h2 id="std-chrono-duration"><a href="#std-chrono-duration" class="headerlink" title="std::chrono::duration"></a>std::chrono::duration</h2><p><code>std::chrono::duration</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中表示时间间隔的类模板。它表示一个时间段，可以用于测量不同时间点之间的时间差，以及进行时间单位之间的转换。<code>std::chrono::duration</code> 的模板定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> duration;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Rep</code>：表示持续时间的类型，通常是一个整数类型，用于存储时间长度。</li>
<li><code>Period</code>：表示时间单位的类型，通常是 <code>std::ratio</code> 类型，它定义了时间间隔的基本单位。</li>
</ul>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个持续时间为10秒的duration</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">int</span>&gt; <span class="title">ten_seconds</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取duration的值和单位</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ten_seconds: &quot;</span> &lt;&lt; ten_seconds.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个浮点型持续时间，表示0.5秒</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">double</span>&gt; <span class="title">half_second</span><span class="params">(<span class="number">0.5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取duration的值和单位</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;half_second: &quot;</span> &lt;&lt; half_second.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行duration之间的加法操作</span></span><br><span class="line">    <span class="keyword">auto</span> total_duration = ten_seconds + half_second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取总持续时间的值和单位</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;total_duration: &quot;</span> &lt;&lt; total_duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>std::chrono::duration</code> 被用来表示不同的时间间隔，可以通过 <code>count()</code> 函数获取其持续时间的值，并且支持多种时间间隔的算术操作，如加法、减法等。</p>
<h2 id="std-chrono-time-point"><a href="#std-chrono-time-point" class="headerlink" title="std::chrono::time_point"></a>std::chrono::time_point</h2><p><code>std::chrono::time_point</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中的类模板，用于表示特定时钟（<code>Clock</code>）的时间点。它结合了时钟（<code>Clock</code>）和持续时间（<code>Duration</code>），可以表示从时钟的起点开始经过的时间。<code>std::chrono::time_point</code> 的模板定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span> = <span class="keyword">typename</span> Clock::duration&gt;</span><br><span class="line"><span class="keyword">class</span> time_point;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Clock</code>：表示时钟类型，例如 <code>std::chrono::system_clock</code>、<code>std::chrono::steady_clock</code> 等。</li>
<li><code>Duration</code>：表示时间间隔的类型，通常是 <code>std::chrono::duration</code> 类型。</li>
</ul>
<h3 id="示例用法：-1"><a href="#示例用法：-1" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 system_clock 获取当前时间点</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; current_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 steady_clock 获取当前时间点</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行一些操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取另一个时间点并计算时间间隔</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::steady_clock&gt; end_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>&gt; duration = end_time - start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出时间间隔</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>std::chrono::time_point</code> 被用于存储不同时钟类型（<code>std::chrono::system_clock</code> 和 <code>std::chrono::steady_clock</code>）的时间点。可以使用 <code>now()</code> 函数获取当前时间点，也可以进行时间点之间的算术运算（例如计算时间间隔）。</p>
<h2 id="std-chrono-system-clock"><a href="#std-chrono-system-clock" class="headerlink" title="std::chrono::system_clock"></a>std::chrono::system_clock</h2><p><code>std::chrono::system_clock</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中的时钟类型，用于提供当前系统时间和日期。它是一个基于实时时钟的时钟类，使用的时钟起点通常是 UNIX 时间（1970 年 1 月 1 日午夜起的秒数）。<code>std::chrono::system_clock</code> 提供了获取当前时间的方法。</p>
<h3 id="示例用法：-2"><a href="#示例用法：-2" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前系统时间点</span></span><br><span class="line">    std::chrono::system_clock::time_point now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将时间点转换为时间戳（秒数）</span></span><br><span class="line">    std::<span class="type">time_t</span> timestamp = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出时间戳</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current timestamp: &quot;</span> &lt;&lt; timestamp &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将时间戳转换回时间点</span></span><br><span class="line">    std::chrono::system_clock::time_point time_from_timestamp = std::chrono::system_clock::<span class="built_in">from_time_t</span>(timestamp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查时间点是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (time_from_timestamp == now) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Time points are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Time points are not equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>std::chrono::system_clock</code> 被用于获取当前系统时间点 (<code>now</code>)，并且可以将时间点转换为时间戳 (<code>std::time_t</code>)，以及将时间戳转换回时间点。这允许在不同的时钟表示之间进行转换和比较。</p>
<h2 id="std-chrono-steady-clock"><a href="#std-chrono-steady-clock" class="headerlink" title="std::chrono::steady_clock"></a>std::chrono::steady_clock</h2><p><code>std::chrono::steady_clock</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中的时钟类型，用于提供稳定、不受系统时间调整影响的时钟。它用于测量时间间隔，适合于需要精确计时而不受系统时间调整（例如时间同步或夏令时变化）影响的场景。</p>
<h3 id="示例用法：-3"><a href="#示例用法：-3" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取起始时间点</span></span><br><span class="line">    std::chrono::steady_clock::time_point start_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一段程序执行时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 做一些计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结束时间点</span></span><br><span class="line">    std::chrono::steady_clock::time_point end_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算程序执行时间间隔</span></span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>&gt; duration = end_time - start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出程序执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program execution time: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::chrono::steady_clock</code> 被用于获取程序开始和结束时的时间点，并计算两个时间点之间的持续时间。这种时钟不受系统时间调整的影响，适用于需要精确计时的场景，比如性能测试或计时要求较高的应用程序。</p>
<h2 id="std-chrono-high-resolution-clock"><a href="#std-chrono-high-resolution-clock" class="headerlink" title="std::chrono::high_resolution_clock"></a>std::chrono::high_resolution_clock</h2><p><code>std::chrono::high_resolution_clock</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中的时钟类型，提供了高精度计时功能，尽可能提供最高分辨率的时间测量。然而，精度和实际分辨率可能因平台和实现而异。</p>
<h3 id="示例用法：-4"><a href="#示例用法：-4" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取起始时间点</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一段程序执行时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 做一些计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结束时间点</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算程序执行时间间隔</span></span><br><span class="line">    <span class="keyword">auto</span> duration = end_time - start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出程序执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program execution time: &quot;</span> &lt;&lt; std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(duration).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>std::chrono::high_resolution_clock</code> 被用于测量程序执行时间。需要注意的是，尽管这个时钟通常提供较高的分辨率，但实际精度取决于系统的支持以及硬件平台。因此，在不同的系统上，精度和分辨率可能会有所不同。</p>
<h2 id="std-chrono-duration-cast"><a href="#std-chrono-duration-cast" class="headerlink" title="std::chrono::duration_cast"></a>std::chrono::duration_cast</h2><p><code>std::chrono::duration_cast</code> 是 <code>&lt;chrono&gt;</code> 标准库中的函数，用于执行 <code>std::chrono::duration</code> 类型之间的转换。它允许将一个持续时间（duration）对象从一种单位转换为另一种单位。常用于从高精度单位（例如纳秒或微秒）转换为较低精度单位（例如秒或毫秒）。</p>
<h3 id="示例用法：-5"><a href="#示例用法：-5" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个高精度的持续时间（纳秒）</span></span><br><span class="line">    std::<span class="function">chrono::nanoseconds <span class="title">ns_duration</span><span class="params">(<span class="number">123456789</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将纳秒转换为毫秒</span></span><br><span class="line">    std::chrono::milliseconds ms_duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(ns_duration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出转换后的持续时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Milliseconds: &quot;</span> &lt;&lt; ms_duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::chrono::duration_cast</code> 将纳秒时间持续时间对象 <code>ns_duration</code> 转换为毫秒时间持续时间对象 <code>ms_duration</code>。<code>count()</code> 函数用于获取转换后持续时间的数值，并输出转换后的持续时间。这个函数非常有用，因为它允许你在不同时间单位之间进行安全和精确的转换。</p>
<h2 id="std-chrono-time-point-cast"><a href="#std-chrono-time-point-cast" class="headerlink" title="std::chrono::time_point_cast"></a>std::chrono::time_point_cast</h2><p><code>std::chrono::time_point_cast</code> 是 <code>&lt;chrono&gt;</code> 标准库中的函数，用于将 <code>std::chrono::time_point</code> 对象从一种时钟类型（<code>Clock</code>）转换为另一种时钟类型，并指定新的时间单位。</p>
<h3 id="示例用法：-6"><a href="#示例用法：-6" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个时间点，使用系统时钟</span></span><br><span class="line">    std::chrono::system_clock::time_point sys_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将系统时钟时间点转换为稳定时钟时间点</span></span><br><span class="line">    std::chrono::steady_clock::time_point steady_time = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::steady_clock::duration&gt;(sys_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出转换后的时间点（稳定时钟）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Steady clock time: &quot;</span> &lt;&lt; std::chrono::steady_clock::<span class="built_in">to_time_t</span>(steady_time) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::chrono::time_point_cast</code> 用于将系统时钟 (<code>std::chrono::system_clock</code>) 的时间点 <code>sys_time</code> 转换为稳定时钟 (<code>std::chrono::steady_clock</code>) 的时间点 <code>steady_time</code>。这种转换可能导致精度损失，因为不同的时钟可能具有不同的分辨率和特性。</p>
<h2 id="std-chrono-system-clock-now"><a href="#std-chrono-system-clock-now" class="headerlink" title="std::chrono::system_clock::now"></a>std::chrono::system_clock::now</h2><p><code>std::chrono::system_clock::now</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中的函数，用于获取当前系统时间点，返回一个 <code>std::chrono::time_point</code> 对象，表示当前的系统时间。</p>
<h3 id="示例用法：-7"><a href="#示例用法：-7" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前系统时间点</span></span><br><span class="line">    std::chrono::system_clock::time_point now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将时间点转换为时间戳（秒数）</span></span><br><span class="line">    std::<span class="type">time_t</span> timestamp = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出时间戳</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current timestamp: &quot;</span> &lt;&lt; timestamp &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::chrono::system_clock::now()</code> 用于获取当前系统时间点，然后通过 <code>std::chrono::system_clock::to_time_t</code> 将时间点转换为时间戳（秒数）以便输出。</p>
<h2 id="std-chrono-steady-clock-now"><a href="#std-chrono-steady-clock-now" class="headerlink" title="std::chrono::steady_clock::now"></a>std::chrono::steady_clock::now</h2><p><code>std::chrono::steady_clock::now()</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中的函数，用于获取当前稳定时钟（<code>std::chrono::steady_clock</code>）的时间点，返回一个 <code>std::chrono::time_point</code> 对象，表示当前的稳定时钟时间点。</p>
<h3 id="示例用法：-8"><a href="#示例用法：-8" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前稳定时钟时间点</span></span><br><span class="line">    std::chrono::steady_clock::time_point now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行一些操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取经过的时间间隔</span></span><br><span class="line">    std::chrono::steady_clock::time_point later = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>&gt; duration = later - now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出经过的时间间隔</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elapsed time: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::chrono::steady_clock::now()</code> 被用于获取程序执行时的稳定时钟时间点，然后可以计算程序执行所经过的时间间隔，这在需要精确计时而又不受系统时间变化影响的场景下非常有用。</p>
<h2 id="std-chrono-duration-1"><a href="#std-chrono-duration-1" class="headerlink" title="std::chrono::duration"></a>std::chrono::duration</h2><p><code>std::chrono::duration</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中用于表示时间间隔的类模板。它能够表示一个时间段，即持续时间，以及可以用于测量不同时间点之间的时间差。</p>
<h3 id="模板定义："><a href="#模板定义：" class="headerlink" title="模板定义："></a>模板定义：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> duration;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Rep</code>：表示时间长度的类型，通常是一个整数类型，用于存储时间的长度。</li>
<li><code>Period</code>：表示时间单位的类型，通常是 <code>std::ratio</code> 类型，定义了时间间隔的基本单位。</li>
</ul>
<h3 id="示例用法：-9"><a href="#示例用法：-9" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个持续时间为 5 秒的 duration 对象</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">int</span>&gt; <span class="title">five_seconds</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 duration 对象的值和单位</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Five seconds: &quot;</span> &lt;&lt; five_seconds.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个浮点型持续时间，表示 2.5 秒</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">double</span>&gt; <span class="title">two_and_half_seconds</span><span class="params">(<span class="number">2.5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取浮点型 duration 对象的值和单位</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Two and a half seconds: &quot;</span> &lt;&lt; two_and_half_seconds.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行 duration 对象之间的加法操作</span></span><br><span class="line">    <span class="keyword">auto</span> total_duration = five_seconds + two_and_half_seconds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取总持续时间的值和单位</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total duration: &quot;</span> &lt;&lt; total_duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>std::chrono::duration</code> 用于表示不同的时间间隔，并可以通过 <code>count()</code> 函数获取持续时间的值。同时，<code>std::chrono::duration</code> 还支持不同时间间隔之间的算术操作，比如加法、减法等。</p>
<h2 id="C-格式化输出年月日-时分秒"><a href="#C-格式化输出年月日-时分秒" class="headerlink" title="C++  格式化输出年月日-时分秒"></a>C++ <chrono> 格式化输出年月日-时分秒</h2><p>要格式化输出年月日-时分秒，你可以使用<code>std::put_time</code>函数。这个函数允许你将<code>std::tm</code>结构体转换为一个字符串，以指定的格式输出。下面是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间点</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将时间点转换为时间结构体</span></span><br><span class="line">    std::<span class="type">time_t</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::tm* now_tm = std::<span class="built_in">localtime</span>(&amp;now_c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化输出年月日-时分秒</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前时间：&quot;</span> &lt;&lt; std::<span class="built_in">put_time</span>(now_tm, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码使用<code>std::put_time</code>将<code>now_tm</code>结构体以指定格式输出，即”%Y-%m-%d %H:%M:%S”，其中：</p>
<ul>
<li><code>%Y</code>表示年份（四位数）</li>
<li><code>%m</code>表示月份（两位数）</li>
<li><code>%d</code>表示日期（两位数）</li>
<li><code>%H</code>表示小时（24小时制，两位数）</li>
<li><code>%M</code>表示分钟（两位数）</li>
<li><code>%S</code>表示秒（两位数）</li>
</ul>
<p>运行这段代码将输出当前的年月日-时分秒。</p>
<h2 id="C-std-chrono-literals-是什么"><a href="#C-std-chrono-literals-是什么" class="headerlink" title="C++ std::chrono_literals 是什么"></a>C++ std::chrono_literals 是什么</h2><p>C++ 标准库中的 <code>std::chrono_literals</code> 是 C++11 引入的一个命名空间，用于提供方便的时间单位字面量，使得在编写时间相关代码时更加直观和易读。</p>
<p>这个命名空间中包含了各种时间单位的字面量，例如：</p>
<ul>
<li><code>1s</code>：表示一秒钟。</li>
<li><code>1ms</code>：表示一毫秒（千分之一秒）。</li>
<li><code>1us</code>：表示一微秒（百万分之一秒）。</li>
<li><code>1ns</code>：表示一纳秒（十亿分之一秒）。</li>
</ul>
<p>通过使用这些字面量，你可以在代码中直接使用自然的时间单位，而不需要手动计算时间的毫秒、微秒或纳秒值，从而提高了代码的可读性和可维护性。</p>
<p>例如，你可以这样使用 <code>std::chrono_literals</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> duration = <span class="number">100</span>ms;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; milliseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> timeout = <span class="number">5</span>s;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Timeout: &quot;</span> &lt;&lt; timeout.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>100ms</code> 和 <code>5s</code> 就是使用 <code>std::chrono_literals</code> 提供的时间单位字面量，分别表示 100 毫秒和 5 秒。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/22/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/24/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
