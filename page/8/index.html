<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/8/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/30/notebook/DeepLearning/OpenVINO/2024-12-30-OpenVino/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/30/notebook/DeepLearning/OpenVINO/2024-12-30-OpenVino/" class="post-title-link" itemprop="url">OpenVino</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-30 09:00:00" itemprop="dateCreated datePublished" datetime="2024-12-30T09:00:00+08:00">2024-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>OpenVino 相关学习笔记</li>
</ul>
<h2 id="ov-AnyMap-详解"><a href="#ov-AnyMap-详解" class="headerlink" title="ov::AnyMap 详解"></a>ov::AnyMap 详解</h2><p>在 OpenVINO 的 C++ API 中，<code>ov::AnyMap</code> 是一个通用的键值对数据结构，用于设置和传递模型编译或推理时的配置参数。它允许用户通过简单的键值映射来定义特定配置，以便调整推理过程的行为。</p>
<hr>
<h2 id="1-ov-AnyMap-的基本概念"><a href="#1-ov-AnyMap-的基本概念" class="headerlink" title="1. ov::AnyMap 的基本概念"></a>1. <strong><code>ov::AnyMap</code> 的基本概念</strong></h2><ul>
<li><strong>类型</strong>: <code>std::map&lt;std::string, ov::Any&gt;</code> 的别名。</li>
<li><strong>功能</strong>: 存储键值对，其中键为配置参数的名称，值为 <code>ov::Any</code> 类型，用于支持不同类型的参数值。</li>
<li><strong>用途</strong>:<ul>
<li>配置推理设备的行为（如线程数、性能模式）。</li>
<li>设置优化参数（如批处理大小、输入精度等）。</li>
<li>传递插件特定的自定义配置。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-创建和使用"><a href="#2-创建和使用" class="headerlink" title="2. 创建和使用"></a>2. <strong>创建和使用</strong></h2><p><code>ov::AnyMap</code> 是可选配置的一部分，通常在调用 <code>ov::Core::compile_model</code> 或类似方法时使用。</p>
<h3 id="创建一个-ov-AnyMap"><a href="#创建一个-ov-AnyMap" class="headerlink" title="创建一个 ov::AnyMap"></a><strong>创建一个 <code>ov::AnyMap</code></strong></h3><p>以下是创建和设置 <code>ov::AnyMap</code> 的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openvino/openvino.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个配置参数的 AnyMap</span></span><br><span class="line">    ov::AnyMap config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置性能模式</span></span><br><span class="line">    config[ov::hint::performance_mode.<span class="built_in">name</span>()] = ov::hint::PerformanceMode::THROUGHPUT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程数</span></span><br><span class="line">    config[ov::inference_num_threads.<span class="built_in">name</span>()] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置流数量</span></span><br><span class="line">    config[ov::num_streams.<span class="built_in">name</span>()] = <span class="string">&quot;AUTO&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-ov-AnyMap"><a href="#使用-ov-AnyMap" class="headerlink" title="使用 ov::AnyMap"></a><strong>使用 <code>ov::AnyMap</code></strong></h3><p>通过 <code>ov::Core</code> 编译模型时传入 <code>ov::AnyMap</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载模型</span></span><br><span class="line"><span class="keyword">auto</span> model = core.<span class="built_in">read_model</span>(<span class="string">&quot;model.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用配置编译模型</span></span><br><span class="line"><span class="keyword">auto</span> compiled_model = core.<span class="built_in">compile_model</span>(model, <span class="string">&quot;CPU&quot;</span>, config);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-ov-Any-的特性"><a href="#3-ov-Any-的特性" class="headerlink" title="3. ov::Any 的特性"></a>3. <strong><code>ov::Any</code> 的特性</strong></h2><p><code>ov::Any</code> 是一个多态类型，支持存储任意类型的值。常见的值类型包括：</p>
<ul>
<li>整数 (<code>int</code>)</li>
<li>浮点数 (<code>float</code>, <code>double</code>)</li>
<li>字符串 (<code>std::string</code>)</li>
<li>枚举类型（如 <code>ov::hint::PerformanceMode</code>）</li>
<li>布尔值 (<code>bool</code>)</li>
</ul>
<p>使用 <code>ov::Any</code> 时，自动处理值类型，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置不同类型的值</span></span><br><span class="line">ov::AnyMap config;</span><br><span class="line">config[<span class="string">&quot;threads&quot;</span>] = <span class="number">4</span>; <span class="comment">// int</span></span><br><span class="line">config[<span class="string">&quot;enable_profiling&quot;</span>] = <span class="literal">true</span>; <span class="comment">// bool</span></span><br><span class="line">config[<span class="string">&quot;device&quot;</span>] = std::<span class="built_in">string</span>(<span class="string">&quot;CPU&quot;</span>); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-常见配置参数"><a href="#4-常见配置参数" class="headerlink" title="4. 常见配置参数"></a>4. <strong>常见配置参数</strong></h2><p>以下是 OpenVINO 支持的一些常见配置参数：</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>值类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ov::hint::performance_mode</code></td>
<td><code>ov::hint::PerformanceMode</code></td>
<td>性能优化模式，如延迟或吞吐量优化。</td>
</tr>
<tr>
<td><code>ov::inference_num_threads</code></td>
<td><code>int</code></td>
<td>推理线程数。</td>
</tr>
<tr>
<td><code>ov::num_streams</code></td>
<td><code>std::string</code></td>
<td>流数量，如 “AUTO”、”1”、”2” 等。</td>
</tr>
<tr>
<td><code>ov::enable_profiling</code></td>
<td><code>bool</code></td>
<td>是否启用性能分析。</td>
</tr>
<tr>
<td><code>ov::hint::model_priority</code></td>
<td><code>ov::hint::Priority</code></td>
<td>模型优先级设置。</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-如何读取配置"><a href="#5-如何读取配置" class="headerlink" title="5. 如何读取配置"></a>5. <strong>如何读取配置</strong></h2><p>使用 <code>ov::AnyMap</code> 设置参数后，可以通过以下方式访问参数值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取配置值</span></span><br><span class="line"><span class="keyword">auto</span> threads = config[<span class="string">&quot;threads&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">// 获取 int 类型的线程数</span></span><br><span class="line"><span class="keyword">auto</span> enable_profiling = config[<span class="string">&quot;enable_profiling&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">bool</span>&gt;(); <span class="comment">// 获取 bool 类型的值</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-错误处理"><a href="#6-错误处理" class="headerlink" title="6. 错误处理"></a>6. <strong>错误处理</strong></h2><ul>
<li>如果尝试访问不存在的键，会抛出异常。</li>
<li>如果类型转换失败（如尝试将 <code>bool</code> 转换为 <code>int</code>），会引发类型错误。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> value = config[<span class="string">&quot;non_existing_key&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-结合设备插件"><a href="#7-结合设备插件" class="headerlink" title="7. 结合设备插件"></a>7. <strong>结合设备插件</strong></h2><p><code>ov::AnyMap</code> 可以传递设备插件特定的配置。例如，针对 GPU：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ov::AnyMap gpu_config = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;CACHE_DIR&quot;</span>, <span class="string">&quot;/path/to/cache&quot;</span>&#125;, <span class="comment">// GPU 缓存目录</span></span><br><span class="line">    &#123;ov::hint::performance_mode.<span class="built_in">name</span>(), ov::hint::PerformanceMode::THROUGHPUT&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> compiled_model = core.<span class="built_in">compile_model</span>(model, <span class="string">&quot;GPU&quot;</span>, gpu_config);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>ov::AnyMap</code> 是 OpenVINO 中灵活且强大的配置工具，用户可以根据需要动态设置和调整推理的行为，优化性能。结合设备特性和推理场景，灵活使用 <code>ov::AnyMap</code> 是提升模型部署效率的重要手段。如果需要针对某个配置参数的具体说明，请进一步告知！</p>
<h2 id="C-OpenVINO-ov-hint-performance-mode-详解"><a href="#C-OpenVINO-ov-hint-performance-mode-详解" class="headerlink" title="C++ OpenVINO ov::hint::performance_mode 详解"></a>C++ OpenVINO ov::hint::performance_mode 详解</h2><p>在 OpenVINO 的 C++ API 中，<code>ov::hint::performance_mode</code> 是一个用于优化推理性能的设置选项。它允许用户为推理过程选择不同的性能模式，以平衡吞吐量、延迟和设备资源利用率等方面的需求。</p>
<p>以下是对 <code>ov::hint::performance_mode</code> 的详解：</p>
<hr>
<h2 id="1-性能模式的类型"><a href="#1-性能模式的类型" class="headerlink" title="1. 性能模式的类型"></a>1. <strong>性能模式的类型</strong></h2><p><code>ov::hint::performance_mode</code> 支持以下几种模式，每种模式都有其适用场景：</p>
<h3 id="a-LATENCY"><a href="#a-LATENCY" class="headerlink" title="a. LATENCY"></a><strong>a. <code>LATENCY</code></strong></h3><ul>
<li><strong>描述</strong>: 优化以降低单次推理的延迟。</li>
<li><strong>应用场景</strong>:<ul>
<li>实时应用，如视频分析和在线推理。</li>
<li>延迟敏感的场景。</li>
</ul>
</li>
</ul>
<h3 id="b-THROUGHPUT"><a href="#b-THROUGHPUT" class="headerlink" title="b. THROUGHPUT"></a><strong>b. <code>THROUGHPUT</code></strong></h3><ul>
<li><strong>描述</strong>: 优化以提高设备的整体吞吐量，通常通过增加批处理大小和并行化执行。</li>
<li><strong>应用场景</strong>:<ul>
<li>离线批量处理。</li>
<li>批量推理任务，如图像分类。</li>
</ul>
</li>
</ul>
<h3 id="c-CUMULATIVE-THROUGHPUT"><a href="#c-CUMULATIVE-THROUGHPUT" class="headerlink" title="c. CUMULATIVE_THROUGHPUT"></a><strong>c. <code>CUMULATIVE_THROUGHPUT</code></strong></h3><ul>
<li><strong>描述</strong>: 专注于在多次推理任务中累积吞吐量的优化。</li>
<li><strong>应用场景</strong>:<ul>
<li>多模型部署。</li>
<li>并发推理任务的优化。</li>
</ul>
</li>
</ul>
<h3 id="d-UNDEFINED"><a href="#d-UNDEFINED" class="headerlink" title="d. UNDEFINED"></a><strong>d. <code>UNDEFINED</code></strong></h3><ul>
<li><strong>描述</strong>: 使用插件的默认性能配置，通常适用于简单场景或不确定优化需求时。</li>
<li><strong>应用场景</strong>:<ul>
<li>开发阶段。</li>
<li>初始实验。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-设置方式"><a href="#2-设置方式" class="headerlink" title="2. 设置方式"></a>2. <strong>设置方式</strong></h2><p>通过 <code>ov::Core</code> 或 <code>ov::CompiledModel</code> 对象设置性能模式。以下是示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openvino/openvino.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 OpenVINO Core 对象</span></span><br><span class="line">    ov::Core core;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型</span></span><br><span class="line">    <span class="keyword">auto</span> model = core.<span class="built_in">read_model</span>(<span class="string">&quot;model.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置性能模式</span></span><br><span class="line">    ov::AnyMap config = &#123;</span><br><span class="line">        &#123;ov::hint::performance_mode, ov::hint::PerformanceMode::LATENCY&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译模型并应用配置</span></span><br><span class="line">    <span class="keyword">auto</span> compiled_model = core.<span class="built_in">compile_model</span>(model, <span class="string">&quot;CPU&quot;</span>, config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行推理</span></span><br><span class="line">    <span class="keyword">auto</span> infer_request = compiled_model.<span class="built_in">create_infer_request</span>();</span><br><span class="line">    <span class="comment">// 推理逻辑...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-性能模式的影响"><a href="#3-性能模式的影响" class="headerlink" title="3. 性能模式的影响"></a>3. <strong>性能模式的影响</strong></h2><p>性能模式主要通过以下方式影响推理行为：</p>
<ul>
<li><strong>线程优化</strong>: 调整计算线程数、绑定策略等。</li>
<li><strong>批量处理</strong>: 增加或减少批处理大小。</li>
<li><strong>并行化策略</strong>: 优化并行计算的粒度和线程分配。</li>
</ul>
<hr>
<h2 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a>4. <strong>最佳实践</strong></h2><ul>
<li>在实时系统中，优先选择 <code>LATENCY</code>。</li>
<li>离线任务或批量处理，选择 <code>THROUGHPUT</code>。</li>
<li>如果部署多个模型，选择 <code>CUMULATIVE_THROUGHPUT</code>。</li>
<li>开发和测试阶段，可以先使用 <code>UNDEFINED</code>，然后根据实际需求调整。</li>
</ul>
<hr>
<h2 id="5-设备支持"><a href="#5-设备支持" class="headerlink" title="5. 设备支持"></a>5. <strong>设备支持</strong></h2><p>不同的设备插件（如 CPU、GPU、VPU 等）可能对性能模式的支持有细微差异。例如：</p>
<ul>
<li><strong>CPU</strong>: 支持所有性能模式，并提供多线程优化。</li>
<li><strong>GPU</strong>: 注重吞吐量优化，但延迟模式下可能受到硬件约束。</li>
<li><strong>VPU</strong>: 通常用于低功耗场景，优化吞吐量和延迟的权衡。</li>
</ul>
<p>了解设备特性和任务需求，有助于更好地选择性能模式。</p>
<hr>
<p>如果你有具体问题或需要针对某个场景的配置示例，请告诉我！</p>
<h2 id="OpenVINO-windows下环境配置教程"><a href="#OpenVINO-windows下环境配置教程" class="headerlink" title="OpenVINO windows下环境配置教程"></a>OpenVINO windows下环境配置教程</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.openvino.ai/2024/get-started/install-openvino/install-openvino-archive-windows.html">OpenVINO 安装指南</a></li>
</ul>
<h2 id="OpenVino-是什么"><a href="#OpenVino-是什么" class="headerlink" title="OpenVino 是什么"></a>OpenVino 是什么</h2><p>OpenVINO（Open Visual Inference and Neural Network Optimization）是一个由 <strong>Intel</strong> 提供的开源工具包，旨在加速深度学习模型的推理和优化，特别是在 Intel 硬件（如 CPU、GPU、FPGA 和 VPU）上的性能表现。它主要用于计算机视觉应用，但也支持其他类型的 AI 工作负载。</p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li><p><strong>模型优化</strong><br>OpenVINO 提供了模型优化器（Model Optimizer），可以将各种深度学习框架（如 TensorFlow、PyTorch、ONNX、Caffe 等）训练的模型转换为 OpenVINO 的中间表示格式（IR Format）。这可以帮助简化模型并提升推理效率。</p>
</li>
<li><p><strong>硬件加速</strong><br>支持在多种 Intel 硬件上运行，包括：  </p>
<ul>
<li>Intel CPU（尤其是使用了 AVX 和其他指令集优化）  </li>
<li>Intel 集成显卡（GPU）  </li>
<li>Intel Movidius VPU（视觉处理单元）  </li>
<li>Intel FPGA（可编程逻辑门阵列）</li>
</ul>
</li>
<li><p><strong>高效推理引擎</strong><br>OpenVINO 提供了推理引擎，可以通过异构计算同时利用多种硬件的优势，最大化推理性能。</p>
</li>
<li><p><strong>预训练模型和工具支持</strong><br>包括预训练的模型库（Open Model Zoo），以及一些便捷的 API 和开发工具，用于快速开发 AI 应用。</p>
</li>
<li><p><strong>跨平台支持</strong><br>OpenVINO 支持在各种操作系统上运行，包括 Linux、Windows 和 macOS。</p>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><strong>计算机视觉</strong>：如目标检测、图像分类、语义分割、人脸识别等。</li>
<li><strong>视频分析</strong>：如实时监控、行为分析、视频内容理解等。</li>
<li><strong>自然语言处理（NLP）</strong>：尽管主要面向视觉任务，但 OpenVINO 也支持 NLP 模型的优化和推理。</li>
<li><strong>嵌入式 AI</strong>：在资源受限的设备（如边缘设备）上运行优化的 AI 模型。</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol>
<li>提高推理速度，降低延迟。</li>
<li>支持多种硬件，灵活适应不同的部署需求。</li>
<li>开源且有丰富的文档和社区支持。</li>
<li>提供易用的 API，适合快速开发。</li>
</ol>
<p>如果你正在开发需要部署深度学习模型的应用，并且目标硬件是 Intel 平台，OpenVINO 是一个非常合适的选择。</p>
<h2 id="OpenVino-推理框架-详解"><a href="#OpenVino-推理框架-详解" class="headerlink" title="OpenVino 推理框架 详解"></a>OpenVino 推理框架 详解</h2><p>OpenVINO 的推理框架（Inference Framework）是 OpenVINO 工具包的核心组件之一，它负责高效地执行优化后的深度学习模型推理。以下是 OpenVINO 推理框架的详细解析：</p>
<hr>
<h3 id="1-核心组件"><a href="#1-核心组件" class="headerlink" title="1. 核心组件"></a><strong>1. 核心组件</strong></h3><h4 id="1-模型优化器（Model-Optimizer）"><a href="#1-模型优化器（Model-Optimizer）" class="headerlink" title="(1) 模型优化器（Model Optimizer）"></a><strong>(1) 模型优化器（Model Optimizer）</strong></h4><ul>
<li>将训练好的深度学习模型转换为 OpenVINO 的中间表示（Intermediate Representation，IR）格式。</li>
<li><strong>输入支持：</strong><ul>
<li>支持多种框架的模型，包括 TensorFlow、PyTorch、ONNX、Caffe 等。</li>
</ul>
</li>
<li><strong>优化方式：</strong><ul>
<li>图形优化（删除冗余运算节点）。</li>
<li>数据类型精简（如 FP32 转换为 FP16）。</li>
<li>插入专为 Intel 硬件设计的高效计算指令。</li>
</ul>
</li>
</ul>
<h4 id="2-推理引擎（Inference-Engine）"><a href="#2-推理引擎（Inference-Engine）" class="headerlink" title="(2) 推理引擎（Inference Engine）"></a><strong>(2) 推理引擎（Inference Engine）</strong></h4><ul>
<li>核心执行模块，负责加载优化后的 IR 模型并在目标硬件上高效运行。</li>
<li><strong>功能：</strong><ul>
<li>提供统一的 API 接口，支持多种硬件。</li>
<li>实现同步和异步推理（适用于实时和离线场景）。</li>
<li>自动分配推理负载到多个设备（如 CPU 和 GPU 同时工作）。</li>
</ul>
</li>
<li><strong>主要模块：</strong><ul>
<li><strong>核心对象（Core API）：</strong> 用于加载模型和配置设备。</li>
<li><strong>插件架构：</strong> 针对不同硬件有特定插件，如 CPU 插件、GPU 插件、VPU 插件。</li>
</ul>
</li>
</ul>
<h4 id="3-硬件支持层（Hardware-Abstraction-Layer）"><a href="#3-硬件支持层（Hardware-Abstraction-Layer）" class="headerlink" title="(3) 硬件支持层（Hardware Abstraction Layer）"></a><strong>(3) 硬件支持层（Hardware Abstraction Layer）</strong></h4><ul>
<li>提供针对 Intel 硬件优化的指令集（如 AVX、VNNI）。</li>
<li>支持的设备包括：<ul>
<li>CPU（使用线程优化和向量化技术）。</li>
<li>GPU（集成 GPU 的 OpenCL 加速）。</li>
<li>VPU（Movidius 芯片）。</li>
<li>FPGA（灵活可编程硬件）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a><strong>2. 工作流程</strong></h3><ol>
<li><strong>模型准备</strong><ul>
<li>从训练框架导出模型（如 <code>.pb</code>、<code>.onnx</code>、<code>.caffemodel</code>）。</li>
<li>使用模型优化器将模型转换为 IR 格式（包括 <code>.xml</code> 和 <code>.bin</code> 文件）。</li>
</ul>
</li>
<li><strong>加载模型</strong><ul>
<li>使用推理引擎的 Core API 加载 IR 模型到指定设备。</li>
</ul>
</li>
<li><strong>预处理</strong><ul>
<li>调整输入数据的格式（如大小、数据类型、归一化等）。</li>
</ul>
</li>
<li><strong>推理执行</strong><ul>
<li>调用推理引擎执行推理操作（支持同步或异步）。</li>
</ul>
</li>
<li><strong>后处理</strong><ul>
<li>对推理结果进行解码或进一步处理（如 NMS、标签映射等）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-编程接口"><a href="#3-编程接口" class="headerlink" title="3. 编程接口"></a><strong>3. 编程接口</strong></h3><h4 id="1-Python-API"><a href="#1-Python-API" class="headerlink" title="(1) Python API"></a><strong>(1) Python API</strong></h4><ul>
<li>简单易用，适合快速开发和原型验证。</li>
<li>样例代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openvino.runtime <span class="keyword">import</span> Core</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Core</span></span><br><span class="line">core = Core()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">model = core.read_model(model=<span class="string">&quot;model.xml&quot;</span>)</span><br><span class="line">compiled_model = core.compile_model(model=model, device_name=<span class="string">&quot;CPU&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推理</span></span><br><span class="line">input_data = ...  <span class="comment"># 预处理后的输入数据</span></span><br><span class="line">results = compiled_model([input_data])</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-C-API"><a href="#2-C-API" class="headerlink" title="(2) C++ API"></a><strong>(2) C++ API</strong></h4><ul>
<li>性能更高，适合生产级部署。</li>
<li>样例代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openvino/openvino.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ov::Core core;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载模型</span></span><br><span class="line">    <span class="keyword">auto</span> model = core.<span class="built_in">read_model</span>(<span class="string">&quot;model.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> compiled_model = core.<span class="built_in">compile_model</span>(model, <span class="string">&quot;CPU&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推理</span></span><br><span class="line">    ov::InferRequest infer_request = compiled_model.<span class="built_in">create_infer_request</span>();</span><br><span class="line">    infer_request.<span class="built_in">set_input_tensor</span>(...);  <span class="comment">// 设置输入</span></span><br><span class="line">    infer_request.<span class="built_in">infer</span>();</span><br><span class="line">    <span class="keyword">auto</span> output = infer_request.<span class="built_in">get_output_tensor</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-支持的推理模式"><a href="#4-支持的推理模式" class="headerlink" title="4. 支持的推理模式"></a><strong>4. 支持的推理模式</strong></h3><h4 id="1-同步推理"><a href="#1-同步推理" class="headerlink" title="(1) 同步推理"></a><strong>(1) 同步推理</strong></h4><ul>
<li>简单、顺序执行推理。</li>
<li>适合离线处理场景。</li>
</ul>
<h4 id="2-异步推理"><a href="#2-异步推理" class="headerlink" title="(2) 异步推理"></a><strong>(2) 异步推理</strong></h4><ul>
<li>非阻塞模式，可以在等待推理结果时并行执行其他任务。</li>
<li>适合实时场景，如视频流分析。</li>
</ul>
<hr>
<h3 id="5-优化特性"><a href="#5-优化特性" class="headerlink" title="5. 优化特性"></a><strong>5. 优化特性</strong></h3><h4 id="1-混合精度推理"><a href="#1-混合精度推理" class="headerlink" title="(1) 混合精度推理"></a><strong>(1) 混合精度推理</strong></h4><ul>
<li>支持 FP32、FP16 和 INT8 的混合精度计算。</li>
<li>使用 INT8 精度进一步提升性能，同时减少计算和内存开销。</li>
</ul>
<h4 id="2-多设备推理"><a href="#2-多设备推理" class="headerlink" title="(2) 多设备推理"></a><strong>(2) 多设备推理</strong></h4><ul>
<li>使用 Heterogeneous Plugin 实现负载均衡。</li>
<li>自动调度任务到最佳设备。</li>
</ul>
<h4 id="3-自定义层扩展"><a href="#3-自定义层扩展" class="headerlink" title="(3) 自定义层扩展"></a><strong>(3) 自定义层扩展</strong></h4><ul>
<li>支持用户定义的自定义操作，适配特定模型需求。</li>
</ul>
<hr>
<h3 id="6-应用场景"><a href="#6-应用场景" class="headerlink" title="6. 应用场景"></a><strong>6. 应用场景</strong></h3><ol>
<li><strong>实时视频分析</strong>（如安防监控、人流统计）。</li>
<li><strong>工业自动化</strong>（如缺陷检测、机器人视觉）。</li>
<li><strong>医疗影像处理</strong>（如肿瘤检测）。</li>
<li><strong>嵌入式 AI</strong>（如无人机、智能家居设备）。</li>
</ol>
<hr>
<h3 id="7-常用工具"><a href="#7-常用工具" class="headerlink" title="7. 常用工具"></a><strong>7. 常用工具</strong></h3><h4 id="1-Open-Model-Zoo"><a href="#1-Open-Model-Zoo" class="headerlink" title="(1) Open Model Zoo"></a><strong>(1) Open Model Zoo</strong></h4><ul>
<li>提供大量预训练模型，如 ResNet、YOLO、SSD。</li>
<li>方便快速测试和验证。</li>
</ul>
<h4 id="2-Benchmark-Tool"><a href="#2-Benchmark-Tool" class="headerlink" title="(2) Benchmark Tool"></a><strong>(2) Benchmark Tool</strong></h4><ul>
<li>测试模型在目标硬件上的性能。</li>
</ul>
<h4 id="3-Post-Training-Optimization-Toolkit-POT"><a href="#3-Post-Training-Optimization-Toolkit-POT" class="headerlink" title="(3) Post-Training Optimization Toolkit (POT)"></a><strong>(3) Post-Training Optimization Toolkit (POT)</strong></h4><ul>
<li>支持后量化（Post-training Quantization），提升推理性能。</li>
</ul>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>OpenVINO 推理框架通过模型优化器和推理引擎，实现高效的深度学习模型推理。其支持多种硬件设备，并提供丰富的优化选项，适用于多种 AI 应用场景，是一个功能强大、灵活且高效的推理工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/19/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-12-19-C++_10_43_system_error/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/19/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-12-19-C++_10_43_system_error/" class="post-title-link" itemprop="url">C++_10_43_system_error</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-19 09:00:00" itemprop="dateCreated datePublished" datetime="2024-12-19T09:00:00+08:00">2024-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><system_error>标准库相关学习笔记</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/12/19/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-12-19-C++_10_43_system_error/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/11/notebook/Tools/2024-12-11-Node/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/11/notebook/Tools/2024-12-11-Node/" class="post-title-link" itemprop="url">Node</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-11 10:00:00" itemprop="dateCreated datePublished" datetime="2024-12-11T10:00:00+08:00">2024-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p><strong>Node.js</strong>（简称 Node）是一个基于 <strong>V8 JavaScript 引擎</strong> 的开源、跨平台运行时环境，用于开发服务器端和网络应用程序。它将 JavaScript 从浏览器中解放出来，使开发者可以使用 JavaScript 构建后端服务和工具。</p>
<hr>
<h3 id="Node-js-的关键特性"><a href="#Node-js-的关键特性" class="headerlink" title="Node.js 的关键特性"></a><strong>Node.js 的关键特性</strong></h3><ol>
<li><p><strong>基于事件驱动和非阻塞 I&#x2F;O</strong><br>Node.js 使用异步事件驱动模型，支持高效的并发处理，非常适合构建 I&#x2F;O 密集型应用（如实时聊天、API 服务等）。</p>
</li>
<li><p><strong>单线程模型</strong><br>虽然 Node.js 是单线程的，但通过事件循环（Event Loop）和回调机制，它可以处理大量的并发连接，而无需为每个连接创建一个线程。</p>
</li>
<li><p><strong>NPM（Node Package Manager）</strong><br>Node.js 附带了 NPM，世界上最大的开源库生态系统。开发者可以使用 NPM 下载、管理和分享 JavaScript 包。</p>
</li>
<li><p><strong>跨平台</strong><br>Node.js 支持 Windows、macOS 和各种 Linux 系统。</p>
</li>
<li><p><strong>模块化系统</strong><br>Node.js 提供了模块化设计，开发者可以通过 <code>require</code> 导入模块，同时也可以创建自己的模块。</p>
</li>
</ol>
<hr>
<h3 id="Node-js-的应用场景"><a href="#Node-js-的应用场景" class="headerlink" title="Node.js 的应用场景"></a><strong>Node.js 的应用场景</strong></h3><ol>
<li><p><strong>Web 应用后端开发</strong>  </p>
<ul>
<li>使用 Node.js 和框架（如 Express.js）构建高效的 RESTful API 或实时 WebSocket 服务。</li>
<li>示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> res.<span class="title function_">send</span>(<span class="string">&#x27;Hello, Node.js!&#x27;</span>));</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server running on port 3000&#x27;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>实时应用程序</strong>  </p>
<ul>
<li>实现实时聊天、在线协作工具（如 Google Docs）或多人在线游戏。</li>
</ul>
</li>
<li><p><strong>工具与脚本开发</strong>  </p>
<ul>
<li>使用 Node.js 开发命令行工具或构建脚本。</li>
</ul>
</li>
<li><p><strong>微服务架构</strong>  </p>
<ul>
<li>Node.js 适合用作微服务的组件，通过轻量级的服务处理特定任务。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Node-js-的局限性"><a href="#Node-js-的局限性" class="headerlink" title="Node.js 的局限性"></a><strong>Node.js 的局限性</strong></h3><ol>
<li><p><strong>CPU 密集型任务的挑战</strong><br>Node.js 对 I&#x2F;O 密集型任务表现优秀，但单线程的特性限制了其在 CPU 密集型任务（如图像处理、大量计算）中的效率。</p>
</li>
<li><p><strong>回调地狱</strong><br>尽管可以通过 Promises 或 async&#x2F;await 改善，但在早期开发中，嵌套的回调可能会导致代码难以维护。</p>
</li>
</ol>
<hr>
<h3 id="如何安装-Node-js"><a href="#如何安装-Node-js" class="headerlink" title="如何安装 Node.js"></a><strong>如何安装 Node.js</strong></h3><ol>
<li><p>通过官方网站下载安装程序：<br><a target="_blank" rel="noopener" href="https://nodejs.org/">Node.js 官方下载页面</a></p>
</li>
<li><p>使用包管理工具安装：  </p>
<ul>
<li>macOS: 使用 Homebrew  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure></li>
<li>Linux: 使用包管理器（如 <code>apt</code> 或 <code>yum</code>）。</li>
</ul>
</li>
<li><p>验证安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v   <span class="comment"># 查看 Node.js 版本</span></span><br><span class="line">npm -v    <span class="comment"># 查看 NPM 版本</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a><strong>相关资源</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/en/docs/">Node.js 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.npmjs.com/">NPM 官方文档</a>  </li>
<li><a target="_blank" rel="noopener" href="https://github.com/nodejs/node">Node.js GitHub 仓库</a></li>
</ul>
<h2 id="npm-是什么"><a href="#npm-是什么" class="headerlink" title="npm 是什么"></a>npm 是什么</h2><p><strong>NPM</strong>，全称 <strong>Node Package Manager</strong>，是一个用于管理 Node.js 包（模块）和项目依赖关系的工具。NPM 是 Node.js 的默认包管理器，随 Node.js 一起安装，功能非常强大。</p>
<hr>
<h3 id="NPM-的主要功能"><a href="#NPM-的主要功能" class="headerlink" title="NPM 的主要功能"></a><strong>NPM 的主要功能</strong></h3><ol>
<li><p><strong>包管理（模块管理）</strong>  </p>
<ul>
<li>提供了世界上最大的 JavaScript 开源包生态系统，开发者可以轻松安装、更新和管理所需的库或模块。</li>
<li>常用命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package&gt;        <span class="comment"># 安装某个包</span></span><br><span class="line">npm uninstall &lt;package&gt;      <span class="comment"># 卸载某个包</span></span><br><span class="line">npm update                   <span class="comment"># 更新所有包</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>项目依赖管理</strong>  </p>
<ul>
<li>NPM 自动记录和管理项目的依赖项，通过 <code>package.json</code> 文件定义项目元数据及依赖项：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-project&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;express&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.18.2&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>包发布与分享</strong>  </p>
<ul>
<li>开发者可以通过 NPM 将自己的模块发布到 NPM 仓库，供其他人下载和使用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>运行脚本</strong>  </p>
<ul>
<li>在 <code>package.json</code> 文件中，开发者可以定义自定义脚本，通过 NPM 执行：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node app.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jest&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
运行方式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="NPM-的安装与使用"><a href="#NPM-的安装与使用" class="headerlink" title="NPM 的安装与使用"></a><strong>NPM 的安装与使用</strong></h3><ol>
<li><p><strong>NPM 安装</strong></p>
<ul>
<li>随 Node.js 一起安装，无需单独安装。</li>
<li>验证安装：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v  <span class="comment"># 显示 NPM 版本</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>常用命令</strong></p>
<ul>
<li><strong>安装依赖</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package&gt; --save       <span class="comment"># 安装依赖到项目中</span></span><br><span class="line">npm install &lt;package&gt; --save-dev  <span class="comment"># 安装开发依赖</span></span><br></pre></td></tr></table></figure></li>
<li><strong>全局安装</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g &lt;package&gt;  <span class="comment"># 全局安装</span></span><br></pre></td></tr></table></figure></li>
<li><strong>移除依赖</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall &lt;package&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用 NPM 初始化项目</strong><br>初始化一个新的 Node.js 项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<p>交互式生成 <code>package.json</code> 文件。</p>
</li>
</ol>
<hr>
<h3 id="NPM-与-Yarn-的比较"><a href="#NPM-与-Yarn-的比较" class="headerlink" title="NPM 与 Yarn 的比较"></a><strong>NPM 与 Yarn 的比较</strong></h3><ul>
<li><strong>速度</strong>：NPM 在 v5 之后显著优化了性能，但 Yarn 使用缓存技术在某些场景中更快。</li>
<li><strong>锁文件</strong>：NPM 使用 <code>package-lock.json</code>，而 Yarn 使用 <code>yarn.lock</code>。</li>
<li><strong>社区支持</strong>：NPM 的社区和生态系统比 Yarn 更大，但 Yarn 也很受欢迎。</li>
</ul>
<hr>
<h3 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a><strong>资源链接</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.npmjs.com/">NPM 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/">Node.js 官方网站</a></li>
</ul>
<p>如需进一步说明特定功能或命令的用法，请告诉我！</p>
<h2 id="npm-editorconfig包-是什么"><a href="#npm-editorconfig包-是什么" class="headerlink" title="npm editorconfig包 是什么"></a>npm editorconfig包 是什么</h2><p>在 NPM 中，与 <strong>EditorConfig</strong> 相关的包主要是用来解析、验证或与 EditorConfig 文件（<code>.editorconfig</code>）集成的工具。这些包旨在帮助开发者统一项目的代码风格规则并验证是否符合 EditorConfig 的定义。</p>
<p>以下是常见的与 EditorConfig 相关的 NPM 包及其用途：</p>
<hr>
<h3 id="1-editorconfig"><a href="#1-editorconfig" class="headerlink" title="1. editorconfig"></a><strong>1. editorconfig</strong></h3><ul>
<li><p><strong>简介</strong>：<br><code>editorconfig</code> 是一个用于解析 <code>.editorconfig</code> 文件的 Node.js 包。它允许开发者在代码中读取并应用 <code>.editorconfig</code> 定义的规则。</p>
</li>
<li><p><strong>安装</strong>：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install editorconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主要用途</strong>：  </p>
<ul>
<li>读取 <code>.editorconfig</code> 文件中的规则。</li>
<li>在开发工具或自定义脚本中应用 EditorConfig 规则。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> editorconfig = <span class="built_in">require</span>(<span class="string">&#x27;editorconfig&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> config = <span class="keyword">await</span> editorconfig.<span class="title function_">parse</span>(<span class="string">&#x27;.editorconfig&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(config);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>适用场景</strong>：  </p>
<ul>
<li>构建自定义格式化工具。</li>
<li>在构建或测试流程中验证文件是否符合 <code>.editorconfig</code> 规则。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-editorconfig-checker"><a href="#2-editorconfig-checker" class="headerlink" title="2. editorconfig-checker"></a><strong>2. editorconfig-checker</strong></h3><ul>
<li><p><strong>简介</strong>：<br><code>editorconfig-checker</code> 是一个用于检查项目文件是否符合 <code>.editorconfig</code> 定义的 CLI 工具。</p>
</li>
<li><p><strong>安装</strong>：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g editorconfig-checker</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主要用途</strong>：  </p>
<ul>
<li>在终端检查代码是否符合 <code>.editorconfig</code> 规则。</li>
<li>用于 CI&#x2F;CD 流程中的自动化验证。</li>
</ul>
</li>
<li><p><strong>使用方法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editorconfig-checker</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>提供清晰的错误报告。</li>
<li>支持忽略特定文件或目录。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-prettier-plugin-editorconfig"><a href="#3-prettier-plugin-editorconfig" class="headerlink" title="3. prettier-plugin-editorconfig"></a><strong>3. prettier-plugin-editorconfig</strong></h3><ul>
<li><p><strong>简介</strong>：<br>该插件将 Prettier 与 EditorConfig 结合，允许 Prettier 自动读取 <code>.editorconfig</code> 配置并应用到格式化规则中。</p>
</li>
<li><p><strong>安装</strong>：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev prettier prettier-plugin-editorconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主要用途</strong>：  </p>
<ul>
<li>使用 Prettier 的强大格式化功能，同时保持与 <code>.editorconfig</code> 一致。</li>
</ul>
</li>
<li><p><strong>使用方法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx prettier --write .</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特点</strong>：  </p>
<ul>
<li>无需重复定义规则。</li>
<li>自动应用 EditorConfig 配置。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-lint-staged-配合-EditorConfig"><a href="#4-lint-staged-配合-EditorConfig" class="headerlink" title="4. lint-staged (配合 EditorConfig)"></a><strong>4. lint-staged (配合 EditorConfig)</strong></h3><ul>
<li><p><strong>简介</strong>：<br><code>lint-staged</code> 是一个工具，用于在 Git 暂存文件上运行格式化工具。结合 EditorConfig 和格式化工具（如 Prettier），可以在提交代码前确保符合规则。</p>
</li>
<li><p><strong>安装</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev lint-staged</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置示例</strong>：<br>在 <code>package.json</code> 中：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;lint-staged&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;*.&#123;js,css,md&#125;&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;prettier --write&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;editorconfig-checker&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="推荐使用场景"><a href="#推荐使用场景" class="headerlink" title="推荐使用场景"></a><strong>推荐使用场景</strong></h3><ul>
<li>如果只需解析 <code>.editorconfig</code> 文件规则，用 <code>editorconfig</code> 包。</li>
<li>如果需要检查项目文件是否符合 EditorConfig，选择 <code>editorconfig-checker</code>。</li>
<li>如果希望格式化工具自动适配 <code>.editorconfig</code>，推荐使用 <code>prettier-plugin-editorconfig</code>。</li>
</ul>
<p>更多信息请访问 <a target="_blank" rel="noopener" href="https://editorconfig.org/">EditorConfig 官方网站</a> 和 <a target="_blank" rel="noopener" href="https://www.npmjs.com/">NPM</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/11/notebook/Tools/2024-12-11-iconv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/11/notebook/Tools/2024-12-11-iconv/" class="post-title-link" itemprop="url">iconv</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-11 10:00:00" itemprop="dateCreated datePublished" datetime="2024-12-11T10:00:00+08:00">2024-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="iconv-命令-详解"><a href="#iconv-命令-详解" class="headerlink" title="iconv 命令 详解"></a>iconv 命令 详解</h2><p><code>iconv</code> 是一个强大的字符编码转换工具，常用于在不同编码之间转换文件或字符串的编码格式。以下是对其常用功能和参数的详解：</p>
<hr>
<h3 id="命令基本格式"><a href="#命令基本格式" class="headerlink" title="命令基本格式"></a><strong>命令基本格式</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv [选项] -f &lt;原始编码&gt; -t &lt;目标编码&gt; [输入文件] -o [输出文件]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>-f</code></strong>: 指定输入文件的编码（<code>from</code>）。</li>
<li><strong><code>-t</code></strong>: 指定目标文件的编码（<code>to</code>）。</li>
<li><strong><code>-o</code></strong>: 指定输出文件（默认输出到标准输出）。</li>
</ul>
<hr>
<h3 id="常用参数详解"><a href="#常用参数详解" class="headerlink" title="常用参数详解"></a><strong>常用参数详解</strong></h3><ol>
<li><p><strong>基本参数</strong></p>
<ul>
<li>**<code>-f</code>**：指定原始文件的编码格式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f UTF-8 -t GBK input.txt</span><br></pre></td></tr></table></figure></li>
<li>**<code>-t</code>**：指定目标编码格式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f UTF-8 -t ISO-8859-1 input.txt &gt; output.txt</span><br></pre></td></tr></table></figure></li>
<li>**<code>-o</code>**：将输出保存到文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f UTF-8 -t GBK input.txt -o output.txt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>列出支持的编码</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -l</span><br></pre></td></tr></table></figure>
<p>该命令列出 <code>iconv</code> 支持的所有编码格式。</p>
</li>
<li><p><strong>处理标准输入</strong><br>使用管道将字符串直接传递给 <code>iconv</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你好，世界&quot;</span> | iconv -f UTF-8 -t GBK</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>忽略或替代无效字符</strong></p>
<ul>
<li><code>//IGNORE</code>: 忽略无法转换的字符。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f UTF-8 -t GBK//IGNORE input.txt -o output.txt</span><br></pre></td></tr></table></figure></li>
<li><code>//TRANSLIT</code>: 用近似字符替换无法转换的字符。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f UTF-8 -t ASCII//TRANSLIT input.txt -o output.txt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a><strong>示例用法</strong></h3><ol>
<li><p><strong>将文件从 UTF-8 转换为 GBK</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f UTF-8 -t GBK input.txt -o output.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将字符串从 GBK 转换为 UTF-8</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你好&quot;</span> | iconv -f GBK -t UTF-8</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转换整个目录的文件</strong><br>使用 <code>find</code> 和 <code>iconv</code> 的组合：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> iconv -f GBK -t UTF-8 &#123;&#125; -o converted_&#123;&#125; \;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>排查编码问题</strong><br>当文件中有乱码时，可以尝试转换为不同编码格式查看结果。</p>
</li>
</ol>
<hr>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ol>
<li><strong>文本文件国际化</strong>：在跨平台和多语言环境中转换文件编码。</li>
<li><strong>解决乱码问题</strong>：修复因编码不一致导致的显示错误。</li>
<li><strong>批量处理文件</strong>：通过脚本将大量文件的编码格式进行转换。</li>
</ol>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul>
<li>转换前确认文件的原始编码（例如通过工具 <code>file</code> 或 <code>chardet</code> 检测）。</li>
<li>在转换时，确保目标编码支持原始文件中的所有字符，否则可能会出现数据丢失。</li>
</ul>
<hr>
<p>更多参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man1/iconv.1.html">Linux iconv 手册</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/libc/manual/html_node/iconv-Invocation.html">GNU iconv 文档</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/11/notebook/BOOST/filesystem/2024-12-11-filesystem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/11/notebook/BOOST/filesystem/2024-12-11-filesystem/" class="post-title-link" itemprop="url">boost/filesystem概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-11 09:00:00" itemprop="dateCreated datePublished" datetime="2024-12-11T09:00:00+08:00">2024-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="boost-filesystem-详解"><a href="#boost-filesystem-详解" class="headerlink" title="boost&#x2F;filesystem 详解"></a>boost&#x2F;filesystem 详解</h2><p><strong>Boost.Filesystem</strong> 是 Boost 库中的一个模块，用于处理文件和目录操作。它提供了跨平台的接口，支持文件路径操作、文件系统查询、文件操作（如创建、删除、复制等），是开发跨平台文件管理工具的强大工具。</p>
<hr>
<h3 id="Boost-Filesystem-的主要功能"><a href="#Boost-Filesystem-的主要功能" class="headerlink" title="Boost.Filesystem 的主要功能"></a><strong>Boost.Filesystem 的主要功能</strong></h3><ol>
<li><p><strong>文件路径操作</strong>：</p>
<ul>
<li>支持创建、解析、合并和操作文件路径。</li>
<li>提供跨平台的路径表示方式，兼容 Windows 和 POSIX 系统。</li>
</ul>
</li>
<li><p><strong>文件和目录操作</strong>：</p>
<ul>
<li>创建、删除、重命名文件或目录。</li>
<li>检查文件是否存在，以及其类型（文件、目录、符号链接等）。</li>
</ul>
</li>
<li><p><strong>文件系统遍历</strong>：</p>
<ul>
<li>提供目录遍历功能，可递归列出文件和子目录。</li>
</ul>
</li>
<li><p><strong>文件属性查询</strong>：</p>
<ul>
<li>查询文件大小、修改时间、权限等元数据。</li>
</ul>
</li>
<li><p><strong>跨平台支持</strong>：</p>
<ul>
<li>通过统一接口屏蔽了不同平台文件系统之间的差异。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="核心类和函数"><a href="#核心类和函数" class="headerlink" title="核心类和函数"></a><strong>核心类和函数</strong></h3><h4 id="1-boost-filesystem-path"><a href="#1-boost-filesystem-path" class="headerlink" title="1. boost::filesystem::path"></a><strong>1. <code>boost::filesystem::path</code></strong></h4><p>表示文件或目录路径的类。</p>
<ul>
<li>构造路径：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="function">filesystem::path <span class="title">p</span><span class="params">(<span class="string">&quot;C:/example/file.txt&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Filename: &quot;</span> &lt;&lt; p.<span class="built_in">filename</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
<li>常用方法：<ul>
<li><code>filename()</code>：返回路径的文件名部分。</li>
<li><code>parent_path()</code>：返回父目录路径。</li>
<li><code>extension()</code>：返回文件扩展名。</li>
<li><code>replace_extension()</code>：替换文件扩展名。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-boost-filesystem-file-status"><a href="#2-boost-filesystem-file-status" class="headerlink" title="2. boost::filesystem::file_status"></a><strong>2. <code>boost::filesystem::file_status</code></strong></h4><p>表示文件的状态信息。</p>
<ul>
<li>常用方法：<ul>
<li><code>exists()</code>：检查文件是否存在。</li>
<li><code>is_regular_file()</code>：检查是否为常规文件。</li>
<li><code>is_directory()</code>：检查是否为目录。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-文件和目录操作函数"><a href="#3-文件和目录操作函数" class="headerlink" title="3. 文件和目录操作函数"></a><strong>3. 文件和目录操作函数</strong></h4><ul>
<li><p><strong>文件操作</strong>：</p>
<ul>
<li><code>boost::filesystem::copy_file()</code>：复制文件。</li>
<li><code>boost::filesystem::remove()</code>：删除文件或目录。</li>
<li><code>boost::filesystem::rename()</code>：重命名文件或目录。</li>
</ul>
</li>
<li><p><strong>目录操作</strong>：</p>
<ul>
<li><code>boost::filesystem::create_directory()</code>：创建目录。</li>
<li><code>boost::filesystem::remove_all()</code>：递归删除目录及其内容。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-目录遍历"><a href="#4-目录遍历" class="headerlink" title="4. 目录遍历"></a><strong>4. 目录遍历</strong></h4><p>使用 <code>directory_iterator</code> 和 <code>recursive_directory_iterator</code> 遍历目录内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::<span class="function">filesystem::path <span class="title">dir</span><span class="params">(<span class="string">&quot;C:/example&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : boost::filesystem::<span class="built_in">directory_iterator</span>(dir)) &#123;</span><br><span class="line">        std::cout &lt;&lt; entry.<span class="built_in">path</span>().<span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-文件属性查询"><a href="#5-文件属性查询" class="headerlink" title="5. 文件属性查询"></a><strong>5. 文件属性查询</strong></h4><ul>
<li><code>boost::filesystem::file_size()</code>：获取文件大小。</li>
<li><code>boost::filesystem::last_write_time()</code>：获取文件最后修改时间。</li>
<li><code>boost::filesystem::permissions()</code>：查询和设置文件权限。</li>
</ul>
<hr>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h3><h4 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a><strong>文件和目录操作</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = boost::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">fs::path <span class="title">dir</span><span class="params">(<span class="string">&quot;example_dir&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建目录</span></span><br><span class="line">    <span class="keyword">if</span> (!fs::<span class="built_in">exists</span>(dir)) &#123;</span><br><span class="line">        fs::<span class="built_in">create_directory</span>(dir);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Directory created: &quot;</span> &lt;&lt; dir.<span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件路径</span></span><br><span class="line">    fs::path file = dir / <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件</span></span><br><span class="line">    std::<span class="built_in">ofstream</span>(file.<span class="built_in">string</span>()) &lt;&lt; <span class="string">&quot;Hello, Boost.Filesystem!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File created: &quot;</span> &lt;&lt; file.<span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除文件和目录</span></span><br><span class="line">    fs::<span class="built_in">remove</span>(file);</span><br><span class="line">    fs::<span class="built_in">remove</span>(dir);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cleanup completed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a><strong>遍历目录</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = boost::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">fs::path <span class="title">dir</span><span class="params">(<span class="string">&quot;C:/example&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fs::<span class="built_in">exists</span>(dir) &amp;&amp; fs::<span class="built_in">is_directory</span>(dir)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : fs::<span class="built_in">recursive_directory_iterator</span>(dir)) &#123;</span><br><span class="line">            std::cout &lt;&lt; entry.<span class="built_in">path</span>().<span class="built_in">string</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Directory does not exist.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Boost-Filesystem-的优势"><a href="#Boost-Filesystem-的优势" class="headerlink" title="Boost.Filesystem 的优势"></a><strong>Boost.Filesystem 的优势</strong></h3><ol>
<li><strong>跨平台一致性</strong>：统一的 API 屏蔽了底层平台差异。</li>
<li><strong>丰富的功能</strong>：从路径操作到文件元数据查询应有尽有。</li>
<li><strong>与标准库兼容</strong>：部分功能被 C++17 的 <code>std::filesystem</code> 所采纳。</li>
</ol>
<hr>
<h3 id="Boost-Filesystem-与-C-标准库"><a href="#Boost-Filesystem-与-C-标准库" class="headerlink" title="Boost.Filesystem 与 C++ 标准库"></a><strong>Boost.Filesystem 与 C++ 标准库</strong></h3><ul>
<li>Boost.Filesystem 是 <code>std::filesystem</code> 的前身，其大部分功能已纳入 C++17 标准。</li>
<li>如果需要支持更老版本的 C++ 或使用扩展功能，Boost.Filesystem 仍是一个强大的工具。</li>
</ul>
<hr>
<h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a><strong>相关资源</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/release/libs/filesystem/">Boost.Filesystem 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/filesystem">C++ std::filesystem 文档</a></li>
</ul>
<p>如果需要更详细的示例或进一步的解释，可以继续讨论！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/11/notebook/BOOST/system/2024-12-11-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/11/notebook/BOOST/system/2024-12-11-system/" class="post-title-link" itemprop="url">boost/system概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-11 09:00:00" itemprop="dateCreated datePublished" datetime="2024-12-11T09:00:00+08:00">2024-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="boost-system模块-详解"><a href="#boost-system模块-详解" class="headerlink" title="boost&#x2F;system模块 详解"></a>boost&#x2F;system模块 详解</h2><p><strong>Boost.System</strong> 是 Boost 库中一个用于处理错误码和异常的模块，主要提供了跨平台和一致的方式来表示和管理系统错误码。在 C++ 应用中，<code>Boost.System</code> 可以帮助开发者高效地处理错误条件而无需依赖特定平台的实现。</p>
<hr>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a><strong>主要功能</strong></h3><ol>
<li><p>**错误码表示 (<code>error_code</code>)**：</p>
<ul>
<li>提供了一种类型安全的方式来表示错误状态。</li>
<li>与 C 风格的错误码（如 <code>errno</code>）相比，具有更强的类型检查和语义。</li>
<li>支持跨平台的错误码和错误信息。</li>
</ul>
</li>
<li><p>**错误条件 (<code>error_condition</code>)**：</p>
<ul>
<li>抽象出错误的通用表示，与特定的错误码关联。</li>
<li>允许开发者将不同来源的错误码映射为通用错误条件。</li>
</ul>
</li>
<li><p><strong>错误信息描述</strong>：</p>
<ul>
<li>提供对错误码的字符串化描述，便于日志记录和调试。</li>
</ul>
</li>
<li><p><strong>与标准库的集成</strong>：</p>
<ul>
<li>可与标准库中的异常类（如 <code>std::system_error</code>）一起使用。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a><strong>核心类</strong></h3><ol>
<li><p>**<code>boost::system::error_code</code>**：</p>
<ul>
<li>表示错误码，是一个值对象。</li>
<li>构造函数接收错误值和错误类别（<code>error_category</code>）。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/system/error_code.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::<span class="function">system::error_code <span class="title">ec</span><span class="params">(<span class="number">1</span>, boost::system::system_category())</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>常用方法：<ul>
<li><code>value()</code>：返回错误码值。</li>
<li><code>message()</code>：返回错误码的描述信息。</li>
<li><code>category()</code>：返回错误类别。</li>
</ul>
</li>
</ul>
</li>
<li><p>**<code>boost::system::error_condition</code>**：</p>
<ul>
<li>表示错误的通用条件，可以与 <code>error_code</code> 进行比较。</li>
<li>用于在不同平台上抽象出一致的错误行为。</li>
</ul>
</li>
<li><p>**<code>boost::system::system_category</code> 和 <code>boost::system::generic_category</code>**：</p>
<ul>
<li>两种常见的错误类别：<ul>
<li>**<code>system_category</code>**：用于与操作系统的本地错误码进行交互（如 Windows 的 <code>GetLastError</code> 或 Unix 的 <code>errno</code>）。</li>
<li>**<code>generic_category</code>**：提供跨平台的通用错误码表示。</li>
</ul>
</li>
</ul>
</li>
<li><p>**<code>boost::system::system_error</code>**：</p>
<ul>
<li>一个异常类，结合了 <code>error_code</code> 和错误信息。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/system/system_error.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> boost::system::<span class="built_in">system_error</span>(</span><br><span class="line">            boost::system::<span class="built_in">error_code</span>(<span class="number">1</span>, boost::system::<span class="built_in">system_category</span>()),</span><br><span class="line">            <span class="string">&quot;Operation failed&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> boost::system::system_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a><strong>典型使用场景</strong></h3><ol>
<li><p><strong>文件操作和网络通信</strong>：</p>
<ul>
<li>配合 <code>Boost.Asio</code> 使用，用于处理网络 I&#x2F;O 错误。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/system/error_code.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io;</span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line"></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> endpoints = resolver.<span class="built_in">resolve</span>(<span class="string">&quot;invalid.host&quot;</span>, <span class="string">&quot;80&quot;</span>, ec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resolved successfully!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>跨平台错误处理</strong>：</p>
<ul>
<li>在跨平台项目中统一管理错误码，避免操作系统特定实现带来的不一致。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h3><ol>
<li><strong>类型安全</strong>：通过强类型化错误码，减少了错误处理的歧义。</li>
<li><strong>跨平台支持</strong>：对系统错误的抽象使代码更具可移植性。</li>
<li><strong>与 Boost 和标准库的无缝集成</strong>：特别是与 <code>Boost.Asio</code> 的配合使用非常强大。</li>
</ol>
<hr>
<h3 id="与-C-标准库的对比"><a href="#与-C-标准库的对比" class="headerlink" title="与 C++ 标准库的对比"></a><strong>与 C++ 标准库的对比</strong></h3><ul>
<li>在 C++11 中，标准库引入了 <code>std::error_code</code> 和 <code>std::system_error</code>，功能与 <code>Boost.System</code> 类似。</li>
<li>Boost.System 是这些标准功能的原型，在某些场景下更为灵活和全面。</li>
</ul>
<hr>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><strong>参考文档</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/release/libs/system">Boost.System 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/release/libs/asio/">Boost.Asio 网络编程参考</a></li>
</ul>
<p>如果需要更具体的用法或示例，可以进一步展开！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/11/notebook/Compiler/LLVM/2024-12-11-clang-format/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/11/notebook/Compiler/LLVM/2024-12-11-clang-format/" class="post-title-link" itemprop="url">Clang-Format</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-11 09:00:00" itemprop="dateCreated datePublished" datetime="2024-12-11T09:00:00+08:00">2024-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="clang-format-是什么"><a href="#clang-format-是什么" class="headerlink" title="clang-format 是什么"></a>clang-format 是什么</h2><p><strong><code>clang-format</code></strong> 是一款由 LLVM 项目开发的代码格式化工具，用于自动格式化 C、C++、JavaScript、Objective-C、C# 等多种语言的源代码。它是开发者用于统一代码风格的高效工具，尤其适用于大型团队和项目。</p>
<hr>
<h3 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a><strong>功能特点</strong></h3><ol>
<li><p><strong>自动化代码格式化</strong><br><code>clang-format</code> 根据指定的格式规则（如缩进、空格、括号对齐）对代码进行调整，无需手动修改。</p>
</li>
<li><p><strong>支持多种配置</strong><br>使用 <code>.clang-format</code> 配置文件或命令行选项自定义规则。支持的规则包括：</p>
<ul>
<li>缩进宽度</li>
<li>括号的换行位置</li>
<li>操作符的对齐方式</li>
</ul>
</li>
<li><p><strong>支持集成开发环境 (IDE)</strong>  </p>
<ul>
<li>可以与主流 IDE（如 Visual Studio、VS Code、CLion 等）集成，提供即时格式化功能。</li>
<li>常用于 Git hook 自动格式化提交代码。</li>
</ul>
</li>
<li><p><strong>格式化范围灵活</strong>  </p>
<ul>
<li>可以格式化整个文件、指定的行范围，或者通过标准输入指定内容。</li>
</ul>
</li>
<li><p><strong>与版本控制配合</strong><br>可以使用 <code>git clang-format</code> 格式化特定的代码变更。</p>
</li>
</ol>
<hr>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><ul>
<li><p><strong>格式化文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format -i &lt;文件名&gt;</span><br></pre></td></tr></table></figure>
<p><code>-i</code> 参数表示直接修改文件。</p>
</li>
<li><p><strong>格式化部分代码：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format &lt; 文件名 &gt; 输出文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指定规则文件：</strong><br>使用 <code>.clang-format</code> 文件指定项目的格式化规则：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">Google</span></span><br><span class="line"><span class="attr">IndentWidth:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">ColumnLimit:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ol>
<li><strong>代码风格统一</strong>：在团队开发中避免因代码风格不一致导致的冲突。</li>
<li><strong>代码质量改进</strong>：提升代码可读性，减少代码审查的时间。</li>
<li><strong>快速代码格式调整</strong>：尤其适用于已有遗留代码的大规模格式化。</li>
</ol>
<hr>
<p>更多信息可参考：  </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ClangFormat.html">LLVM 官方文档</a>  </li>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/tree/main/clang/tools/clang-format">GitHub 项目页面</a></li>
</ul>
<h2 id="clang-format-常用参数-详解"><a href="#clang-format-常用参数-详解" class="headerlink" title="clang-format 常用参数 详解"></a>clang-format 常用参数 详解</h2><p><code>clang-format</code> 是一个强大的代码格式化工具，支持丰富的配置选项，以满足不同团队或项目的代码风格要求。以下是其常用参数及配置选项的详解：</p>
<hr>
<h3 id="命令行常用参数"><a href="#命令行常用参数" class="headerlink" title="命令行常用参数"></a><strong>命令行常用参数</strong></h3><ol>
<li><p><strong>基本操作</strong></p>
<ul>
<li><code>-i</code>: 直接修改原文件（in-place）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format -i example.cpp</span><br></pre></td></tr></table></figure></li>
<li><code>-style=&lt;style&gt;</code>: 指定格式风格，可以使用内置样式（如 <code>LLVM</code>, <code>Google</code>, <code>Chromium</code>）或自定义样式文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format -style=Google example.cpp</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>格式化范围</strong></p>
<ul>
<li><code>-lines=&lt;start&gt;:&lt;end&gt;</code>: 格式化指定行的代码。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format -lines=5:10 example.cpp</span><br></pre></td></tr></table></figure></li>
<li><code>-offset=&lt;offset&gt; -length=&lt;length&gt;</code>: 格式化指定偏移和长度的代码。</li>
</ul>
</li>
<li><p><strong>标准输入&#x2F;输出</strong></p>
<ul>
<li><code>-</code>: 从标准输入读取代码，格式化后输出到标准输出。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format - &lt; example.cpp &gt; formatted.cpp</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>其他参数</strong></p>
<ul>
<li><code>-dump-config</code>: 导出当前的 <code>.clang-format</code> 配置。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format -dump-config &gt; .clang-format</span><br></pre></td></tr></table></figure></li>
<li><code>-assume-filename=&lt;filename&gt;</code>: 假定文件名以便确定语言类型（如 <code>.cpp</code>, <code>.js</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="clang-format-配置文件常用选项"><a href="#clang-format-配置文件常用选项" class="headerlink" title=".clang-format 配置文件常用选项"></a><strong><code>.clang-format</code> 配置文件常用选项</strong></h3><p><code>.clang-format</code> 是一个 YAML 格式的文件，用于定义代码格式化规则。以下是常用选项：</p>
<h4 id="1-基础选项"><a href="#1-基础选项" class="headerlink" title="1. 基础选项"></a><strong>1. 基础选项</strong></h4><ul>
<li><p><code>BasedOnStyle</code>: 指定基础风格（<code>LLVM</code>, <code>Google</code>, <code>Chromium</code>, <code>Mozilla</code> 等）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">Google</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Language</code>: 指定语言（<code>Cpp</code>, <code>Java</code>, <code>JavaScript</code> 等）。</p>
</li>
</ul>
<h4 id="2-缩进与对齐"><a href="#2-缩进与对齐" class="headerlink" title="2. 缩进与对齐"></a><strong>2. 缩进与对齐</strong></h4><ul>
<li><p><code>IndentWidth</code>: 缩进的空格数。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">IndentWidth:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UseTab</code>: 是否使用 Tab 替代空格（<code>Never</code>, <code>ForIndentation</code>, <code>Always</code>）。</p>
</li>
<li><p><code>AlignConsecutiveAssignments</code>: 对齐连续的赋值语句。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">AlignConsecutiveAssignments:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-换行规则"><a href="#3-换行规则" class="headerlink" title="3. 换行规则"></a><strong>3. 换行规则</strong></h4><ul>
<li><p><code>ColumnLimit</code>: 每行代码的最大字符数。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ColumnLimit:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>BreakBeforeBraces</code>: 括号换行规则（<code>Attach</code>, <code>Linux</code>, <code>Allman</code>, <code>Stroustrup</code> 等）。</p>
</li>
</ul>
<h4 id="4-空格规则"><a href="#4-空格规则" class="headerlink" title="4. 空格规则"></a><strong>4. 空格规则</strong></h4><ul>
<li><p><code>SpaceBeforeParens</code>: 函数声明和调用括号前是否加空格。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SpaceBeforeParens:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SpacesInParentheses</code>: 括号内是否添加空格。</p>
</li>
</ul>
<h4 id="5-注释规则"><a href="#5-注释规则" class="headerlink" title="5. 注释规则"></a><strong>5. 注释规则</strong></h4><ul>
<li><code>SortIncludes</code>: 是否排序 include 语句。</li>
<li><code>ReflowComments</code>: 自动调整注释的行宽。</li>
</ul>
<hr>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a><strong>使用示例</strong></h3><ol>
<li><p>格式化整个项目代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.cpp&quot;</span> -o -name <span class="string">&quot;*.h&quot;</span> | xargs clang-format -i</span><br></pre></td></tr></table></figure>
</li>
<li><p>配合 Git，仅格式化改动的代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clang-format</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出当前项目的默认风格配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format -dump-config &gt; .clang-format</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="更多参考资料"><a href="#更多参考资料" class="headerlink" title="更多参考资料"></a><strong>更多参考资料</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ClangFormat.html">Clang-Format 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://zed0.co.uk/clang-format-configurator/">Clang-Format 配置样例</a></li>
</ul>
<p>如果需要帮助配置 <code>.clang-format</code>，请提供具体需求！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/10/notebook/Compiler/2024-12-10-msvc%E7%BC%96%E8%AF%91%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/10/notebook/Compiler/2024-12-10-msvc%E7%BC%96%E8%AF%91%E5%99%A8/" class="post-title-link" itemprop="url">MSVC编译器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-10 09:00:00" itemprop="dateCreated datePublished" datetime="2024-12-10T09:00:00+08:00">2024-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>windows下C++编程 相关学习笔记</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/12/10/notebook/Compiler/2024-12-10-msvc%E7%BC%96%E8%AF%91%E5%99%A8/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/03/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-12-03-python_3_pathlib%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/03/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-12-03-python_3_pathlib%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">python_3_pathlib模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-03 09:00:00" itemprop="dateCreated datePublished" datetime="2024-12-03T09:00:00+08:00">2024-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="python3-pathlib模块-详解"><a href="#python3-pathlib模块-详解" class="headerlink" title="python3 pathlib模块 详解"></a>python3 pathlib模块 详解</h2><p><code>pathlib</code> 是 Python 3.4 引入的标准库模块，用于处理文件和路径。它提供了面向对象的接口，简洁优雅，功能强大，是现代 Python 开发操作路径的推荐选择。</p>
<p>以下是对 <code>pathlib</code> 模块的详细介绍及用法：</p>
<hr>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h2><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br></pre></td></tr></table></figure>

<p><code>Path</code> 类是 <code>pathlib</code> 模块的核心。它抽象了不同操作系统文件路径的细节，支持跨平台操作。</p>
<hr>
<h2 id="2-创建-Path-对象"><a href="#2-创建-Path-对象" class="headerlink" title="2. 创建 Path 对象"></a><strong>2. 创建 <code>Path</code> 对象</strong></h2><h3 id="创建路径对象"><a href="#创建路径对象" class="headerlink" title="创建路径对象"></a>创建路径对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用字符串路径</span></span><br><span class="line">path = Path(<span class="string">&quot;/home/user/documents&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用相对路径</span></span><br><span class="line">relative_path = Path(<span class="string">&quot;documents/example.txt&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_dir = Path.cwd()</span><br><span class="line"><span class="built_in">print</span>(current_dir)</span><br></pre></td></tr></table></figure>

<h3 id="当前脚本所在目录"><a href="#当前脚本所在目录" class="headerlink" title="当前脚本所在目录"></a>当前脚本所在目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">script_dir = Path(__file__).resolve().parent</span><br><span class="line"><span class="built_in">print</span>(script_dir)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-路径的基本操作"><a href="#3-路径的基本操作" class="headerlink" title="3. 路径的基本操作"></a><strong>3. 路径的基本操作</strong></h2><h3 id="拼接路径"><a href="#拼接路径" class="headerlink" title="拼接路径"></a>拼接路径</h3><p>使用 <code>/</code> 运算符拼接路径，比字符串操作更简洁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user&quot;</span>) / <span class="string">&quot;documents&quot;</span> / <span class="string">&quot;example.txt&quot;</span></span><br><span class="line"><span class="built_in">print</span>(path)  <span class="comment"># 输出: /home/user/documents/example.txt</span></span><br></pre></td></tr></table></figure>

<h3 id="获取路径的父目录"><a href="#获取路径的父目录" class="headerlink" title="获取路径的父目录"></a>获取路径的父目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents/example.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(path.parent)  <span class="comment"># 输出: /home/user/documents</span></span><br></pre></td></tr></table></figure>

<h3 id="获取路径的各部分"><a href="#获取路径的各部分" class="headerlink" title="获取路径的各部分"></a>获取路径的各部分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents/example.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(path.name)       <span class="comment"># 输出: example.txt (文件名)</span></span><br><span class="line"><span class="built_in">print</span>(path.stem)       <span class="comment"># 输出: example (文件名去掉后缀)</span></span><br><span class="line"><span class="built_in">print</span>(path.suffix)     <span class="comment"># 输出: .txt (文件后缀)</span></span><br><span class="line"><span class="built_in">print</span>(path.parts)      <span class="comment"># 输出: (&#x27;/&#x27;, &#x27;home&#x27;, &#x27;user&#x27;, &#x27;documents&#x27;, &#x27;example.txt&#x27;)</span></span><br></pre></td></tr></table></figure>

<h3 id="判断路径类型"><a href="#判断路径类型" class="headerlink" title="判断路径类型"></a>判断路径类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents/example.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(path.is_file())  <span class="comment"># 检查是否是文件</span></span><br><span class="line"><span class="built_in">print</span>(path.is_dir())   <span class="comment"># 检查是否是目录</span></span><br></pre></td></tr></table></figure>

<h3 id="检查路径是否存在"><a href="#检查路径是否存在" class="headerlink" title="检查路径是否存在"></a>检查路径是否存在</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents/example.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(path.exists())  <span class="comment"># 检查路径是否存在</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-遍历目录"><a href="#4-遍历目录" class="headerlink" title="4. 遍历目录"></a><strong>4. 遍历目录</strong></h2><h3 id="遍历当前目录的文件和子目录"><a href="#遍历当前目录的文件和子目录" class="headerlink" title="遍历当前目录的文件和子目录"></a>遍历当前目录的文件和子目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> path.iterdir():</span><br><span class="line">    <span class="built_in">print</span>(item)  <span class="comment"># 输出目录下的文件和文件夹</span></span><br></pre></td></tr></table></figure>

<h3 id="递归遍历目录"><a href="#递归遍历目录" class="headerlink" title="递归遍历目录"></a>递归遍历目录</h3><p>使用 <code>glob()</code> 或 <code>rglob()</code> 查找符合模式的文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下所有 .txt 文件</span></span><br><span class="line"><span class="keyword">for</span> txt_file <span class="keyword">in</span> path.glob(<span class="string">&quot;*.txt&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(txt_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归查找所有 .txt 文件</span></span><br><span class="line"><span class="keyword">for</span> txt_file <span class="keyword">in</span> path.rglob(<span class="string">&quot;*.txt&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(txt_file)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5. 文件操作"></a><strong>5. 文件操作</strong></h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/new_folder&quot;</span>)</span><br><span class="line">path.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)  <span class="comment"># 创建目录，父目录不存在时自动创建</span></span><br></pre></td></tr></table></figure>

<h3 id="删除目录或文件"><a href="#删除目录或文件" class="headerlink" title="删除目录或文件"></a>删除目录或文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">file_path = Path(<span class="string">&quot;/home/user/example.txt&quot;</span>)</span><br><span class="line">file_path.unlink()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空目录</span></span><br><span class="line">dir_path = Path(<span class="string">&quot;/home/user/empty_folder&quot;</span>)</span><br><span class="line">dir_path.rmdir()</span><br></pre></td></tr></table></figure>

<h3 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_path = Path(<span class="string">&quot;/home/user/example.txt&quot;</span>)</span><br><span class="line">content = file_path.read_text(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>

<h3 id="写入文件内容"><a href="#写入文件内容" class="headerlink" title="写入文件内容"></a>写入文件内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_path = Path(<span class="string">&quot;/home/user/example.txt&quot;</span>)</span><br><span class="line">file_path.write_text(<span class="string">&quot;Hello, World!&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-路径比较"><a href="#6-路径比较" class="headerlink" title="6. 路径比较"></a><strong>6. 路径比较</strong></h2><p><code>pathlib</code> 支持路径的比较操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path1 = Path(<span class="string">&quot;/home/user/documents&quot;</span>)</span><br><span class="line">path2 = Path(<span class="string">&quot;/home/user/documents/example.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(path1 &lt; path2)  <span class="comment"># 比较路径字典序</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-高级功能"><a href="#7-高级功能" class="headerlink" title="7. 高级功能"></a><strong>7. 高级功能</strong></h2><h3 id="获取绝对路径"><a href="#获取绝对路径" class="headerlink" title="获取绝对路径"></a>获取绝对路径</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;documents/example.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(path.resolve())  <span class="comment"># 输出绝对路径</span></span><br></pre></td></tr></table></figure>

<h3 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_path = Path(<span class="string">&quot;/home/user/example.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(file_path.stat().st_size)  <span class="comment"># 文件大小（字节）</span></span><br></pre></td></tr></table></figure>

<h3 id="修改时间、创建时间等信息"><a href="#修改时间、创建时间等信息" class="headerlink" title="修改时间、创建时间等信息"></a>修改时间、创建时间等信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file_path = Path(<span class="string">&quot;/home/user/example.txt&quot;</span>)</span><br><span class="line">info = file_path.stat()</span><br><span class="line"><span class="built_in">print</span>(info.st_mtime)  <span class="comment"># 修改时间</span></span><br><span class="line"><span class="built_in">print</span>(info.st_ctime)  <span class="comment"># 创建时间</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-跨平台操作"><a href="#8-跨平台操作" class="headerlink" title="8. 跨平台操作"></a><strong>8. 跨平台操作</strong></h2><p><code>pathlib</code> 自动适配不同的操作系统，无需担心路径分隔符问题。<br>但如果需要明确使用 Windows 或 Posix 风格路径，可以使用 <code>PureWindowsPath</code> 或 <code>PurePosixPath</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> PureWindowsPath, PurePosixPath</span><br><span class="line"></span><br><span class="line">windows_path = PureWindowsPath(<span class="string">&quot;C:/Windows/System32&quot;</span>)</span><br><span class="line">posix_path = PurePosixPath(<span class="string">&quot;/home/user/documents&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-示例：批量重命名文件"><a href="#9-示例：批量重命名文件" class="headerlink" title="9. 示例：批量重命名文件"></a><strong>9. 示例：批量重命名文件</strong></h2><p>以下示例将目录下的所有 <code>.txt</code> 文件重命名为 <code>.bak</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> path.glob(<span class="string">&quot;*.txt&quot;</span>):</span><br><span class="line">    new_name = file.with_suffix(<span class="string">&quot;.bak&quot;</span>)</span><br><span class="line">    file.rename(new_name)</span><br></pre></td></tr></table></figure>

<hr>
<p><code>pathlib</code> 模块非常强大且易于使用，大大简化了文件和路径操作。如需进一步扩展或解决特定问题，请告诉我！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/03/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-12-03-python_3_zipfile%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/03/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-12-03-python_3_zipfile%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">python_3_zipfile模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-03 09:00:00" itemprop="dateCreated datePublished" datetime="2024-12-03T09:00:00+08:00">2024-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="python3-zipfile模块-详解"><a href="#python3-zipfile模块-详解" class="headerlink" title="python3 zipfile模块 详解"></a>python3 zipfile模块 详解</h2><p>Python 的 <code>zipfile</code> 模块用于处理 ZIP 文件。它支持创建、读取、写入、添加和解压 ZIP 文件。以下是对 <code>zipfile</code> 模块的详细介绍和用法。</p>
<hr>
<h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. <strong>基本用法</strong></h3><h4 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-创建-ZIP-文件"><a href="#2-创建-ZIP-文件" class="headerlink" title="2. 创建 ZIP 文件"></a>2. <strong>创建 ZIP 文件</strong></h3><h4 id="创建一个新-ZIP-文件并写入内容"><a href="#创建一个新-ZIP-文件并写入内容" class="headerlink" title="创建一个新 ZIP 文件并写入内容"></a>创建一个新 ZIP 文件并写入内容</h4><ul>
<li>模式选项：<ul>
<li><code>&#39;w&#39;</code>：创建一个新文件（如果文件已存在，将覆盖）。</li>
<li><code>&#39;a&#39;</code>：添加到现有的 ZIP 文件中。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.write(<span class="string">&#x27;file1.txt&#x27;</span>)  <span class="comment"># 添加文件到 ZIP 中</span></span><br><span class="line">    zipf.write(<span class="string">&#x27;file2.txt&#x27;</span>, arcname=<span class="string">&#x27;renamed_file2.txt&#x27;</span>)  <span class="comment"># 指定压缩时的文件名</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-读取-ZIP-文件"><a href="#3-读取-ZIP-文件" class="headerlink" title="3. 读取 ZIP 文件"></a>3. <strong>读取 ZIP 文件</strong></h3><h4 id="列出-ZIP-文件中的内容"><a href="#列出-ZIP-文件中的内容" class="headerlink" title="列出 ZIP 文件中的内容"></a>列出 ZIP 文件中的内容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    <span class="built_in">print</span>(zipf.namelist())  <span class="comment"># 列出压缩包内所有文件和目录</span></span><br></pre></td></tr></table></figure>

<h4 id="读取文件信息"><a href="#读取文件信息" class="headerlink" title="读取文件信息"></a>读取文件信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    <span class="keyword">for</span> info <span class="keyword">in</span> zipf.infolist():</span><br><span class="line">        <span class="built_in">print</span>(info.filename, info.file_size, info.compress_size)</span><br></pre></td></tr></table></figure>

<h4 id="解压-ZIP-文件"><a href="#解压-ZIP-文件" class="headerlink" title="解压 ZIP 文件"></a>解压 ZIP 文件</h4><ul>
<li><p>解压到当前目录：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.extractall()  <span class="comment"># 解压到当前目录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解压到指定目录：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.extractall(<span class="string">&#x27;output_directory&#x27;</span>)  <span class="comment"># 解压到指定目录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解压单个文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.extract(<span class="string">&#x27;file1.txt&#x27;</span>, <span class="string">&#x27;output_directory&#x27;</span>)  <span class="comment"># 解压指定文件到目录</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-追加文件到-ZIP"><a href="#4-追加文件到-ZIP" class="headerlink" title="4. 追加文件到 ZIP"></a>4. <strong>追加文件到 ZIP</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.write(<span class="string">&#x27;new_file.txt&#x27;</span>, arcname=<span class="string">&#x27;folder/new_file.txt&#x27;</span>)  <span class="comment"># 指定路径</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-压缩和解压密码保护的-ZIP-文件"><a href="#5-压缩和解压密码保护的-ZIP-文件" class="headerlink" title="5. 压缩和解压密码保护的 ZIP 文件"></a>5. <strong>压缩和解压密码保护的 ZIP 文件</strong></h3><h4 id="压缩带密码的-ZIP"><a href="#压缩带密码的-ZIP" class="headerlink" title="压缩带密码的 ZIP"></a>压缩带密码的 ZIP</h4><p>Python 的 <code>zipfile</code> 本身不支持加密 ZIP 文件，但可以使用第三方库如 <code>pyminizip</code> 或 <code>zipfile_with_password</code>。</p>
<h4 id="解压带密码的-ZIP"><a href="#解压带密码的-ZIP" class="headerlink" title="解压带密码的 ZIP"></a>解压带密码的 ZIP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;protected.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.extractall(pwd=<span class="string">b&#x27;password&#x27;</span>)  <span class="comment"># 密码需要以字节形式提供</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-检查文件是否为-ZIP"><a href="#6-检查文件是否为-ZIP" class="headerlink" title="6. 检查文件是否为 ZIP"></a>6. <strong>检查文件是否为 ZIP</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> zipfile.is_zipfile(<span class="string">&#x27;example.zip&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;是一个有效的 ZIP 文件&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不是有效的 ZIP 文件&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-高级操作"><a href="#7-高级操作" class="headerlink" title="7. 高级操作"></a>7. <strong>高级操作</strong></h3><h4 id="获取压缩信息"><a href="#获取压缩信息" class="headerlink" title="获取压缩信息"></a>获取压缩信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    info = zipf.getinfo(<span class="string">&#x27;file1.txt&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(info.filename)</span><br><span class="line">    <span class="built_in">print</span>(info.compress_type)  <span class="comment"># 压缩方式</span></span><br><span class="line">    <span class="built_in">print</span>(info.file_size)      <span class="comment"># 原始大小</span></span><br><span class="line">    <span class="built_in">print</span>(info.compress_size)  <span class="comment"># 压缩后大小</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义压缩级别"><a href="#自定义压缩级别" class="headerlink" title="自定义压缩级别"></a>自定义压缩级别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;compressed.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, compression=zipfile.ZIP_DEFLATED, compresslevel=<span class="number">9</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.write(<span class="string">&#x27;file1.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-支持的压缩类型"><a href="#8-支持的压缩类型" class="headerlink" title="8. 支持的压缩类型"></a>8. <strong>支持的压缩类型</strong></h3><ul>
<li><code>zipfile.ZIP_STORED</code>：不压缩。</li>
<li><code>zipfile.ZIP_DEFLATED</code>：标准压缩（需要 <code>zlib</code> 支持）。</li>
<li><code>zipfile.ZIP_BZIP2</code>：bzip2 压缩（需要 <code>bz2</code> 支持）。</li>
<li><code>zipfile.ZIP_LZMA</code>：LZMA 压缩（需要 <code>lzma</code> 支持）。</li>
</ul>
<hr>
<h3 id="9-完整示例：批量压缩文件"><a href="#9-完整示例：批量压缩文件" class="headerlink" title="9. 完整示例：批量压缩文件"></a>9. <strong>完整示例：批量压缩文件</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compress_directory</span>(<span class="params">dir_path, output_file</span>):</span><br><span class="line">    <span class="keyword">with</span> zipfile.ZipFile(output_file, <span class="string">&#x27;w&#x27;</span>, compression=zipfile.ZIP_DEFLATED) <span class="keyword">as</span> zipf:</span><br><span class="line">        <span class="keyword">for</span> foldername, subfolders, filenames <span class="keyword">in</span> os.walk(dir_path):</span><br><span class="line">            <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">                file_path = os.path.join(foldername, filename)</span><br><span class="line">                arcname = os.path.relpath(file_path, dir_path)</span><br><span class="line">                zipf.write(file_path, arcname)</span><br><span class="line"></span><br><span class="line">compress_directory(<span class="string">&#x27;my_folder&#x27;</span>, <span class="string">&#x27;archive.zip&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10-完整示例：批量解压-ZIP-文件"><a href="#10-完整示例：批量解压-ZIP-文件" class="headerlink" title="10. 完整示例：批量解压 ZIP 文件"></a>10. <strong>完整示例：批量解压 ZIP 文件</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_all</span>(<span class="params">zip_file, output_dir</span>):</span><br><span class="line">    <span class="keyword">with</span> zipfile.ZipFile(zip_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">        zipf.extractall(output_dir)</span><br><span class="line"></span><br><span class="line">extract_all(<span class="string">&#x27;archive.zip&#x27;</span>, <span class="string">&#x27;extracted_files&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>希望这些内容能帮助你全面理解 <code>zipfile</code> 模块！如需更详细的实例或功能扩展，请告诉我。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/20/notebook/Webfrontend/2024-11-20-HTML%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/20/notebook/Webfrontend/2024-11-20-HTML%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">HTML常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-20 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-20T09:00:00+08:00">2024-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Webfrontend/" itemprop="url" rel="index"><span itemprop="name">Webfrontend</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="html-实现分割线效果"><a href="#html-实现分割线效果" class="headerlink" title="html 实现分割线效果"></a>html 实现分割线效果</h2><p>在 HTML 中，分割线可以通过以下方式实现：</p>
<hr>
<h3 id="1-使用-标签"><a href="#1-使用-标签" class="headerlink" title="1. 使用 &lt;hr&gt; 标签"></a>1. <strong>使用 <code>&lt;hr&gt;</code> 标签</strong></h3><p><code>&lt;hr&gt;</code> 是 HTML 提供的默认分割线标签。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第一段文字。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二段文字。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><ul>
<li>默认生成一条水平分割线，占据页面的宽度。</li>
</ul>
<hr>
<h3 id="2-自定义分割线样式"><a href="#2-自定义分割线样式" class="headerlink" title="2. 自定义分割线样式"></a>2. <strong>自定义分割线样式</strong></h3><p>可以通过 CSS 自定义 <code>&lt;hr&gt;</code> 的样式，例如颜色、宽度、边框样式等。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;border: none; border-top: 2px solid #0078d7; width: 50%; margin: 20px auto;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="属性说明"><a href="#属性说明" class="headerlink" title="属性说明"></a>属性说明</h4><ul>
<li><strong><code>border: none;</code></strong> 去除默认边框。</li>
<li><strong><code>border-top: 2px solid #0078d7;</code></strong> 自定义分割线样式（颜色和粗细）。</li>
<li><strong><code>width: 50%;</code></strong> 设置分割线宽度。</li>
<li><strong><code>margin: 20px auto;</code></strong> 设置上下间距并居中。</li>
</ul>
<hr>
<h3 id="3-使用-CSS-before-或-after-创建分割线"><a href="#3-使用-CSS-before-或-after-创建分割线" class="headerlink" title="3. 使用 CSS :before 或 :after 创建分割线"></a>3. <strong>使用 CSS <code>:before</code> 或 <code>:after</code> 创建分割线</strong></h3><p>通过伪元素，分割线可以作为装饰效果使用。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center; position: relative; margin: 20px 0;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;background: white; padding: 0 10px; position: relative; z-index: 1;&quot;</span>&gt;</span>中间带文字的分割线<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;border: none; border-top: 1px solid #ccc; position: absolute; top: 50%; left: 0; width: 100%; z-index: 0;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><ul>
<li>在分割线中间插入文字。</li>
<li>利用伪元素或额外的 HTML 元素实现装饰效果。</li>
</ul>
<hr>
<h3 id="4-带图标或装饰的分割线"><a href="#4-带图标或装饰的分割线" class="headerlink" title="4. 带图标或装饰的分割线"></a>4. <strong>带图标或装饰的分割线</strong></h3><p>可以将图片或图标结合分割线，增加美观效果。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center; margin: 20px 0;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;border: none; border-top: 1px solid #ccc; width: 40%; display: inline-block;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 24px; margin: 0 10px;&quot;</span>&gt;</span>⭐<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;border: none; border-top: 1px solid #ccc; width: 40%; display: inline-block;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h4><ul>
<li>分割线两端显示图标或文字。</li>
</ul>
<hr>
<h3 id="5-渐变色分割线"><a href="#5-渐变色分割线" class="headerlink" title="5. 渐变色分割线"></a>5. <strong>渐变色分割线</strong></h3><p>通过 CSS 渐变实现更现代的分割线效果。</p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;border: none; height: 2px; background: linear-gradient(to right, #ff7e5f, #feb47b);&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h4><ul>
<li>分割线有渐变色效果。</li>
<li><strong><code>height: 2px;</code></strong> 设置分割线的高度。</li>
</ul>
<hr>
<h3 id="6-波浪形分割线"><a href="#6-波浪形分割线" class="headerlink" title="6. 波浪形分割线"></a>6. <strong>波浪形分割线</strong></h3><p>通过 SVG 或图片制作波浪形分割线。</p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; overflow: hidden;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 1440 320&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">fill</span>=<span class="string">&quot;#0099ff&quot;</span> <span class="attr">fill-opacity</span>=<span class="string">&quot;1&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M0,128L40,122.7C80,117,160,107,240,112C320,117,400,139,480,160C560,181,640,203,720,213.3C800,224,880,224,960,218.7C1040,213,1120,203,1200,192C1280,181,1360,171,1400,165.3L1440,160L1440,320L1400,320C1360,320,1280,320,1200,320C1120,320,1040,320,960,320C880,320,800,320,720,320C640,320,560,320,480,320C400,320,320,320,240,320C160,320,80,320,40,320L0,320Z&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="效果-4"><a href="#效果-4" class="headerlink" title="效果"></a>效果</h4><ul>
<li>波浪形动态分割线。</li>
<li>使用 <code>&lt;svg&gt;</code> 绘制分割线形状，可自定义填充颜色和路径。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>简单需求可以直接使用 <code>&lt;hr&gt;</code>。</li>
<li>自定义样式时可以结合 CSS 修改颜色、宽度或添加装饰。</li>
<li>高级需求（如波浪或渐变）可以使用 CSS 或 SVG 实现。</li>
</ul>
<h2 id="html-加粗字体"><a href="#html-加粗字体" class="headerlink" title="html 加粗字体"></a>html 加粗字体</h2><p>在 HTML 中，可以使用以下方法来加粗字体：</p>
<hr>
<h3 id="1-使用-标签-1"><a href="#1-使用-标签-1" class="headerlink" title="1. 使用 &lt;b&gt; 标签"></a>1. <strong>使用 <code>&lt;b&gt;</code> 标签</strong></h3><p><code>&lt;b&gt;</code> 标签用于加粗文本，但不会传递语义信息，仅是视觉效果。</p>
<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段普通文本，<span class="tag">&lt;<span class="name">b</span>&gt;</span>这是加粗的文本<span class="tag">&lt;/<span class="name">b</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-使用-标签"><a href="#2-使用-标签" class="headerlink" title="2. 使用 &lt;strong&gt; 标签"></a>2. <strong>使用 <code>&lt;strong&gt;</code> 标签</strong></h3><p><code>&lt;strong&gt;</code> 标签不仅加粗文本，还会传递语义信息，表示该内容是重要的。</p>
<h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>请注意：<span class="tag">&lt;<span class="name">strong</span>&gt;</span>此操作不可撤销<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-使用内联样式"><a href="#3-使用内联样式" class="headerlink" title="3. 使用内联样式"></a>3. <strong>使用内联样式</strong></h3><p>通过 CSS 的 <code>font-weight</code> 属性实现加粗效果。</p>
<h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是普通文本，<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: bold;&quot;</span>&gt;</span>这是加粗的文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-定义全局样式"><a href="#4-定义全局样式" class="headerlink" title="4. 定义全局样式"></a>4. <strong>定义全局样式</strong></h3><p>在样式表中定义 <code>font-weight</code> 属性，灵活控制加粗效果。</p>
<h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.bold-text</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>普通文本，<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;bold-text&quot;</span>&gt;</span>加粗文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-调整字体粗细"><a href="#5-调整字体粗细" class="headerlink" title="5. 调整字体粗细"></a>5. <strong>调整字体粗细</strong></h3><p>通过 <code>font-weight</code> 属性，你可以指定不同程度的字体粗细，例如 100（细）到 900（粗）。</p>
<h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>字体粗细示例：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: 400;&quot;</span>&gt;</span>普通字体（400）。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: 700;&quot;</span>&gt;</span>加粗字体（700）。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: 900;&quot;</span>&gt;</span>超粗字体（900）。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-结合其他标签"><a href="#6-结合其他标签" class="headerlink" title="6. 结合其他标签"></a>6. <strong>结合其他标签</strong></h3><p>可以将加粗效果与其他标签一起使用，如标题标签。</p>
<h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一级标题（加粗）。<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>这是二级标题，使用<span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span>标签加粗。<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
<th>推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;b&gt;</code></td>
<td>仅加粗文本，无语义</td>
<td>仅需要视觉加粗的场景</td>
</tr>
<tr>
<td><code>&lt;strong&gt;</code></td>
<td>加粗文本，表示重要性</td>
<td>需要强调内容的场景</td>
</tr>
<tr>
<td><code>font-weight</code></td>
<td>CSS 样式，灵活控制粗细</td>
<td>自定义粗细的场景</td>
</tr>
<tr>
<td>样式类（class）</td>
<td>全局样式复用</td>
<td>需要一致样式的场景</td>
</tr>
</tbody></table>
<p>根据需求选择适合的加粗方式！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/20/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-20-09-QWidget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/20/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-20-09-QWidget/" class="post-title-link" itemprop="url">QWidget</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-20 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-20T09:00:00+08:00">2024-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-Qt-QWidget-setStyleSheet-函数-详解"><a href="#C-Qt-QWidget-setStyleSheet-函数-详解" class="headerlink" title="C++ Qt QWidget::setStyleSheet()函数 详解"></a>C++ Qt QWidget::setStyleSheet()函数 详解</h2><p><code>QWidget::setStyleSheet()</code> 是 Qt 中用于设置控件样式表的函数，它允许开发者通过样式表（类似 CSS 的语法）自定义 Qt 控件的外观和行为。以下是对该函数的详细说明：</p>
<hr>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a><strong>函数定义</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setStyleSheet</span><span class="params">(<span class="type">const</span> QString &amp;styleSheet)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数</strong>:  <ul>
<li><code>styleSheet</code> 是一个包含样式表定义的字符串。</li>
</ul>
</li>
<li><strong>功能</strong>:  <ul>
<li>为控件设置或更改样式。</li>
<li>如果传入空字符串，则清除控件的样式表。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><p>使用 <code>setStyleSheet()</code> 可以方便地修改控件的外观。以下是一些常见的使用场景：</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Click Me&quot;</span>);</span><br><span class="line">button-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightblue; color: black; font-size: 18px;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>:<br>设置按钮的背景颜色为浅蓝色，文本颜色为黑色，字体大小为 18px。</p>
<hr>
<h3 id="设置多个属性"><a href="#设置多个属性" class="headerlink" title="设置多个属性"></a><strong>设置多个属性</strong></h3><p>通过使用 <code>;</code> 分隔，可以为控件设置多个样式属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, Qt!&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;border: 2px solid red; background-color: yellow; color: green;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>:<br>标签的边框变为 2px 的红色实线，背景为黄色，字体颜色为绿色。</p>
<hr>
<h3 id="针对子控件设置样式"><a href="#针对子控件设置样式" class="headerlink" title="针对子控件设置样式"></a><strong>针对子控件设置样式</strong></h3><p>通过样式表可以精确指定某个子控件的样式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button&quot;</span>);</span><br><span class="line">button-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton &#123; background-color: lightblue; &#125; QPushButton:hover &#123; background-color: yellow; &#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>:<br>按钮默认背景颜色为浅蓝色，当鼠标悬停在按钮上时，背景颜色变为黄色。</p>
<hr>
<h3 id="使用类名和对象名"><a href="#使用类名和对象名" class="headerlink" title="使用类名和对象名"></a><strong>使用类名和对象名</strong></h3><h4 id="使用类名"><a href="#使用类名" class="headerlink" title="使用类名"></a>使用类名</h4><p>可以为同一类的所有控件设置样式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QWidget *widget = <span class="keyword">new</span> QWidget;</span><br><span class="line">widget-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QLineEdit &#123; border: 2px solid green; &#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>:<br>应用到 <code>QWidget</code> 内的所有 <code>QLineEdit</code>。</p>
<h4 id="使用对象名"><a href="#使用对象名" class="headerlink" title="使用对象名"></a>使用对象名</h4><p>可以通过设置控件的 <code>objectName</code> 来定义特定控件的样式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QLineEdit *lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">lineEdit-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;specialLineEdit&quot;</span>);</span><br><span class="line">lineEdit-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;#specialLineEdit &#123; background-color: pink; &#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>:<br>仅为名为 <code>specialLineEdit</code> 的输入框设置样式。</p>
<hr>
<h3 id="支持的样式属性"><a href="#支持的样式属性" class="headerlink" title="支持的样式属性"></a><strong>支持的样式属性</strong></h3><p>Qt 样式表支持许多类似 CSS 的属性，包括但不限于：</p>
<ul>
<li><strong>颜色相关</strong>: <code>color</code>, <code>background-color</code>, <code>border-color</code></li>
<li><strong>字体相关</strong>: <code>font-size</code>, <code>font-family</code>, <code>font-style</code>, <code>font-weight</code></li>
<li><strong>边框相关</strong>: <code>border</code>, <code>border-radius</code>, <code>border-width</code>, <code>border-style</code></li>
<li><strong>间距和大小</strong>: <code>padding</code>, <code>margin</code>, <code>min-width</code>, <code>max-height</code></li>
</ul>
<hr>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol>
<li><strong>继承性</strong>:<ul>
<li>设置在父控件上的样式可能会影响其子控件，除非明确覆盖子控件的样式。</li>
</ul>
</li>
<li><strong>性能影响</strong>:<ul>
<li><code>setStyleSheet</code> 使用样式表可能会稍微影响性能，尤其是复杂样式或频繁修改样式时。</li>
</ul>
</li>
<li><strong>动态更新</strong>:<ul>
<li>若要动态更新样式，确保重新调用 <code>setStyleSheet()</code>。</li>
</ul>
</li>
<li><strong>调试样式</strong>:<ul>
<li>可以使用 <code>QSS</code> 文件来组织复杂的样式表，方便维护。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a><strong>完整示例</strong></h2><p>以下是一个完整的示例，展示如何为多个控件设置不同样式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;StyleSheet Example&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Enter your name:&quot;</span>);</span><br><span class="line">    QLineEdit *lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Submit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置样式</span></span><br><span class="line">    window.<span class="built_in">setStyleSheet</span>(</span><br><span class="line">        <span class="string">&quot;QLabel &#123; color: blue; font-size: 16px; &#125;&quot;</span></span><br><span class="line">        <span class="string">&quot;QLineEdit &#123; border: 2px solid gray; border-radius: 5px; padding: 5px; &#125;&quot;</span></span><br><span class="line">        <span class="string">&quot;QPushButton &#123; background-color: green; color: white; padding: 10px; border-radius: 10px; &#125;&quot;</span></span><br><span class="line">        <span class="string">&quot;QPushButton:hover &#123; background-color: lightgreen; &#125;&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">    window.<span class="built_in">setLayout</span>(layout);</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行效果</strong>:  </p>
<ul>
<li>标签文字为蓝色，字体大小为 16px。</li>
<li>输入框有灰色圆角边框和内边距。</li>
<li>按钮为绿色，鼠标悬停时变为浅绿色。</li>
</ul>
<hr>
<p>通过 <code>QWidget::setStyleSheet()</code>，开发者可以灵活地设计现代化、美观的用户界面。</p>
<h2 id="C-Qt-QWidget类-详解"><a href="#C-Qt-QWidget类-详解" class="headerlink" title="C++ Qt QWidget类 详解"></a>C++ Qt QWidget类 详解</h2><p>在 Qt 框架中，<code>QWidget</code> 类是所有用户界面对象的基类。它是 GUI 编程的核心部分，几乎所有的可视化组件（如按钮、标签、窗口等）都直接或间接地继承自 <code>QWidget</code>。以下是对 <code>QWidget</code> 类的详细说明：</p>
<hr>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h2><p><code>QWidget</code> 提供了创建和管理用户界面的基础功能。它负责处理：</p>
<ul>
<li><strong>绘制</strong>：管理窗口内容的绘制。</li>
<li><strong>事件</strong>：响应用户的输入事件（如鼠标点击、键盘输入等）。</li>
<li><strong>布局</strong>：安排子控件的位置和大小。</li>
<li><strong>窗口</strong>：管理窗口显示和属性（如标题、大小、样式等）。</li>
</ul>
<hr>
<h2 id="2-常用构造函数"><a href="#2-常用构造函数" class="headerlink" title="2. 常用构造函数"></a><strong>2. 常用构造函数</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QWidget</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>parent</code>:<ul>
<li>指定父控件。</li>
<li>若 <code>parent</code> 为 <code>nullptr</code>，该控件为顶层窗口。</li>
</ul>
</li>
<li><code>f</code>:<ul>
<li>指定窗口标志（如是否有边框、是否可调整大小等）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>顶层窗口和子控件</strong>:</p>
<ul>
<li>顶层窗口：<code>parent == nullptr</code>。</li>
<li>子控件：<code>parent != nullptr</code>，会自动嵌套在父控件中。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-常用功能"><a href="#3-常用功能" class="headerlink" title="3. 常用功能"></a><strong>3. 常用功能</strong></h2><h3 id="3-1-显示与隐藏"><a href="#3-1-显示与隐藏" class="headerlink" title="3.1 显示与隐藏"></a><strong>3.1 显示与隐藏</strong></h3><ul>
<li><p><strong>显示控件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>显示控件，控件会根据其父控件的关系自动安排位置。</p>
</li>
<li><p><strong>隐藏控件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hide</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全屏显示</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showFullScreen</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最大化、最小化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMaximized</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMinimized</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-2-设置控件属性"><a href="#3-2-设置控件属性" class="headerlink" title="3.2 设置控件属性"></a><strong>3.2 设置控件属性</strong></h3><ul>
<li><p><strong>大小和位置</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGeometry</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure>
<p>设置控件的位置和大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">geometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>获取控件的几何形状。</p>
</li>
<li><p><strong>窗口标题</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowTitle</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">windowTitle</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口图标</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"><span class="function">QIcon <span class="title">windowIcon</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口样式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowFlags</span><span class="params">(Qt::WindowFlags flags)</span></span>;</span><br><span class="line"><span class="function">Qt::WindowFlags <span class="title">windowFlags</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>背景颜色</strong><br>使用样式表设置背景颜色：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">widget-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightblue;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-3-布局管理"><a href="#3-3-布局管理" class="headerlink" title="3.3 布局管理"></a><strong>3.3 布局管理</strong></h3><p><code>QWidget</code> 提供了布局机制来自动调整子控件的位置和大小。常见的布局类包括：</p>
<ul>
<li><code>QVBoxLayout</code>：垂直布局</li>
<li><code>QHBoxLayout</code>：水平布局</li>
<li><code>QGridLayout</code>：网格布局</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;widget);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button 1&quot;</span>));</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button 2&quot;</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-事件处理"><a href="#3-4-事件处理" class="headerlink" title="3.4 事件处理"></a><strong>3.4 事件处理</strong></h3><ul>
<li><p><strong>鼠标事件</strong><br>重写 <code>mousePressEvent()</code> 以处理鼠标点击：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>键盘事件</strong><br>重写 <code>keyPressEvent()</code> 以处理键盘按键：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *event)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>绘制事件</strong><br>使用 <code>paintEvent()</code> 绘制自定义内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>示例：自定义绘制</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::paintEvent</span><span class="params">(QPaintEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(Qt::yellow);</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="built_in">rect</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-5-获取控件信息"><a href="#3-5-获取控件信息" class="headerlink" title="3.5 获取控件信息"></a><strong>3.5 获取控件信息</strong></h3><ul>
<li><p><strong>获取控件尺寸</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QSize <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取父控件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QWidget *<span class="title">parentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取子控件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QList&lt;QWidget *&gt; <span class="title">findChildren</span><span class="params">(<span class="type">const</span> QString &amp;name = QString(), Qt::FindChildOption options = Qt::FindChildrenRecursively)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="4-典型示例"><a href="#4-典型示例" class="headerlink" title="4. 典型示例"></a><strong>4. 典型示例</strong></h2><p>以下代码演示如何使用 <code>QWidget</code> 创建一个基本窗口，并添加一些子控件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QWidget Example&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加子控件</span></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, Qt!&quot;</span>, &amp;window);</span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Click Me&quot;</span>, &amp;window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局</span></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行效果</strong>:</p>
<ul>
<li>一个窗口显示“Hello, Qt!”标签和“Click Me”按钮，按钮点击时会响应默认行为。</li>
</ul>
<hr>
<h2 id="5-常用继承类"><a href="#5-常用继承类" class="headerlink" title="5. 常用继承类"></a><strong>5. 常用继承类</strong></h2><p><code>QWidget</code> 是许多常用控件的基类，包括：</p>
<ul>
<li><code>QMainWindow</code>：主窗口类，支持菜单栏、工具栏等。</li>
<li><code>QDialog</code>：对话框类。</li>
<li><code>QPushButton</code>、<code>QLabel</code>、<code>QLineEdit</code> 等具体控件。</li>
</ul>
<hr>
<h2 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a><strong>6. 注意事项</strong></h2><ol>
<li><strong>父子关系</strong>: <ul>
<li>子控件的生命周期由父控件管理，不需要手动删除。</li>
</ul>
</li>
<li><strong>事件处理</strong>:<ul>
<li>可通过重写事件处理函数（如 <code>paintEvent</code>、<code>mousePressEvent</code>）来自定义行为。</li>
</ul>
</li>
<li><strong>性能</strong>:<ul>
<li>在复杂界面中，合理使用布局和样式表可提升性能。</li>
</ul>
</li>
</ol>
<hr>
<p>通过 <code>QWidget</code>，可以轻松构建灵活、现代化的图形用户界面，同时还支持高度的自定义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/19/notebook/Qt/2024-11-19-qt_8_%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/19/notebook/Qt/2024-11-19-qt_8_%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">qt_8_消息循环机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-19 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-19T09:00:00+08:00">2024-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>Qt消息循环机制相关学习笔记</li>
</ul>
<h1 id="深入了解Qt消息循环及线程相关性"><a href="#深入了解Qt消息循环及线程相关性" class="headerlink" title="深入了解Qt消息循环及线程相关性"></a>深入了解Qt消息循环及线程相关性</h1><h2 id="什么是Qt消息循环"><a href="#什么是Qt消息循环" class="headerlink" title="什么是Qt消息循环"></a>什么是Qt消息循环</h2><ul>
<li><p>Qt消息循环，就是从一个队列中不断取出消息，并响应消息的过程。窗体的鼠标，键盘，输入法，绘制，各种消息，都来自于Qt的消息循环。</p>
</li>
<li><p>以Windows操作系统为例，Qt接管Windows原生窗口消息，并翻译成Qt的消息，派发给程序下的各个子对象，子QWidget等，通过接管层，可以很好屏蔽不同平台之间的差异性，开发人员不需要关心Windows或者X11的消息的差异性，只需要搞清楚各个QEvent之间是什么含义。</p>
</li>
<li><p>最开始的Qt消息循环开始于 QCoreApplication::exec。用户创建出一个QCoreApplication，或者说更多情况下是QApplication，执行QCoreApplication::exec，一个应用程序便开始了。QCoreApplication会不断从操作系统获取消息，并且分发给QObject。</p>
</li>
<li><p>如果没有消息循环，那么Qt的信号和槽无法完全使用。有些函数也无法正确执行。举个例子，通过QueuedConnection连接的信号，其实是将一个事件压入了消息循环，如果没有QCoreApplication::exec，那么这个消息循环将永远无法派发到指定的对象。</p>
</li>
</ul>
<h2 id="什么是线程相关性"><a href="#什么是线程相关性" class="headerlink" title="什么是线程相关性"></a>什么是线程相关性</h2><ul>
<li><p>准确来说，应该是指QObject的线程相关性。以Qt文档中的示意图来做说明</p>
</li>
<li><p>当我们创建一个QObject时，它会与创建自己所在的线程绑定，它参与的消息循环，其实是它所在线程的消息循环。加入某个线程没有默认的QThread::exec，那么该线程上的QObject则无法接收到事件。另外，如果两个不同线程的QObject需要相互通信，那么只能通过QueuedConnection的方式，异步通知对象线程，在下一轮消息循环处理QObject的消息。</p>
</li>
<li><p>QObject的线程相关性默认和它的parent保持一致。如果一个QObject没有parent，那么可以通过 moveToThread，将它的线程相关性切换到指定线程</p>
</li>
<li><p>了解QObject的线程相关性非常重要，很多初学者常常分不清一个多线程中哪些QObject应该由主线程创建，哪些应该由工作线程创建。我的观点是，它参与哪个消息循环，就由哪个来创建。</p>
</li>
<li><p>正因为这样的特性，我们才可以理解什么叫做AutoConnection。通过AutoConnection连接的两个QObject，如果是在同一个线程，那么可以直接调用DirectConnection，如果不是在同一个线程，那么就通过事件通知的方式QueueConnection来调用。通过信号和槽，事件或者QueuedConnection方式来进行线程间的通讯，尤其是与UI线程通讯，永远是最优雅的方式之一。</p>
</li>
</ul>
<h2 id="什么是消息循环"><a href="#什么是消息循环" class="headerlink" title="什么是消息循环"></a>什么是消息循环</h2><ul>
<li>关于消息循环的过程。</li>
<li>首先，用户通过GetMessage，PeekMessage等函数，从消息队列中取出事件，接下来，通过DispatchMessage来分发事件。系统将这个事件分发到对应的窗口处理函数WNDPROC中进行处理</li>
<li>在绝大部分GUI程序中，GetMessage，DispatchMessage是写在一个死循环中的，除非程序退出，否则会一直处理各种事件。</li>
</ul>
<h2 id="消息队列的相关性"><a href="#消息队列的相关性" class="headerlink" title="消息队列的相关性"></a>消息队列的相关性</h2><ul>
<li><p>参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/winmsg/about-messages-and-message-queues">https://docs.microsoft.com/zh-cn/windows/win32/winmsg/about-messages-and-message-queues</a></li>
</ul>
</li>
<li><p>系统将用创建某Window的线程来分发消息。例如窗体1在线程A创建，窗体2在线程B创建，那么它们的WNDPROC则是由不同线程来回调的。一般的，我们也只会在主线程中创建窗体，不过系统还是允许在各个线程中处理窗口的。</p>
</li>
</ul>
<h2 id="Qt消息循环的基础：窗体事件"><a href="#Qt消息循环的基础：窗体事件" class="headerlink" title="Qt消息循环的基础：窗体事件"></a>Qt消息循环的基础：窗体事件</h2><ul>
<li>在Windows中，要处理事件一定要有一个窗体，在Qt中，事件一共有两类，一类是和窗体无关的实践，例如QTimerEvent，另外一类就是常见的窗体事件，例如鼠标，键盘，绘制等事件。因此，qt至少有两个WNDPROC，一个处理Timer等事件，一个处理QWidget中的事件。</li>
<li>刚刚也提到，Windows事件其实是和线程相关的，那么也就是说，对于每一个QObject的对象，它必须要有自己所在线程的信息。不同线程的对象是无法直接通信的，要通过事件才可以。</li>
<li>在Qt中，消息循环在 QEventLoop 类中实现。通过QEventLoop::exec可以进入一个消息循环的阻塞状态中，也就是不断地PeekMessage-DispatchMessage。其实，QEventLoop里面几乎没有实现任何细节。</li>
<li>不难想到，QEventLoop通过内部的一层抽象，来不断从系统获取和处理消息，而这一层抽象，是和线程相关的。所有相同的线程，完全可以共用这层抽象。</li>
</ul>
<h1 id="qt-消息循环机制"><a href="#qt-消息循环机制" class="headerlink" title="qt 消息循环机制"></a>qt 消息循环机制</h1><p>在 Qt 中，消息循环机制是事件驱动编程的一部分，负责管理和调度事件的处理。在 Qt 应用程序中，消息循环是确保程序能够响应用户输入、窗口更新、定时器等事件的核心机制。理解 Qt 的消息循环机制对于开发交互式应用程序至关重要。</p>
<h3 id="Qt-消息循环机制概述"><a href="#Qt-消息循环机制概述" class="headerlink" title="Qt 消息循环机制概述"></a>Qt 消息循环机制概述</h3><p>Qt 的事件处理机制基于 <strong>事件队列</strong>，当事件发生时（例如用户点击按钮、输入文本、定时器超时等），事件被放入事件队列，然后通过事件循环逐一处理。事件循环会持续运行，直到应用程序退出。</p>
<h3 id="事件和消息"><a href="#事件和消息" class="headerlink" title="事件和消息"></a>事件和消息</h3><p>在 Qt 中，“事件”和“消息”通常是同义词，它们代表着某种需要处理的动作。常见的事件类型包括：</p>
<ul>
<li>用户输入事件：如 <code>QKeyEvent</code>（键盘输入）、<code>QMouseEvent</code>（鼠标点击或移动）</li>
<li>窗口事件：如 <code>QResizeEvent</code>（窗口大小调整）、<code>QCloseEvent</code>（窗口关闭事件）</li>
<li>定时器事件：如 <code>QTimerEvent</code>（定时器超时事件）</li>
<li>自定义事件：如通过 <code>QCoreApplication::postEvent()</code> 创建和发送的事件</li>
</ul>
<h3 id="消息循环的基本工作原理"><a href="#消息循环的基本工作原理" class="headerlink" title="消息循环的基本工作原理"></a>消息循环的基本工作原理</h3><p>Qt 的消息循环机制通过 <code>QCoreApplication::exec()</code> 函数启动。当调用 <code>exec()</code> 时，它会进入一个循环，等待并处理事件。这是消息循环的核心，它会处理所有传入的事件，直到程序结束或调用 <code>exit()</code> 函数。</p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li><strong>事件触发</strong>：当用户与程序交互时（如点击按钮、输入键盘、定时器触发等），相应的事件会被发送到事件队列。</li>
<li><strong>事件入队</strong>：事件会被放入一个队列中，等待处理。</li>
<li><strong>事件循环</strong>：<code>QCoreApplication::exec()</code> 会不断地从队列中取出事件并分发到合适的对象（通常是控件或窗口），然后调用相应的事件处理函数（如 <code>mousePressEvent()</code>、<code>keyPressEvent()</code> 等）。</li>
<li><strong>事件分发</strong>：当一个事件被取出后，Qt 会根据事件类型调用相应的处理函数。</li>
<li><strong>退出循环</strong>：当消息循环完成（例如用户请求退出程序或调用 <code>exit()</code>），消息循环结束，程序退出。</li>
</ol>
<h3 id="消息循环的代码示例"><a href="#消息循环的代码示例" class="headerlink" title="消息循环的代码示例"></a>消息循环的代码示例</h3><p>下面是一个典型的 Qt 程序结构，展示了消息循环的使用。</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;  <span class="comment">// 初始化应用程序，启动事件循环</span></span><br><span class="line"></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;点击我&quot;</span>)</span></span>;</span><br><span class="line">    button.<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">    button.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();  <span class="comment">// 启动事件循环，等待并处理事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个简单的例子中：</p>
<ol>
<li><code>QApplication app(argc, argv);</code> 会初始化应用程序。</li>
<li><code>button.show();</code> 显示按钮，等待用户交互。</li>
<li><code>app.exec();</code> 启动消息循环并等待处理用户事件（例如鼠标点击、键盘输入等）。</li>
</ol>
<p>当用户点击按钮时，Qt 会触发 <code>QPushButton</code> 的相关事件，如 <code>mousePressEvent()</code>，并调用相应的事件处理方法。</p>
<h3 id="Qt-事件循环的工作方式"><a href="#Qt-事件循环的工作方式" class="headerlink" title="Qt 事件循环的工作方式"></a>Qt 事件循环的工作方式</h3><h4 id="1-事件队列"><a href="#1-事件队列" class="headerlink" title="1. 事件队列"></a>1. <strong>事件队列</strong></h4><p>每个应用程序都有一个事件队列，用于存储需要处理的事件。事件队列是由操作系统和 Qt 内部管理的。当事件被触发时，它们会被放入队列。</p>
<h4 id="2-事件处理"><a href="#2-事件处理" class="headerlink" title="2. 事件处理"></a>2. <strong>事件处理</strong></h4><p>事件的处理通常是通过事件重载来实现的。例如，在自定义窗口类中，你可以重载 <code>mousePressEvent()</code> 来处理鼠标点击事件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;鼠标按下：位置 (&quot;</span> &lt;&lt; event-&gt;<span class="built_in">x</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; event-&gt;<span class="built_in">y</span>() &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-事件循环的执行"><a href="#3-事件循环的执行" class="headerlink" title="3. 事件循环的执行"></a>3. <strong>事件循环的执行</strong></h4><p>Qt 的事件循环会从事件队列中提取事件，并根据事件类型调用合适的事件处理函数。例如：</p>
<ul>
<li>如果事件是键盘输入，则会调用 <code>keyPressEvent()</code>。</li>
<li>如果事件是鼠标点击，则会调用 <code>mousePressEvent()</code>。</li>
</ul>
<h4 id="4-事件的优先级"><a href="#4-事件的优先级" class="headerlink" title="4. 事件的优先级"></a>4. <strong>事件的优先级</strong></h4><p>Qt 处理事件的顺序是由事件的类型和优先级决定的。通常，事件会按照到达顺序进行处理，但也可以通过改变事件的优先级来控制事件的处理顺序。</p>
<h3 id="自定义事件和事件发送"><a href="#自定义事件和事件发送" class="headerlink" title="自定义事件和事件发送"></a><strong>自定义事件和事件发送</strong></h3><p>你可以在 Qt 中发送自定义事件，甚至通过 <code>QCoreApplication::postEvent()</code> 来在事件队列中插入事件。自定义事件通常用于在不同对象之间传递信息。</p>
<h4 id="示例：自定义事件"><a href="#示例：自定义事件" class="headerlink" title="示例：自定义事件"></a>示例：自定义事件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEvent</span> : <span class="keyword">public</span> QEvent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyEvent</span>() : <span class="built_in">QEvent</span>(QEvent::User) &#123;&#125;  <span class="comment">// 设置自定义事件类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWidget</span> : <span class="keyword">public</span> QWidget &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">customEvent</span><span class="params">(QEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::User) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;处理自定义事件&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    MyWidget widget;</span><br><span class="line">    widget.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    QCoreApplication::<span class="built_in">postEvent</span>(&amp;widget, <span class="keyword">new</span> <span class="built_in">MyEvent</span>());  <span class="comment">// 发送自定义事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();  <span class="comment">// 启动事件循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>MyEvent</code> 是一个自定义事件，继承自 <code>QEvent</code>。在 <code>MyWidget</code> 中重载了 <code>customEvent()</code> 来处理这个事件。</p>
<h3 id="线程与消息循环"><a href="#线程与消息循环" class="headerlink" title="线程与消息循环"></a>线程与消息循环</h3><p>Qt 的事件循环通常与主线程相关。主线程是 Qt 应用程序的 GUI 线程，所有的界面更新和事件处理都在主线程中执行。如果你在其他线程中执行操作，必须确保线程安全。例如，可以使用 <code>QEventLoop</code> 或 <code>QTimer</code> 在非主线程中实现事件循环。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>消息循环</strong>是事件驱动编程的核心，确保 Qt 应用程序能够响应各种事件。</li>
<li>事件通过 <code>QCoreApplication::exec()</code> 启动并被依次处理。</li>
<li>Qt 会自动管理事件队列，触发事件时，事件会被推入队列，消息循环会逐一取出并调用相应的事件处理函数。</li>
<li>通过 <code>QEvent</code> 和 <code>QCoreApplication::postEvent()</code>，可以发送自定义事件，实现对象间的通信。</li>
</ul>
<p>Qt 的消息循环机制是事件驱动模型的一个典型实现，理解这一机制对于构建响应式、交互式的 GUI 应用程序至关重要。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/19/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-19-08-QLabel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/19/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-19-08-QLabel/" class="post-title-link" itemprop="url">QLabel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-19 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-19T09:00:00+08:00">2024-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="QLabel-setFixedSize-详解"><a href="#QLabel-setFixedSize-详解" class="headerlink" title="QLabel::setFixedSize() 详解"></a>QLabel::setFixedSize() 详解</h2><p><code>QLabel::setFixedSize()</code> 是 <code>QWidget</code> 类提供的方法，用于设置窗口或控件的固定大小，使其无法通过用户操作或布局管理器改变大小。</p>
<hr>
<h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a><strong>方法定义</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size</code>：通过 <code>QSize</code> 对象指定宽度和高度。</li>
<li><code>width</code>、<code>height</code>：直接指定宽度和高度的整数值。</li>
</ul>
<p>一旦调用了 <code>setFixedSize()</code>，控件或窗口的大小将固定，无法被用户拖动调整，也不会响应布局管理器的尺寸更改。</p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ol>
<li><strong>固定控件大小</strong>：<ul>
<li>某些控件需要保持固定大小，例如按钮、图标等。</li>
</ul>
</li>
<li><strong>弹窗或对话框</strong>：<ul>
<li>创建不可调整大小的窗口或对话框。</li>
</ul>
</li>
<li><strong>自定义 UI</strong>：<ul>
<li>精确控制控件的尺寸，不受布局管理器影响。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><h4 id="1-设置固定大小"><a href="#1-设置固定大小" class="headerlink" title="1. 设置固定大小"></a>1. 设置固定大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;固定大小的 QLabel&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>, <span class="number">100</span>); <span class="comment">// 宽 200px，高 100px</span></span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightblue;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<h4 id="2-使用-QSize-对象"><a href="#2-使用-QSize-对象" class="headerlink" title="2. 使用 QSize 对象"></a>2. 使用 <code>QSize</code> 对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;使用 QSize 设置固定大小&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setFixedSize</span>(<span class="built_in">QSize</span>(<span class="number">300</span>, <span class="number">150</span>)); <span class="comment">// 宽 300px，高 150px</span></span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightgreen;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="与其他方法的区别"><a href="#与其他方法的区别" class="headerlink" title="与其他方法的区别"></a><strong>与其他方法的区别</strong></h3><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>resize(int, int)</code></td>
<td>设置控件的当前大小，但大小可能会被用户调整或布局管理器覆盖。</td>
</tr>
<tr>
<td><code>setMinimumSize(int, int)</code></td>
<td>设置控件的最小大小，允许控件变大，但不能小于该值。</td>
</tr>
<tr>
<td><code>setMaximumSize(int, int)</code></td>
<td>设置控件的最大大小，允许控件变小，但不能大于该值。</td>
</tr>
<tr>
<td><code>setFixedSize()</code></td>
<td>同时设置最小大小和最大大小为相同值，从而固定控件大小，完全禁止大小变化。</td>
</tr>
</tbody></table>
<hr>
<h3 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a><strong>示例应用</strong></h3><h4 id="1-创建不可调整大小的窗口"><a href="#1-创建不可调整大小的窗口" class="headerlink" title="1. 创建不可调整大小的窗口"></a>1. 创建不可调整大小的窗口</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;这是一个固定大小的窗口&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::Window); <span class="comment">// 设置为独立窗口</span></span><br><span class="line">label-&gt;<span class="built_in">setFixedSize</span>(<span class="number">400</span>, <span class="number">300</span>);     <span class="comment">// 固定窗口大小</span></span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightyellow;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<h4 id="2-创建一个图标显示区域"><a href="#2-创建一个图标显示区域" class="headerlink" title="2. 创建一个图标显示区域"></a>2. 创建一个图标显示区域</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QLabel *iconLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">iconLabel-&gt;<span class="built_in">setFixedSize</span>(<span class="number">64</span>, <span class="number">64</span>); <span class="comment">// 固定大小为 64x64</span></span><br><span class="line">iconLabel-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/icons/sample_icon.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">64</span>, <span class="number">64</span>)); <span class="comment">// 设置图标</span></span><br><span class="line">iconLabel-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">iconLabel-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;border: 1px solid gray;&quot;</span>);</span><br><span class="line">iconLabel-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<h4 id="3-在布局中使用固定大小的控件"><a href="#3-在布局中使用固定大小的控件" class="headerlink" title="3. 在布局中使用固定大小的控件"></a>3. 在布局中使用固定大小的控件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line"></span><br><span class="line">    QLabel *label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;这是可调整大小的 QLabel&quot;</span>);</span><br><span class="line">    QLabel *label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;这是固定大小的 QLabel&quot;</span>);</span><br><span class="line">    label2-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label1);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label2);</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>label1</code> 的大小会随着布局调整，而 <code>label2</code> 的大小保持固定。</p>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>禁用大小调整</strong>：</p>
<ul>
<li>调用 <code>setFixedSize()</code> 后，控件或窗口将禁用用户拖动调整大小的功能。</li>
</ul>
</li>
<li><p><strong>优先级高于布局管理器</strong>：</p>
<ul>
<li>如果控件位于布局中，<code>setFixedSize()</code> 会覆盖布局管理器对控件大小的设置。</li>
</ul>
</li>
<li><p><strong>跨平台行为一致</strong>：</p>
<ul>
<li><code>setFixedSize()</code> 在不同平台上表现一致，无需担心平台差异。</li>
</ul>
</li>
<li><p><strong>与 <code>setMinimumSize</code> 和 <code>setMaximumSize</code> 的关系</strong>：</p>
<ul>
<li>调用 <code>setFixedSize()</code> 会同时设置最小和最大大小为同一个值，相当于调用了：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">widget-&gt;<span class="built_in">setMinimumSize</span>(width, height);</span><br><span class="line">widget-&gt;<span class="built_in">setMaximumSize</span>(width, height);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<p>通过 <code>setFixedSize()</code>，可以精确控制窗口或控件的大小，适用于需要固定尺寸的场景，例如弹窗、按钮、图标区域等，是构建稳定用户界面布局的重要工具。</p>
<h2 id="QLabel-setWindowFlags-详解"><a href="#QLabel-setWindowFlags-详解" class="headerlink" title="QLabel::setWindowFlags() 详解"></a>QLabel::setWindowFlags() 详解</h2><p><code>QLabel::setWindowFlags()</code> 是用于设置 <code>QLabel</code> 窗口标志的方法，继承自 <code>QWidget</code>。窗口标志（<code>Qt::WindowFlags</code>）定义了窗口的外观和行为特性，例如是否有边框、标题栏、是否是工具窗口等。</p>
<hr>
<h3 id="方法定义-1"><a href="#方法定义-1" class="headerlink" title="方法定义"></a><strong>方法定义</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLabel::setWindowFlags</span><span class="params">(Qt::WindowFlags flags)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>flags</code> 是一个 <code>Qt::WindowFlags</code> 类型，可以通过 <code>|</code> 运算符组合多个标志。</li>
<li>设置了特定标志后，会改变 <code>QLabel</code> 的窗口特性，比如是否显示为独立窗口、是否无边框、是否置顶等。</li>
</ul>
<hr>
<h3 id="常见的-Qt-WindowFlags"><a href="#常见的-Qt-WindowFlags" class="headerlink" title="常见的 Qt::WindowFlags"></a><strong>常见的 <code>Qt::WindowFlags</code></strong></h3><p>以下是常用的窗口标志及其作用：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Qt::Widget</code></td>
<td>默认值，表示普通窗口部件。</td>
</tr>
<tr>
<td><code>Qt::Window</code></td>
<td>将 <code>QLabel</code> 转换为顶层窗口，显示为独立窗口。</td>
</tr>
<tr>
<td><code>Qt::Dialog</code></td>
<td>将 <code>QLabel</code> 转换为对话框窗口（类似模态对话框）。</td>
</tr>
<tr>
<td><code>Qt::Tool</code></td>
<td>工具窗口，通常是小窗口，不会在任务栏显示，并总是置顶父窗口之上。</td>
</tr>
<tr>
<td><code>Qt::FramelessWindowHint</code></td>
<td>无边框窗口，不带标题栏和边框。</td>
</tr>
<tr>
<td><code>Qt::WindowStaysOnTopHint</code></td>
<td>窗口总是保持在其他窗口的上方。</td>
</tr>
<tr>
<td><code>Qt::WindowStaysOnBottomHint</code></td>
<td>窗口总是保持在其他窗口的下方。</td>
</tr>
<tr>
<td><code>Qt::CustomizeWindowHint</code></td>
<td>自定义窗口标志，必须手动添加需要的功能（如标题栏）。</td>
</tr>
<tr>
<td><code>Qt::SplashScreen</code></td>
<td>用于启动画面窗口。</td>
</tr>
<tr>
<td><code>Qt::SubWindow</code></td>
<td>作为子窗口嵌套在父窗口中。</td>
</tr>
<tr>
<td><code>Qt::Popup</code></td>
<td>弹出窗口，常用于右键菜单或选择框。</td>
</tr>
<tr>
<td><code>Qt::WindowCloseButtonHint</code></td>
<td>显示关闭按钮（标题栏需要 <code>Qt::Window</code> 或相关标志）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a><strong>用法示例</strong></h3><h4 id="1-普通窗口"><a href="#1-普通窗口" class="headerlink" title="1. 普通窗口"></a>1. <strong>普通窗口</strong></h4><p><code>QLabel</code> 默认是作为子窗口（<code>Qt::Widget</code>）存在的。如果需要显示为独立窗口，可以设置为 <code>Qt::Window</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;这是一个普通窗口&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::Window);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-无边框窗口"><a href="#2-无边框窗口" class="headerlink" title="2. 无边框窗口"></a>2. <strong>无边框窗口</strong></h4><p>可以移除标题栏和边框，用于自定义窗口或提示框。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;无边框窗口&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightblue; padding: 10px;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-工具窗口"><a href="#3-工具窗口" class="headerlink" title="3. 工具窗口"></a>3. <strong>工具窗口</strong></h4><p>将窗口设置为工具窗口，使其成为一个小型的、总是置顶的辅助窗口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;工具窗口&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::Tool | Qt::WindowStaysOnTopHint);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightgreen; padding: 10px;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-自定义标题栏窗口"><a href="#4-自定义标题栏窗口" class="headerlink" title="4. 自定义标题栏窗口"></a>4. <strong>自定义标题栏窗口</strong></h4><p>使用 <code>Qt::CustomizeWindowHint</code> 自定义窗口功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;自定义标题栏窗口&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::Window | Qt::CustomizeWindowHint | Qt::WindowCloseButtonHint);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-弹出窗口"><a href="#5-弹出窗口" class="headerlink" title="5. 弹出窗口"></a>5. <strong>弹出窗口</strong></h4><p>使用 <code>Qt::Popup</code> 将窗口设置为弹出窗口，例如右键菜单或工具选择器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;弹出窗口&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::Popup);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: yellow; padding: 10px;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-启动画面窗口"><a href="#6-启动画面窗口" class="headerlink" title="6. 启动画面窗口"></a>6. <strong>启动画面窗口</strong></h4><p>使用 <code>Qt::SplashScreen</code> 设置窗口为启动画面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;启动画面&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::SplashScreen);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: orange; padding: 10px;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见问题与注意事项"><a href="#常见问题与注意事项" class="headerlink" title="常见问题与注意事项"></a><strong>常见问题与注意事项</strong></h3><ol>
<li><p><strong>无边框后窗口无法移动</strong></p>
<ul>
<li>无边框窗口（<code>Qt::FramelessWindowHint</code>）会失去默认的拖动功能，需要手动实现鼠标拖动。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::LeftButton) &#123;</span><br><span class="line">        dragStartPosition = event-&gt;<span class="built_in">globalPos</span>() - <span class="built_in">frameGeometry</span>().<span class="built_in">topLeft</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton) &#123;</span><br><span class="line">        <span class="built_in">move</span>(event-&gt;<span class="built_in">globalPos</span>() - dragStartPosition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>标志的组合</strong></p>
<ul>
<li>窗口标志可以通过 <code>|</code> 运算符组合使用，但某些标志可能会互相覆盖，例如 <code>Qt::FramelessWindowHint</code> 和 <code>Qt::WindowCloseButtonHint</code> 一起使用时，关闭按钮不会显示。</li>
</ul>
</li>
<li><p><strong>父子关系影响</strong></p>
<ul>
<li>如果设置了父窗口，窗口标志的行为可能受影响。例如，<code>Qt::WindowStaysOnTopHint</code> 的窗口总是置顶，但只会置顶于父窗口之上。</li>
</ul>
</li>
<li><p><strong>跨平台差异</strong></p>
<ul>
<li>不同平台对某些窗口标志的支持可能存在差异。例如，某些 Linux 窗口管理器可能不支持 <code>Qt::WindowStaysOnBottomHint</code>。</li>
</ul>
</li>
</ol>
<hr>
<p>通过 <code>setWindowFlags()</code>，可以灵活控制 <code>QLabel</code> 的显示行为，让其满足各种场景需求，如独立窗口、无边框窗口、工具窗口等。</p>
<h2 id="C-QLabel类-详解"><a href="#C-QLabel类-详解" class="headerlink" title="C++ QLabel类 详解"></a>C++ QLabel类 详解</h2><p><code>QLabel</code> 是 Qt 框架中用于显示文本或图像的控件类。它是一个简单的 GUI 元素，适用于需要显示静态文本、动态文本或图像的场景。</p>
<p>以下是对 <code>QLabel</code> 类的详解：</p>
<hr>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a><strong>基本功能</strong></h3><p><code>QLabel</code> 的主要功能是：</p>
<ol>
<li>显示文本（静态文本、HTML 格式文本、动态更新的文本）。</li>
<li>显示图片。</li>
<li>可作为提示信息的承载控件。</li>
<li>支持丰富的文本格式，包括纯文本、HTML 和样式化文本。</li>
</ol>
<hr>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QLabel</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"><span class="built_in">QLabel</span>(<span class="type">const</span> QString &amp;text, QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>text</code>：初始显示的文本。</li>
<li><code>parent</code>：父窗口指针。</li>
<li><code>f</code>：窗口标志，通常保持默认值。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, QLabel!&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h3><h4 id="1-设置文本"><a href="#1-设置文本" class="headerlink" title="1. 设置文本"></a><strong>1. 设置文本</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">text</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置或获取 QLabel 的显示文本。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;New Text&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-设置对齐方式"><a href="#2-设置对齐方式" class="headerlink" title="2. 设置对齐方式"></a><strong>2. 设置对齐方式</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlignment</span><span class="params">(Qt::Alignment alignment)</span></span>;</span><br><span class="line"><span class="function">Qt::Alignment <span class="title">alignment</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置文本或图片的对齐方式。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-设置图片"><a href="#3-设置图片" class="headerlink" title="3. 设置图片"></a><strong>3. 设置图片</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPixmap</span><span class="params">(<span class="type">const</span> QPixmap &amp;pixmap)</span></span>;</span><br><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置 QLabel 显示的图片。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/images/logo.png&quot;</span>)</span></span>;</span><br><span class="line">label-&gt;<span class="built_in">setPixmap</span>(pixmap);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-自动调整大小"><a href="#4-自动调整大小" class="headerlink" title="4. 自动调整大小"></a><strong>4. 自动调整大小</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScaledContents</span><span class="params">(<span class="type">bool</span> scaled)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasScaledContents</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>控制 QLabel 是否根据内容自动调整大小。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-设置文本格式"><a href="#5-设置文本格式" class="headerlink" title="5. 设置文本格式"></a><strong>5. 设置文本格式</strong></h4><ul>
<li><strong>支持 HTML 格式的文本显示</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTextFormat</span><span class="params">(Qt::TextFormat format)</span></span>;</span><br><span class="line"><span class="function">Qt::TextFormat <span class="title">textFormat</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>常用格式包括 <code>Qt::PlainText</code>、<code>Qt::RichText</code> 和 <code>Qt::AutoText</code>。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;&lt;b&gt;Bold Text&lt;/b&gt;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-设置文本样式"><a href="#6-设置文本样式" class="headerlink" title="6. 设置文本样式"></a><strong>6. 设置文本样式</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setStyleSheet</span><span class="params">(<span class="type">const</span> QString &amp;styleSheet)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置 QLabel 的样式表。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;color: red; font-size: 16px;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-获取文本尺寸"><a href="#7-获取文本尺寸" class="headerlink" title="7. 获取文本尺寸"></a><strong>7. 获取文本尺寸</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QSize <span class="title">sizeHint</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回 QLabel 当前内容建议的尺寸。</li>
</ul>
<h4 id="8-设置提示信息"><a href="#8-设置提示信息" class="headerlink" title="8. 设置提示信息"></a><strong>8. 设置提示信息</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setToolTip</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>为 QLabel 设置提示信息。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setToolTip</span>(<span class="string">&quot;This is a QLabel&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-清除内容"><a href="#9-清除内容" class="headerlink" title="9. 清除内容"></a><strong>9. 清除内容</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>清空 QLabel 的内容。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a><strong>信号与槽</strong></h3><p><code>QLabel</code> 本身不直接提供信号，但可以通过事件或自定义逻辑配合使用。例如，结合鼠标事件使 QLabel 响应点击：</p>
<ul>
<li>重写 <code>mousePressEvent</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClickableLabel</span> : <span class="keyword">public</span> QLabel &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ClickableLabel</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span> : QLabel(parent) &#123;</span>&#125;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="function">emit <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line">        QLabel::<span class="built_in">mousePressEvent</span>(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>使用自定义 <code>clicked</code> 信号。</li>
</ul>
<hr>
<h3 id="QLabel-示例代码"><a href="#QLabel-示例代码" class="headerlink" title="QLabel 示例代码"></a><strong>QLabel 示例代码</strong></h3><h4 id="纯文本显示"><a href="#纯文本显示" class="headerlink" title="纯文本显示"></a><strong>纯文本显示</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(<span class="string">&quot;Hello, QLabel!&quot;</span>)</span></span>;</span><br><span class="line">    label.<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    label.<span class="built_in">setStyleSheet</span>(<span class="string">&quot;font-size: 20px; color: blue;&quot;</span>);</span><br><span class="line">    label.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a><strong>显示图片</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QLabel label;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/images/logo.png&quot;</span>)</span></span>;</span><br><span class="line">    label.<span class="built_in">setPixmap</span>(pixmap);</span><br><span class="line">    label.<span class="built_in">setScaledContents</span>(<span class="literal">true</span>); <span class="comment">// 图片自动适应 QLabel 大小</span></span><br><span class="line">    label.<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    label.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HTML-格式文本"><a href="#HTML-格式文本" class="headerlink" title="HTML 格式文本"></a><strong>HTML 格式文本</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QLabel label;</span><br><span class="line">    label.<span class="built_in">setText</span>(<span class="string">&quot;&lt;h1 style=&#x27;color:red;&#x27;&gt;Hello, &lt;i&gt;HTML&lt;/i&gt;!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    label.<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    label.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="QLabel-常见属性"><a href="#QLabel-常见属性" class="headerlink" title="QLabel 常见属性"></a><strong>QLabel 常见属性</strong></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>text</code></td>
<td>显示的文本内容</td>
</tr>
<tr>
<td><code>pixmap</code></td>
<td>显示的图片</td>
</tr>
<tr>
<td><code>alignment</code></td>
<td>对齐方式（文本或图片）</td>
</tr>
<tr>
<td><code>wordWrap</code></td>
<td>是否自动换行</td>
</tr>
<tr>
<td><code>scaledContents</code></td>
<td>是否自动缩放内容</td>
</tr>
<tr>
<td><code>toolTip</code></td>
<td>鼠标悬浮提示信息</td>
</tr>
</tbody></table>
<hr>
<p>通过灵活使用 QLabel，可以满足 GUI 界面中简单的显示需求，例如展示文字、图片或动态信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/2024-11-18-qt_7_%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/2024-11-18-qt_7_%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">qt_7_常见函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Qt-WindowStaysOnTopHint-是什么"><a href="#Qt-WindowStaysOnTopHint-是什么" class="headerlink" title="Qt::WindowStaysOnTopHint 是什么"></a>Qt::WindowStaysOnTopHint 是什么</h2><p><code>Qt::WindowStaysOnTopHint</code> 是 Qt 中的一个窗口标志（Window Flag），它用于使窗口始终保持在其他窗口的上方。</p>
<p>当一个窗口设置了这个标志后，无论其他窗口是否被激活，该窗口都会始终位于最前面，类似于“置顶”的效果。</p>
<hr>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>
<p>通常与其他标志组合使用，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a><strong>常见场景</strong></h3><ol>
<li><strong>提示框</strong>：显示重要信息或通知时，不希望被其他窗口遮挡。</li>
<li><strong>悬浮工具栏</strong>：开发一些辅助工具或快捷操作面板时。</li>
<li><strong>系统通知</strong>：显示系统级通知或警告。</li>
<li><strong>调试工具</strong>：为调试时的窗口提供置顶功能。</li>
</ol>
<hr>
<h3 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a><strong>完整例子</strong></h3><p>以下是一个简单的例子，展示如何使用 <code>Qt::WindowStaysOnTopHint</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(<span class="string">&quot;我是置顶窗口&quot;</span>)</span></span>;</span><br><span class="line">    label.<span class="built_in">setWindowFlags</span>(Qt::Tool | Qt::WindowStaysOnTopHint);</span><br><span class="line">    label.<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: yellow; padding: 10px; font-size: 16px;&quot;</span>);</span><br><span class="line">    label.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后，<code>label</code> 将始终显示在其他窗口的上方。</p>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>窗口管理器支持</strong>：</p>
<ul>
<li>在某些操作系统或桌面环境下，窗口管理器可能不完全支持此标志。</li>
<li>特别是在某些 Linux 桌面环境中，置顶功能可能会受到限制。</li>
</ul>
</li>
<li><p><strong>不适合主窗口</strong>：</p>
<ul>
<li>这个标志通常用于子窗口或辅助窗口，而不是主窗口（<code>QMainWindow</code>），否则会导致用户体验不佳。</li>
</ul>
</li>
<li><p><strong>与其他标志冲突</strong>：</p>
<ul>
<li>如果设置了 <code>Qt::WindowStaysOnTopHint</code>，但窗口没有置顶，可能是其他窗口标志（如模态窗口）导致的冲突。</li>
</ul>
</li>
</ol>
<hr>
<p>通过这个标志，可以方便地实现类似系统通知、浮动工具栏等功能，提升程序的交互体验。</p>
<h2 id="Qt-FramelessWindowHint"><a href="#Qt-FramelessWindowHint" class="headerlink" title="Qt::FramelessWindowHint"></a>Qt::FramelessWindowHint</h2><p><code>Qt::FramelessWindowHint</code> 是 Qt 中的一个窗口标志，用于移除窗口的标题栏和边框。设置该标志的窗口将变得无边框，并且不包含系统提供的关闭、最小化、最大化等按钮。</p>
<hr>
<h3 id="特点与用途"><a href="#特点与用途" class="headerlink" title="特点与用途"></a><strong>特点与用途</strong></h3><ul>
<li><strong>去除边框和标题栏</strong>：<ul>
<li>使窗口显示更加简洁，用于自定义界面。</li>
</ul>
</li>
<li><strong>完全可控</strong>：<ul>
<li>通常用于自定义窗口的外观，例如圆角窗口、透明窗口等。</li>
</ul>
</li>
<li><strong>常见场景</strong>：<ul>
<li>Splash Screen（启动画面）。</li>
<li>自定义提示框。</li>
<li>自定义主窗口或弹窗。</li>
<li>不规则形状的窗口。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><p>通过 <code>setWindowFlags</code> 设置 <code>Qt::FramelessWindowHint</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br></pre></td></tr></table></figure>

<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint); <span class="comment">// 设置无边框</span></span><br><span class="line">    window.<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightblue; border-radius: 10px;&quot;</span>);</span><br><span class="line">    window.<span class="built_in">setFixedSize</span>(<span class="number">400</span>, <span class="number">300</span>); <span class="comment">// 固定窗口大小</span></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后，窗口将显示为无边框的蓝色矩形。</p>
<hr>
<h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a><strong>组合使用</strong></h3><p><code>Qt::FramelessWindowHint</code> 可以与其他窗口标志组合使用，以实现更多功能。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="鼠标拖动窗口"><a href="#鼠标拖动窗口" class="headerlink" title="鼠标拖动窗口"></a><strong>鼠标拖动窗口</strong></h3><p>由于无边框窗口失去了默认的拖动功能，需要手动实现鼠标拖动窗口：</p>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FramelessWindow</span> : <span class="keyword">public</span> QWidget &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FramelessWindow</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span> : QWidget(parent) &#123;</span></span><br><span class="line">        <span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint); <span class="comment">// 设置无边框</span></span><br><span class="line">        <span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightgreen; border-radius: 10px;&quot;</span>);</span><br><span class="line">        <span class="built_in">setFixedSize</span>(<span class="number">400</span>, <span class="number">300</span>); <span class="comment">// 固定大小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::LeftButton) &#123;</span><br><span class="line">            dragStartPosition = event-&gt;<span class="built_in">globalPos</span>() - <span class="built_in">frameGeometry</span>().<span class="built_in">topLeft</span>();</span><br><span class="line">            event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton) &#123;</span><br><span class="line">            <span class="built_in">move</span>(event-&gt;<span class="built_in">globalPos</span>() - dragStartPosition);</span><br><span class="line">            event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPoint dragStartPosition; <span class="comment">// 记录鼠标初始位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    FramelessWindow window;</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码实现了一个无边框窗口，并支持用鼠标拖动。</p>
<hr>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>系统按钮功能缺失</strong>：</p>
<ul>
<li>无边框窗口会失去最小化、最大化和关闭按钮，需要自行实现这些功能。</li>
</ul>
</li>
<li><p><strong>操作系统兼容性</strong>：</p>
<ul>
<li>在某些操作系统（如 macOS 和 Windows）上，去边框可能会带来窗口交互体验的差异，例如窗口无法调整大小。</li>
</ul>
</li>
<li><p><strong>自定义效果</strong>：</p>
<ul>
<li>搭配 <code>QPainter</code> 或 <code>QStyleSheet</code>，可以实现更加复杂的窗口样式，比如圆角或透明效果。</li>
</ul>
</li>
</ol>
<hr>
<p>通过 <code>Qt::FramelessWindowHint</code>，开发者可以完全掌控窗口的外观和行为，是构建现代化、个性化界面的重要工具。</p>
<h2 id="Qt-Tool"><a href="#Qt-Tool" class="headerlink" title="Qt::Tool"></a>Qt::Tool</h2><p><code>Qt::Tool</code> 是 Qt 中的一个窗口标志（Window Type），用于指定窗口作为工具窗口显示。</p>
<p>工具窗口通常是一个小型的、非主窗口的辅助窗口，它的作用是提供附加功能或工具。比如，颜色选择器、调试面板、浮动工具栏等。</p>
<hr>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a><strong>主要特点</strong></h3><ol>
<li><p><strong>非主窗口类型</strong>：</p>
<ul>
<li><code>Qt::Tool</code> 窗口是附属于主窗口的辅助窗口，但它不会在任务栏显示图标。</li>
</ul>
</li>
<li><p><strong>置顶显示</strong>：</p>
<ul>
<li>通常，工具窗口会始终置顶在父窗口上方。</li>
<li>如果需要它始终置顶所有窗口，可以额外使用 <code>Qt::WindowStaysOnTopHint</code>。</li>
</ul>
</li>
<li><p><strong>独立窗口</strong>：</p>
<ul>
<li>工具窗口不会阻塞主窗口的操作，可以与主窗口同时交互。</li>
</ul>
</li>
<li><p><strong>大小和外观</strong>：</p>
<ul>
<li>工具窗口通常比主窗口小，而且默认没有任务栏图标。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget mainWindow;</span><br><span class="line">    mainWindow.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;主窗口&quot;</span>);</span><br><span class="line">    mainWindow.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">    mainWindow.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    QWidget toolWindow;</span><br><span class="line">    toolWindow.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;工具窗口&quot;</span>);</span><br><span class="line">    toolWindow.<span class="built_in">setWindowFlags</span>(Qt::Tool); <span class="comment">// 设置为工具窗口</span></span><br><span class="line">    toolWindow.<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">150</span>);</span><br><span class="line">    toolWindow.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后，你会看到：</p>
<ul>
<li>主窗口是常规的应用窗口。</li>
<li>工具窗口不会在任务栏中显示。</li>
</ul>
<hr>
<h3 id="组合使用-1"><a href="#组合使用-1" class="headerlink" title="组合使用"></a><strong>组合使用</strong></h3><p>可以将 <code>Qt::Tool</code> 与其他窗口标志结合使用，进一步控制工具窗口的行为。例如：</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolWindow.<span class="built_in">setWindowFlags</span>(Qt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>Qt::FramelessWindowHint</code>**：去掉工具窗口的边框。</li>
<li>**<code>Qt::WindowStaysOnTopHint</code>**：让工具窗口始终保持在所有窗口的最上方。</li>
</ul>
<hr>
<h3 id="工具窗口的父子关系"><a href="#工具窗口的父子关系" class="headerlink" title="工具窗口的父子关系"></a><strong>工具窗口的父子关系</strong></h3><p>如果设置工具窗口的父窗口，则工具窗口会自动跟随主窗口（如一起最小化或隐藏）。</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toolWindow.<span class="built_in">setParent</span>(&amp;mainWindow); <span class="comment">// 设置父窗口</span></span><br><span class="line">toolWindow.<span class="built_in">setWindowFlags</span>(Qt::Tool);</span><br><span class="line">toolWindow.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>当主窗口被最小化时，工具窗口也会被最小化。</li>
<li>工具窗口始终在其父窗口的范围内显示。</li>
</ul>
<hr>
<h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a><strong>常见用途</strong></h3><ol>
<li><strong>浮动工具栏</strong>：<ul>
<li>用于辅助功能（如编辑器的工具面板）。</li>
</ul>
</li>
<li><strong>调试窗口</strong>：<ul>
<li>用于显示调试信息或日志输出。</li>
</ul>
</li>
<li><strong>颜色选择器</strong>：<ul>
<li>提供小型的选择工具。</li>
</ul>
</li>
<li><strong>弹出提示框</strong>：<ul>
<li>实现自定义的提示窗口。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>任务栏图标</strong>：</p>
<ul>
<li>工具窗口不会显示在任务栏中，但如果需要显示，可以去掉 <code>Qt::Tool</code> 标志，改用普通窗口类型。</li>
</ul>
</li>
<li><p><strong>行为依赖父窗口</strong>：</p>
<ul>
<li>如果没有设置父窗口，工具窗口的置顶行为可能不稳定。</li>
</ul>
</li>
<li><p><strong>兼容性</strong>：</p>
<ul>
<li>在不同操作系统上的表现可能稍有差异，尤其是与其他窗口标志结合使用时。</li>
</ul>
</li>
</ol>
<hr>
<p>通过 <code>Qt::Tool</code>，可以轻松创建轻量级、功能明确的辅助窗口，提升应用程序的用户体验和功能扩展能力。</p>
<h2 id="QGuiApplication-primaryScreen-详解"><a href="#QGuiApplication-primaryScreen-详解" class="headerlink" title="QGuiApplication::primaryScreen() 详解"></a>QGuiApplication::primaryScreen() 详解</h2><p><code>QGuiApplication::primaryScreen()</code> 是 Qt 提供的一个方法，用于获取系统的主屏幕对象（<code>QScreen</code>）。它属于 <code>QGuiApplication</code> 类，适用于需要处理屏幕信息的场景，比如获取屏幕分辨率、设置窗口位置、在多屏环境下处理窗口布局等。</p>
<hr>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a><strong>主要功能</strong></h3><ol>
<li><strong>获取主屏幕信息</strong>：<ul>
<li>返回一个 <code>QScreen*</code>，表示主屏幕对象。</li>
</ul>
</li>
<li><strong>跨多屏支持</strong>：<ul>
<li>在多显示器环境中，<code>primaryScreen()</code> 返回的是主屏幕（通常是显示系统任务栏的屏幕）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><h4 id="获取主屏幕对象"><a href="#获取主屏幕对象" class="headerlink" title="获取主屏幕对象"></a>获取主屏幕对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScreen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line">    <span class="keyword">if</span> (screen) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Primary screen name:&quot;</span> &lt;&lt; screen-&gt;<span class="built_in">name</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Screen resolution:&quot;</span> &lt;&lt; screen-&gt;<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Screen geometry:&quot;</span> &lt;&lt; screen-&gt;<span class="built_in">geometry</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Primary screen name: &quot;eDP-1&quot;</span><br><span class="line">Screen resolution: QSize(1920, 1080)</span><br><span class="line">Screen geometry: QRect(0, 0, 1920, 1080)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见用途-1"><a href="#常见用途-1" class="headerlink" title="常见用途"></a><strong>常见用途</strong></h3><h4 id="1-获取主屏幕分辨率"><a href="#1-获取主屏幕分辨率" class="headerlink" title="1. 获取主屏幕分辨率"></a>1. <strong>获取主屏幕分辨率</strong></h4><p>可以通过 <code>QScreen</code> 的 <code>size()</code> 或 <code>availableGeometry()</code> 获取屏幕的分辨率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line"><span class="keyword">if</span> (screen) &#123;</span><br><span class="line">    QSize resolution = screen-&gt;<span class="built_in">size</span>(); <span class="comment">// 获取屏幕分辨率</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Screen resolution:&quot;</span> &lt;&lt; resolution;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-设置窗口到主屏幕中心"><a href="#2-设置窗口到主屏幕中心" class="headerlink" title="2. 设置窗口到主屏幕中心"></a>2. <strong>设置窗口到主屏幕中心</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScreen&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setFixedSize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取主屏幕的几何信息</span></span><br><span class="line">    QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line">    <span class="keyword">if</span> (screen) &#123;</span><br><span class="line">        QRect screenGeometry = screen-&gt;<span class="built_in">geometry</span>();</span><br><span class="line">        <span class="type">int</span> x = screenGeometry.<span class="built_in">center</span>().<span class="built_in">x</span>() - window.<span class="built_in">width</span>() / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> y = screenGeometry.<span class="built_in">center</span>().<span class="built_in">y</span>() - window.<span class="built_in">height</span>() / <span class="number">2</span>;</span><br><span class="line">        window.<span class="built_in">move</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-支持多屏幕环境"><a href="#3-支持多屏幕环境" class="headerlink" title="3. 支持多屏幕环境"></a>3. <strong>支持多屏幕环境</strong></h4><p>对于多屏幕环境，可以使用 <code>QGuiApplication::screens()</code> 获取所有屏幕的列表，并选择特定的屏幕进行操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScreen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QList&lt;QScreen *&gt; screens = QGuiApplication::<span class="built_in">screens</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Number of screens:&quot;</span> &lt;&lt; screens.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (QScreen *screen : screens) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Screen name:&quot;</span> &lt;&lt; screen-&gt;<span class="built_in">name</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Resolution:&quot;</span> &lt;&lt; screen-&gt;<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a><strong>常见方法</strong></h3><p>以下是 <code>QScreen</code> 类常用的方法，可以结合 <code>primaryScreen()</code> 使用：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>geometry()</code></td>
<td>返回屏幕的矩形区域（包括不可用部分）。</td>
</tr>
<tr>
<td><code>availableGeometry()</code></td>
<td>返回屏幕的可用区域（排除了任务栏和停靠窗口的部分）。</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回屏幕的分辨率（<code>QSize</code>）。</td>
</tr>
<tr>
<td><code>physicalSize()</code></td>
<td>返回屏幕的物理尺寸（毫米为单位）。</td>
</tr>
<tr>
<td><code>refreshRate()</code></td>
<td>返回屏幕的刷新率（Hz）。</td>
</tr>
<tr>
<td><code>logicalDotsPerInch()</code></td>
<td>返回屏幕的逻辑 DPI（通常用于字体和布局的计算）。</td>
</tr>
<tr>
<td><code>devicePixelRatio()</code></td>
<td>返回屏幕的设备像素比率（高分屏时非常重要）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>多屏环境</strong>：</p>
<ul>
<li>如果程序运行在多显示器环境下，<code>primaryScreen()</code> 返回的只是主屏幕，而其他屏幕需要通过 <code>QGuiApplication::screens()</code> 获取。</li>
</ul>
</li>
<li><p><strong>跨平台差异</strong>：</p>
<ul>
<li>在某些平台（如 macOS）上，任务栏可能不总是定义主屏幕。</li>
</ul>
</li>
<li><p><strong>高分屏支持</strong>：</p>
<ul>
<li>如果使用高分屏，记得考虑设备像素比率 (<code>devicePixelRatio()</code>)，以避免显示问题。</li>
</ul>
</li>
</ol>
<hr>
<p>通过 <code>QGuiApplication::primaryScreen()</code>，可以轻松获取屏幕的几何信息并灵活控制窗口的位置和布局，特别是在需要多屏支持或自定义布局时非常有用。</p>
<h2 id="Qt-findChild-函数-详解"><a href="#Qt-findChild-函数-详解" class="headerlink" title="Qt findChild()函数 详解"></a>Qt findChild()函数 详解</h2><p><code>findChild()</code> 是 Qt 中用于查找某个特定类型或名称的子对象的函数。它通常用于在运行时查找对象树中的子对象，特别是在动态生成或加载 UI 元素时非常有用。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">findChild</span><span class="params">(<span class="type">const</span> QString &amp;name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>T</strong>: 模板参数，表示要查找的对象类型（如 <code>QWidget*</code>、<code>QPushButton*</code> 等）。</li>
<li><strong>name</strong>: 子对象的名称（对象名），可以省略。如果省略，表示查找第一个符合类型的对象。</li>
<li><strong>options</strong>: 查找选项，可以指定查找的深度（递归或不递归）。</li>
</ul>
<h3 id="查找选项-Qt-FindChildOptions"><a href="#查找选项-Qt-FindChildOptions" class="headerlink" title="查找选项 (Qt::FindChildOptions)"></a>查找选项 (<code>Qt::FindChildOptions</code>)</h3><ul>
<li><code>Qt::FindDirectChildrenOnly</code>: 仅查找直接子对象，不会递归查找子对象的子对象。</li>
<li><code>Qt::FindChildrenRecursively</code>: 递归查找所有子对象（包括子对象的子对象）。这是默认选项。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你有一个包含多个子部件的 <code>QWidget</code>，其中一个 <code>QPushButton</code> 名为 <code>&quot;myButton&quot;</code>，你可以使用 <code>findChild()</code> 来查找该按钮。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *button = parentWidget-&gt;<span class="built_in">findChild</span>&lt;QPushButton*&gt;(<span class="string">&quot;myButton&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (button) &#123;</span><br><span class="line">    <span class="comment">// 找到了名为 &quot;myButton&quot; 的按钮，可以在这里进行操作</span></span><br><span class="line">    button-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Button Found!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有找到该按钮</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Button not found!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找没有名称的子对象"><a href="#查找没有名称的子对象" class="headerlink" title="查找没有名称的子对象"></a>查找没有名称的子对象</h3><p>如果你不关心对象名，只需要查找某一类型的子对象，可以不传入 <code>name</code> 参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = parentWidget-&gt;<span class="built_in">findChild</span>&lt;QLabel*&gt;();</span><br><span class="line"><span class="keyword">if</span> (label) &#123;</span><br><span class="line">    <span class="comment">// 找到了某个 QLabel，可以在这里进行操作</span></span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Label Found!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>对象名必须唯一</strong>：如果查找指定名称的子对象，确保该名称在对象树中是唯一的。否则，<code>findChild()</code> 可能只返回找到的第一个匹配对象。</li>
<li><strong>类型检查</strong>：模板参数 <code>T</code> 应与查找的子对象的实际类型匹配。否则，返回的指针将是 <code>nullptr</code>。</li>
</ul>
<h3 id="递归查找多个子对象"><a href="#递归查找多个子对象" class="headerlink" title="递归查找多个子对象"></a>递归查找多个子对象</h3><p>如果需要查找多个匹配的子对象，可以使用 <code>findChildren()</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QPushButton*&gt; buttons = parentWidget-&gt;<span class="built_in">findChildren</span>&lt;QPushButton*&gt;(<span class="string">&quot;myButton&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (QPushButton *button : buttons) &#123;</span><br><span class="line">    <span class="comment">// 对每个找到的按钮进行操作</span></span><br><span class="line">    button-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Found Multiple Buttons!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h3><ul>
<li><strong>动态 UI 查找</strong>：在运行时查找动态生成的 UI 元素。</li>
<li><strong>复用代码</strong>：通过查找对象，可以避免直接传递指针来访问特定 UI 元素，从而提高代码的可复用性和维护性。</li>
<li><strong>调试</strong>：查找和验证某个对象是否正确创建并存在于对象树中。</li>
</ul>
<p><code>findChild()</code> 是 Qt 中非常强大的工具，特别适用于需要在运行时动态查找和操作 UI 元素的场景。</p>
<h2 id="Qt-QTextCodec-setCodecForLocale-函数-详解"><a href="#Qt-QTextCodec-setCodecForLocale-函数-详解" class="headerlink" title="Qt QTextCodec::setCodecForLocale() 函数 详解"></a>Qt QTextCodec::setCodecForLocale() 函数 详解</h2><p><code>QTextCodec::setCodecForLocale()</code> 是 Qt 中用于设置程序的字符编码的函数。具体来说，它设置用于处理当前区域语言（locale）的字符编码。</p>
<h3 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">QTextCodec::setCodecForLocale</span><span class="params">(QTextCodec *codec)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-主要用途"><a href="#2-主要用途" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h3><p><code>setCodecForLocale()</code> 函数的作用是为本地字符编码（locale）设置一个自定义的编码器（<code>QTextCodec</code>）。这影响到与本地字符编码相关的操作，如从文件系统读取文件名、处理文本输入输出等。</p>
<p>Qt 中的字符编码处理依赖 <code>QTextCodec</code>，它是一个字符编码转换的类。不同的 <code>QTextCodec</code> 子类代表了不同的字符编码方式，例如 UTF-8、GBK、ISO 8859-1 等。</p>
<h3 id="3-具体使用场景"><a href="#3-具体使用场景" class="headerlink" title="3. 具体使用场景"></a>3. 具体使用场景</h3><p>在多语言应用中，可能会遇到字符编码问题，例如中文路径或文件内容乱码。通过设置适当的 <code>QTextCodec</code>，可以解决这些问题。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为 UTF-8 编码</span></span><br><span class="line">    QTextCodec::<span class="built_in">setCodecForLocale</span>(QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者设置为 GBK 编码（用于处理中文字符）</span></span><br><span class="line">    QTextCodec::<span class="built_in">setCodecForLocale</span>(QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你的应用程序代码</span></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><p>从 Qt 5 开始，<code>setCodecForLocale()</code> 已经逐渐被淘汰，因为 Qt 更推荐使用 Unicode（如 UTF-8）作为全局字符编码。大多数现代应用不需要手动设置字符编码。Qt 默认使用 UTF-8 编码来处理字符串，并且建议开发者尽量遵循这个标准。</p>
<h3 id="5-相关函数"><a href="#5-相关函数" class="headerlink" title="5. 相关函数"></a>5. 相关函数</h3><ul>
<li><code>QTextCodec::codecForLocale()</code>: 获取当前设置的本地编码。</li>
<li><code>QTextCodec::codecForName(const char *name)</code>: 根据编码名称获取对应的 <code>QTextCodec</code> 对象。</li>
</ul>
<h3 id="6-示例代码"><a href="#6-示例代码" class="headerlink" title="6. 示例代码"></a>6. 示例代码</h3><p>以下是如何在早期版本的 Qt 中使用 <code>setCodecForLocale()</code> 的一个典型场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将本地编码设置为 GBK（适用于简体中文环境）</span></span><br><span class="line">    QTextCodec::<span class="built_in">setCodecForLocale</span>(QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续其他应用逻辑...</span></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-现代-Qt-的替代方案"><a href="#7-现代-Qt-的替代方案" class="headerlink" title="7. 现代 Qt 的替代方案"></a>7. 现代 Qt 的替代方案</h3><p>在现代 Qt 中，通常不需要显式设置编码。确保使用 QString、QByteArray 以及使用 UTF-8 编码文件可以避免大多数字符编码问题。</p>
<p>通过以上内容，你应该了解了 <code>QTextCodec::setCodecForLocale()</code> 的用法及其在现代 Qt 开发中的替代方案。</p>
<h2 id="QTextCodec-codecForName-函数-详解"><a href="#QTextCodec-codecForName-函数-详解" class="headerlink" title="QTextCodec::codecForName() 函数 详解"></a>QTextCodec::codecForName() 函数 详解</h2><p><code>QTextCodec::codecForName()</code> 是 Qt 中用于根据字符编码名称获取对应 <code>QTextCodec</code> 对象的静态函数。<code>QTextCodec</code> 是一个处理字符编码转换的类，这个函数允许开发者选择适当的字符编码以处理文本数据的编码和解码。</p>
<h3 id="1-函数原型-1"><a href="#1-函数原型-1" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> QTextCodec *<span class="title">QTextCodec::codecForName</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> QTextCodec *<span class="title">QTextCodec::codecForName</span><span class="params">(<span class="type">const</span> QByteArray &amp;name)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-主要用途-1"><a href="#2-主要用途-1" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h3><p><code>codecForName()</code> 函数用于根据指定的编码名称返回对应的 <code>QTextCodec</code> 实例。这对于在多语言环境下处理不同编码格式的文本文件或网络数据非常有用。例如，你可能需要处理 UTF-8、GBK 或 ISO-8859-1 等编码的文本内容。</p>
<h3 id="3-具体用法"><a href="#3-具体用法" class="headerlink" title="3. 具体用法"></a>3. 具体用法</h3><p>下面是使用 <code>codecForName()</code> 的典型场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 UTF-8 编码的 QTextCodec 实例</span></span><br><span class="line">    QTextCodec *utf8Codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 QString 编码为 UTF-8 字节数组</span></span><br><span class="line">    QString str = <span class="string">&quot;Hello, 你好!&quot;</span>;</span><br><span class="line">    QByteArray encodedStr = utf8Codec-&gt;<span class="built_in">fromUnicode</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 UTF-8 字节数组解码为 QString</span></span><br><span class="line">    QString decodedStr = utf8Codec-&gt;<span class="built_in">toUnicode</span>(encodedStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-参数说明"><a href="#4-参数说明" class="headerlink" title="4. 参数说明"></a>4. 参数说明</h3><ul>
<li><strong><code>const char *name</code></strong>: 表示编码名称的 C 字符串，例如 <code>&quot;UTF-8&quot;</code>、<code>&quot;GBK&quot;</code>、<code>&quot;ISO-8859-1&quot;</code> 等。</li>
<li><strong><code>const QByteArray &amp;name</code></strong>: 作为 QByteArray 类型的编码名称，适用于编码名称是动态生成的场景。</li>
</ul>
<h3 id="5-返回值"><a href="#5-返回值" class="headerlink" title="5. 返回值"></a>5. 返回值</h3><ul>
<li>成功时返回对应编码的 <code>QTextCodec</code> 对象指针。</li>
<li>如果找不到对应编码，返回 <code>nullptr</code>。</li>
</ul>
<h3 id="6-常用编码名称"><a href="#6-常用编码名称" class="headerlink" title="6. 常用编码名称"></a>6. 常用编码名称</h3><p>一些常用的编码名称包括：</p>
<ul>
<li><code>&quot;UTF-8&quot;</code>：用于处理 Unicode 的最常见编码，适合多语言文本。</li>
<li><code>&quot;GBK&quot;</code>：中文常用编码。</li>
<li><code>&quot;ISO-8859-1&quot;</code>：常见于西欧语言的编码。</li>
<li><code>&quot;Shift-JIS&quot;</code>：用于日语编码。</li>
</ul>
<p>编码名称不区分大小写，输入 <code>&quot;utf-8&quot;</code> 或 <code>&quot;UTF-8&quot;</code> 均可。</p>
<h3 id="7-示例代码"><a href="#7-示例代码" class="headerlink" title="7. 示例代码"></a>7. 示例代码</h3><p>下面的代码展示了如何根据不同的编码名称获取对应的 <code>QTextCodec</code>，并进行文本转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 GBK 编码的 QTextCodec 实例</span></span><br><span class="line">    QTextCodec *codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (codec) &#123;</span><br><span class="line">        QString text = <span class="string">&quot;你好, 世界!&quot;</span>;</span><br><span class="line">        QByteArray encodedText = codec-&gt;<span class="built_in">fromUnicode</span>(text);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Encoded text (GBK):&quot;</span> &lt;&lt; encodedText;</span><br><span class="line"></span><br><span class="line">        QString decodedText = codec-&gt;<span class="built_in">toUnicode</span>(encodedText);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Decoded text:&quot;</span> &lt;&lt; decodedText;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Error: Codec not found!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-注意事项"><a href="#8-注意事项" class="headerlink" title="8. 注意事项"></a>8. 注意事项</h3><ul>
<li>在调用 <code>codecForName()</code> 时，如果编码名称无效（如拼写错误或 Qt 不支持），函数将返回 <code>nullptr</code>，因此在使用返回值之前需要检查其有效性。</li>
<li>尽量在现代应用中使用 Unicode（如 UTF-8）编码，减少字符编码转换问题。</li>
</ul>
<h3 id="9-相关函数"><a href="#9-相关函数" class="headerlink" title="9. 相关函数"></a>9. 相关函数</h3><ul>
<li><code>QTextCodec::setCodecForLocale()</code>: 设置程序的本地字符编码。</li>
<li><code>QTextCodec::codecForLocale()</code>: 获取当前本地环境使用的编码。</li>
<li><code>QTextCodec::availableCodecs()</code>: 获取所有可用编码名称的列表。</li>
</ul>
<p>通过这些内容，你应该掌握了 <code>QTextCodec::codecForName()</code> 的用法以及它在字符编码处理中的重要作用。</p>
<h2 id="Qt-QT-BEGIN-NAMESPACE-宏-详解"><a href="#Qt-QT-BEGIN-NAMESPACE-宏-详解" class="headerlink" title="Qt QT_BEGIN_NAMESPACE 宏 详解"></a>Qt QT_BEGIN_NAMESPACE 宏 详解</h2><p><code>QT_BEGIN_NAMESPACE</code> 是 Qt 中定义的一个宏，通常用于简化命名空间的管理，特别是在处理 Qt 库的代码时。这个宏与 <code>QT_END_NAMESPACE</code> 配合使用，主要目的是将 Qt 的类、函数等代码封装到命名空间 <code>Qt</code> 中。</p>
<h3 id="1-作用和用法"><a href="#1-作用和用法" class="headerlink" title="1. 作用和用法"></a>1. 作用和用法</h3><p><code>QT_BEGIN_NAMESPACE</code> 是在代码中用于开启 Qt 命名空间的宏定义，它的作用相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Qt &#123;</span><br></pre></td></tr></table></figure>

<p>与之对应，<code>QT_END_NAMESPACE</code> 用于关闭命名空间，等同于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h3><p>在 Qt 库的源码或插件开发中，可能会看到以下形式的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QWidget</span> &#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QT_END_NAMESPACE</span><br></pre></td></tr></table></figure>

<p>这段代码实际上被处理为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Qt &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QWidget</span> &#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace Qt</span></span><br></pre></td></tr></table></figure>

<p>通过使用这些宏，Qt 提供了一个方便的方式来管理命名空间，确保 Qt 库内部代码在正确的命名空间内被封装。</p>
<h3 id="3-为什么使用这些宏？"><a href="#3-为什么使用这些宏？" class="headerlink" title="3. 为什么使用这些宏？"></a>3. 为什么使用这些宏？</h3><p>Qt 采用这些宏而不是直接使用 <code>namespace Qt &#123; ... &#125;</code> 这种语法的原因在于：</p>
<ol>
<li><strong>跨平台兼容性</strong>：Qt 是一个跨平台库，为了在不同的编译器、平台上保持代码一致性，使用宏可以更灵活地适应不同平台的特殊需求。</li>
<li><strong>条件编译支持</strong>：通过这些宏，Qt 可以根据配置或编译选项有条件地开启或关闭命名空间。例如，在某些特殊编译环境下，可能不需要使用 <code>Qt</code> 命名空间，这时可以通过配置条件控制这些宏的行为。</li>
<li><strong>简化代码维护</strong>：在大型代码库中使用宏，可以在需要更改命名空间策略时集中管理，避免大量手动修改。</li>
</ol>
<h3 id="4-相关宏"><a href="#4-相关宏" class="headerlink" title="4. 相关宏"></a>4. 相关宏</h3><p>除了 <code>QT_BEGIN_NAMESPACE</code> 和 <code>QT_END_NAMESPACE</code>，还有一些相关的宏，用于处理命名空间或条件编译：</p>
<ul>
<li><code>QT_USE_NAMESPACE</code>: 当在项目中使用 Qt 命名空间时，可以在代码中包含这个宏，以确保代码在正确的命名空间中运行。</li>
<li><code>QT_PREPEND_NAMESPACE(ClassName)</code>: 这个宏用于在不使用命名空间时显式地为类名加上 <code>Qt::</code> 前缀，如 <code>Qt::QWidget</code>。</li>
<li><code>QT_END_HEADER</code>: 用于在头文件中结束命名空间的定义，特别是在跨平台的头文件中使用。</li>
</ul>
<h3 id="5-在项目中的使用"><a href="#5-在项目中的使用" class="headerlink" title="5. 在项目中的使用"></a>5. 在项目中的使用</h3><p>在自己的项目中，通常不需要直接使用这些宏，除非你在开发 Qt 插件、扩展库或直接修改 Qt 源码。在普通的 Qt 应用程序开发中，直接使用 <code>Qt</code> 命名空间即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，你不需要关心 <code>QT_BEGIN_NAMESPACE</code> 等宏，因为 Qt 的头文件已经处理了命名空间的封装。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p><code>QT_BEGIN_NAMESPACE</code> 和 <code>QT_END_NAMESPACE</code> 是 Qt 用于命名空间管理的宏，它们的作用是简化 Qt 库代码中命名空间的封装。这种设计提高了代码的可维护性、跨平台兼容性，并为条件编译提供了灵活性。在大多数应用开发中，开发者不需要直接使用这些宏，只需知道它们在 Qt 库中的作用即可。</p>
<h2 id="Qt-Q-OBJECT-宏-详解"><a href="#Qt-Q-OBJECT-宏-详解" class="headerlink" title="Qt Q_OBJECT 宏 详解"></a>Qt Q_OBJECT 宏 详解</h2><p><code>Q_OBJECT</code> 宏是 Qt 框架中用于支持 Qt 元对象系统的关键宏。这个宏通常放在 Qt 类的声明部分，特别是需要使用信号和槽机制的类。它使得 Qt 的一些高级特性，如信号和槽、属性系统、动态属性等，可以在类中工作。下面是对 <code>Q_OBJECT</code> 宏的详细解解：</p>
<h3 id="1-定义和位置"><a href="#1-定义和位置" class="headerlink" title="1. 定义和位置"></a>1. <strong>定义和位置</strong></h3><p><code>Q_OBJECT</code> 宏必须放在类的 <code>public</code> 或 <code>protected</code> 访问修饰符下方，紧接在类声明的开头。这是因为宏会在类的头文件中生成一些额外的代码，类的元对象系统需要这些代码来实现 Qt 的信号和槽机制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySlot</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-元对象系统"><a href="#2-元对象系统" class="headerlink" title="2. 元对象系统"></a>2. <strong>元对象系统</strong></h3><p>当你在一个类中使用 <code>Q_OBJECT</code> 宏时，Qt 的元对象系统会生成一些额外的代码，包括：</p>
<ul>
<li><strong>信号和槽机制的支持</strong>：<code>Q_OBJECT</code> 宏让类能够发射信号并处理槽函数。</li>
<li><strong>动态属性的支持</strong>：允许类在运行时动态地添加和查询属性。</li>
<li><strong>元对象信息</strong>：提供有关类的运行时信息，如类名、继承关系等。</li>
</ul>
<h3 id="3-MOC（Meta-Object-Compiler）"><a href="#3-MOC（Meta-Object-Compiler）" class="headerlink" title="3. MOC（Meta-Object Compiler）"></a>3. <strong>MOC（Meta-Object Compiler）</strong></h3><p><code>Q_OBJECT</code> 宏的主要作用是让 Qt 的 Meta-Object Compiler（MOC）工具生成相关的元对象代码。MOC 工具会读取你的类定义文件，并根据 <code>Q_OBJECT</code> 宏生成一个 <code>.moc</code> 文件，这个文件包含了信号和槽机制的实现代码。在编译过程中，MOC 生成的代码会被编译到最终的二进制文件中。</p>
<h3 id="4-信号和槽"><a href="#4-信号和槽" class="headerlink" title="4. 信号和槽"></a>4. <strong>信号和槽</strong></h3><p>信号和槽是 Qt 的核心特性，<code>Q_OBJECT</code> 宏使得你可以在类中声明信号和槽，并且在运行时连接它们。信号是事件的通知，而槽是响应这些事件的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明信号</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明槽</span></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySlot</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-动态属性和其他功能"><a href="#5-动态属性和其他功能" class="headerlink" title="5. 动态属性和其他功能"></a>5. <strong>动态属性和其他功能</strong></h3><p>使用 <code>Q_OBJECT</code> 宏后，你的类还可以利用 Qt 的动态属性系统，允许在运行时设置和获取对象的属性。此外，<code>Q_OBJECT</code> 使得 Qt 能够在运行时查询类的元信息。</p>
<h3 id="6-编译注意事项"><a href="#6-编译注意事项" class="headerlink" title="6. 编译注意事项"></a>6. <strong>编译注意事项</strong></h3><p>如果你更改了包含 <code>Q_OBJECT</code> 宏的类的定义，你必须重新运行 MOC 并重新编译项目。通常，Qt 的构建系统（如 qmake 或 CMake）会自动处理这个过程。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySlot</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总之，<code>Q_OBJECT</code> 宏是 Qt 的信号和槽机制、动态属性以及元对象系统的核心，它是实现 Qt 许多功能的基础。</p>
<h2 id="Qt-connect-函数-详解"><a href="#Qt-connect-函数-详解" class="headerlink" title="Qt connect() 函数 详解"></a>Qt connect() 函数 详解</h2><p><code>connect()</code> 函数是 Qt 信号与槽机制的核心。它用于将信号和槽函数连接起来，使得当某个信号发出时，自动调用与其连接的槽函数。这种机制是 Qt 的基础，用于实现组件之间的松耦合通信，尤其在 GUI 编程中非常常用。</p>
<h3 id="1-信号与槽机制简介"><a href="#1-信号与槽机制简介" class="headerlink" title="1. 信号与槽机制简介"></a>1. <strong>信号与槽机制简介</strong></h3><p>在 Qt 中，信号（signal）和槽（slot）是一种观察者模式的实现。信号用于通知事件的发生，而槽是用来处理这些事件的函数。当某个对象发出信号时，与之连接的槽函数会被自动调用。</p>
<h3 id="2-connect-函数的语法"><a href="#2-connect-函数的语法" class="headerlink" title="2. connect() 函数的语法"></a>2. <strong>connect() 函数的语法</strong></h3><p>Qt 的 <code>connect()</code> 函数有多种形式，最常用的语法如下：</p>
<h4 id="2-1-基于旧版字符串的连接（Qt4-风格）"><a href="#2-1-基于旧版字符串的连接（Qt4-风格）" class="headerlink" title="2.1 基于旧版字符串的连接（Qt4 风格）"></a>2.1 基于旧版字符串的连接（Qt4 风格）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">signalName</span>(parameters)), receiver, <span class="built_in">SLOT</span>(<span class="built_in">slotName</span>(parameters)));</span><br></pre></td></tr></table></figure>

<p>这种方法使用 <code>SIGNAL()</code> 和 <code>SLOT()</code> 宏将信号和槽的名称转换为字符串。虽然这种方式在旧版 Qt 中常用，但现在已不推荐使用。</p>
<h4 id="2-2-基于新信号槽语法（Qt5-及以上）"><a href="#2-2-基于新信号槽语法（Qt5-及以上）" class="headerlink" title="2.2 基于新信号槽语法（Qt5 及以上）"></a>2.2 基于新信号槽语法（Qt5 及以上）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(sender, &amp;SenderClass::signalName, receiver, &amp;ReceiverClass::slotName);</span><br></pre></td></tr></table></figure>

<p>这种方法是类型安全的，编译器会在编译期检查信号和槽的参数匹配情况，并且不需要使用宏，语法更加清晰和安全。</p>
<h4 id="2-3-使用-Lambda-表达式"><a href="#2-3-使用-Lambda-表达式" class="headerlink" title="2.3 使用 Lambda 表达式"></a>2.3 使用 Lambda 表达式</h4><p>在 Qt5 中，槽函数还可以是一个 Lambda 表达式，非常适合简单的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(sender, &amp;SenderClass::signalName, [](parameters) &#123;</span><br><span class="line">    <span class="comment">// Lambda 表达式内的槽函数实现</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-connect-函数的参数详解"><a href="#3-connect-函数的参数详解" class="headerlink" title="3. connect() 函数的参数详解"></a>3. <strong>connect() 函数的参数详解</strong></h3><ul>
<li>**<code>sender</code>**：发出信号的对象，通常是一个 <code>QObject</code> 或其派生类的实例。</li>
<li>**<code>signalName</code>**：信号的名称。在旧版语法中，需要用 <code>SIGNAL()</code> 宏包裹；在新版语法中，直接使用指针形式 <code>&amp;SenderClass::signalName</code>。</li>
<li>**<code>receiver</code>**：接收信号的对象，也是一个 <code>QObject</code> 或其派生类的实例。</li>
<li>**<code>slotName</code>**：槽函数的名称。在旧版语法中，用 <code>SLOT()</code> 宏包裹；在新版语法中，直接使用指针形式 <code>&amp;ReceiverClass::slotName</code>。</li>
</ul>
<h3 id="4-connect-的高级用法"><a href="#4-connect-的高级用法" class="headerlink" title="4. connect() 的高级用法"></a>4. <strong>connect() 的高级用法</strong></h3><ul>
<li><p><strong>连接到多个槽函数</strong>：一个信号可以连接到多个槽函数，信号发出时，这些槽函数会按连接顺序依次被调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, &amp;SenderClass::signalName, receiver1, &amp;ReceiverClass1::slotName);</span><br><span class="line"><span class="built_in">connect</span>(sender, &amp;SenderClass::signalName, receiver2, &amp;ReceiverClass2::slotName);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>连接到同一个槽函数的多个信号</strong>：多个信号可以连接到同一个槽函数，这样无论哪个信号发出，都会调用相同的槽函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender1, &amp;SenderClass1::signalName, receiver, &amp;ReceiverClass::slotName);</span><br><span class="line"><span class="built_in">connect</span>(sender2, &amp;SenderClass2::signalName, receiver, &amp;ReceiverClass::slotName);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>连接到匿名槽（Lambda 表达式）</strong>：适用于只需处理简单逻辑的场景。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(button, &amp;QPushButton::clicked, []() &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Button clicked!&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>连接到 Qt 内置信号</strong>：很多 Qt 控件自带常用信号，如按钮的 <code>clicked()</code> 信号、文本框的 <code>textChanged()</code> 信号等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::onButtonClicked);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-连接失败的原因及解决方法"><a href="#5-连接失败的原因及解决方法" class="headerlink" title="5. 连接失败的原因及解决方法"></a>5. <strong>连接失败的原因及解决方法</strong></h3><ul>
<li><strong>信号和槽参数不匹配</strong>：信号和槽的参数类型和数量必须一致，否则连接将失败。</li>
<li><strong>对象生命周期问题</strong>：<code>sender</code> 或 <code>receiver</code> 可能在信号发出前已经被销毁，导致连接失效。</li>
<li><strong>无效的信号或槽名称</strong>：检查信号和槽是否拼写正确，且使用正确的语法（旧版或新版）。</li>
<li><strong>类型不兼容</strong>：新版语法下，信号和槽必须是同一个类的成员函数指针。</li>
</ul>
<h3 id="6-断开信号与槽的连接"><a href="#6-断开信号与槽的连接" class="headerlink" title="6. 断开信号与槽的连接"></a>6. <strong>断开信号与槽的连接</strong></h3><p>使用 <code>QObject::disconnect()</code> 可以手动断开信号与槽的连接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">disconnect</span>(sender, &amp;SenderClass::signalName, receiver, &amp;ReceiverClass::slotName);</span><br></pre></td></tr></table></figure>

<p>或者直接使用 <code>disconnect(sender)</code> 来断开 <code>sender</code> 发出的所有信号。</p>
<h3 id="7-connect-的返回值"><a href="#7-connect-的返回值" class="headerlink" title="7. connect() 的返回值"></a>7. <strong>connect() 的返回值</strong></h3><p><code>connect()</code> 函数返回一个 <code>bool</code> 值，表示连接是否成功。通常不需要手动检查返回值，但在复杂或关键场景下，检查返回值可以帮助调试连接失败的原因。</p>
<h3 id="8-常见示例"><a href="#8-常见示例" class="headerlink" title="8. 常见示例"></a>8. <strong>常见示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Click Me&quot;</span>)</span></span>;</span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;button, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="literal">nullptr</span>, <span class="string">&quot;Title&quot;</span>, <span class="string">&quot;Button clicked!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    button.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>connect()</code> 是 Qt 信号与槽机制的核心，它允许在不同对象间实现松耦合的事件处理。在 Qt5 及以上版本中，推荐使用新版的指针语法，因为它类型安全、语法简洁且更易于维护。通过灵活使用 <code>connect()</code>，可以极大简化 Qt 程序中的事件处理流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-01-QStackedWidget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-01-QStackedWidget/" class="post-title-link" itemprop="url">QStackedWidget</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>QStackedWidget类相关笔记</li>
</ul>
<h1 id="QStackedWidget-详解"><a href="#QStackedWidget-详解" class="headerlink" title="QStackedWidget 详解"></a>QStackedWidget 详解</h1><p><code>QStackedWidget</code> 是 Qt 框架中的一个控件类，用于在同一位置显示多个小部件（widget），但一次只能显示其中的一个。它常用于需要在同一空间切换不同页面内容的场景，如实现向导界面、选项卡式界面或动态内容切换等。</p>
<h3 id="QStackedWidget-类的详细说明"><a href="#QStackedWidget-类的详细说明" class="headerlink" title="QStackedWidget 类的详细说明"></a><code>QStackedWidget</code> 类的详细说明</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul>
<li><strong><code>QStackedWidget</code></strong> 继承自 <code>QFrame</code>，属于一个容器小部件。</li>
<li>该控件维护一组子小部件，这些子小部件按堆栈排列。一次只能显示一个小部件，其他小部件会被隐藏。</li>
</ul>
<h4 id="2-常用方法和成员函数"><a href="#2-常用方法和成员函数" class="headerlink" title="2. 常用方法和成员函数"></a>2. 常用方法和成员函数</h4><ul>
<li><p><strong><code>addWidget(QWidget *widget)</code></strong>:<br>将新的小部件添加到堆栈中，返回新页面的索引值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStackedWidget *stackedWidget = <span class="keyword">new</span> QStackedWidget;</span><br><span class="line">QWidget *page1 = <span class="keyword">new</span> QWidget;</span><br><span class="line">stackedWidget-&gt;<span class="built_in">addWidget</span>(page1);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>insertWidget(int index, QWidget *widget)</code></strong>:<br>在指定索引位置插入一个小部件。</p>
</li>
<li><p><strong><code>setCurrentIndex(int index)</code></strong>:<br>设置当前显示的小部件的索引。可以通过此方法切换页面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>); <span class="comment">// 显示第一个页面</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>setCurrentWidget(QWidget *widget)</code></strong>:<br>通过指针设置当前显示的小部件。</p>
</li>
<li><p><strong><code>currentIndex()</code></strong>:<br>返回当前显示的小部件的索引。</p>
</li>
<li><p><strong><code>currentWidget()</code></strong>:<br>返回当前显示的小部件的指针。</p>
</li>
<li><p><strong><code>removeWidget(QWidget *widget)</code></strong>:<br>从堆栈中移除指定的小部件，不会删除该小部件。</p>
</li>
</ul>
<h4 id="3-信号（Signals）"><a href="#3-信号（Signals）" class="headerlink" title="3. 信号（Signals）"></a>3. 信号（Signals）</h4><ul>
<li><p><strong><code>currentChanged(int index)</code></strong>:<br>当当前小部件的索引改变时触发。</p>
</li>
<li><p><strong><code>widgetRemoved(int index)</code></strong>:<br>当小部件从堆栈中移除时触发。</p>
</li>
</ul>
<h4 id="4-使用示例"><a href="#4-使用示例" class="headerlink" title="4. 使用示例"></a>4. 使用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStackedWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 QStackedWidget 实例</span></span><br><span class="line">    QStackedWidget *stackedWidget = <span class="keyword">new</span> QStackedWidget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个页面</span></span><br><span class="line">    QWidget *page1 = <span class="keyword">new</span> QWidget;</span><br><span class="line">    QPushButton *button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Page 1&quot;</span>);</span><br><span class="line">    QVBoxLayout *page1Layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(page1);</span><br><span class="line">    page1Layout-&gt;<span class="built_in">addWidget</span>(button1);</span><br><span class="line"></span><br><span class="line">    QWidget *page2 = <span class="keyword">new</span> QWidget;</span><br><span class="line">    QPushButton *button2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Page 2&quot;</span>);</span><br><span class="line">    QVBoxLayout *page2Layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(page2);</span><br><span class="line">    page2Layout-&gt;<span class="built_in">addWidget</span>(button2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加页面到 QStackedWidget</span></span><br><span class="line">    stackedWidget-&gt;<span class="built_in">addWidget</span>(page1);</span><br><span class="line">    stackedWidget-&gt;<span class="built_in">addWidget</span>(page2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 QStackedWidget 添加到主布局</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(stackedWidget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换页面示例</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(button1, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(button2, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-常见应用场景"><a href="#5-常见应用场景" class="headerlink" title="5. 常见应用场景"></a>5. 常见应用场景</h3><ul>
<li><strong>向导程序</strong>: <code>QStackedWidget</code> 非常适合用于实现多步骤的向导程序，每个页面代表向导的一个步骤。</li>
<li><strong>动态内容切换</strong>: 如设置窗口、选项卡界面等。</li>
<li><strong>多功能面板</strong>: 实现功能区的页面切换。</li>
</ul>
<h3 id="6-样式和自定义"><a href="#6-样式和自定义" class="headerlink" title="6. 样式和自定义"></a>6. 样式和自定义</h3><p><code>QStackedWidget</code> 可以像其他 Qt 小部件一样通过 <code>QStyle</code> 和 <code>QSS</code>（Qt 样式表）来进行样式自定义。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStackedWidget &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a>7. 注意事项</h3><ul>
<li>如果需要在切换页面时进行一些处理逻辑，可以连接 <code>currentChanged()</code> 信号来进行。</li>
<li><code>QStackedWidget</code> 只会在其当前显示的小部件上处理事件，如鼠标和键盘事件，因此需要确保切换逻辑合理。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>QStackedWidget</code> 是一个非常有用的控件，用于实现页面切换或动态内容显示。通过其 API 和信号槽机制，开发者可以轻松创建复杂的用户界面，增强用户体验。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-03-QMainWindow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-03-QMainWindow/" class="post-title-link" itemprop="url">QMainWindow</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="QMainWindow-类-详解"><a href="#QMainWindow-类-详解" class="headerlink" title="QMainWindow 类 详解"></a>QMainWindow 类 详解</h2><p><code>QMainWindow</code> 是 Qt 框架中用于创建主窗口的类。它提供了一个标准的窗口框架，通常用于构建图形用户界面（GUI）应用程序的主窗口。<code>QMainWindow</code> 提供了功能齐全的窗口部件，如菜单栏、工具栏、状态栏等，以及一个中央区域用于显示主要内容。</p>
<h3 id="1-类定义"><a href="#1-类定义" class="headerlink" title="1. 类定义"></a>1. 类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QMainWindow</span> : <span class="keyword">public</span> QWidget</span><br></pre></td></tr></table></figure>
<p><code>QMainWindow</code> 继承自 <code>QWidget</code>，因此它也是一个 QWidget，具有所有 QWidget 的特性。</p>
<h3 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2. 主要功能"></a>2. 主要功能</h3><p><code>QMainWindow</code> 提供了一些标准的窗口元素和布局管理功能：</p>
<ul>
<li><strong>菜单栏</strong> (<code>QMenuBar</code>): 用于显示应用程序的菜单项。</li>
<li><strong>工具栏</strong> (<code>QToolBar</code>): 用于提供快捷工具按钮。</li>
<li><strong>状态栏</strong> (<code>QStatusBar</code>): 用于显示状态信息。</li>
<li><strong>中央区域</strong> (<code>QWidget</code>): 用于显示主内容区域，可以是任何其他的 QWidget。</li>
</ul>
<h3 id="3-关键成员函数"><a href="#3-关键成员函数" class="headerlink" title="3. 关键成员函数"></a>3. 关键成员函数</h3><h4 id="1-设置和获取中央窗口部件"><a href="#1-设置和获取中央窗口部件" class="headerlink" title="1. 设置和获取中央窗口部件"></a>1. <strong>设置和获取中央窗口部件</strong></h4><ul>
<li><code>void setCentralWidget(QWidget *widget)</code>: 设置主窗口的中央部件。</li>
<li><code>QWidget *centralWidget() const</code>: 获取当前的中央部件。</li>
</ul>
<h4 id="2-菜单栏管理"><a href="#2-菜单栏管理" class="headerlink" title="2. 菜单栏管理"></a>2. <strong>菜单栏管理</strong></h4><ul>
<li><code>QMenuBar *menuBar() const</code>: 获取菜单栏对象。如果需要在窗口中添加菜单项，可以使用此函数。</li>
</ul>
<h4 id="3-工具栏管理"><a href="#3-工具栏管理" class="headerlink" title="3. 工具栏管理"></a>3. <strong>工具栏管理</strong></h4><ul>
<li><code>QToolBar *addToolBar(const QString &amp;title)</code>: 添加工具栏到主窗口。</li>
<li><code>QToolBar *toolBar(const QString &amp;title) const</code>: 根据标题获取工具栏对象。</li>
</ul>
<h4 id="4-状态栏管理"><a href="#4-状态栏管理" class="headerlink" title="4. 状态栏管理"></a>4. <strong>状态栏管理</strong></h4><ul>
<li><code>QStatusBar *statusBar() const</code>: 获取状态栏对象，用于在窗口底部显示状态信息。</li>
<li><code>void setStatusBar(QStatusBar *statusBar)</code>: 设置自定义状态栏。</li>
</ul>
<h4 id="5-菜单和工具栏操作"><a href="#5-菜单和工具栏操作" class="headerlink" title="5. 菜单和工具栏操作"></a>5. <strong>菜单和工具栏操作</strong></h4><ul>
<li><code>void removeToolBar(QToolBar *toolbar)</code>: 从主窗口中移除工具栏。</li>
<li><code>void removeToolBarBreak(QToolBar *toolbar)</code>: 移除工具栏之间的分隔符。</li>
</ul>
<h3 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h3><p>以下是一个简单的使用 <code>QMainWindow</code> 的示例，展示了如何创建一个带有菜单栏、工具栏和状态栏的主窗口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStatusBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QMainWindow mainWindow;</span><br><span class="line">    mainWindow.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QMainWindow Example&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并设置中央部件</span></span><br><span class="line">    QWidget *centralWidget = <span class="keyword">new</span> QWidget;</span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Click Me&quot;</span>);</span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">    centralWidget-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    mainWindow.<span class="built_in">setCentralWidget</span>(centralWidget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建菜单栏</span></span><br><span class="line">    QMenuBar *menuBar = mainWindow.<span class="built_in">menuBar</span>();</span><br><span class="line">    QMenu *fileMenu = menuBar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;File&quot;</span>);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;Open&quot;</span>);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;Save&quot;</span>);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;Exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建工具栏</span></span><br><span class="line">    QToolBar *toolBar = mainWindow.<span class="built_in">addToolBar</span>(<span class="string">&quot;Main Toolbar&quot;</span>);</span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;Open&quot;</span>);</span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;Save&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建状态栏</span></span><br><span class="line">    QStatusBar *statusBar = <span class="keyword">new</span> QStatusBar;</span><br><span class="line">    mainWindow.<span class="built_in">setStatusBar</span>(statusBar);</span><br><span class="line">    statusBar-&gt;<span class="built_in">showMessage</span>(<span class="string">&quot;Ready&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示主窗口</span></span><br><span class="line">    mainWindow.<span class="built_in">resize</span>(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    mainWindow.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-继承和扩展"><a href="#5-继承和扩展" class="headerlink" title="5. 继承和扩展"></a>5. 继承和扩展</h3><p><code>QMainWindow</code> 可以被继承和扩展，以添加自定义功能或修改现有行为。例如，你可以创建一个自定义的主窗口类，添加额外的工具栏或菜单项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStatusBar&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainWindow</span> : <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyMainWindow</span>() &#123;</span><br><span class="line">        <span class="comment">// 自定义菜单</span></span><br><span class="line">        QMenu *fileMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;File&quot;</span>);</span><br><span class="line">        QAction *exitAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;Exit&quot;</span>);</span><br><span class="line">        <span class="built_in">connect</span>(exitAction, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;QMainWindow::close);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义工具栏</span></span><br><span class="line">        QToolBar *toolbar = <span class="built_in">addToolBar</span>(<span class="string">&quot;My Toolbar&quot;</span>);</span><br><span class="line">        toolbar-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;My Action&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义状态栏</span></span><br><span class="line">        <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="string">&quot;Welcome to My Application&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul>
<li><strong>中央部件</strong>：<code>QMainWindow</code> 只允许设置一个中央部件（<code>centralWidget</code>）。如果你需要在中央区域放置多个部件，可以使用布局管理器将它们组织起来。</li>
<li><strong>工具栏和菜单</strong>：工具栏和菜单可以动态添加或移除，但要确保在主窗口显示之前设置好它们。</li>
<li><strong>状态栏</strong>：状态栏通常用于显示应用程序的状态信息，可以显示多条信息或者使用复杂的状态显示组件。</li>
</ul>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p><code>QMainWindow</code> 是一个功能丰富的主窗口类，提供了标准的窗口元素，如菜单栏、工具栏和状态栏。它是构建 Qt GUI 应用程序的基础组件之一，并提供了丰富的接口来管理和定制窗口的各个部分。通过继承和扩展 <code>QMainWindow</code>，你可以创建符合需求的复杂主窗口。</p>
<h2 id="Qt-Ui-MainWindow-类-详解"><a href="#Qt-Ui-MainWindow-类-详解" class="headerlink" title="Qt Ui::MainWindow 类 详解"></a>Qt Ui::MainWindow 类 详解</h2><p>在 Qt 应用程序中，<code>Ui::MainWindow</code> 类通常是由 Qt Designer 生成的用于管理用户界面元素的类。它是 Qt UI 系统的重要组成部分，主要用于连接 UI 界面设计与应用程序逻辑。通常在使用 Qt Designer 设计主窗口时，生成的 <code>.ui</code> 文件会通过 <code>uic</code> 工具转换为 C++ 代码，其中包含一个 <code>Ui::MainWindow</code> 类。</p>
<h3 id="1-Ui-MainWindow-类的作用"><a href="#1-Ui-MainWindow-类的作用" class="headerlink" title="1. Ui::MainWindow 类的作用"></a>1. <strong><code>Ui::MainWindow</code> 类的作用</strong></h3><p><code>Ui::MainWindow</code> 是自动生成的类，它负责管理和初始化设计时创建的 UI 元素。这个类是由 Qt Designer 创建的 <code>.ui</code> 文件转换而来的，通常位于生成的 <code>ui_mainwindow.h</code> 文件中。它主要负责以下内容：</p>
<ul>
<li>创建和布局窗口控件。</li>
<li>初始化控件的属性和默认状态。</li>
<li>提供接口用于在代码中访问这些控件。</li>
</ul>
<h3 id="2-Ui-MainWindow-的使用方式"><a href="#2-Ui-MainWindow-的使用方式" class="headerlink" title="2. Ui::MainWindow 的使用方式"></a>2. <strong><code>Ui::MainWindow</code> 的使用方式</strong></h3><p>当你使用 Qt Designer 创建一个主窗口并将其保存为 <code>mainwindow.ui</code> 时，Qt 会自动生成一个 <code>ui_mainwindow.h</code> 文件，其中包含 <code>Ui::MainWindow</code> 类的定义。这个类可以通过在自定义的 <code>MainWindow</code> 类中包含 <code>ui_mainwindow.h</code> 文件来使用。</p>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><p>假设我们在 Qt Designer 中创建了一个主窗口，并保存为 <code>mainwindow.ui</code>。生成的 <code>ui_mainwindow.h</code> 文件会包含如下内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ui_mainwindow.h（自动生成的文件）</span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QWidget *centralWidget;</span><br><span class="line">    QMenuBar *menuBar;</span><br><span class="line">    QStatusBar *statusBar;</span><br><span class="line">    QPushButton *myButton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setupUi</span><span class="params">(QMainWindow *MainWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (MainWindow-&gt;<span class="built_in">objectName</span>().<span class="built_in">isEmpty</span>())</span><br><span class="line">            MainWindow-&gt;<span class="built_in">setObjectName</span>(QString::<span class="built_in">fromUtf8</span>(<span class="string">&quot;MainWindow&quot;</span>));</span><br><span class="line">        MainWindow-&gt;<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">        centralWidget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(MainWindow);</span><br><span class="line">        menuBar = <span class="keyword">new</span> <span class="built_in">QMenuBar</span>(MainWindow);</span><br><span class="line">        statusBar = <span class="keyword">new</span> <span class="built_in">QStatusBar</span>(MainWindow);</span><br><span class="line">        myButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(centralWidget);</span><br><span class="line">        myButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Click Me&quot;</span>);</span><br><span class="line"></span><br><span class="line">        MainWindow-&gt;<span class="built_in">setCentralWidget</span>(centralWidget);</span><br><span class="line">        MainWindow-&gt;<span class="built_in">setMenuBar</span>(menuBar);</span><br><span class="line">        MainWindow-&gt;<span class="built_in">setStatusBar</span>(statusBar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在自定义主窗口类中的使用："><a href="#在自定义主窗口类中的使用：" class="headerlink" title="在自定义主窗口类中的使用："></a>在自定义主窗口类中的使用：</h4><p>通常，我们会在自定义的主窗口类中使用 <code>Ui::MainWindow</code> 以便将设计的 UI 和应用逻辑结合在一起：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span>  <span class="comment">// 包含自动生成的 UI 类</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">        : QMainWindow(parent), ui(new Ui::MainWindow) &#123;</span></span><br><span class="line">        ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);  <span class="comment">// 初始化 UI</span></span><br><span class="line">        <span class="built_in">connect</span>(ui-&gt;myButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::onButtonClicked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MainWindow</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> ui;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onButtonClicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理按钮点击事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-setupUi-方法"><a href="#3-setupUi-方法" class="headerlink" title="3. setupUi() 方法"></a>3. <strong><code>setupUi()</code> 方法</strong></h3><p><code>setupUi()</code> 方法是 <code>Ui::MainWindow</code> 类中的核心方法。它负责初始化窗口控件并设置其布局、属性、信号槽连接等。通常在主窗口类的构造函数中调用该方法。这个方法需要一个 <code>QMainWindow</code> 对象作为参数，以便将控件添加到主窗口中。</p>
<h3 id="4-访问-UI-元素"><a href="#4-访问-UI-元素" class="headerlink" title="4. 访问 UI 元素"></a>4. <strong>访问 UI 元素</strong></h3><p>通过 <code>Ui::MainWindow</code> 类中的指针，可以轻松访问和操作设计时创建的控件。例如，使用 <code>ui-&gt;myButton</code> 可以访问按钮并设置它的文本或连接信号槽。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;myButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;New Text&quot;</span>);</span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;myButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::onButtonClicked);</span><br></pre></td></tr></table></figure>

<h3 id="5-Ui-MainWindow-与-QMainWindow-的关系"><a href="#5-Ui-MainWindow-与-QMainWindow-的关系" class="headerlink" title="5. Ui::MainWindow 与 QMainWindow 的关系"></a>5. <strong><code>Ui::MainWindow</code> 与 <code>QMainWindow</code> 的关系</strong></h3><p><code>Ui::MainWindow</code> 是一个辅助类，实际的窗口功能仍然由继承自 <code>QMainWindow</code> 的自定义类实现。<code>QMainWindow</code> 提供了主窗口的基本框架和功能（如菜单栏、状态栏、工具栏），而 <code>Ui::MainWindow</code> 主要负责管理控件和布局。</p>
<h3 id="6-自定义控件与扩展-UI"><a href="#6-自定义控件与扩展-UI" class="headerlink" title="6. 自定义控件与扩展 UI"></a>6. <strong>自定义控件与扩展 UI</strong></h3><p>如果你需要在设计时添加自定义控件或进行更多的 UI 扩展，可以在 Qt Designer 中通过提升控件的方式实现。此外，你也可以手动在 <code>MainWindow</code> 类的构造函数中添加新的控件，并将其与现有的 UI 进行整合。</p>
<h3 id="7-典型的工作流程"><a href="#7-典型的工作流程" class="headerlink" title="7. 典型的工作流程"></a>7. <strong>典型的工作流程</strong></h3><ul>
<li>使用 Qt Designer 设计主窗口，并保存为 <code>.ui</code> 文件。</li>
<li>通过 Qt 的构建工具（如 qmake 或 CMake）自动生成对应的 <code>ui_mainwindow.h</code> 文件。</li>
<li>在自定义的主窗口类中包含生成的 <code>ui_mainwindow.h</code> 文件，并使用 <code>Ui::MainWindow</code> 类来管理 UI 元素。</li>
<li>在应用程序逻辑中，使用 <code>ui-&gt;</code> 前缀来访问控件，并编写对应的事件处理代码。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Ui::MainWindow</code> 是一个自动生成的类，它负责将 Qt Designer 设计的 UI 界面与代码逻辑连接起来。通过调用 <code>setupUi()</code>，开发者可以方便地初始化和使用设计时创建的控件，从而简化了 UI 编程的流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-02-QApplication/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-02-QApplication/" class="post-title-link" itemprop="url">QApplication</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="QApplication-类-详解"><a href="#QApplication-类-详解" class="headerlink" title="QApplication 类 详解"></a>QApplication 类 详解</h2><p><code>QApplication</code> 类是 Qt 应用程序的核心类之一，用于管理应用程序的控制流和主要设置。它负责处理应用程序的初始化、事件循环、窗口管理、以及应用全局的设置。通常，一个 GUI 应用程序中只能有一个 <code>QApplication</code> 实例。</p>
<h3 id="1-类定义"><a href="#1-类定义" class="headerlink" title="1. 类定义"></a>1. 类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QApplication</span> : <span class="keyword">public</span> QGuiApplication</span><br></pre></td></tr></table></figure>
<p><code>QApplication</code> 继承自 <code>QGuiApplication</code>，并且通过其进一步继承了 <code>QCoreApplication</code>。<code>QApplication</code> 是 GUI 程序的基础，而 <code>QGuiApplication</code> 适用于不需要窗口但依然有 GUI 功能的程序（如 OpenGL 渲染等）。<code>QCoreApplication</code> 则用于没有 GUI 的控制台程序。</p>
<h3 id="2-创建-QApplication-对象"><a href="#2-创建-QApplication-对象" class="headerlink" title="2. 创建 QApplication 对象"></a>2. 创建 <code>QApplication</code> 对象</h3><p>在大多数情况下，<code>QApplication</code> 是程序的第一个创建的对象，并且程序的主要控制权交给了它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Hello, Qt!&quot;</span>)</span></span>;</span><br><span class="line">    button.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>QApplication app(argc, argv);</code> 初始化了应用程序对象。</li>
<li><code>app.exec();</code> 进入应用程序的事件循环，处理用户输入和其他事件。</li>
</ul>
<h3 id="3-主要功能和成员函数"><a href="#3-主要功能和成员函数" class="headerlink" title="3. 主要功能和成员函数"></a>3. 主要功能和成员函数</h3><p><code>QApplication</code> 提供了许多全局设置和管理功能：</p>
<h4 id="1-事件循环"><a href="#1-事件循环" class="headerlink" title="1. 事件循环"></a>1. <strong>事件循环</strong></h4><ul>
<li><code>int exec()</code>: 启动事件循环。应用程序在进入这个循环后开始运行，直到调用 <code>quit()</code> 或窗口关闭。</li>
<li><code>void exit(int returnCode = 0)</code>: 退出事件循环。</li>
</ul>
<h4 id="2-全局设置"><a href="#2-全局设置" class="headerlink" title="2. 全局设置"></a>2. <strong>全局设置</strong></h4><ul>
<li><code>void setStyle(const QString &amp;style)</code>: 设置应用程序的 GUI 样式，如 “Fusion”、”Windows”、”Macintosh” 等。</li>
<li><code>QStyle *style()</code>: 返回当前使用的样式。</li>
</ul>
<h4 id="3-应用程序信息"><a href="#3-应用程序信息" class="headerlink" title="3. 应用程序信息"></a>3. <strong>应用程序信息</strong></h4><ul>
<li><code>void setApplicationName(const QString &amp;name)</code>: 设置应用程序的名称。</li>
<li><code>QString applicationName()</code>: 获取应用程序的名称。</li>
<li><code>void setApplicationVersion(const QString &amp;version)</code>: 设置应用程序版本。</li>
<li><code>QString applicationVersion()</code>: 获取应用程序版本。</li>
</ul>
<h4 id="4-图标和主题"><a href="#4-图标和主题" class="headerlink" title="4. 图标和主题"></a>4. <strong>图标和主题</strong></h4><ul>
<li><code>void setWindowIcon(const QIcon &amp;icon)</code>: 设置应用程序的全局图标，这个图标会出现在应用窗口的标题栏、任务栏以及系统托盘中。</li>
<li><code>QIcon windowIcon()</code>: 获取应用程序的图标。</li>
</ul>
<h4 id="5-剪贴板"><a href="#5-剪贴板" class="headerlink" title="5. 剪贴板"></a>5. <strong>剪贴板</strong></h4><ul>
<li><code>QClipboard *clipboard()</code>: 返回系统的剪贴板对象，可以用来复制和粘贴文本、图片等数据。</li>
</ul>
<h4 id="6-应用程序事件处理"><a href="#6-应用程序事件处理" class="headerlink" title="6. 应用程序事件处理"></a>6. <strong>应用程序事件处理</strong></h4><ul>
<li><code>bool notify(QObject *receiver, QEvent *event)</code>: 事件通知处理函数，通常不需要重写，但可以在特殊情况下进行自定义事件处理。</li>
<li><code>void installEventFilter(QObject *filterObj)</code>: 安装事件过滤器，用于拦截和处理特定事件。</li>
</ul>
<h4 id="7-颜色与字体"><a href="#7-颜色与字体" class="headerlink" title="7. 颜色与字体"></a>7. <strong>颜色与字体</strong></h4><ul>
<li><code>void setPalette(const QPalette &amp;palette)</code>: 设置全局调色板，影响整个应用程序的颜色风格。</li>
<li><code>QFont font()</code>: 获取当前应用程序的全局字体。</li>
<li><code>void setFont(const QFont &amp;font)</code>: 设置应用程序的全局字体。</li>
</ul>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul>
<li><code>QApplication</code> 是一个 GUI 应用的核心，因此所有 GUI 应用必须创建 <code>QApplication</code> 对象。</li>
<li>一个应用程序中只能有一个 <code>QApplication</code> 实例。如果尝试创建多个，会导致程序异常。</li>
<li><code>QApplication</code> 必须在创建任何其他 Qt 对象之前创建。</li>
</ul>
<h3 id="5-常见的使用场景"><a href="#5-常见的使用场景" class="headerlink" title="5. 常见的使用场景"></a>5. 常见的使用场景</h3><ul>
<li><strong>应用程序启动和事件管理</strong>: <code>QApplication</code> 的主要职责是启动并维持事件循环，这是 GUI 程序处理用户输入、界面更新的基础。</li>
<li><strong>全局设置</strong>: <code>QApplication</code> 允许你为整个应用程序设置默认的字体、颜色、样式等。</li>
<li><strong>跨平台支持</strong>: Qt 中的 <code>QApplication</code> 处理了许多跨平台细节，使得开发者可以在不同平台上使用一致的 API。</li>
</ul>
<h3 id="6-示例代码"><a href="#6-示例代码" class="headerlink" title="6. 示例代码"></a>6. 示例代码</h3><p>以下是一个更完整的示例，展示了如何使用 <code>QApplication</code> 设置全局样式和图标：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QIcon&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置应用程序信息</span></span><br><span class="line">    app.<span class="built_in">setApplicationName</span>(<span class="string">&quot;My Qt Application&quot;</span>);</span><br><span class="line">    app.<span class="built_in">setApplicationVersion</span>(<span class="string">&quot;1.0.0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置应用程序图标</span></span><br><span class="line">    app.<span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/resources/myicon.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个按钮并显示</span></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Click Me&quot;</span>)</span></span>;</span><br><span class="line">    button.<span class="built_in">setFont</span>(<span class="built_in">QFont</span>(<span class="string">&quot;Arial&quot;</span>, <span class="number">18</span>));  <span class="comment">// 设置字体</span></span><br><span class="line">    button.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-继承与扩展"><a href="#7-继承与扩展" class="headerlink" title="7. 继承与扩展"></a>7. 继承与扩展</h3><p>在一些复杂的应用中，可以通过继承 <code>QApplication</code> 来扩展其功能。例如，可以重写 <code>notify()</code> 函数来捕获所有事件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplication</span> : <span class="keyword">public</span> QApplication &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyApplication</span>(<span class="type">int</span> &amp;argc, <span class="type">char</span> **argv) : <span class="built_in">QApplication</span>(argc, argv) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">notify</span><span class="params">(QObject *receiver, QEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在此进行自定义事件处理</span></span><br><span class="line">        <span class="keyword">return</span> QApplication::<span class="built_in">notify</span>(receiver, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p><code>QApplication</code> 是 Qt GUI 应用程序的基础，它负责管理事件循环、全局设置、样式、系统剪贴板等。理解并熟练使用 <code>QApplication</code> 是开发 Qt GUI 应用程序的重要步骤。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-04-QByteArray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-04-QByteArray/" class="post-title-link" itemprop="url">QByteArray</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Qt-QByteArray-类-详解"><a href="#Qt-QByteArray-类-详解" class="headerlink" title="Qt QByteArray 类 详解"></a>Qt QByteArray 类 详解</h2><p><code>QByteArray</code> 是 Qt 框架中用于处理字节数据的类。它类似于 C++ 标准库中的 <code>std::string</code>，但专门设计用来处理原始字节数据。<code>QByteArray</code> 提供了许多功能，包括存储和操作字节数据、支持多种编码、以及对比和查找等操作。以下是对 <code>QByteArray</code> 类的详细解解：</p>
<h3 id="1-基本功能"><a href="#1-基本功能" class="headerlink" title="1. 基本功能"></a>1. <strong>基本功能</strong></h3><ul>
<li><p><strong>定义和初始化</strong>：<br><code>QByteArray</code> 可以用多种方式初始化，包括从 C 风格字符串、Qt 字符串（<code>QString</code>）、或者通过构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QByteArray byteArray1; <span class="comment">// 空的字节数组</span></span><br><span class="line"><span class="function">QByteArray <span class="title">byteArray2</span><span class="params">(<span class="string">&quot;Hello, world!&quot;</span>)</span></span>; <span class="comment">// 从 C 风格字符串初始化</span></span><br><span class="line"><span class="function">QByteArray <span class="title">byteArray3</span><span class="params">(QString(<span class="string">&quot;Hello, world!&quot;</span>).toUtf8())</span></span>; <span class="comment">// 从 QString 初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>存储字节数据</strong>：<br><code>QByteArray</code> 用于存储字节数据，可以方便地进行操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">byteArray</span><span class="params">(<span class="string">&quot;Data&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. <strong>基本操作</strong></h3><ul>
<li><p><strong>追加和插入</strong>：<br>可以使用 <code>append()</code> 和 <code>insert()</code> 方法将数据追加到字节数组的末尾或在指定位置插入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byteArray.<span class="built_in">append</span>(<span class="string">&quot; more data&quot;</span>);</span><br><span class="line">byteArray.<span class="built_in">insert</span>(<span class="number">4</span>, <span class="string">&quot; insert&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>移除和替换</strong>：<br><code>remove()</code> 方法用于删除字节数据，而 <code>replace()</code> 用于替换指定范围的字节数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byteArray.<span class="built_in">remove</span>(<span class="number">4</span>, <span class="number">6</span>); <span class="comment">// 从位置4开始，删除6个字节</span></span><br><span class="line">byteArray.<span class="built_in">replace</span>(<span class="string">&quot;insert&quot;</span>, <span class="string">&quot;replace&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>清空和检查</strong>：<br><code>clear()</code> 方法可以清空字节数组，<code>isEmpty()</code> 方法用于检查字节数组是否为空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byteArray.<span class="built_in">clear</span>();</span><br><span class="line"><span class="type">bool</span> isEmpty = byteArray.<span class="built_in">isEmpty</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-编码和解码"><a href="#3-编码和解码" class="headerlink" title="3. 编码和解码"></a>3. <strong>编码和解码</strong></h3><ul>
<li><p><strong>与 QString 互转</strong>：<br><code>QByteArray</code> 可以方便地与 <code>QString</code> 转换，使用 <code>toStdString()</code> 可以转换为 <code>std::string</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">QByteArray byteArray = str.<span class="built_in">toUtf8</span>();</span><br><span class="line">QString backToStr = QString::<span class="built_in">fromUtf8</span>(byteArray);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编码和解码</strong>：<br><code>QByteArray</code> 支持多种编码格式，如 UTF-8、Latin1 等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QByteArray utf8Array = <span class="string">&quot;UTF-8 data&quot;</span>;</span><br><span class="line">QByteArray latin1Array = utf8Array.<span class="built_in">toLatin1</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-查找和比较"><a href="#4-查找和比较" class="headerlink" title="4. 查找和比较"></a>4. <strong>查找和比较</strong></h3><ul>
<li><p><strong>查找子串</strong>：<br>使用 <code>indexOf()</code> 方法查找子字节串的位置，<code>contains()</code> 方法检查是否包含某个子字节串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pos = byteArray.<span class="built_in">indexOf</span>(<span class="string">&quot;data&quot;</span>);</span><br><span class="line"><span class="type">bool</span> contains = byteArray.<span class="built_in">contains</span>(<span class="string">&quot;data&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>比较字节数组</strong>：<br>使用 <code>compare()</code> 方法比较两个字节数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">byteArray1</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray <span class="title">byteArray2</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> result = QByteArray::<span class="built_in">compare</span>(byteArray1, byteArray2); <span class="comment">// 0 表示相等</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-转换和操作"><a href="#5-转换和操作" class="headerlink" title="5. 转换和操作"></a>5. <strong>转换和操作</strong></h3><ul>
<li><p>**转换为 <code>std::string</code>**：<br>可以通过 <code>toStdString()</code> 方法将 <code>QByteArray</code> 转换为标准 C++ 字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string stdString = byteArray.<span class="built_in">toStdString</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>操作字节数据</strong>：<br><code>QByteArray</code> 提供了类似于 C++ 数组的操作，例如直接访问字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> firstByte = byteArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-文件操作"><a href="#6-文件操作" class="headerlink" title="6. 文件操作"></a>6. <strong>文件操作</strong></h3><ul>
<li><p><strong>读写文件</strong>：<br><code>QByteArray</code> 可用于处理文件内容，可以与 <code>QFile</code> 类一起使用来读取和写入字节数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;example.dat&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (file.<span class="built_in">open</span>(QIODevice::ReadWrite)) &#123;</span><br><span class="line">    QByteArray data = file.<span class="built_in">readAll</span>();</span><br><span class="line">    file.<span class="built_in">write</span>(<span class="string">&quot;New data&quot;</span>);</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QByteArray <span class="title">byteArray</span><span class="params">(<span class="string">&quot;Hello, world!&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Append data</span></span><br><span class="line">    byteArray.<span class="built_in">append</span>(<span class="string">&quot; Welcome to Qt.&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Replace part of the string</span></span><br><span class="line">    byteArray.<span class="built_in">replace</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Qt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Convert to QString</span></span><br><span class="line">    QString str = QString::<span class="built_in">fromUtf8</span>(byteArray);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Print the result</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; str;  <span class="comment">// Output: Hello, Qt! Welcome to Qt.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>QByteArray</code> 是处理字节数据时非常有用的类，特别是在涉及到编码转换、数据传输和文件操作时。它提供了灵活且高效的字节数据处理功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-06-QTimer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-06-QTimer/" class="post-title-link" itemprop="url">QTimer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Qt-QTimer-类-详解"><a href="#Qt-QTimer-类-详解" class="headerlink" title="Qt QTimer 类 详解"></a>Qt QTimer 类 详解</h2><p><code>QTimer</code> 是 Qt 框架中的一个用于定时和计时的类。它提供了一种非常方便的方式来设置定时器，并在定时器超时时执行指定的操作。<code>QTimer</code> 在 Qt 的事件驱动模型中非常重要，尤其适合在需要周期性或延迟执行操作的场景中使用，例如动画、定时任务、用户界面刷新等。</p>
<h3 id="1-QTimer-的基本功能"><a href="#1-QTimer-的基本功能" class="headerlink" title="1. QTimer 的基本功能"></a>1. <strong><code>QTimer</code> 的基本功能</strong></h3><ul>
<li><p><strong>定时器类型</strong>：</p>
<ul>
<li><strong>单次定时器</strong>：定时器触发一次后就自动停止。</li>
<li><strong>循环定时器</strong>：定时器以固定的时间间隔循环触发，直到手动停止。</li>
</ul>
</li>
<li><p><strong>信号与槽机制</strong>：<br><code>QTimer</code> 依赖于信号和槽机制，定时器超时时会发出 <code>timeout()</code> 信号，应用程序可以连接到这个信号并执行特定的槽函数。</p>
</li>
</ul>
<h3 id="2-QTimer-的常用方法"><a href="#2-QTimer-的常用方法" class="headerlink" title="2. QTimer 的常用方法"></a>2. <strong><code>QTimer</code> 的常用方法</strong></h3><ul>
<li>**<code>start(int msec)</code>**：启动定时器，参数 <code>msec</code> 是以毫秒为单位的间隔时间。</li>
<li>**<code>stop()</code>**：停止定时器。如果定时器正在运行，它会被停止，且不会再触发。</li>
<li>**<code>setInterval(int msec)</code>**：设置定时器的间隔时间（单位：毫秒）。</li>
<li>**<code>setSingleShot(bool singleShot)</code>**：设置定时器是否为单次触发。如果设置为 <code>true</code>，定时器在超时后会自动停止。</li>
<li>**<code>isActive()</code>**：检查定时器是否正在运行。</li>
<li>**<code>remainingTime()</code>**：返回定时器剩余的时间（单位：毫秒）。如果定时器已超时或停止，则返回 -1。</li>
</ul>
<h3 id="3-QTimer-的使用方式"><a href="#3-QTimer-的使用方式" class="headerlink" title="3. QTimer 的使用方式"></a>3. <strong><code>QTimer</code> 的使用方式</strong></h3><p><code>QTimer</code> 可以有两种常见的使用方式：</p>
<ol>
<li><strong>直接使用 <code>QTimer</code> 静态方法</strong>。</li>
<li><strong>创建 <code>QTimer</code> 对象，并将其与槽函数连接</strong>。</li>
</ol>
<h4 id="3-1-直接使用静态方法"><a href="#3-1-直接使用静态方法" class="headerlink" title="3.1 直接使用静态方法"></a>3.1 直接使用静态方法</h4><ul>
<li><p>**<code>QTimer::singleShot(int msec, const QObject *receiver, const char *member)</code>**：<br>这是一个静态方法，适合用于只需要延迟执行一次的操作。它会在指定时间后发出信号并调用连接的槽函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>, <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">doSomething</span>())); <span class="comment">// 2秒后调用槽函数 doSomething()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-2-创建-QTimer-对象"><a href="#3-2-创建-QTimer-对象" class="headerlink" title="3.2 创建 QTimer 对象"></a>3.2 创建 <code>QTimer</code> 对象</h4><p>你可以创建一个 <code>QTimer</code> 对象并手动控制它的启动、停止和触发。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyObject</span>() &#123;</span><br><span class="line">        <span class="comment">// 创建定时器</span></span><br><span class="line">        timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 连接定时器的超时信号到槽函数</span></span><br><span class="line">        <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;MyObject::onTimeout);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置定时器为循环模式，每隔1秒触发一次</span></span><br><span class="line">        timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>); <span class="comment">// 1000毫秒 = 1秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Timer triggered!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QTimer *timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-单次定时器与循环定时器"><a href="#4-单次定时器与循环定时器" class="headerlink" title="4. 单次定时器与循环定时器"></a>4. <strong>单次定时器与循环定时器</strong></h3><ul>
<li><p><strong>单次定时器</strong>：在 <code>QTimer</code> 中可以通过设置 <code>setSingleShot(true)</code> 或使用 <code>QTimer::singleShot()</code> 来实现单次定时器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">timer-&gt;<span class="built_in">setSingleShot</span>(<span class="literal">true</span>);  <span class="comment">// 设置为单次定时器</span></span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">2000</span>);  <span class="comment">// 2秒后触发</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>循环定时器</strong>：默认情况下，<code>QTimer</code> 是循环定时器，即每隔指定的时间间隔触发一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);  <span class="comment">// 每隔1秒触发</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-定时器的精度"><a href="#5-定时器的精度" class="headerlink" title="5. 定时器的精度"></a>5. <strong>定时器的精度</strong></h3><ul>
<li><code>QTimer</code> 是基于 Qt 事件循环的，因此它的精度受限于系统的事件调度机制。在处理复杂的 UI 或繁重任务时，定时器的精度可能受到影响。通常情况下，<code>QTimer</code> 可以提供毫秒级的精度，但并不适用于需要严格实时性的场景。</li>
</ul>
<h3 id="6-定时器的线程安全性"><a href="#6-定时器的线程安全性" class="headerlink" title="6. 定时器的线程安全性"></a>6. <strong>定时器的线程安全性</strong></h3><ul>
<li><code>QTimer</code> 必须在其所属的线程中使用。如果你在多线程环境中使用定时器，确保定时器与其所在的线程一致。可以使用 <code>QTimer</code> 和 <code>QThread</code> 的组合来在子线程中处理定时任务。</li>
</ul>
<h3 id="7-常见用例"><a href="#7-常见用例" class="headerlink" title="7. 常见用例"></a>7. <strong>常见用例</strong></h3><ul>
<li><strong>动画刷新</strong>：通过定时器定期更新 UI 元素的状态。</li>
<li><strong>定时任务</strong>：在应用程序中定时执行某些任务，例如自动保存、定时更新数据等。</li>
<li><strong>延迟操作</strong>：在特定时间后执行某一操作，如提示信息延迟消失。</li>
</ul>
<h3 id="8-QTimer-示例"><a href="#8-QTimer-示例" class="headerlink" title="8. QTimer 示例"></a>8. <strong>QTimer 示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QMainWindow mainWindow;</span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, Qt!&quot;</span>, &amp;mainWindow);</span><br><span class="line">    mainWindow.<span class="built_in">setCentralWidget</span>(label);</span><br><span class="line"></span><br><span class="line">    QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(&amp;mainWindow);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [&amp;]() &#123;</span><br><span class="line">        label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Timer triggered!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">2000</span>); <span class="comment">// 2秒后触发</span></span><br><span class="line"></span><br><span class="line">    mainWindow.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>QTimer</code> 是一个强大且灵活的定时工具，在 Qt 开发中广泛用于管理定时任务。它与 Qt 的信号和槽机制紧密集成，使得处理异步操作和事件驱动编程变得更加容易。无论是周期性操作还是一次性延迟操作，<code>QTimer</code> 都能够提供理想的解决方案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
