<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/10/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/10/15/notebook/Qt/2024-10-15_qt_7_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/15/notebook/Qt/2024-10-15_qt_7_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">qt_7_常见问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-15 10:00:00" itemprop="dateCreated datePublished" datetime="2024-10-15T10:00:00+08:00">2024-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Qt开发过程中遇到的问题及解决方案</li>
</ul>
<h2 id="VS2022-打开ui文件自动退出问题"><a href="#VS2022-打开ui文件自动退出问题" class="headerlink" title="VS2022 打开ui文件自动退出问题"></a>VS2022 打开ui文件自动退出问题</h2><ul>
<li>选择“扩展-&gt;QT VS Tools-&gt;Options”，对话框中左侧选择“Qt-&gt;General”，右侧选择“Qt Designer-&gt;Run in detached window”选项值设为true 即可解决。</li>
</ul>
<h2 id="VS2022-cmake-加载ui文件无法生成头文件问题"><a href="#VS2022-cmake-加载ui文件无法生成头文件问题" class="headerlink" title="VS2022 cmake 加载ui文件无法生成头文件问题"></a>VS2022 cmake 加载ui文件无法生成头文件问题</h2><ul>
<li>选择 “项目-&gt;使用cmake调试器配置” 选项重新配置项目</li>
<li>重启VS</li>
</ul>
<h2 id="qt5-字符编码问题"><a href="#qt5-字符编码问题" class="headerlink" title="qt5 字符编码问题"></a>qt5 字符编码问题</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/802984">https://developer.aliyun.com/article/802984</a></li>
</ul>
<h2 id="Qt中MainWindow界面最大化按钮是灰色的"><a href="#Qt中MainWindow界面最大化按钮是灰色的" class="headerlink" title="Qt中MainWindow界面最大化按钮是灰色的"></a>Qt中MainWindow界面最大化按钮是灰色的</h2><ul>
<li>在Qt Designer中将maximumSize的值设置为16777215x16777215即可使窗口打开时最大化按钮可用。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/10/15/notebook/Qt/2024-10-15-qt_6_%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/15/notebook/Qt/2024-10-15-qt_6_%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">qt_6_应用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-15 09:00:00" itemprop="dateCreated datePublished" datetime="2024-10-15T09:00:00+08:00">2024-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>基于Qt5的桌面应用软件开发常见技巧</li>
</ul>
<h2 id="Qt-设置标签的背景颜色和透明度"><a href="#Qt-设置标签的背景颜色和透明度" class="headerlink" title="Qt 设置标签的背景颜色和透明度"></a>Qt 设置标签的背景颜色和透明度</h2><p>在 Qt 中，可以通过多种方式设置 <code>QLabel</code> 的背景颜色和透明度。以下是具体方法：</p>
<hr>
<h2 id="1-使用样式表-setStyleSheet"><a href="#1-使用样式表-setStyleSheet" class="headerlink" title="1. 使用样式表 (setStyleSheet)"></a><strong>1. 使用样式表 (<code>setStyleSheet</code>)</strong></h2><h3 id="设置背景颜色"><a href="#设置背景颜色" class="headerlink" title="设置背景颜色"></a><strong>设置背景颜色</strong></h3><p>通过 <code>setStyleSheet</code>，可以使用 CSS 样式为 <code>QLabel</code> 设置背景颜色。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, Qt!&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightblue; color: black;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong>:</p>
<ul>
<li>标签背景为浅蓝色，文字颜色为黑色。</li>
</ul>
<hr>
<h3 id="设置背景透明度"><a href="#设置背景透明度" class="headerlink" title="设置背景透明度"></a><strong>设置背景透明度</strong></h3><p>使用 <code>rgba</code> 或 <code>hsla</code> 颜色值可以设置背景透明度。</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Transparent Background&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: rgba(0, 0, 255, 0.5); color: white;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong>:</p>
<ul>
<li>背景颜色为半透明蓝色，文字颜色为白色。</li>
</ul>
<hr>
<h2 id="2-使用-QPalette-设置背景颜色"><a href="#2-使用-QPalette-设置背景颜色" class="headerlink" title="2. 使用 QPalette 设置背景颜色"></a><strong>2. 使用 <code>QPalette</code> 设置背景颜色</strong></h2><p><code>QPalette</code> 是 Qt 中管理控件颜色的类，适用于简单背景颜色的设置。</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, Palette!&quot;</span>);</span><br><span class="line">QPalette palette = label-&gt;<span class="built_in">palette</span>();</span><br><span class="line">palette.<span class="built_in">setColor</span>(QPalette::Window, <span class="built_in">QColor</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">127</span>)); <span class="comment">// 设置半透明蓝色</span></span><br><span class="line">label-&gt;<span class="built_in">setAutoFillBackground</span>(<span class="literal">true</span>); <span class="comment">// 启用背景填充</span></span><br><span class="line">label-&gt;<span class="built_in">setPalette</span>(palette);</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong>:</p>
<ul>
<li>背景为半透明蓝色。</li>
</ul>
<hr>
<h2 id="3-自定义绘制-paintEvent"><a href="#3-自定义绘制-paintEvent" class="headerlink" title="3. 自定义绘制 (paintEvent)"></a><strong>3. 自定义绘制 (<code>paintEvent</code>)</strong></h2><p>对于高度定制的背景绘制，可以重写 <code>paintEvent</code> 方法。</p>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TransparentLabel</span> : <span class="keyword">public</span> QLabel &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        painter.<span class="built_in">setBrush</span>(<span class="built_in">QBrush</span>(<span class="built_in">QColor</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">127</span>))); <span class="comment">// 半透明蓝色</span></span><br><span class="line">        painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">        painter.<span class="built_in">drawRect</span>(<span class="keyword">this</span>-&gt;<span class="built_in">rect</span>());</span><br><span class="line">        QLabel::<span class="built_in">paintEvent</span>(event); <span class="comment">// 绘制文字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong>:</p>
<ul>
<li>标签背景为半透明蓝色，支持自定义绘制逻辑。</li>
</ul>
<hr>
<h2 id="4-背景和文字透明独立处理"><a href="#4-背景和文字透明独立处理" class="headerlink" title="4. 背景和文字透明独立处理"></a><strong>4. 背景和文字透明独立处理</strong></h2><p>如果需要设置背景透明，同时保持文字完全不透明，可以使用伪类或层叠元素技术：</p>
<h3 id="伪类方法"><a href="#伪类方法" class="headerlink" title="伪类方法"></a><strong>伪类方法</strong></h3><p>通过 <code>::before</code> 添加一个透明背景层：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Text with Transparent Background&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(</span><br><span class="line">    <span class="string">&quot;QLabel &#123; color: black; &#125; &quot;</span></span><br><span class="line">    <span class="string">&quot;QLabel::before &#123; content: &#x27;&#x27;; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 255, 0.5); z-index: -1; &#125;&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a><strong>完整示例</strong></h2><p>以下示例演示如何结合 <code>QLabel</code> 和样式表设置透明背景及文本颜色：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QLabel Background Example&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    QLabel *label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Opaque Background&quot;</span>);</span><br><span class="line">    label1-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightblue; color: black;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QLabel *label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Transparent Background&quot;</span>);</span><br><span class="line">    label2-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: rgba(255, 0, 0, 0.5); color: white;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label1);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label2);</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行效果</strong>:</p>
<ul>
<li>第一行是背景不透明的标签。</li>
<li>第二行是带有透明背景的标签。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>setStyleSheet</code></td>
<td>简单背景颜色和透明度设置</td>
<td>易于实现，语法类似 CSS</td>
</tr>
<tr>
<td><code>QPalette</code></td>
<td>设置单一颜色的背景</td>
<td>使用标准 API，易于理解</td>
</tr>
<tr>
<td><code>paintEvent</code></td>
<td>高度自定义背景绘制</td>
<td>灵活控制绘制行为</td>
</tr>
<tr>
<td>伪类或叠加元素</td>
<td>背景和文字透明度独立设置</td>
<td>背景透明但文字保持清晰</td>
</tr>
</tbody></table>
<p>根据实际需求选择适合的方法，即可轻松实现 QLabel 的背景颜色和透明度设置！</p>
<h2 id="设置子窗口显示在父窗口的位置-绝对坐标"><a href="#设置子窗口显示在父窗口的位置-绝对坐标" class="headerlink" title="设置子窗口显示在父窗口的位置 (绝对坐标)"></a>设置子窗口显示在父窗口的位置 (绝对坐标)</h2><ul>
<li>需求：需要在父窗体弹出消息提示框，弹出的位置是相对于父窗体的位置</li>
<li>方法<ul>
<li>获取父窗口相对于屏幕的坐标，即绝对坐标</li>
<li>计算子窗口的坐标</li>
<li>移动窗口</li>
</ul>
</li>
<li>示例如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NewMainWindow::MessageAlertButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QLabel* label_ptr = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;this is a message alert...&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    label_ptr-&gt;<span class="built_in">setWindowFlags</span>(Qt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br><span class="line">    label_ptr-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: green; color: white; padding: 10px; border-radius: 5px;&quot;</span>);</span><br><span class="line">    label_ptr-&gt;<span class="built_in">setAlignment</span>(Qt::AlignHCenter);</span><br><span class="line">    label_ptr-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    QPoint global_pos = <span class="built_in">mapToGlobal</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    label_ptr-&gt;<span class="built_in">move</span>(global_pos.<span class="built_in">x</span>() + <span class="built_in">width</span>() / <span class="number">2</span> - label_ptr-&gt;<span class="built_in">width</span>() / <span class="number">2</span>, global_pos.<span class="built_in">y</span>() + <span class="number">50</span>);</span><br><span class="line">    label_ptr-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器 3 秒后关闭窗口</span></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">3000</span>, label_ptr, &amp;QLabel::deleteLater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="建立一个最简单的窗口"><a href="#建立一个最简单的窗口" class="headerlink" title="建立一个最简单的窗口"></a>建立一个最简单的窗口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span> <span class="comment">//主函数入口，编译器将会从这里开始启动程序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc,argv)</span></span>;  <span class="comment">//启动Qt的应用程序，相当于初始化Qt的框架</span></span><br><span class="line">    QWidget w;                  <span class="comment">//QWidget类是所有用户界面对象的基类</span></span><br><span class="line">    w.<span class="built_in">resize</span>(<span class="number">400</span>,<span class="number">300</span>);          <span class="comment">//设置界面宽为400像素，高为300像素</span></span><br><span class="line">    w.<span class="built_in">show</span>();                   <span class="comment">//展示界面</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();            <span class="comment">//程序在a的事件循环里执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/10/13/notebook/Diary/2024-10-13-%E7%BD%91%E7%BB%9C%E6%97%A5%E8%AE%B0001/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/13/notebook/Diary/2024-10-13-%E7%BD%91%E7%BB%9C%E6%97%A5%E8%AE%B0001/" class="post-title-link" itemprop="url">网络日记001</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-13 09:00:00" itemprop="dateCreated datePublished" datetime="2024-10-13T09:00:00+08:00">2024-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Diary/" itemprop="url" rel="index"><span itemprop="name">Diary</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网路日记001"><a href="#网路日记001" class="headerlink" title="网路日记001"></a>网路日记001</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>今天是周六，在图书馆学习qt，但是收获很少且效率很低。目前我对于职业方向很迷茫，我需要解决这个问题，但不能只在脑海中思考，还要落在实处。所以，我开始写网络日记，试图让思考的过程有迹可循。网络日记并不是一天一篇，而是隔几天总结自己的现状和未来的思考。</p>
<h2 id="当前现状"><a href="#当前现状" class="headerlink" title="当前现状"></a>当前现状</h2><p>在一家做机器人的公司工作，岗位是机器人软件研发工程师，方向是机器人应用模块开发。当前参加的两个项目为碰钉机器人和装板机器人，两者都为移动地盘＋机械臂＋末端工具，项目架构分为通信模块，机器人模块，任务模块，视觉模块。我负责任务模块。</p>
<p>当前开发环境在windows平台，用到的开发工具有 VSCode，Visual Studio 2022，CLion。用到的第三方库有qt，spdlog。</p>
<h2 id="当前困难"><a href="#当前困难" class="headerlink" title="当前困难"></a>当前困难</h2><p>代码开发工作较少且难度较低，更多的是现场调试。与视觉没有关系，与底层没有关系，纯纯业务开发。</p>
<p>这样的情况产生的问题有：</p>
<ul>
<li>代码提升有限</li>
<li>开发环境和技术栈并不通用，不便于跳槽</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/09/23/notebook/Tools/2024-09-20-SVN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/23/notebook/Tools/2024-09-20-SVN/" class="post-title-link" itemprop="url">SVN</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-09-23 10:00:00" itemprop="dateCreated datePublished" datetime="2024-09-23T10:00:00+08:00">2024-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>svn项目管理工具学习笔记</li>
</ul>
<h2 id="SVN是什么"><a href="#SVN是什么" class="headerlink" title="SVN是什么"></a>SVN是什么</h2><p>SVN，全称为<strong>Subversion</strong>，是一种开源的<strong>版本控制系统</strong>（Version Control System，简称VCS）。它用于管理和跟踪文件的版本，特别是在多个开发人员协作时对代码的管理。SVN 允许团队成员对项目中的文件进行修改、查看历史版本、合并更改，并在需要时还原到以前的版本。</p>
<p>SVN 的主要功能包括：</p>
<ol>
<li><strong>版本控制</strong>：跟踪文件的每一次修改，记录历史版本。</li>
<li><strong>分支和标签</strong>：可以为代码创建分支，以便并行开发不同的功能，标签用于标记特定版本。</li>
<li><strong>并行开发</strong>：多人可以同时对相同文件进行修改，SVN会处理合并冲突。</li>
<li><strong>回滚</strong>：可以将文件恢复到先前的版本。</li>
<li><strong>集中式存储库</strong>：SVN 使用的是一个中央的存储库，所有的代码和历史记录都保存在这个中央服务器上，用户通过客户端与服务器进行交互。</li>
</ol>
<p>SVN 在早期非常流行，特别是在 Git 等分布式版本控制系统普及之前。现在，许多开发团队已经转向 Git，但 SVN 依然在一些企业和项目中使用。</p>
<h2 id="SVN版本控制系统-详解"><a href="#SVN版本控制系统-详解" class="headerlink" title="SVN版本控制系统 详解"></a>SVN版本控制系统 详解</h2><p>SVN（<strong>Subversion</strong>）是一种<strong>集中式版本控制系统</strong>，用于管理项目中文件和目录的变更。其目的是帮助开发者更高效地协作，同时保证项目文件的完整性和历史记录。下面是 SVN 的详细介绍，包括其工作原理、架构、核心概念及主要功能。</p>
<h3 id="1-SVN-的工作原理"><a href="#1-SVN-的工作原理" class="headerlink" title="1. SVN 的工作原理"></a>1. SVN 的工作原理</h3><p>SVN 采用<strong>集中式版本控制模型</strong>，即所有的项目文件都存储在一个<strong>中央存储库</strong>（Repository）中。开发人员通过客户端从存储库中获取文件的副本，并在本地工作。修改完成后，用户可以将更改提交回中央存储库。</p>
<p>SVN 的工作流程通常如下：</p>
<ol>
<li><strong>Checkout</strong>：开发者从中央存储库拉取项目的当前版本到本地进行修改。</li>
<li><strong>Update</strong>：开发者在提交之前，通常会先更新本地的代码库，获取其他开发者提交的最新修改。</li>
<li><strong>Commit</strong>：修改完成后，开发者将更改提交到中央存储库，产生一个新的版本。</li>
<li><strong>Merge</strong>：如果有冲突，SVN 会帮助开发者合并不同的修改。</li>
</ol>
<h3 id="2-SVN-的架构"><a href="#2-SVN-的架构" class="headerlink" title="2. SVN 的架构"></a>2. SVN 的架构</h3><p>SVN 的架构分为两个主要部分：</p>
<ul>
<li><strong>SVN 服务器</strong>：存储所有的文件和它们的历史版本，用户通过网络连接到 SVN 服务器进行协作。服务器可以部署在本地或远程。</li>
<li><strong>SVN 客户端</strong>：用户通过客户端与服务器交互，可以从服务器拉取文件、提交修改、查看历史等。常见的 SVN 客户端包括 TortoiseSVN、命令行客户端等。</li>
</ul>
<h3 id="3-SVN-的核心概念"><a href="#3-SVN-的核心概念" class="headerlink" title="3. SVN 的核心概念"></a>3. SVN 的核心概念</h3><ul>
<li><strong>Repository（存储库）</strong>：存放项目文件的中央位置，存储文件的当前版本及其历史版本。</li>
<li><strong>Working Copy（工作副本）</strong>：用户从存储库拉取的本地副本，用户可以在本地对其进行修改。</li>
<li><strong>Revision（修订版）</strong>：每一次对存储库的修改都会生成一个新的修订版本，修订版用递增的数字标识。</li>
<li><strong>Trunk（主干）</strong>：项目的主要开发线，通常用于存放稳定或开发中的代码。</li>
<li><strong>Branch（分支）</strong>：从主干或其他分支创建的独立开发线，常用于实现新的功能或修复 bug。</li>
<li><strong>Tag（标签）</strong>：用于标记某个特殊的修订版本，通常用于发布版本。</li>
<li><strong>Merge（合并）</strong>：将不同分支的修改合并到一起，通常在多条开发线并行工作时使用。</li>
</ul>
<h3 id="4-SVN-的主要功能"><a href="#4-SVN-的主要功能" class="headerlink" title="4. SVN 的主要功能"></a>4. SVN 的主要功能</h3><h4 id="4-1-版本控制"><a href="#4-1-版本控制" class="headerlink" title="4.1 版本控制"></a>4.1 版本控制</h4><ul>
<li>SVN 可以记录每个文件的修改历史，允许用户查看每次更改的内容以及是谁进行的修改。</li>
<li>可以通过版本号恢复到以前的版本，回滚文件状态。</li>
</ul>
<h4 id="4-2-并行开发"><a href="#4-2-并行开发" class="headerlink" title="4.2 并行开发"></a>4.2 并行开发</h4><ul>
<li><strong>分支和合并</strong>：通过创建分支，团队可以并行开发多个功能，避免冲突。开发完成后可以合并到主干。</li>
<li><strong>冲突检测和解决</strong>：SVN 能检测出多个开发者修改同一文件的不同部分，并提供冲突解决工具。</li>
</ul>
<h4 id="4-3-锁定机制"><a href="#4-3-锁定机制" class="headerlink" title="4.3 锁定机制"></a>4.3 锁定机制</h4><ul>
<li>为避免多用户同时编辑同一文件导致冲突，SVN 提供<strong>文件锁定机制</strong>，允许用户锁定文件，使得其他用户暂时无法编辑该文件，适用于无法自动合并的文件，如二进制文件。</li>
</ul>
<h4 id="4-4-访问控制和安全"><a href="#4-4-访问控制和安全" class="headerlink" title="4.4 访问控制和安全"></a>4.4 访问控制和安全</h4><ul>
<li>SVN 服务器允许管理员为不同用户设置不同的访问权限，可以控制某些用户只读或读写某些分支或文件。</li>
<li>支持 HTTP(S) 等加密协议，确保数据传输的安全性。</li>
</ul>
<h3 id="5-SVN-的优势与局限"><a href="#5-SVN-的优势与局限" class="headerlink" title="5. SVN 的优势与局限"></a>5. SVN 的优势与局限</h3><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><ul>
<li><strong>简单易用</strong>：SVN 的命令和概念相对简单，适合小到中型团队使用。</li>
<li><strong>集中式管理</strong>：由于所有代码和历史都集中存储，便于备份、管理和访问控制。</li>
<li><strong>完善的分支管理</strong>：支持创建分支和标签，便于并行开发和版本发布管理。</li>
<li><strong>适用多种文件类型</strong>：不仅适用于代码，还可以管理文档、图片等文件。</li>
</ul>
<h4 id="局限："><a href="#局限：" class="headerlink" title="局限："></a>局限：</h4><ul>
<li><strong>集中式存储模型的瓶颈</strong>：所有开发人员都需要访问中央服务器，容易产生网络延迟问题，尤其是团队分布全球时。</li>
<li><strong>不适合离线工作</strong>：与 Git 等分布式版本控制系统相比，SVN 在离线情况下的操作较为不便，用户必须连接到服务器才能提交更改。</li>
<li><strong>性能问题</strong>：在处理大量文件或复杂项目时，SVN 的性能可能不如分布式版本控制系统。</li>
</ul>
<h3 id="6-SVN-和-Git-的对比"><a href="#6-SVN-和-Git-的对比" class="headerlink" title="6. SVN 和 Git 的对比"></a>6. SVN 和 Git 的对比</h3><ul>
<li><strong>集中式 vs 分布式</strong>：SVN 是集中式版本控制系统，而 Git 是分布式版本控制系统。在 Git 中，每个开发者都有完整的项目历史记录，SVN 则将所有历史保存在中央服务器。</li>
<li><strong>分支管理</strong>：SVN 的分支管理较为笨重，创建和切换分支可能涉及较多步骤，而 Git 由于其轻量级分支机制，使得分支操作非常快速。</li>
<li><strong>提交机制</strong>：SVN 的提交必须连接到中央服务器，而 Git 支持本地提交，允许开发者离线工作，并在连接服务器后再推送更改。</li>
</ul>
<h3 id="7-典型使用场景"><a href="#7-典型使用场景" class="headerlink" title="7. 典型使用场景"></a>7. 典型使用场景</h3><ul>
<li><strong>传统企业</strong>：SVN 仍然在一些企业软件项目中使用，特别是在需要严格控制权限和管理较大代码库时。</li>
<li><strong>文档和文件管理</strong>：因为 SVN 处理二进制文件相对较好，且支持锁定文件，它常用于需要管理大量文档和文件的项目。</li>
</ul>
<h3 id="8-常用命令"><a href="#8-常用命令" class="headerlink" title="8. 常用命令"></a>8. 常用命令</h3><ul>
<li><code>svn checkout URL</code>：从存储库下载项目到本地工作副本。</li>
<li><code>svn update</code>：更新工作副本中的文件，获取最新的更改。</li>
<li><code>svn commit -m &quot;message&quot;</code>：提交本地更改到存储库。</li>
<li><code>svn add FILE</code>：将新文件或目录添加到版本控制中。</li>
<li><code>svn delete FILE</code>：从版本控制中删除文件。</li>
<li><code>svn status</code>：查看当前工作副本的修改状态。</li>
<li><code>svn log</code>：查看存储库的提交历史。</li>
<li><code>svn merge BRANCH_URL</code>：将某个分支的更改合并到当前分支。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SVN 是一个强大且稳定的版本控制系统，适合需要集中管理、精确控制和清晰历史记录的项目。尽管如今 Git 更受欢迎，SVN 在某些特定领域和企业环境中仍然广泛使用。如果你的团队已经习惯了集中式版本控制系统的工作流程，SVN 依然是一个可靠的选择。</p>
<h2 id="svn-基本项目管理流程"><a href="#svn-基本项目管理流程" class="headerlink" title="svn 基本项目管理流程"></a>svn 基本项目管理流程</h2><p>SVN（Subversion）是一种版本控制系统，用于管理项目中的代码和文件的版本变化。在使用SVN进行项目管理时，通常有一套基本的流程，可以帮助团队更高效地协作和管理代码。以下是一个常见的 SVN 项目管理流程：</p>
<h3 id="1-创建项目版本库"><a href="#1-创建项目版本库" class="headerlink" title="1. 创建项目版本库"></a>1. <strong>创建项目版本库</strong></h3><ul>
<li>在服务器上初始化一个 SVN 仓库，用于存储项目的所有版本历史记录。</li>
<li>创建基础目录结构，一般包括：<ul>
<li><strong>trunk</strong>：主开发线，放置稳定的代码。</li>
<li><strong>branches</strong>：分支，用于开发新功能或修复 Bug 的不同版本。</li>
<li><strong>tags</strong>：标签，标记重要的发布版本，如 <code>v1.0</code>、<code>v2.0</code>。</li>
</ul>
</li>
</ul>
<h3 id="2-工作副本-Checkout"><a href="#2-工作副本-Checkout" class="headerlink" title="2. 工作副本 Checkout"></a>2. <strong>工作副本 Checkout</strong></h3><ul>
<li>开发者将项目从 SVN 仓库中检出（checkout）到本地机器。检出操作会复制项目的所有文件和目录到本地。</li>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn checkout https://svn.example.com/repo/project/trunk</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-日常开发流程"><a href="#3-日常开发流程" class="headerlink" title="3. 日常开发流程"></a>3. <strong>日常开发流程</strong></h3><ol>
<li><p><strong>更新 (Update)</strong></p>
<ul>
<li>在开始修改代码前，开发者应通过 <code>svn update</code> 命令同步最新版本的代码，以确保本地工作副本是最新的。</li>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn update</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>修改 (Modify)</strong></p>
<ul>
<li>在本地修改代码或其他文件。SVN 会跟踪这些修改，但这些更改只保存在开发者的本地副本中，直到提交（commit）到仓库。</li>
</ul>
</li>
<li><p><strong>检查状态 (Status)</strong></p>
<ul>
<li>使用 <code>svn status</code> 查看哪些文件被修改、删除或新增。</li>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn status</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>添加&#x2F;删除文件 (Add&#x2F;Delete Files)</strong></p>
<ul>
<li>如果有新的文件需要加入版本控制，使用 <code>svn add</code> 命令。</li>
<li>如果需要删除文件，使用 <code>svn delete</code> 命令。</li>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn add newfile.txt</span><br><span class="line">svn delete oldfile.txt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>解决冲突 (Conflict Resolution)</strong></p>
<ul>
<li>如果在更新代码时发生冲突，SVN 会提示冲突文件，开发者需要手动解决冲突，然后标记为已解决：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn resolved conflictedfile.txt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="4-提交更改-Commit"><a href="#4-提交更改-Commit" class="headerlink" title="4. 提交更改 (Commit)"></a>4. <strong>提交更改 (Commit)</strong></h3><ul>
<li>完成本地修改后，开发者需要将修改提交到 SVN 仓库，确保其他团队成员可以看到并使用最新版本的代码。</li>
<li>提交时需要编写清晰的提交说明，描述更改内容。</li>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn commit -m <span class="string">&quot;Fix bug in login module&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-分支管理-Branch-Management"><a href="#5-分支管理-Branch-Management" class="headerlink" title="5. 分支管理 (Branch Management)"></a>5. <strong>分支管理 (Branch Management)</strong></h3><ul>
<li><strong>创建分支</strong>：为了开发新功能或修复特定问题，可以从主干（trunk）创建一个新的分支。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn copy https://svn.example.com/repo/project/trunk https://svn.example.com/repo/project/branches/feature-branch -m <span class="string">&quot;Creating a new feature branch&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>合并分支</strong>：在分支上的开发完成后，可以将分支的修改合并回主干。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn merge https://svn.example.com/repo/project/branches/feature-branch</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-打标签-Tagging"><a href="#6-打标签-Tagging" class="headerlink" title="6. 打标签 (Tagging)"></a>6. <strong>打标签 (Tagging)</strong></h3><ul>
<li>在项目达到某个稳定点时，可以创建一个标签，方便将来的回滚或参考。标签一般是不可修改的。</li>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn copy https://svn.example.com/repo/project/trunk https://svn.example.com/repo/project/tags/release-1.0 -m <span class="string">&quot;Tagging version 1.0&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-查看历史记录-Log"><a href="#7-查看历史记录-Log" class="headerlink" title="7. 查看历史记录 (Log)"></a>7. <strong>查看历史记录 (Log)</strong></h3><ul>
<li>使用 <code>svn log</code> 查看项目的提交历史，了解之前的更改和版本信息。</li>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-回滚版本-Revert"><a href="#8-回滚版本-Revert" class="headerlink" title="8. 回滚版本 (Revert)"></a>8. <strong>回滚版本 (Revert)</strong></h3><ul>
<li>如果发现某个版本存在问题，可以回滚到之前的某个版本。</li>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn revert somefile.txt</span><br><span class="line">svn merge -r HEAD:1234 https://svn.example.com/repo/project/trunk</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>SVN 的基本流程包括从版本库检出项目、更新本地副本、修改文件、解决冲突、提交修改、分支管理、打标签以及查看历史记录。这一流程有助于确保团队协作开发时代码的版本控制，避免冲突并方便回滚和历史查看。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/09/05/notebook/Books/2024-09-05-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E6%A0%87%E5%87%86%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/05/notebook/Books/2024-09-05-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%E6%A0%87%E5%87%86%E5%BA%93/" class="post-title-link" itemprop="url">C++程序设计语言 第四部分 标准库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-09-05 09:00:00" itemprop="dateCreated datePublished" datetime="2024-09-05T09:00:00+08:00">2024-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++程序设计语言 第四部分 标准库相关笔记</li>
</ul>
<h2 id="第三十章-标准库概览"><a href="#第三十章-标准库概览" class="headerlink" title="第三十章 标准库概览"></a>第三十章 标准库概览</h2><h3 id="30-1-引言"><a href="#30-1-引言" class="headerlink" title="30.1 引言"></a>30.1 引言</h3><ul>
<li>标准库是一个组件集合，在ISO C++标准中定义，在所有实现中都以一致的形式(和性能)提供。出于可移植性和长期维护的考虑，强烈推荐在合适的地方尽量使用表混库。一般而言，不要尝试重新发明轮子。</li>
</ul>
<h4 id="30-1-1-标准库设施"><a href="#30-1-1-标准库设施" class="headerlink" title="30.1.1 标准库设施"></a>30.1.1 标准库设施</h4><ul>
<li><p>标准库是所有C++实现都必须提供的，以便每个程序员都能依靠它来编写程序。C++标准库提供</p>
<ul>
<li>语言特性的支持，例如内存管理，范围for语句和运行时类型信息</li>
<li>具体C++实现所定义的一些语言相关的信息，如最大float值</li>
<li>单纯用语言难以高效实现的基本操作，例如 is_polymorphic, is_scalar 和 is_nothrow_constructible</li>
<li>底层(无锁)并发编程设施</li>
<li>基于线程的并发编程的支持</li>
<li>基于任务的并发的基本支持，例如future和async()</li>
<li>大多数程序员难以实现最优且可移植版本的函数，例如 uninitialized_fill()和memmove()</li>
<li>无用内存回收(垃圾收集)的基本支持，例如declare_reachable()</li>
<li>程序员编写可移植代码所需的复杂基础组件，例如list,map,sort和IO流</li>
<li>用于标准库自身扩展的框架，例如允许用户为自定义类型提供与内置类型相似的I&#x2F;O操作的规范和基础组件以及标准模板库STL</li>
</ul>
</li>
<li><p>标准库的设计目标之一是成为其他库的公共基础。特别是，组合使用标准库特性可以起到三方面的支撑作用</p>
<ul>
<li>可移植性的基础</li>
<li>一组紧凑且高效的组件，可以作为构造性能敏感的库和应用的基础</li>
<li>一组实现库内交互的组件。</li>
</ul>
</li>
</ul>
<h3 id="30-2-头文件"><a href="#30-2-头文件" class="headerlink" title="30.2 头文件"></a>30.2 头文件</h3><ul>
<li><p>标准库组件都定义在命名空间std中，以一组头文件的形式提供。头文件构成了标准库最主要的部分，因此，列出头文件可以给出标准库的一个概貌。</p>
</li>
<li><p>以字母c开头的标准库头文件对应C标准库中的头文件。每个C标准库头文件&lt;x.h&gt;都定义了一些同时位于全局命名空间和命名空间std中的内容，且有一个定义相同内容的对应头文件<cx>。理想情况下，头文件<cX>中的名字不会污染全局命名空间，但不幸的是(归咎于管理多语言，多操作系统环境的复杂性)大多数实际情况下会发生污染。</p>
</li>
<li><p>容器</p>
<ul>
<li><vector> 可变大小一维数组</li>
<li><deque> 双端队列</li>
<li><forward_list> 单向链表</li>
<li><list> 双向链表</li>
<li><map> 关联数组</li>
<li><set> 集合</li>
<li><unordered_map> 哈希关联数组</li>
<li><unordered_set> 哈希集合</li>
<li><queue> 队列</li>
<li><stack> 栈</li>
<li><array> 固定大小一维数组</li>
<li><bitset> bool数组</li>
</ul>
</li>
<li><p>关联容器multimap和multiset分别声明在<map>和<set>中，priority_queue声明在<queue>中</p>
</li>
<li><p>通用工具</p>
<ul>
<li><utility> 运算符和值对</li>
<li><tuple> 元组</li>
<li><type_traits> 类型萃取</li>
<li><typeindex> 将type_info用作一个关键字或哈希码</li>
<li><function> 函数对象</li>
<li><memory> 资源管理指针</li>
<li><scoped_allocator> 限定作用域的分配器</li>
<li><ratio> 编译时有理数算术运算</li>
<li><chrono> 时间工具</li>
<li><ctime> C风格日期和时间工具</li>
<li><iterator> 迭代器及其支持</li>
</ul>
</li>
<li><p>迭代器机制令标准库算法具有通用性</p>
</li>
<li><p>算法</p>
<ul>
<li><algorithm> 泛型算法</li>
<li><cstdlib> bseach(), qsort()</li>
</ul>
</li>
<li><p>一个典型的泛型算法能应用于任何类型的元素构成的序列。C标准库函数bsearch()和qsort()只能用于内置数组，且元素类型不能有用户自定义的拷贝构造函数和析构函数</p>
</li>
<li><p>诊断</p>
<ul>
<li><exception> 异常类</li>
<li><stdexcept> 标准异常</li>
<li><cassert> 断言宏</li>
<li><cerrno> C风格错误才处理</li>
<li><system_error> 系统错误支持</li>
</ul>
</li>
<li><p>字符串和字符</p>
<ul>
<li><string> T的字符串</li>
<li><cctype> 字符分类</li>
<li><cwctype> 宽字符分类</li>
<li><cstring> C风格字符串函数</li>
<li><cwchar> C风格宽字符字符串函数</li>
<li><cstdlib> C风格分配函数</li>
<li><cuchar> C风格多字节字符串</li>
<li><regex> 正则表达式匹配</li>
</ul>
</li>
<li><p>头文件<cstring>声明了strlen(),strcpy()等一族函数。头文件<cstdlib>声明了atof()和atoi()，可将C风格字符串转换为数值。</p>
</li>
<li><p>输入&#x2F;输出</p>
<ul>
<li><iosfwd> I&#x2F;O组件的前置声明</li>
<li><iostream> 标准iostream对象和操作</li>
<li><ios> iostream基类</li>
<li><streambuf> 流缓冲</li>
<li><istream> 输入流模板</li>
<li><ostream> 输出流模板</li>
<li><iomanip> 操纵符</li>
<li><sstream> 字符串流</li>
<li><cctype> 字符分类函数</li>
<li><fstream> 文件流</li>
<li><cstdio> printf() I&#x2F;O函数族</li>
<li><cwchar> 宽字符printf()风格I&#x2F;O函数</li>
</ul>
</li>
<li><p>操纵符是操作流状态的对象</p>
</li>
<li><p>本地化</p>
<ul>
<li><locale> 表示文化差异</li>
<li><clocale> 文化差异C风格表示</li>
<li><codecvt> 代码转换</li>
</ul>
</li>
<li><p>locale对日期输出格式，货币表示符号和字符串校勘等在不同语言和文化中有差异的内容进行本地化</p>
</li>
<li><p>语言支持</p>
<ul>
<li><limits> 数值限制</li>
<li><climits> 数值标量限制C风格宏</li>
<li><cfloat> 浮点数限制C风格宏</li>
<li><cstdint> 标准整数类型名</li>
<li><new> 动态内存管理</li>
<li><typeinfo> 运行时类型识别支持</li>
<li><exception> 异常处理支持</li>
<li><initializer_list> initializer_list</li>
<li><cstddef> C标准库语言支持</li>
<li><cstdarg> 可变长函数参数列表</li>
<li><csetjmp> C风格栈展开</li>
<li><cstdlib> 程序终止</li>
<li><ctime> 系统时钟</li>
<li><csignal> C风格信号处理</li>
</ul>
</li>
<li><p>头文件<cstddef>定义了sizeof()返回的类型size_t，指针减法和数组下标返回的类型ptrdiff_t以及声名狼藉的NULL宏</p>
</li>
<li><p>C风格栈展开(使用&lt;csetjmp中的setjmp和longjmp&gt;)与析构函数和异常处理不兼容，因此最好避免使用。</p>
</li>
<li><p>数值</p>
<ul>
<li><complex> 复数及其运算</li>
<li><valarray> 数值向量及其运算</li>
<li><numeric> 推广的数值运算</li>
<li><cmath> 标准数学函数</li>
<li><cstdlib> C风格随机数</li>
<li><random> 随机数发生器</li>
</ul>
</li>
<li><p>由于历史原因，abs()和div()不像其他数学函数那样在<cmath>中，而是在<cstdlib>中</p>
</li>
<li><p>并发</p>
<ul>
<li><atomic> 原子类型及其操作</li>
<li><condition_variable> 等待动作</li>
<li><future> 异步任务</li>
<li><mutex> 互斥类</li>
<li><thread> 线程</li>
</ul>
</li>
<li><p>C标准库的一些组件与C++程序员有着不同程度的关联，C++标准库提供了对这些组件的访问机制。</p>
</li>
<li><p>C兼容性</p>
<ul>
<li><cinttypes> 公共整数类型的别名</li>
<li><cstdbool> C的bool类型</li>
<li><ccomplex> <complex></li>
<li><cfenv> 浮点数环境</li>
<li><cstdalign> C的对齐机制</li>
<li><ctgmath> C的泛型数学函数： <complex> 和 <cmath></li>
</ul>
</li>
</ul>
<h3 id="30-3-语言支持"><a href="#30-3-语言支持" class="headerlink" title="30.3 语言支持"></a>30.3 语言支持</h3><ul>
<li><p>语言支持是标准库中很小但至关重要的部分，是程序正常运行所必需的，因为语言特性依赖于这些组件。</p>
</li>
<li><p>标准库支持的语言特性</p>
<ul>
<li><new> new和delete</li>
<li><typeinfo> typeid()和type_info</li>
<li><iterator> 范围for</li>
<li><initializer_list> initializer_list</li>
</ul>
</li>
</ul>
<h3 id="30-3-1-initializer-list-支持"><a href="#30-3-1-initializer-list-支持" class="headerlink" title="30.3.1 initializer_list 支持"></a>30.3.1 initializer_list 支持</h3><ul>
<li><p>一个 {} 列表会依据规则转换为一个 std::initializer_list<X> 类型的对象。</p>
</li>
<li><p>不幸的是, initializer_list并未提供下标运算符。如果你希望用 [] 而不是 *，可对指针使用下标</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(initializer_list&lt;<span class="type">int</span>&gt; lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* p = lst.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lst.<span class="built_in">size</span>(); i++&gt;)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cerr &lt;&lt; p[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>initializer_list自然也可用于范围for语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(initializer_list&lt;<span class="type">int</span>&gt; lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : lst)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cerr &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="30-3-2-范围for支持"><a href="#30-3-2-范围for支持" class="headerlink" title="30.3.2 范围for支持"></a>30.3.2 范围for支持</h3><ul>
<li>一条范围for语句会借助迭代器映射为一条for语句。</li>
<li>在<iterator>中，标准库提供了std::begin()和std::end()两个函数，可用于内置数组及任何提供了begin()和end()成员的类型。</li>
<li>所有标准库容器和字符串都支持使用范围for的迭代；容器适配器(例如stack和priority_queue)则不支持。容器的头文件(例如<vector>)会包含<initializer_list>，因此用户很少需要自己直接包含它。</li>
</ul>
<h3 id="30-4-错误处理"><a href="#30-4-错误处理" class="headerlink" title="30.4 错误处理"></a>30.4 错误处理</h3><ul>
<li><p>标准库包含的组件已有将近40年的开发历程。因此，它们处理错误的风格和方法并不统一</p>
<ul>
<li>C风格库函数大多数通过设置errno来指示发生了错误</li>
<li>很多对元素序列进行操作的算法返回一个尾后迭代器来指示 未找到 或 失败</li>
<li>I&#x2F;O流库要依赖于每个流中的一个状态来反映错误，并可能(根据用户需要)通过抛出异常来指示错误。</li>
<li>一些标准库组件，例如vector,string和bitset通过抛出异常来指示错误。</li>
</ul>
</li>
<li><p>标准库的设计目标之一是所有组件都遵守基本保证：即，即使抛出了异常，也不会有资源(例如内存)泄露，且不会有标准库类的不变式被破坏的情况出现。</p>
</li>
</ul>
<h3 id="30-4-1-异常"><a href="#30-4-1-异常" class="headerlink" title="30.4.1 异常"></a>30.4.1 异常</h3><ul>
<li>一些标准库组件通过抛出异常来报告错误</li>
<li>标准库异常<ul>
<li>bitset: 抛出invalid_argument, out_of_range,overflow_error</li>
<li>iostream: 如果允许异常的话，抛出ios_base::failure</li>
<li>regex: 抛出regex_error</li>
<li>string: 抛出length_error,out_of_range</li>
<li>vector: 抛出out_of_range</li>
<li>new T: 如果不能为一个T分配内存，抛出bad_alloc</li>
<li>dynamic_cast<T>(r): 如果不能将引用r转换为一个T，抛出bad_cast</li>
<li>typeid(): 如果不能获得一个type_info,抛出bad_typeid</li>
<li>thread: 抛出system_error</li>
<li>call_once(): 抛出system_error</li>
<li>mutex: 抛出system_error</li>
<li>condition_variable: 抛出system_error</li>
<li>async(): 抛出system_error</li>
<li>packaged_task: 抛出system_error</li>
<li>future和promise: 抛出system_error</li>
</ul>
</li>
<li>任何直接或间接使用这些组件的代码都可能遇到这些异常。</li>
<li>除非你确认使用组件的方式不会令它们抛出异常，否则坚持在某处(例如main())捕获标准库异常类层次的某个根类(例如exception)和任何异常(…)是一个很好的编程习惯。</li>
</ul>
<h4 id="30-4-1-1-标准库exception类层次"><a href="#30-4-1-1-标准库exception类层次" class="headerlink" title="30.4.1.1 标准库exception类层次"></a>30.4.1.1 标准库exception类层次</h4><ul>
<li>不要抛出int，C风格字符串等内置类型，而应该抛出专门表示异常的类型的对象。</li>
</ul>
<h4 id="30-4-1-2-异常传播"><a href="#30-4-1-2-异常传播" class="headerlink" title="30.4.1.2 异常传播"></a>30.4.1.2 异常传播</h4><ul>
<li><exception>中提供了一些组件，令异常传播对程序员可见</li>
<li>异常传播<ul>
<li>exception_ptr: 非特定的异常指针类型</li>
<li>ep &#x3D; current_exception() ep是一个exception_ptr,指向当前异常，若当前无活动异常则不指向任何异常；不抛出异常</li>
<li>rethrow_exception(ep): 重新抛出ep指向的异常；ep包含的不能是空指针nullptr；无返回值</li>
<li>ep &#x3D; make_exception_ptr(e): ep是指向exception e的exception_ptr；不抛出异常。</li>
</ul>
</li>
<li>一个exception_ptr可以指向任何异常，不局限于exception类层次中的异常。可将exception_ptr看作一种智能指针(类似shared_ptr)–只要一个exception_ptr还指向其异常，那么这个异常就会保持活跃。这样，我们就可以通过exception_ptr将一个异常从捕获它的函数中传递出来，并在其他地方重新抛出。即，exception_ptr可用来实现在捕获线程之外的其他线程中重抛出异常，这是promise和future所需要的。对一个exception_ptr使用rethrow_exception(在不同线程中)不会引起数据竞争。</li>
<li><strong>异常不能从noexcept函数中传播出去</strong>.</li>
</ul>
<h4 id="30-4-1-3-terminate"><a href="#30-4-1-3-terminate" class="headerlink" title="30.4.1.3 terminate()"></a>30.4.1.3 terminate()</h4><ul>
<li>在<exception>中，标准库提供了处理意外异常的组件</li>
<li>terminate<ul>
<li>h &#x3D; get_terminate(): h为当前终止处理程序；不抛出异常</li>
<li>h2 &#x3D; set_terminate(): 当前终止处理程序被设定为h；h2为旧终止处理程序；不抛出异常</li>
<li>terminate(): 终止程序；无返回值；不抛出异常。</li>
</ul>
</li>
<li>除了极特殊的情况下使用set_terminate()和terminate()之外，其他情况应避免使用这些函数</li>
</ul>
<h3 id="30-4-2-断言"><a href="#30-4-2-断言" class="headerlink" title="30.4.2 断言"></a>30.4.2 断言</h3><ul>
<li>标准库提供了断言机制</li>
<li>断言<ul>
<li>static_assert(e, s) 在编译时对e求职；若!e为假则将s作为编译器错误信息输出</li>
<li>assert(e): 若宏NOBUG未定义，则在运行时对e进行求职，若!e为假，向cerr输出一个消息并调用abort();若定义了NOBUG，则什么也不做。</li>
<li>assert()是一个宏，定义在<cassert>中，assert()生成什么错误信息由C++具体实现自己决定，但应该包含源文件名(<strong>FILE</strong>)和assert()所在的源码行号(<strong>LINE</strong>)</li>
<li>断言常常用于产品级代码而非教材的小例子中(它也本应如此)</li>
<li>函数名(<strong>func</strong>)也可能包含在消息中。</li>
</ul>
</li>
</ul>
<h3 id="30-4-3-system-error"><a href="#30-4-3-system-error" class="headerlink" title="30.4.3 system_error"></a>30.4.3 system_error</h3><ul>
<li>在<system_error>中，标准库提供了一个能从操作系统和底层系统组件报告错误的框架。</li>
</ul>
<h4 id="30-4-3-1-错误码"><a href="#30-4-3-1-错误码" class="headerlink" title="30.4.3.1 错误码"></a>30.4.3.1 错误码</h4><ul>
<li>当一个错误以错误码的形式从程序底层浮上来时，我们必须处理这个错误或将错误码转换为一个异常。</li>
</ul>
<h4 id="30-4-3-2-错误类别"><a href="#30-4-3-2-错误类别" class="headerlink" title="30.4.3.2 错误类别"></a>30.4.3.2 错误类别</h4><h4 id="30-4-3-3-system-error异常"><a href="#30-4-3-3-system-error异常" class="headerlink" title="30.4.3.3 system_error异常"></a>30.4.3.3 system_error异常</h4><ul>
<li>system_error报告的错误都源自标准库中处理操作系统的部分。它传递一个error_code，并可传递一个错误消息字符串。</li>
<li>自然的，system_error可用于标准库之外的程序。它传递一个系统相关的error_code，而不是一个可移植的error_condition</li>
</ul>
<h4 id="30-4-3-4-可移植的错误状态"><a href="#30-4-3-4-可移植的错误状态" class="headerlink" title="30.4.3.4 可移植的错误状态"></a>30.4.3.4 可移植的错误状态</h4><ul>
<li>可移植错误码(error_condition)的表现形式与系统相关的error_code几乎相同。总体思路是每个系统有一组特有的(“原生的”)错误码，可映射到潜在可移植的错误码，这样对于需要跨平台编程的程序员(通常是编写库的程序员)来说会更加方便。</li>
</ul>
<h3 id="30-5-建议"><a href="#30-5-建议" class="headerlink" title="30.5 建议"></a>30.5 建议</h3><ul>
<li>使用标准库组件保持可移植性</li>
<li>使用标准库组件尽量减少维护成本</li>
<li>将标准库组件作为更广泛和更专门化的库的基础</li>
<li>使用标准库组件作为灵活，广泛使用的软件的模型</li>
<li>标准库组件定义在命名空间std中，都是在标准库头文件中定义的</li>
<li>每个C标准库头文件X.h都有其C++标准库对应的版本<cX></li>
<li>必须#include相应的头文件才能使用标准库组件</li>
<li>为了对内置数组使用范围for，需要 #include <iterator></li>
<li>优选基于异常的错误处理而非返回错误码方式的错误处理</li>
<li>始终要捕获 exception&amp;(对标准库和语言支持的异常)和…(对意料之外的异常)</li>
<li>标准库exception层次可以(但不是必须支持)用于用户自定义异常</li>
<li>如果发生严重错误，调用terminate()</li>
<li>大量使用static_assert()和assert()</li>
<li>不要假定assert()总是会被求值</li>
</ul>
<h2 id="第三十一章-STL容器"><a href="#第三十一章-STL容器" class="headerlink" title="第三十一章 STL容器"></a>第三十一章 STL容器</h2><h3 id="31-1-引言"><a href="#31-1-引言" class="headerlink" title="31.1 引言"></a>31.1 引言</h3><ul>
<li>STL包含标准库中的迭代器，容器，算法和函数对象几个部分。</li>
</ul>
<h3 id="31-2-容器概览"><a href="#31-2-容器概览" class="headerlink" title="31.2 容器概览"></a>31.2 容器概览</h3><ul>
<li><p>一个容器保存着一个对象序列。容器可分类为</p>
<ul>
<li>顺序容器提供对元素(半开)序列的访问</li>
<li>关联容器提供基于关键字的关联查询</li>
</ul>
</li>
<li><p>此外，标准库还提供了一些保存元素的对象类型，它们并未提供顺序容器或关联容器的全部功能</p>
<ul>
<li>容器适配器提供对底层容器的特殊访问</li>
<li>拟容器保存元素序列，提供容器的大部分但非全部功能</li>
</ul>
</li>
<li><p>STL容器都是资源句柄，都定了拷贝和移动操作。所有容器操作都提供了基本保证，确保与基于异常的错误处理机制能够正确协同工作。</p>
</li>
<li><p>顺序容器</p>
<ul>
<li>vector&lt;T, A&gt; 空间连续分配的T类型元素序列，默认选择容器</li>
<li>list&lt;T, A&gt; T类型元素双向链表，当需要插入&#x2F;删除元素但不移动已有元素时选择它</li>
<li>forward_list&lt;T, A&gt; T类型元素单向链表，很短的或空序列的理想选择</li>
<li>deque&lt;T, A&gt; T类型元素双端队列，向量和链表的混合，对大多数应用而言，都比向量和链表其中之一要慢。</li>
</ul>
</li>
<li><p>这些容器都定义在<vector>,<list>和<deque>中。顺序容器为元素连续分配内存(例如vector)或将元素组织为链表(例如forward_list)，元素的类型是容器的成员value_type(或者是上表中的T)。deque(发音为 deck)采用链表和连续存储的混合方式。</p>
</li>
<li><p>除非你有充足的理由，否则应该优选vector而不是其他顺序容器。注意，vector提供了添加，删除元素的操作，这些操作都允许vector按需增长或收缩。对于包含少量元素的序列而言，vector是一种完美的支持列表操作的数据结构。</p>
</li>
<li><p>当在一个vector中插入，删除元素时，其他元素可能会移动。与之相反，链表或关联容器中的元素则不会因为插入新元素或删除其他元素而移动。</p>
</li>
<li><p>forward_list(单向链表)是一种专为空链表和极短链表优化过的数据结构。一个空forward_list只占用一个内存字。在实际应用中，有相当多的情况链表是空的(还有很多情况链表是非常短)</p>
</li>
<li><p>有序关联容器</p>
<ul>
<li>map&lt;K,V,C,A&gt; 从K到V的有序映射，一个(K,V)对序列</li>
<li>multimap&lt;K,V,C,A&gt; 从K到V的有序映射，允许重复关键字</li>
<li>set&lt;K,C,A&gt; K的有序集合</li>
<li>multiset&lt;K,C,A&gt; K的有序集合，允许重复关键字</li>
</ul>
</li>
<li><p>这些容器通常用平衡二叉树(通常是红黑树)实现</p>
</li>
<li><p>关键字(K)的默认序标准是 std::less<K></p>
</li>
<li><p>类似顺序容器，模板参数A是分配器，容器用它来分配和释放内存。对映射，A的默认值是 std::allocator&lt;std::pair&lt;const K,T&gt;&gt;，对集合，A的默认值是std::allocator<K></p>
</li>
<li><p>无序关联容器</p>
<ul>
<li>unordered_map&lt;K,V,H,E,A&gt; 从K到V 的无序映射</li>
<li>unordered_multimap&lt;K,V,H,E,A&gt; 从K到V 的无序映射，允许关键字重复</li>
<li>unordered_set&lt;K,H,E,A&gt; K的无序集合</li>
<li>unordered_multiset&lt;K,H,E,A&gt; 从K的无序集合，允许关键字重复</li>
</ul>
</li>
<li><p>这些容器都是采用溢出链表法的哈希表实现。关键字类型K的默认哈希函数类型H为 std::hash<K>。关键字类型K的默认相等判断函数类型E为 std::equal_to<K>；相等性判定函数用来判断哈希值相同的两个对象是否相等</p>
</li>
<li><p>容器适配器是一类特殊容器，它们为其他容器提供了特殊的接口</p>
<ul>
<li>priority_queue&lt;T,C,Cmp&gt; T的优先队列，Cmp是优先级函数类型</li>
<li>queue&lt;T,C&gt; T的队列，支持push()和pop()操作</li>
<li>stack&lt;T,C&gt; T的栈，支持push()和pop()操作</li>
</ul>
</li>
<li><p>一个priority_queue的默认优先级函数Cmp为std::less<T>.queue的默认容器类型C为 std::deque<T>,stack和priority_queue的默认容器类型C为std::vector<T></p>
</li>
<li><p>某些数据类型具有标准容器所应有的大部分特性，但又非全部。我们有时称这些数据类型为 拟容器。</p>
<ul>
<li>T[N] 固定大小的内置数组；N个连续存储的类型为T的元素；没有size()或其他成员函数</li>
<li>array&lt;T, N&gt; 固定大小的数组，N个连续存储的类型为T的元素，类似内置数组，但解决了大部分问题。</li>
<li>basic_string&lt;C, Tr, A&gt; 一个连续分配空间的类型为C的字符序列，支持文本处理操作，例如连接(+, +&#x3D;)；basic_string通常都经过了优化，短字符串无须使用自由存储空间。</li>
<li>string basic_string<char></li>
<li>u16string basic_string<char16_t></li>
<li>u32string basic_string<char32_t></li>
<li>wstring basic_string<wchar_t></li>
<li>valarray<T> 数值向量，支持向量运算，但有一些限制，这些限制是为了鼓励高性能实现；只在做大量向量运算时使用</li>
<li>bitset<N> N个二进制位的集合，支持集合操作，例如&amp;和|</li>
<li>vector<bool> vector<T>的特例化版本，紧凑保存二进制位</li>
</ul>
</li>
<li><p>对basic_string，A是其分配器，Tr是字符萃取</p>
</li>
<li><p>如果可以选择的话，应该有限选择vector,string或array这样的容器，而不是内置数组。内置数组有两个问题–<strong>数组到指针的隐式类型转换和必须要记住大小</strong>，它们都是错误的主要来源。</p>
</li>
<li><p>还应该优先选择标准字符串，而不是其他字符串或C风格字符串。C风格字符串的指针语义意味着笨拙的符号表示和程序员的额外工作，它也是主要错误来源之一(例如内存泄漏)</p>
</li>
</ul>
<h4 id="31-2-1"><a href="#31-2-1" class="headerlink" title="31.2.1"></a>31.2.1</h4><ul>
<li><p>C++标准并未给标准容器规定特定的表示形式，而是指明了容器接口和一些复杂性要求。实现者会选择适当的(通常也是巧妙优化过的)实现方法来满足一般要求和常见用途。除了处理元素所需的一些内容之外，这类句柄还持有一个分配器。</p>
</li>
<li><p>对于一个vector，其元素的数据结构很可能是一个数组。vector会保存指向一个元素组的指针，还会保存元素数目和向量容量(已分配的和尚未使用的位置数)或等价的一些信息</p>
</li>
<li><p>list很可能表示为一个指向元素的链接序列以及元素数目</p>
</li>
<li><p>forward_list很可能表示为一个指向元素的链接序列</p>
</li>
<li><p>map很可能实现为一颗平衡树，树节点指向(键，值)对</p>
</li>
<li><p>unorder_map很可能实现为一个哈希表</p>
</li>
<li><p>string的实现可能为：短string的字符保存在string句柄内，而长string的元素则保存在自由存储空间中的连续区域(类似vector的元素)。类似vector，一个string也会预留空闲空间，以便扩张时不必频繁的重新分配空间</p>
</li>
<li><p>类似内置数组，array就是一个简单的元素序列，无句柄。这意味着一个局部array不会使用任何自由存储空间(除非它本身实在自由存储空间中分配的)，而且一个类的array成员也不会悄悄带来任何自由存储空间操作。</p>
</li>
</ul>
<h4 id="31-2-2-对元素的要求"><a href="#31-2-2-对元素的要求" class="headerlink" title="31.2.2 对元素的要求"></a>31.2.2 对元素的要求</h4><ul>
<li><p>若想作为一个容器的元素，对象类型必须允许容器拷贝，移动以及交换元素。如果容器使用拷贝构造函数或拷贝赋值操作拷贝一个元素，拷贝的结果必须是一个等价的对象。这大致意味着任何对象值相等性检测都必须得到副本和原值相等的结论。换句话说，元素拷贝必须能像int的普通拷贝一样正常工作。</p>
</li>
<li><p>类似的，移动构造函数和移动赋值操作也必须具有常规定义和常规移动语义。此外，元素类型还必须允许按常规语义交换元素。如果一个类型定义了拷贝或移动操作，则标准库swap()就能正常工作。</p>
</li>
<li><p>对元素类型的要求和细节散布在C++标准中，很难阅读，但基本上，如果一个类型具有常规的拷贝或移动操作，容器就能保存该类型元素。只要满足容器元素的基本要求和算法的特定要求(例如元素有序)，很多基本算法，例如copy(),find()和sort()都能正常运行。</p>
</li>
<li><p>当无法拷贝对象时，一个替换方案是将对象指针而不是对象本身保存在容器中。最典型的例子就是多态类型。例如，<strong>我们使用vector&lt;unique_prt<Shape>&gt;或vector&lt;Shape*&gt;，而不是vector<Shape>来保证多态性行为</strong>。</p>
</li>
</ul>
<h5 id="31-2-2-1-比较操作"><a href="#31-2-2-1-比较操作" class="headerlink" title="31.2.2.1 比较操作"></a>31.2.2.1 比较操作</h5><ul>
<li>关联容器要求其元素能够排序，很多可以应用于容器的操作也有此要求。默认情况下，&lt; 运算符被用来定义序。如果 &lt; 不合适，程序员必须提供一个替代操作。</li>
<li>排序标准必须定义一个严格弱序(strict weak ordering)。形式化地描述，即小于和相等关系(如果定义了的话)都必须是传递的。</li>
</ul>
<h3 id="31-3-操作概览"><a href="#31-3-操作概览" class="headerlink" title="31.3 操作概览"></a>31.3 操作概览</h3><ul>
<li>常量，表示操作花费的时间不依赖于容器中的元素数目；常量时间(constant time)的另一种常见表示方式是O(1)。O(n)表示操作花费的时间与元素数目成正比</li>
<li>所有容器的size()操作都是常量时间的。</li>
</ul>
<h4 id="31-3-1-成员类型"><a href="#31-3-1-成员类型" class="headerlink" title="31.3.1 成员类型"></a>31.3.1 成员类型</h4><ul>
<li>每个容器都定义了如下一组成员类型<ul>
<li>value_type 元素类型</li>
<li>allocator_type 内存管理类型</li>
<li>size_type 容器下标，元素数目等无符号类型</li>
<li>difference_type 迭代器差异的带符号类型</li>
<li>iterator 行为类似value_type*</li>
<li>const_iterator 行为类似 const_value_type*</li>
<li>reverse_iterator 行为类似 value_type*</li>
<li>const_reverse_iterator 行为类似 const_value_type*</li>
<li>reference const_value_type&amp;</li>
<li>const_reference 行为类似value_type*</li>
<li>pointer 行为类似 value_type*</li>
<li>const_pointer 行为类似 const_value_type*</li>
<li>kep_type 关键字类型；仅关联容器具有</li>
<li>mapped_type 映射值类型；仅关联容器具有</li>
<li>key_compare 比较标准类型；仅有序容器具有</li>
<li>hasher 哈希函数类型: 仅无序容器具有</li>
<li>key_euqal 等价性检验函数类型；仅无需容器具有</li>
<li>local_iterator 桶迭代器类型；仅无需容器具有</li>
<li>const_local_iterator 桶迭代器类型；仅无需容器具有</li>
</ul>
</li>
<li>每个容器和 拟容器 都提供了上表中大多数成员类型，但是不会提供无意义的类型</li>
</ul>
<h4 id="31-3-2-构造函数，析构函数和赋值操作"><a href="#31-3-2-构造函数，析构函数和赋值操作" class="headerlink" title="31.3.2 构造函数，析构函数和赋值操作"></a>31.3.2 构造函数，析构函数和赋值操作</h4><ul>
<li>赋值操作并不拷贝或移动分配器，目标容器获得了一组新的元素，但会保留其旧分配器，新元素(如果有的话)的空间也是用此分配器分配的。</li>
<li>谨记，一个构造函数或是一次元素拷贝可能会抛出异常，来指出它无法完成这个任务</li>
<li>紧急，<strong>对大小初始化器使用 (),而对其他所有初始化器都是用 {}</strong></li>
<li>容器通常都很大，因此我们几乎总是以引用方式传递容器实参。但是，由于容器是资源句柄，我们可以高效地以返回值的方式返回容器(隐含使用移动操作)。类似地，当我们不想用别名的时候，可以用移动方式传递容器实参。</li>
</ul>
<h4 id="31-3-3-大小和容量"><a href="#31-3-3-大小和容量" class="headerlink" title="31.3.3 大小和容量"></a>31.3.3 大小和容量</h4><ul>
<li>大小是指容器中的元素数目；容量是指在重新分配更多内存之前容器能够保存的元素数目。</li>
<li>在改变大小或容量时，元素可能会被移动到新的存储位置。这意味着指向元素的迭代器(以及指针和引用)可能会失效(即，指向旧元素的位置)</li>
<li>指向关联容器(例如map)元素的迭代器只有当所指元素从容器中删除(erase())时才会失效。与之相反，指向顺序容器(例如vector)元素的迭代器当元素重新分配空间(例如resize(), reverse()或push_back())或所指元素在容器中移动(例如在前一个位置进行erase()或insert())时也会失效。</li>
</ul>
<h4 id="31-3-4-迭代器"><a href="#31-3-4-迭代器" class="headerlink" title="31.3.4 迭代器"></a>31.3.4 迭代器</h4><ul>
<li>容器可以看作按容器迭代器定义的顺序或相反的顺序排列的元素序列。对一个关联容器，元素的序由容器比较标准(默认为 &lt; )决定</li>
<li>元素遍历的最常见形式是从头至尾遍历一个容器。最简单的遍历方法是使用范围for语句，它隐含的使用了begin()和end()</li>
<li>当我们需要了解一个元素在容器中的位置或需要同时引用多个元素时，就要直接使用迭代器。在这些情况下，auto很有用，它能帮助尽量简化代码并减少输入错误。</li>
</ul>
<h4 id="31-3-5-元素访问"><a href="#31-3-5-元素访问" class="headerlink" title="31.3.5 元素访问"></a>31.3.5 元素访问</h4><h4 id="31-3-6-栈操作"><a href="#31-3-6-栈操作" class="headerlink" title="31.3.6 栈操作"></a>31.3.6 栈操作</h4><ul>
<li><p>标准vector,deque和list(不包括forward_list和关联容器)提供了高效的元素序列尾部操作</p>
</li>
<li><p>栈操作</p>
<ul>
<li>c.push_back(x) 将x添加到c的尾元素之后(使用拷贝或移动)</li>
<li>c.pop_back() 删除c的尾元素</li>
<li>c.emplace_back(args) 用args构造一个对象，将它添加到c的尾元素之后</li>
</ul>
</li>
<li><p>c.push_back(x)将x移动或拷贝入x，这会将c的大小增加1。如果内存耗尽或x的拷贝构造函数抛出一个异常，c.push_back(x)会失败。push_back()失败不会对容器造成任何影响，因为标准库操作都提供了强保证。</p>
</li>
</ul>
<h4 id="31-3-7-列表操作"><a href="#31-3-7-列表操作" class="headerlink" title="31.3.7 列表操作"></a>31.3.7 列表操作</h4><h4 id="31-3-8-其他操作"><a href="#31-3-8-其他操作" class="headerlink" title="31.3.8 其他操作"></a>31.3.8 其他操作</h4><ul>
<li>容器可以比较和交换</li>
<li>swap()操作既交换元素也交换分配器</li>
</ul>
<h3 id="31-4-容器"><a href="#31-4-容器" class="headerlink" title="31.4 容器"></a>31.4 容器</h3><h4 id="31-4-1-vector"><a href="#31-4-1-vector" class="headerlink" title="31.4.1 vector"></a>31.4.1 vector</h4><ul>
<li>STL的vector是默认容器–除非你有充分理由，否则应该使用它。如果你希望使用链表或内置数组替代vector，应慎重考虑后再做决定。</li>
</ul>
<h5 id="31-4-1-1-vector和增长"><a href="#31-4-1-1-vector和增长" class="headerlink" title="31.4.1.1 vector和增长"></a>31.4.1.1 vector和增长</h5><ul>
<li>使用大小(元素数目)和容量(不重新分配空间的前提下可容纳的元素数目)零push_back()操作时的向量增长相当高效：不会在添加每个元素时都分配内存，而是在超出容量时才进行一次重新分配。C++标准并未指出超出容量时向量的增长幅度，但很多C++实现都是增加大小的一半。</li>
<li>容量的概念令指向vector元素的迭代器只有在真正发生重分配时才会失效。</li>
</ul>
<h4 id="31-3-1-2-vector和嵌套"><a href="#31-3-1-2-vector和嵌套" class="headerlink" title="31.3.1.2 vector和嵌套"></a>31.3.1.2 vector和嵌套</h4><ul>
<li>与其他数据结构相比，vector(以及类似的连续存储元素的数据结构)有三个主要优势<ul>
<li>vector的元素是紧凑存储的：所有元素都不存在额外的内存开销。类型为vector<X>的vec的内存消耗大致为 sizeof(vector<x>) + vec.size() * sizeof(x)。其中sizeof(vector<x>) 大约为12个字节，对大向量而言是微不足道的</li>
<li>vector的遍历非常快。为访问下一个元素，我们不必利用指针间接寻址，而且对类vector结构上的连续访问，现代计算机都进行了优化。这使得vector元素的线性扫描(就像find()和copy()所做的)接近最优</li>
<li>vector支持简单且高效的随机访问。这使得vector上的很多算法(例如sort()和binary_search())非常高效</li>
</ul>
</li>
</ul>
<h4 id="31-3-1-3-vector和数组"><a href="#31-3-1-3-vector和数组" class="headerlink" title="31.3.1.3 vector和数组"></a>31.3.1.3 vector和数组</h4><ul>
<li><strong>vector是一种资源句柄</strong>，这是允许改变大小和实现高效移动语义的原因。但是这一特点偶尔也会变为缺点–尤其是与不依赖于元素和句柄分离存储的数据结构(例如内置数组和array)相比。将元素序列保存在栈中或另一个对象中可能会带来性能上的优势。</li>
</ul>
<h4 id="31-3-1-4-vector和string"><a href="#31-3-1-4-vector和string" class="headerlink" title="31.3.1.4 vector和string"></a>31.3.1.4 vector和string</h4><ul>
<li>vector<char>是可改变大小，连续存储的char序列，string也是如此。那么我们应该如何在两者之间进行选择呢</li>
<li>vector是一种保存值的通用机制，并不对保存的值之间的关系做任何假设。对一个vector<char>而言，字符串Hello,World只不过是一个13个char类型的元素的序列而已。与之相反，string的设计目的就是保存字符序列，它认为字符间的关系是非常重要的。因此，我们很少会对string中的字符进行排序，因为这会破坏字符串的含义。某些string操作反映了这一点(例如c_str(), &gt;&gt; 和 find() C风格字符串以0结束)。string的实现也反映了对其使用方式的假设。</li>
</ul>
<h3 id="31-4-2-链表"><a href="#31-4-2-链表" class="headerlink" title="31.4.2 链表"></a>31.4.2 链表</h3><ul>
<li><p>STL提供了两种链表类型</p>
<ul>
<li>list：双向链表</li>
<li>forward_list：单向链表</li>
</ul>
</li>
<li><p>list为元素插入和删除操作进行了优化。当你向一个list插入元素或是从一个list删除元素时，list中其他元素的位置不会受到影响。特别的是，指向其他元素的迭代器也不会受到影响。</p>
</li>
<li><p>默认情况下，list的元素都独立分配内存空间，而且要保存指向前驱和后继的指针。与vector相比，每个list元素占用更多内存空间(通常每个元素至少多4个字)，遍历(迭代)操作也要慢得多，因为需要通过指针进行间接寻址而不是简单的连续访问。</p>
</li>
<li><p>forward_list是单向链表。你可以将其看作一种为空链表或很短的链表专门优化的数据结构，对这类链表的操作通常是从头开始遍历。</p>
</li>
</ul>
<h3 id="31-4-3-关联容器"><a href="#31-4-3-关联容器" class="headerlink" title="31.4.3 关联容器"></a>31.4.3 关联容器</h3><ul>
<li>关联容器支持基于关键字的查找。它有两个变体<ul>
<li>有序关联容器(ordered associative container)基于一个序标准(默认是小于比较操作 &lt;)进行查找。这类容器用平衡二叉树实现，通常是红黑树</li>
<li>无序关联容器(unordered associative container)基于一个哈希函数进行查找。这类容器用哈希表实现，采用溢出链表策略。</li>
</ul>
</li>
<li>两类容器都支持<ul>
<li>map: {键，值}对序列</li>
<li>set: 不带值的map(或者你可以说关键字就是值)</li>
</ul>
</li>
<li>最后，映射和集合，无论是有序还是无序的，都有两个变体<ul>
<li>普通映射或集合：每个关键字只有唯一一项</li>
<li>多重映射或集合：每个关键字可对应多项。</li>
</ul>
</li>
<li>一个关联容器的名字指出了它在三维空间{集合|映射，普通|无序，普通|多重}中的位置。</li>
</ul>
<h4 id="31-4-3-1-有序关联容器"><a href="#31-4-3-1-有序关联容器" class="headerlink" title="31.4.3.1 有序关联容器"></a>31.4.3.1 有序关联容器</h4><ul>
<li><p>实际上，[]并不仅仅是insert()的简写形式，它所做的要更多一些。m[k]的结果等价于 (*(m.insert(make_pair(k,v{})).first)).second，其中V是映射类型。insert(make_pair())这种描述方式相当冗长，我们可以用emplace()取而代之：dictionary.emplace(“sea cow”, “extinct”);</p>
</li>
<li><p><strong>关联容器中元素的关键字是不可变的</strong>。因此，我们不能改变set中的值。我们甚至不能改变不参与比较的元素的成员。如果需要修改元素，应使用map。不要尝试修改关键字：假如你成功了，就意味着查找元素的底层机制会崩溃。</p>
</li>
</ul>
<h4 id="31-4-3-2-无序关联容器"><a href="#31-4-3-2-无序关联容器" class="headerlink" title="31.4.3.2 无序关联容器"></a>31.4.3.2 无序关联容器</h4><ul>
<li>无序关联容器都是用哈希表实现的。对简单应用而言，无序关联容器与有序容器的差别不大，因为关联容器共享大部分操作。</li>
<li>unordered_map的遍历顺序取决于插入顺序，哈希函数和装载因子。特别是，元素的遍历顺序并不保证与其插入顺序一致。</li>
</ul>
<h4 id="31-4-3-3-构造unordered-map"><a href="#31-4-3-3-构造unordered-map" class="headerlink" title="31.4.3.3 构造unordered_map"></a>31.4.3.3 构造unordered_map</h4><h4 id="31-4-3-4-哈希和相等判定函数"><a href="#31-4-3-4-哈希和相等判定函数" class="headerlink" title="31.4.3.4 哈希和相等判定函数"></a>31.4.3.4 哈希和相等判定函数</h4><ul>
<li>用户可以自定义哈希函数，定义方式有多种，不同的技术可满足不同的需求。</li>
</ul>
<h4 id="31-4-3-5-装载因子和桶"><a href="#31-4-3-5-装载因子和桶" class="headerlink" title="31.4.3.5 装载因子和桶"></a>31.4.3.5 装载因子和桶</h4><ul>
<li>无序容器实现的重要部分对程序员是可见的。我们说具有相同哈希值的关键字 落在同一个桶中。程序员也可以获取并设置哈希表的大小。</li>
<li>无序关联容器的装载因子(load factor)定义为已用空间的比例。例如，若capacity()为100个元素，size()为30，则load_factor()为0.3</li>
<li>桶接口的一个用途是允许对哈希函数进行实验: 一个糟糕的哈希函数会导致某些关键字值的bucket_count()异常大，即，很多关键字被映射为相同的哈希值。</li>
</ul>
<h3 id="31-5-容器适配器"><a href="#31-5-容器适配器" class="headerlink" title="31.5 容器适配器"></a>31.5 容器适配器</h3><ul>
<li>容器适配器(container adaptor)为容器提供不同的(通常是受限的)的接口。容器适配器的设计用法就是仅通过其特殊接口使用。特别是，STL容器适配器不提供直接访问其底层容器的方式，也不提供迭代器或下标操作。</li>
<li>从一个容器创建容器适配器的技术是一种通用的按用户需求非侵入式适配类接口的技术。</li>
</ul>
<h4 id="31-5-1-stack"><a href="#31-5-1-stack" class="headerlink" title="31.5.1 stack"></a>31.5.1 stack</h4><ul>
<li>stack是一个容器接口，容器类型是作为模板实参传递给它的。stack通过接口屏蔽了其底层容器上的非栈操作，接口采用常规命名: top(), push()和pop()</li>
<li>此外，stack还提供了常用的比较运算符(&#x3D;&#x3D;, &lt;等)和非成员函数swap()</li>
<li>默认情况下，stack用deque保存其元素，但任何提供back(),push_back()和pop_back()操作的序列都可使用。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">char</span>&gt; s1;   <span class="comment">// 使用deque&lt;char&gt;保存元素</span></span><br><span class="line">stack&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; s2;  <span class="comment">// 使用vector&lt;int&gt;保存元素</span></span><br></pre></td></tr></table></figure></li>
<li>vector通常比deque更快，使用内存也更少</li>
<li>stack对底层容器使用push_back()来添加元素。因此，只要机器还有可用内存供容器申请，stack就不会溢出。</li>
<li>默认情况下，stack使用其底层容器的分配器。如果这不够，有几个构造函数可以指定分配器。</li>
</ul>
<h4 id="31-5-2-queue"><a href="#31-5-2-queue" class="headerlink" title="31.5.2 queue"></a>31.5.2 queue</h4><ul>
<li>queue定义在<queue>中，它是一个容器接口，允许在back()中插入元素，在front()中提取元素</li>
</ul>
<h4 id="31-5-3-priority-queue"><a href="#31-5-3-priority-queue" class="headerlink" title="31.5.3 priority_queue"></a>31.5.3 priority_queue</h4><ul>
<li>priority_queue是一种队列，其中每个元素都被赋予一个优先级，用来控制元素被top()获取的顺序。priority_queue的声明非常像queue，只是多了处理一个比较对象的代码和一组从序列进行初始化的构造函数。</li>
<li>默认情况下,priority_queue简单的用 &lt; 运算符比较元素，用top()返回优先级最高的元素</li>
</ul>
<h3 id="31-6-建议"><a href="#31-6-建议" class="headerlink" title="31.6 建议"></a>31.6 建议</h3><ul>
<li>一个STL容器定义一个序列</li>
<li>将vector作为默认容器使用</li>
<li>insert()和push_back()这样的插入操作在vector上通常比在list上更高效</li>
<li>将forward_list用于通常为空的序列</li>
<li>当设计性能时，不要盲目信任你的直觉，而要进行测试</li>
<li>不要盲目信任渐进复杂性度量；某些序列很短而单一操作的代价差异可能很大</li>
<li>STL容器都是资源句柄</li>
<li>map通常实现为红黑树</li>
<li>unordered_map是哈希表</li>
<li>STL容器的元素类型必须提供拷贝和移动操作</li>
<li>如果你希望保持多态行为，使用指针或智能指针的容器</li>
<li>比较操作应该实现一个严格弱序</li>
<li>以传引用方式传递容器参数，以传值方式返回容器</li>
<li>对一个容器，用()初始化器初始化大小，用{}初始化器语法初始化元素列表</li>
<li>用范围for循环或首位迭代器对容器进行简单遍历</li>
<li>如果不需要修改容器元素，使用const迭代器</li>
<li>当使用迭代器时，用auto避免冗长易错的输入</li>
<li>用reserve()壁面指向容器元素的指针和迭代器失效</li>
<li>未经测试不要假定reserve()会有性能收益</li>
<li>使用容器上的push_back()或resize()，而不是数组上的realloc()</li>
<li>vector和deque改变大小后，不要继续使用其上的迭代器</li>
<li>在需要时使用reserve()令性能可预测</li>
<li>不要假定[]会进行范围检查</li>
<li>当需要保证进行范围检查时使用at()</li>
<li>用emplace()方便符号表示</li>
<li>优选紧凑连续存储的数据结构</li>
<li>用emplace()避免提前初始化元素</li>
<li>遍历list的代价相对较高</li>
<li>list一般会有每个元素四个字的额外内存开销</li>
<li>有序容器序列由其比较对象(默认为 &lt;)定义</li>
<li>无序容器(哈希容器)序列并无可预测的序</li>
<li>如果你需要在大量数据中快速查找元素，使用无序容器</li>
<li>对五自然序的元素类型，使用无序容器</li>
<li>如果需要按顺序遍历元素，使用有序关联容器</li>
<li>用实验检查你的哈希函数是否可以接受</li>
<li>用异或操作组合标准哈希函数得到的哈希函数通常有很好的性能</li>
<li>0.7通常是一个合理的装载因子</li>
<li>你可以为容器提供其他接口</li>
<li>STL适配器不提供对其底层容器的直接访问</li>
</ul>
<h2 id="第三十二章-STL算法"><a href="#第三十二章-STL算法" class="headerlink" title="第三十二章 STL算法"></a>第三十二章 STL算法</h2><h3 id="32-1-引言"><a href="#32-1-引言" class="headerlink" title="32.1 引言"></a>32.1 引言</h3><ul>
<li>STL包含标准库中的迭代器，容器，算法和函数对象几个部分</li>
</ul>
<h3 id="32-2-算法"><a href="#32-2-算法" class="headerlink" title="32.2 算法"></a>32.2 算法</h3><ul>
<li><p><algorithm>中定义了大约80个标准算法。</p>
</li>
<li><p>很多算法都遵循一种常规表示方式: 返回序列的末尾来表示 未找到。</p>
</li>
<li><p>无论是标准库算法还是用户自己设计的算法，都很重要</p>
<ul>
<li>每个算法命名一个特定操作，描述其接口，并指定其语义</li>
<li>每个算法都可能广泛使用并被很多程序员熟知</li>
</ul>
</li>
<li><p>如果你发现你写的一段代码有若干看起来没什么关联的循环，局部变量，或是有很复杂的控制结构，那么就应该考虑是否可以简化代码，将某些部分改写为具有描述性的名字以及良好定义的目的，接口和依赖关系的函数&#x2F;算法。</p>
</li>
</ul>
<h4 id="32-2-1-序列"><a href="#32-2-1-序列" class="headerlink" title="32.2.1 序列"></a>32.2.1 序列</h4><ul>
<li>标准库算法的理想目标是为可优化实现的某些东西提供最通用最灵活的接口。</li>
<li>注意，无论一个STL算法返回什么，它都不会是实参的容器。传递给STL算法的实参是迭代器，算法完全不了解迭代器所指向的数据结构。</li>
<li>迭代器的存在主要是为了将算法从它所处理的数据结构上分离开来，反之亦然。</li>
</ul>
<h3 id="32-8-建议"><a href="#32-8-建议" class="headerlink" title="32.8 建议"></a>32.8 建议</h3><ul>
<li>STL算法操作一个或多个序列</li>
<li>一个输入序列是一个半开区间，由一对迭代器定义</li>
<li>进行搜索时，算法通常返回输入序列的末尾位置表示 未找到</li>
<li>优选精心说明的算法而非 随意代码</li>
<li>当你要编写一个循环时，思考它是否可以表达为一个通用算法</li>
<li>确保一对迭代器实参确使指定了一个序列</li>
<li>当迭代器对风格显得冗长时，引入容器&#x2F;范围版本的算法</li>
<li>用谓词和其他函数对象赋予标准算法更宽泛的含义</li>
<li>谓词不能修改其实参</li>
<li>指针上默认的&#x3D;&#x3D;和 &lt; 极少能满足标准算法的需求</li>
<li>了解你使用的算法的时间复杂性，但要记住复杂性评价只是对性能的粗略引导</li>
<li>只在对一个任务没有更专用的算法时使用 for_each() 和 transform()</li>
<li>算法并不直接向其实参序列添加元素或从其中删除元素</li>
<li>如果不得不处理未初始化的对象，考虑 uninitialized_* 系列算法</li>
<li>STL算法基于其排序比较操作实现相等性比较</li>
<li>注意，排序和搜索C风格的字符串要求用户提供一个字符串比较操作。</li>
</ul>
<h2 id="第三十三章-STL迭代器"><a href="#第三十三章-STL迭代器" class="headerlink" title="第三十三章 STL迭代器"></a>第三十三章 STL迭代器</h2><h3 id="33-1-引言"><a href="#33-1-引言" class="headerlink" title="33.1 引言"></a>33.1 引言</h3><ul>
<li>迭代器是标准库算法和所操作的数据间的粘合剂。反过来，也可以说迭代器机制是为了最小化算法与所操作的数据结构间的依赖性</li>
</ul>
<h4 id="33-1-1-迭代器模型"><a href="#33-1-1-迭代器模型" class="headerlink" title="33.1.1 迭代器模型"></a>33.1.1 迭代器模型</h4><ul>
<li>与指针类似，迭代器提供了简介访问的操作(例如解引用操作 *)和移动到新元素的操作(例如，++操作移动到下一个元素)。一对迭代器定义一个半开区间 [begin:end)，即所谓序列(sequence)<ul>
<li>即，begin指向序列的首元素，end指向序列的尾元素之后的位置。永远也不要从 *end 读取数据，也不要向它写入数据。</li>
<li>注意，空序列满足 begin &#x3D;&#x3D; end；即，对任意迭代器p都有 [p:p)是空序列</li>
</ul>
</li>
<li>为了 读取一个序列，算法通常接受一对表示半开区间[begin:end)的迭代器(b, e)，并使用++编译序列直至到达末尾</li>
</ul>
<h4 id="33-1-2-迭代器类别"><a href="#33-1-2-迭代器类别" class="headerlink" title="33.1.2 迭代器类别"></a>33.1.2 迭代器类别</h4><ul>
<li><p>标准库提供了五种迭代器</p>
<ul>
<li>输入迭代器(input iterator): 利用输入迭代器，我们可以用++向前遍历序列并用*(反复)读取每个元素。我们可以用&#x3D;&#x3D;和!&#x3D;比较输入迭代器。istream提供了这种迭代器</li>
<li>输出迭代器(output iterator): 利用输出迭代器，我们可以用++向前遍历序列并用*每次写入一个元素。ostream提供了这种迭代器</li>
<li>前向迭代器(forward iterator): 利用前向迭代器，我们可以反复使用++向前遍历序列并用*读写元素(除非元素是const的)。如果一个前向迭代器指向一个类对象我们可以用-&gt;访问其成员。我们可以用&#x3D;&#x3D;和!&#x3D;比较前向迭代器。forward_list提供了这种迭代器</li>
<li>双向迭代器(bidirection iterator): 利用双向迭代器，我们可以向前(用++)和向后(用–)遍历序列并用*(反复)读写元素(除非元素是const的)。如果一个双向迭代器指向一个类对象，我们可以用-&gt;访问其成员。我们可以用&#x3D;&#x3D;和!&#x3D;比较双向迭代器。list，map和set提供了这种迭代器</li>
<li>随机访问迭代器(random-access iterator): 对一个随机访问迭代器，我们可以用[]进行下标操作，用+加上一个整数，以及用-减去一个整数。我们可以将指向同一个序列的两个随机访问迭代器相减来获得他们的距离。我们可以用&#x3D;&#x3D;,!&#x3D;,&lt;&#x3D;, &gt;和&gt;&#x3D;比较双向迭代器。vector提供了这种迭代器</li>
</ul>
</li>
<li><p><strong>这些迭代器类别是概念而非类</strong>，因此这个层次并非用继承实现的类层次。如果你希望用迭代器类别做一些更进阶的事情，可(直接或间接)使用iterator_traits。</p>
</li>
</ul>
<h4 id="33-1-3-迭代器萃取"><a href="#33-1-3-迭代器萃取" class="headerlink" title="33.1.3 迭代器萃取"></a>33.1.3 迭代器萃取</h4><ul>
<li>迭代器标签的本质是类型，用来基于迭代器类型选择算法。</li>
<li>关键思路是：为了获得迭代器的属性，你应该访问其 iterator_traits而不是迭代器本身</li>
</ul>
<h4 id="33-1-4-迭代器操作"><a href="#33-1-4-迭代器操作" class="headerlink" title="33.1.4 迭代器操作"></a>33.1.4 迭代器操作</h4><h3 id="33-2-迭代器适配器"><a href="#33-2-迭代器适配器" class="headerlink" title="33.2 迭代器适配器"></a>33.2 迭代器适配器</h3><ul>
<li>在<iterator>中，标准库提供了适配器，能从一个给定的迭代器类型生成有用的相关迭代器类型<ul>
<li>reverse_iterator 反向遍历</li>
<li>back_insert_iterator 在尾部插入</li>
<li>front_insert_iterator 在头部插入</li>
<li>insert_iterator 在任意位置插入</li>
<li>move_iterator 移动而不是拷贝</li>
<li>raw_storage_iterator 写入未初始化的存储空间</li>
</ul>
</li>
</ul>
<h3 id="33-4-函数对象"><a href="#33-4-函数对象" class="headerlink" title="33.4 函数对象"></a>33.4 函数对象</h3><ul>
<li>很多标准库算法接受函数对象(或函数)参数，来控制其工作方式。常见的函数对象包括比较标准，谓词(返回bool的函数)和算术运算。在<functional>中，标准库提供了若干常用函数对象。</li>
</ul>
<h3 id="33-5-函数适配器"><a href="#33-5-函数适配器" class="headerlink" title="33.5 函数适配器"></a>33.5 函数适配器</h3><ul>
<li>函数适配器接受一个函数参数，返回一个可用来调用该函数的函数对象。<ul>
<li>g &#x3D; bind(f, args) <ul>
<li>g(args2)等价于f(args3)是通过用args2中的实参替换args中对应的占位符(例如 _1, _2, _3)得到的</li>
</ul>
</li>
<li>g &#x3D; mem_fn(f) 若p是一个指针，则g(p, args)表示p-&gt;f(args)，否则g(p, args)表示p.mf(args); args是一个实参列表</li>
<li>g &#x3D; not1(f) g(x)表示!f(x)</li>
<li>g &#x3D; not2(f) g(x, y) 表示 !f(x, y)</li>
</ul>
</li>
</ul>
<h4 id="33-5-3-function"><a href="#33-5-3-function" class="headerlink" title="33.5.3 function"></a>33.5.3 function</h4><ul>
<li>我们可以直接使用bind()，以及用它来初始化auto变量。从这个角度看，bind()很像是一个lambda</li>
<li>标准库function是一种类型，它可以保存你能调用运算符()调用的任何对象。即，一个function类型对象就是一个函数对象</li>
<li>显然，function对回调，将操作作为参数传递等机制非常有用</li>
</ul>
<h3 id="33-6-建议"><a href="#33-6-建议" class="headerlink" title="33.6 建议"></a>33.6 建议</h3><ul>
<li>一个输入序列由一对迭代器定义</li>
<li>一个输出序列由单一迭代器定义；程序员应负责避免溢出</li>
<li>对任意迭代器p，[p:p)是一个空序列</li>
<li>使用序列列尾表示 未找到</li>
<li>将迭代器理解为更通用，通常行为也更好的指针</li>
<li>使用迭代器类型，例如 list<char>::iterator，而不是指向容器中元素的指针</li>
<li>用iterator_traits获取迭代器的相关信息</li>
<li>可以用iterator_traits实现编译时分发</li>
<li>用iterator_traits实现基于迭代器类别选择最优算法</li>
<li>用base()从reverse_iterator提取iterator</li>
<li>可以使用插入迭代器向容器添加元素</li>
<li>move_iterator可用来将拷贝操作变为移动操作</li>
<li>确认你的容器可用范围for语句遍历</li>
<li>用bind()创建函数和函数对象的变体</li>
<li>注意bind()会提前解引用；如果你希望推迟解引用，使用ref()</li>
<li>可使用mem_fn()或lambda将p-&gt;f(a)调用规范转换为f(p, a)</li>
<li>如果你需要一个可以保存各种可调用对象的变量，使用function</li>
</ul>
<h2 id="第三十四章-内存和资源"><a href="#第三十四章-内存和资源" class="headerlink" title="第三十四章 内存和资源"></a>第三十四章 内存和资源</h2><h3 id="34-1-引言"><a href="#34-1-引言" class="headerlink" title="34.1 引言"></a>34.1 引言</h3><ul>
<li>STL时标准库中高度结构化的，通用的数据管理和操作组件。本章介绍更为专用的以及处理裸内存的(与处理强类型对象相对)组件</li>
</ul>
<h3 id="34-2-拟容器"><a href="#34-2-拟容器" class="headerlink" title="34.2 拟容器"></a>34.2 拟容器</h3><ul>
<li><p>标准库中有一些容器不能很好的纳入STL框架，例如内置数组，array和string。我有时将他们称为拟容器。</p>
<ul>
<li>T[N]  固定大小的内置数组，连续存储的N个类型为T的元素，隐式转换为T*</li>
<li>array&lt;T,N&gt;  固定大小的数组，连续存储的N个类型为T的元素，类似内置数组，但解决了大部分问题</li>
<li>bitset<N>  固定大小的N个二进制的序列</li>
<li>vector<bool> vector的特例化版本，紧凑保存二进制位序列</li>
<li>pair&lt;T, U&gt;  两个元素，类型为T和U</li>
<li>tuple&lt;T…&gt;  任意数目任意类型的元素的序列</li>
<li>basic_string<C>  类型为C的字符的序列，提供了字符串操作</li>
<li>valarray<T>  类型为T的数值的数组，提供了数值运算</li>
</ul>
</li>
<li><p>为什么标准库会提供这么多容器？这是为了满足很多常见但又有差异(通常也有重叠)的需求。如果标准库不提供这些容器，很多人将不得不自己实现。例如</p>
<ul>
<li>pair和tuple是异构的，所有其他容器都是同构的(元素都是相同类型)</li>
<li>array, vector和tuple连续保存元素；forward_list和map是链式结构</li>
<li>bitset和vector<bool>保存二进制位，通过代理对象访问这些二进制位；所有其他标准库容器都可以保存不同类型并直接访问元素</li>
<li>basic_string要求其元素位某种字符类型，它提供了字符串操作，例如连接操作和区域敏感操作，valarray要求其元素为数值类型，并提供数值运算。</li>
</ul>
</li>
</ul>
<h4 id="34-2-1-array"><a href="#34-2-1-array" class="headerlink" title="34.2.1 array"></a>34.2.1 array</h4><ul>
<li><p>array定义在<array>中，是固定大小的给定类型的元素的序列，元素数目在编译时指定。因此，连同其元素可以在栈中，对象内或静态存储中分配空间。</p>
</li>
<li><p>array在哪个作用域中定义，元素就会在其中分配。理解array的最好方式是将其视为固定大小的内置数组，但不会隐式的，出乎意料地转换为指针类型，且提供了一些便利的函数</p>
</li>
<li><p>array中不保存任何管理信息(例如大小)。这意味着移动一个array比拷贝它更为高效(除非array的元素是资源句柄，且定义了高效的移动操作)。array没有构造函数或分配器(因为它不直接分配任何东西)</p>
</li>
<li><p>array的元素数目和下标值是unsigned类型(size_t)</p>
</li>
<li><p>元素数目必须是一个常量表达式</p>
</li>
<li><p>如果需要可变元素数目，应该使用vector。另一方面，由于array的元素数目在编译时即知，array的size()是一个constexpr函数</p>
</li>
<li><p>如果需要，可以将一个array作为指针显式的传递给一个C风格的函数</p>
</li>
<li><p>vector是如此灵活，我们为什么要使用array呢？</p>
<ul>
<li>原因是array虽不如vector灵活，但更简单。少数情况下，直接访问分配在栈中的元素较之在自由存储空间中分配元素，然后通过vector(句柄)间接访问它们，最后将它们释放，会有巨大的性能优势。</li>
<li>当然另一方面，栈是一个有限的资源(特别是在一些嵌入式系统中)，而栈溢出是非常糟糕的</li>
</ul>
</li>
<li><p>如果我们可以使用内置数组，又为什么要使用array呢？</p>
<ul>
<li>array了解自己的大小，因此很容易使用标准库算法，而且可以拷贝(用&#x3D;或初始化)。</li>
<li>但是选择array的主要原因是，它使我不必为糟糕的指针转换头疼。</li>
</ul>
</li>
</ul>
<h4 id="34-2-2-bitset"><a href="#34-2-2-bitset" class="headerlink" title="34.2.2 bitset"></a>34.2.2 bitset</h4><ul>
<li><p>一个bitset<N>就是一个包含N个二进制位的数组，它定义在<bitset>中。它与vector<bool>的不同之处是大小固定，与set的不同之处是二进制位用整数索引而不是关联值，与vector<bool>和set的共同差异是提供了操作二进制位的操作。</p>
</li>
<li><p>用内置指针是不可能寻址一个二进制位的。因此，bitset提供了一种位引用(代理)类型。对那些由于某种原因不适合用内置指针寻址的对象，通常这种技术是很有用的解决方案</p>
</li>
<li><p>bitset设计中的一个关键思想是：能放入单个机器字中的bitset可优化实现。其接口反映了这一思想。</p>
</li>
</ul>
<h4 id="34-2-3-vector"><a href="#34-2-3-vector" class="headerlink" title="34.2.3 vector"></a>34.2.3 vector<bool></h4><ul>
<li>vector<bool>定义在<vector>中，它是vector的一个特例化版本，提供了二进制(bool值)的紧凑存储</li>
<li>显然，vector<bool>与bitset很相似，与bitset不同而与vector<T>相似的是，vector<bool>具有分配器，也能改变大小。</li>
<li>类似vector<T>，vector<bool>中索引更大的元素保存在高地址。这与bitset的内存布局完全相反。而且标准库也提供将整数和字符串直接转换为vector<bool>的操作。</li>
</ul>
<h4 id="34-2-4-元组"><a href="#34-2-4-元组" class="headerlink" title="34.2.4 元组"></a>34.2.4 元组</h4><ul>
<li>标准库提供了两种将任意类型的值组成单一对象的方法<ul>
<li>pair保存两个值</li>
<li>tuple保存零个或多个值</li>
</ul>
</li>
<li>如果我们预先知道恰好有两个值，pair就很有用处了。而tuple用于我们必须处理任意多个值的情况</li>
</ul>
<h3 id="34-3-资源管理指针"><a href="#34-3-资源管理指针" class="headerlink" title="34.3 资源管理指针"></a>34.3 资源管理指针</h3><ul>
<li>一个指针指向一个对象(或不指向任何东西)。但是，指针并不能指出谁(如果有的话)拥有对象。即，仅仅查看指针，我们得不到任何关于”谁应(或是如何，或是是否)删除对象”的信息。</li>
<li>在<memory>中，我们可以找到表达所有权的智能指针<ul>
<li>unique_ptr: 表示互斥的所有权</li>
<li>shared_ptr: 表示共享的所有权</li>
<li>weak_ptr: 可打破循环共享数据结构中的回路</li>
</ul>
</li>
</ul>
<h4 id="34-3-1-unique-ptr"><a href="#34-3-1-unique-ptr" class="headerlink" title="34.3.1 unique_ptr"></a>34.3.1 unique_ptr</h4><ul>
<li><p>unique_ptr提供了一种严格的所有权语义</p>
<ul>
<li>一个unique_ptr拥有一个对象，它保存一个指针(指向该对象)。即，unique_ptr有责任用所保护的指针销毁所指向的对象(如果有的话)</li>
<li>unique_ptr不能拷贝(没有拷贝构造函数和拷贝赋值函数)，但是可以移动</li>
<li>unique_ptr保存一个指针，当它自身被销毁时，使用关联的释放器(如果有的话)释放所指向的对象(如果有的话)</li>
</ul>
</li>
<li><p>unique_ptr的用途包括</p>
<ul>
<li>为动态分配的内存提供异常安全</li>
<li>将动态分配内存的所有权传递给函数</li>
<li>从函数返回动态分配的内存</li>
<li>在容器中保存指针</li>
</ul>
</li>
<li><p>unique_ptr不提供拷贝构造函数和拷贝赋值运算符。</p>
</li>
</ul>
<h4 id="34-3-2-shared-ptr"><a href="#34-3-2-shared-ptr" class="headerlink" title="34.3.2 shared_ptr"></a>34.3.2 shared_ptr</h4><ul>
<li><p>shared_ptr表示共享所有权。当两段代码需要访问同一个数据，但两者都没有独享所有权(负责销毁对象)时，可以使用shared_ptr。shared_ptr是一种计数指针，当计数变为零时释放所指向的对象。</p>
</li>
<li><p>我们可以将共享指针理解为包含两个指针的结构：一个指针指向对象，另一个指针指向计数器。</p>
</li>
<li><p>释放器(deleter)用来在计数器变为零时释放共享对象。默认释放器通常是delete(它会调用对象的析构函数(如果存在的话)，并释放自由存储空间)</p>
</li>
<li><p>当可以选择时</p>
<ul>
<li>优先选择unique_ptr而不是shared_ptr</li>
<li>优先选择普通限域对象而不是在堆中分配空间，由unique_ptr管理所有权的对象</li>
</ul>
</li>
</ul>
<h4 id="34-3-3-weak-ptr"><a href="#34-3-3-weak-ptr" class="headerlink" title="34.3.3 weak_ptr"></a>34.3.3 weak_ptr</h4><ul>
<li>weak_ptr指向一个shared_ptr所管理的对象。为了访问对象，可使用成员函数lock()将weak_ptr转换为shared_ptr。weak_ptr允许访问他人拥有的对象<ul>
<li>(仅)当对象存在时你才需要访问他</li>
<li>对象可能在任何时间被(其他人)释放</li>
<li>在对象最后一次被使用后必须调用其析构函数(通常释放非内存资源)</li>
</ul>
</li>
</ul>
<h3 id="34-4-分配器"><a href="#34-4-分配器" class="headerlink" title="34.4 分配器"></a>34.4 分配器</h3><ul>
<li>STL容器和string都是资源句柄，获取和释放内存来保存其元素。为此，它们使用分配器(allocator)。分配器的基本目的是为给定类型提供内存资源以及提供在内存不再需要时将其归还的地方。</li>
<li>基本的分配器函数有<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = a.<span class="built_in">allocate</span>(n);  <span class="comment">// 为n个类型为T的对象获取空间</span></span><br><span class="line">a.<span class="built_in">deallocate</span>(p, n);  <span class="comment">// 释放p所指的保存n个类型为T的对象的空间</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="34-4-1-默认分配器"><a href="#34-4-1-默认分配器" class="headerlink" title="34.4.1 默认分配器"></a>34.4.1 默认分配器</h4><ul>
<li>所有标准库容器都(默认)使用默认分配器，它用new分配空间，用delete释放空间</li>
</ul>
<h3 id="34-5-垃圾收集接口"><a href="#34-5-垃圾收集接口" class="headerlink" title="34.5 垃圾收集接口"></a>34.5 垃圾收集接口</h3><ul>
<li>垃圾收集(自动回收无引用的内存区域)有时被认为是万能灵药，但它并不是。特别是，垃圾收集器可能无法避免并非纯内存的资源的泄露，例如文件句柄，线程句柄以及锁。</li>
<li>我将垃圾收集看作下列常见的防泄漏技术都已用尽时的最后一种方便的手段<ul>
<li>只要可能，应使用具有正确语义的资源句柄来防止应用程序中的资源泄露。标准库提供了string, vector, unordered_map, thread, lock_guard以及其他很多资源句柄。移动语义允许从函数高效返回这类对象</li>
<li>使用unique_ptr保存这样的对象：不隐式管理其所拥有资源(例如指针)，需要免受不成熟释放机制之害或是需要特别关注分配方式(释放器)、</li>
<li>使用shared_ptr保存需要共享所有权的对象。</li>
</ul>
</li>
</ul>
<h3 id="34-6-未初始化内存"><a href="#34-6-未初始化内存" class="headerlink" title="34.6 未初始化内存"></a>34.6 未初始化内存</h3><ul>
<li>大多数情况下，最好避免使用未初始化的内存。这样做可以简化编程，消除很多错误。</li>
<li>除了标准的allocator，<memory>头文件还提供了fill*系列函数用于处理未初始化内存。</li>
</ul>
<h3 id="34-7-建议"><a href="#34-7-建议" class="headerlink" title="34.7 建议"></a>34.7 建议</h3><ul>
<li>当你需要一个具有constexpr大小的序列时，使用array</li>
<li>优先选择array而不是内置数组</li>
<li>当你需要N个二进制位而N又不到一定是整数类型的位宽时，使用bitset</li>
<li>避免使用vector<bool></li>
<li>当使用pair时，考虑使用make_pair()进行类型推断</li>
<li>当使用tuple时，考虑使用make_tuple()进行类型推断</li>
<li>使用unique_ptr表示互斥所有权</li>
<li>使用shared_ptr表示共享所有权</li>
<li>尽量不适用weak_ptr</li>
<li>(仅)当由于逻辑上或性能上的原因，常用的new&#x2F;delete语义不能满足需求时才使用分配器</li>
<li>优先选择有特定语义的资源句柄而不是智能指针</li>
<li>优先选择unique_ptr而不是shared_ptr</li>
<li>优先选择智能指针而不是垃圾收集</li>
<li>为通用资源的管理提供一致，完整的策略</li>
<li>在大量使用指针的程序中处理泄露问题，垃圾收集是非常有用的</li>
<li>垃圾收集是可选的</li>
<li>不要伪装指针(即使你不使用垃圾收集)</li>
<li>如果你使用垃圾收集，使用declare_no_pointers()令垃圾收集器忽略不可能包含指针的数据</li>
<li>不要随机使用未初始化内存，除非你确使必须这么做。</li>
</ul>
<h2 id="第三十五章-工具"><a href="#第三十五章-工具" class="headerlink" title="第三十五章 工具"></a>第三十五章 工具</h2><h3 id="35-1-引言"><a href="#35-1-引言" class="headerlink" title="35.1 引言"></a>35.1 引言</h3><ul>
<li>标准库提供了很多应用广泛的工具组件，但它们很难归到某类主要组件中。</li>
</ul>
<h3 id="35-2-时间"><a href="#35-2-时间" class="headerlink" title="35.2 时间"></a>35.2 时间</h3><ul>
<li><p>在<chrono>中，标准库提供了处理时间段和时间点的组件。</p>
</li>
<li><p>我们通常希望对某事计时或做某些依赖于时间的事情。例如，标准库互斥量和锁提供了让thread等待一段时间(duration)或等待到给定时刻(time_point)的选项。</p>
</li>
<li><p>如果你希望获得当前的time_point，可以对3种时钟之一调用now(): system_clock, steady_clock和high_resolution_clock</p>
</li>
<li><p>时钟返回一个time_point, 一个duration就是相同时钟的两个time_point间的距离。</p>
</li>
<li><p>时间组件的设计目的之一是支持在系统深层中的高效使用；它们不提供社交日历便利维护这类组件。实际上，时间组件源自高能物理的迫切需求。</p>
</li>
</ul>
<h4 id="35-2-1-duration"><a href="#35-2-1-duration" class="headerlink" title="35.2.1 duration"></a>35.2.1 duration</h4><ul>
<li>在<chrono>中，标准库提供了类型duration来表示两个时间点(time_point)间的距离</li>
</ul>
<h4 id="35-2-2-time-point"><a href="#35-2-2-time-point" class="headerlink" title="35.2.2 time_point"></a>35.2.2 time_point</h4><ul>
<li>在<chrono>中，标准库提供了类型time_point，用来表示给定纪元的一个时间点，用给定的clock度量</li>
<li>一个纪元(epoch)就是由给定clock确定的一个时间范围，用duration来衡量，从duration::zero()开始</li>
</ul>
<h4 id="35-2-3-时钟"><a href="#35-2-3-时钟" class="headerlink" title="35.2.3 时钟"></a>35.2.3 时钟</h4><ul>
<li>time_point和duration值归根结底是从硬件时钟获得的。</li>
<li>系统提供了3个命名的时钟<ul>
<li>system_clock 系统实时时钟；可以重置系统时钟(向前或向后跳)来匹配内部时钟</li>
<li>steady_clock 时间稳定推移的时钟，即时间不会回退且时钟周期的间隔是常量</li>
<li>high_resolution_clock 一个系统上具有最短时间增量的时钟</li>
</ul>
</li>
</ul>
<h3 id="35-3-编译时有理数运算"><a href="#35-3-编译时有理数运算" class="headerlink" title="35.3 编译时有理数运算"></a>35.3 编译时有理数运算</h3><ul>
<li><ratio>中定义了类ratio，提供了编译时有理数运算。标准库用ratio提供时间段和时间点的编译时表示</li>
<li>其基本思想是将一个有理数的分子和分母编码为(值)模板实参。分母必须非零</li>
</ul>
<h3 id="35-4-类型函数"><a href="#35-4-类型函数" class="headerlink" title="35.4 类型函数"></a>35.4 类型函数</h3><ul>
<li>在<type_traits>中，标准库提供了类型函数，用来确定类型的属性(类型萃取)以及从已有类型生成新类型(类型生成器)</li>
</ul>
<h4 id="35-4-1-类型萃取"><a href="#35-4-1-类型萃取" class="headerlink" title="35.4.1 类型萃取"></a>35.4.1 类型萃取</h4><ul>
<li>在<type_traits>中，标准库提供了多种类型函数，允许程序员确定一个类型或一对类型的属性。它们的名字大多是自解释的。主类型谓词(primary type predicate)检测类型的基本属性</li>
<li>类型萃取返回一个布尔值。为了访问此值，可使用后缀::value</li>
</ul>
<h4 id="35-4-2-类型生成器"><a href="#35-4-2-类型生成器" class="headerlink" title="35.4.2 类型生成器"></a>35.4.2 类型生成器</h4><ul>
<li>在<type_traits>中，标准库提供了从一个给定类型实参生成另一个类型的类型函数。</li>
<li>一个类型转换器返回一个类型。为了访问这个类型，可以使用后缀::type</li>
</ul>
<h3 id="35-5-其他工具"><a href="#35-5-其他工具" class="headerlink" title="35.5 其他工具"></a>35.5 其他工具</h3><h4 id="35-5-1-move-和forward"><a href="#35-5-1-move-和forward" class="headerlink" title="35.5.1 move()和forward()"></a>35.5.1 move()和forward()</h4><ul>
<li>move()进行简单的右值转换。我们用move()告知编译器：此对象在上下文中不再被使用，因此其值可被移动，留下一个空对象</li>
<li>forward()的典型用法是将一个实参从一个函数 完美转发 到另一个函数。</li>
<li>当希望用一个移动操作 窃取 一个对象的表达形式时，使用move()；当希望转发一个对象时，使用forward()</li>
<li>因此，forward(x)总是安全的，而move(x)标记x将被销毁，因此要小心使用。调用move(x)之后x唯一安全的用法就是析构或者是赋值的目的。</li>
</ul>
<h4 id="35-5-2-swap"><a href="#35-5-2-swap" class="headerlink" title="35.5.2 swap()"></a>35.5.2 swap()</h4><ul>
<li>在<utility>中，标准库提供了一个通用的swap()和一个针对内置数组的特例化的版本</li>
<li>swap()不能用来交换右值</li>
</ul>
<h4 id="35-5-3-关系运算符"><a href="#35-5-3-关系运算符" class="headerlink" title="35.5.3 关系运算符"></a>35.5.3 关系运算符</h4><ul>
<li>在<utility>中，标准库提供了任意类型的关系运算符，它们定义在子命名空间rel_ops中</li>
</ul>
<h4 id="35-5-4-比较和哈希type-info"><a href="#35-5-4-比较和哈希type-info" class="headerlink" title="35.5.4 比较和哈希type_info"></a>35.5.4 比较和哈希type_info</h4><ul>
<li>在<typeindex>中，标准库提供了比较和哈希type_index的组件。一个type_index是从一个type_info创建的，专门用于这种比较和哈希。</li>
</ul>
<h3 id="35-6-建议"><a href="#35-6-建议" class="headerlink" title="35.6 建议"></a>35.6 建议</h3><ul>
<li>用<chrono>组件，如steady_clock, duration和time_point进行计时</li>
<li>优先使用<clock>组件而不是<ctime>组件</li>
<li>用duration_cast获得已知单位的时间段</li>
<li>用system_clock::now()获得当前时间</li>
<li>可以在编译时查询类型的属性</li>
<li>仅当obj的值不再使用时使用move(obj)</li>
<li>用forward()进行转发。</li>
</ul>
<h2 id="第三十六章-字符串"><a href="#第三十六章-字符串" class="headerlink" title="第三十六章 字符串"></a>第三十六章 字符串</h2><h3 id="36-1-引言"><a href="#36-1-引言" class="headerlink" title="36.1 引言"></a>36.1 引言</h3><ul>
<li>在<cctype>中，标准库提供了字符分类操作，在<string>中提供了字符串相关操作，在<regex>中提供了正则表达式匹配组件，在<cstring>中提供了C风格字符串支持。</li>
<li>不同字符集的处理，编码和区域习惯将在第三十九章介绍</li>
</ul>
<h3 id="36-2-字符分类"><a href="#36-2-字符分类" class="headerlink" title="36.2 字符分类"></a>36.2 字符分类</h3><ul>
<li>标准库提供了一些分类函数，帮助用户操纵字符串(及其他字符序列)，还提供了一些指出字符类型属性的萃取，帮助实现字符串上的操作。</li>
</ul>
<h4 id="36-2-1-分类函数"><a href="#36-2-1-分类函数" class="headerlink" title="36.2.1 分类函数"></a>36.2.1 分类函数</h4><ul>
<li><p>在<cctype>中，标准库提供了从基本运行字符集中分类字符的函数</p>
<ul>
<li>isspace(c)</li>
<li>isalpha(c)</li>
<li>isdigit(c)</li>
<li>isxdigit(c)</li>
<li>isupper(c)</li>
<li>islower(c)</li>
<li>isalnum(c)</li>
<li>iscntrl(c)</li>
<li>ispunct(c)</li>
<li>isprint(c)</li>
<li>isgraph(c)</li>
</ul>
</li>
<li><p>此外，标准库提供了两种去除大小写区别的有用函数</p>
<ul>
<li>toupper(c)</li>
<li>tolower(c)</li>
</ul>
</li>
<li><p>这些字符分类函数很有用，原因之一是字符分类其实比看起来要麻烦很多。</p>
<ul>
<li>例如，一个初学者可能会这样编写代码： if (‘a’ &lt; ch &amp;&amp; ch &lt; ‘z’&gt;)  &#x2F;&#x2F; 一个小写字母</li>
<li>下面的写法更简洁，而且可能更高效： if (islower(ch))  &#x2F;&#x2F; 一个小写字母</li>
</ul>
</li>
<li><p>更重要的是，在编码空间中，字母并不保证是连续编码的，所以第一段代码可能会出错。</p>
</li>
</ul>
<h4 id="36-2-2-字符萃取"><a href="#36-2-2-字符萃取" class="headerlink" title="36.2.2 字符萃取"></a>36.2.2 字符萃取</h4><ul>
<li>一个字符类型的属性由其char_traits定义。一个char_traits是以下模板的特例化版本<ul>
<li>template<typename C> struct char_traits {};</li>
</ul>
</li>
<li>所有char_traits都定义在命名空间std中，头文件<string>中给出了标准char_traits。通用char_traits本身是没有属性的；只有特定字符类型的特例化char_traits才有属性</li>
</ul>
<h3 id="36-3-字符串"><a href="#36-3-字符串" class="headerlink" title="36.3 字符串"></a>36.3 字符串</h3><ul>
<li>在<string>中，标准库提供了通用字符串模板basic_string</li>
<li>元素(字符串)是连续存储的，这样底层输入操作可以安全的将basic_string的字符序列作为源或目的。</li>
<li>basic_string提供了强保证：若一个basic_string操作抛出了异常，则字符串保持不变。</li>
<li>与容器类似，basic_string的设计目的不是为了用作基类，而且它提供了移动语义，因此能高效地以传值方式由函数返回。</li>
</ul>
<h4 id="36-3-1-string和C风格字符串"><a href="#36-3-1-string和C风格字符串" class="headerlink" title="36.3.1 string和C风格字符串"></a>36.3.1 string和C风格字符串</h4><ul>
<li>C风格字符串与string的根本区别是，string是具有常规语义的真正类型，而C风格字符串则是一些有用的函数支撑的一组规范。</li>
</ul>
<h4 id="36-3-2-构造函数"><a href="#36-3-2-构造函数" class="headerlink" title="36.3.2 构造函数"></a>36.3.2 构造函数</h4><ul>
<li><p>basic_string提供了各式各样令人眼花缭乱的构造函数。</p>
</li>
<li><p>最常用也是最简单的</p>
<ul>
<li>string s0;</li>
<li>string s1 {“As simple as that”};</li>
<li>string s2 {s1};</li>
</ul>
</li>
<li><p>不要尝试用一个nullptr初始化一个string。最好情况下，你会得到一个糟糕的运行时错误，而最坏情况下，你会得到难以理解的未定义行为。</p>
</li>
<li><p>值string::npos表示一个超出string长度的位置，通常用来表示 string 尾</p>
</li>
</ul>
<h4 id="36-3-3-基本操作"><a href="#36-3-3-基本操作" class="headerlink" title="36.3.3 基本操作"></a>36.3.3 基本操作</h4><ul>
<li>basic_string提供了比较操作，大小和容量控制操作以及访问操作</li>
<li>用at()进行越界访问会抛出std::out_of_range。若+&#x3D;(), push_back()或+会令size()超过max_size()，则抛出std::length_error</li>
</ul>
<h4 id="36-3-4-字符串I-O"><a href="#36-3-4-字符串I-O" class="headerlink" title="36.3.4 字符串I&#x2F;O"></a>36.3.4 字符串I&#x2F;O</h4><ul>
<li>我们可以用 &lt;&lt; 输出basic_string，以及用 &gt;&gt; 读取输入保存到basic_string中。若输入操作会令size()超过max_size()，则抛出std::length_error</li>
<li>getline()会从输入流中删除结束符(默认为 ‘\n\ )，但不将其存入字符串中。这简化了对输入的逐行处理。</li>
</ul>
<h4 id="36-3-7-find系列函数"><a href="#36-3-7-find系列函数" class="headerlink" title="36.3.7 find系列函数"></a>36.3.7 find系列函数</h4><ul>
<li>标准库提供了各种各样令人眼花缭乱的子串查找操作。照例，find()从s.begin()开始向后搜索，rfind()从s.end()开始向前搜索。find()函数用string::npos(非位置)来表示 未找到</li>
<li>find_*_of()系列函数与find()和rfind()的不同指出在于它查找单个字符而非一个字符序列</li>
</ul>
<h3 id="36-4-建议"><a href="#36-4-建议" class="headerlink" title="36.4 建议"></a>36.4 建议</h3><ul>
<li>使用字符分类而非手工编写的代码检查字符范围</li>
<li>如果实现类字符串的抽象，使用character_traits实现字符上的操作</li>
<li>可用basic_string创建任意字符类型的字符串</li>
<li>将string用作变量和成员而非基类</li>
<li>优先选择string操作而非C风格字符串函数</li>
<li>以传值方式返回string(依赖移动语义)</li>
<li>将string::npos表示 string 剩余部分</li>
<li>不要将nullptr传递给接受C风格字符串的string函数</li>
<li>string可以按需增长和收缩</li>
<li>当需要进行范围检查时，使用at()而非迭代器或[]</li>
<li>当需要优化速度时，使用迭代器或[]而非at()</li>
<li>如果使用string，应在程序某些地方捕获length_error和out_of_range</li>
<li>仅在必要时，用c_str()生成string的C风格字符串表示</li>
<li>string输入是类型敏感的且不会溢出</li>
<li>优先选择string_stream或通用的值抽取函数而非直接使用str*系列数值转换函数</li>
<li>使用find()操作在string中定位元素(而不是自己编写循环)</li>
<li>直接或间接使用substr()读取字符串，用replace()写入子串</li>
</ul>
<h2 id="第三十八章-I-O流"><a href="#第三十八章-I-O流" class="headerlink" title="第三十八章 I&#x2F;O流"></a>第三十八章 I&#x2F;O流</h2><h3 id="38-1-引言"><a href="#38-1-引言" class="headerlink" title="38.1 引言"></a>38.1 引言</h3><ul>
<li>I&#x2F;O流库提供了文本和数值的输入输出功能，这种输入输出是带缓冲的，可以是格式化的，也可以是未格式化的。</li>
<li>I&#x2F;O流工具定义在<istream><ostream>等头文件中<ul>
<li>ostream将有类型的对象转换为字符流(字节流)</li>
<li>istream将字符流(字节流)转换为有类型的对象</li>
</ul>
</li>
</ul>
<h3 id="38-2-I-O流层次"><a href="#38-2-I-O流层次" class="headerlink" title="38.2 I&#x2F;O流层次"></a>38.2 I&#x2F;O流层次</h3><ul>
<li>关键的类是basic_ios，其中定义了大多数实现和很多操作。</li>
</ul>
<h4 id="38-2-1-文件流"><a href="#38-2-1-文件流" class="headerlink" title="38.2.1 文件流"></a>38.2.1 文件流</h4><ul>
<li>在<fstream>中，标准库提供了读写文件的流<ul>
<li>ifstream 用于从文件读取数据</li>
<li>ofstream 用于向文件写入数据</li>
<li>fstream 用于读写文件</li>
</ul>
</li>
</ul>
<h4 id="38-2-2-字符串流"><a href="#38-2-2-字符串流" class="headerlink" title="38.2.2 字符串流"></a>38.2.2 字符串流</h4><ul>
<li>在<sstream>中，标准库提供了读写string的流<ul>
<li>istringstream 用于从string读取数据</li>
<li>ostringstream 用于向string写入数据</li>
<li>stringstream 用于读写string</li>
</ul>
</li>
<li>字符串流不提供拷贝操作。如果你希望两个名字指向同一个字符串流，可使用引用或指针</li>
</ul>
<h3 id="38-3-错误处理"><a href="#38-3-错误处理" class="headerlink" title="38.3 错误处理"></a>38.3 错误处理</h3><ul>
<li>一个iostream在某个时刻会处于四种状态之一，这些状态的定义来自于<ios>的basic_ios中<ul>
<li>good() 前一个iostream操作成功</li>
<li>eof() 到达输入尾(文件尾)</li>
<li>fail() 发生了出乎意料的事情(例如，读取数据却得到一个‘x’)</li>
<li>bad() 发生了处于医疗的严重事情(例如，磁盘读错误)</li>
</ul>
</li>
<li>如果一个流不在good()状态，对它的任何操作都没有效果，即相当于空操作。</li>
</ul>
<h3 id="38-7-建议"><a href="#38-7-建议" class="headerlink" title="38.7 建议"></a>38.7 建议</h3><ul>
<li>若用户自定义类型的值存在有意义的文本表示，可为其定义 &lt;&lt; 和 &gt;&gt;</li>
<li>用cout进行正常输入，用cerr输出错误</li>
<li>标准库提供了普通字符和宽字符的iostream，你可以为任意类型的字符定义iostream</li>
<li>标准库为标准I&#x2F;O流，文件和string定义了标准iostream</li>
<li>不要尝试拷贝一个文件流</li>
<li>二进制I&#x2F;O依赖于系统</li>
<li>在使用文件流之前记得检查它是否已关联到文件</li>
<li>优先选择ifstream和ofstream，而非通用的fstream</li>
<li>用stringfstream进行内存中的格式化</li>
<li>用异常机制捕获稀少的bad() I&#x2F;O错误</li>
<li>用流状态fail处理潜在的可恢复的I&#x2F;O错误</li>
<li>为了定义新的 &lt;&lt; 和 &gt;&gt; 你无需修改istream或ostream</li>
<li>当实现iostream原语操作时，使用sentry</li>
<li>优先选择格式化输入而非未格式化的，底层的输入</li>
<li>读取输入存入string不会导致溢出</li>
<li>当使用get(), getline() 和 read() 时，要小心结束标准</li>
<li><blockquote>
<blockquote>
<p>默认忽略空白符</p>
</blockquote>
</blockquote>
</li>
<li>优先选择操纵夫而非状态标志来控制I&#x2F;O</li>
<li>如果你希望混合C风格I&#x2F;O和iostream-I&#x2F;O，使用sync_with_stdio(true)</li>
<li>使用sync_with_stdio(false)优化iostream</li>
<li>连接流来实现交互式I&#x2F;O</li>
<li>用imbue()来令iostream反应locale的文化差异</li>
<li>width()说明只应用于紧接着的下一个I&#x2F;O操作</li>
<li>precision()说明应用于后续所有浮点输出操作</li>
<li>浮点格式说明(例如scientific)应用于后续所有浮点输出操作</li>
<li>为使用接受参数的标准操纵符，要 #include <iomanip></li>
<li>你几乎不会需要flush()</li>
<li>除非可能有审美趣味上的原因，否则不要使用 endl</li>
<li>如果iostream格式化变得令人厌烦，编写你自己的操纵符</li>
<li>通过定义一个简单的函数对象，你可以实现三元运算符的效果(和效率)</li>
</ul>
<h2 id="第四十章-数值计算"><a href="#第四十章-数值计算" class="headerlink" title="第四十章 数值计算"></a>第四十章 数值计算</h2><h3 id="40-1-引言"><a href="#40-1-引言" class="headerlink" title="40.1 引言"></a>40.1 引言</h3><ul>
<li>当复杂数据结构是计算过程中的必要部分时，C++的优势就变得很重要了。C++因而被广泛用于科学计算，工程计算，金融计算以及其他包含复杂数值计算的任务，这催生了这类计算的语言特性和技术。</li>
<li>本章介绍标准库中支持数值计算的部分。我不打算讲授数值方法。数值计算本身就是一个吸引人的话题。学习数值计算需要一门好的数值方法课程或者至少有一本好的教材—而不是仅靠一本编程语言手册和导引就能完成的。</li>
</ul>
<h3 id="40-2-数值限制"><a href="#40-2-数值限制" class="headerlink" title="40.2 数值限制"></a>40.2 数值限制</h3><ul>
<li>为了处理数值相关的有趣事情，我们通常需要了解一些内置数值类型的一般特性的知识。为了让程序员能最充分的利用硬件，这些特性都是依赖于具体C++实现，而不是由语言本身规定的。</li>
<li>例如<ul>
<li>最大的int有多大？</li>
<li>最小的正float是什么？</li>
<li>将一个double赋予一个float时，是舍入还是截断？</li>
<li>一个char有多少位？</li>
</ul>
</li>
<li>这类问题的答案由 numeric_limits 的特例化版本提供，它定义在 <limits>中</li>
<li>每个特例化版本提供其实参类型的相关信息。因此，通用numberic_limits模板就是一组常量和constexpr函数的标志句柄。真正的信息保存在特例化版本中。</li>
</ul>
<h4 id="40-2-1-数值标量限制C风格宏"><a href="#40-2-1-数值标量限制C风格宏" class="headerlink" title="40.2.1 数值标量限制C风格宏"></a>40.2.1 数值标量限制C风格宏</h4><ul>
<li>C++ 从C继承了描述整数属性的宏，它们定义在 <climits>中</li>
</ul>
<h3 id="40-3-标准数学函数"><a href="#40-3-标准数学函数" class="headerlink" title="40.3 标准数学函数"></a>40.3 标准数学函数</h3><ul>
<li>在<cmath>中我们可以找到通常被称为标准数学函数(Standard Mathematical Function)的组件</li>
</ul>
<h3 id="40-7-随机数发生器"><a href="#40-7-随机数发生器" class="headerlink" title="40.7 随机数发生器"></a>40.7 随机数发生器</h3><ul>
<li><p>在<random>中，标准库定义了生成(伪)随机数的特性。这种随机数是按照数学公式生成的值的序列，而不是无法猜测(真随机)的数，后者可以从物理过程中获得，例如放射性衰变或太阳辐射。</p>
</li>
<li><p>标准库提供了四种随机数相关的实体</p>
<ul>
<li>均匀随机数发生器(uniform random number generator)是一个返回无符号整数值的函数对象，值域中每个可能值(理想情况下)被返回的概率相等</li>
<li>随机数引擎(random number engine, 简称引擎)是一个均匀随机数发生器，可用默认状态创建，或者用一个seed确定的状态创建</li>
<li>随机数引擎适配器(random number engine adaptor, 简称适配器)是一个随机数引擎，它接受某个其他随机数引擎生成的值，并应用算法将这些值转换为另一个具有不同随机特性的值的序列。</li>
<li>随机数分布(random number distribution, 简称分布)是一个函数对象，其返回值的分布服从一个关联的数学概率密度函数或一个关联的离散概率函数</li>
</ul>
</li>
<li><p>符合用户习惯的更简单的描述是，一个随机数发生器就是一个引擎加一个分布。引擎生成一个均匀分布的值的序列，分布再将这些值转换为要求的形状(分布)。即，如果你从随机数发生器接受了大量数值并绘制它们，就会得到一个描述它们分布的相当平滑的图形。</p>
</li>
<li><p>大多数请款下，大多数程序员只需要一个给定范围内假肚腩的均匀分布整数序列或浮点数序列。</p>
</li>
</ul>
<h4 id="40-7-4-C风格随机数"><a href="#40-7-4-C风格随机数" class="headerlink" title="40.7.4 C风格随机数"></a>40.7.4 C风格随机数</h4><ul>
<li><p>在<cstdlib>和&lt;stdlib.h&gt;中，标准库提供了一些简单的特性来生成随机数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RAND_MAX implementation_defined <span class="comment">/*最大可能整数*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rand</span><span class="params">()</span></span>;   <span class="comment">// 0和RAND_MAX间的伪随机数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> i)</span></span>;  <span class="comment">// 将随机数发生器的种子设置为i</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用srand(s)用种子(seed)s(作为参数提供)爱是一个新的随机数序列。为了方便调试，一个给定种子生成固定的序列通常很重要。但是，我们通常希望用一个新种子开始程序的每次运行。</p>
</li>
</ul>
<h2 id="第四十一章-并发"><a href="#第四十一章-并发" class="headerlink" title="第四十一章 并发"></a>第四十一章 并发</h2><h3 id="41-1-引言"><a href="#41-1-引言" class="headerlink" title="41.1 引言"></a>41.1 引言</h3><ul>
<li><p>并发，即多个任务同时执行，广泛用于提高吞吐率(使用多个处理器完成单个运算)或提高响应能力(当程序的一部分等待响应时允许另一部分继续执行)</p>
</li>
<li><p>如果一项活动可能与其他活动并发执行，我们就称之为任务(task)。线程(thread)是执行任务的计算机特性在系统层面的表示。一个标准库thread可执行一个任务。一个线程可与其他线程共享地址空间。即，在单一地址空间中的所有线程能访问相同的内存位置。而并发系统程序员所面临的重要挑战之一就是，确保多线程并发访问内存的方式是合理的。</p>
</li>
<li><p>标准库对并发的支持包括</p>
<ul>
<li>内存模型(memory model): 这是对内存并发访问的一组保证，主要是确保简单的普通访问能按人们的朴素的预期工作</li>
<li>对无锁编程(programming without locks)的支持: 这是一些避免数据竞争的细粒度底层机制</li>
<li>一个线程(thread)库: 这是一组支持传统线程–锁风格的系统级并发编程的组件，例如thread, condition_variable, mutex</li>
<li>一个任务(task)支持库: 这是一些支持任务级并发编程的特性: future, promise, packaged_task, async()</li>
</ul>
</li>
<li><p>这些主题是按照从最基础，最底层到最高层的顺序排列的。内存模型是所有编程风格所共用的。为提高程序员开发效率，尽量减少错误，应在尽可能高的层次上编程。例如，应该优先选择future而不是mutex实现信息交换；除非是简单的计数器，否则应该优选mutex而不是atomic；诸如此类，尽量将复杂任务留给标准库实现者。</p>
</li>
<li><p>在C++标准库的语境中，一个锁(lock)就是一个mutex(互斥量)以及任何构建于mutex之上的抽象，用来提供对资源的互斥访问或同步多个并发任务的进度。</p>
</li>
<li><p>进程(process)即运行于独立地址空间，通过进程间通信机制进行交互的线程，并不在本书介绍范围之内。</p>
</li>
<li><p>类似的，我们可以以函数对象(例如lambda)的形式定义任务并将它们传递给线程，而无需进行类型转换或担心类型违规。</p>
</li>
</ul>
<h3 id="41-2-内存模型"><a href="#41-2-内存模型" class="headerlink" title="41.2 内存模型"></a>41.2 内存模型</h3><ul>
<li>C++实现大多标准库组件的形式提供对并发机制的支持。这些组件依赖于一组称为内存模型(memory model)的语言保证。内存模型是计算机设计师和编译器实现者之间关于计算机硬件最佳表示方式的讨论结果。</li>
<li>为了理解所涉及的问题，请记住一个简单事实：对内存中对象的操作永远不直接处理内存中的对象，而是将对象加载到处理器的寄存器中，在哪里修改，然后再写回内存。更糟糕的是，对象通常首先从主存加载到缓存中，然后再加载到寄存器。</li>
</ul>
<h4 id="41-2-1-内存位置"><a href="#41-2-1-内存位置" class="headerlink" title="41.2.1 内存位置"></a>41.2.1 内存位置</h4><ul>
<li>C++内存模型保证两个更新和访问不同内存位置的线程可以互不影响的执行。这恰是我们的朴素期望。防止我们遇到现代硬件有时很奇怪和微妙的行为是编译器的任务。编译器和硬件如何写作来实现这一目的应该由编译器负责。我们编程所用的机器实际上是由硬件和非常底层的(由编译器生成的)软件组合提供的。</li>
</ul>
<h4 id="41-2-2-指令重排"><a href="#41-2-2-指令重排" class="headerlink" title="41.2.2 指令重排"></a>41.2.2 指令重排</h4><ul>
<li>为提高性能，编译器，优化器以及硬件都可能重排指令顺序。</li>
</ul>
<h4 id="41-2-3-内存序"><a href="#41-2-3-内存序" class="headerlink" title="41.2.3 内存序"></a>41.2.3 内存序</h4><ul>
<li>术语内存序(memory ordering)用来描述一个线程从内存访问一个值时会看到什么。最简单的内存序称为顺序一致性(sequentially consistent)。再一个顺序一致性内存模型中，每个线程看到的是相同的操作执行效果，此顺序就像是所有指令都在单一线程中顺序执行一样。</li>
<li>线程仍可重排指令，但对其他线程可以观察变量的每个时间点，时间点前执行的指令集合(因而)和观察家到的内存位置的值必须是明确定义的且对所有线程都一致。</li>
<li>观察值从而强制内存位置的一个一致性视图的操作被称为原子操作(atomic operation)</li>
</ul>
<h3 id="41-3-原子性"><a href="#41-3-原子性" class="headerlink" title="41.3 原子性"></a>41.3 原子性</h3><ul>
<li>所谓无锁编程，就是一组来编写不显示使用锁的并发程序的技术。程序员转而依靠原语操作(由硬件直接支持)来避免小对象(通常是单一字或双字)的数据竞争。不必忍受数据竞争的原语操作通常被称为原子操作(atomic operation)，可用来实现高层并发机制，例如锁，线程和无锁数据结构。</li>
<li>除了简单的原子计数器这一明显例外，无锁编程通常很复杂，最好留给专家使用</li>
</ul>
<h4 id="41-3-1-atomic类型"><a href="#41-3-1-atomic类型" class="headerlink" title="41.3.1 atomic类型"></a>41.3.1 atomic类型</h4><ul>
<li>原子类型(atomic type)是atomic模板的特例化版本。原子类型的对象上的操作是原子的(atomic)。即，操作由单一线程执行，不会受到其它线程干扰</li>
</ul>
<h4 id="41-3-2-标志和栅栏"><a href="#41-3-2-标志和栅栏" class="headerlink" title="41.3.2 标志和栅栏"></a>41.3.2 标志和栅栏</h4><ul>
<li>除了支持原子类型之外，标准库还提供了两种更底层的同步特性： 原子标志和栅栏。它们的主要用途是实现最底层的原子特性，例如自旋锁和原子类型。这两个特性是仅有的每个C++实现都保证支持的无锁机制。</li>
<li>基本上没有程序员需要使用标志或栅栏。其使用者通常是和硬件设计师紧密合作的人。</li>
</ul>
<h3 id="41-4-volatile"><a href="#41-4-volatile" class="headerlink" title="41.4 volatile"></a>41.4 volatile</h3><ul>
<li>说明符volatile用来指出一个对象可被线程控制范围之外的东西修改</li>
<li>volatile说明符主要是告知编译器不要优化掉明显冗余的读写操作</li>
<li>除非是直接处理硬件的底层代码中，否则不要使用volatile</li>
<li>不要假定volatile在内存模型中有特殊含义，它确使没有。与某些新语言不同，在C++中volatile并非一种同步机制。为了进行同步，应该使用atomic，mutex或condition_variable</li>
</ul>
<h3 id="41-5"><a href="#41-5" class="headerlink" title="41.5"></a>41.5</h3><ul>
<li>用并发提高响应能力或吞吐率</li>
<li>只要代价可接受，应在尽可能高的抽象层次上编程</li>
<li>优先选择packaged_task和future，而不是直接使用thread和mutex</li>
<li>除非是实现简单计数器，否则优先选择mutex和condition_variable，而不是直接使用atomic</li>
<li>尽量避免显式共享数据</li>
<li>将进程视为线程的代替</li>
<li>标准库并发特性是类型安全的</li>
<li>内存模型是为了省去程序员从机器体系结构思考计算机的麻烦</li>
<li>内存模型令内存行为大致如我们的朴素预取</li>
<li>不同线程访问一个struct的不同位域可能互相干扰</li>
<li>避免数据竞争</li>
<li>原子类型和操作可实现无锁编程</li>
<li>无锁编程对避免死锁和确保每个线程持续前进是很重要的</li>
<li>将无锁编程留给专家</li>
<li>将放松内存模型留给专家</li>
<li>volatile告知编译器一个对象的值可以被程序之外的东西改变</li>
<li>C++的volatile不是一种同步机制</li>
</ul>
<h2 id="第四十二章-线程和任务"><a href="#第四十二章-线程和任务" class="headerlink" title="第四十二章 线程和任务"></a>第四十二章 线程和任务</h2><h3 id="42-1-引言"><a href="#42-1-引言" class="headerlink" title="42.1 引言"></a>42.1 引言</h3><h3 id="42-2-线程"><a href="#42-2-线程" class="headerlink" title="42.2 线程"></a>42.2 线程</h3><ul>
<li><p>thread是计算的概念在计算机硬件层面的抽象。C++标准库thread的设计目标是与操作系统线程形成一对一映射。</p>
</li>
<li><p>所有thread工作于同一个地址空间中。如果你希望硬件能防止数据竞争，则应该使用进程。thread间不共享栈，因此局部变量不会产生数据竞争问题，除非你不小心将一个局部变量的指针传递给其他thread。</p>
</li>
<li><p>如果一个thread不能继续前进(例如遇到了一个其他thread所拥有的mutex)，我们称它处于阻塞(blocked)或睡眠(asleep)状态</p>
</li>
<li><p>一个thread表示一个系统资源，一个系统线程，甚至可能有专用硬件，因此thread可以移动但是不能拷贝。</p>
</li>
</ul>
<h4 id="42-2-1-身份"><a href="#42-2-1-身份" class="headerlink" title="42.2.1 身份"></a>42.2.1 身份</h4><ul>
<li>每个执行线程都有唯一标识符，用thread::id类型的值表示。如果一个thread不表示一个执行线程，则其id为默认的id{}。一个thread的id可以通过调用get_id()获得。</li>
</ul>
<h4 id="42-2-2-构造"><a href="#42-2-2-构造" class="headerlink" title="42.2.2 构造"></a>42.2.2 构造</h4><ul>
<li><p>thread的构造函数接受一个要执行的任务，以及该任务要求的参数。参数的数量和类型必须与任务所要求的参数列表匹配。</p>
</li>
<li><p>thread构造完毕之后，一旦运行时系统能获取它运行所需的资源，它就开始执行任务。你可以认为这个过程是 立即的。并不存在单独的启动thread操作。</p>
</li>
<li><p>如果你希望构建一组任务，将它们链接在一起，你应该将任务构造为函数对象，然后，在他们就绪之后启动thread</p>
</li>
<li><p>将任务从一个thread移动到另一个thread并不影响其执行，thread的移动只是改变thread指向的是什么。</p>
</li>
</ul>
<h4 id="42-2-3-析构"><a href="#42-2-3-析构" class="headerlink" title="42.2.3 析构"></a>42.2.3 析构</h4><ul>
<li>显然，thread的析构函数销毁thread对象。为了防止发生系统线程的生命期长于其thread的意外情况，thread析构函数调用terminate()结束程序(若thread是joinable()的，即get_id() !&#x3D; id())</li>
</ul>
<h4 id="42-2-4-join"><a href="#42-2-4-join" class="headerlink" title="42.2.4 join()"></a>42.2.4 join()</h4><ul>
<li>t.join() 告诉当前thread在t结束之前不要继续前进</li>
</ul>
<h4 id="42-2-5-detach"><a href="#42-2-5-detach" class="headerlink" title="42.2.5 detach()"></a>42.2.5 detach()</h4><ul>
<li><p>注意，thread提供了移动赋值操作和移动构造函数。这令thread可以迁移出它创建时所在的作用域，从而常常可作为detach()的替代方案。我们可以将thread迁移到程序的主模块，通过unique_ptr或shared_ptr访问它们，或者将它们放置于一个容器中(例如vector<thread>),免得失去与它们的联系。</p>
</li>
<li><p>如果你必须detach()一个thread，请确保它没有引用其作用域中的变量</p>
</li>
<li><p>我们必须使用detach()才能让一个thread离开其作用域；除非有非常好的理由，否则不要这么做，即使需要使用detach()，也应首先仔细思考thread的任务可能做什么，然后再使用。</p>
</li>
</ul>
<h4 id="42-2-6-名字空间this-thread"><a href="#42-2-6-名字空间this-thread" class="headerlink" title="42.2.6 名字空间this_thread"></a>42.2.6 名字空间this_thread</h4><ul>
<li>对当前thread的操作定义再名字空间this_thread中<ul>
<li>x &#x3D; get_id()  x为当前thread的id；不抛出异常</li>
<li>yield() 给调度器机会运行另一个thread；不抛出异常</li>
<li>sleep_until(tp) 令当前thread进行睡眠状态，直到time_point tp</li>
<li>sleep_for(d)  令当前thread进行睡眠状态，持续duration d</li>
</ul>
</li>
<li>在所有主要C++实现中thread都是可抢占的；即，C++实现可以从一个任务切换到另一个任务，以确保所有thread都以一个合理的速度前进。</li>
</ul>
<h4 id="42-2-7-杀死thread"><a href="#42-2-7-杀死thread" class="headerlink" title="42.2.7 杀死thread"></a>42.2.7 杀死thread</h4><ul>
<li>thread漏掉了一个重要操作，没有一种简单的标准方法告知一个正在运行的thread对其任务已经失去了兴趣，因此请它停止运行并释放所有资源。此操作(在不同语言和系统中被称为杀死，取消和终止)的缺席有各种历史原因和技术原因。</li>
<li>如需要，应用程序员可以编写自己的杀线程操作。例如，很多任务包含一个请求循环。在此情况下，发送一条请自杀消息给一个thread即可令其释放所有资源并结束。如果没有请求循环，线程可以周期性的检查一个需要变量来判断用户是否还需要本线程的结果。</li>
</ul>
<h4 id="42-2-8-thread-local-数据"><a href="#42-2-8-thread-local-数据" class="headerlink" title="42.2.8 thread_local 数据"></a>42.2.8 thread_local 数据</h4><ul>
<li><p>如其名，一个thread_local变量是一个thread专有的对象，其他thread不能访问，除非其拥有者将指向它的指针提供给了其他线程。</p>
</li>
<li><p>我们说一个thread_local具有线程存储存续时间(thread storage duration)。每个thread对thread_local变量都有自己的拷贝。thread_local在首次使用前初始化。如果已构造，会在thread退出时销毁。</p>
</li>
<li><p>thread_local存储的一个重要用途是供thread显示缓存互斥访问数据。</p>
</li>
<li><p>一般而言，非局部内存是并发编程的一个难题，因为确定数据是否共享通常不那么简单，因而可能成为数据竞争之源</p>
</li>
<li><p>名字空间变量，局部static和类static成员都可以声明为thread_local。</p>
</li>
</ul>
<h3 id="42-3-避免数据竞争"><a href="#42-3-避免数据竞争" class="headerlink" title="42.3 避免数据竞争"></a>42.3 避免数据竞争</h3><ul>
<li>避免数据竞争的最好方法是不共享数据。将感兴趣的数据保存在局部变量中，保存在不与其他线程共享的自由存储中，或是保持在thread_local内存中。不要将这类数据的指针传递给其他thread。当另一个thread需要处理这类数据时(例如并行排序)，传递数据特定片段的指针并确保在任务结束之前不触碰此数据片段。</li>
<li>这些简单规则背后的思想是避免并发数据访问，因此程序不需要锁机制且能达到最高效率。在不能应用这些规则的场合，例如有大量数据需要共享的场合，可使用某种形式的锁机制<ul>
<li>互斥量(mutex)：互斥量就是一个用来表示某个资源互斥访问权限的对象。为访问资源，先获取互斥量，然后访问数据，最后释放互斥量</li>
<li>条件变量(condition variable): 一个thread用条件变量等待另一个thread或计时器生成的事件。</li>
</ul>
</li>
<li>严格来说，条件变量不能防止数据竞争，而是帮我们避免引入可能引起数据竞争的共享数据。</li>
</ul>
<h4 id="42-3-1-互斥量"><a href="#42-3-1-互斥量" class="headerlink" title="42.3.1 互斥量"></a>42.3.1 互斥量</h4><ul>
<li>mutex对象用来表示资源的互斥访问。因此，它可用来防止数据竞争以及同步多个thread对共享数据的访问。</li>
</ul>
<h4 id="42-3-2-多重锁"><a href="#42-3-2-多重锁" class="headerlink" title="42.3.2 多重锁"></a>42.3.2 多重锁</h4><ul>
<li>为执行某个任务获取多个资源的需求非常常见。不幸的是，获取两个锁就可能产生死锁。</li>
</ul>
<h4 id="42-3-3-call-once"><a href="#42-3-3-call-once" class="headerlink" title="42.3.3 call_once()"></a>42.3.3 call_once()</h4><ul>
<li>我们通常希望初始化对象时不会产生数据竞争。谓词，类型once_flag和函数call_once()提供了一种高效且简单的底层工具。</li>
<li>可以将call_once()理解为这样一种方法，它简单的修改并发前代码，这些代码依赖于已初始化的static数据。</li>
</ul>
<h4 id="42-3-4-条件变量"><a href="#42-3-4-条件变量" class="headerlink" title="42.3.4 条件变量"></a>42.3.4 条件变量</h4><ul>
<li>我们用条件变量管理thread间的通信。一个thread可等待(阻塞)在一个condition_variable上，直至发生某个事件，例如到达一个特定时刻或者另一个thread完成。</li>
</ul>
<h3 id="42-4-基于任务的并发"><a href="#42-4-基于任务的并发" class="headerlink" title="42.4 基于任务的并发"></a>42.4 基于任务的并发</h3><ul>
<li>本节介绍如何指定一种简单的任务：一种根据给定参数完成一项工作，生成一个结果的任务</li>
</ul>
<h4 id="42-4-1-future和promise"><a href="#42-4-1-future和promise" class="headerlink" title="42.4.1 future和promise"></a>42.4.1 future和promise</h4><ul>
<li>任务间的通信由一对future和promise处理。任务将其结果放入一个promise，需要此结果的任务则从对应的future提取结果。</li>
</ul>
<h4 id="42-4-2-promise"><a href="#42-4-2-promise" class="headerlink" title="42.4.2 promise"></a>42.4.2 promise</h4><ul>
<li>一个promise就是一个共享状态的句柄。它是一个任务可用来存放其结果的地方，供其他任务通过future提取。</li>
</ul>
<h4 id="42-4-3-packaged-task"><a href="#42-4-3-packaged-task" class="headerlink" title="42.4.3 packaged_task"></a>42.4.3 packaged_task</h4><ul>
<li>packaged_task保存了一个任务和一个future&#x2F;promise对</li>
</ul>
<h4 id="42-4-4-future"><a href="#42-4-4-future" class="headerlink" title="42.4.4 future"></a>42.4.4 future</h4><ul>
<li>future就是共享状态的句柄，它是任务提取由promise存放的结果的地方</li>
</ul>
<h4 id="42-4-5-shared-future"><a href="#42-4-5-shared-future" class="headerlink" title="42.4.5 shared_future"></a>42.4.5 shared_future</h4><ul>
<li>future的结果值只能被读一次，因为读取时它就被移动了。因此，如果你希望反复读取结果值，或是可能有多个读者读取结果，就必须拷贝它，然后读取副本。这正是shared_future所做的。每个可用的shared_future都是通过直接或间接的从具有相同结果类型的future中移出值来进行初始化的。</li>
</ul>
<h3 id="42-5-建议"><a href="#42-5-建议" class="headerlink" title="42.5 建议"></a>42.5 建议</h3><ul>
<li>thread是系统线程的类型安全的接口</li>
<li>不要销毁正在运行的thread</li>
<li>用join()等待thread结束</li>
<li>除非不得已，否则不要detach()一个thread</li>
<li>用lock_guard或unique_lock管理互斥量</li>
<li>用lock()获取多重锁</li>
<li>用condition_variable管理thread间通信</li>
<li>从并发执行任务的角度思考，而非直接从thread角度思考</li>
<li>重视间接性</li>
<li>用promise返回结果，从future获取结果</li>
<li>不要对一个promise两次执行set_value(), set_exception()</li>
<li>用packaged_task管理任务抛出的异常以及安排返回值</li>
<li>用packaged_task和future表达对外部服务的请求以及等待其应用</li>
<li>不要从一个future两次使用get()</li>
<li>用async()启动简单任务</li>
<li>选择好的并发粒度很困难：依赖实验和测量做出选择</li>
<li>尽量将并发隐藏在并行算法接口之后</li>
<li>并行算法在语义上可能与解决统一问题的穿行解决方案不同</li>
<li>有时，穿行解决方案比并行版本简单且快速。</li>
</ul>
<h2 id="第四十三章-C标准库"><a href="#第四十三章-C标准库" class="headerlink" title="第四十三章 C标准库"></a>第四十三章 C标准库</h2><h3 id="43-1-引言"><a href="#43-1-引言" class="headerlink" title="43.1 引言"></a>43.1 引言</h3><ul>
<li>C标准库经过很小改动后已被纳入C++标准库中。</li>
</ul>
<h3 id="43-2-文件"><a href="#43-2-文件" class="headerlink" title="43.2 文件"></a>43.2 文件</h3><ul>
<li>C I&#x2F;O系统是基于文件的。一个文件(FILE *)可以指向一个外存文件或一个标准输入输出流: stdin, stdout, stderr</li>
</ul>
<h3 id="43-3-printf-系列函数"><a href="#43-3-printf-系列函数" class="headerlink" title="43.3 printf()系列函数"></a>43.3 printf()系列函数</h3><ul>
<li>最流行的C标准库函数是输出函数。但是，我倾向于使用iostream库，因为它是类型安全且可扩展的。</li>
</ul>
<h3 id="43-4-C风格字符串"><a href="#43-4-C风格字符串" class="headerlink" title="43.4 C风格字符串"></a>43.4 C风格字符串</h3><ul>
<li>一个C风格字符串就是一个零结尾的char数组。定义于<cstring>和<cstdlib>中的一组函数提供了对这种字符串表示方法的支持。</li>
</ul>
<h3 id="43-5-内存"><a href="#43-5-内存" class="headerlink" title="43.5 内存"></a>43.5 内存</h3><ul>
<li>操纵内存的函数通过void*指针(const void *用于只读内存)对裸内存(类型未知)进行操作。</li>
<li>注意，malloc()等函数并不调用构造函数，free()也不会调用析构函数。不要对具有构造函数和析构函数的类型使用这些函数。而且memset()也不应该用于具有构造函数的任何类型。</li>
</ul>
<h3 id="43-6-日期和时间"><a href="#43-6-日期和时间" class="headerlink" title="43.6 日期和时间"></a>43.6 日期和时间</h3><ul>
<li>在<ctime>中，可以找到一些日期和时间相关的类型和函数</li>
</ul>
<h3 id="43-8-建议"><a href="#43-8-建议" class="headerlink" title="43.8 建议"></a>43.8 建议</h3><ul>
<li>如果担心资源泄露，使用fstream而不是fopen()&#x2F;fclose()</li>
<li>处于类型安全和扩展性的考虑，优先选择<iostream>而不是<stdlib></li>
<li>据对不要使用gets()或者scanf(“%s”, s)</li>
<li>处于资源管理易用性和简单性考虑，使用<string>而不是<cstring></li>
<li>只对裸内存使用C内存管理例程，如memcpy()</li>
<li>优先选择vector而不是malloc()和realloc()</li>
<li>C标准库不了解构造函数和析构函数</li>
<li>优先选择<chrono>而不是<ctime>进行计时</li>
<li>考虑到灵活性，易用性和性能，优先选择sort()而不是qsort()</li>
<li>不要使用exit()，应该选择抛出异常</li>
<li>不要使用longjmp()，应该选择抛出异常</li>
</ul>
<h2 id="第四十四章-兼容性"><a href="#第四十四章-兼容性" class="headerlink" title="第四十四章 兼容性"></a>第四十四章 兼容性</h2><h3 id="44-1-引言"><a href="#44-1-引言" class="headerlink" title="44.1 引言"></a>44.1 引言</h3><ul>
<li>本章的目的是<ul>
<li>给出C++11新特性的简明列表</li>
<li>介绍会给程序员的带来难题的差异</li>
<li>指出解决问题的方法</li>
</ul>
</li>
</ul>
<h3 id="44-2-C-11扩展"><a href="#44-2-C-11扩展" class="headerlink" title="44.2 C++11扩展"></a>44.2 C++11扩展</h3><h4 id="44-2-1-语言特性"><a href="#44-2-1-语言特性" class="headerlink" title="44.2.1 语言特性"></a>44.2.1 语言特性</h4><ul>
<li>研究语言特性列表着实让人眼花缭乱。但要记住，语言特性并不是孤立使用的。特别是，大多数C++11新特性如果脱离了其他特性构成的框架就毫无意义。</li>
<li>下面特性列表的顺序大致就是在本书中第一次出现的顺序<ul>
<li>使用{}列表进行一致且通用的初始化</li>
<li>从初始化器进行类型推断：auto</li>
<li>避免窄化转换</li>
<li>推广的且有保证的常量表达式：constexpr</li>
<li>范围for语句</li>
<li>空指针关键字: nullptr</li>
<li>限域且强类型的枚举：enum class</li>
<li>编译时断言：static_assert</li>
<li>{}列表到std::initializer_list的语言映射</li>
<li>右值引用，允许移动语义</li>
<li>以&gt;&gt;结束的嵌套模板参数</li>
<li>lambda</li>
<li>可变参数模板</li>
<li>类型和模板别名</li>
<li>Unicode字符</li>
<li>long long整数类型</li>
<li>对齐控制: alignas, alignof</li>
<li>在声明中将表达式的类型用作类型的能力：decltype</li>
<li>裸字符串字面值常量</li>
<li>推广的POD</li>
<li>推广的union</li>
<li>局部类作为模板实参</li>
<li>尾置语法和两种标准属性: [[carries_dependency]]和[[noreturn]]</li>
<li>阻止异常传播: noexcept说明符</li>
<li>检测表达式抛出异常的可能性：noexcept运算符</li>
<li>inline名字空间</li>
<li>委托构造函数</li>
<li>类内成员初始化器</li>
<li>默认控制：defult和delete</li>
<li>显式转换运算符</li>
<li>用户自定义字面值常量</li>
<li>template实例化更为显式的控制：extern template</li>
<li>函数模板的默认模板实参</li>
<li>继承构造函数</li>
<li>覆盖控制：override和final</li>
<li>更简单，更通用的SFINAE规则</li>
<li>内存模型</li>
<li>线程局部存储：thread_local</li>
</ul>
</li>
</ul>
<h4 id="44-2-2-标准库组件"><a href="#44-2-2-标准库组件" class="headerlink" title="44.2.2 标准库组件"></a>44.2.2 标准库组件</h4><h3 id="44-4-建议"><a href="#44-4-建议" class="headerlink" title="44.4 建议"></a>44.4 建议</h3><ul>
<li>在使用新特性编写产品级代码前，应先尝试编写小规模程序来测试它是否符合标准以及你所使用的C++实现是否满足性能要求</li>
<li>学习C++时应使用你能获得的最新的，最完整的标准C++实现</li>
<li>C和C++的公共子集不是学习C++的最佳起点</li>
<li>优先选择标准特性而不是非标准特性</li>
<li>避免使用throw说明这样的启用特性</li>
<li>避免使用C风格类型转换</li>
<li>隐式int已被弃用，因此应显式说明每个函数，变量，const等的类型</li>
<li>在将C程序转换为C++程序时，首先确保一致使用函数声明(原型)和标准头文件</li>
<li>在将C程序转换为C++程序时，需将与C++关键字同名的变量改名</li>
<li>处于可以执行和类型安全的考虑，如果必须使用C，应该用C和C++的公共子集编写代码</li>
<li>在将C程序转换为C++程序时，应将malloc()的返回结果转换为正确类型或改用new</li>
<li>当从malloc()和free()转换为new 和delete时，考虑使用vector,push_back()和reserve()而不是realloc()</li>
<li>在将C程序转换为C++程序时，记住C++中没有从int到枚举类型的隐式类型转换，如果需要，应该使用显式类型转换</li>
<li>名字空间std中定义的特性都是定义于一个文件名无后缀的头文件中</li>
<li>包含<string>以便使用std::string</li>
<li>每个标准C头文件&lt;X.h&gt;都将名字置于全局名字空间中，对应的C++头文件<cX>将名字置于名字空间std中</li>
<li>声明C函数时使用extern “C”</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/09/05/notebook/Qt/2024-09-05-qt_3_%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/05/notebook/Qt/2024-09-05-qt_3_%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">qt_3_常见类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-09-05 09:00:00" itemprop="dateCreated datePublished" datetime="2024-09-05T09:00:00+08:00">2024-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Qt 中常见的数据类型及其笔记</li>
</ul>
<h2 id="Qt-QAtomicInt类型-详解"><a href="#Qt-QAtomicInt类型-详解" class="headerlink" title="Qt QAtomicInt类型 详解"></a>Qt QAtomicInt类型 详解</h2><p><code>QAtomicInt</code> 是 Qt 中提供的一种用于原子操作的整数类型。原子操作指的是在多线程环境中执行的操作，它们在 CPU 层级上是不可分割的，确保操作在执行时不会被中断，从而避免线程竞争问题。</p>
<h3 id="QAtomicInt-概述"><a href="#QAtomicInt-概述" class="headerlink" title="QAtomicInt 概述"></a><code>QAtomicInt</code> 概述</h3><p><code>QAtomicInt</code> 是一个提供了基本整型（<code>int</code>）的原子操作封装的类。它通常用于实现线程安全的计数器或其他需要原子性递增、递减操作的场景。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li><strong>原子性</strong>：所有的操作都在底层以原子方式执行，避免了线程安全问题。</li>
<li><strong>跨平台支持</strong>：Qt 提供的原子操作在不同的平台上具有一致性，可以在 Windows、Linux、macOS 等平台上使用。</li>
</ul>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>以下是 <code>QAtomicInt</code> 常用的方法：</p>
<ol>
<li><p><strong>构造函数</strong></p>
<ul>
<li><code>QAtomicInt()</code>：默认构造一个原子整数，并将其初始化为 0。</li>
<li><code>QAtomicInt(int value)</code>：使用指定的值初始化原子整数。</li>
</ul>
</li>
<li><p><strong>读操作</strong></p>
<ul>
<li><code>int loadAcquire() const</code>：获取当前值，确保所有读操作在此操作之前完成。</li>
<li><code>int loadRelaxed() const</code>：获取当前值，但不强制同步内存。</li>
</ul>
</li>
<li><p><strong>写操作</strong></p>
<ul>
<li><code>void storeRelease(int newValue)</code>：设置新值，确保所有写操作在此操作之后完成。</li>
<li><code>void storeRelaxed(int newValue)</code>：设置新值，但不强制同步内存。</li>
</ul>
</li>
<li><p><strong>增减操作</strong></p>
<ul>
<li><code>bool ref()</code>：将值递增 1。如果结果是非零值，返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>bool deref()</code>：将值递减 1。如果结果是非零值，返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>int fetchAndAddAcquire(int value)</code>：在获取值后再增加指定的值。</li>
<li><code>int fetchAndAddRelaxed(int value)</code>：在不强制同步内存的情况下增加指定的值。</li>
<li><code>int fetchAndStoreAcquire(int newValue)</code>：获取当前值并将其设置为 <code>newValue</code>。</li>
<li><code>int fetchAndStoreRelaxed(int newValue)</code>：在不强制同步内存的情况下设置新值。</li>
</ul>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><strong>线程计数器</strong>：在多线程应用中，可以使用 <code>QAtomicInt</code> 来实现一个线程安全的计数器。</li>
<li><strong>资源管理</strong>：可以用于引用计数的实现，确保在多线程环境下资源能够正确地分配和释放。</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>QAtomicInt</code> 的简单例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QAtomicInt&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">QAtomicInt <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        counter.<span class="built_in">ref</span>();  <span class="comment">// 线程安全地增加计数器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QThread <span class="title">t1</span><span class="params">(workerFunction)</span></span>;</span><br><span class="line">    <span class="function">QThread <span class="title">t2</span><span class="params">(workerFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">start</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">wait</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Final counter value:&quot;</span> &lt;&lt; counter.<span class="built_in">loadAcquire</span>();  <span class="comment">// 输出最终计数值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了两个线程，每个线程都递增 <code>counter</code> 1000 次。由于使用了 <code>QAtomicInt</code>，计数操作是线程安全的，因此最终的计数值是 2000。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>QAtomicInt</code> 适合用于简单的整数原子操作。如果需要更复杂的原子操作，可以考虑使用 <code>QAtomicInteger&lt;T&gt;</code> 或 <code>QMutex</code>、<code>QSemaphore</code> 等同步原语。</li>
</ul>
<p><code>QAtomicInt</code> 提供了一种简单而高效的方式来处理多线程环境中的整数操作，确保数据的一致性和线程安全性。</p>
<h2 id="Qt-QString-详解"><a href="#Qt-QString-详解" class="headerlink" title="Qt QString 详解"></a>Qt QString 详解</h2><p><code>QString</code> 是 Qt 框架中用于表示和操作文本字符串的类。它是一个 Unicode 字符串类，能够很好地处理多语言字符集和复杂文本操作。<code>QString</code> 提供了丰富的功能用于创建、修改、查询和转换字符串。以下是 <code>QString</code> 的详细介绍，包括常用功能和示例代码。</p>
<h3 id="1-QString-基本概念"><a href="#1-QString-基本概念" class="headerlink" title="1. QString 基本概念"></a>1. <strong>QString 基本概念</strong></h3><p><code>QString</code> 是一个 Unicode 字符串类，支持宽字符集。Qt 使用 UTF-16 编码存储字符串。相比 C++ 的 <code>std::string</code>，<code>QString</code> 更加适合处理包含多语言和特殊字符的文本。</p>
<h3 id="2-QString-的构造方法"><a href="#2-QString-的构造方法" class="headerlink" title="2. QString 的构造方法"></a>2. <strong>QString 的构造方法</strong></h3><p><code>QString</code> 提供了多种构造函数，可以从各种数据类型构建字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QString str1;                        <span class="comment">// 空字符串</span></span><br><span class="line"><span class="function">QString <span class="title">str2</span><span class="params">(<span class="string">&quot;Hello, Qt!&quot;</span>)</span></span>;           <span class="comment">// 从字符串字面值创建</span></span><br><span class="line"><span class="function">QString <span class="title">str3</span><span class="params">(QLatin1String(<span class="string">&quot;Hello&quot;</span>))</span></span>; <span class="comment">// 从 QLatin1String 创建</span></span><br><span class="line"><span class="function">QString <span class="title">str4</span><span class="params">(str2)</span></span>;                   <span class="comment">// 拷贝构造函数</span></span><br><span class="line">QString str5 = QString::<span class="built_in">number</span>(<span class="number">42</span>);   <span class="comment">// 从数字创建</span></span><br></pre></td></tr></table></figure>

<h3 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. <strong>常用方法</strong></h3><h4 id="3-1-字符串拼接"><a href="#3-1-字符串拼接" class="headerlink" title="3.1. 字符串拼接"></a>3.1. 字符串拼接</h4><p><code>QString</code> 提供了多种方式来拼接字符串。</p>
<ul>
<li><p>使用 <code>+</code> 运算符拼接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">QString str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">QString result = str1 + <span class="string">&quot; &quot;</span> + str2;  <span class="comment">// &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>append()</code> 方法拼接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot; World&quot;</span>);  <span class="comment">// &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-2-字符串长度和访问"><a href="#3-2-字符串长度和访问" class="headerlink" title="3.2. 字符串长度和访问"></a>3.2. 字符串长度和访问</h4><ul>
<li><p>获取字符串长度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> length = str.<span class="built_in">length</span>();  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问单个字符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QChar ch = str.<span class="built_in">at</span>(<span class="number">1</span>);  <span class="comment">// &#x27;e&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-3-查找和替换"><a href="#3-3-查找和替换" class="headerlink" title="3.3. 查找和替换"></a>3.3. 查找和替换</h4><p><code>QString</code> 提供了多种查找和替换子字符串的函数：</p>
<ul>
<li><p>查找子字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;Hello, Qt!&quot;</span>;</span><br><span class="line"><span class="type">int</span> index = str.<span class="built_in">indexOf</span>(<span class="string">&quot;Qt&quot;</span>);  <span class="comment">// 返回子字符串首次出现的索引，结果是 7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>替换子字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">str.<span class="built_in">replace</span>(<span class="string">&quot;World&quot;</span>, <span class="string">&quot;Qt&quot;</span>);  <span class="comment">// 结果是 &quot;Hello, Qt!&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-4-大小写转换"><a href="#3-4-大小写转换" class="headerlink" title="3.4. 大小写转换"></a>3.4. 大小写转换</h4><ul>
<li>转换为大写或小写：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">QString upperStr = str.<span class="built_in">toUpper</span>();  <span class="comment">// &quot;HELLO&quot;</span></span><br><span class="line">QString lowerStr = str.<span class="built_in">toLower</span>();  <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-5-截取字符串"><a href="#3-5-截取字符串" class="headerlink" title="3.5. 截取字符串"></a>3.5. 截取字符串</h4><ul>
<li><p>使用 <code>mid()</code> 截取部分字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;Hello, Qt!&quot;</span>;</span><br><span class="line">QString substr = str.<span class="built_in">mid</span>(<span class="number">7</span>, <span class="number">2</span>);  <span class="comment">// 结果是 &quot;Qt&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>left()</code> 和 <code>right()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString leftStr = str.<span class="built_in">left</span>(<span class="number">5</span>);    <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">QString rightStr = str.<span class="built_in">right</span>(<span class="number">3</span>);  <span class="comment">// &quot;Qt!&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-6-字符串分割"><a href="#3-6-字符串分割" class="headerlink" title="3.6. 字符串分割"></a>3.6. 字符串分割</h4><ul>
<li>使用 <code>split()</code> 按照分隔符拆分字符串：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;apple,banana,grape&quot;</span>;</span><br><span class="line">QStringList list = str.<span class="built_in">split</span>(<span class="string">&quot;,&quot;</span>);  <span class="comment">// 拆分为 [&quot;apple&quot;, &quot;banana&quot;, &quot;grape&quot;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-7-转换为其他数据类型"><a href="#3-7-转换为其他数据类型" class="headerlink" title="3.7. 转换为其他数据类型"></a>3.7. 转换为其他数据类型</h4><ul>
<li><p>转换为整数、浮点数等：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = str.<span class="built_in">toInt</span>();  <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">QString floatStr = <span class="string">&quot;123.45&quot;</span>;</span><br><span class="line"><span class="type">double</span> num2 = floatStr.<span class="built_in">toDouble</span>();  <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>转换为字节数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">QByteArray byteArray = str.<span class="built_in">toUtf8</span>();  <span class="comment">// UTF-8 编码的字节数组</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4. 静态方法"></a>4. <strong>静态方法</strong></h3><h4 id="4-1-创建字符串"><a href="#4-1-创建字符串" class="headerlink" title="4.1. 创建字符串"></a>4.1. 创建字符串</h4><ul>
<li><p>使用 <code>QString::number()</code> 方法从数值创建字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str = QString::<span class="built_in">number</span>(<span class="number">42</span>);      <span class="comment">// &quot;42&quot;</span></span><br><span class="line">QString str2 = QString::<span class="built_in">number</span>(<span class="number">3.1415</span>); <span class="comment">// &quot;3.1415&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>arg()</code> 格式化字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="built_in">QString</span>(<span class="string">&quot;The value is %1&quot;</span>).<span class="built_in">arg</span>(<span class="number">42</span>);  <span class="comment">// &quot;The value is 42&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-比较字符串"><a href="#5-比较字符串" class="headerlink" title="5. 比较字符串"></a>5. <strong>比较字符串</strong></h3><ul>
<li><p>使用 <code>compare()</code> 方法比较两个字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString str1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">QString str2 = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = QString::<span class="built_in">compare</span>(str1, str2);  <span class="comment">// &lt; 0，因为 &quot;apple&quot; 在字典序中小于 &quot;orange&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以使用 <code>==</code> 或 <code>!=</code> 比较字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str1 == str2) &#123;</span><br><span class="line">    <span class="comment">// 字符串相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-字符串的编码处理"><a href="#6-字符串的编码处理" class="headerlink" title="6. 字符串的编码处理"></a>6. <strong>字符串的编码处理</strong></h3><p><code>QString</code> 内部使用 UTF-16 存储字符，但可以轻松转换为其他编码格式，例如 UTF-8、Latin1 等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;你好，世界&quot;</span>;</span><br><span class="line">QByteArray utf8String = str.<span class="built_in">toUtf8</span>();  <span class="comment">// 转换为 UTF-8 字节数组</span></span><br><span class="line">QByteArray latin1String = str.<span class="built_in">toLatin1</span>();  <span class="comment">// 转换为 Latin1 编码字节数组</span></span><br></pre></td></tr></table></figure>

<h3 id="7-性能优化"><a href="#7-性能优化" class="headerlink" title="7. 性能优化"></a>7. <strong>性能优化</strong></h3><p><code>QString</code> 使用了引用计数（copy-on-write）的机制来优化性能，避免不必要的拷贝操作。当多个 <code>QString</code> 对象引用同一数据时，它们共享数据；只有当其中一个发生修改时，才会执行深拷贝。</p>
<h3 id="8-使用-QString-与-QByteArray-的转换"><a href="#8-使用-QString-与-QByteArray-的转换" class="headerlink" title="8. 使用 QString 与 QByteArray 的转换"></a>8. <strong>使用 <code>QString</code> 与 <code>QByteArray</code> 的转换</strong></h3><p><code>QByteArray</code> 是字节数组类，而 <code>QString</code> 是 Unicode 字符串类，它们可以互相转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">QByteArray byteArray = str.<span class="built_in">toUtf8</span>();  <span class="comment">// 将 QString 转换为 QByteArray</span></span><br><span class="line"></span><br><span class="line">QString str2 = QString::<span class="built_in">fromUtf8</span>(byteArray);  <span class="comment">// 将 QByteArray 转换回 QString</span></span><br></pre></td></tr></table></figure>

<h3 id="9-处理空字符串"><a href="#9-处理空字符串" class="headerlink" title="9. 处理空字符串"></a>9. <strong>处理空字符串</strong></h3><ul>
<li><code>isEmpty()</code> 和 <code>isNull()</code> 用于判断字符串是否为空或为 <code>null</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString str;</span><br><span class="line"><span class="type">bool</span> empty = str.<span class="built_in">isEmpty</span>();  <span class="comment">// true，因为是空字符串</span></span><br><span class="line"><span class="type">bool</span> null = str.<span class="built_in">isNull</span>();    <span class="comment">// true，因为没有分配任何值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. <strong>总结</strong></h3><p><code>QString</code> 是一个功能强大的类，能够处理各种复杂的字符串操作。它的 Unicode 支持使其在处理多语言字符时特别有效，且提供了高效的性能优化措施。</p>
<h2 id="Qt-QVector-详解"><a href="#Qt-QVector-详解" class="headerlink" title="Qt QVector 详解"></a>Qt QVector 详解</h2><p><code>QVector</code> 是 Qt 框架中用于存储相同类型元素的动态数组类，类似于 C++ 标准库的 <code>std::vector</code>。它提供了许多方便的接口来进行动态分配、访问和操作数据。下面是对 <code>QVector</code> 的详解。</p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><p><code>QVector&lt;T&gt;</code> 是一个模板类，<code>T</code> 是其中元素的类型。<code>QVector</code> 可以根据需要动态调整数组的大小，支持类似数组的下标访问方式，并且性能表现与 <code>std::vector</code> 类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="type">int</span>&gt; intVector;  <span class="comment">// 创建一个存储整数的 QVector</span></span><br></pre></td></tr></table></figure>

<h3 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2. 常用操作"></a>2. <strong>常用操作</strong></h3><h4 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 <strong>初始化</strong></h4><p><code>QVector</code> 支持多种初始化方式，包括默认构造、指定大小的构造、和使用初始值的构造等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVector&lt;<span class="type">int</span>&gt; vec1;  <span class="comment">// 默认构造，空向量</span></span><br><span class="line"><span class="function">QVector&lt;<span class="type">int</span>&gt; <span class="title">vec2</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 构造一个包含5个默认初始化元素的向量</span></span><br><span class="line"><span class="function">QVector&lt;<span class="type">int</span>&gt; <span class="title">vec3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;  <span class="comment">// 构造一个包含5个元素，每个元素初始化为10</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-访问元素"><a href="#2-2-访问元素" class="headerlink" title="2.2 访问元素"></a>2.2 <strong>访问元素</strong></h4><p>可以通过下标访问或者使用 <code>at()</code> 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> first = vec3[<span class="number">0</span>];  <span class="comment">// 使用下标访问</span></span><br><span class="line"><span class="type">int</span> second = vec<span class="number">3.</span><span class="built_in">at</span>(<span class="number">1</span>);  <span class="comment">// 使用 at() 方法访问</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-添加元素"><a href="#2-3-添加元素" class="headerlink" title="2.3 添加元素"></a>2.3 <strong>添加元素</strong></h4><p>可以通过 <code>append()</code> 和 <code>push_back()</code> 方法向向量末尾添加元素。<code>insert()</code> 方法可以在特定位置插入元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec<span class="number">1.</span><span class="built_in">append</span>(<span class="number">3</span>);      <span class="comment">// 向尾部添加元素</span></span><br><span class="line">vec<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">5</span>);   <span class="comment">// 与 append 类似，添加到末尾</span></span><br><span class="line">vec<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">4</span>);   <span class="comment">// 在索引 1 处插入元素</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-删除元素"><a href="#2-4-删除元素" class="headerlink" title="2.4 删除元素"></a>2.4 <strong>删除元素</strong></h4><p>可以使用 <code>remove()</code>, <code>removeAt()</code>, <code>removeFirst()</code>, <code>removeLast()</code> 等函数来删除元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec<span class="number">1.</span><span class="built_in">removeAt</span>(<span class="number">0</span>);    <span class="comment">// 删除索引为 0 的元素</span></span><br><span class="line">vec<span class="number">1.</span><span class="built_in">removeFirst</span>();  <span class="comment">// 删除第一个元素</span></span><br><span class="line">vec<span class="number">1.</span><span class="built_in">removeLast</span>();   <span class="comment">// 删除最后一个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-查找和判断"><a href="#2-5-查找和判断" class="headerlink" title="2.5 查找和判断"></a>2.5 <strong>查找和判断</strong></h4><p><code>QVector</code> 提供 <code>contains()</code> 来判断是否包含某元素，<code>indexOf()</code> 和 <code>lastIndexOf()</code> 用于查找某个元素的索引。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> hasValue = vec<span class="number">1.</span><span class="built_in">contains</span>(<span class="number">5</span>);  <span class="comment">// 判断是否包含 5</span></span><br><span class="line"><span class="type">int</span> index = vec<span class="number">1.</span><span class="built_in">indexOf</span>(<span class="number">5</span>);       <span class="comment">// 查找 5 的位置</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-大小和容量"><a href="#2-6-大小和容量" class="headerlink" title="2.6 大小和容量"></a>2.6 <strong>大小和容量</strong></h4><p><code>QVector</code> 动态调整大小，可以通过 <code>size()</code> 获取当前元素的数量，通过 <code>capacity()</code> 获取预分配的内存容量。可以通过 <code>resize()</code> 改变 <code>QVector</code> 的大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = vec<span class="number">1.</span><span class="built_in">size</span>();       <span class="comment">// 获取当前元素数量</span></span><br><span class="line"><span class="type">int</span> capacity = vec<span class="number">1.</span><span class="built_in">capacity</span>(); <span class="comment">// 获取当前容量</span></span><br><span class="line">vec<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">10</span>);              <span class="comment">// 改变大小为10，可能会填充新元素</span></span><br></pre></td></tr></table></figure>

<h3 id="3-迭代"><a href="#3-迭代" class="headerlink" title="3. 迭代"></a>3. <strong>迭代</strong></h3><p>支持 C++ 范围循环（range-based for loop）和迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : vec1) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QVector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = vec<span class="number">1.</span><span class="built_in">begin</span>(); it != vec<span class="number">1.</span><span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-性能"><a href="#4-性能" class="headerlink" title="4. 性能"></a>4. <strong>性能</strong></h3><ul>
<li><strong>内存管理</strong>：<code>QVector</code> 会动态调整内存，避免频繁的内存分配。通常，<code>capacity()</code> 比 <code>size()</code> 大，以减少内存重新分配的次数。</li>
<li><strong>浅拷贝优化（Copy-on-Write）</strong>：<code>QVector</code> 使用 Qt 的隐式共享机制，也称为浅拷贝。当一个 <code>QVector</code> 被复制时，实际上并不会立即进行数据复制，直到修改操作发生，这提高了性能。</li>
</ul>
<h3 id="5-与其他容器的互操作"><a href="#5-与其他容器的互操作" class="headerlink" title="5. 与其他容器的互操作"></a>5. <strong>与其他容器的互操作</strong></h3><p><code>QVector</code> 提供了与其他容器（如 <code>QList</code>, <code>QSet</code>）的互操作能力，可以方便地将 <code>QVector</code> 转换为其他容器类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;<span class="type">int</span>&gt; list = vec<span class="number">1.</span><span class="built_in">toList</span>();  <span class="comment">// 将 QVector 转为 QList</span></span><br></pre></td></tr></table></figure>

<h3 id="6-常用函数总结"><a href="#6-常用函数总结" class="headerlink" title="6. 常用函数总结"></a>6. <strong>常用函数总结</strong></h3><ul>
<li><code>append(T value)</code> &#x2F; <code>push_back(T value)</code>：在末尾添加元素。</li>
<li><code>at(int i)</code>：返回指定索引处的元素。</li>
<li><code>size()</code>：返回当前元素数量。</li>
<li><code>capacity()</code>：返回当前预分配的内存大小。</li>
<li><code>clear()</code>：清空所有元素。</li>
<li><code>contains(T value)</code>：判断是否包含某个元素。</li>
<li><code>indexOf(T value)</code>：返回某个元素的索引。</li>
<li><code>removeAt(int i)</code>：删除指定位置的元素。</li>
<li><code>resize(int size)</code>：调整大小。</li>
</ul>
<h3 id="7-QVector-使用示例"><a href="#7-QVector-使用示例" class="headerlink" title="7. QVector 使用示例"></a>7. <strong>QVector 使用示例</strong></h3><p>下面是一个简单的示例，演示了 <code>QVector</code> 的基本用法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    vec.<span class="built_in">append</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">append</span>(<span class="number">2</span>);</span><br><span class="line">    vec.<span class="built_in">append</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;First element:&quot;</span> &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Element at index&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; vec[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找和判断</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">contains</span>(<span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Vector contains 2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    vec.<span class="built_in">removeAt</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;After removing index 1:&quot;</span> &lt;&lt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>QVector</code> 是 Qt 提供的强大而灵活的动态数组容器，适用于需要高效存储和访问大量相同类型数据的场景。在日常使用中，可以充分利用其丰富的 API 和高性能特性来简化开发流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/09/05/notebook/Qt/2024-09-05-qt_4_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/05/notebook/Qt/2024-09-05-qt_4_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">qt_5_常见技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-09-05 09:00:00" itemprop="dateCreated datePublished" datetime="2024-09-05T09:00:00+08:00">2024-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Qt常见技巧</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/05/notebook/Qt/2024-09-05-qt_4_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/09/04/notebook/C++/C++_03_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-09-04-C++_03_3_windows%E4%B8%8B%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/04/notebook/C++/C++_03_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-09-04-C++_03_3_windows%E4%B8%8B%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++_03_3_windows下常见函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-09-04 09:00:00" itemprop="dateCreated datePublished" datetime="2024-09-04T09:00:00+08:00">2024-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>windows环境下C++编程遇到的函数</li>
</ul>
<h2 id="windows-C-WSAStartup-函数-详解"><a href="#windows-C-WSAStartup-函数-详解" class="headerlink" title="windows C++ WSAStartup()函数 详解"></a>windows C++ WSAStartup()函数 详解</h2><p><code>WSAStartup()</code> 是 Windows Sockets API（也称为 Winsock）中用于初始化 Windows Sockets 库的函数。该函数在使用任何其他 Windows Sockets 函数之前必须调用，用于设置程序对网络通信的支持。</p>
<h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAStartup</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WORD wVersionRequested,  <span class="comment">// 请求的 Winsock 版本</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPWSADATA lpWSAData      <span class="comment">// 指向 WSADATA 结构的指针，用于接收系统信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>wVersionRequested</code>：指定应用程序请求的 Winsock 版本。该参数由高字节和低字节组成，例如，<code>MAKEWORD(2, 2)</code> 表示请求 Winsock 2.2 版本。</li>
<li><code>lpWSAData</code>：指向一个 <code>WSADATA</code> 结构的指针，用于接收有关 Windows Sockets 实现的详细信息。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>如果函数调用成功，返回值为零 (<code>0</code>)。</li>
<li>如果函数调用失败，返回一个非零的错误代码。常见的错误代码包括 <code>WSASYSNOTREADY</code>（底层网络子系统不可用）和 <code>WSAVERNOTSUPPORTED</code>（请求的 Winsock 版本不受支持）。</li>
</ul>
</li>
</ul>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol>
<li><p><strong>版本管理</strong>：</p>
<ul>
<li>在调用 <code>WSAStartup()</code> 时，必须指定应用程序希望使用的 Winsock 版本。最常用的是 <code>2.2</code> 版本 (<code>MAKEWORD(2, 2)</code>)，因为它支持大多数现代网络应用程序的需求。</li>
<li>如果系统支持请求的版本，<code>WSAStartup()</code> 会返回该版本的详细信息。如果系统不支持请求的版本，则返回较低的版本信息，或者函数调用失败。</li>
</ul>
</li>
<li><p><strong>WSADATA 结构</strong>：</p>
<ul>
<li><code>lpWSAData</code> 参数指向的 <code>WSADATA</code> 结构用于接收 Winsock 的相关信息。该结构包含了 Winsock 版本、最大套接字数等重要信息。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">WSAData</span> &#123;</span><br><span class="line">    WORD           wVersion;       <span class="comment">// Winsock 版本</span></span><br><span class="line">    WORD           wHighVersion;   <span class="comment">// 最高支持的 Winsock 版本</span></span><br><span class="line">    <span class="type">char</span>           szDescription[WSADESCRIPTION_LEN + <span class="number">1</span>];  <span class="comment">// 实现描述</span></span><br><span class="line">    <span class="type">char</span>           szSystemStatus[WSASYSSTATUS_LEN + <span class="number">1</span>];   <span class="comment">// 系统状态</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> iMaxSockets;    <span class="comment">// 支持的最大套接字数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> iMaxUdpDg;      <span class="comment">// 最大 UDP 数据报长度</span></span><br><span class="line">    <span class="type">char</span> FAR*      lpVendorInfo;   <span class="comment">// 供应商特定信息</span></span><br><span class="line">&#125; WSADATA, *LPWSADATA;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>清理</strong>：</p>
<ul>
<li>当应用程序不再需要使用 Windows Sockets API 时，应该调用 <code>WSACleanup()</code> 函数来卸载 Winsock 库并释放相关资源。</li>
</ul>
</li>
<li><p><strong>错误处理</strong>：</p>
<ul>
<li>如果 <code>WSAStartup()</code> 返回非零值，表明初始化失败，应用程序应检查返回值并通过 <code>WSAGetLastError()</code> 函数获取详细的错误信息。</li>
</ul>
</li>
</ol>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>以下是一个简单的示例，展示如何正确使用 <code>WSAStartup()</code> 函数来初始化 Winsock 库：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock 2.2 版本</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;WSAStartup failed with error: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Winsock initialized successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Winsock version: &quot;</span> &lt;&lt; <span class="built_in">LOBYTE</span>(wsaData.wVersion) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">HIBYTE</span>(wsaData.wVersion) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Description: &quot;</span> &lt;&lt; wsaData.szDescription &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此处可以编写网络通信相关代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 Winsock</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><code>WSAStartup()</code> 函数用于初始化 Winsock 库，请求使用 Winsock 2.2 版本。</li>
<li>如果初始化成功，程序会输出 Winsock 的版本信息和描述。</li>
<li>当程序不再需要使用网络功能时，调用 <code>WSACleanup()</code> 函数来清理 Winsock 资源。</li>
</ul>
<p><code>WSAStartup()</code> 是任何使用 Windows Sockets API 进行网络编程的应用程序中的必备步骤。初始化成功后，您就可以使用其他 Winsock 函数来执行各种网络操作，例如创建套接字、连接到服务器、发送和接收数据等。</p>
<h2 id="windows-C-GetCurrentThreadId-函数-详解"><a href="#windows-C-GetCurrentThreadId-函数-详解" class="headerlink" title="windows C++ GetCurrentThreadId()函数 详解"></a>windows C++ GetCurrentThreadId()函数 详解</h2><p><code>GetCurrentThreadId()</code> 是 Windows API 中的一个函数，用于获取当前线程的唯一标识符（线程 ID）。在多线程编程中，每个线程都有一个唯一的 ID，可以通过该函数获取，便于在线程间进行标识和管理。</p>
<h2 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetCurrentThreadId</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>void</code>：该函数不接受任何参数。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回当前调用线程的 <code>DWORD</code> 类型的线程 ID。线程 ID 是一个系统分配的数字，用于唯一标识当前线程。</li>
</ul>
</li>
</ul>
<h2 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h2><ol>
<li><p><strong>线程 ID 的唯一性</strong>：</p>
<ul>
<li>每个线程在其生命周期内都有一个唯一的线程 ID。当线程终止时，该 ID 可能会被系统回收并分配给新的线程。</li>
</ul>
</li>
<li><p><strong>典型用法</strong>：</p>
<ul>
<li><code>GetCurrentThreadId()</code> 常用于调试、日志记录、线程间通信或同步等场景中。例如，可以使用线程 ID 来标记日志消息，便于区分不同线程的输出。</li>
<li>线程 ID 也可以用于将线程与某些特定的资源（如窗口、数据结构）关联起来。</li>
</ul>
</li>
<li><p><strong>与其他 API 的关系</strong>：</p>
<ul>
<li>线程 ID 与线程句柄不同，线程句柄通过 <code>CreateThread</code> 或 <code>OpenThread</code> 等函数获取，而线程 ID 则是一个直接标识线程的数字。</li>
<li>通过 <code>OpenThread()</code> 函数可以将线程 ID 转换为线程句柄，便于进行更复杂的线程操作。</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>线程 ID 是系统分配的，不应直接作为关键数据或资源的唯一标识，因为它们在特定条件下可能被重复使用。</li>
</ul>
</li>
</ol>
<h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><p>以下是一个简单的示例，演示如何使用 <code>GetCurrentThreadId()</code> 获取并打印当前线程的 ID。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParam)</span> </span>&#123;</span><br><span class="line">    DWORD threadId = <span class="built_in">GetCurrentThreadId</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot; is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">2000</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot; is exiting.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个线程</span></span><br><span class="line">    HANDLE hThread1 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    HANDLE hThread2 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread1, INFINITE);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread2, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread1);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><code>ThreadProc</code> 是线程的执行函数，每个线程在启动后都会执行该函数。</li>
<li>每个线程都会调用 <code>GetCurrentThreadId()</code> 来获取并打印其自身的线程 ID。</li>
<li>主线程创建了两个子线程，并等待它们完成执行。</li>
<li>通过线程 ID，您可以在日志或调试信息中区分不同线程的行为。</li>
</ul>
<p><code>GetCurrentThreadId()</code> 是多线程编程中的一个基本工具，能够帮助开发者识别和管理不同的线程。</p>
<h2 id="windows-C-WaitForSingleObject-函数-详解"><a href="#windows-C-WaitForSingleObject-函数-详解" class="headerlink" title="windows C++ WaitForSingleObject()函数 详解"></a>windows C++ WaitForSingleObject()函数 详解</h2><p><code>WaitForSingleObject()</code> 是 Windows API 中用于同步操作的函数。它用于使调用线程等待一个内核对象（如线程、进程、信号量、事件等）变为有信号状态，或者等待超时。该函数经常用于多线程编程中，确保线程之间的协调与同步。</p>
<h2 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hHandle,   <span class="comment">// 内核对象的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  dwMilliseconds <span class="comment">// 等待的时间（毫秒）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>hHandle</code>：要等待的内核对象的句柄。这个句柄可以是由 <code>CreateEvent</code>、<code>CreateMutex</code>、<code>CreateSemaphore</code>、<code>CreateThread</code> 等函数返回的句柄。</li>
<li><code>dwMilliseconds</code>：指定等待的时间，单位为毫秒。可以是以下值之一：<ul>
<li><code>INFINITE</code>：表示无限等待，直到对象变为有信号状态。</li>
<li>非零值：指定最大等待时间（毫秒）。如果在指定时间内对象没有变为有信号状态，函数会返回 <code>WAIT_TIMEOUT</code>。</li>
<li><code>0</code>：表示立即返回，不等待。如果对象已经是有信号状态，函数立即返回；否则，函数立即返回 <code>WAIT_TIMEOUT</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li><code>WAIT_OBJECT_0</code> (0x00000000L)：指定的对象变为有信号状态。</li>
<li><code>WAIT_TIMEOUT</code> (0x00000102L)：等待超时，指定的对象未变为有信号状态。</li>
<li><code>WAIT_ABANDONED</code> (0x00000080L)：等待的对象是一个互斥体对象，且上一个拥有该互斥体的线程在没有释放互斥体的情况下终止。表示互斥体已被“放弃”。</li>
<li><code>WAIT_FAILED</code>：函数调用失败。可以通过 <code>GetLastError()</code> 获取错误代码。</li>
</ul>
</li>
</ul>
<h2 id="使用说明-2"><a href="#使用说明-2" class="headerlink" title="使用说明"></a>使用说明</h2><ol>
<li><p><strong>同步操作</strong>：</p>
<ul>
<li><code>WaitForSingleObject()</code> 主要用于线程同步，确保某个线程在执行某些操作之前等待另一个线程或进程完成其工作。</li>
</ul>
</li>
<li><p><strong>常见应用场景</strong>：</p>
<ul>
<li>等待线程或进程终止：通过等待线程或进程的句柄，确保主线程在子线程或子进程完成后再继续执行。</li>
<li>事件同步：通过等待事件对象，控制多个线程的执行顺序。</li>
<li>互斥体和信号量：通过等待这些对象，控制对共享资源的访问。</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>如果使用 <code>INFINITE</code> 作为等待时间，线程将无限期地等待，直到对象变为有信号状态，这可能导致线程挂起，无法继续执行。</li>
<li>对于互斥体，使用 <code>WAIT_ABANDONED</code> 返回值表示该互斥体对象被上一个线程错误地放弃，此时程序应小心处理共享资源的状态。</li>
</ul>
</li>
</ol>
<h2 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h2><p>下面是一个使用 <code>WaitForSingleObject()</code> 的简单示例，演示如何等待一个线程完成执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParam)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">3000</span>); <span class="comment">// 模拟线程工作 3 秒钟</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread is exiting...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(</span><br><span class="line">        <span class="literal">NULL</span>,        <span class="comment">// 默认安全属性</span></span><br><span class="line">        <span class="number">0</span>,           <span class="comment">// 默认堆栈大小</span></span><br><span class="line">        ThreadProc,  <span class="comment">// 线程函数</span></span><br><span class="line">        <span class="literal">NULL</span>,        <span class="comment">// 线程函数的参数</span></span><br><span class="line">        <span class="number">0</span>,           <span class="comment">// 默认创建标志</span></span><br><span class="line">        <span class="literal">NULL</span>         <span class="comment">// 不接收线程 ID</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to create thread. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    DWORD dwResult = <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">    <span class="keyword">switch</span> (dwResult) &#123;</span><br><span class="line">        <span class="keyword">case</span> WAIT_OBJECT_0:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread has terminated.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WAIT_TIMEOUT:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Wait timed out.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WAIT_FAILED:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Wait failed. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><code>CreateThread()</code> 函数创建了一个新线程，执行 <code>ThreadProc</code> 函数。</li>
<li>主线程使用 <code>WaitForSingleObject()</code> 来等待子线程完成执行。因为等待时间设置为 <code>INFINITE</code>，主线程会一直等待，直到子线程终止。</li>
<li>通过 <code>dwResult</code> 检查 <code>WaitForSingleObject()</code> 的返回值，决定接下来的操作。</li>
</ul>
<p><code>WaitForSingleObject()</code> 是多线程编程中非常重要的一个工具，能有效管理线程间的执行顺序和资源访问控制。</p>
<h2 id="windows-C-GetLastError-函数-详解"><a href="#windows-C-GetLastError-函数-详解" class="headerlink" title="windows C++ GetLastError()函数 详解"></a>windows C++ GetLastError()函数 详解</h2><p><code>GetLastError()</code> 是 Windows API 中用于获取调用失败的函数返回的错误代码的函数。许多 Windows API 函数在执行失败时，不会直接返回错误信息，而是通过设置一个内部的线程局部变量来记录错误代码。调用 <code>GetLastError()</code> 函数可以检索到这个错误代码，用于诊断和处理错误情况。</p>
<h2 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetLastError</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：<ul>
<li>返回一个 <code>DWORD</code> 类型的错误代码。这个错误代码是一个整数值，对应特定的错误类型。</li>
</ul>
</li>
</ul>
<h2 id="使用说明-3"><a href="#使用说明-3" class="headerlink" title="使用说明"></a>使用说明</h2><ol>
<li><p><strong>线程局部存储</strong>：</p>
<ul>
<li><code>GetLastError()</code> 返回的错误代码与调用线程是关联的，即每个线程都有自己的错误代码存储区。因此，如果多线程程序中某个线程调用 <code>GetLastError()</code>，它获取到的错误代码仅适用于该线程的上下文。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>当调用 Windows API 函数时，如果函数返回了一个失败的状态（例如返回 <code>NULL</code> 或 <code>INVALID_HANDLE_VALUE</code>），通常应该紧接着调用 <code>GetLastError()</code> 来获取具体的错误代码。这有助于诊断失败的原因并采取相应措施。</li>
</ul>
</li>
<li><p><strong>与 <code>FormatMessage()</code> 配合使用</strong>：</p>
<ul>
<li>错误代码本身是一个数字，通常难以直接理解。可以使用 <code>FormatMessage()</code> 函数将错误代码转换为可读的错误消息字符串。</li>
</ul>
</li>
<li><p><strong>清除错误代码</strong>：</p>
<ul>
<li><code>GetLastError()</code> 只会返回最近一次失败的函数调用的错误代码。对于成功的函数调用，错误代码不会被清除。因此，在进行新的操作之前，如果想确保没有残留的错误代码，可以先调用 <code>SetLastError(0)</code> 清除错误状态。</li>
</ul>
</li>
</ol>
<h2 id="常见错误代码"><a href="#常见错误代码" class="headerlink" title="常见错误代码"></a>常见错误代码</h2><p>以下是一些常见的错误代码及其含义：</p>
<ul>
<li><code>ERROR_SUCCESS</code> (0)：操作成功。</li>
<li><code>ERROR_FILE_NOT_FOUND</code> (2)：系统找不到指定的文件。</li>
<li><code>ERROR_ACCESS_DENIED</code> (5)：拒绝访问。</li>
<li><code>ERROR_INVALID_HANDLE</code> (6)：句柄无效。</li>
<li><code>ERROR_NOT_ENOUGH_MEMORY</code> (8)：内存不足，无法完成此操作。</li>
<li><code>ERROR_INVALID_PARAMETER</code> (87)：参数错误。</li>
<li><code>ERROR_INSUFFICIENT_BUFFER</code> (122)：缓冲区大小不足。</li>
</ul>
<p>完整的错误代码列表可以在微软文档中找到。</p>
<h2 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h2><p>以下是一个简单的示例，演示如何使用 <code>GetLastError()</code> 获取错误代码并显示相应的错误消息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试打开一个不存在的文件</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFile</span>(</span><br><span class="line">        <span class="string">L&quot;nonexistent_file.txt&quot;</span>, <span class="comment">// 文件名</span></span><br><span class="line">        GENERIC_READ,            <span class="comment">// 访问模式</span></span><br><span class="line">        <span class="number">0</span>,                       <span class="comment">// 共享模式</span></span><br><span class="line">        <span class="literal">NULL</span>,                    <span class="comment">// 安全属性</span></span><br><span class="line">        OPEN_EXISTING,           <span class="comment">// 如何创建</span></span><br><span class="line">        FILE_ATTRIBUTE_NORMAL,   <span class="comment">// 文件属性</span></span><br><span class="line">        <span class="literal">NULL</span>                     <span class="comment">// 模板文件句柄</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        DWORD dwError = <span class="built_in">GetLastError</span>();  <span class="comment">// 获取错误代码</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file. Error code: &quot;</span> &lt;&lt; dwError &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 FormatMessage 获取错误信息</span></span><br><span class="line">        LPVOID lpMsgBuf;</span><br><span class="line">        <span class="built_in">FormatMessage</span>(</span><br><span class="line">            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            dwError,</span><br><span class="line">            <span class="built_in">MAKELANGID</span>(LANG_NEUTRAL, SUBLANG_DEFAULT),</span><br><span class="line">            (LPWSTR)&amp;lpMsgBuf,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        std::wcerr &lt;&lt; <span class="string">&quot;Error message: &quot;</span> &lt;&lt; (LPWSTR)lpMsgBuf &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放 FormatMessage 分配的缓冲区</span></span><br><span class="line">        <span class="built_in">LocalFree</span>(lpMsgBuf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File opened successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);  <span class="comment">// 关闭文件句柄</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>尝试打开一个不存在的文件 <code>nonexistent_file.txt</code>。</li>
<li><code>CreateFile()</code> 调用失败并返回 <code>INVALID_HANDLE_VALUE</code>，表示操作失败。</li>
<li>使用 <code>GetLastError()</code> 获取具体的错误代码，并使用 <code>FormatMessage()</code> 将错误代码转换为可读的错误消息。</li>
</ul>
<p>这个函数对于调试和错误处理非常重要，可以帮助开发者准确定位问题所在。</p>
<h2 id="windows-C-ClearCommError-函数-详解"><a href="#windows-C-ClearCommError-函数-详解" class="headerlink" title="windows C++ ClearCommError()函数 详解"></a>windows C++ ClearCommError()函数 详解</h2><p><code>ClearCommError()</code> 是 Windows API 中用于处理通信端口（如串口）错误的函数。它用于获取通信设备的错误信息，并可以清除通信设备的错误状态。这个函数通常用于串口通信程序中，用来检查和处理通信异常情况。</p>
<h2 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ClearCommError</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hFile,           <span class="comment">// 通信设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD lpErrors,       <span class="comment">// 指向一个变量，该变量接收设备错误信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCOMSTAT lpStat        <span class="comment">// 指向 COMSTAT 结构，该结构接收通信状态信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>hFile</code>：通信设备的句柄。通常通过 <code>CreateFile()</code> 函数获取，用于表示串口设备（如 <code>COM1</code>, <code>COM2</code>）。</li>
<li><code>lpErrors</code>：指向一个 <code>DWORD</code> 变量的指针，用于接收通信设备的错误状态信息。这个参数可以为 <code>NULL</code>，如果不需要获取错误信息。</li>
<li><code>lpStat</code>：指向一个 <code>COMSTAT</code> 结构的指针，该结构接收设备的通信状态信息。这个参数可以为 <code>NULL</code>，如果不需要获取通信状态信息。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>如果函数调用成功，返回值为非零值 (<code>TRUE</code>)。</li>
<li>如果函数调用失败，返回值为零 (<code>FALSE</code>)。可以通过调用 <code>GetLastError()</code> 函数获取详细的错误信息。</li>
</ul>
</li>
</ul>
<h2 id="错误状态"><a href="#错误状态" class="headerlink" title="错误状态"></a>错误状态</h2><p><code>lpErrors</code> 参数接收的错误状态是一个或多个以下值的组合：</p>
<ul>
<li><code>CE_BREAK</code>：接收到中断信号。</li>
<li><code>CE_FRAME</code>：硬件检测到帧错误。</li>
<li><code>CE_OVERRUN</code>：输入缓冲区溢出。数据丢失。</li>
<li><code>CE_RXOVER</code>：输入缓冲区溢出，字符被丢弃。</li>
<li><code>CE_RXPARITY</code>：接收到的字符有奇偶校验错误。</li>
<li><code>CE_TXFULL</code>：应用程序试图传输字符时，输出缓冲区已满。</li>
</ul>
<h2 id="COMSTAT-结构"><a href="#COMSTAT-结构" class="headerlink" title="COMSTAT 结构"></a>COMSTAT 结构</h2><p><code>lpStat</code> 参数指向的 <code>COMSTAT</code> 结构，用于获取通信设备的状态信息。该结构包括如下成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_COMSTAT</span> &#123;</span><br><span class="line">  DWORD fCtsHold : <span class="number">1</span>;      <span class="comment">// CTS (Clear To Send) 信号被保持</span></span><br><span class="line">  DWORD fDsrHold : <span class="number">1</span>;      <span class="comment">// DSR (Data Set Ready) 信号被保持</span></span><br><span class="line">  DWORD fRlsdHold : <span class="number">1</span>;     <span class="comment">// RLSD (Receive Line Signal Detect) 信号被保持</span></span><br><span class="line">  DWORD fXoffHold : <span class="number">1</span>;     <span class="comment">// XOFF 被保持</span></span><br><span class="line">  DWORD fXoffSent : <span class="number">1</span>;     <span class="comment">// 已发送 XOFF</span></span><br><span class="line">  DWORD fEof : <span class="number">1</span>;          <span class="comment">// 已接收到 EOF</span></span><br><span class="line">  DWORD fTxim : <span class="number">1</span>;         <span class="comment">// 传输缓冲区被空中断</span></span><br><span class="line">  DWORD fReserved : <span class="number">25</span>;    <span class="comment">// 保留</span></span><br><span class="line">  DWORD cbInQue;           <span class="comment">// 输入缓冲区中的字节数</span></span><br><span class="line">  DWORD cbOutQue;          <span class="comment">// 输出缓冲区中的字节数</span></span><br><span class="line">&#125; COMSTAT, *LPCOMSTAT;</span><br></pre></td></tr></table></figure>

<h2 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="使用示例"></a>使用示例</h2><p>下面是一个使用 <code>ClearCommError()</code> 函数的简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开串口 (COM1)</span></span><br><span class="line">    HANDLE hComm = <span class="built_in">CreateFile</span>(</span><br><span class="line">        <span class="string">L&quot;COM1&quot;</span>,                     <span class="comment">// 设备名</span></span><br><span class="line">        GENERIC_READ | GENERIC_WRITE, <span class="comment">// 访问模式</span></span><br><span class="line">        <span class="number">0</span>,                            <span class="comment">// 共享模式</span></span><br><span class="line">        <span class="literal">NULL</span>,                         <span class="comment">// 安全属性</span></span><br><span class="line">        OPEN_EXISTING,                <span class="comment">// 打开已存在的设备</span></span><br><span class="line">        <span class="number">0</span>,                            <span class="comment">// 文件属性</span></span><br><span class="line">        <span class="literal">NULL</span>                          <span class="comment">// 模板文件句柄</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hComm == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open COM1. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查并清除错误</span></span><br><span class="line">    DWORD dwErrors;</span><br><span class="line">    COMSTAT comStat;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ClearCommError</span>(hComm, &amp;dwErrors, &amp;comStat)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dwErrors != <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Communication error occurred: &quot;</span> &lt;&lt; dwErrors &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No errors. Bytes in queue: &quot;</span> &lt;&lt; comStat.cbInQue &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to clear communication error. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭串口</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hComm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><code>CreateFile()</code> 用于打开串口设备 <code>COM1</code>。</li>
<li><code>ClearCommError()</code> 用于检查通信错误，并获取当前通信状态。</li>
<li>如果有错误发生，<code>dwErrors</code> 变量将包含具体的错误代码。</li>
<li><code>comStat</code> 结构提供有关输入和输出缓冲区状态的信息。</li>
</ul>
<p>这个函数在串口通信程序中非常有用，可以帮助开发者处理通信中的异常情况，如数据丢失、缓冲区溢出等问题。</p>
<h2 id="windows-C-CloseHandle-函数-详解"><a href="#windows-C-CloseHandle-函数-详解" class="headerlink" title="windows C++ CloseHandle()函数 详解"></a>windows C++ CloseHandle()函数 详解</h2><p><code>CloseHandle()</code> 是 Windows API 中用于关闭内核对象句柄的函数。它是 Windows 操作系统中资源管理的一部分，用于释放进程中占用的系统资源。</p>
<h2 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CloseHandle</span><span class="params">(HANDLE hObject)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>hObject</code>：需要关闭的句柄。这个句柄可以是打开的文件、线程、进程、信号量、文件映射对象、互斥体等内核对象。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>如果函数调用成功，返回值为非零值 (<code>TRUE</code>)。</li>
<li>如果函数调用失败，返回值为零 (<code>FALSE</code>)。可以通过调用 <code>GetLastError()</code> 函数获取详细的错误信息。</li>
</ul>
</li>
</ul>
<h2 id="使用说明-4"><a href="#使用说明-4" class="headerlink" title="使用说明"></a>使用说明</h2><ol>
<li><p><strong>资源管理</strong>：</p>
<ul>
<li>在 Windows 操作系统中，许多资源（如文件、进程、线程等）都是通过句柄来管理的。每当你创建或打开这些资源时，系统都会分配一个句柄。当不再需要这些资源时，必须调用 <code>CloseHandle()</code> 来释放句柄，否则会导致资源泄漏。</li>
</ul>
</li>
<li><p><strong>句柄类型</strong>：</p>
<ul>
<li><code>CloseHandle()</code> 可以用于关闭多种类型的句柄，例如文件句柄、线程句柄、进程句柄、互斥体句柄、事件对象句柄等。需要确保关闭正确的句柄类型，以避免程序异常。</li>
</ul>
</li>
<li><p><strong>多次调用</strong>：</p>
<ul>
<li>对同一个句柄多次调用 <code>CloseHandle()</code> 是错误的行为。这将导致未定义的行为，可能会引发程序崩溃或其他严重的错误。因此，调用 <code>CloseHandle()</code> 后，不应再使用这个句柄。</li>
</ul>
</li>
<li><p><strong>系统资源的自动释放</strong>：</p>
<ul>
<li>当进程终止时，系统会自动关闭该进程中所有打开的句柄。但依赖于系统自动关闭句柄通常不是一个好的实践，程序应该显式地调用 <code>CloseHandle()</code> 来关闭不再需要的句柄。</li>
</ul>
</li>
</ol>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFile</span>(</span><br><span class="line">        <span class="string">L&quot;example.txt&quot;</span>,            <span class="comment">// 文件名</span></span><br><span class="line">        GENERIC_READ,              <span class="comment">// 访问模式</span></span><br><span class="line">        <span class="number">0</span>,                         <span class="comment">// 共享模式</span></span><br><span class="line">        <span class="literal">NULL</span>,                      <span class="comment">// 安全属性</span></span><br><span class="line">        OPEN_EXISTING,             <span class="comment">// 如何创建</span></span><br><span class="line">        FILE_ATTRIBUTE_NORMAL,     <span class="comment">// 文件属性</span></span><br><span class="line">        <span class="literal">NULL</span>);                     <span class="comment">// 模板文件句柄</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行文件操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件句柄</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CloseHandle</span>(hFile)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File handle closed successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to close file handle. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>CreateFile()</code> 函数用于打开一个文件，并返回一个文件句柄。然后，使用 <code>CloseHandle()</code> 函数关闭这个文件句柄，释放相关资源。</p>
<h2 id="windows-C-PurgeComm-函数-详解"><a href="#windows-C-PurgeComm-函数-详解" class="headerlink" title="windows C++ PurgeComm()函数 详解"></a>windows C++ PurgeComm()函数 详解</h2><p><code>PurgeComm</code> 函数是 Windows API 中用于清除串口通信设备的输入或输出缓冲区的函数。它可以有效地清除缓冲区中的数据以及挂起的输入或输出请求，确保串口通信处于已知状态。这在处理通信错误或重置串口设备时非常有用。</p>
<h3 id="函数原型-6"><a href="#函数原型-6" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PurgeComm</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  dwFlags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h3><ol>
<li><p><strong><code>hFile</code></strong></p>
<ul>
<li>类型：<code>HANDLE</code></li>
<li>描述：这是一个串口设备的句柄，通常由 <code>CreateFile</code> 函数获得，代表一个打开的串口通信端口（如 <code>&quot;COM1&quot;</code>）。</li>
</ul>
</li>
<li><p><strong><code>dwFlags</code></strong></p>
<ul>
<li><p>类型：<code>DWORD</code></p>
</li>
<li><p>描述：指定要清除的缓冲区或挂起的操作的标志。可以是以下值的组合：</p>
</li>
<li><p><strong><code>PURGE_RXABORT</code> (0x0002)</strong>: 终止所有挂起的读取操作。未完成的读取操作将失败。</p>
</li>
<li><p><strong><code>PURGE_RXCLEAR</code> (0x0008)</strong>: 清除接收缓冲区中的数据。</p>
</li>
<li><p><strong><code>PURGE_TXABORT</code> (0x0001)</strong>: 终止所有挂起的写入操作。未完成的写入操作将失败。</p>
</li>
<li><p><strong><code>PURGE_TXCLEAR</code> (0x0004)</strong>: 清除发送缓冲区中的数据。</p>
</li>
</ul>
<p>这些标志可以通过按位或 (<code>|</code>) 组合使用，例如 <code>PURGE_RXABORT | PURGE_TXCLEAR</code>。</p>
</li>
</ol>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><strong>成功</strong>：如果函数执行成功，返回 <code>TRUE</code>，表示缓冲区已被成功清除。</li>
<li><strong>失败</strong>：如果函数执行失败，返回 <code>FALSE</code>，可以通过调用 <code>GetLastError()</code> 来获取更多错误信息。</li>
</ul>
<h3 id="使用示例-5"><a href="#使用示例-5" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开串口</span></span><br><span class="line">    HANDLE hSerial = <span class="built_in">CreateFile</span>(</span><br><span class="line">        <span class="string">&quot;COM1&quot;</span>,                        <span class="comment">// 串口名称</span></span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,  <span class="comment">// 读写权限</span></span><br><span class="line">        <span class="number">0</span>,                             <span class="comment">// 独占访问</span></span><br><span class="line">        <span class="literal">NULL</span>,                          <span class="comment">// 默认安全属性</span></span><br><span class="line">        OPEN_EXISTING,                 <span class="comment">// 打开现有串口</span></span><br><span class="line">        <span class="number">0</span>,                             <span class="comment">// 属性标志</span></span><br><span class="line">        <span class="literal">NULL</span>                           <span class="comment">// 不使用模板文件</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hSerial == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open COM port. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除接收缓冲区和终止所有挂起的读取操作</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PurgeComm</span>(hSerial, PURGE_RXCLEAR | PURGE_RXABORT)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to purge COM port. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hSerial);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;COM port purged successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行其他串口通信操作...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭串口</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSerial);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例中-PurgeComm-的使用"><a href="#解释示例中-PurgeComm-的使用" class="headerlink" title="解释示例中 PurgeComm 的使用"></a>解释示例中 <code>PurgeComm</code> 的使用</h3><p>在上面的例子中，我们首先打开了 <code>COM1</code> 串口。接着，我们使用 <code>PurgeComm</code> 函数清除了接收缓冲区 (<code>PURGE_RXCLEAR</code>) 并终止了所有挂起的读取操作 (<code>PURGE_RXABORT</code>)。这有助于在进行进一步的串口操作之前，确保没有未处理的旧数据或挂起的操作。</p>
<h3 id="典型用法场景"><a href="#典型用法场景" class="headerlink" title="典型用法场景"></a>典型用法场景</h3><ul>
<li><strong>处理通信错误</strong>：在检测到通信错误后，可以使用 <code>PurgeComm</code> 清除串口缓冲区，以便重新开始通信。</li>
<li><strong>重置串口状态</strong>：当需要重置串口状态时，可以清除所有挂起的操作和缓冲区内容，确保通信的稳定性。</li>
<li><strong>同步操作</strong>：当程序需要与设备重新同步时，可以通过清除接收缓冲区来忽略不完整或意外的输入。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>挂起操作的影响</strong>：使用 <code>PURGE_RXABORT</code> 和 <code>PURGE_TXABORT</code> 标志会导致挂起的读取或写入操作失败，并返回错误。使用这些标志时需要确保程序能够正确处理这些失败的操作。</li>
<li><strong>数据丢失</strong>：清除缓冲区（使用 <code>PURGE_RXCLEAR</code> 或 <code>PURGE_TXCLEAR</code>）会导致缓冲区中的数据丢失。因此，调用 <code>PurgeComm</code> 函数之前应确保缓冲区中的数据已被处理或不再需要。</li>
</ul>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ul>
<li>**<code>ERROR_INVALID_HANDLE</code>**：无效的句柄，可能是因为串口未成功打开或句柄已关闭。</li>
<li>**<code>ERROR_IO_PENDING</code>**：有未完成的 I&#x2F;O 操作。这通常表示在尝试清除缓冲区时，有未处理完的操作。</li>
</ul>
<p><code>PurgeComm</code> 是串口通信中一个重要的维护工具，特别是在需要处理错误、重置通信状态或确保系统处于已知状态时。通过正确使用该函数，可以提高串口通信的稳定性和可靠性。</p>
<h2 id="windows-C-SetCommTimeouts-函数-详解"><a href="#windows-C-SetCommTimeouts-函数-详解" class="headerlink" title="windows C++ SetCommTimeouts()函数 详解"></a>windows C++ SetCommTimeouts()函数 详解</h2><p><code>SetCommTimeouts</code> 函数是 Windows API 中用于设置串口通信设备的超时时间的函数。它允许你定义串口设备在读取和写入操作时的超时行为，这是确保串口通信可靠性的重要一步。</p>
<h3 id="函数原型-7"><a href="#函数原型-7" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetCommTimeouts</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCOMMTIMEOUTS lpCommTimeouts</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数详解-1"><a href="#参数详解-1" class="headerlink" title="参数详解"></a>参数详解</h3><ol>
<li><p><strong><code>hFile</code></strong></p>
<ul>
<li>类型：<code>HANDLE</code></li>
<li>描述：这是一个串口设备的句柄，通常由 <code>CreateFile</code> 函数获得，代表一个打开的串口通信端口（如 <code>&quot;COM1&quot;</code>）。</li>
</ul>
</li>
<li><p><strong><code>lpCommTimeouts</code></strong></p>
<ul>
<li>类型：<code>LPCOMMTIMEOUTS</code></li>
<li>描述：指向 <code>COMMTIMEOUTS</code> 结构的指针，该结构包含了设备输入输出操作的超时设置。</li>
</ul>
</li>
</ol>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><strong>成功</strong>：如果函数执行成功，返回 <code>TRUE</code>，表示串口设备的超时设置已被成功应用。</li>
<li><strong>失败</strong>：如果函数执行失败，返回 <code>FALSE</code>，可以通过调用 <code>GetLastError()</code> 来获取更多错误信息。</li>
</ul>
<h3 id="COMMTIMEOUTS-结构体"><a href="#COMMTIMEOUTS-结构体" class="headerlink" title="COMMTIMEOUTS 结构体"></a><code>COMMTIMEOUTS</code> 结构体</h3><p><code>COMMTIMEOUTS</code> 结构体定义了串口设备读写操作的超时设置。结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_COMMTIMEOUTS</span> &#123;</span><br><span class="line">  DWORD ReadIntervalTimeout;         <span class="comment">// 读取字符间隔超时（毫秒）</span></span><br><span class="line">  DWORD ReadTotalTimeoutMultiplier;  <span class="comment">// 总读取超时乘子</span></span><br><span class="line">  DWORD ReadTotalTimeoutConstant;    <span class="comment">// 总读取超时常量（毫秒）</span></span><br><span class="line">  DWORD WriteTotalTimeoutMultiplier; <span class="comment">// 总写入超时乘子</span></span><br><span class="line">  DWORD WriteTotalTimeoutConstant;   <span class="comment">// 总写入超时常量（毫秒）</span></span><br><span class="line">&#125; COMMTIMEOUTS, *LPCOMMTIMEOUTS;</span><br></pre></td></tr></table></figure>

<h3 id="结构体字段详解"><a href="#结构体字段详解" class="headerlink" title="结构体字段详解"></a>结构体字段详解</h3><ol>
<li><p><strong><code>ReadIntervalTimeout</code></strong></p>
<ul>
<li>描述：指定两次字符读取之间的最大间隔时间。如果超出此时间，读取操作将完成。以毫秒为单位。</li>
<li>特殊值：<ul>
<li><code>MAXDWORD</code>：表示非零值的超时时间无效，系统返回立即可用的数据，而不等待进一步的数据输入。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>ReadTotalTimeoutMultiplier</code></strong></p>
<ul>
<li>描述：指定读取操作的超时乘子。实际的超时为乘子乘以读取的字符数。</li>
</ul>
</li>
<li><p><strong><code>ReadTotalTimeoutConstant</code></strong></p>
<ul>
<li>描述：指定读取操作的总超时常量。该值加上 <code>ReadTotalTimeoutMultiplier</code> 的结果为总读取超时时间。</li>
</ul>
</li>
<li><p><strong><code>WriteTotalTimeoutMultiplier</code></strong></p>
<ul>
<li>描述：指定写入操作的超时乘子。实际的超时为乘子乘以写入的字符数。</li>
</ul>
</li>
<li><p><strong><code>WriteTotalTimeoutConstant</code></strong></p>
<ul>
<li>描述：指定写入操作的总超时常量。该值加上 <code>WriteTotalTimeoutMultiplier</code> 的结果为总写入超时时间。</li>
</ul>
</li>
</ol>
<h3 id="使用示例-6"><a href="#使用示例-6" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开串口</span></span><br><span class="line">    HANDLE hSerial = <span class="built_in">CreateFile</span>(</span><br><span class="line">        <span class="string">&quot;COM1&quot;</span>,                        <span class="comment">// 串口名称</span></span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,  <span class="comment">// 读写权限</span></span><br><span class="line">        <span class="number">0</span>,                             <span class="comment">// 独占访问</span></span><br><span class="line">        <span class="literal">NULL</span>,                          <span class="comment">// 默认安全属性</span></span><br><span class="line">        OPEN_EXISTING,                 <span class="comment">// 打开现有串口</span></span><br><span class="line">        <span class="number">0</span>,                             <span class="comment">// 属性标志</span></span><br><span class="line">        <span class="literal">NULL</span>                           <span class="comment">// 不使用模板文件</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hSerial == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open COM port. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置串口超时参数</span></span><br><span class="line">    COMMTIMEOUTS timeouts = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    timeouts.ReadIntervalTimeout = <span class="number">50</span>;          <span class="comment">// 50ms 的字符间隔超时</span></span><br><span class="line">    timeouts.ReadTotalTimeoutMultiplier = <span class="number">10</span>;   <span class="comment">// 每个字符的读取时间为 10ms</span></span><br><span class="line">    timeouts.ReadTotalTimeoutConstant = <span class="number">100</span>;    <span class="comment">// 总读取操作的附加时间为 100ms</span></span><br><span class="line">    timeouts.WriteTotalTimeoutMultiplier = <span class="number">10</span>;  <span class="comment">// 每个字符的写入时间为 10ms</span></span><br><span class="line">    timeouts.WriteTotalTimeoutConstant = <span class="number">100</span>;   <span class="comment">// 总写入操作的附加时间为 100ms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">SetCommTimeouts</span>(hSerial, &amp;timeouts)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to set COM port timeouts. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hSerial);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;COM port timeouts configured successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行其他串口通信操作...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭串口</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSerial);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例中超时设置的逻辑"><a href="#解释示例中超时设置的逻辑" class="headerlink" title="解释示例中超时设置的逻辑"></a>解释示例中超时设置的逻辑</h3><ul>
<li><p><strong>读取超时</strong>：</p>
<ul>
<li><code>ReadIntervalTimeout = 50</code>：如果两次字符读取之间的间隔超过 50 毫秒，读取操作将结束。</li>
<li><code>ReadTotalTimeoutMultiplier = 10</code>：对于每个要读取的字符，设置 10 毫秒的超时。</li>
<li><code>ReadTotalTimeoutConstant = 100</code>：总读取超时常量为 100 毫秒。</li>
</ul>
<p>例如，如果要读取 5 个字符，总读取超时时间为：<code>(5 * 10) + 100 = 150</code> 毫秒。</p>
</li>
<li><p><strong>写入超时</strong>：</p>
<ul>
<li><code>WriteTotalTimeoutMultiplier = 10</code>：对于每个要写入的字符，设置 10 毫秒的超时。</li>
<li><code>WriteTotalTimeoutConstant = 100</code>：总写入超时常量为 100 毫秒。</li>
</ul>
<p>例如，如果要写入 5 个字符，总写入超时时间为：<code>(5 * 10) + 100 = 150</code> 毫秒。</p>
</li>
</ul>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>超时的适应性</strong>：设置的超时应根据实际应用的需要进行调整。如果超时设置得过短，可能会导致读取或写入操作过早地结束；而如果超时设置得过长，则可能会导致应用程序响应迟缓。</li>
<li><strong>特殊情况</strong>：如果串口通信中需要实时处理（如工业控制），则超时设置要特别小心，确保在通信故障时系统能够快速响应。</li>
</ul>
<h3 id="常见错误-1"><a href="#常见错误-1" class="headerlink" title="常见错误"></a>常见错误</h3><ul>
<li>**<code>ERROR_INVALID_HANDLE</code>**：无效的句柄，可能是因为串口未成功打开或句柄已关闭。</li>
<li>**<code>ERROR_INVALID_PARAMETER</code>**：传递给 <code>SetCommTimeouts</code> 的参数无效，可能是 <code>COMMTIMEOUTS</code> 结构体中的字段值不合理。</li>
</ul>
<p><code>SetCommTimeouts</code> 函数是配置串口通信设备超时的关键函数，通过合理设置，可以确保串口通信的有效性和可靠性，避免因超时问题导致的通信失败。</p>
<h2 id="windows-C-SetCommState-函数-详解"><a href="#windows-C-SetCommState-函数-详解" class="headerlink" title="windows C++ SetCommState()函数 详解"></a>windows C++ SetCommState()函数 详解</h2><p><code>SetCommState</code> 函数是 Windows API 中用于设置串口设备通信参数的一个函数。它可以修改串口设备的配置，如波特率、数据位、停止位和奇偶校验等。这对于串口通信非常重要，因为需要确保串口设备的设置与通信双方的要求一致。</p>
<h3 id="函数原型-8"><a href="#函数原型-8" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetCommState</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPDCB  lpDCB</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数详解-2"><a href="#参数详解-2" class="headerlink" title="参数详解"></a>参数详解</h3><ol>
<li><p><strong><code>hFile</code></strong></p>
<ul>
<li>类型：<code>HANDLE</code></li>
<li>描述：这是一个串口设备的句柄，通常由 <code>CreateFile</code> 函数获得，代表一个打开的串口通信端口（如 <code>&quot;COM1&quot;</code>）。</li>
</ul>
</li>
<li><p><strong><code>lpDCB</code></strong></p>
<ul>
<li>类型：<code>LPDCB</code></li>
<li>描述：指向 <code>DCB</code>（Device Control Block）结构的指针，该结构包含了串口设备的通信设置。通过 <code>SetCommState</code> 函数，你可以将这些设置应用到串口设备上。</li>
</ul>
</li>
</ol>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><strong>成功</strong>：如果函数执行成功，返回 <code>TRUE</code>，表示串口设备的配置已被成功修改。</li>
<li><strong>失败</strong>：如果函数执行失败，返回 <code>FALSE</code>，可以通过调用 <code>GetLastError()</code> 来获取更多错误信息。</li>
</ul>
<h3 id="DCB-结构体"><a href="#DCB-结构体" class="headerlink" title="DCB 结构体"></a><code>DCB</code> 结构体</h3><p><code>DCB</code> 结构体保存了串口设备的详细设置，如波特率、数据位、停止位、奇偶校验等。该结构体的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_DCB</span> &#123;</span><br><span class="line">  DWORD DCBlength;       <span class="comment">// DCB结构体大小</span></span><br><span class="line">  DWORD BaudRate;        <span class="comment">// 波特率</span></span><br><span class="line">  DWORD fBinary : <span class="number">1</span>;     <span class="comment">// 二进制模式，必须为 TRUE</span></span><br><span class="line">  DWORD fParity : <span class="number">1</span>;     <span class="comment">// 启用奇偶校验</span></span><br><span class="line">  DWORD fOutxCtsFlow : <span class="number">1</span>;<span class="comment">// CTS（清除发送）流控制</span></span><br><span class="line">  DWORD fOutxDsrFlow : <span class="number">1</span>;<span class="comment">// DSR（数据设置就绪）流控制</span></span><br><span class="line">  DWORD fDtrControl : <span class="number">2</span>; <span class="comment">// DTR（数据终端就绪）流控制</span></span><br><span class="line">  DWORD fDsrSensitivity : <span class="number">1</span>; <span class="comment">// DSR敏感性</span></span><br><span class="line">  DWORD fTXContinueOnXoff : <span class="number">1</span>; <span class="comment">// 在接收到XOFF时继续发送</span></span><br><span class="line">  DWORD fOutX : <span class="number">1</span>;       <span class="comment">// 启用XON/XOFF发送控制</span></span><br><span class="line">  DWORD fInX : <span class="number">1</span>;        <span class="comment">// 启用XON/XOFF接收控制</span></span><br><span class="line">  DWORD fErrorChar : <span class="number">1</span>;  <span class="comment">// 启用错误字符替换</span></span><br><span class="line">  DWORD fNull : <span class="number">1</span>;       <span class="comment">// 启用空字节丢弃</span></span><br><span class="line">  DWORD fRtsControl : <span class="number">2</span>; <span class="comment">// RTS（请求发送）流控制</span></span><br><span class="line">  DWORD fAbortOnError : <span class="number">1</span>; <span class="comment">// 发生错误时中止所有读写操作</span></span><br><span class="line">  DWORD fDummy2 : <span class="number">17</span>;    <span class="comment">// 保留</span></span><br><span class="line">  WORD  wReserved;       <span class="comment">// 保留</span></span><br><span class="line">  WORD  XonLim;          <span class="comment">// 传输XON字符之前输入缓冲区中最少的字节数</span></span><br><span class="line">  WORD  XoffLim;         <span class="comment">// 传输XOFF字符之前输入缓冲区中最多的字节数</span></span><br><span class="line">  BYTE  ByteSize;        <span class="comment">// 数据位数（4-8）</span></span><br><span class="line">  BYTE  Parity;          <span class="comment">// 奇偶校验设置（0-4 = 无，奇，偶，标记，空格）</span></span><br><span class="line">  BYTE  StopBits;        <span class="comment">// 停止位数（0,1,2 = 1位，1.5位，2位）</span></span><br><span class="line">  <span class="type">char</span>  XonChar;         <span class="comment">// XON字符</span></span><br><span class="line">  <span class="type">char</span>  XoffChar;        <span class="comment">// XOFF字符</span></span><br><span class="line">  <span class="type">char</span>  ErrorChar;       <span class="comment">// 错误字符（如果fErrorChar为TRUE）</span></span><br><span class="line">  <span class="type">char</span>  EofChar;         <span class="comment">// 文件结束字符</span></span><br><span class="line">  <span class="type">char</span>  EvtChar;         <span class="comment">// 事件字符</span></span><br><span class="line">  WORD  wReserved1;      <span class="comment">// 保留</span></span><br><span class="line">&#125; DCB, *LPDCB;</span><br></pre></td></tr></table></figure>

<h3 id="使用示例-7"><a href="#使用示例-7" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开串口</span></span><br><span class="line">    HANDLE hSerial = <span class="built_in">CreateFile</span>(</span><br><span class="line">        <span class="string">&quot;COM1&quot;</span>,                        <span class="comment">// 串口名称</span></span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,  <span class="comment">// 读写权限</span></span><br><span class="line">        <span class="number">0</span>,                             <span class="comment">// 独占访问</span></span><br><span class="line">        <span class="literal">NULL</span>,                          <span class="comment">// 默认安全属性</span></span><br><span class="line">        OPEN_EXISTING,                 <span class="comment">// 打开现有串口</span></span><br><span class="line">        <span class="number">0</span>,                             <span class="comment">// 属性标志</span></span><br><span class="line">        <span class="literal">NULL</span>                           <span class="comment">// 不使用模板文件</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hSerial == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open COM port. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前串口状态</span></span><br><span class="line">    DCB dcbSerialParams = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    dcbSerialParams.DCBlength = <span class="built_in">sizeof</span>(dcbSerialParams);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetCommState</span>(hSerial, &amp;dcbSerialParams)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to get COM port state. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hSerial);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置串口参数</span></span><br><span class="line">    dcbSerialParams.BaudRate = CBR_9600;   <span class="comment">// 设置波特率为9600</span></span><br><span class="line">    dcbSerialParams.ByteSize = <span class="number">8</span>;          <span class="comment">// 设置数据位为8</span></span><br><span class="line">    dcbSerialParams.StopBits = ONESTOPBIT; <span class="comment">// 设置停止位为1</span></span><br><span class="line">    dcbSerialParams.Parity   = NOPARITY;   <span class="comment">// 设置无奇偶校验</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置串口状态</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">SetCommState</span>(hSerial, &amp;dcbSerialParams)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to set COM port state. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hSerial);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;COM port configured successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行其他串口通信操作...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭串口</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSerial);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要字段详解"><a href="#主要字段详解" class="headerlink" title="主要字段详解"></a>主要字段详解</h3><ul>
<li>**<code>BaudRate</code>**：设置串口的波特率（例如 <code>CBR_9600</code> 表示 9600 bps）。</li>
<li>**<code>ByteSize</code>**：设置每个数据包的数据位数，可以是 4 到 8 位。</li>
<li>**<code>Parity</code>**：设置奇偶校验位，常用值包括 <code>NOPARITY</code> (0)，<code>ODDPARITY</code> (1)，<code>EVENPARITY</code> (2)。</li>
<li>**<code>StopBits</code>**：设置停止位数，常用值为 <code>ONESTOPBIT</code> (0)，<code>ONE5STOPBITS</code> (1)，<code>TWOSTOPBITS</code> (2)。</li>
<li>**<code>fBinary</code>**：必须设置为 <code>TRUE</code>，表示串口以二进制模式工作。</li>
<li>**<code>fParity</code>**：是否启用奇偶校验。</li>
</ul>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>结构体初始化</strong>：在调用 <code>SetCommState</code> 之前，确保 <code>DCB</code> 结构体的所有字段都已正确设置，特别是 <code>DCBlength</code> 字段应被设置为 <code>sizeof(DCB)</code>。</li>
<li><strong>获取和设置状态</strong>：通常在调用 <code>SetCommState</code> 之前，先使用 <code>GetCommState</code> 获取当前串口配置，然后对 <code>DCB</code> 结构体进行修改，并再调用 <code>SetCommState</code> 进行设置。</li>
<li><strong>波特率一致性</strong>：确保通信双方使用相同的波特率和其他通信参数，否则会导致通信失败或数据错误。</li>
</ul>
<h3 id="常见错误-2"><a href="#常见错误-2" class="headerlink" title="常见错误"></a>常见错误</h3><ul>
<li>**<code>ERROR_INVALID_HANDLE</code>**：无效的句柄，可能是因为串口未成功打开或句柄已关闭。</li>
<li>**<code>ERROR_BAD_COMMAND</code>**：请求的操作不能被串口设备执行，可能是由于串口不支持特定的配置。</li>
<li>**<code>ERROR_INVALID_PARAMETER</code>**：传递给 <code>SetCommState</code> 的参数无效，可能是 <code>DCB</code> 结构体中的字段值不合理。</li>
</ul>
<p><code>SetCommState</code> 是配置串口通信的核心函数，它允许你设置各种串口通信参数，以确保串口设备按照期望的方式工作。</p>
<h2 id="windows-C-GetCommState-函数-详解"><a href="#windows-C-GetCommState-函数-详解" class="headerlink" title="windows C++ GetCommState()函数 详解"></a>windows C++ GetCommState()函数 详解</h2><p><code>GetCommState</code> 函数是 Windows API 中用于获取串口通信设备当前配置的一个函数。它可以获取串口设备的通信参数，包括波特率、数据位、停止位和奇偶校验设置等。</p>
<h3 id="函数原型-9"><a href="#函数原型-9" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetCommState</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPDCB  lpDCB</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数详解-3"><a href="#参数详解-3" class="headerlink" title="参数详解"></a>参数详解</h3><ol>
<li><p><strong><code>hFile</code></strong></p>
<ul>
<li>类型：<code>HANDLE</code></li>
<li>描述：这是一个串口设备的句柄，通常由 <code>CreateFile</code> 函数获得，代表一个打开的串口通信端口（如 <code>&quot;COM1&quot;</code>）。</li>
</ul>
</li>
<li><p><strong><code>lpDCB</code></strong></p>
<ul>
<li>类型：<code>LPDCB</code></li>
<li>描述：指向 <code>DCB</code> 结构的指针，该结构用于存储串口设备的当前配置。<code>DCB</code> 结构保存了串口的详细设置，包括波特率、数据位、停止位、奇偶校验等。</li>
</ul>
</li>
</ol>
<h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><strong>成功</strong>：如果函数执行成功，返回 <code>TRUE</code>，并且 <code>lpDCB</code> 指向的结构体被填充为当前的串口配置。</li>
<li><strong>失败</strong>：如果函数执行失败，返回 <code>FALSE</code>，可以通过调用 <code>GetLastError()</code> 来获取更多错误信息。</li>
</ul>
<h3 id="DCB-结构体-1"><a href="#DCB-结构体-1" class="headerlink" title="DCB 结构体"></a><code>DCB</code> 结构体</h3><p><code>DCB</code>（Device Control Block）结构体包含了串口设备的配置信息。结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_DCB</span> &#123;</span><br><span class="line">  DWORD DCBlength;       <span class="comment">// DCB结构体大小</span></span><br><span class="line">  DWORD BaudRate;        <span class="comment">// 波特率</span></span><br><span class="line">  DWORD fBinary : <span class="number">1</span>;     <span class="comment">// 二进制模式，必须为 TRUE</span></span><br><span class="line">  DWORD fParity : <span class="number">1</span>;     <span class="comment">// 启用奇偶校验</span></span><br><span class="line">  DWORD fOutxCtsFlow : <span class="number">1</span>;<span class="comment">// CTS（清除发送）流控制</span></span><br><span class="line">  DWORD fOutxDsrFlow : <span class="number">1</span>;<span class="comment">// DSR（数据设置就绪）流控制</span></span><br><span class="line">  DWORD fDtrControl : <span class="number">2</span>; <span class="comment">// DTR（数据终端就绪）流控制</span></span><br><span class="line">  DWORD fDsrSensitivity : <span class="number">1</span>; <span class="comment">// DSR敏感性</span></span><br><span class="line">  DWORD fTXContinueOnXoff : <span class="number">1</span>; <span class="comment">// 在接收到XOFF时继续发送</span></span><br><span class="line">  DWORD fOutX : <span class="number">1</span>;       <span class="comment">// 启用XON/XOFF发送控制</span></span><br><span class="line">  DWORD fInX : <span class="number">1</span>;        <span class="comment">// 启用XON/XOFF接收控制</span></span><br><span class="line">  DWORD fErrorChar : <span class="number">1</span>;  <span class="comment">// 启用错误字符替换</span></span><br><span class="line">  DWORD fNull : <span class="number">1</span>;       <span class="comment">// 启用空字节丢弃</span></span><br><span class="line">  DWORD fRtsControl : <span class="number">2</span>; <span class="comment">// RTS（请求发送）流控制</span></span><br><span class="line">  DWORD fAbortOnError : <span class="number">1</span>; <span class="comment">// 发生错误时中止所有读写操作</span></span><br><span class="line">  DWORD fDummy2 : <span class="number">17</span>;    <span class="comment">// 保留</span></span><br><span class="line">  WORD  wReserved;       <span class="comment">// 保留</span></span><br><span class="line">  WORD  XonLim;          <span class="comment">// 传输XON字符之前输入缓冲区中最少的字节数</span></span><br><span class="line">  WORD  XoffLim;         <span class="comment">// 传输XOFF字符之前输入缓冲区中最多的字节数</span></span><br><span class="line">  BYTE  ByteSize;        <span class="comment">// 数据位数（4-8）</span></span><br><span class="line">  BYTE  Parity;          <span class="comment">// 奇偶校验设置（0-4 = 无，奇，偶，标记，空格）</span></span><br><span class="line">  BYTE  StopBits;        <span class="comment">// 停止位数（0,1,2 = 1位，1.5位，2位）</span></span><br><span class="line">  <span class="type">char</span>  XonChar;         <span class="comment">// XON字符</span></span><br><span class="line">  <span class="type">char</span>  XoffChar;        <span class="comment">// XOFF字符</span></span><br><span class="line">  <span class="type">char</span>  ErrorChar;       <span class="comment">// 错误字符（如果fErrorChar为TRUE）</span></span><br><span class="line">  <span class="type">char</span>  EofChar;         <span class="comment">// 文件结束字符</span></span><br><span class="line">  <span class="type">char</span>  EvtChar;         <span class="comment">// 事件字符</span></span><br><span class="line">  WORD  wReserved1;      <span class="comment">// 保留</span></span><br><span class="line">&#125; DCB, *LPDCB;</span><br></pre></td></tr></table></figure>

<h3 id="使用示例-8"><a href="#使用示例-8" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开串口</span></span><br><span class="line">    HANDLE hSerial = <span class="built_in">CreateFile</span>(</span><br><span class="line">        <span class="string">&quot;COM1&quot;</span>,                        <span class="comment">// 串口名称</span></span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,  <span class="comment">// 读写权限</span></span><br><span class="line">        <span class="number">0</span>,                             <span class="comment">// 独占访问</span></span><br><span class="line">        <span class="literal">NULL</span>,                          <span class="comment">// 默认安全属性</span></span><br><span class="line">        OPEN_EXISTING,                 <span class="comment">// 打开现有串口</span></span><br><span class="line">        <span class="number">0</span>,                             <span class="comment">// 属性标志</span></span><br><span class="line">        <span class="literal">NULL</span>                           <span class="comment">// 不使用模板文件</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hSerial == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open COM port. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取串口状态</span></span><br><span class="line">    DCB dcbSerialParams = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    dcbSerialParams.DCBlength = <span class="built_in">sizeof</span>(dcbSerialParams);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetCommState</span>(hSerial, &amp;dcbSerialParams)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to get COM port state. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hSerial);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出当前串口配置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Baud Rate: &quot;</span> &lt;&lt; dcbSerialParams.BaudRate &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Byte Size: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(dcbSerialParams.ByteSize) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Parity: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(dcbSerialParams.Parity) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stop Bits: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(dcbSerialParams.StopBits) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭串口</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSerial);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要字段详解-1"><a href="#主要字段详解-1" class="headerlink" title="主要字段详解"></a>主要字段详解</h3><ul>
<li>**<code>BaudRate</code>**：波特率，例如 9600、19200 等。</li>
<li>**<code>ByteSize</code>**：每个字节的数据位数，可以是 4 到 8。</li>
<li>**<code>Parity</code>**：奇偶校验位设置，常用值包括 <code>NOPARITY</code> (0)，<code>ODDPARITY</code> (1)，<code>EVENPARITY</code> (2)。</li>
<li>**<code>StopBits</code>**：停止位数，常用值为 <code>ONESTOPBIT</code> (0)，<code>ONE5STOPBITS</code> (1)，<code>TWOSTOPBITS</code> (2)。</li>
</ul>
<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>结构体初始化</strong>：在调用 <code>GetCommState</code> 之前，确保 <code>DCB</code> 结构体的 <code>DCBlength</code> 字段已被正确设置为 <code>sizeof(DCB)</code>。</li>
<li><strong>获取和设置状态</strong>：通常在调用 <code>GetCommState</code> 获取当前配置后，可以使用 <code>SetCommState</code> 修改配置并应用到串口设备上。</li>
<li><strong>设备句柄</strong>：确保传递给 <code>GetCommState</code> 的句柄是有效的，通常是通过 <code>CreateFile</code> 成功打开串口设备获得的句柄。</li>
</ul>
<h3 id="常见错误-3"><a href="#常见错误-3" class="headerlink" title="常见错误"></a>常见错误</h3><ul>
<li>**<code>ERROR_INVALID_HANDLE</code>**：无效的句柄，可能是因为串口未成功打开或句柄已关闭。</li>
<li>**<code>ERROR_BAD_COMMAND</code>**：请求的操作不能被串口设备执行，可能是由于串口不支持特定的配置。</li>
</ul>
<p><code>GetCommState</code> 函数在串口通信中非常重要，它让你能够读取和理解当前的串口配置，从而确保通信的正确性和稳定性。</p>
<h2 id="windows-C-SetupComm-函数-详解"><a href="#windows-C-SetupComm-函数-详解" class="headerlink" title="windows C++ SetupComm()函数 详解"></a>windows C++ SetupComm()函数 详解</h2><p><code>SetupComm</code> 函数是 Windows API 中用于配置串口设备缓冲区大小的一个函数。它主要用于设置串口通信时的输入和输出缓冲区的大小。这在处理串口通信时非常重要，因为适当配置的缓冲区可以避免数据丢失或溢出。</p>
<h3 id="函数原型-10"><a href="#函数原型-10" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetupComm</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  dwInQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  dwOutQueue</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数详解-4"><a href="#参数详解-4" class="headerlink" title="参数详解"></a>参数详解</h3><ol>
<li><p><strong><code>hFile</code></strong></p>
<ul>
<li>类型：<code>HANDLE</code></li>
<li>描述：这是一个串口设备的句柄。通常，该句柄由 <code>CreateFile</code> 函数获得，代表一个打开的串口通信端口（如 <code>&quot;COM1&quot;</code>）。</li>
</ul>
</li>
<li><p><strong><code>dwInQueue</code></strong></p>
<ul>
<li>类型：<code>DWORD</code></li>
<li>描述：指定输入缓冲区的大小（以字节为单位）。这个缓冲区用于存储从串口接收到的数据。</li>
</ul>
</li>
<li><p><strong><code>dwOutQueue</code></strong></p>
<ul>
<li>类型：<code>DWORD</code></li>
<li>描述：指定输出缓冲区的大小（以字节为单位）。这个缓冲区用于存储将要通过串口发送的数据。</li>
</ul>
</li>
</ol>
<h3 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><strong>成功</strong>：如果函数执行成功，返回 <code>TRUE</code>。</li>
<li><strong>失败</strong>：如果函数执行失败，返回 <code>FALSE</code>，可以通过调用 <code>GetLastError()</code> 来获取更多错误信息。</li>
</ul>
<h3 id="使用示例-9"><a href="#使用示例-9" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开串口</span></span><br><span class="line">    HANDLE hSerial = <span class="built_in">CreateFile</span>(</span><br><span class="line">        <span class="string">&quot;COM1&quot;</span>,                        <span class="comment">// 串口名称</span></span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,  <span class="comment">// 读写权限</span></span><br><span class="line">        <span class="number">0</span>,                             <span class="comment">// 独占访问</span></span><br><span class="line">        <span class="literal">NULL</span>,                          <span class="comment">// 默认安全属性</span></span><br><span class="line">        OPEN_EXISTING,                 <span class="comment">// 打开现有串口</span></span><br><span class="line">        <span class="number">0</span>,                             <span class="comment">// 属性标志</span></span><br><span class="line">        <span class="literal">NULL</span>                           <span class="comment">// 不使用模板文件</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hSerial == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open COM port. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置输入缓冲区为 1024 字节，输出缓冲区为 1024 字节</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">SetupComm</span>(hSerial, <span class="number">1024</span>, <span class="number">1024</span>)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to setup COM port buffers. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hSerial);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;COM port buffers setup successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行其他串口通信操作...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭串口</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSerial);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>缓冲区大小的设置</strong>：通常，输入和输出缓冲区的大小应根据应用程序的需求进行设置。较大的缓冲区可以容纳更多的数据，减少数据丢失的可能性，但也会占用更多的内存。</li>
<li><strong>句柄有效性</strong>：确保在调用 <code>SetupComm</code> 前，串口设备句柄是有效的。这意味着 <code>CreateFile</code> 成功打开了一个串口设备。</li>
<li><strong>缓冲区重设</strong>：如果需要更改缓冲区的大小，可以在打开串口设备后立即调用 <code>SetupComm</code>，以确保在任何数据传输之前正确配置缓冲区。</li>
</ul>
<h3 id="常见错误-4"><a href="#常见错误-4" class="headerlink" title="常见错误"></a>常见错误</h3><ul>
<li><strong><code>ERROR_INVALID_HANDLE</code></strong>: 提供的句柄无效，可能是因为串口未成功打开。</li>
<li><strong><code>ERROR_IO_PENDING</code></strong>: 该错误通常与重叠 I&#x2F;O 操作有关，但在使用 <code>SetupComm</code> 时并不常见。</li>
</ul>
<p><code>SetupComm</code> 是串口通信设置中的一个基础函数，正确配置它可以确保串口数据通信的稳定性和效率。</p>
<h2 id="windows-C-CreateFileA-函数-详解"><a href="#windows-C-CreateFileA-函数-详解" class="headerlink" title="windows C++ CreateFileA()函数 详解"></a>windows C++ CreateFileA()函数 详解</h2><p><code>CreateFileA</code> 函数是 Windows API 中用于打开或创建文件、文件夹、符号链接、命名管道、通信设备等的一种函数。<code>CreateFileA</code> 是其 ANSI 版本，对应的 Unicode 版本为 <code>CreateFileW</code>。以下是 <code>CreateFileA</code> 函数的详解。</p>
<h3 id="函数原型-11"><a href="#函数原型-11" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFileA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR               lpFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                dwShareMode,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                dwCreationDisposition,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                dwFlagsAndAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE               hTemplateFile</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数详解-5"><a href="#参数详解-5" class="headerlink" title="参数详解"></a>参数详解</h3><ol>
<li><p><strong><code>lpFileName</code></strong></p>
<ul>
<li>类型：<code>LPCSTR</code></li>
<li>描述：指向要打开或创建的对象的名称的指针。对于文件，这通常是文件的路径。如果是设备文件，则使用设备名称（例如 <code>&quot;\\\\.\\COM1&quot;</code>）。</li>
</ul>
</li>
<li><p><strong><code>dwDesiredAccess</code></strong></p>
<ul>
<li>类型：<code>DWORD</code></li>
<li>描述：指定所需的访问权限。可以是以下常量的组合：<ul>
<li><code>GENERIC_READ</code>：读取访问。</li>
<li><code>GENERIC_WRITE</code>：写入访问。</li>
<li><code>GENERIC_EXECUTE</code>：执行访问。</li>
<li><code>GENERIC_ALL</code>：所有访问权限。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>dwShareMode</code></strong></p>
<ul>
<li>类型：<code>DWORD</code></li>
<li>描述：指定文件的共享模式，决定其他进程如何访问该文件。可以是以下常量的组合：<ul>
<li><code>FILE_SHARE_READ</code>：允许其他进程读取文件。</li>
<li><code>FILE_SHARE_WRITE</code>：允许其他进程写入文件。</li>
<li><code>FILE_SHARE_DELETE</code>：允许其他进程删除文件。</li>
</ul>
</li>
<li>如果此参数为 0，文件将被独占使用。</li>
</ul>
</li>
<li><p><strong><code>lpSecurityAttributes</code></strong></p>
<ul>
<li>类型：<code>LPSECURITY_ATTRIBUTES</code></li>
<li>描述：指向 <code>SECURITY_ATTRIBUTES</code> 结构的指针，该结构指定返回的句柄是否可被子进程继承以及文件或对象的安全描述符。如果为 NULL，句柄不可继承，且对象没有指定的安全描述符。</li>
</ul>
</li>
<li><p><strong><code>dwCreationDisposition</code></strong></p>
<ul>
<li>类型：<code>DWORD</code></li>
<li>描述：指定如何创建或打开文件，以下是常用的选项：<ul>
<li><code>CREATE_NEW</code>：创建新文件。如果文件已存在，函数将失败。</li>
<li><code>CREATE_ALWAYS</code>：创建新文件。如果文件已存在，将覆盖该文件。</li>
<li><code>OPEN_EXISTING</code>：打开现有文件。如果文件不存在，函数将失败。</li>
<li><code>OPEN_ALWAYS</code>：打开文件，如果文件不存在则创建新文件。</li>
<li><code>TRUNCATE_EXISTING</code>：打开现有文件并截断（清空）文件内容。该文件必须有写入权限。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>dwFlagsAndAttributes</code></strong></p>
<ul>
<li>类型：<code>DWORD</code></li>
<li>描述：指定文件或设备的标志和属性。常用的标志包括：<ul>
<li><code>FILE_ATTRIBUTE_ARCHIVE</code>：文件归档属性。</li>
<li><code>FILE_ATTRIBUTE_HIDDEN</code>：文件为隐藏文件。</li>
<li><code>FILE_ATTRIBUTE_NORMAL</code>：无特殊属性集的文件。</li>
<li><code>FILE_ATTRIBUTE_READONLY</code>：只读文件。</li>
<li><code>FILE_FLAG_DELETE_ON_CLOSE</code>：文件在关闭时自动删除。</li>
<li><code>FILE_FLAG_SEQUENTIAL_SCAN</code>：访问模式为顺序扫描。</li>
<li><code>FILE_FLAG_RANDOM_ACCESS</code>：访问模式为随机访问。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>hTemplateFile</code></strong></p>
<ul>
<li>类型：<code>HANDLE</code></li>
<li>描述：用于指定一个有效的模板文件句柄，模板文件的属性将复制到新创建的文件中。该参数通常用于创建新文件时设置与模板文件相同的属性。如果不需要模板文件，设置为 <code>NULL</code>。</li>
</ul>
</li>
</ol>
<h3 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li>成功：返回一个指向新打开文件、设备、管道等的句柄 (<code>HANDLE</code>)。你可以使用此句柄进行读写操作。</li>
<li>失败：返回 <code>INVALID_HANDLE_VALUE</code>，可以调用 <code>GetLastError()</code> 获取详细的错误信息。</li>
</ul>
<h3 id="使用示例-10"><a href="#使用示例-10" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(</span><br><span class="line">        <span class="string">&quot;example.txt&quot;</span>,                 <span class="comment">// 文件名</span></span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,  <span class="comment">// 读写权限</span></span><br><span class="line">        <span class="number">0</span>,                             <span class="comment">// 独占模式，不共享</span></span><br><span class="line">        <span class="literal">NULL</span>,                          <span class="comment">// 默认安全属性</span></span><br><span class="line">        CREATE_ALWAYS,                 <span class="comment">// 总是创建新文件</span></span><br><span class="line">        FILE_ATTRIBUTE_NORMAL,         <span class="comment">// 普通文件</span></span><br><span class="line">        <span class="literal">NULL</span>                           <span class="comment">// 不使用模板文件</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create or open file. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File created/opened successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行文件操作...</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);  <span class="comment">// 关闭文件句柄</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>打开现有文件时，确保使用正确的权限设置（<code>dwDesiredAccess</code>），否则可能会导致访问失败。</li>
<li>如果文件被其他进程占用且未使用共享模式，你可能会遇到无法访问文件的情况。</li>
<li>在使用 <code>CreateFileA</code> 打开设备（如串口或并口）时，<code>lpFileName</code> 参数需要使用特定的格式（如 <code>&quot;\\\\.\\COM1&quot;</code>）。</li>
</ul>
<h3 id="常见错误-5"><a href="#常见错误-5" class="headerlink" title="常见错误"></a>常见错误</h3><ul>
<li><code>ERROR_FILE_NOT_FOUND</code>: 文件不存在，且未指定创建新文件。</li>
<li><code>ERROR_ACCESS_DENIED</code>: 权限不足，无法访问文件。</li>
</ul>
<p>这个函数的灵活性和多功能性使它在 Windows 编程中非常重要。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/09/03/notebook/Books/2024-09-03-Effective_Modern_C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/03/notebook/Books/2024-09-03-Effective_Modern_C++/" class="post-title-link" itemprop="url">Effective Modern C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-09-03 09:00:00" itemprop="dateCreated datePublished" datetime="2024-09-03T09:00:00+08:00">2024-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Effective Modern C++ 中文版学习笔记，Scott Meyers著作，高博译</li>
</ul>
<h2 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h2><ul>
<li>现代C++在语言方面所进行的大刀阔斧，釜底抽薪式的变革，无需赘言。但是这些变革背后，更重要的反而是其保持不变者，即所谓C++语言的精神，或曰设计哲学。例如，由实际问题驱动，并立刻用于解决实际问题。现代C++中提供了并发API，在语言层面上支持并发程序设计，结束了在各种体系结构和操作系统之上存在很多互不兼容的第三方并发库的乱局，就是这种设计哲学的体现。<strong>程序员应该能够自由地选择自己的程序设计风格，而语言应该为该风格提供完备的支持</strong>。</li>
<li>C++语言之难，主要还是在于众多语言特性之间的综合交叉。尤其对于新的语言特性，掌握其本身往往并不是很难，而要考虑到它与众多也已经存在的语言特性之发生的相互作用就不容易了。</li>
</ul>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul>
<li>本书的写作目的并非对于C++11和C++14特性的泛泛介绍，而是为了揭示他们的高效应用。</li>
<li>本书中的信息被分解成若干准则，称为条款。本书中的条款都是准则，而非规则，因为准则允许有例外。条款给出的建议并非最要紧的部分，建议背后的原理才是精华。只有掌握了原理，你才能判定，你的项目面临的具体情况是否真的违反了条款所指。<strong>本书的真正目标并不在于告诉你什么该做，什么不该做，而是想要传达对C++11和C++14运作原理的更深入理解</strong>。</li>
</ul>
<h2 id="术语和惯例"><a href="#术语和惯例" class="headerlink" title="术语和惯例"></a>术语和惯例</h2><ul>
<li><p>C++98缺乏并发支持(仅对C++98和C++03成立)</p>
</li>
<li><p>C++11支持lambda表达式(对C++11和C++14成立)</p>
</li>
<li><p>C++14提供了广义返回值性别推导(仅对C++14成立)</p>
</li>
<li><p>C++11被最广泛接受的特性可能莫过于移动语义，而移动语义的基础在于区分左值表达式和右值表达式。因为，一个对象是右值意味着能够对其实施移动语义，而左值则一般不然。从概念上说(实践上并不总是成立)，右值对应的是函数返回的临时对象，而左值对应的是可指涉的对象，而指涉的途径则无论通过名字，指针，还是左值引用皆可。</p>
</li>
<li><p>有一种甄别表达式是否左值的使用方法富有启发性，那就是检查能否取得该表达式的地址。如果可以取得，那么该表达式基本上可以断定是左值。如果不可以，则其通常是右值。这种方法之所以说富有启发性，是因为它让你记得，表达式的型别与它是左值还是右值没有关系。换言之，给定一型别T，则既有T型别的左值，也有T型别的右值。这一点在处理右值引用型别的形参时尤其要注意，因为该形参本身是个左值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);   <span class="comment">// rhs是个左值，尽管它具有右值引用型别</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>在Widget的移动构造函数内部对rhs取址完全没有问题，所以rhs是个左值，尽管它的型别属于右值引用(基于类似的理由，我们可以得知，任何形参都是左值)</p>
</li>
<li><p>若某对象是依据同一型别的另一对象初始化出来的，则该新对象称为提供初始化依据的对象的一个副本，即使该副本是由移动构造函数创建的。这样称呼情有可原，因为C++中并无术语用以区分某对象到底是经由复制否早函数创建的副本，还是经由移动构造函数创建的副本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(Widget w)</span></span>;    <span class="comment">// someFunc的形参w按值传递</span></span><br><span class="line">Widget wid;                 <span class="comment">// wid是Widget型别的某个对象</span></span><br><span class="line"><span class="built_in">someFunc</span>(wid);              <span class="comment">// 在这个对someFunc的调用中，w是wid经由复制构造函数创建的副本</span></span><br><span class="line"><span class="built_in">someFunc</span>(std::<span class="built_in">move</span>(wid));   <span class="comment">// 在这个对someFunc的调用中，w是wid经由移动构造函数创建的副本</span></span><br></pre></td></tr></table></figure></li>
<li><p>右值的副本经常经由移动构造函数创建，而左值的副本通常经由复制构造函数创建。这也就是说，如果你仅仅了解到某个对象是另一个对象的副本，则还不能判断构造这个副本要花费多少成本。</p>
</li>
<li><p>在函数调用中，调用方的表达式，称为函数的实参。实参的用处，是初始化函数的形参。</p>
</li>
<li><p>在上面someFunc的第一次调用中，实参是wid。而在第二次调用中，实参则是std::move(wid)。在两次调用中，形参都是w。</p>
</li>
<li><p>实参和形参有着重大的区别，因为形参都是左值，而用来作为其初始化依据的实参，则极可能是右值，也可能是左值。这一点在完美转发(perfect forwarding)的过程中尤其关系重大，在这样的一个过程中，传递给某个函数的实参会被传递给另一个函数，并保持其右值性(rvalueness)或左值性(lvalueness)</p>
</li>
<li><p>设计良好的函数都是异常安全的，这意味着它们至少会提供基本异常安全保证(即基本保证)。提供了基本保证的函数能够向调用者确保即使有异常抛出，程序的不变量不会受到影响(即不会有数据结构被破坏)，且不会发生资源泄露。而提供了强异常安全保证(即强保证)的函数则能够通过向调用者确保即使有异常抛出，程序状态会在调用前后保持不变。</p>
</li>
<li><p>当提及函数对象时，我通常意指某个对象，其型别支持operator()成员函数。换言之，就是说该对象表现得像个函数。进一步泛化这一术语的话，就涵盖了指涉到成员函数的指针，从而得到了所谓的可调用物。一般情况下，你可以不用关心这些含义之前的细微差别，函数指针也好，可调用物也罢，你只需要知道他们在C++中表示某种函数调用语法加以调用就行了。</p>
</li>
<li><p>经由lambda表达式创建的函数对象称为闭包，将lambda表达式和他们创建的闭包区分开来，意义不大，所以我经常把他们统称为lambda式。</p>
</li>
<li><p>相似的，我也很少区分函数模板(即用以生成函数的模板)和模板函数(即从函数模板生成的函数)。类模板和模板类的情形同上。</p>
</li>
<li><p>C++中有很多事物能够加以声明和定义。声明的作用是引入名字和型别，而不给出细节，例如存储位置或具体实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x;               <span class="comment">// 对象生命</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;               <span class="comment">// 类声明</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>; <span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>;           <span class="comment">// 限定作用域的枚举声明</span></span><br></pre></td></tr></table></figure></li>
<li><p>定义则会给出存储位置和具体实现的细节。</p>
</li>
<li><p>定义同时也可以当声明用。所以，除非某些场合非给出定义不可，我倾向于只使用声明。</p>
</li>
<li><p>我把函数声明的形参型别和返回值型别这部分定义为函数的签名，而函数名字和形参名字则不属于签名的组成部分。</p>
</li>
<li><p>函数声明除形参型别和返回值型别的其他组成元素(即可能存在的noexcept或constexpr)则被排除在外(noexcept和constexpr)</p>
</li>
<li><p>签名的官方定义与我给出的稍有不同，但是在本书中，我们定义的更加使用(官方定义有时会省区返回值型别)</p>
</li>
<li><p>标准有时会把某个操作的结果说成是未定义行为。意思是，其运行期行为不可预测，你当然会对这样的不确定性敬而远之。未定义行为的例子有，在方括号([])内使用越界值作为std::vector的下表，未初始化的迭代器实施提领操作，或者进入数据竞险(即两个或更多线程同时访问同一内存位置，且其中至少有一个执行写操作的情形)</p>
</li>
<li><p>我将内建的指针，就是new表达式返回的那些指针，称为萝指针。而与裸指针形成对照的，则是智能指针。智能指针通常都重载了指针提领运算符(operator-&gt;和operator*)</p>
</li>
</ul>
<h2 id="第一张-型别推导"><a href="#第一张-型别推导" class="headerlink" title="第一张 型别推导"></a>第一张 型别推导</h2><ul>
<li>C++98仅有一套型别推导规则，用于函数模板。C++11对这套规则进行了一些改动，并且增加了两套规则，一套用于auto，另一套用于decltype。后来，C++14又扩展了能够运用auto和decltype的语境。型别推导应用返回的不断普及，使得人们不惜再去写下那些不言自明或是完全冗余的型别。</li>
<li>想要使用现代C++高效编程，就离不开对型别推导操作的坚实理解。型别推导设计的语境实在不胜枚举: 在函数模板的调用中，在auto现身的大多数场景中，在decltype表达式中，特别是在C++14中那个神秘莫测的decltype(auto)结构中</li>
<li>本章解释了模板型别推导如何运作，auto的型别推导如何构建在此运作规则之上，以及decltype独特的型别推导规则。</li>
</ul>
<h3 id="条款一：理解模板型别推导"><a href="#条款一：理解模板型别推导" class="headerlink" title="条款一：理解模板型别推导"></a>条款一：理解模板型别推导</h3><ul>
<li>如果一个复杂系统的用户对于该系统的运作方式一无所知，然而却对其提供的服务表示满意，这就充分说明系统设计得好。</li>
<li>模板的型别推导，是现代C++最广泛应用的特性之一–auto的基础。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/09/03/notebook/C++/C++_11_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2024-09-03-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/03/notebook/C++/C++_11_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2024-09-03-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">单例模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-09-03 09:00:00" itemprop="dateCreated datePublished" datetime="2024-09-03T09:00:00+08:00">2024-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>单例模式相关学习笔记</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li><p>单例模式，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
</li>
<li><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
</li>
<li><p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。</p>
</li>
<li><p>注意：</p>
<ul>
<li>单例类只能有一个实例</li>
<li>单例类必须自己创建自己的唯一实例</li>
<li>单例类必须给所有其他对象提供这一实例</li>
</ul>
</li>
<li><p>单例模式是设计模式中最简单，最常见的一种。其主要目的是确保整个进程中，只有一个类的实例，并且提供一个统一的访问接口。常用于Logger类，通信接口类，线程池等。</p>
</li>
</ul>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ul>
<li>限制用户直接访问类的构造函数，提供一个统一的public接口获取单例对象</li>
<li>这里有一个先有鸡还是先有蛋的问题<ul>
<li>因为用户无法访问构造函数，所以无法创建对象</li>
<li>因为无法创建对象，所以不能调用普通的getInstance()方法来获取单例对象</li>
</ul>
</li>
<li>解决这个问题的方法很简单，将 getInstance() 定义为static即可(这也会限制getInstance()内只能访问类的静态成员)</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>所有的构造函数是private</li>
<li>拷贝构造，拷贝赋值运算符需要显示删除 &#x3D;delete，防止编译器自动合成</li>
</ul>
<h2 id="C-单例模式的几种实现方式"><a href="#C-单例模式的几种实现方式" class="headerlink" title="C++单例模式的几种实现方式"></a>C++单例模式的几种实现方式</h2><h3 id="版本一-饿汉式"><a href="#版本一-饿汉式" class="headerlink" title="版本一 饿汉式"></a>版本一 饿汉式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton1* <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;inst; &#125;</span><br><span class="line">    <span class="built_in">Singleton1</span>(<span class="type">const</span> Singleton1&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton1&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton1&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> Singleton1 inst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton1 Singleton1::inst;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个版本在程序启动时创建单例对象，即使没有使用也会创建，浪费资源。</li>
</ul>
<h3 id="版本二-懒汉式"><a href="#版本二-懒汉式" class="headerlink" title="版本二 懒汉式"></a>版本二 懒汉式</h3><ul>
<li>通过将单例对象的实例化会推迟到首次调用getInstance()，解决版本一的问题<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton2* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pSingleton) &#123;</span><br><span class="line">            pSingleton = <span class="keyword">new</span> <span class="built_in">Singleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton2</span>(<span class="type">const</span> Singleton2&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton2&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton2&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> Singleton2* pSingleton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton2* Singleton2::pSingleton = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="版本三-线程安全"><a href="#版本三-线程安全" class="headerlink" title="版本三 线程安全"></a>版本三 线程安全</h3><ul>
<li>在版本二中，如果多个线程同时调用getInstance()则有可能创建多个实例<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton3* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!pSingleton) &#123;</span><br><span class="line">            pSingleton = <span class="keyword">new</span> <span class="built_in">Singleton3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton3</span>(<span class="type">const</span> Singleton3&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton3&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton3&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton3</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> Singleton3* pSingleton;</span><br><span class="line">    <span class="type">static</span> mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton3* Singleton3::pSingleton = <span class="literal">nullptr</span>;</span><br><span class="line">mutex Singleton3::mtx;</span><br></pre></td></tr></table></figure></li>
<li>加锁可以解决线程安全的问题，但是版本三的问题在于效率太低，每次调用getInstance()都需要加锁，而加锁的开销又是相当高昂的</li>
</ul>
<h3 id="版本四-DCL-Double-Checked-Locking"><a href="#版本四-DCL-Double-Checked-Locking" class="headerlink" title="版本四 DCL(Double-Checked Locking)"></a>版本四 DCL(Double-Checked Locking)</h3><ul>
<li>版本四是版本三的改进版本，只有在指针为空的时候才会进行加锁，然后再次判断指针是否为空。而一旦首次初始化完成之后，指针不为空，则不再进行加锁。既保证了线程安全，又不会导致后续每次调用都产生锁的开销<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton4</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton4* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pSingleton) &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!pSingleton) &#123;</span><br><span class="line">                pSingleton = <span class="keyword">new</span> <span class="built_in">Singleton4</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton4</span>(<span class="type">const</span> Singleton4&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton4&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton4&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton4</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> Singleton4* pSingleton;</span><br><span class="line">    <span class="type">static</span> mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton4* Singleton4::pSingleton = <span class="literal">nullptr</span>;</span><br><span class="line">mutex Singleton4::mtx;</span><br></pre></td></tr></table></figure></li>
<li>DCL在很长一段时间内被认为是C++单例模式的最佳实践。但是也有文章表示DCL的正确性取决于内存模型。关于这部分的深入讨论可以参考以下两篇文章<ul>
<li><a target="_blank" rel="noopener" href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a></li>
<li><a target="_blank" rel="noopener" href="https://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/">https://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/</a></li>
</ul>
</li>
</ul>
<h3 id="版本五-Meyer’s-Singleton"><a href="#版本五-Meyer’s-Singleton" class="headerlink" title="版本五 Meyer’s Singleton"></a>版本五 Meyer’s Singleton</h3><ul>
<li>这个版本利用局部静态变量来实现单例模式。最早由C++大佬，Effective C++系列的作者Scott Meyers提出，因此也被称为Meyers’ Singleton</li>
<li>TLDR: 这就是C++11之后的单例模式最佳实践，没有之一<ul>
<li>最简洁： 不需要额外定义类的静态成员</li>
<li>线程安全：不需要额外加锁</li>
<li>没有烦人的指针</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton5</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton5&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton5 inst;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton5</span>(<span class="type">const</span> Singleton5&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton5&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton5&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton5</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/31/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-08-31-python_3_bs4%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/31/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-08-31-python_3_bs4%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">python_3_bs4模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-31 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-31T09:00:00+08:00">2024-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>python3 bs4模块相关笔记</li>
</ul>
<h2 id="python3-bs4模块-详解"><a href="#python3-bs4模块-详解" class="headerlink" title="python3 bs4模块 详解"></a>python3 bs4模块 详解</h2><p><code>BeautifulSoup</code> 是一个用于从HTML和XML文档中提取数据的Python库。它为用户提供了简单的API，使得解析、导航和搜索文档树变得更加直观和高效。以下是<code>BeautifulSoup</code>库的一些关键概念和使用方法的详细介绍。</p>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>首先，你需要安装 <code>BeautifulSoup4</code> 以及一个解析器库（例如 <code>lxml</code> 或 <code>html.parser</code>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4 lxml</span><br></pre></td></tr></table></figure>

<h3 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h3><h4 id="导入模块并创建-BeautifulSoup-对象"><a href="#导入模块并创建-BeautifulSoup-对象" class="headerlink" title="导入模块并创建 BeautifulSoup 对象"></a>导入模块并创建 <code>BeautifulSoup</code> 对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html_doc = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">&#x27;lxml&#x27;</span>)  <span class="comment"># 使用 lxml 解析器</span></span><br></pre></td></tr></table></figure>

<h3 id="3-基本导航"><a href="#3-基本导航" class="headerlink" title="3. 基本导航"></a>3. 基本导航</h3><p><code>BeautifulSoup</code> 提供了多种方式来导航和操作文档树。</p>
<h4 id="3-1-标签选择"><a href="#3-1-标签选择" class="headerlink" title="3.1 标签选择"></a>3.1 标签选择</h4><p>你可以使用标签名直接选择标签。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.title)  <span class="comment"># &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;</span></span><br><span class="line"><span class="built_in">print</span>(soup.title.name)  <span class="comment"># title</span></span><br><span class="line"><span class="built_in">print</span>(soup.title.string)  <span class="comment"># The Dormouse&#x27;s story</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-获取标签的属性"><a href="#3-2-获取标签的属性" class="headerlink" title="3.2 获取标签的属性"></a>3.2 获取标签的属性</h4><p>标签的属性可以当作字典来访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.a)  <span class="comment"># &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"><span class="built_in">print</span>(soup.a[<span class="string">&#x27;href&#x27;</span>])  <span class="comment"># http://example.com/elsie</span></span><br><span class="line"><span class="built_in">print</span>(soup.a[<span class="string">&#x27;class&#x27;</span>])  <span class="comment"># [&#x27;sister&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-直接子节点和所有子节点"><a href="#3-3-直接子节点和所有子节点" class="headerlink" title="3.3 直接子节点和所有子节点"></a>3.3 直接子节点和所有子节点</h4><p><code>contents</code> 属性可以返回直接子节点列表，<code>children</code> 可以用于遍历直接子节点，而 <code>descendants</code> 则会递归遍历所有子节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.body.contents)  <span class="comment"># 直接子节点</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> soup.body.children:</span><br><span class="line">    <span class="built_in">print</span>(child)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> descendant <span class="keyword">in</span> soup.body.descendants:</span><br><span class="line">    <span class="built_in">print</span>(descendant)</span><br></pre></td></tr></table></figure>

<h3 id="4-搜索文档树"><a href="#4-搜索文档树" class="headerlink" title="4. 搜索文档树"></a>4. 搜索文档树</h3><p><code>BeautifulSoup</code> 提供了几种查找文档树中特定元素的方法。</p>
<h4 id="4-1-find-all"><a href="#4-1-find-all" class="headerlink" title="4.1 find_all()"></a>4.1 <code>find_all()</code></h4><p>查找所有符合条件的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">links = soup.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">    <span class="built_in">print</span>(link[<span class="string">&#x27;href&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="4-2-find"><a href="#4-2-find" class="headerlink" title="4.2 find()"></a>4.2 <code>find()</code></h4><p>查找第一个符合条件的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first_link = soup.find(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(first_link[<span class="string">&#x27;href&#x27;</span>])  <span class="comment"># http://example.com/elsie</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-使用-CSS-选择器"><a href="#4-3-使用-CSS-选择器" class="headerlink" title="4.3 使用 CSS 选择器"></a>4.3 使用 CSS 选择器</h4><p>你可以使用 <code>.select()</code> 方法通过CSS选择器语法查找元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;p.title&#x27;</span>))  <span class="comment"># 选择类名为 title 的 &lt;p&gt; 标签</span></span><br></pre></td></tr></table></figure>

<h3 id="5-修改文档树"><a href="#5-修改文档树" class="headerlink" title="5. 修改文档树"></a>5. 修改文档树</h3><p><code>BeautifulSoup</code> 允许你直接修改文档内容。</p>
<h4 id="5-1-修改标签内容"><a href="#5-1-修改标签内容" class="headerlink" title="5.1 修改标签内容"></a>5.1 修改标签内容</h4><p>你可以直接修改标签的 <code>.string</code> 属性来更改其内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.title.string = <span class="string">&quot;New Title&quot;</span></span><br><span class="line"><span class="built_in">print</span>(soup.title)  <span class="comment"># &lt;title&gt;New Title&lt;/title&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-插入和删除标签"><a href="#5-2-插入和删除标签" class="headerlink" title="5.2 插入和删除标签"></a>5.2 插入和删除标签</h4><p>你可以使用 <code>append()</code>、<code>insert()</code>、<code>decompose()</code> 等方法来添加或删除标签。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new_tag = soup.new_tag(<span class="string">&quot;p&quot;</span>)</span><br><span class="line">new_tag.string = <span class="string">&quot;This is a new paragraph.&quot;</span></span><br><span class="line">soup.body.append(new_tag)  <span class="comment"># 添加新标签到 body</span></span><br><span class="line"></span><br><span class="line">soup.p.decompose()  <span class="comment"># 删除第一个 &lt;p&gt; 标签</span></span><br></pre></td></tr></table></figure>

<h3 id="6-输出修饰后的HTML"><a href="#6-输出修饰后的HTML" class="headerlink" title="6. 输出修饰后的HTML"></a>6. 输出修饰后的HTML</h3><p>修改完文档树后，你可以使用 <code>prettify()</code> 方法以缩进格式输出HTML。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.prettify())</span><br></pre></td></tr></table></figure>

<h3 id="7-使用示例"><a href="#7-使用示例" class="headerlink" title="7. 使用示例"></a>7. 使用示例</h3><p>一个简单的例子，展示如何提取所有链接，并打印它们的文本和链接地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Text: <span class="subst">&#123;link.string&#125;</span>, URL: <span class="subst">&#123;link[<span class="string">&#x27;href&#x27;</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="8-处理复杂的HTML"><a href="#8-处理复杂的HTML" class="headerlink" title="8. 处理复杂的HTML"></a>8. 处理复杂的HTML</h3><p><code>BeautifulSoup</code> 可以非常有效地处理和解析有错误或不完整的HTML。它会自动修复文档树，使其更易于解析。</p>
<hr>
<p>这就是 <code>BeautifulSoup</code> 库的基本使用方法和主要功能。通过这些方法，你可以轻松地从复杂的HTML文档中提取所需的信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/30/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-08-30-python_3_pandas%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-08-30-python_3_pandas%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">python_3_pandas模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-30 09:01:00" itemprop="dateCreated datePublished" datetime="2024-08-30T09:01:00+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>pandas模块相关笔记</li>
</ul>
<h2 id="python3-pandas模块-详解"><a href="#python3-pandas模块-详解" class="headerlink" title="python3 pandas模块 详解"></a>python3 pandas模块 详解</h2><p>Pandas 是 Python 数据分析中最常用的库之一，它提供了数据结构和数据分析工具，尤其擅长处理表格数据。以下是 Pandas 模块的一些详细介绍。</p>
<h3 id="1-安装-Pandas"><a href="#1-安装-Pandas" class="headerlink" title="1. 安装 Pandas"></a>1. 安装 Pandas</h3><p>在使用 Pandas 之前，你需要确保已经安装了它。可以使用以下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pandas</span><br></pre></td></tr></table></figure>

<h3 id="2-导入-Pandas"><a href="#2-导入-Pandas" class="headerlink" title="2. 导入 Pandas"></a>2. 导入 Pandas</h3><p>导入 Pandas 通常使用 <code>pd</code> 作为别名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>

<h3 id="3-核心数据结构"><a href="#3-核心数据结构" class="headerlink" title="3. 核心数据结构"></a>3. 核心数据结构</h3><h4 id="3-1-Series"><a href="#3-1-Series" class="headerlink" title="3.1 Series"></a>3.1 Series</h4><p><code>Series</code> 是 Pandas 的基本数据结构之一，它是一维的，类似于 Python 中的列表或字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个简单的 Series</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-DataFrame"><a href="#3-2-DataFrame" class="headerlink" title="3.2 DataFrame"></a>3.2 DataFrame</h4><p><code>DataFrame</code> 是 Pandas 中最重要的数据结构，它是一个二维的表格数据结构，可以理解为一个“表格”或“电子表格”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个简单的 DataFrame</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>],</span><br><span class="line">    <span class="string">&#x27;City&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Los Angeles&#x27;</span>, <span class="string">&#x27;Chicago&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h3 id="4-DataFrame-基本操作"><a href="#4-DataFrame-基本操作" class="headerlink" title="4. DataFrame 基本操作"></a>4. DataFrame 基本操作</h3><h4 id="4-1-查看数据"><a href="#4-1-查看数据" class="headerlink" title="4.1 查看数据"></a>4.1 查看数据</h4><ul>
<li><strong>头部和尾部</strong>：使用 <code>head()</code> 和 <code>tail()</code> 方法可以查看数据的前几行和最后几行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.head())  <span class="comment"># 默认前5行</span></span><br><span class="line"><span class="built_in">print</span>(df.tail(<span class="number">2</span>))  <span class="comment"># 最后2行</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>数据概览</strong>：使用 <code>info()</code> 和 <code>describe()</code> 方法可以获取 DataFrame 的基本信息和统计摘要。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.info())  <span class="comment"># 数据结构信息</span></span><br><span class="line"><span class="built_in">print</span>(df.describe())  <span class="comment"># 数值列的统计信息</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-选择数据"><a href="#4-2-选择数据" class="headerlink" title="4.2 选择数据"></a>4.2 选择数据</h4><ul>
<li><strong>选择列</strong>：可以通过列名选择特定列。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;Name&#x27;</span>])  <span class="comment"># 返回 Name 列</span></span><br><span class="line"><span class="built_in">print</span>(df[[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]])  <span class="comment"># 返回 Name 和 Age 列</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>选择行</strong>：使用 <code>loc</code> 和 <code>iloc</code> 方法选择特定的行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据标签选择</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="number">0</span>])  <span class="comment"># 返回第0行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据索引选择</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">0</span>])  <span class="comment"># 返回第0行</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-条件筛选"><a href="#4-3-条件筛选" class="headerlink" title="4.3 条件筛选"></a>4.3 条件筛选</h4><p>Pandas 提供了强大的条件筛选功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 筛选 Age 大于 30 的行</span></span><br><span class="line">filtered_df = df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(filtered_df)</span><br></pre></td></tr></table></figure>

<h3 id="5-数据清理"><a href="#5-数据清理" class="headerlink" title="5. 数据清理"></a>5. 数据清理</h3><h4 id="5-1-缺失值处理"><a href="#5-1-缺失值处理" class="headerlink" title="5.1 缺失值处理"></a>5.1 缺失值处理</h4><ul>
<li><strong>检测缺失值</strong>：使用 <code>isnull()</code> 和 <code>notnull()</code> 可以检测缺失值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.isnull())  <span class="comment"># 检查所有数据的缺失情况</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>填充缺失值</strong>：使用 <code>fillna()</code> 方法可以填充缺失值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_filled = df.fillna(<span class="number">0</span>)  <span class="comment"># 将缺失值填充为 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>删除缺失值</strong>：使用 <code>dropna()</code> 方法可以删除含有缺失值的行或列。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_dropped = df.dropna()  <span class="comment"># 删除含有缺失值的行</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-数据转换"><a href="#5-2-数据转换" class="headerlink" title="5.2 数据转换"></a>5.2 数据转换</h4><ul>
<li><strong>修改数据类型</strong>：使用 <code>astype()</code> 可以转换数据类型。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Age&#x27;</span>] = df[<span class="string">&#x27;Age&#x27;</span>].astype(<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符串操作</strong>：可以使用 <code>.str</code> 访问字符串方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Name&#x27;</span>] = df[<span class="string">&#x27;Name&#x27;</span>].<span class="built_in">str</span>.upper()  <span class="comment"># 将 Name 列的值全部转换为大写</span></span><br></pre></td></tr></table></figure>

<h3 id="6-数据分析"><a href="#6-数据分析" class="headerlink" title="6. 数据分析"></a>6. 数据分析</h3><h4 id="6-1-排序"><a href="#6-1-排序" class="headerlink" title="6.1 排序"></a>6.1 排序</h4><p>使用 <code>sort_values()</code> 方法可以对 DataFrame 进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_sorted = df.sort_values(by=<span class="string">&#x27;Age&#x27;</span>, ascending=<span class="literal">False</span>)  <span class="comment"># 按 Age 降序排列</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-分组操作"><a href="#6-2-分组操作" class="headerlink" title="6.2 分组操作"></a>6.2 分组操作</h4><p>使用 <code>groupby()</code> 方法可以对数据进行分组，并对每组数据进行聚合操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grouped = df.groupby(<span class="string">&#x27;City&#x27;</span>)[<span class="string">&#x27;Age&#x27;</span>].mean()  <span class="comment"># 按 City 分组，并计算 Age 的平均值</span></span><br><span class="line"><span class="built_in">print</span>(grouped)</span><br></pre></td></tr></table></figure>

<h4 id="6-3-合并数据"><a href="#6-3-合并数据" class="headerlink" title="6.3 合并数据"></a>6.3 合并数据</h4><p>Pandas 提供了 <code>merge()</code>、<code>concat()</code> 和 <code>join()</code> 等方法来合并数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并两个 DataFrame</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>], <span class="string">&#x27;value&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>], <span class="string">&#x27;value&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"></span><br><span class="line">merged_df = pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>)  <span class="comment"># 内连接</span></span><br><span class="line"><span class="built_in">print</span>(merged_df)</span><br></pre></td></tr></table></figure>

<h3 id="7-数据输入输出"><a href="#7-数据输入输出" class="headerlink" title="7. 数据输入输出"></a>7. 数据输入输出</h3><ul>
<li><strong>读取 CSV 文件</strong>：使用 <code>read_csv()</code> 方法可以从 CSV 文件读取数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>写入  文件</strong>：使用 <code>to_csv()</code> 方法可以将 DataFrame 保存为 CSV 文件。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.to_csv(<span class="string">&#x27;output.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h3 id="8-可视化"><a href="#8-可视化" class="headerlink" title="8. 可视化"></a>8. 可视化</h3><p>Pandas 可以与 Matplotlib、Seaborn 等库结合使用来生成图表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;Age&#x27;</span>].plot(kind=<span class="string">&#x27;hist&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="9-高级功能"><a href="#9-高级功能" class="headerlink" title="9. 高级功能"></a>9. 高级功能</h3><h4 id="9-1-透视表"><a href="#9-1-透视表" class="headerlink" title="9.1 透视表"></a>9.1 透视表</h4><p>使用 <code>pivot_table()</code> 方法可以生成透视表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pivot = df.pivot_table(values=<span class="string">&#x27;Age&#x27;</span>, index=<span class="string">&#x27;City&#x27;</span>, columns=<span class="string">&#x27;Name&#x27;</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(pivot)</span><br></pre></td></tr></table></figure>

<h4 id="9-2-时间序列分析"><a href="#9-2-时间序列分析" class="headerlink" title="9.2 时间序列分析"></a>9.2 时间序列分析</h4><p>Pandas 提供了强大的时间序列处理功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将列转换为日期格式</span></span><br><span class="line">df[<span class="string">&#x27;Date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;Date&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置索引为日期</span></span><br><span class="line">df.set_index(<span class="string">&#x27;Date&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行重采样</span></span><br><span class="line">df_resampled = df.resample(<span class="string">&#x27;M&#x27;</span>).mean()  <span class="comment"># 按月重采样</span></span><br></pre></td></tr></table></figure>

<h3 id="10-实用技巧"><a href="#10-实用技巧" class="headerlink" title="10. 实用技巧"></a>10. 实用技巧</h3><ul>
<li><strong>链式操作</strong>：Pandas 支持链式操作，可以将多个操作链式连接在一起，代码更简洁。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = df.dropna().sort_values(by=<span class="string">&#x27;Age&#x27;</span>).reset_index(drop=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 <code>.apply()</code> 函数</strong>：<code>apply()</code> 函数可以对 Series 或 DataFrame 应用自定义函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Age_plus_one&#x27;</span>] = df[<span class="string">&#x27;Age&#x27;</span>].apply(<span class="keyword">lambda</span> x: x + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>以上是 Pandas 模块的简要详解，Pandas 功能丰富，在实际应用中还可以深入学习更多高级用法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/30/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-08-30-python_3_selenium%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/30/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-08-30-python_3_selenium%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">python_3_selenium模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-30 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-30T09:00:00+08:00">2024-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>python3中selenium模块相关笔记</li>
</ul>
<h2 id="python3-selenium模块-详解"><a href="#python3-selenium模块-详解" class="headerlink" title="python3 selenium模块 详解"></a>python3 selenium模块 详解</h2><p><code>Selenium</code> 是一个流行的 Web 测试和自动化工具，通常用于通过编程方式控制浏览器执行各种任务。<code>Selenium</code> 提供了多种语言绑定，其中之一是 Python。通过 <code>selenium</code> 模块，你可以用 Python 编写脚本来自动化浏览器的操作，如填表、点击按钮、抓取数据等。</p>
<p>下面是 <code>Selenium</code> 模块的详细介绍，包括安装、基本用法以及常用功能。</p>
<h3 id="1-安装-Selenium"><a href="#1-安装-Selenium" class="headerlink" title="1. 安装 Selenium"></a>1. 安装 <code>Selenium</code></h3><p>要在 Python 中使用 <code>Selenium</code>，首先需要安装它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>

<h3 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a>2. 基本用法</h3><p>在使用 <code>Selenium</code> 之前，你还需要下载一个适用于你所用浏览器的 WebDriver。例如，如果你使用 Chrome 浏览器，你需要下载 ChromeDriver。</p>
<h4 id="2-1-导入模块并设置-WebDriver"><a href="#2-1-导入模块并设置-WebDriver" class="headerlink" title="2.1 导入模块并设置 WebDriver"></a>2.1 导入模块并设置 WebDriver</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Chrome WebDriver 的路径</span></span><br><span class="line">driver = webdriver.Chrome(executable_path=<span class="string">&#x27;/path/to/chromedriver&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个网页</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.example.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-2-查找元素"><a href="#2-2-查找元素" class="headerlink" title="2.2 查找元素"></a>2.2 查找元素</h4><p><code>Selenium</code> 提供多种方法来查找页面中的元素：</p>
<ul>
<li><code>find_element_by_id(id)</code></li>
<li><code>find_element_by_name(name)</code></li>
<li><code>find_element_by_xpath(xpath)</code></li>
<li><code>find_element_by_css_selector(css_selector)</code></li>
<li><code>find_element_by_tag_name(tag_name)</code></li>
<li><code>find_element_by_class_name(class_name)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找元素</span></span><br><span class="line">element = driver.find_element_by_id(<span class="string">&#x27;element_id&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对元素进行操作</span></span><br><span class="line">element.click()  <span class="comment"># 点击元素</span></span><br><span class="line">element.send_keys(<span class="string">&#x27;text&#x27;</span>)  <span class="comment"># 输入文本</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-与页面交互"><a href="#2-3-与页面交互" class="headerlink" title="2.3 与页面交互"></a>2.3 与页面交互</h4><ul>
<li><strong>点击按钮：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">button = driver.find_element_by_xpath(<span class="string">&#x27;//button[@id=&quot;submit&quot;]&#x27;</span>)</span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>输入文本：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_box = driver.find_element_by_name(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">input_box.send_keys(<span class="string">&#x27;Selenium Python&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>获取文本内容：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text = driver.find_element_by_tag_name(<span class="string">&#x27;h1&#x27;</span>).text</span><br><span class="line"><span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure>

<h3 id="3-常用功能"><a href="#3-常用功能" class="headerlink" title="3. 常用功能"></a>3. 常用功能</h3><h4 id="3-1-等待页面加载"><a href="#3-1-等待页面加载" class="headerlink" title="3.1 等待页面加载"></a>3.1 等待页面加载</h4><p>有时页面元素需要时间加载，<code>Selenium</code> 提供了两种等待机制：</p>
<ul>
<li><strong>隐式等待：</strong> 在设置的时间内等待元素加载完成。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 等待最多10秒</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>显式等待：</strong> 明确等待某个条件满足。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">    EC.presence_of_element_located((By.ID, <span class="string">&#x27;myElement&#x27;</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-处理弹窗"><a href="#3-2-处理弹窗" class="headerlink" title="3.2 处理弹窗"></a>3.2 处理弹窗</h4><p>可以用 <code>switch_to.alert</code> 来处理 JavaScript 弹窗：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert = driver.switch_to.alert</span><br><span class="line">alert.accept()  <span class="comment"># 接受弹窗</span></span><br><span class="line">alert.dismiss()  <span class="comment"># 关闭弹窗</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-处理多窗口"><a href="#3-3-处理多窗口" class="headerlink" title="3.3 处理多窗口"></a>3.3 处理多窗口</h4><p><code>Selenium</code> 允许在多个窗口或标签页之间切换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前窗口句柄</span></span><br><span class="line">main_window = driver.current_window_handle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有窗口句柄</span></span><br><span class="line">windows = driver.window_handles</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到新窗口</span></span><br><span class="line">driver.switch_to.window(windows[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h4 id="3-4-截图"><a href="#3-4-截图" class="headerlink" title="3.4 截图"></a>3.4 截图</h4><p>可以用 <code>save_screenshot</code> 方法截图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.save_screenshot(<span class="string">&#x27;screenshot.png&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-关闭浏览器"><a href="#4-关闭浏览器" class="headerlink" title="4. 关闭浏览器"></a>4. 关闭浏览器</h3><p>完成操作后，应该关闭浏览器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h3 id="5-完整示例"><a href="#5-完整示例" class="headerlink" title="5. 完整示例"></a>5. 完整示例</h3><p>以下是一个完整的示例，展示如何使用 <code>Selenium</code> 进行简单的搜索操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 WebDriver</span></span><br><span class="line">driver = webdriver.Chrome(executable_path=<span class="string">&#x27;/path/to/chromedriver&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 Google</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.google.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找搜索框并输入内容</span></span><br><span class="line">search_box = driver.find_element_by_name(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">search_box.send_keys(<span class="string">&#x27;Selenium Python&#x27;</span>)</span><br><span class="line">search_box.send_keys(Keys.RETURN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待搜索结果页面加载并获取结果</span></span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">results = driver.find_elements_by_xpath(<span class="string">&#x27;//h3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(result.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h3 id="6-高级功能"><a href="#6-高级功能" class="headerlink" title="6. 高级功能"></a>6. 高级功能</h3><p><code>Selenium</code> 还支持处理复杂的场景，如文件上传、拖放、iframe 操作等。了解这些功能可以通过官方文档或其他高级教程。</p>
<h3 id="7-参考文档"><a href="#7-参考文档" class="headerlink" title="7. 参考文档"></a>7. 参考文档</h3><p>你可以在 <a target="_blank" rel="noopener" href="https://www.selenium.dev/documentation/">Selenium 官方文档</a> 中找到更多详细的内容和使用示例。</p>
<h2 id="python3-selenium-WebDriver类-详解"><a href="#python3-selenium-WebDriver类-详解" class="headerlink" title="python3 selenium.WebDriver类 详解"></a>python3 selenium.WebDriver类 详解</h2><p><code>WebDriver</code> 类是 Selenium 中的核心类之一，用于控制和与浏览器交互。通过 <code>WebDriver</code> 类，您可以启动和操作各种浏览器（如 Chrome、Firefox、Safari 等），执行诸如打开网页、查找元素、模拟用户输入、点击、截屏等操作。</p>
<p>以下是 <code>WebDriver</code> 类的详细解释：</p>
<h3 id="1-WebDriver-类简介"><a href="#1-WebDriver-类简介" class="headerlink" title="1. WebDriver 类简介"></a>1. <code>WebDriver</code> 类简介</h3><p><code>WebDriver</code> 是一个抽象类，用于定义所有浏览器驱动程序（如 <code>ChromeDriver</code>、<code>FirefoxDriver</code> 等）必须实现的接口。通过 <code>WebDriver</code> 类，可以执行一系列浏览器操作，如导航、窗口管理、页面交互等。</p>
<h3 id="2-浏览器驱动初始化"><a href="#2-浏览器驱动初始化" class="headerlink" title="2. 浏览器驱动初始化"></a>2. 浏览器驱动初始化</h3><p>使用 <code>WebDriver</code> 类时，通常需要实例化一个特定浏览器的驱动程序。以下是几个常见的浏览器驱动初始化方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Chrome 浏览器驱动</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Firefox 浏览器驱动</span></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Safari 浏览器驱动</span></span><br><span class="line">driver = webdriver.Safari()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Edge 浏览器驱动</span></span><br><span class="line">driver = webdriver.Edge()</span><br></pre></td></tr></table></figure>

<h3 id="3-常用方法与属性"><a href="#3-常用方法与属性" class="headerlink" title="3. 常用方法与属性"></a>3. 常用方法与属性</h3><p><code>WebDriver</code> 类提供了许多方法和属性，用于控制和操作浏览器。以下是一些常用的方法和属性：</p>
<h4 id="3-1-页面导航"><a href="#3-1-页面导航" class="headerlink" title="3.1 页面导航"></a>3.1 页面导航</h4><ul>
<li><p><strong><code>get(url)</code></strong>: 导航到指定的 URL。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">&quot;https://www.example.com&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>current_url</code></strong>: 返回当前页面的 URL。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current_page_url = driver.current_url</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>title</code></strong>: 返回当前页面的标题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page_title = driver.title</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>back()</code></strong>: 模拟浏览器的后退按钮。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.back()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>forward()</code></strong>: 模拟浏览器的前进按钮。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.forward()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>refresh()</code></strong>: 刷新当前页面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.refresh()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-2-元素查找"><a href="#3-2-元素查找" class="headerlink" title="3.2 元素查找"></a>3.2 元素查找</h4><ul>
<li><p><strong><code>find_element_by_id(id)</code></strong>: 根据元素的 <code>id</code> 查找元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element = driver.find_element_by_id(<span class="string">&quot;element-id&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>find_element_by_name(name)</code></strong>: 根据元素的 <code>name</code> 属性查找元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element = driver.find_element_by_name(<span class="string">&quot;element-name&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>find_element_by_xpath(xpath)</code></strong>: 根据 XPath 表达式查找元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element = driver.find_element_by_xpath(<span class="string">&quot;//div[@class=&#x27;example&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>find_element_by_css_selector(selector)</code></strong>: 根据 CSS 选择器查找元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element = driver.find_element_by_css_selector(<span class="string">&quot;.example-class&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>find_elements_by_*</code></strong>: 对应于 <code>find_element_by_*</code> 的方法，用于查找多个符合条件的元素，返回一个元素列表。</p>
</li>
</ul>
<h4 id="3-3-浏览器窗口管理"><a href="#3-3-浏览器窗口管理" class="headerlink" title="3.3 浏览器窗口管理"></a>3.3 浏览器窗口管理</h4><ul>
<li><p><strong><code>maximize_window()</code></strong>: 最大化浏览器窗口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.maximize_window()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>minimize_window()</code></strong>: 最小化浏览器窗口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.minimize_window()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>set_window_size(width, height)</code></strong>: 设置浏览器窗口大小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.set_window_size(<span class="number">1024</span>, <span class="number">768</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>get_window_size()</code></strong>: 获取当前窗口大小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size = driver.get_window_size()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>switch_to.window(window_name)</code></strong>: 切换到指定的窗口或标签页。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.window(driver.window_handles[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-4-框架和窗口切换"><a href="#3-4-框架和窗口切换" class="headerlink" title="3.4 框架和窗口切换"></a>3.4 框架和窗口切换</h4><ul>
<li><p><strong><code>switch_to.frame(frame_reference)</code></strong>: 切换到指定的 iframe 或 frame。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.frame(<span class="string">&quot;frame-name&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>switch_to.default_content()</code></strong>: 退出 iframe 或 frame，返回到主页面内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.default_content()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-5-警告和弹出框处理"><a href="#3-5-警告和弹出框处理" class="headerlink" title="3.5 警告和弹出框处理"></a>3.5 警告和弹出框处理</h4><ul>
<li><p><strong><code>switch_to.alert</code></strong>: 切换到浏览器警告对话框（alert）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert = driver.switch_to.alert</span><br><span class="line">alert.accept()  <span class="comment"># 确认警告</span></span><br><span class="line">alert.dismiss()  <span class="comment"># 取消警告</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-6-执行-JavaScript"><a href="#3-6-执行-JavaScript" class="headerlink" title="3.6 执行 JavaScript"></a>3.6 执行 JavaScript</h4><ul>
<li><p><strong><code>execute_script(script, *args)</code></strong>: 在页面上执行 JavaScript 脚本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.execute_script(<span class="string">&quot;alert(&#x27;Hello, world!&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-7-截屏"><a href="#3-7-截屏" class="headerlink" title="3.7 截屏"></a>3.7 截屏</h4><ul>
<li><p><strong><code>save_screenshot(filename)</code></strong>: 截取当前窗口并保存为文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.save_screenshot(<span class="string">&quot;screenshot.png&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-关闭与退出"><a href="#4-关闭与退出" class="headerlink" title="4. 关闭与退出"></a>4. 关闭与退出</h3><ul>
<li><p><strong><code>close()</code></strong>: 关闭当前窗口。如果这是唯一的窗口，则会退出 WebDriver 会话。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>quit()</code></strong>: 关闭所有关联的窗口，并退出 WebDriver 会话。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-等待"><a href="#5-等待" class="headerlink" title="5. 等待"></a>5. 等待</h3><p>在 WebDriver 中，等待是一个非常重要的概念，尤其是在处理动态加载的网页内容时。Selenium 提供了两种等待方式：</p>
<h4 id="5-1-隐式等待"><a href="#5-1-隐式等待" class="headerlink" title="5.1 隐式等待"></a>5.1 隐式等待</h4><p>设置一个全局等待时间，WebDriver 会在查找元素时，轮询等待元素在指定时间内加载完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 等待最多10秒</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-显式等待"><a href="#5-2-显式等待" class="headerlink" title="5.2 显式等待"></a>5.2 显式等待</h4><p>显式等待指定某个条件，在指定时间内等待该条件满足。如果条件在超时时间内满足，继续执行；否则抛出异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">    EC.presence_of_element_located((By.ID, <span class="string">&quot;element-id&quot;</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h3><p>使用 <code>WebDriver</code> 时，可能会遇到各种异常，如元素未找到、超时、无效的 URL 等。Selenium 提供了一些常见的异常类：</p>
<ul>
<li><code>NoSuchElementException</code>: 元素未找到。</li>
<li><code>TimeoutException</code>: 操作超时。</li>
<li><code>WebDriverException</code>: 一般性的 WebDriver 错误。</li>
</ul>
<p>可以通过异常处理机制来捕获和处理这些错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    driver.find_element_by_id(<span class="string">&quot;non-existent-id&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Element not found!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-示例代码"><a href="#7-示例代码" class="headerlink" title="7. 示例代码"></a>7. 示例代码</h3><p>以下是一个简单的示例，展示了如何使用 <code>WebDriver</code> 类打开网页、查找元素并与之交互。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Chrome 浏览器</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开网页</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.example.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找元素并与之交互</span></span><br><span class="line">search_box = driver.find_element_by_name(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">search_box.send_keys(<span class="string">&quot;Selenium WebDriver&quot;</span>)</span><br><span class="line">search_box.submit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待页面加载完成</span></span><br><span class="line">driver.implicitly_wait(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取页面标题</span></span><br><span class="line"><span class="built_in">print</span>(driver.title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>WebDriver</code> 类是 Selenium 的核心，提供了丰富的功能来自动化浏览器操作。掌握 <code>WebDriver</code> 的各种方法和属性，是进行 Web 自动化测试的基础。</p>
<h2 id="python3-WebDriver-get-函数-详解"><a href="#python3-WebDriver-get-函数-详解" class="headerlink" title="python3 WebDriver.get()函数 详解"></a>python3 WebDriver.get()函数 详解</h2><p><code>WebDriver.get()</code> 是 Selenium WebDriver 的一个函数，用于让 WebDriver 导航到指定的 URL（即加载网页）。该函数是自动化浏览器操作的基础之一。以下是 <code>WebDriver.get()</code> 函数的详细说明：</p>
<h3 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webdriver.get(url)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>webdriver</code> 是你初始化的浏览器对象（例如 Chrome、Firefox 等）。</li>
<li><code>url</code> 是你希望 WebDriver 加载的网页的 URL，它必须是一个字符串。</li>
</ul>
<h3 id="2-参数说明"><a href="#2-参数说明" class="headerlink" title="2. 参数说明"></a>2. 参数说明</h3><ul>
<li><strong>url</strong>: 这是一个字符串，表示你想让 WebDriver 打开的网页地址。该 URL 必须以 <code>http://</code> 或 <code>https://</code> 开头。如果没有指定协议，WebDriver 将不会加载页面，并且可能抛出异常。</li>
</ul>
<h3 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h3><ul>
<li>该方法没有返回值。WebDriver 将会打开指定的 URL，并在页面完全加载后继续执行后续代码。</li>
</ul>
<h3 id="4-常见用途"><a href="#4-常见用途" class="headerlink" title="4. 常见用途"></a>4. 常见用途</h3><ul>
<li><p><strong>打开网页</strong>: 这是 <code>WebDriver.get()</code> 最常见的用途，用于在浏览器中导航到特定的网页。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 WebDriver</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开网页</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.example.com&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>与其他 WebDriver 操作结合</strong>: 在加载页面后，通常会执行其他操作，如查找元素、执行 JavaScript 等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;https://www.example.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找页面中的元素</span></span><br><span class="line">element = driver.find_element_by_id(<span class="string">&quot;example-id&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行其他操作</span></span><br><span class="line">element.click()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h3><ul>
<li><p><strong>等待页面加载</strong>: <code>WebDriver.get()</code> 会等待页面的完全加载，即等待所有同步加载的资源（HTML、CSS、JavaScript 等）都加载完成后，才会继续执行下一行代码。但是，某些动态内容（例如通过 AJAX 加载的数据）可能需要手动等待。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&quot;https://www.example.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待某个元素加载完成</span></span><br><span class="line">WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">    EC.presence_of_element_located((<span class="string">&quot;id&quot;</span>, <span class="string">&quot;example-id&quot;</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常处理</strong>: 如果给定的 URL 格式不正确，或由于其他原因无法加载页面，WebDriver 可能会抛出异常（如 <code>WebDriverException</code>）。在实际应用中，可以通过异常处理机制捕获并处理这些错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    driver.get(<span class="string">&quot;invalid-url&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;An error occurred: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-关闭-WebDriver"><a href="#6-关闭-WebDriver" class="headerlink" title="6. 关闭 WebDriver"></a>6. 关闭 WebDriver</h3><p>在使用完 WebDriver 后，应该调用 <code>quit()</code> 方法来关闭浏览器并释放资源。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>WebDriver.get()</code> 是 Selenium WebDriver 中非常基本且重要的函数，用于导航到指定网页。理解和正确使用这个方法，是自动化浏览器操作的基础。</p>
<h2 id="python3-WebDriver-delete-all-cookies-函数-详解"><a href="#python3-WebDriver-delete-all-cookies-函数-详解" class="headerlink" title="python3 WebDriver.delete_all_cookies()函数 详解"></a>python3 WebDriver.delete_all_cookies()函数 详解</h2><p><code>WebDriver.delete_all_cookies()</code> 是 Selenium WebDriver 中的一个函数，用于删除当前会话中的所有 cookies。下面是对该函数的详细解释：</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><code>delete_all_cookies()</code> 方法的主要功能是在自动化测试过程中清除浏览器中所有的 cookies。Cookies 是存储在浏览器中的小数据文件，通常用于保持用户登录状态、存储用户偏好等。在某些测试场景中，可能需要删除这些 cookies 以确保测试的独立性和一致性。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 WebDriver 实例</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开某个网页</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.example.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有 cookies</span></span><br><span class="line">driver.delete_all_cookies()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续执行其他操作</span></span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>清除会话数据</strong>: 当你希望从一个干净的状态开始测试时，可以使用 <code>delete_all_cookies()</code> 来清除所有的 session 信息。</li>
<li><strong>模拟不同用户登录</strong>: 在测试不同用户登录时，删除 cookies 可以防止前一个用户的会话信息干扰到下一个用户。</li>
<li><strong>重置浏览器状态</strong>: 在多步骤的测试中，删除 cookies 可以帮助重置浏览器状态，以确保每个步骤都从同一初始状态开始。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>这个方法会删除当前会话的所有 cookies，并且在调用 <code>delete_all_cookies()</code> 之后，如果页面依赖 cookies 工作，可能需要重新加载页面或者重新设置 cookies。</li>
<li>删除 cookies 不会影响浏览器的历史记录或缓存，只会影响 cookies。</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li><strong>删除后无效</strong>: 如果删除 cookies 后仍然看到之前的数据，可能是因为浏览器的缓存问题，建议同时清除缓存。</li>
<li><strong>权限问题</strong>: 某些 cookies 可能由于安全设置而无法删除，这通常涉及到跨域或安全标志的 cookies。</li>
</ul>
<p>通过使用 <code>delete_all_cookies()</code>，你可以确保在不同的测试场景中拥有一个干净的环境，从而提高测试的准确性和可靠性。</p>
<h2 id="python3-WebDriver-find-elements-函数-详解"><a href="#python3-WebDriver-find-elements-函数-详解" class="headerlink" title="python3 WebDriver.find_elements()函数 详解"></a>python3 WebDriver.find_elements()函数 详解</h2><p><code>WebDriver.find_elements()</code> 是 Selenium WebDriver 中用于查找网页元素的一个函数。它返回符合特定定位策略的所有元素列表。如果没有找到任何元素，则返回空列表。</p>
<h3 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elements = driver.find_elements(by=By.XPATH, value=<span class="string">&quot;//tag[@attribute=&#x27;value&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>by</code>: 用于指定查找元素的方式，通常使用 <code>By</code> 类提供的常量，例如 <code>By.ID</code>, <code>By.NAME</code>, <code>By.XPATH</code> 等。</li>
<li><code>value</code>: 一个字符串，指定如何根据 <code>by</code> 参数查找元素的值。例如，如果 <code>by=By.ID</code>，那么 <code>value</code> 就是对应的元素 <code>id</code> 值。</li>
</ul>
<h3 id="常用的-By-定位方式"><a href="#常用的-By-定位方式" class="headerlink" title="常用的 By 定位方式"></a>常用的 <code>By</code> 定位方式</h3><ul>
<li><code>By.ID</code>: 通过元素的 <code>id</code> 属性定位元素。</li>
<li><code>By.NAME</code>: 通过元素的 <code>name</code> 属性定位元素。</li>
<li><code>By.CLASS_NAME</code>: 通过元素的 <code>class</code> 属性定位元素。</li>
<li><code>By.TAG_NAME</code>: 通过元素的标签名定位元素。</li>
<li><code>By.LINK_TEXT</code>: 通过元素的文本内容（超链接）定位元素。</li>
<li><code>By.PARTIAL_LINK_TEXT</code>: 通过部分文本内容定位超链接。</li>
<li><code>By.XPATH</code>: 通过 XPath 表达式定位元素。</li>
<li><code>By.CSS_SELECTOR</code>: 通过 CSS 选择器定位元素。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>List[WebElement]</code>: 由所有匹配元素组成的列表。如果没有找到元素，返回空列表。</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 WebDriver（比如使用 Chrome 浏览器）</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个网址</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.example.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 find_elements() 查找元素列表</span></span><br><span class="line">elements = driver.find_elements(By.CLASS_NAME, <span class="string">&quot;example-class&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历并操作元素</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">    <span class="built_in">print</span>(element.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 WebDriver</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>与 <code>find_element()</code> 不同，<code>find_elements()</code> 不会抛出 <code>NoSuchElementException</code> 异常。如果没有找到元素，返回的是一个空列表。</li>
<li><code>find_elements()</code> 查找所有符合条件的元素，而 <code>find_element()</code> 仅返回第一个匹配的元素。</li>
</ul>
<p>通过 <code>find_elements()</code>，可以轻松地处理网页中的多个相似元素，比如同一类的按钮、表单元素等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/29/notebook/OpenCV/opencv_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-08-29-VideoCapture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/29/notebook/OpenCV/opencv_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-08-29-VideoCapture/" class="post-title-link" itemprop="url">VideoCapture</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-29 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-29T09:00:00+08:00">2024-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenCV/" itemprop="url" rel="index"><span itemprop="name">OpenCV</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>OpenCV中 VideoCapture类学习笔记</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/29/notebook/OpenCV/opencv_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-08-29-VideoCapture/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/28/notebook/CMake/cmake_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-08-28-1_02_MasteringCMake/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/28/notebook/CMake/cmake_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-08-28-1_02_MasteringCMake/" class="post-title-link" itemprop="url">MasteringCMake</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-28 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-28T09:00:00+08:00">2024-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cmake官方文档: MasteringCMake 阅读笔记</li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul>
<li>CMake在构建项目时有两个主要的目录: 源代码目录和二进制目录<ul>
<li>源代码目录是存放项目源代码的位置</li>
<li>二进制目录，有时候也成为build目录，是CMake存放最终对象文件，库和可执行文件的位置。</li>
</ul>
</li>
<li>CMake不会向源代码目录写任何文件，只会向二进制目录写文件。</li>
</ul>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><ul>
<li>CMake用各种各样的本地开发工具，将一个或多个CMakeLists 文件作为输入，并生成项目文件或者Makefile使用</li>
<li>下面是典型的CMake处理流程<ul>
<li>项目定义一个或多个CMakeLists文件</li>
<li>CMake配置并生成项目文件</li>
<li>用户按需使用本地开发工具构建项目</li>
</ul>
</li>
</ul>
<h2 id="CMakeLists文件"><a href="#CMakeLists文件" class="headerlink" title="CMakeLists文件"></a>CMakeLists文件</h2><ul>
<li>CMakeLists文件是包含使用CMake语言描述项目的文本文件。</li>
<li>CMake语言表示为一系列的注释，命令和变量。</li>
<li>CMake为什么要有自己的语言？<ul>
<li>因为CMake如果依赖于其他语言，例如Python，就需要在使用CMake时安装其他语言。</li>
<li>有CMake语言能够更高效，更方便。</li>
</ul>
</li>
</ul>
<h2 id="CMake中的Hello-World"><a href="#CMake中的Hello-World" class="headerlink" title="CMake中的Hello World"></a>CMake中的Hello World</h2><ul>
<li><p>示例</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(Hello)</span><br><span class="line"><span class="keyword">add_executable</span>(Hello Hello.c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>CMakeLists文件第一行总会是 cmake_minimum_requried.这使得CMake可以使用指定的版本。</p>
</li>
<li><p>第二行应该是 project 命令。这个命令设置项目的名字，也可以指定其他的参数，例如语言，版本。</p>
</li>
<li><p>最后使用 add_executable 命令用这些给定的源代码文件生成项目的可执行对象。</p>
</li>
</ul>
<h2 id="为CMake指定编译器"><a href="#为CMake指定编译器" class="headerlink" title="为CMake指定编译器"></a>为CMake指定编译器</h2><ul>
<li><p>环境变量 CC 用来指定 C编译器</p>
</li>
<li><p>环境变量 CXX 用来指定 C++编译器</p>
</li>
<li><p>可以在命令行中通过使用 -DCMAKE_CXX_COMPILER&#x3D;cl 来指定编译器</p>
</li>
<li><p>设置 LDFLAGS 用来初始化 链接参数</p>
</li>
<li><p>设置 CXXFLAGS 用来初始化 CMAKE_CXX_FLAGS</p>
</li>
<li><p>设置 CFLAGS 用来初始化 CMAKE_C_FLAGS</p>
</li>
</ul>
<h2 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h2><ul>
<li>构建配置允许以不同的方式构建项目。CMake默认支持的方式有: Debug, Release, MinSizeRel, RelWithDebInfo<ul>
<li>Debug: 打开了基本的调试符号</li>
<li>Release: 打开了基本的优化</li>
<li>MinSizeRel: 产生最小的，但不一定是最快的目标文件</li>
<li>RelWithDebInfo: 既有调试信息，也开启了优化的目标文件</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/27/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-08-27-spdlog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/27/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-08-27-spdlog/" class="post-title-link" itemprop="url">spdlog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-27 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-27T09:00:00+08:00">2024-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="输出文件名和行号"><a href="#输出文件名和行号" class="headerlink" title="输出文件名和行号"></a>输出文件名和行号</h2><ul>
<li>使用宏，例如SPDLOG_INFO</li>
</ul>
<h2 id="使用宏函数输出的日志也写入到文件"><a href="#使用宏函数输出的日志也写入到文件" class="headerlink" title="使用宏函数输出的日志也写入到文件"></a>使用宏函数输出的日志也写入到文件</h2><ul>
<li>使用函数 spdlog::set_default_logger();</li>
<li>示例如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">InitLogger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建控制台日志记录器</span></span><br><span class="line">    <span class="keyword">auto</span> console_sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_color_sink_mt&gt;();</span><br><span class="line">    console_sink-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br><span class="line"></span><br><span class="line">    console_sink-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;[%Y-%m-%d %H:%M:%S.%e][thread %t][%s:%#][%l]: %v&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件日志记录器: 滚动记录，最大文件5M，文件数量100个</span></span><br><span class="line">    std::string log_path = ROOT_PATH;</span><br><span class="line">    log_path += <span class="string">&quot;logs/rotating.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> rotating_sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt;(log_path, <span class="number">1048576</span> * <span class="number">5</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步记录器，</span></span><br><span class="line">    std::vector&lt;spdlog::sink_ptr&gt; sinks&#123; console_sink, rotating_sink &#125;;</span><br><span class="line">    <span class="keyword">auto</span> logger = std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">&quot;logger&quot;</span>, sinks.<span class="built_in">begin</span>(), sinks.<span class="built_in">end</span>());</span><br><span class="line">    spdlog::<span class="built_in">register_logger</span>(logger); <span class="comment">//注册为全局日志，通过log_write访问;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宏相关配置</span></span><br><span class="line">    spdlog::<span class="built_in">set_default_logger</span>(logger);</span><br><span class="line">    spdlog::<span class="built_in">set_pattern</span>(<span class="string">&quot;[%Y-%m-%d %H:%M:%S.%e][thread %t][%s:%#][%l]: %v&quot;</span>);</span><br><span class="line">    spdlog::<span class="built_in">set_level</span>(spdlog::level::warn);</span><br><span class="line">    spdlog::<span class="built_in">flush_every</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>)); <span class="comment">//每3s刷新一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><p>logger: 日志对象，每个日志内包含一个sink组成的vector，每个sink可以分别设置优先级，logger本身也可设置优先级。</p>
</li>
<li><p>sink: 直译是水槽，实际上是引流的对象或者可以认为是输出目标，spdlog库内置了多种不同类型的logger可供选择</p>
</li>
<li><p>formatter: 格式化对象，绝大部分情况下spdlog默认的格式就足够用了，但是如果有个性化需求，可以进行自定义格式</p>
</li>
<li><p>level: 日志级别，不同的日志库可能会有不同的设置，但是基本情况下都会有debug,info,warn,error等级别划分来处理不同的情况，具体各个级别的情况可以根据自己的实际情况选取</p>
</li>
<li><p>逻辑关系</p>
<ul>
<li>每个logger包含一个vector,该vector由一个或者多个 std::shared_ptr<sink> 组成，logger的每条日志都会调用sink对象，由sink对象按照formatter的格式输出到指定的地方(有可能是控制台，文件等)</li>
</ul>
</li>
</ul>
<h2 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h2><ul>
<li>formatter也即是格式化对象，用于控制日志的输出格式，spdlog自带了默认的formatter，一般情况下，我们无需任何修改，直接使用即可。需要注意的是，每个sink会有一个formatter</li>
<li>默认formatter的格式为: [日期时间][logger名][log级别]log内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2022-10-13 17:00:55.795] [service] [debug] found env XXXXXXX : true</span><br><span class="line">[2022-10-13 17:00:55.795] [func_config] [debug] kafka_brokers : localhost:9092</span><br><span class="line">[2022-10-13 17:00:55.795] [func_config] [debug] kafka_main_topic : kafka_test</span><br><span class="line">[2022-10-13 17:00:55.795] [func_config] [debug] kafka_partition_value : -1</span><br><span class="line">[2022-10-13 17:00:55.795] [service] [info] initialized</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="sink"><a href="#sink" class="headerlink" title="sink"></a>sink</h2><ul>
<li><p>每个sink对应着一个输出目标和输出格式，它内部包含一个formatter，输出目标可以是控制台，文件等地方。</p>
</li>
<li><p>所有的sink都在命名空间spdlog::sinks下，可以自行探索</p>
</li>
<li><p>spdlog中创建控制台sink非常简单，该方式创建的sink会输出到命令行终端，且是彩色的。后缀的 _mt 代表多线程， _st 代表单线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sink1 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_color_sink_mt&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件sink的类型有很多，这里展示几种经典类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sink1 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::basic_file_sink_mt&gt;(log_file_name);<span class="comment">//最简单的文件sink，只需要指定文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sink2 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::daily_file_sink_mt&gt;(log_file_name, path, <span class="number">14</span>, <span class="number">22</span>);<span class="comment">//每天的14点22分在path下创建新的文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sink3 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt;(log_file_name, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>, <span class="number">100</span>, <span class="literal">false</span>);<span class="comment">//轮转文件，一个文件满了会写到下一个文件，第二个参数是单文件大小上限，第三个参数是文件数量最大值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他sink</p>
<ul>
<li>ostream_sink</li>
<li>syslog_sink</li>
</ul>
</li>
<li><p>sink的flush问题</p>
<ul>
<li>创建好sink后建议设置flush方式，否则可能无法立刻在文件中看到logger的内容</li>
<li>以下为两种重要的flush方式设置(直接设置全局)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">flush_every</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">spdlog::<span class="built_in">flush_on</span>(spdlog::level::debug);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h2><ul>
<li><p>日志对象，每个logger内容包含了一个vector用于存放sink，每个sink都是互相独立</p>
</li>
<li><p>因此一个日志对象在输出日志时可以同时输出到控制台和文件等位置</p>
</li>
<li><p>如果整个项目中只需要一个logger，spdlog提供了最为便捷的logger，注意，该logger在全局公用，输出到控制台，多线程，彩色。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Use the default logger (stdout, multi-threaded, colored)</span></span><br><span class="line">spdlog::<span class="built_in">info</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建特定的logger</p>
<ul>
<li>大部分情况下默认logger是不够用的，因为我们可能需要做不同模块各自的logger，可能需要logger输出到文件进行持久化，所以创建logger是很很重要的一件事。</li>
</ul>
</li>
<li><p>直接创建</p>
<ul>
<li>与创建sink类似，我们可以非常便捷的创建logger。</li>
<li>由于大部分时候一个logger只会有一个sink，所以spdlog提供了创建logger的接口并封装了创建sink的过程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> console = spdlog::<span class="built_in">stdout_color_mt</span>(<span class="string">&quot;some_unique_name&quot;</span>);<span class="comment">//一个输出到控制台的彩色多线程logger，可以指定名字</span></span><br><span class="line"><span class="keyword">auto</span> file_logger = spdlog::<span class="built_in">rotating_logger_mt</span>(<span class="string">&quot;file_logger&quot;</span>, <span class="string">&quot;logs/mylogfile&quot;</span>, <span class="number">1048576</span> * <span class="number">5</span>, <span class="number">3</span>);<span class="comment">//一个输出到指定文件的轮转文件logger，后面的参数指定了文件的信息</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>组合sinks方式创建</p>
<ul>
<li>有时候，单sink的logger不够用，那么可以先创建sink的vector，然后使用sinks_vector创建vector</li>
<li>以下示例中，首先创建了sink的vector，然后创建了两个sink并放入vector，最后使用该vector创建了logger，其中 set_level 的过程不是必须的， register_logger 一般是必须的，否则只能在创建logger的地方使用该logger<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;spdlog::sink_ptr&gt; sinks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sink1 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_color_sink_mt&gt;();</span><br><span class="line">sink1-&gt;<span class="built_in">set_level</span>(MyLoggers::<span class="built_in">getGlobalLevel</span>());</span><br><span class="line">sinks.<span class="built_in">push_back</span>(sink1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sink2 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt;(log_file_name, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>, <span class="number">100</span>, <span class="literal">false</span>);</span><br><span class="line">sink2-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br><span class="line">sinks.<span class="built_in">push_back</span>(sink2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> logger = std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">&quot;logger_name&quot;</span>, <span class="built_in">begin</span>(sinks), <span class="built_in">end</span>(sinks));</span><br><span class="line">logger-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br><span class="line">spdlog::<span class="built_in">register_logger</span>(logger);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>logger的注册与获取</p>
<ul>
<li>在一个地方创建了logger却智能在该处使用肯定是不好的，所以spdlog提供了全局注册和获取logger，我们只需要在某处先创建logger并注册，那么后面再其他地方使用时直接获取就可以了</li>
<li>注册: spdlog::register_logger()</li>
<li>获取: spdlog::get()<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的代码中我们注册了一个logger，名字是logger_name，接下来尝试获取</span></span><br><span class="line"><span class="keyword">auto</span> logger = MyLoggers::<span class="built_in">getLogger</span>(<span class="string">&quot;logger_name&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="logger的使用"><a href="#logger的使用" class="headerlink" title="logger的使用"></a>logger的使用</h2><ul>
<li><p>logger的默认level是info，如果处于开发换进给或者生产环境，绘制需要debug级别以上，可以设置logger的级别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以设置全局logger级别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_level</span>(spdlog::level::warn);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以设置sink级别的logger</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sink1-&gt;<span class="built_in">set_level</span>(spdlog::level::info);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意: 一个logger假如有多个sink，那么这些sink分别设置level是可以不同的，但是由于logger本身也有level，所以真正使用时，logger的level如果高于某个sink，会覆盖该sink的level，所以建议此时把logger的level手动设置为debug(默认为info)</p>
</li>
</ul>
<h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li><p>使用方法一：</p>
<ul>
<li>下载好项目源代码，使用cmake编译，命令:<code>cmake -S . -B build</code>，然后进入build进行make，会获取到一个静态库 <code>libspdlog.a</code></li>
<li>之后通过包含include下的头文件和链接生成的静态库，使用spdlog</li>
</ul>
</li>
<li><p>使用方法二：</p>
<ul>
<li>将头文件和源文件分别添加到相应工程中的头文件和源文件</li>
<li>然后再CMakeLists.txt中添加头文件目录和源文件目录，并且添加一条命令用来编译指定文件：<code>target_compile_definitions($&#123;PROJECT_NAME&#125; PUBLIC SPDLOG_COMPILED_LIB)</code></li>
</ul>
</li>
</ul>
<h3 id="1-2-基本用法"><a href="#1-2-基本用法" class="headerlink" title="1.2 基本用法"></a>1.2 基本用法</h3><ul>
<li><p>输出日志信息到标准输出</p>
<ul>
<li><code>spdlog::info(&quot;This is a log message.&#123;0&#125; &#123;1&#125;&quot;, &quot;hello&quot;, &quot;world&quot;)</code></li>
<li><code>spdlog::warn(&quot;This is a warn message&quot;);</code></li>
<li><code>spdlog::debug(&quot;This message should not be displayed&quot;);</code></li>
<li><code>spdlog::set_level(spdlog::level::trace);  // set specifice logger&#39;s log level</code></li>
<li><code>spdlog::debug(&quot;This message should be displayed, because the level is setted trace&quot;);</code></li>
</ul>
</li>
<li><p>日志信息输出到文件</p>
<ul>
<li>创建基础日志文件：<ul>
<li><code>#include &quot;spdlog/sinks/basic_file_sink.h&quot;</code></li>
<li><code>auto my_logger = spdlog::basic_logger_mt(&quot;file_logger&quot;, &quot;logs/basic-log.txt&quot;, true);</code></li>
<li>创建一个文件为<code>logs/basic-log.txt</code>，并设置输出的消息标识为<code>file_logger</code>的日志文件，通过使用<code>my_logger</code>来操作该日志文件</li>
</ul>
</li>
<li>将日志输出到日志文件中：<ul>
<li><code>my_logger-&gt;info(&quot;Helo Info&quot;);</code></li>
</ul>
</li>
</ul>
</li>
<li><p>输出行号：</p>
<ul>
<li><code>SPDLOG_DEBUG(&quot;some debug message about program: &#123;&#125;&quot;, &quot;robot&quot;);</code></li>
</ul>
</li>
</ul>
<h2 id="spdlog-spdlog-get-函数-详解"><a href="#spdlog-spdlog-get-函数-详解" class="headerlink" title="spdlog spdlog::get()函数 详解"></a>spdlog spdlog::get()函数 详解</h2><p><code>spdlog</code> 是一个快速的 C++ 日志库，广泛用于高效日志记录。<code>spdlog::get()</code> 函数用于获取已经创建的日志记录器（logger）的共享指针。如果指定名称的日志记录器不存在，它会返回 <code>nullptr</code>。</p>
<h3 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;spdlog::logger&gt; <span class="title">spdlog::get</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-参数说明"><a href="#2-参数说明" class="headerlink" title="2. 参数说明"></a>2. 参数说明</h3><ul>
<li><strong>name</strong>: 一个 <code>std::string</code> 类型的参数，表示需要获取的日志记录器的名称。</li>
</ul>
<h3 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h3><ul>
<li><strong><code>std::shared_ptr&lt;spdlog::logger&gt;</code></strong>: 返回一个指向指定名称的日志记录器的共享指针。如果指定名称的日志记录器未找到，则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><p><code>spdlog::get()</code> 通常用于在应用程序的不同模块中共享同一个日志记录器。比如，你在主模块中创建了一个名为 “my_logger” 的日志记录器，之后可以在其他模块中通过 <code>spdlog::get(&quot;my_logger&quot;)</code> 获取同一个记录器，而无需重新创建。</p>
<h3 id="5-示例代码"><a href="#5-示例代码" class="headerlink" title="5. 示例代码"></a>5. 示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;spdlog/spdlog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;spdlog/sinks/basic_file_sink.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个名为 &quot;file_logger&quot; 的日志记录器</span></span><br><span class="line">    <span class="keyword">auto</span> logger = spdlog::<span class="built_in">basic_logger_mt</span>(<span class="string">&quot;file_logger&quot;</span>, <span class="string">&quot;logs.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用记录器进行日志记录</span></span><br><span class="line">    logger-&gt;<span class="built_in">info</span>(<span class="string">&quot;This is an info message&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在其他地方获取并使用相同的记录器</span></span><br><span class="line">    <span class="keyword">auto</span> same_logger = spdlog::<span class="built_in">get</span>(<span class="string">&quot;file_logger&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (same_logger) &#123;</span><br><span class="line">        same_logger-&gt;<span class="built_in">warn</span>(<span class="string">&quot;This is a warning message from the same logger&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        spdlog::<span class="built_in">error</span>(<span class="string">&quot;Logger not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul>
<li><code>spdlog::get()</code> 只返回已经通过 <code>spdlog::register_logger()</code> 或者 <code>spdlog::basic_logger_mt()</code> 等方法注册过的日志记录器。如果未注册过，返回的会是 <code>nullptr</code>。</li>
<li><code>spdlog::get()</code> 函数是线程安全的，因此可以在多线程环境中安全使用。</li>
</ul>
<p>通过 <code>spdlog::get()</code>，你可以在不同模块中灵活地获取和使用日志记录器，确保日志管理的一致性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/25/notebook/VSCode/2024-08-25-3_launch%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/25/notebook/VSCode/2024-08-25-3_launch%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">vscode-launch.json文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-25 10:21:03" itemprop="dateCreated datePublished" datetime="2024-08-25T10:21:03+08:00">2024-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vscode/" itemprop="url" rel="index"><span itemprop="name">vscode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>VSCode下C++程序的调试的配置文件是launch.json。这篇文章是关于launch.json文件的使用笔记，包括常见的参数，常用技巧和常见错误及其解决方法。</li>
</ul>
<h2 id="windows-程序调试阻塞，出现-unable-to-start-Microsoft-Visual-Debug-Console"><a href="#windows-程序调试阻塞，出现-unable-to-start-Microsoft-Visual-Debug-Console" class="headerlink" title="windows 程序调试阻塞，出现 unable to start Microsoft Visual Debug Console."></a>windows 程序调试阻塞，出现 unable to start Microsoft Visual Debug Console.</h2><ul>
<li><p>这个是因为程序输出需要在命令窗口中，在launch.json中console参数是设置命令窗口的启动属性。如果设置了 externalTerminal 则会出现问题。</p>
</li>
<li><p>解决方法</p>
<ul>
<li>将console的值设置为 integratedTerminal</li>
</ul>
</li>
</ul>
<h2 id="console-参数-详解"><a href="#console-参数-详解" class="headerlink" title="console 参数 详解"></a>console 参数 详解</h2><ul>
<li><p>console: Where to launch the debug target. Defaults to ‘internalConsole’ if not defined.</p>
</li>
<li><p>console: 需要调试的程序运行的地方。如果没有定义，默认为 internalConsole</p>
</li>
<li><p>console的值有: </p>
<ul>
<li>externalTerminal: <ul>
<li>Console applications will be launched in an external terminal window. The window will be reused in relaunch scenarios and will not automatically disappear when the application exits.</li>
<li>控制台应用程序将在外部控制台窗口中启动。这个窗口将在程序再次启动时被重复使用，并且不会随着程序退出自动退出。</li>
</ul>
</li>
<li>integratedTerminal<ul>
<li>VS Code’s integrated terminal.</li>
<li>VSCode的集成终端</li>
</ul>
</li>
<li>internalConsole<ul>
<li>Output to the VS Code Debug Console. This doesn’t support reading console input (ex:’std::cin’ or ‘scanf’).</li>
<li>输出到VSCode调试窗口。这个不支持从窗口读取数据，例如 std::cin或 scanf</li>
</ul>
</li>
<li>newExternalWindow<ul>
<li>Console applications will be launched in their own external console window which will end when the application stops. Non-console applications will run without a terminal, and stdout&#x2F;stderr will be ignored.</li>
<li>控制台应用程序将在其自己的外部控制台窗口中启动，该窗口将在应用程序停止时结束。非控制台应用程序在没有终端且标准输出和标准错误输出被忽略的情况下运行。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/23/notebook/Books/2024-08-23-QtC++%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/23/notebook/Books/2024-08-23-QtC++%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Qt5.9 C++开发指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-23 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-23T09:00:00+08:00">2024-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>本书主要介绍如何使用Qt进行C++应用程序开发。</li>
<li>Qt实际上是一套应用程序开发类库，Qt类库由许多模块组成，例如核心的GUI组件模块Qt Widget，用于数据库访问的Qt SQL模块，用于二维图表显示的Qt Charts模块，用于数据三位显示的Qt Data Visualization模块，用于网络编程的Qt Network模块等。</li>
</ul>
<h2 id="第一章-认识Qt"><a href="#第一章-认识Qt" class="headerlink" title="第一章 认识Qt"></a>第一章 认识Qt</h2><h3 id="1-1-Qt简介"><a href="#1-1-Qt简介" class="headerlink" title="1.1 Qt简介"></a>1.1 Qt简介</h3><ul>
<li>C++是一种通用的标准编程语言，使用任何编辑器都可以编写C++源程序，然后利用C++编译器对程序进行编译，就可以生成可执行的程序。</li>
<li>为了方便进行C++程序的编写和编译，有各种综合开发环境(Integrated Developing Environment, IDE)，例如Visual Studio就是Windows平台上常见的编写C++程序的IDE。一个IDE不仅提供程序的编辑和编译，一般还提供一套基本类库，用于提供支持平台应用程序开发的各种基本类，例如Visual Studio使用MFC进行Windows平台的应用程序开发。</li>
<li>Qt是一套应用程序开发类库，但是与MFC不同，Qt是跨平台的开发类库。Qt支持PC和服务器的平台，包括Windows，Linux，macOS等，还支持移动和嵌入式操作系统，例如IOS，Embedded Linux，Andriod，WinRT等。跨平台意味着只需要编写一次程序，在不同平台上无需改动或只需要少许改动后在编译，就可以形成不同平台上运行的版本。</li>
</ul>
<h3 id="1-2-Qt的获取和安装"><a href="#1-2-Qt的获取和安装" class="headerlink" title="1.2 Qt的获取和安装"></a>1.2 Qt的获取和安装</h3><h4 id="1-2-1-Qt的许可类型"><a href="#1-2-1-Qt的许可类型" class="headerlink" title="1.2.1 Qt的许可类型"></a>1.2.1 Qt的许可类型</h4><ul>
<li>Qt的许可类型分为商业许可和开源许可，开源许可又分为LGPLV3和GPLV2&#x2F;GPLV3.</li>
</ul>
<h4 id="1-2-2-Qt的版本"><a href="#1-2-2-Qt的版本" class="headerlink" title="1.2.2 Qt的版本"></a>1.2.2 Qt的版本</h4><ul>
<li>Qt的版本更新比较快，且版本更新时会新增一些类或者停止维护一些以前版本的类。如果不是为了维护用旧版本编写的程序，一定要选用最新版本的Qt进行程序开发。</li>
</ul>
<h4 id="1-2-3-Qt的下载和安装"><a href="#1-2-3-Qt的下载和安装" class="headerlink" title="1.2.3 Qt的下载和安装"></a>1.2.3 Qt的下载和安装</h4><ul>
<li><p>从Qt官网可以下载最新版本的Qt软件。根据开发项目的不同，Qt分为桌面和移动设备应用开发，嵌入式设备开发两大类不同的安装包。</p>
<ul>
<li>桌面和移动设备应用开发就是开发在PC，服务器，手机，平板电脑等设备上运行的程序，操作系统平台可以是Windows，Linux，macOS，Andriod等。</li>
<li>嵌入式设备开发是针对具体的嵌入式设备来开发应用程序，例如物联网设备，汽车电子设备，医疗设备等特定的嵌入式设备。</li>
</ul>
</li>
<li><p>Qt的安装包分为在线安装包和离线安装包，为便于重复安装，最好下载离线安装包。</p>
</li>
<li><p>在安装过程中会出现安装选项设置页面，在这个页面里选择需要安装的模块。这些模块包括内容如下</p>
<ul>
<li>MinGW 编译器模块。MinGW是Minimalist GNU For Windows的缩写，MinGW是Windows平台上使用的GNU工具集导入库的集合。</li>
<li>用于UWP编译的模块。UWP是Windows 10中Universal Windows Platform的简称，有不同编译器类型的UWP</li>
<li>用于Windows平台上的MSVC编译器模块。要安装MSVC编译器的模块，需要计算机上已经安装相应版本的Visual Studio</li>
<li>用于Andriod平台的模块，例如 Andriod x86和Android ARMv7</li>
<li>Sources是Qt的源程序类</li>
<li>Qt Charts是二维图标模块，用于绘制柱状图，饼图，曲线图等常用二维图表</li>
<li>Qt Data Visualization是三维数据图表模块，用于数据的三维显示，例如散点的三维空间分布，三维曲面等</li>
<li>Qt Purchsing，Qt WebEngine, Qt Network Auth(TP)等其他模块，括号里的TP表示技术预览(Technology Preview)</li>
<li>Qt Scritp(Deprecated)是脚本模块，括号里的”Deprecated”表示这是个已经过时的模块</li>
</ul>
</li>
<li><p>“Tools”节点下面是一些工具软件，包括内容如下</p>
<ul>
<li>Qt Creator 是用于Qt程序开发的IDE</li>
<li>MinGW 是MinGW编译工具链</li>
<li>StrawBerry Perl是一个Perl语言工具</li>
</ul>
</li>
<li><p>工具软件有</p>
<ul>
<li>Assistant 是一个独立的查看Qt帮助文件的程序，集成在了Qt Creator中</li>
<li>Designer 是一个独立的进行窗口，对话框等界面可视化设计的程序。Designer也集成在了Qt Creator中，在Qt Creator中编辑或创建界面文件时，就可以自动打开并进行界面设计。</li>
<li>Linguist是一个编辑语言资源文件的程序，在开发多语言界面的应用程序时会用到。</li>
</ul>
</li>
<li><p>这三个工具软件可独立使用，前两个集成到了Qt Creator里，可在Qt Creator打开。所以Qt的主要工具是Qt Creator。</p>
</li>
</ul>
<h3 id="1-3-Qt-Creator初步使用"><a href="#1-3-Qt-Creator初步使用" class="headerlink" title="1.3 Qt Creator初步使用"></a>1.3 Qt Creator初步使用</h3><h3 id="1-4-编写一个Hello-World程序"><a href="#1-4-编写一个Hello-World程序" class="headerlink" title="1.4 编写一个Hello World程序"></a>1.4 编写一个Hello World程序</h3><h4 id="1-4-1-新建一个项目"><a href="#1-4-1-新建一个项目" class="headerlink" title="1.4.1 新建一个项目"></a>1.4.1 新建一个项目</h4><ul>
<li><p>Qt Creator可以创建多种项目，各类应用程序如下</p>
<ul>
<li>Qt Widgets Application，支持桌面平台的有图形用户界面(Graphic User Interface,GUI)界面的应用程序。GUI的设计完全基于C++语言，采用Qt提供的一套C++类库。</li>
<li>Qt Console Application，控制台应用程序，无GUI界面，一般用于学习C&#x2F;C++语言。</li>
<li>Qt Quick Application, 创建可部署的Qt Quick 2应用程序。Qt Quick是Qt支持的一套GUI开发架构，其界面设计采用QML语言，程序架构采用C++语言。利用Qt Quick可以设计非常炫的用户界面，一般用于移动设备或嵌入式设备上无边框的应用程序的设计。</li>
<li>Qt Quick Controls 2 Application，创建基于Qt Quick Controls 2组件的可部署的Qt Quick 2应用程序。</li>
<li>Qt Canvas 3D Application，创建Qt Canvas 3D QML项目，也是基于QML语言的界面设计，支持3D画布。</li>
</ul>
</li>
<li><p>界面的基类(base class)，有3中基类可以选择</p>
<ul>
<li>QMainWindow 是主窗口类，主窗口具有主菜单栏，工具栏和状态栏，类似于一般的应用程序的主窗口；</li>
<li>QWidget 是所有具有可视界面类的基类，选择QWidget创建的界面对各种界面组件都可以支持</li>
<li>QDialog 是对话框类，可建立一个基于对话框的界面</li>
</ul>
</li>
</ul>
<h2 id="第二章-GUI应用程序设计基础"><a href="#第二章-GUI应用程序设计基础" class="headerlink" title="第二章 GUI应用程序设计基础"></a>第二章 GUI应用程序设计基础</h2><ul>
<li>本章深入的介绍Qt Creator设计GUI应用程序的基本方法，包括Qt创建的应用程序项目的 基本组织结构，可视化设计的UI界面文件的原理和运行机制，信号与槽的使用方法，窗体可视化设计的底层原理，应用程序的窗体，组件布局，菜单，工具栏，Actions等常见设计元素的使用方法。</li>
</ul>
<h3 id="2-1-UI文件设计与运行机制"><a href="#2-1-UI文件设计与运行机制" class="headerlink" title="2.1 UI文件设计与运行机制"></a>2.1 UI文件设计与运行机制</h3><h4 id="2-1-1-项目文件组成"><a href="#2-1-1-项目文件组成" class="headerlink" title="2.1.1 项目文件组成"></a>2.1.1 项目文件组成</h4><ul>
<li>一个Widget Application项目包含一下一些文件<ul>
<li>项目组织文件 samp2_1.pro,存储项目设置的文件</li>
<li>主程序入口文件main.cpp,实现main()函数的程序文件</li>
<li>窗体界面文件widget.ui，一个XML格式存储的窗体上的元件及其布局的文件</li>
<li>widget.h是所设计的窗体类的头文件，widget.cpp是widget.h里定义类的实现文件。在C++里，<strong>任何窗体或界面组件都是用类封装的</strong>，一个类一般有一个头文件和一个源文件。</li>
</ul>
</li>
</ul>
<h4 id="2-1-2-项目管理文件"><a href="#2-1-2-项目管理文件" class="headerlink" title="2.1.2 项目管理文件"></a>2.1.2 项目管理文件</h4><ul>
<li>后缀为.pro的文件是项目的管理文件，文件名就是项目的名称</li>
</ul>
<h4 id="2-1-3-界面文件"><a href="#2-1-3-界面文件" class="headerlink" title="2.1.3 界面文件"></a>2.1.3 界面文件</h4><ul>
<li>后缀为 .ui 的文件是可视化设计的窗体的定义文件，例如 widget.ui</li>
<li>本书后面将成这个集成在Qt Creator中的Qt Designer为 UI设计器，以便与独立运行的Qt Designer区别开来</li>
</ul>
<h4 id="2-1-4-主函数文件"><a href="#2-1-4-主函数文件" class="headerlink" title="2.1.4 主函数文件"></a>2.1.4 主函数文件</h4><ul>
<li>main函数是应用程序的入口。它的主要功能是创建应用程序，创建窗口，显示窗口，并运行从应用程序，开始应用程序的消息循环和事件处理。</li>
</ul>
<h4 id="2-1-5-窗体相关的文件"><a href="#2-1-5-窗体相关的文件" class="headerlink" title="2.1.5 窗体相关的文件"></a>2.1.5 窗体相关的文件</h4><ul>
<li>为了搞清楚窗体类的定义，以及界面功能的实现原理，香茗居编译后会自动生成一个文件 ui_widget.h，这样对于一个窗体，就有四个文件<ul>
<li>widget.h 定义窗体类的头文件定义了类Widget</li>
<li>widget.cpp Widget类的功能实现源程序文件</li>
<li>widget.ui 窗体界面文件，由UI设计器自动生成，存储了窗体上各个组件的属性设置和布局</li>
<li>ui_widget.h 编译后，根据窗体上的组件及其属性，信号与槽的关联自动生成的一个类的定义文件，类的名称是Ui_Widget</li>
</ul>
</li>
</ul>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><h4 id="2-2-3-信号与槽"><a href="#2-2-3-信号与槽" class="headerlink" title="2.2.3 信号与槽"></a>2.2.3 信号与槽</h4><ul>
<li><p>信号与槽(Signal &amp; Slot)是Qt编程的基础，也是Qt的一大创新。因为有了信号与槽的编程机制，在Qt中处理界面各个组件的交互操作时变得更加直观和简单。</p>
</li>
<li><p>信号(Signal)就是在特定情况下被发射的事件，例如PushButton最常见的信号就是鼠标单击时发射的clicked()信号，一个ComboBox最常见的信号是选择的列表项变化时发射的CurrentIndexChanged()信号。GUI程序设计的主要内容就是对界面上各组件的信号的相应，只需要知道什么情况下发射哪些信号，合理的去响应和处理这些信号就可以了。</p>
</li>
<li><p>槽(Slot)就是对信号响应的函数。槽就是一个函数，与一般的C++函数是一样的，可以定义在类的任何部分(public, private或protected)，可以具有任何参数，也可以被直接调用。槽函数与一般函数不同的是: <strong>槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行</strong>。</p>
</li>
<li><p>信号与槽关联是用QObject::connect()函数实现的，其基本格式是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">signal</span>()), reciver, <span class="built_in">SLOT</span>(<span class="built_in">slot</span>()));</span><br></pre></td></tr></table></figure></li>
<li><p>connect()是QObject类的一个静态函数，而QObject是所有Qt类的基类，在实际调用时可以忽略前面的限定符，所以可以直接写为: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">signal</span>()), reciver, <span class="built_in">SLOT</span>(<span class="built_in">slot</span>()));</span><br></pre></td></tr></table></figure>
<ul>
<li>其中，sender是发射信号的对象的名称，signal()是信号名称。信号可以看作是特殊的函数，需要带括号，有参数时还需要指明参数。receiver是接收信号的对象名称，slot()是槽函数的名称，需要带括号，有参数时还需要指明参数。</li>
<li>SIGNAL和SLOT是Qt的宏，用于指明信号和槽，并将它们的参数转换为相应的字符串。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(btnClose, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), Widget, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br></pre></td></tr></table></figure></li>
<li>其作用就是将btnClose按钮的clicked()信号与窗体(Widget)的槽函数close()相关联，这样，当单击btnClose按钮时，就会执行Widget的Close()槽函数。</li>
</ul>
</li>
<li><p>关于信号与槽的使用，有以下一些规则需要注意</p>
<ul>
<li>一个信号可以连接多个槽，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(spinNum, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">addFun</span>(<span class="type">int</span>)));</span><br><span class="line"><span class="built_in">connect</span>(spinNum, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">updateStatus</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>
<ul>
<li>这是当一个对象spinNUm的数值发生变化时，所在窗体有两个槽进行响应，一个addFun()用于计算，一个updateStatus()用于更新状态。</li>
<li>当一个信号与多个槽函数关联时，槽函数按照建立连接时的顺序依次执行。</li>
<li>当信号和槽函数带有参数时，在connect()函数里，要写明参数的类型，但可以不写参数名称。</li>
</ul>
</li>
<li>多个信号可以连接同一个槽，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;rBtnBlue, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">setTextFontColor</span>()));</span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;rBtnRed, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOG</span>(<span class="built_in">setTextFontColor</span>()));</span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;rBtnBlack, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOG</span>(<span class="built_in">setTextFontColor</span>()));</span><br></pre></td></tr></table></figure>
<ul>
<li>这样，当任何一个RadioButton被单击时，都会执行setTextFontColor()函数。</li>
</ul>
</li>
<li>一个信号可以连接另外一个信号，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(spinNum, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">refreshInfo</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>
<ul>
<li>这样，当一个信号发射时，也会发射另外一个信号，实现某些特殊的功能。</li>
</ul>
</li>
<li>严格情况下，信号与槽的参数个数和类型需要一致，至少信号的参数不能少于槽的参数。如果不匹配，会出现编译错误或运行错误。</li>
<li>在使用信号与槽的类中，必须在类的定义中加入宏Q_OBJECT</li>
<li>当一个信号被发射时，与其关联的槽函数通常被立即执行，就像正常调用一个函数一样。只有当信号关联的所有槽函数执行完毕后，才会执行发射信号处后面的代码。</li>
</ul>
</li>
<li><p>信号与槽机制是Qt GUI编程的基础，使用信号与槽机制可以比较容易的将信号与响应代码关联起来。</p>
</li>
</ul>
<h2 id="第三章-Qt类库概述"><a href="#第三章-Qt类库概述" class="headerlink" title="第三章 Qt类库概述"></a>第三章 Qt类库概述</h2><ul>
<li>Qt是一个用标准C++编写的跨平台开发类库，它对标准C++进行了扩展，引入了元对象系统，信号与槽，属性等特性，使应用程序的开发变得更高效。本章将介绍Qt的这些核心特点，对于理解和编写高效的Qt C++程序是大有帮助的。</li>
<li>本章还介绍<QtGlobal>头文件中Qt的一些全局定义，包括数据类型，函数和宏等，介绍Qt的容器类及其响应迭代器的使用方法。这些全局定义和容器类在程序中经常用到，了解其原理便于理解后面遇到的一些实例程序。</li>
<li>Qt类库中大量的类是以模块形式分类组织的，包括基本模块和扩展模块等，本章对这些模块做一个总体的介绍。一个模块通常就是一个编程主题，例如数据库，图表，网格等。本书后面的章节一般是每章介绍一个编程主题。</li>
</ul>
<h3 id="3-1-Qt核心特点"><a href="#3-1-Qt核心特点" class="headerlink" title="3.1 Qt核心特点"></a>3.1 Qt核心特点</h3><h4 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1 概述"></a>3.1.1 概述</h4><ul>
<li><p>Qt本身并不是一种编程语言，它实质上是一个跨平台的C++开发类库，是用标准C++编写的类库，它为开发GUI应用程序和非GUI应用程序提供了各种类。</p>
</li>
<li><p>Qt对标准C++进行了扩展，引入了一些新的概念和功能，例如信号与槽，对象属性等。Qt的元对象编译器(Meta-Object Compiler, MOC)是一个预处理器，在源程序被编译前先将这些Qt特性的程序转换为标准C++兼容的形式，然后再由标准C++编译器进行编译。这就是为什么在使用信号与槽机制的类里，必须添加一个Q_OBJECT宏的原因，只有添加了这个宏，moc才能对类里的信号与槽的代码进行预处理。</p>
</li>
<li><p>Qt Core模块是Qt类库的核心，所有其他模块都依赖于此模块。Qt 为C++语言增加的特性就是在Qt Core模块里实现的，这些扩展特性由Qt的元对象系统实现，包括信号与槽机制，属性系统，动态类型转换等。</p>
</li>
</ul>
<h4 id="3-1-2-元对象系统"><a href="#3-1-2-元对象系统" class="headerlink" title="3.1.2 元对象系统"></a>3.1.2 元对象系统</h4><ul>
<li><p>Qt的元对象系统(Meta-Object System)提供了对象之间通信的信号与槽机制，运行时类型信息和动态属性系统。</p>
</li>
<li><p>元对象系统由以下三个基础组成</p>
<ul>
<li>QObject类是所有使用元对象系统的类的基类。</li>
<li>在一个类的private部分声明Q_OBJECT宏，使得类可以使用元对象的特性，例如动态属性，信号与槽。</li>
<li>MOC(元对象编译器)为每个QObject的子类提供必要的代码来实现元对象系统的特性。</li>
</ul>
</li>
<li><p>构建项目时，MOC工具读取C++源文件，当它发现类的定义里有Q_OBJECT宏时，它就会为这个类生成另外一个包含有元对象支持代码的C++源文件，这个生成的源文件连同类的实现文件一起被编译和链接。</p>
</li>
<li><p>除了信号与槽机制外，元对象还提供如下一些功能</p>
<ul>
<li>QOBject::metaObject()函数返回类关联的元对象，元对象类QMetaObject包含了访问对象的一些接口函数，例如QMetaObject::className()函数可在运行时返回类的名称字符串。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QObject *obj = <span class="keyword">new</span> QPushButton;</span><br><span class="line">obj-&gt;<span class="built_in">metaObject</span>()-&gt;<span class="built_in">className</span>();  <span class="comment">// 返回&quot;QPushButton</span></span><br></pre></td></tr></table></figure></li>
<li>QMetaObject::newInstance()函数创建类的一个新的实例</li>
<li>QObject::inherits(const char* className)函数判断一个对象实例是否是名称为className的类或QObject的子类的实例。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTimer *timer = <span class="keyword">new</span> QTimer; <span class="comment">// QTimer是QObject的子类</span></span><br><span class="line">timer-&gt;<span class="built_in">inherits</span>(<span class="string">&quot;QTimer&quot;</span>);  <span class="comment">// 返回true</span></span><br><span class="line">timer-&gt;<span class="built_in">inherits</span>(<span class="string">&quot;QObject&quot;</span>); <span class="comment">// 返回true</span></span><br><span class="line">timer-&gt;<span class="built_in">inherits</span>(<span class="string">&quot;QAbstractButton&quot;</span>); <span class="comment">// 返回false，不是QAbstractButton的子类</span></span><br></pre></td></tr></table></figure></li>
<li>QObject::tr()和QObject::trUtf8()函数可翻译字符串，用于多语言界面设计。</li>
<li>QObject::setProperty()和QObject::property()函数用于通过属性名称动态设置和获取属性值。</li>
</ul>
</li>
<li><p>对于QObject及其子类，还可以使用qobject_cast()函数进行动态映射(dynamic cast)。</p>
</li>
<li><p>使用动态投射，使得程序可以在运行时对不同的对象做不同的处理。</p>
</li>
</ul>
<h4 id="3-1-3-属性系统"><a href="#3-1-3-属性系统" class="headerlink" title="3.1.3 属性系统"></a>3.1.3 属性系统</h4><ul>
<li>Qt提供一个 Q_PROPERTY()宏可以定义属性，它也是基于元对象系统实现的。Qt的属性系统与C++编译器无关，可以用任何标准的C++编译器编译定义了属性的QtC++程序。</li>
<li>Q_PROPERTY宏定义一个返回值类型为type，名称为name的属性，用READ，WRITE关键字定义属性的读取，写入函数，还有其他的一些关键字定义属性的一些操作特性。属性的类型可以是QVariant支持的任何类型，也可以用户自定义类型。</li>
<li>Q_PROPERTY宏定义属性的一些主要关键字的意义如下</li>
<li>READ: 指定一个读取属性值的函数，没有MEMBER关键字时必须设置READ</li>
<li>WRITE: 指定一个设定属性值的函数，只读属性没有WRITE设置</li>
<li>MEMBER: 指定一个成员变量与属性关联，成为可读可写的属性，无需再设置READ和WRITE</li>
<li>RESET: 是可选的，用于指定一个设置属性缺省值的函数</li>
<li>NOTIFY: 是可选的，用于设置一个信号，当属性值变化时发射此信号</li>
<li>DESIGNABLE: 表示属性是否在Qt Designer里可见，缺省为true</li>
<li>CONSTANT: 表示属性值是一个常数，对于一个对象实例，READ指定的函数返回值是常数，但是每个实例的返回值可以不一样。具有CONSTANT关键字的属性不能有WRITE和NOTIFY关键字。</li>
<li>FINAL: 表示所定义的属性不能被子类重载</li>
</ul>
<h4 id="3-1-4-信号与槽"><a href="#3-1-4-信号与槽" class="headerlink" title="3.1.4 信号与槽"></a>3.1.4 信号与槽</h4><ul>
<li><p>信号与槽是Qt的一个核心特点，也是它区别于其他框架的重要特性。信号与槽是对象间进行通信的机制，也需要由Qt的元对象系统支持才能实现的。</p>
</li>
<li><p>Qt使用信号与槽的机制实现对象间通信，它隐藏了复杂的底层实现，完成信号与槽的关联后，发射信号时并不需要知道Qt是如何找到槽函数的。Qt的信号与槽机制与Delphi和C++ Builder的”事件–响应”比较类似，但是更加灵活。</p>
</li>
<li><p>某些开发架构使用回调函数(callback)实现对象间通信。与回调函数相比，信号与槽的执行速度稍微慢一点，因为需要查找连接的对象和槽函数，但是这种差别在应用程序运行时是感觉不到的，而其提供的灵活性却比回调函数强很多。</p>
</li>
<li><p>对信号与槽的特点和用法做一些补充</p>
<ol>
<li>connect()函数的不同参数形式</li>
</ol>
<ul>
<li>QObject::connect()函数有多重参数形式，一种参数形式的函数原型是<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender, <span class="type">const</span> <span class="type">char</span> *signal, <span class="type">const</span> QObject *receiver, <span class="type">const</span> <span class="type">char</span> *method, Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>使用这种参数形式的connect()进行信号与槽函数的连接时，一般句法如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">signal</span>()), receiver, <span class="built_in">SLOT</span>(<span class="built_in">slot</span>()));</span><br></pre></td></tr></table></figure></li>
<li>这里使用了宏SIGNAL()和SLOT()指定信号和槽函数，而且如果信号和槽函数带有参数，还需要注明参数类型，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(spinNum, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">updateStatus</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure></li>
<li>另外一种参数形式的connect()函数的原型是:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender, <span class="type">const</span> QMetaMethod &amp;signal, <span class="type">const</span> QObject *receiver, <span class="type">const</span> QMetaMethod &amp;method, Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>对于具有默认参数的信号与槽(即信号名称是唯一的，没有参数不同而同名的两个信号)，可以使用这种函数指针形式进行关联，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(lineEdit, &amp;QLineEdit::textChanged, <span class="keyword">this</span>, &amp;widget::on_textChanged);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>不管是哪种参数形式的connect()函数，最后一个参数Qt::ConnectionType type，缺省值为Qt::AutoConnection。枚举类型Qt::ConnectionType表示了信号与槽之间的关联方式，有以下几种取值:</p>
<ul>
<li>Qt::AutoConnection(缺省值): 如果信号的接收者与发射者在同一个线程，就使用Qt::DirectConnection方式；否则使用Qt::QueuedConnection方式，在信号发射时自动确定关联方式</li>
<li>Qt::DirectConnection: 信号被发射时槽函数立即执行，槽函数与信号在同一个线程</li>
<li>Qt::QueuedConnection: 在事件循环回到接收者线程后执行槽函数，槽函数与信号在不同的线程。</li>
<li>Qt::BlockingQueuedConnection: 与Qt::QueuedConnection相似，只是信号线程会阻塞直到槽函数执行完毕。当信号与槽函数在同一个线程时绝对不能使用这种方式，否则会造成死锁。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>使用sender()获得信号发射者<ul>
<li>在槽函数里，使用QObject::sender()可以获取信号发射者的指针。如果知道信号发射者的类型，可以将指针投射为确定的类型，然后使用这个确定类的接口函数。</li>
</ul>
</li>
<li>自定义信号及其使用<ul>
<li>在自己设计的类里也可以自定义信号，<strong>信号就是在类定义里声明的一个函数，但是这个函数无需实现，只需要发射(emit)</strong>  </li>
<li>例如，在下面的自定义类QPerson的signals部分定义一个信号ageChanged(int)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QPerson</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">incAge</span><span class="params">()</span></span>;</span><br><span class="line">signals:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ageChanged</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li>信号函数必须是无返回值的函数，但是可以有输入参数。信号函数无需实现，只需在某些条件下发射信号。例如，在incAge()函数中发射信号，其代码如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPerson::incAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_age++;</span><br><span class="line">  <span class="function">emit <span class="title">ageChanged</span><span class="params">(m_age)</span></span>; <span class="comment">// 发射信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在incAge()函数里，当私有变量m_age变化后，发射信号ageChanged(int)，表示年龄发生了变化。至于是否有此信号相关联的槽函数，信号发射者并不管。如果在使用QPerson类对象的程序中为此信号关联了槽函数，在incAge()函数里发射此信号时，就会执行相关联的槽函数。至于是否立即执行槽函数，发射信号的线程是否等待槽函数执行完之后再执行后面的代码，与connect()函数设置信号与槽关联时设置的连接类型以及信号与槽是否在同一个线程有关。</li>
</ul>
<h3 id="3-2-Qt全局定义"><a href="#3-2-Qt全局定义" class="headerlink" title="3.2 Qt全局定义"></a>3.2 Qt全局定义</h3><ul>
<li><QtGlobal>头文件包含了Qt类库的一些全局定义，包括基本数据类型，函数和宏，一般的Qt类的头文件都会包含该文件，所以不用显示包含这个头文件也可以使用其中的定义。</li>
</ul>
<h4 id="3-2-1-数据类型定义"><a href="#3-2-1-数据类型定义" class="headerlink" title="3.2.1 数据类型定义"></a>3.2.1 数据类型定义</h4><ul>
<li>为了确保在各个平台上各数据类型都有统一确定的长度，Qt为各种常见数据类型定义了类型符号，例如qint8就是signed char的类型定义，即 typedef signed char qint8;</li>
</ul>
<h4 id="3-2-2-函数"><a href="#3-2-2-函数" class="headerlink" title="3.2.2 函数"></a>3.2.2 函数</h4><ul>
<li><QtGlobal>头文件包含一些常用函数的定义，这些函数多以模板类型作为参数，返回相应的模板类型，模板类型可以用任何其他类型替换。若是以double或float类型作为参数的，一般有两个参数版本的额同名函数，例如qFuzzyIsNull(double d)和qFuzzyIsNull(float f)。</li>
<li>还有一些基础的数学运算函数在<QtMath>头文件中定义，例如三角运算函数，弧度与角度之间的转换函数等。</li>
</ul>
<h4 id="3-2-3-宏定义"><a href="#3-2-3-宏定义" class="headerlink" title="3.2.3 宏定义"></a>3.2.3 宏定义</h4><ul>
<li><p><QtGlobal>头文件中定义了很多宏，以下是一些比较常用的</p>
</li>
<li><p>QT_VERSION</p>
<ul>
<li>这个宏展开为数值形式0xMMNNPP(MM &#x3D; major, NN &#x3D; minor, PP &#x3D; patch)表示Qt编译器版本，例如Qt编译器版本为Qt 5.9.1，则QT_VERSION为0x050901。这个宏常用于条件编译设置，根据Qt版本不同，编译不同的代码段。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> QT_VERSION &gt;= 0x040100</span></span><br><span class="line">  QIcon icon = <span class="built_in">style</span>()-&gt;<span class="built_in">standardIcon</span>(QStyle::SP_TrashIcon);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  QPixmap pixmap = <span class="built_in">style</span>()-&gt;<span class="built_in">standardPixmap</span>(QStyle::SP_TrashIcon);</span><br><span class="line">  <span class="function">QIcon <span class="title">icon</span><span class="params">(pixmap)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>QT_VERSION_CHECK</p>
<ul>
<li>这个宏展开为Qt版本号的一个整数表示，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5, 0, 0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>QT_VERSION_STR</p>
<ul>
<li>这个宏展开为Qt版本号的字符串，例如 “5.9.0”</li>
</ul>
</li>
<li><p>Q_BYTE_ORDER, Q_BIG_ENDIAN 和 Q_LITTLE_ENDIAN</p>
<ul>
<li>Q_BYTE_ORDER 表示系统内存中数据的字节序，</li>
<li>Q_BIG_ENDIAN 表示大端字节序</li>
<li>Q_LITTLE_ENDIAN 表示小端字节序。</li>
<li>在需要判断系统字节序时会用到，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> Q_BYTE_ORDER == Q_LITTLE_ENDIAN</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Q_DECL_IMPORT, Q_DECL_EXPORT</p>
<ul>
<li>在使用或设计共享库时，用于导入或到处库的内容</li>
</ul>
</li>
<li><p>Q_DECL_OVERRIDE</p>
<ul>
<li>在类定义中，用于重载一个虚函数，例如在某个类中重载虚函数paintEvent(),可以定义如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent*)</span> Q_DECL_OVERRIDE</span>;</span><br></pre></td></tr></table></figure></li>
<li>使用Q_DECL_OVERRIDE宏后，如果重载的虚函数没有进行任何重载操作，编译器将会报错。</li>
</ul>
</li>
<li><p>Q_DECL_FINAL</p>
<ul>
<li>这个宏将一个虚函数定义为最终级别，不能再被重载，或定义一个类不能再被继承，实例如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QRect</span> Q_DECL_FINAL &#123;  <span class="comment">// QRect不能再被继承</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Q_UNUSED(name)</p>
<ul>
<li>这个宏用于在函数中定义不在函数体里使用的参数，示例如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_imageSaved</span><span class="params">(<span class="type">int</span> id, <span class="type">const</span> QString &amp;filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">Q_UNUSED</span>(id);</span><br><span class="line">  LabInfo-&gt;<span class="built_in">setText</span>(<span class="string">&quot;图片保存为: &quot;</span> + filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在这个函数里，id参数没有使用。如果不用Q_UNUSED(id)定义，编译器会出现参数未使用的警告。</li>
</ul>
</li>
<li><p>foreach(variable, container)</p>
<ul>
<li>foreach用于容器类的遍历，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foreach (<span class="type">const</span> QString &amp;codecName, recorder-&gt;<span class="built_in">supportedAudioCodecs</span>())</span><br><span class="line">  ui-&gt;comboCodec-&gt;<span class="built_in">addItem</span>(codecName);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>forever</p>
<ul>
<li>forever用于构造一个无限循环，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forever &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>qDebug(const char *message, …)</p>
<ul>
<li>在debugger窗体显示信息，如果编译器设置了 Qt_NO_DEBUG_OUTPUT，则不作任何输出，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>(<span class="string">&quot;Item in list: %d&quot;</span>, myList.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>类似的宏还有 qWarning, qCritical, qFatal, qInfo等，也是用于在debugger窗体显示信息。</p>
</li>
</ul>
<h3 id="3-3-容器类"><a href="#3-3-容器类" class="headerlink" title="3.3 容器类"></a>3.3 容器类</h3><h4 id="3-3-1-容器类概述"><a href="#3-3-1-容器类概述" class="headerlink" title="3.3.1 容器类概述"></a>3.3.1 容器类概述</h4><ul>
<li><p>Qt提供了多个基于模板的容器类，这些容器类可以用于存储指定类型的数据项，例如常用的字符串列表类QStringList就是从容器类QList<QString>继承的，实现对字符串列表的添加，存储，删除等操作。</p>
</li>
<li><p>Qt的容器壁标准模板库(STL)中的容器类更轻巧，安全和易于使用。这些容器类是隐式共享和可重入的，而且他们进行了速度和存储优化，因此可以减少可执行文件的大小。此外，它们还是线程安全的，也就是说<strong>它们作为只读容器时可以被多个线程访问</strong>。</p>
</li>
<li><p>容器类是基于模板的类，如常用的容器类QList<T>，T是一个具体的类型，可以是int, float等简单的类型，也可以是QString, QDate等类，但是不能是QObject或任何其子类。T必须是一个可赋值的类型，即T必须提供一个缺省的构造函数，一个可复制构造函数和一个赋值运算符。</p>
</li>
<li><p>Qt的容器类分为顺序容器(sequential containers)和关联容器(associative containers)</p>
</li>
<li><p>容器迭代类用于遍历容器里的数据项，有Java类型的迭代类和STL类型的迭代类。Java类型的迭代类易于使用，提供高级功能，而STL类型的迭代类效率更高一些。</p>
</li>
<li><p>Qt还提供了foreach宏用于遍历容器内的所有数据项。</p>
</li>
</ul>
<h4 id="3-3-2-顺序容器类"><a href="#3-3-2-顺序容器类" class="headerlink" title="3.3.2 顺序容器类"></a>3.3.2 顺序容器类</h4><ul>
<li><p>Qt的顺序容器类有 QList, QLinkedList, QVector, QStack和QQueue</p>
</li>
<li><p>QList</p>
<ul>
<li>QList是最常用的容器类，虽然它是以数组列表(array-list)的形式实现的，但是在其前或后添加数据非常快。QList以下标索引的方式对数据项进行访问。</li>
</ul>
</li>
<li><p>QLinkedList</p>
<ul>
<li>QLinkedList<T>是链式列表(linked-list),数据项不是用连续的内存存储的，它基于迭代器访问数据项，并且插入和删除数据项的操作时间相同。<br>除了不提供基于下标索引的数据项访问外，QLinkedList的其他接口函数与QList基本相同。</li>
</ul>
</li>
<li><p>QVector</p>
<ul>
<li>QVector<T>提供动态数组的功能，以下标索引访问数据。</li>
<li>QVector的函数接口与QList几乎完全相同，QVector<T>的性能比QList<T>更高，因为QVector<T>的数据项是连续存储的。</li>
</ul>
</li>
<li><p>QStack</p>
<ul>
<li>QStack<T>是提供类似于堆栈的后入先出(LIFO)操作的容器类，push()和pop()是主要的接口函数。</li>
</ul>
</li>
<li><p>QQueue</p>
<ul>
<li>QQueue<T>是提供类似于队列先入先出(FIFO)操作的容器类。enqueue()和dequeue()是主要的操作函数</li>
</ul>
</li>
</ul>
<h4 id="3-3-3-关联容器类"><a href="#3-3-3-关联容器类" class="headerlink" title="3.3.3 关联容器类"></a>3.3.3 关联容器类</h4><ul>
<li><p>Qt还提供关联容器类 QMap, QMultiMap, QHash, QMultiHash和QSet</p>
</li>
<li><p>QMultiMap和QMultiHash支持一个键关联多个值，QHash和QMultiHash类使用散列(Hash)函数进行查找，查找速度较快</p>
</li>
<li><p>QSet</p>
<ul>
<li>QSet是基于散列列表的集合模板类，它存储数据的顺序是不定的，查找值的速度非常快。QSet<T>内部就是用QHash实现的。</li>
<li>测试一个值是否包含于这个集合，用contains()函数</li>
</ul>
</li>
<li><p>QMap</p>
<ul>
<li>QMap&lt;Key, T&gt;提供一个字典(关联数组)，一个键映射到一个值。QMap存储数据是按照键的顺序，如果不在乎存储顺序，使用QHash会更快</li>
</ul>
</li>
<li><p>QMultiMap</p>
<ul>
<li>QMultiMap是QMap的子类，是用于处理多值映射的便利类</li>
</ul>
</li>
<li><p>QHash</p>
<ul>
<li>QHash是基于散列表来实现字典功能的模板类，QHash&lt;Key, T&gt;存储的键值对具有非常快的查找速度。</li>
</ul>
</li>
<li><p>QHash与QMap的功能和用法相似，区别在于以下几点</p>
<ul>
<li>QHash比QMap的查找速度更快</li>
<li>在QMap上遍历时，数据项是按照键排序的，而QHash的数据项是任意顺序的</li>
<li>QMap的键必须提供 “&lt;” 运算符，QHash的键必须提供 “&#x3D;&#x3D;” 运算符和一个名称为 qHash() 的全局散列函数</li>
</ul>
</li>
<li><p>QMultiHash</p>
<ul>
<li>QMultiHash是QHash的子类，是哟弄个与处理多值映射的便利类，其用法与QMultiMap类似</li>
</ul>
</li>
</ul>
<h3 id="3-4-容器类的迭代"><a href="#3-4-容器类的迭代" class="headerlink" title="3.4 容器类的迭代"></a>3.4 容器类的迭代</h3><ul>
<li>迭代器(iterator)为访问容器类里的数据项提供了统一的方法，Qt有两种迭代器类: Java类型的迭代器和STL类型的迭代器</li>
<li>Java类型的迭代器更易于使用，且提供一些高级功能，而STL类型的迭代器效率更高。</li>
</ul>
<h4 id="3-4-1-Java类型迭代器"><a href="#3-4-1-Java类型迭代器" class="headerlink" title="3.4.1 Java类型迭代器"></a>3.4.1 Java类型迭代器</h4><h4 id="3-4-2-STL类型迭代器"><a href="#3-4-2-STL类型迭代器" class="headerlink" title="3.4.2 STL类型迭代器"></a>3.4.2 STL类型迭代器</h4><ul>
<li><p>STL迭代器与Qt和STL的原生算法兼容，并且进行了速度优化</p>
</li>
<li><p>对于每一个容器类，都有两个STL类型迭代器：一个用于只读访问，一个用于读写访问。无需修改数据时一定使用只读迭代器，因为它们速度更快。</p>
</li>
<li><p>STL类型的迭代器是数组的指针，所以 “++” 运算符使迭代器指向下一个数据项， “*”运算符返回数据项内容。</p>
</li>
<li><p>隐式共享(Implicit Sharing)是对象的管理方法，一个对象被隐式共享，只是传递该对象的一个指针给使用者，而不实际复制对象数据，只有在使用者修改数据时，才实质复制共享对象给使用者。</p>
</li>
<li><p>对于STL类型的容器，隐式共享还涉及到另外一个问题，即当有一个迭代器在操作一个容器变量时，不要去复制这个容器变量。</p>
</li>
</ul>
<h4 id="3-4-3-foreach关键字"><a href="#3-4-3-foreach关键字" class="headerlink" title="3.4.3 foreach关键字"></a>3.4.3 foreach关键字</h4><ul>
<li>如果只是想遍历容器中所有的项，可以使用foreach关键字。foreach是<QtGlobal>头文件中定义的一个宏。</li>
<li><strong>foreach关键字遍历一个容器变量是创建了容器的一个副本，所以不能修改原来容器变量的数据项</strong>。</li>
</ul>
<h3 id="3-5-Qt类库的模块"><a href="#3-5-Qt类库的模块" class="headerlink" title="3.5 Qt类库的模块"></a>3.5 Qt类库的模块</h3><ul>
<li>Qt类库里大量的类根据功能分为各种模块，这些模块又分为几大类<ul>
<li>Qt基本模块(Qt Essentials): 提供了Qt在所有平台上的基本功能</li>
<li>Qt附加模块(Qt Add-Ons): 实现一些特定功能的提供附加价值的模块</li>
<li>增值模块(Value-Add Modules): 单独发布的提供额外价值的模块或工具</li>
<li>技术预览模块(Technology Preview Modules): 一些处于开发阶段，但是可以作为技术预览使用的模块</li>
<li>Qt工具(Qt Tools): 帮助应用程序开发的一些工具。</li>
</ul>
</li>
</ul>
<h4 id="3-5-1-Qt基本模块"><a href="#3-5-1-Qt基本模块" class="headerlink" title="3.5.1 Qt基本模块"></a>3.5.1 Qt基本模块</h4><ul>
<li>Qt基本模块是Qt在所有平台上的基本功能，它们在所有的开发平台和目标平台上都可用，在Qt5所有版本上是源代码和二进制兼容的。具体的基本模块如下<ul>
<li>Qt Core: 其他模块都用到的核心非图形类</li>
<li>Qt GUI: 设计GUI界面的基础类，包括OpenGL</li>
<li>Qt Multimedia: 音频，视频，摄像头和广播功能的类</li>
<li>Qt Multimedia Widgets: 实现多媒体功能的界面组件类</li>
<li>Qt Network: 使网路编程更简单和轻便的类</li>
<li>Qt QML: 用于QML和JavaScript语言的类</li>
<li>Qt Quick: 用于构建具有定制用户界面的动态应用程序的声明框架</li>
<li>Qt Quick Controls: 创建桌面样式用户界面，基于Qt Quick的用户界面控件</li>
<li>Qt Quick Dialogs: 用于Qt Quick的系统对话框类型</li>
<li>Qt Quick Layouts: 用于Qt Quick 2界面元素的布局项</li>
<li>Qt SQL: 使用SQL用于数据库操作的类</li>
<li>Qt Test: 用于应用程序和库进行单元测试的类</li>
<li>Qt Widgets: 用于构建GUI界面的C++图形组件类</li>
</ul>
</li>
</ul>
<h4 id="3-5-2-Qt附加模块"><a href="#3-5-2-Qt附加模块" class="headerlink" title="3.5.2 Qt附加模块"></a>3.5.2 Qt附加模块</h4><h4 id="3-5-3-增值模块"><a href="#3-5-3-增值模块" class="headerlink" title="3.5.3 增值模块"></a>3.5.3 增值模块</h4><h4 id="3-5-4-技术预览模块"><a href="#3-5-4-技术预览模块" class="headerlink" title="3.5.4 技术预览模块"></a>3.5.4 技术预览模块</h4><h4 id="4-5-5-Qt-工具"><a href="#4-5-5-Qt-工具" class="headerlink" title="4.5.5 Qt 工具"></a>4.5.5 Qt 工具</h4><ul>
<li>Qt工具在所有支持的平台上都可以使用，用于帮助应用程序的开发和设计<ul>
<li>Qt Designer: 用于扩展Qt Designer的类</li>
<li>Qt Help: 在应用程序中集成在线文档的类，实现类似于Qt Assistant的功能</li>
<li>Qt UI Tools: 操作Qt Designer生成的窗体的类</li>
</ul>
</li>
</ul>
<h2 id="第四章-常用界面设计组件"><a href="#第四章-常用界面设计组件" class="headerlink" title="第四章 常用界面设计组件"></a>第四章 常用界面设计组件</h2><h2 id="第五章-Model-View结构"><a href="#第五章-Model-View结构" class="headerlink" title="第五章 Model&#x2F;View结构"></a>第五章 Model&#x2F;View结构</h2><ul>
<li>Model&#x2F;View(模型&#x2F;视图)结构是Qt中用界面组件显示与编辑数据结构的一种结构，视图(View)是显示和编辑数据的界面组件，模型(Model)是视图与原始数据之间的接口。Model&#x2F;View结构的典型应用是在是数据库应用程序中。</li>
<li>主要的视图组件有 QListVew, QTreeView和QTableView</li>
</ul>
<h2 id="第六章-对话框与多窗体设计"><a href="#第六章-对话框与多窗体设计" class="headerlink" title="第六章 对话框与多窗体设计"></a>第六章 对话框与多窗体设计</h2><ul>
<li>在一个完整的应用程序设计中，不可避免地会涉及多个窗体，对话框的设计和调用，如何设计和调用这些对话框和窗体是搞清楚一个庞大的应用程序设计的基础。本章将介绍对话框和多窗体设计，调用方式，数据传递等问题，主要包括以下几点<ul>
<li>Qt 提供的标准对话框的使用，例如打开文件对话框，选择颜色对话框，字体对话框，消息提示和确认选择对话框等</li>
<li>自定义对话框的设计和调用，如何获取返回值，在对话框中如何操作主窗体等</li>
<li>在一个应用程序中如何设计多种窗体，基于QDialog,QWidget和QMainWindow创建的窗体的调用方式有哪些，它们之间有什么区别</li>
<li>如何创建一个在多页组件中管理的多窗体应用，类似于现在流行的多页浏览器的界面效果，子窗体如何与主窗体实现交互</li>
<li>如何创建MDI(Multi-document interface)应用程序</li>
<li>如何创建一个带有启动界面(Splash)和登录界面的窗体，如何保存和读取应用程序设置的参数。</li>
</ul>
</li>
</ul>
<h2 id="第七章-文件系统和文件读写"><a href="#第七章-文件系统和文件读写" class="headerlink" title="第七章 文件系统和文件读写"></a>第七章 文件系统和文件读写</h2><ul>
<li>文件的读写是很多程序具有的功能，甚至某些应用程序就是围绕着某一种格式文件的处理而开发的，所以文件读写是应用程序开发的一个基本功能。</li>
<li>本章介绍Qt中如何实现文本文件，二进制文件的读写，以及文件和目录的管理功能。</li>
</ul>
<h2 id="第八章-绘图"><a href="#第八章-绘图" class="headerlink" title="第八章 绘图"></a>第八章 绘图</h2><ul>
<li>GUI用户界面的优势是通过可视化的界面元素为用户提供遍历的操作，界面上的按钮，编辑框等各种界面组件其实都是通过绘图而得到的。Qt的二维绘图基本功能是使用QPainter在绘图设备上绘图，绘图设备包括QWidget,QPixmap等，通过绘制一些基本的点，线，圆等基本形状组成自己需要的图形，得到的图形是不可交互操作的图形。</li>
<li>Qt还提供了Graphics View架构，使用GraphicsView, QGraphicsScene和各种QGraphicsItem类绘图，在一个场景中可以绘制大量图件，且每个图件是可选择，可交互的，如同矢量图编辑软件那样可以操作每个图件。Graphics View架构为用户绘制复杂的组件化图形提供了便利。</li>
</ul>
<h2 id="第九章-Qt-Charts"><a href="#第九章-Qt-Charts" class="headerlink" title="第九章 Qt Charts"></a>第九章 Qt Charts</h2><ul>
<li>Qt Charts是Qt提供的图表模块，在Qt 5.7以前只有商业版才有Qt Charts，但是从Qt 5.7开始，社区版本也包含了Qt Charts。Qt Charts可以很方便的绘制常见的折线图，柱状图，饼图等图表。</li>
</ul>
<h2 id="第十章-Data-Visualization"><a href="#第十章-Data-Visualization" class="headerlink" title="第十章 Data Visualization"></a>第十章 Data Visualization</h2><ul>
<li>Data Visualization是Qt提供的用于数据三维显示的模块。在Qt 5.7以前只有商业版才有Qt Visualization，但是从Qt 5.7开始，社区版本也包含了Qt Visualization</li>
<li>Data Visualization用于数据的三维显示，包括三维柱状图，三维空间散点，三维曲面等。</li>
</ul>
<h2 id="第十一章-数据库"><a href="#第十一章-数据库" class="headerlink" title="第十一章 数据库"></a>第十一章 数据库</h2><ul>
<li>Qt SQL模块提供数据库编程的支持，Qt支持多种常见的数据库，例如 MySQL, Oracle, MS SQL Server, SQlite等。Qt SQL模块包括多个类，可以实现数据库连接，SQL语句执行，数据获取与界面显示等功能，数据与界面之间使用Model&#x2F;View架构，从而可以方便的实现数据的界面显示和操作。</li>
</ul>
<h2 id="第十二章-自定义插件和库"><a href="#第十二章-自定义插件和库" class="headerlink" title="第十二章 自定义插件和库"></a>第十二章 自定义插件和库</h2><ul>
<li>当UI设计器提供的界面组件不满足实际需求时，可以从QWidget继承自定义界面组件。有两种方法使用自定义界面组件，一种是提升发(promotion)；另一种是为UI设计器设计自定义界面组件的Widget插件，直接安装到UI设计器的组件面板里。</li>
</ul>
<h2 id="第十三章-多线程"><a href="#第十三章-多线程" class="headerlink" title="第十三章 多线程"></a>第十三章 多线程</h2><ul>
<li>Qt为多线程提供了完整的支持。QThread是线程类，是实现多线程操作的核心类，一般从QThread继承定义自己的线程类。线程之间的同步是其交互的主要问题，Qt提供了QMutex，QMutexLocker,QReadWriteLock,QwaitCondition,QSemaphore等多种类用于实现线程之间的同步。Qt还有Qt Concurrent模块，提供一些高级的API实现多线程编程而无需使用QMutex, QwaitCondition和QSemaphore等基础操作。使用Qt Concurrent实现的多线程程序可以自动根据处理器内核个数调整线程个数。</li>
<li>本章主要介绍用QThread实现多线程编程的方法，以及用QMutex，QWaitCondition,QSemaphore等实现线程同步的方法。</li>
</ul>
<h3 id="13-1-QThread创建多线程程序"><a href="#13-1-QThread创建多线程程序" class="headerlink" title="13.1 QThread创建多线程程序"></a>13.1 QThread创建多线程程序</h3><h4 id="13-1-1-QThread类功能简介"><a href="#13-1-1-QThread类功能简介" class="headerlink" title="13.1.1 QThread类功能简介"></a>13.1.1 QThread类功能简介</h4><ul>
<li><p>QThread类提供不依赖于平台的管理线程的方法。一个QThread类的对象管理一个线程，一般从QThread继承一个自定义类，并重定义虚函数run()，在run()函数里实现线程需要完成的任务。</p>
</li>
<li><p>将应用程序的线程称为主线程，额外创建的线程称为工作线程。一般在主线程里创建工作线程，并调用start()开始执行工作线程的任务。start()会在内部调用run()函数，进入工作线程的事件循环，在run()函数里调用exit()或quit()可以结束线程的事件循环，或者在主线程里调用terminate()强制结束线程。</p>
</li>
<li><p>QThread类的主要接口函数，信号和槽函数如下</p>
<ul>
<li>公共函数<ul>
<li>bool isFinished(): 线程是否结束</li>
<li>bool isRunning(): 线程是否正在运行</li>
<li>Priority priority(): 返回线程的优先级</li>
<li>void setPriority(Priority priority): 设置线程的优先级</li>
<li>void exit(int returnCode &#x3D; 0): 退出线程的事件循环，退出码为 returnCode，0表示成功退出，否则表示有错误</li>
<li>bool wait(unsigned long time): 阻止线程执行，直到线程结束(从run()函数返回)，或等待时间超过time(毫秒)</li>
</ul>
</li>
<li>公共槽函数<ul>
<li>void quit(): 退出线程的事件循环，并返回代码0，等效于exit(0)</li>
<li>void start(Priority priority): 内部调用run()开始执行线程，操作系统根据priority参数进行调度</li>
<li>void terminate(): 终止线程的运行，但不是立即结束线程，而是等待操作系统结束线程。使用terminate()之后应使用wait()</li>
</ul>
</li>
<li>信号<ul>
<li>void finished(): 在线程就要结束时发射此信号</li>
<li>void started(): 在线程开始执行，run()函数被调用之前发射此信号</li>
</ul>
</li>
<li>静态公共成员<ul>
<li>int idelThreadCount(): 返回系统上能够运行的线程的理想个数</li>
<li>void msleep(unsigned long msecs): 强制当前线程休眠msecs毫秒</li>
<li>void sleep(unsigned long secs): 强制当前线程休眠secs秒</li>
<li>void usleep(unsigned long usecs): 强制当前线程休眠usecs微妙</li>
</ul>
</li>
<li>保护函数<ul>
<li>virtual void run(): start()调用run()函数开始线程任务的执行，所以在run()函数里实现线程的任务功能</li>
<li>int exec(): 由run()函数调用，进入此线程的事件循环，等待exit()退出。</li>
</ul>
</li>
</ul>
</li>
<li><p>QThread是QObject的子类，所以可以使用信号和槽机制。QThread自身定义了started()和finished()两个信号，started()信号在线程开始执行之前发射，也就是在run()函数被调用之前，finished()信号在线程就要结束时发射。</p>
</li>
</ul>
<h3 id="13-2-线程同步"><a href="#13-2-线程同步" class="headerlink" title="13.2 线程同步"></a>13.2 线程同步</h3><h4 id="13-2-1-线程同步的概念"><a href="#13-2-1-线程同步的概念" class="headerlink" title="13.2.1 线程同步的概念"></a>13.2.1 线程同步的概念</h4><ul>
<li>在多线程应用程序中，由于多个线程的存在，线程之间可能需要访问同一个变量，或一个线程需要等待另外一个线程完成某个操作后才产生相应的动作。</li>
</ul>
<h4 id="13-2-2-基于互斥量的线程同步"><a href="#13-2-2-基于互斥量的线程同步" class="headerlink" title="13.2.2 基于互斥量的线程同步"></a>13.2.2 基于互斥量的线程同步</h4><ul>
<li><p>QMutex和QMutexLocker是基于互斥量的线程同步类，QMutex定义的实例是一个互斥量，QMutex主要提供3个函数</p>
<ul>
<li>lock(): 锁定互斥量，如果另外一个线程锁定了这个互斥量，它将阻塞执行直到其他线程解锁这个互斥量。</li>
<li>unlock(): 解锁一个互斥量，需要与lock()配对使用</li>
<li>tryLock(): 试图锁定一个互斥量，如果成功锁定就返回true；如果其他线程已经锁定了这个互斥量，就返回false，但不阻塞程序执行。</li>
</ul>
</li>
<li><p>定义的互斥量mutex相当于一个标牌，可以这样来理解互斥量: 列车上的卫生间一次智能进一个人，当一个人尝试进入卫生间就是lock()，如果有人占用，它就只能等待；等里面的人出来，腾出了卫生间是unlock()，这个等待的人才可以进入并且锁住卫生间的门，就是lock()，使用完卫生间之后他再出来时就是unlock()</p>
</li>
<li><p>QMutex需要配对使用lock()和unlock()来实现代码段的保护，在一些逻辑复杂的代码段或可能发生一场的代码中，配对就可能出错。</p>
</li>
<li><p>QMutexLocker是另外一个简化了互斥量处理的类。QMutexLocker的构造函数接受一个互斥量作为参数并将其锁定，QMutexLocker的析构函数则将此互斥量解锁，所以在QMutexLocker实例变量的生存期内的代码段得到保护，自动进行互斥量的锁定和解锁。(与C++的自动锁原理一样，构造函数锁住互斥量，析构函数释放互斥量)</p>
</li>
</ul>
<h4 id="13-2-3-基于QReadWriteLock的线程同步"><a href="#13-2-3-基于QReadWriteLock的线程同步" class="headerlink" title="13.2.3 基于QReadWriteLock的线程同步"></a>13.2.3 基于QReadWriteLock的线程同步</h4><ul>
<li><p>使用互斥量时存在一个问题: 每次只能有一个线程获得互斥量的权限。如果在一个程序中有多个线程读取某个变量，使用互斥量时也需要排队。而实际上若只是读取一个变量，是可以让多个线程同时访问的，这样互斥量就会降低程序的性能。</p>
</li>
<li><p>Qt提供了QReadWriteLock类，它是基于读或写的模式进行代码段锁定的，在多个线程读写一个共享数据时，可以解决上面所说的互斥量存在的问题。</p>
</li>
<li><p>QReadWriteLock以读或写锁定的同步方法允许以读或写的方式保护一段代码，它可以允许多个线程以只读方式同步访问资源，但是只要有一个线程以写方式访问资源，其他线程必须等待直到写操作结束。</p>
</li>
<li><p>QReadWriteLock提供一下几个主要的函数</p>
<ul>
<li>lockForRead(): 以只读方式锁定资源，如果有其他线程以写入方式锁定，这个函数会阻塞</li>
<li>lockForWrite(): 以写入方式锁定资源，如果本线程或其他线程以读或写模式锁定资源，这个函数就会阻塞。</li>
<li>unlock(): 解锁</li>
<li>tryLockForRead():  是lockForRead()的非阻塞版本</li>
<li>tryLockForWrite(): 是lockForRead()的非阻塞版本</li>
</ul>
</li>
<li><p>QReadLocker和QWriteLocker是QReadWriteLock的简便形式，如同QMutexLocker是QMutex的简便版本一样，无需与unlock()配对使用。使用QReadLocker和QWriterLocker。</p>
</li>
</ul>
<h4 id="13-2-4-基于QWaitCondition的线程同步"><a href="#13-2-4-基于QWaitCondition的线程同步" class="headerlink" title="13.2.4 基于QWaitCondition的线程同步"></a>13.2.4 基于QWaitCondition的线程同步</h4><ul>
<li><p>在多线程的程序中，多个线程之间的同步实际上就是他们之间的协调问题。前面采用的互斥量和基于QReadWriteLock的方法都是对资源的锁定和解锁，避免同时访问资源时发生冲突。在一个线程解锁资源后，不能及时通知其他线程。</p>
</li>
<li><p>QWaitCondition提供了另外一种改进的线程同步方法，QWaitCondition与QMutex结合，可以使一个线程在满足一定条件时通知其他多个线程，使他们及时做出响应，这样比只使用互斥量效率更高一些。</p>
</li>
<li><p>QWaitCondition提供如下一些函数</p>
<ul>
<li>wait(Qmutex *lockedMutex): 解锁互斥量lockedMutex，并阻塞等待唤醒条件，被唤醒后锁定lockedMutex并退出函数</li>
<li>wakeAll(): 唤醒所有处于等待状态的线程，线程唤醒的顺序不确定，由操作系统的调度策略决定</li>
<li>wakeOne(): 唤醒一个处于等待状态的线程，唤醒哪个线程不确定，由操作系统的调度策略决定</li>
</ul>
</li>
<li><p>QWaitCondition一般用于 “生产者&#x2F;消费者(producer&#x2F;consumer)”模型中。</p>
</li>
</ul>
<h4 id="13-2-5-基于信号量的线程同步"><a href="#13-2-5-基于信号量的线程同步" class="headerlink" title="13.2.5 基于信号量的线程同步"></a>13.2.5 基于信号量的线程同步</h4><ul>
<li><p>信号量(Semaphore)是另一种限制对共享资源进行访问的线程同步机制，它与互斥量(Mutex)相似，但是有区别。一个互斥量只能被锁定依次，而信号量可以多次使用。信号量通常用来保护一定数量的相同的资源，例如数据采集时的双缓冲区。</p>
</li>
<li><p>QSemaphore是实现信号量功能的类，它提供以下几个基本的函数</p>
<ul>
<li>acquire(int n): 尝试获得n个资源。如果没有这么多资源，线程将阻塞直到有n个资源可用</li>
<li>release(int n): 释放n个资源，如果信号量的资源已全部可用之后再release()，就可以创建更多的资源，增加可用资源的个数</li>
<li>int available(): 返回当前信号量可用的资源个数，这个个数永远不可能为负数，如果为0，就说明当前没有资源可用</li>
<li>bool tryAcquire(int n &#x3D; 1): 尝试获取n个资源，不成功时不阻塞线程。</li>
</ul>
</li>
<li><p>在定义QSemaphore的实例时，可以传递一个数值作为初始可用的资源个数。</p>
</li>
</ul>
<h2 id="第十四章-网络编程"><a href="#第十四章-网络编程" class="headerlink" title="第十四章 网络编程"></a>第十四章 网络编程</h2><ul>
<li>Qt网络模块提供了用于编写TCP&#x2F;IP客户端和服务端程序的各种类，例如用于TCP通信的QTcpSocket和QTcpServer，用于UDP通信的QudpSocket，还有用于实现HTTp，FTP等普通网络协议的高级类，例如QNetworkRequest，QNetworkReply和QNetworkAccessManager。</li>
</ul>
<h3 id="14-1-主机信息查询"><a href="#14-1-主机信息查询" class="headerlink" title="14.1 主机信息查询"></a>14.1 主机信息查询</h3><h4 id="14-1-1-QHostInfo-和-QNetworkInterface-类"><a href="#14-1-1-QHostInfo-和-QNetworkInterface-类" class="headerlink" title="14.1.1 QHostInfo 和 QNetworkInterface 类"></a>14.1.1 QHostInfo 和 QNetworkInterface 类</h4><ul>
<li><p>查询一个主机的MAC地址或IP地址是网络应用程序中经常用到的功能。</p>
</li>
<li><p>QHostInfo的静态函数 localHostName() 可获取本机的主机名，静态函数 fromName() 可以通过主机名获取IP地址，静态函数 lookupHost() 可以通过一个主机名，以异步方式查找这个主机的IP地址。</p>
</li>
<li><p>QNetworkInterface 可以获得运行应用程序的主机的所有IP地址和网络接口列表。静态函数 allInterfaces() 返回主机上所有的网络接口的列表，一个网络接口可能包括多个的IP地址，每个IP地址与掩码或广播地址关联。如果无需直到子网掩码和广播的IP地址，使用静态函数 allAddresses() 可以获得主机上的所有IP地址列表。</p>
</li>
</ul>
<h3 id="14-2-TCP通信"><a href="#14-2-TCP通信" class="headerlink" title="14.2 TCP通信"></a>14.2 TCP通信</h3><h4 id="14-2-1-TCP通信概述"><a href="#14-2-1-TCP通信概述" class="headerlink" title="14.2.1 TCP通信概述"></a>14.2.1 TCP通信概述</h4><ul>
<li>TCP(Transmission Control Protocol)是一种被大多数Internet网络协议(例如HTTP和FTP)用于数据传输的低级网络协议，它是可靠的，面向流，面向连接的传输协议，特别适合用于连续数据传输。</li>
</ul>
<h3 id="14-3-QUdpSocket-实现-UDP通信"><a href="#14-3-QUdpSocket-实现-UDP通信" class="headerlink" title="14.3 QUdpSocket 实现 UDP通信"></a>14.3 QUdpSocket 实现 UDP通信</h3><h4 id="14-3-1-UDP通信概述"><a href="#14-3-1-UDP通信概述" class="headerlink" title="14.3.1 UDP通信概述"></a>14.3.1 UDP通信概述</h4><ul>
<li>UDP(User Datagram Protocol，用户数据包协议)是轻量的，不可靠的，面向数据报(datagram)，无连接的协议，它可以用于对可靠性要求不高的场合。与TCP通信不同，两个程序之间进行UDP通信无需预先建立持久的socket连接，UDP每次发送数据报都需要指定目标地址和端口。</li>
<li>UDP消息传送有单播，广播，组播三种模式<ul>
<li>单播(unicast)模式: 一个UDP客户端发出的数据包只发送到另一个指定地址和端口的UDP客户端，是一对一的数据传输</li>
<li>广播(broadcast)模式：一个UDP客户端发出的数据包，在同一个网络范围内其他所有的UDP客户端都可以收到。</li>
<li>组播(multicast)模式: 也称多播。UDP客户端加入到另一个组播IP地址指定的多播组，成员向组播地址发送的数据包组内成员都可以接收到。</li>
</ul>
</li>
<li>使用广播和多播模式，UDP可以实现一些比较灵活的通信功能，而TCP通信只有单播模式，没有广播和多播模式。所以UDP通信虽然不能保证数据传输的准确性，但是具有灵活性，一般的即时通信软件都是基于UDP通信的。</li>
</ul>
<h3 id="14-4-基于HTTP协议的网络应用程序"><a href="#14-4-基于HTTP协议的网络应用程序" class="headerlink" title="14.4 基于HTTP协议的网络应用程序"></a>14.4 基于HTTP协议的网络应用程序</h3><h4 id="14-4-1-实现高层网络操作的类"><a href="#14-4-1-实现高层网络操作的类" class="headerlink" title="14.4.1 实现高层网络操作的类"></a>14.4.1 实现高层网络操作的类</h4><ul>
<li>Qt网络模块提供一些类实现OSI七层网络模型中高层的网络协议，例如HTTP，FTP，SNMP等，这些类主要是QNetworkRequest, QNetworkReply和QNetowrkAccessManager</li>
</ul>
<h2 id="第十五章-多媒体"><a href="#第十五章-多媒体" class="headerlink" title="第十五章 多媒体"></a>第十五章 多媒体</h2><ul>
<li>多媒体功能指的主要是计算机的音频和视频的输入，输出，显示和播放等功能，Qt的多媒体模块为音频和视频播放，录音，摄像头拍照和录像等提供支持，甚至还提供数字收音机的支持。</li>
</ul>
<h3 id="15-1-Qt多媒体模块功能概述"><a href="#15-1-Qt多媒体模块功能概述" class="headerlink" title="15.1 Qt多媒体模块功能概述"></a>15.1 Qt多媒体模块功能概述</h3><ul>
<li>利用Qt多媒体模块提供的各种类，可以实现一般的音频，视频的输入和输出。</li>
</ul>
<h2 id="第十六章-应用程序设计辅助功能"><a href="#第十六章-应用程序设计辅助功能" class="headerlink" title="第十六章 应用程序设计辅助功能"></a>第十六章 应用程序设计辅助功能</h2><ul>
<li>本章介绍Qt应用程序设计的一些辅助功能，包括设计多语言界面，使用样式表定制界面和组件的外观，使用QStyle设置界面外观，以及应用程序发布等。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/22/notebook/MicrosoftVisualStudio/2024-08-22-1-1-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/22/notebook/MicrosoftVisualStudio/2024-08-22-1-1-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1-1-理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-22T09:00:00+08:00">2024-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MicrosoftVisualStudio/" itemprop="url" rel="index"><span itemprop="name">MicrosoftVisualStudio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>关于windows下C++集成开发工具 Microsoft Visual Studio的学习笔记</li>
</ul>
<h2 id="项目和解决方案"><a href="#项目和解决方案" class="headerlink" title="项目和解决方案"></a>项目和解决方案</h2><ul>
<li>解决方案是一个容器，用于组织一个或多个相关的代码项目，例如，类库项目和对应的测试项目。</li>
<li>在Visual Studio中，解决方案不是答案。解决方案仅仅是Visual Studio用来组织一个或多个相关项目的容器。打开某个解决方案时，Visual Studio会自动加载该解决方案包含的所有项目。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/20/notebook/Compiler/2024-08-20-%E5%B8%B8%E8%A7%81C%E5%92%8CCPP%E7%BC%96%E8%AF%91%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/20/notebook/Compiler/2024-08-20-%E5%B8%B8%E8%A7%81C%E5%92%8CCPP%E7%BC%96%E8%AF%91%E5%99%A8/" class="post-title-link" itemprop="url">C和CPP常见编译器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-20 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-20T09:00:00+08:00">2024-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>常见的C和C++编译器相关笔记</li>
<li>目前常见的编译器有<ul>
<li>GCC</li>
<li>LLVM + clang</li>
<li>TCC</li>
<li>MSVC</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/20/notebook/Compiler/2024-08-20-%E5%B8%B8%E8%A7%81C%E5%92%8CCPP%E7%BC%96%E8%AF%91%E5%99%A8/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
