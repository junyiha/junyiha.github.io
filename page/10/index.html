<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/10/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/28/notebook/CMake/cmake_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-08-28-1_02_MasteringCMake/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/28/notebook/CMake/cmake_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-08-28-1_02_MasteringCMake/" class="post-title-link" itemprop="url">MasteringCMake</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-28 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-28T09:00:00+08:00">2024-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cmake官方文档: MasteringCMake 阅读笔记</li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul>
<li>CMake在构建项目时有两个主要的目录: 源代码目录和二进制目录<ul>
<li>源代码目录是存放项目源代码的位置</li>
<li>二进制目录，有时候也成为build目录，是CMake存放最终对象文件，库和可执行文件的位置。</li>
</ul>
</li>
<li>CMake不会向源代码目录写任何文件，只会向二进制目录写文件。</li>
</ul>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><ul>
<li>CMake用各种各样的本地开发工具，将一个或多个CMakeLists 文件作为输入，并生成项目文件或者Makefile使用</li>
<li>下面是典型的CMake处理流程<ul>
<li>项目定义一个或多个CMakeLists文件</li>
<li>CMake配置并生成项目文件</li>
<li>用户按需使用本地开发工具构建项目</li>
</ul>
</li>
</ul>
<h2 id="CMakeLists文件"><a href="#CMakeLists文件" class="headerlink" title="CMakeLists文件"></a>CMakeLists文件</h2><ul>
<li>CMakeLists文件是包含使用CMake语言描述项目的文本文件。</li>
<li>CMake语言表示为一系列的注释，命令和变量。</li>
<li>CMake为什么要有自己的语言？<ul>
<li>因为CMake如果依赖于其他语言，例如Python，就需要在使用CMake时安装其他语言。</li>
<li>有CMake语言能够更高效，更方便。</li>
</ul>
</li>
</ul>
<h2 id="CMake中的Hello-World"><a href="#CMake中的Hello-World" class="headerlink" title="CMake中的Hello World"></a>CMake中的Hello World</h2><ul>
<li><p>示例</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(Hello)</span><br><span class="line"><span class="keyword">add_executable</span>(Hello Hello.c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>CMakeLists文件第一行总会是 cmake_minimum_requried.这使得CMake可以使用指定的版本。</p>
</li>
<li><p>第二行应该是 project 命令。这个命令设置项目的名字，也可以指定其他的参数，例如语言，版本。</p>
</li>
<li><p>最后使用 add_executable 命令用这些给定的源代码文件生成项目的可执行对象。</p>
</li>
</ul>
<h2 id="为CMake指定编译器"><a href="#为CMake指定编译器" class="headerlink" title="为CMake指定编译器"></a>为CMake指定编译器</h2><ul>
<li><p>环境变量 CC 用来指定 C编译器</p>
</li>
<li><p>环境变量 CXX 用来指定 C++编译器</p>
</li>
<li><p>可以在命令行中通过使用 -DCMAKE_CXX_COMPILER&#x3D;cl 来指定编译器</p>
</li>
<li><p>设置 LDFLAGS 用来初始化 链接参数</p>
</li>
<li><p>设置 CXXFLAGS 用来初始化 CMAKE_CXX_FLAGS</p>
</li>
<li><p>设置 CFLAGS 用来初始化 CMAKE_C_FLAGS</p>
</li>
</ul>
<h2 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h2><ul>
<li>构建配置允许以不同的方式构建项目。CMake默认支持的方式有: Debug, Release, MinSizeRel, RelWithDebInfo<ul>
<li>Debug: 打开了基本的调试符号</li>
<li>Release: 打开了基本的优化</li>
<li>MinSizeRel: 产生最小的，但不一定是最快的目标文件</li>
<li>RelWithDebInfo: 既有调试信息，也开启了优化的目标文件</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/27/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-08-27-spdlog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/27/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-08-27-spdlog/" class="post-title-link" itemprop="url">spdlog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-27 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-27T09:00:00+08:00">2024-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="输出文件名和行号"><a href="#输出文件名和行号" class="headerlink" title="输出文件名和行号"></a>输出文件名和行号</h2><ul>
<li>使用宏，例如SPDLOG_INFO</li>
</ul>
<h2 id="使用宏函数输出的日志也写入到文件"><a href="#使用宏函数输出的日志也写入到文件" class="headerlink" title="使用宏函数输出的日志也写入到文件"></a>使用宏函数输出的日志也写入到文件</h2><ul>
<li>使用函数 spdlog::set_default_logger();</li>
<li>示例如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">InitLogger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建控制台日志记录器</span></span><br><span class="line">    <span class="keyword">auto</span> console_sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_color_sink_mt&gt;();</span><br><span class="line">    console_sink-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br><span class="line"></span><br><span class="line">    console_sink-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;[%Y-%m-%d %H:%M:%S.%e][thread %t][%s:%#][%l]: %v&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件日志记录器: 滚动记录，最大文件5M，文件数量100个</span></span><br><span class="line">    std::string log_path = ROOT_PATH;</span><br><span class="line">    log_path += <span class="string">&quot;logs/rotating.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> rotating_sink = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt;(log_path, <span class="number">1048576</span> * <span class="number">5</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步记录器，</span></span><br><span class="line">    std::vector&lt;spdlog::sink_ptr&gt; sinks&#123; console_sink, rotating_sink &#125;;</span><br><span class="line">    <span class="keyword">auto</span> logger = std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">&quot;logger&quot;</span>, sinks.<span class="built_in">begin</span>(), sinks.<span class="built_in">end</span>());</span><br><span class="line">    spdlog::<span class="built_in">register_logger</span>(logger); <span class="comment">//注册为全局日志，通过log_write访问;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宏相关配置</span></span><br><span class="line">    spdlog::<span class="built_in">set_default_logger</span>(logger);</span><br><span class="line">    spdlog::<span class="built_in">set_pattern</span>(<span class="string">&quot;[%Y-%m-%d %H:%M:%S.%e][thread %t][%s:%#][%l]: %v&quot;</span>);</span><br><span class="line">    spdlog::<span class="built_in">set_level</span>(spdlog::level::warn);</span><br><span class="line">    spdlog::<span class="built_in">flush_every</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>)); <span class="comment">//每3s刷新一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><p>logger: 日志对象，每个日志内包含一个sink组成的vector，每个sink可以分别设置优先级，logger本身也可设置优先级。</p>
</li>
<li><p>sink: 直译是水槽，实际上是引流的对象或者可以认为是输出目标，spdlog库内置了多种不同类型的logger可供选择</p>
</li>
<li><p>formatter: 格式化对象，绝大部分情况下spdlog默认的格式就足够用了，但是如果有个性化需求，可以进行自定义格式</p>
</li>
<li><p>level: 日志级别，不同的日志库可能会有不同的设置，但是基本情况下都会有debug,info,warn,error等级别划分来处理不同的情况，具体各个级别的情况可以根据自己的实际情况选取</p>
</li>
<li><p>逻辑关系</p>
<ul>
<li>每个logger包含一个vector,该vector由一个或者多个 std::shared_ptr<sink> 组成，logger的每条日志都会调用sink对象，由sink对象按照formatter的格式输出到指定的地方(有可能是控制台，文件等)</li>
</ul>
</li>
</ul>
<h2 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h2><ul>
<li>formatter也即是格式化对象，用于控制日志的输出格式，spdlog自带了默认的formatter，一般情况下，我们无需任何修改，直接使用即可。需要注意的是，每个sink会有一个formatter</li>
<li>默认formatter的格式为: [日期时间][logger名][log级别]log内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2022-10-13 17:00:55.795] [service] [debug] found env XXXXXXX : true</span><br><span class="line">[2022-10-13 17:00:55.795] [func_config] [debug] kafka_brokers : localhost:9092</span><br><span class="line">[2022-10-13 17:00:55.795] [func_config] [debug] kafka_main_topic : kafka_test</span><br><span class="line">[2022-10-13 17:00:55.795] [func_config] [debug] kafka_partition_value : -1</span><br><span class="line">[2022-10-13 17:00:55.795] [service] [info] initialized</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="sink"><a href="#sink" class="headerlink" title="sink"></a>sink</h2><ul>
<li><p>每个sink对应着一个输出目标和输出格式，它内部包含一个formatter，输出目标可以是控制台，文件等地方。</p>
</li>
<li><p>所有的sink都在命名空间spdlog::sinks下，可以自行探索</p>
</li>
<li><p>spdlog中创建控制台sink非常简单，该方式创建的sink会输出到命令行终端，且是彩色的。后缀的 _mt 代表多线程， _st 代表单线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sink1 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_color_sink_mt&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件sink的类型有很多，这里展示几种经典类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sink1 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::basic_file_sink_mt&gt;(log_file_name);<span class="comment">//最简单的文件sink，只需要指定文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sink2 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::daily_file_sink_mt&gt;(log_file_name, path, <span class="number">14</span>, <span class="number">22</span>);<span class="comment">//每天的14点22分在path下创建新的文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sink3 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt;(log_file_name, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>, <span class="number">100</span>, <span class="literal">false</span>);<span class="comment">//轮转文件，一个文件满了会写到下一个文件，第二个参数是单文件大小上限，第三个参数是文件数量最大值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他sink</p>
<ul>
<li>ostream_sink</li>
<li>syslog_sink</li>
</ul>
</li>
<li><p>sink的flush问题</p>
<ul>
<li>创建好sink后建议设置flush方式，否则可能无法立刻在文件中看到logger的内容</li>
<li>以下为两种重要的flush方式设置(直接设置全局)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">flush_every</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">spdlog::<span class="built_in">flush_on</span>(spdlog::level::debug);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h2><ul>
<li><p>日志对象，每个logger内容包含了一个vector用于存放sink，每个sink都是互相独立</p>
</li>
<li><p>因此一个日志对象在输出日志时可以同时输出到控制台和文件等位置</p>
</li>
<li><p>如果整个项目中只需要一个logger，spdlog提供了最为便捷的logger，注意，该logger在全局公用，输出到控制台，多线程，彩色。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Use the default logger (stdout, multi-threaded, colored)</span></span><br><span class="line">spdlog::<span class="built_in">info</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建特定的logger</p>
<ul>
<li>大部分情况下默认logger是不够用的，因为我们可能需要做不同模块各自的logger，可能需要logger输出到文件进行持久化，所以创建logger是很很重要的一件事。</li>
</ul>
</li>
<li><p>直接创建</p>
<ul>
<li>与创建sink类似，我们可以非常便捷的创建logger。</li>
<li>由于大部分时候一个logger只会有一个sink，所以spdlog提供了创建logger的接口并封装了创建sink的过程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> console = spdlog::<span class="built_in">stdout_color_mt</span>(<span class="string">&quot;some_unique_name&quot;</span>);<span class="comment">//一个输出到控制台的彩色多线程logger，可以指定名字</span></span><br><span class="line"><span class="keyword">auto</span> file_logger = spdlog::<span class="built_in">rotating_logger_mt</span>(<span class="string">&quot;file_logger&quot;</span>, <span class="string">&quot;logs/mylogfile&quot;</span>, <span class="number">1048576</span> * <span class="number">5</span>, <span class="number">3</span>);<span class="comment">//一个输出到指定文件的轮转文件logger，后面的参数指定了文件的信息</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>组合sinks方式创建</p>
<ul>
<li>有时候，单sink的logger不够用，那么可以先创建sink的vector，然后使用sinks_vector创建vector</li>
<li>以下示例中，首先创建了sink的vector，然后创建了两个sink并放入vector，最后使用该vector创建了logger，其中 set_level 的过程不是必须的， register_logger 一般是必须的，否则只能在创建logger的地方使用该logger<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;spdlog::sink_ptr&gt; sinks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sink1 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_color_sink_mt&gt;();</span><br><span class="line">sink1-&gt;<span class="built_in">set_level</span>(MyLoggers::<span class="built_in">getGlobalLevel</span>());</span><br><span class="line">sinks.<span class="built_in">push_back</span>(sink1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sink2 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::rotating_file_sink_mt&gt;(log_file_name, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>, <span class="number">100</span>, <span class="literal">false</span>);</span><br><span class="line">sink2-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br><span class="line">sinks.<span class="built_in">push_back</span>(sink2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> logger = std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">&quot;logger_name&quot;</span>, <span class="built_in">begin</span>(sinks), <span class="built_in">end</span>(sinks));</span><br><span class="line">logger-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br><span class="line">spdlog::<span class="built_in">register_logger</span>(logger);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>logger的注册与获取</p>
<ul>
<li>在一个地方创建了logger却智能在该处使用肯定是不好的，所以spdlog提供了全局注册和获取logger，我们只需要在某处先创建logger并注册，那么后面再其他地方使用时直接获取就可以了</li>
<li>注册: spdlog::register_logger()</li>
<li>获取: spdlog::get()<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的代码中我们注册了一个logger，名字是logger_name，接下来尝试获取</span></span><br><span class="line"><span class="keyword">auto</span> logger = MyLoggers::<span class="built_in">getLogger</span>(<span class="string">&quot;logger_name&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="logger的使用"><a href="#logger的使用" class="headerlink" title="logger的使用"></a>logger的使用</h2><ul>
<li><p>logger的默认level是info，如果处于开发换进给或者生产环境，绘制需要debug级别以上，可以设置logger的级别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以设置全局logger级别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_level</span>(spdlog::level::warn);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以设置sink级别的logger</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sink1-&gt;<span class="built_in">set_level</span>(spdlog::level::info);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意: 一个logger假如有多个sink，那么这些sink分别设置level是可以不同的，但是由于logger本身也有level，所以真正使用时，logger的level如果高于某个sink，会覆盖该sink的level，所以建议此时把logger的level手动设置为debug(默认为info)</p>
</li>
</ul>
<h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul>
<li><p>使用方法一：</p>
<ul>
<li>下载好项目源代码，使用cmake编译，命令:<code>cmake -S . -B build</code>，然后进入build进行make，会获取到一个静态库 <code>libspdlog.a</code></li>
<li>之后通过包含include下的头文件和链接生成的静态库，使用spdlog</li>
</ul>
</li>
<li><p>使用方法二：</p>
<ul>
<li>将头文件和源文件分别添加到相应工程中的头文件和源文件</li>
<li>然后再CMakeLists.txt中添加头文件目录和源文件目录，并且添加一条命令用来编译指定文件：<code>target_compile_definitions($&#123;PROJECT_NAME&#125; PUBLIC SPDLOG_COMPILED_LIB)</code></li>
</ul>
</li>
</ul>
<h3 id="1-2-基本用法"><a href="#1-2-基本用法" class="headerlink" title="1.2 基本用法"></a>1.2 基本用法</h3><ul>
<li><p>输出日志信息到标准输出</p>
<ul>
<li><code>spdlog::info(&quot;This is a log message.&#123;0&#125; &#123;1&#125;&quot;, &quot;hello&quot;, &quot;world&quot;)</code></li>
<li><code>spdlog::warn(&quot;This is a warn message&quot;);</code></li>
<li><code>spdlog::debug(&quot;This message should not be displayed&quot;);</code></li>
<li><code>spdlog::set_level(spdlog::level::trace);  // set specifice logger&#39;s log level</code></li>
<li><code>spdlog::debug(&quot;This message should be displayed, because the level is setted trace&quot;);</code></li>
</ul>
</li>
<li><p>日志信息输出到文件</p>
<ul>
<li>创建基础日志文件：<ul>
<li><code>#include &quot;spdlog/sinks/basic_file_sink.h&quot;</code></li>
<li><code>auto my_logger = spdlog::basic_logger_mt(&quot;file_logger&quot;, &quot;logs/basic-log.txt&quot;, true);</code></li>
<li>创建一个文件为<code>logs/basic-log.txt</code>，并设置输出的消息标识为<code>file_logger</code>的日志文件，通过使用<code>my_logger</code>来操作该日志文件</li>
</ul>
</li>
<li>将日志输出到日志文件中：<ul>
<li><code>my_logger-&gt;info(&quot;Helo Info&quot;);</code></li>
</ul>
</li>
</ul>
</li>
<li><p>输出行号：</p>
<ul>
<li><code>SPDLOG_DEBUG(&quot;some debug message about program: &#123;&#125;&quot;, &quot;robot&quot;);</code></li>
</ul>
</li>
</ul>
<h2 id="spdlog-spdlog-get-函数-详解"><a href="#spdlog-spdlog-get-函数-详解" class="headerlink" title="spdlog spdlog::get()函数 详解"></a>spdlog spdlog::get()函数 详解</h2><p><code>spdlog</code> 是一个快速的 C++ 日志库，广泛用于高效日志记录。<code>spdlog::get()</code> 函数用于获取已经创建的日志记录器（logger）的共享指针。如果指定名称的日志记录器不存在，它会返回 <code>nullptr</code>。</p>
<h3 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;spdlog::logger&gt; <span class="title">spdlog::get</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-参数说明"><a href="#2-参数说明" class="headerlink" title="2. 参数说明"></a>2. 参数说明</h3><ul>
<li><strong>name</strong>: 一个 <code>std::string</code> 类型的参数，表示需要获取的日志记录器的名称。</li>
</ul>
<h3 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h3><ul>
<li><strong><code>std::shared_ptr&lt;spdlog::logger&gt;</code></strong>: 返回一个指向指定名称的日志记录器的共享指针。如果指定名称的日志记录器未找到，则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><p><code>spdlog::get()</code> 通常用于在应用程序的不同模块中共享同一个日志记录器。比如，你在主模块中创建了一个名为 “my_logger” 的日志记录器，之后可以在其他模块中通过 <code>spdlog::get(&quot;my_logger&quot;)</code> 获取同一个记录器，而无需重新创建。</p>
<h3 id="5-示例代码"><a href="#5-示例代码" class="headerlink" title="5. 示例代码"></a>5. 示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;spdlog/spdlog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;spdlog/sinks/basic_file_sink.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个名为 &quot;file_logger&quot; 的日志记录器</span></span><br><span class="line">    <span class="keyword">auto</span> logger = spdlog::<span class="built_in">basic_logger_mt</span>(<span class="string">&quot;file_logger&quot;</span>, <span class="string">&quot;logs.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用记录器进行日志记录</span></span><br><span class="line">    logger-&gt;<span class="built_in">info</span>(<span class="string">&quot;This is an info message&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在其他地方获取并使用相同的记录器</span></span><br><span class="line">    <span class="keyword">auto</span> same_logger = spdlog::<span class="built_in">get</span>(<span class="string">&quot;file_logger&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (same_logger) &#123;</span><br><span class="line">        same_logger-&gt;<span class="built_in">warn</span>(<span class="string">&quot;This is a warning message from the same logger&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        spdlog::<span class="built_in">error</span>(<span class="string">&quot;Logger not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul>
<li><code>spdlog::get()</code> 只返回已经通过 <code>spdlog::register_logger()</code> 或者 <code>spdlog::basic_logger_mt()</code> 等方法注册过的日志记录器。如果未注册过，返回的会是 <code>nullptr</code>。</li>
<li><code>spdlog::get()</code> 函数是线程安全的，因此可以在多线程环境中安全使用。</li>
</ul>
<p>通过 <code>spdlog::get()</code>，你可以在不同模块中灵活地获取和使用日志记录器，确保日志管理的一致性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/25/notebook/VSCode/2024-08-25-3_launch%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/25/notebook/VSCode/2024-08-25-3_launch%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">vscode-launch.json文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-25 10:21:03" itemprop="dateCreated datePublished" datetime="2024-08-25T10:21:03+08:00">2024-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vscode/" itemprop="url" rel="index"><span itemprop="name">vscode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>VSCode下C++程序的调试的配置文件是launch.json。这篇文章是关于launch.json文件的使用笔记，包括常见的参数，常用技巧和常见错误及其解决方法。</li>
</ul>
<h2 id="windows-程序调试阻塞，出现-unable-to-start-Microsoft-Visual-Debug-Console"><a href="#windows-程序调试阻塞，出现-unable-to-start-Microsoft-Visual-Debug-Console" class="headerlink" title="windows 程序调试阻塞，出现 unable to start Microsoft Visual Debug Console."></a>windows 程序调试阻塞，出现 unable to start Microsoft Visual Debug Console.</h2><ul>
<li><p>这个是因为程序输出需要在命令窗口中，在launch.json中console参数是设置命令窗口的启动属性。如果设置了 externalTerminal 则会出现问题。</p>
</li>
<li><p>解决方法</p>
<ul>
<li>将console的值设置为 integratedTerminal</li>
</ul>
</li>
</ul>
<h2 id="console-参数-详解"><a href="#console-参数-详解" class="headerlink" title="console 参数 详解"></a>console 参数 详解</h2><ul>
<li><p>console: Where to launch the debug target. Defaults to ‘internalConsole’ if not defined.</p>
</li>
<li><p>console: 需要调试的程序运行的地方。如果没有定义，默认为 internalConsole</p>
</li>
<li><p>console的值有: </p>
<ul>
<li>externalTerminal: <ul>
<li>Console applications will be launched in an external terminal window. The window will be reused in relaunch scenarios and will not automatically disappear when the application exits.</li>
<li>控制台应用程序将在外部控制台窗口中启动。这个窗口将在程序再次启动时被重复使用，并且不会随着程序退出自动退出。</li>
</ul>
</li>
<li>integratedTerminal<ul>
<li>VS Code’s integrated terminal.</li>
<li>VSCode的集成终端</li>
</ul>
</li>
<li>internalConsole<ul>
<li>Output to the VS Code Debug Console. This doesn’t support reading console input (ex:’std::cin’ or ‘scanf’).</li>
<li>输出到VSCode调试窗口。这个不支持从窗口读取数据，例如 std::cin或 scanf</li>
</ul>
</li>
<li>newExternalWindow<ul>
<li>Console applications will be launched in their own external console window which will end when the application stops. Non-console applications will run without a terminal, and stdout&#x2F;stderr will be ignored.</li>
<li>控制台应用程序将在其自己的外部控制台窗口中启动，该窗口将在应用程序停止时结束。非控制台应用程序在没有终端且标准输出和标准错误输出被忽略的情况下运行。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/23/notebook/Books/2024-08-23-QtC++%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/23/notebook/Books/2024-08-23-QtC++%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Qt5.9 C++开发指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-23 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-23T09:00:00+08:00">2024-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>本书主要介绍如何使用Qt进行C++应用程序开发。</li>
<li>Qt实际上是一套应用程序开发类库，Qt类库由许多模块组成，例如核心的GUI组件模块Qt Widget，用于数据库访问的Qt SQL模块，用于二维图表显示的Qt Charts模块，用于数据三位显示的Qt Data Visualization模块，用于网络编程的Qt Network模块等。</li>
</ul>
<h2 id="第一章-认识Qt"><a href="#第一章-认识Qt" class="headerlink" title="第一章 认识Qt"></a>第一章 认识Qt</h2><h3 id="1-1-Qt简介"><a href="#1-1-Qt简介" class="headerlink" title="1.1 Qt简介"></a>1.1 Qt简介</h3><ul>
<li>C++是一种通用的标准编程语言，使用任何编辑器都可以编写C++源程序，然后利用C++编译器对程序进行编译，就可以生成可执行的程序。</li>
<li>为了方便进行C++程序的编写和编译，有各种综合开发环境(Integrated Developing Environment, IDE)，例如Visual Studio就是Windows平台上常见的编写C++程序的IDE。一个IDE不仅提供程序的编辑和编译，一般还提供一套基本类库，用于提供支持平台应用程序开发的各种基本类，例如Visual Studio使用MFC进行Windows平台的应用程序开发。</li>
<li>Qt是一套应用程序开发类库，但是与MFC不同，Qt是跨平台的开发类库。Qt支持PC和服务器的平台，包括Windows，Linux，macOS等，还支持移动和嵌入式操作系统，例如IOS，Embedded Linux，Andriod，WinRT等。跨平台意味着只需要编写一次程序，在不同平台上无需改动或只需要少许改动后在编译，就可以形成不同平台上运行的版本。</li>
</ul>
<h3 id="1-2-Qt的获取和安装"><a href="#1-2-Qt的获取和安装" class="headerlink" title="1.2 Qt的获取和安装"></a>1.2 Qt的获取和安装</h3><h4 id="1-2-1-Qt的许可类型"><a href="#1-2-1-Qt的许可类型" class="headerlink" title="1.2.1 Qt的许可类型"></a>1.2.1 Qt的许可类型</h4><ul>
<li>Qt的许可类型分为商业许可和开源许可，开源许可又分为LGPLV3和GPLV2&#x2F;GPLV3.</li>
</ul>
<h4 id="1-2-2-Qt的版本"><a href="#1-2-2-Qt的版本" class="headerlink" title="1.2.2 Qt的版本"></a>1.2.2 Qt的版本</h4><ul>
<li>Qt的版本更新比较快，且版本更新时会新增一些类或者停止维护一些以前版本的类。如果不是为了维护用旧版本编写的程序，一定要选用最新版本的Qt进行程序开发。</li>
</ul>
<h4 id="1-2-3-Qt的下载和安装"><a href="#1-2-3-Qt的下载和安装" class="headerlink" title="1.2.3 Qt的下载和安装"></a>1.2.3 Qt的下载和安装</h4><ul>
<li><p>从Qt官网可以下载最新版本的Qt软件。根据开发项目的不同，Qt分为桌面和移动设备应用开发，嵌入式设备开发两大类不同的安装包。</p>
<ul>
<li>桌面和移动设备应用开发就是开发在PC，服务器，手机，平板电脑等设备上运行的程序，操作系统平台可以是Windows，Linux，macOS，Andriod等。</li>
<li>嵌入式设备开发是针对具体的嵌入式设备来开发应用程序，例如物联网设备，汽车电子设备，医疗设备等特定的嵌入式设备。</li>
</ul>
</li>
<li><p>Qt的安装包分为在线安装包和离线安装包，为便于重复安装，最好下载离线安装包。</p>
</li>
<li><p>在安装过程中会出现安装选项设置页面，在这个页面里选择需要安装的模块。这些模块包括内容如下</p>
<ul>
<li>MinGW 编译器模块。MinGW是Minimalist GNU For Windows的缩写，MinGW是Windows平台上使用的GNU工具集导入库的集合。</li>
<li>用于UWP编译的模块。UWP是Windows 10中Universal Windows Platform的简称，有不同编译器类型的UWP</li>
<li>用于Windows平台上的MSVC编译器模块。要安装MSVC编译器的模块，需要计算机上已经安装相应版本的Visual Studio</li>
<li>用于Andriod平台的模块，例如 Andriod x86和Android ARMv7</li>
<li>Sources是Qt的源程序类</li>
<li>Qt Charts是二维图标模块，用于绘制柱状图，饼图，曲线图等常用二维图表</li>
<li>Qt Data Visualization是三维数据图表模块，用于数据的三维显示，例如散点的三维空间分布，三维曲面等</li>
<li>Qt Purchsing，Qt WebEngine, Qt Network Auth(TP)等其他模块，括号里的TP表示技术预览(Technology Preview)</li>
<li>Qt Scritp(Deprecated)是脚本模块，括号里的”Deprecated”表示这是个已经过时的模块</li>
</ul>
</li>
<li><p>“Tools”节点下面是一些工具软件，包括内容如下</p>
<ul>
<li>Qt Creator 是用于Qt程序开发的IDE</li>
<li>MinGW 是MinGW编译工具链</li>
<li>StrawBerry Perl是一个Perl语言工具</li>
</ul>
</li>
<li><p>工具软件有</p>
<ul>
<li>Assistant 是一个独立的查看Qt帮助文件的程序，集成在了Qt Creator中</li>
<li>Designer 是一个独立的进行窗口，对话框等界面可视化设计的程序。Designer也集成在了Qt Creator中，在Qt Creator中编辑或创建界面文件时，就可以自动打开并进行界面设计。</li>
<li>Linguist是一个编辑语言资源文件的程序，在开发多语言界面的应用程序时会用到。</li>
</ul>
</li>
<li><p>这三个工具软件可独立使用，前两个集成到了Qt Creator里，可在Qt Creator打开。所以Qt的主要工具是Qt Creator。</p>
</li>
</ul>
<h3 id="1-3-Qt-Creator初步使用"><a href="#1-3-Qt-Creator初步使用" class="headerlink" title="1.3 Qt Creator初步使用"></a>1.3 Qt Creator初步使用</h3><h3 id="1-4-编写一个Hello-World程序"><a href="#1-4-编写一个Hello-World程序" class="headerlink" title="1.4 编写一个Hello World程序"></a>1.4 编写一个Hello World程序</h3><h4 id="1-4-1-新建一个项目"><a href="#1-4-1-新建一个项目" class="headerlink" title="1.4.1 新建一个项目"></a>1.4.1 新建一个项目</h4><ul>
<li><p>Qt Creator可以创建多种项目，各类应用程序如下</p>
<ul>
<li>Qt Widgets Application，支持桌面平台的有图形用户界面(Graphic User Interface,GUI)界面的应用程序。GUI的设计完全基于C++语言，采用Qt提供的一套C++类库。</li>
<li>Qt Console Application，控制台应用程序，无GUI界面，一般用于学习C&#x2F;C++语言。</li>
<li>Qt Quick Application, 创建可部署的Qt Quick 2应用程序。Qt Quick是Qt支持的一套GUI开发架构，其界面设计采用QML语言，程序架构采用C++语言。利用Qt Quick可以设计非常炫的用户界面，一般用于移动设备或嵌入式设备上无边框的应用程序的设计。</li>
<li>Qt Quick Controls 2 Application，创建基于Qt Quick Controls 2组件的可部署的Qt Quick 2应用程序。</li>
<li>Qt Canvas 3D Application，创建Qt Canvas 3D QML项目，也是基于QML语言的界面设计，支持3D画布。</li>
</ul>
</li>
<li><p>界面的基类(base class)，有3中基类可以选择</p>
<ul>
<li>QMainWindow 是主窗口类，主窗口具有主菜单栏，工具栏和状态栏，类似于一般的应用程序的主窗口；</li>
<li>QWidget 是所有具有可视界面类的基类，选择QWidget创建的界面对各种界面组件都可以支持</li>
<li>QDialog 是对话框类，可建立一个基于对话框的界面</li>
</ul>
</li>
</ul>
<h2 id="第二章-GUI应用程序设计基础"><a href="#第二章-GUI应用程序设计基础" class="headerlink" title="第二章 GUI应用程序设计基础"></a>第二章 GUI应用程序设计基础</h2><ul>
<li>本章深入的介绍Qt Creator设计GUI应用程序的基本方法，包括Qt创建的应用程序项目的 基本组织结构，可视化设计的UI界面文件的原理和运行机制，信号与槽的使用方法，窗体可视化设计的底层原理，应用程序的窗体，组件布局，菜单，工具栏，Actions等常见设计元素的使用方法。</li>
</ul>
<h3 id="2-1-UI文件设计与运行机制"><a href="#2-1-UI文件设计与运行机制" class="headerlink" title="2.1 UI文件设计与运行机制"></a>2.1 UI文件设计与运行机制</h3><h4 id="2-1-1-项目文件组成"><a href="#2-1-1-项目文件组成" class="headerlink" title="2.1.1 项目文件组成"></a>2.1.1 项目文件组成</h4><ul>
<li>一个Widget Application项目包含一下一些文件<ul>
<li>项目组织文件 samp2_1.pro,存储项目设置的文件</li>
<li>主程序入口文件main.cpp,实现main()函数的程序文件</li>
<li>窗体界面文件widget.ui，一个XML格式存储的窗体上的元件及其布局的文件</li>
<li>widget.h是所设计的窗体类的头文件，widget.cpp是widget.h里定义类的实现文件。在C++里，<strong>任何窗体或界面组件都是用类封装的</strong>，一个类一般有一个头文件和一个源文件。</li>
</ul>
</li>
</ul>
<h4 id="2-1-2-项目管理文件"><a href="#2-1-2-项目管理文件" class="headerlink" title="2.1.2 项目管理文件"></a>2.1.2 项目管理文件</h4><ul>
<li>后缀为.pro的文件是项目的管理文件，文件名就是项目的名称</li>
</ul>
<h4 id="2-1-3-界面文件"><a href="#2-1-3-界面文件" class="headerlink" title="2.1.3 界面文件"></a>2.1.3 界面文件</h4><ul>
<li>后缀为 .ui 的文件是可视化设计的窗体的定义文件，例如 widget.ui</li>
<li>本书后面将成这个集成在Qt Creator中的Qt Designer为 UI设计器，以便与独立运行的Qt Designer区别开来</li>
</ul>
<h4 id="2-1-4-主函数文件"><a href="#2-1-4-主函数文件" class="headerlink" title="2.1.4 主函数文件"></a>2.1.4 主函数文件</h4><ul>
<li>main函数是应用程序的入口。它的主要功能是创建应用程序，创建窗口，显示窗口，并运行从应用程序，开始应用程序的消息循环和事件处理。</li>
</ul>
<h4 id="2-1-5-窗体相关的文件"><a href="#2-1-5-窗体相关的文件" class="headerlink" title="2.1.5 窗体相关的文件"></a>2.1.5 窗体相关的文件</h4><ul>
<li>为了搞清楚窗体类的定义，以及界面功能的实现原理，香茗居编译后会自动生成一个文件 ui_widget.h，这样对于一个窗体，就有四个文件<ul>
<li>widget.h 定义窗体类的头文件定义了类Widget</li>
<li>widget.cpp Widget类的功能实现源程序文件</li>
<li>widget.ui 窗体界面文件，由UI设计器自动生成，存储了窗体上各个组件的属性设置和布局</li>
<li>ui_widget.h 编译后，根据窗体上的组件及其属性，信号与槽的关联自动生成的一个类的定义文件，类的名称是Ui_Widget</li>
</ul>
</li>
</ul>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><h4 id="2-2-3-信号与槽"><a href="#2-2-3-信号与槽" class="headerlink" title="2.2.3 信号与槽"></a>2.2.3 信号与槽</h4><ul>
<li><p>信号与槽(Signal &amp; Slot)是Qt编程的基础，也是Qt的一大创新。因为有了信号与槽的编程机制，在Qt中处理界面各个组件的交互操作时变得更加直观和简单。</p>
</li>
<li><p>信号(Signal)就是在特定情况下被发射的事件，例如PushButton最常见的信号就是鼠标单击时发射的clicked()信号，一个ComboBox最常见的信号是选择的列表项变化时发射的CurrentIndexChanged()信号。GUI程序设计的主要内容就是对界面上各组件的信号的相应，只需要知道什么情况下发射哪些信号，合理的去响应和处理这些信号就可以了。</p>
</li>
<li><p>槽(Slot)就是对信号响应的函数。槽就是一个函数，与一般的C++函数是一样的，可以定义在类的任何部分(public, private或protected)，可以具有任何参数，也可以被直接调用。槽函数与一般函数不同的是: <strong>槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行</strong>。</p>
</li>
<li><p>信号与槽关联是用QObject::connect()函数实现的，其基本格式是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">signal</span>()), reciver, <span class="built_in">SLOT</span>(<span class="built_in">slot</span>()));</span><br></pre></td></tr></table></figure></li>
<li><p>connect()是QObject类的一个静态函数，而QObject是所有Qt类的基类，在实际调用时可以忽略前面的限定符，所以可以直接写为: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">signal</span>()), reciver, <span class="built_in">SLOT</span>(<span class="built_in">slot</span>()));</span><br></pre></td></tr></table></figure>
<ul>
<li>其中，sender是发射信号的对象的名称，signal()是信号名称。信号可以看作是特殊的函数，需要带括号，有参数时还需要指明参数。receiver是接收信号的对象名称，slot()是槽函数的名称，需要带括号，有参数时还需要指明参数。</li>
<li>SIGNAL和SLOT是Qt的宏，用于指明信号和槽，并将它们的参数转换为相应的字符串。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(btnClose, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), Widget, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br></pre></td></tr></table></figure></li>
<li>其作用就是将btnClose按钮的clicked()信号与窗体(Widget)的槽函数close()相关联，这样，当单击btnClose按钮时，就会执行Widget的Close()槽函数。</li>
</ul>
</li>
<li><p>关于信号与槽的使用，有以下一些规则需要注意</p>
<ul>
<li>一个信号可以连接多个槽，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(spinNum, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">addFun</span>(<span class="type">int</span>)));</span><br><span class="line"><span class="built_in">connect</span>(spinNum, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">updateStatus</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>
<ul>
<li>这是当一个对象spinNUm的数值发生变化时，所在窗体有两个槽进行响应，一个addFun()用于计算，一个updateStatus()用于更新状态。</li>
<li>当一个信号与多个槽函数关联时，槽函数按照建立连接时的顺序依次执行。</li>
<li>当信号和槽函数带有参数时，在connect()函数里，要写明参数的类型，但可以不写参数名称。</li>
</ul>
</li>
<li>多个信号可以连接同一个槽，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;rBtnBlue, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">setTextFontColor</span>()));</span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;rBtnRed, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOG</span>(<span class="built_in">setTextFontColor</span>()));</span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;rBtnBlack, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOG</span>(<span class="built_in">setTextFontColor</span>()));</span><br></pre></td></tr></table></figure>
<ul>
<li>这样，当任何一个RadioButton被单击时，都会执行setTextFontColor()函数。</li>
</ul>
</li>
<li>一个信号可以连接另外一个信号，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(spinNum, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">refreshInfo</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>
<ul>
<li>这样，当一个信号发射时，也会发射另外一个信号，实现某些特殊的功能。</li>
</ul>
</li>
<li>严格情况下，信号与槽的参数个数和类型需要一致，至少信号的参数不能少于槽的参数。如果不匹配，会出现编译错误或运行错误。</li>
<li>在使用信号与槽的类中，必须在类的定义中加入宏Q_OBJECT</li>
<li>当一个信号被发射时，与其关联的槽函数通常被立即执行，就像正常调用一个函数一样。只有当信号关联的所有槽函数执行完毕后，才会执行发射信号处后面的代码。</li>
</ul>
</li>
<li><p>信号与槽机制是Qt GUI编程的基础，使用信号与槽机制可以比较容易的将信号与响应代码关联起来。</p>
</li>
</ul>
<h2 id="第三章-Qt类库概述"><a href="#第三章-Qt类库概述" class="headerlink" title="第三章 Qt类库概述"></a>第三章 Qt类库概述</h2><ul>
<li>Qt是一个用标准C++编写的跨平台开发类库，它对标准C++进行了扩展，引入了元对象系统，信号与槽，属性等特性，使应用程序的开发变得更高效。本章将介绍Qt的这些核心特点，对于理解和编写高效的Qt C++程序是大有帮助的。</li>
<li>本章还介绍<QtGlobal>头文件中Qt的一些全局定义，包括数据类型，函数和宏等，介绍Qt的容器类及其响应迭代器的使用方法。这些全局定义和容器类在程序中经常用到，了解其原理便于理解后面遇到的一些实例程序。</li>
<li>Qt类库中大量的类是以模块形式分类组织的，包括基本模块和扩展模块等，本章对这些模块做一个总体的介绍。一个模块通常就是一个编程主题，例如数据库，图表，网格等。本书后面的章节一般是每章介绍一个编程主题。</li>
</ul>
<h3 id="3-1-Qt核心特点"><a href="#3-1-Qt核心特点" class="headerlink" title="3.1 Qt核心特点"></a>3.1 Qt核心特点</h3><h4 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1 概述"></a>3.1.1 概述</h4><ul>
<li><p>Qt本身并不是一种编程语言，它实质上是一个跨平台的C++开发类库，是用标准C++编写的类库，它为开发GUI应用程序和非GUI应用程序提供了各种类。</p>
</li>
<li><p>Qt对标准C++进行了扩展，引入了一些新的概念和功能，例如信号与槽，对象属性等。Qt的元对象编译器(Meta-Object Compiler, MOC)是一个预处理器，在源程序被编译前先将这些Qt特性的程序转换为标准C++兼容的形式，然后再由标准C++编译器进行编译。这就是为什么在使用信号与槽机制的类里，必须添加一个Q_OBJECT宏的原因，只有添加了这个宏，moc才能对类里的信号与槽的代码进行预处理。</p>
</li>
<li><p>Qt Core模块是Qt类库的核心，所有其他模块都依赖于此模块。Qt 为C++语言增加的特性就是在Qt Core模块里实现的，这些扩展特性由Qt的元对象系统实现，包括信号与槽机制，属性系统，动态类型转换等。</p>
</li>
</ul>
<h4 id="3-1-2-元对象系统"><a href="#3-1-2-元对象系统" class="headerlink" title="3.1.2 元对象系统"></a>3.1.2 元对象系统</h4><ul>
<li><p>Qt的元对象系统(Meta-Object System)提供了对象之间通信的信号与槽机制，运行时类型信息和动态属性系统。</p>
</li>
<li><p>元对象系统由以下三个基础组成</p>
<ul>
<li>QObject类是所有使用元对象系统的类的基类。</li>
<li>在一个类的private部分声明Q_OBJECT宏，使得类可以使用元对象的特性，例如动态属性，信号与槽。</li>
<li>MOC(元对象编译器)为每个QObject的子类提供必要的代码来实现元对象系统的特性。</li>
</ul>
</li>
<li><p>构建项目时，MOC工具读取C++源文件，当它发现类的定义里有Q_OBJECT宏时，它就会为这个类生成另外一个包含有元对象支持代码的C++源文件，这个生成的源文件连同类的实现文件一起被编译和链接。</p>
</li>
<li><p>除了信号与槽机制外，元对象还提供如下一些功能</p>
<ul>
<li>QOBject::metaObject()函数返回类关联的元对象，元对象类QMetaObject包含了访问对象的一些接口函数，例如QMetaObject::className()函数可在运行时返回类的名称字符串。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QObject *obj = <span class="keyword">new</span> QPushButton;</span><br><span class="line">obj-&gt;<span class="built_in">metaObject</span>()-&gt;<span class="built_in">className</span>();  <span class="comment">// 返回&quot;QPushButton</span></span><br></pre></td></tr></table></figure></li>
<li>QMetaObject::newInstance()函数创建类的一个新的实例</li>
<li>QObject::inherits(const char* className)函数判断一个对象实例是否是名称为className的类或QObject的子类的实例。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTimer *timer = <span class="keyword">new</span> QTimer; <span class="comment">// QTimer是QObject的子类</span></span><br><span class="line">timer-&gt;<span class="built_in">inherits</span>(<span class="string">&quot;QTimer&quot;</span>);  <span class="comment">// 返回true</span></span><br><span class="line">timer-&gt;<span class="built_in">inherits</span>(<span class="string">&quot;QObject&quot;</span>); <span class="comment">// 返回true</span></span><br><span class="line">timer-&gt;<span class="built_in">inherits</span>(<span class="string">&quot;QAbstractButton&quot;</span>); <span class="comment">// 返回false，不是QAbstractButton的子类</span></span><br></pre></td></tr></table></figure></li>
<li>QObject::tr()和QObject::trUtf8()函数可翻译字符串，用于多语言界面设计。</li>
<li>QObject::setProperty()和QObject::property()函数用于通过属性名称动态设置和获取属性值。</li>
</ul>
</li>
<li><p>对于QObject及其子类，还可以使用qobject_cast()函数进行动态映射(dynamic cast)。</p>
</li>
<li><p>使用动态投射，使得程序可以在运行时对不同的对象做不同的处理。</p>
</li>
</ul>
<h4 id="3-1-3-属性系统"><a href="#3-1-3-属性系统" class="headerlink" title="3.1.3 属性系统"></a>3.1.3 属性系统</h4><ul>
<li>Qt提供一个 Q_PROPERTY()宏可以定义属性，它也是基于元对象系统实现的。Qt的属性系统与C++编译器无关，可以用任何标准的C++编译器编译定义了属性的QtC++程序。</li>
<li>Q_PROPERTY宏定义一个返回值类型为type，名称为name的属性，用READ，WRITE关键字定义属性的读取，写入函数，还有其他的一些关键字定义属性的一些操作特性。属性的类型可以是QVariant支持的任何类型，也可以用户自定义类型。</li>
<li>Q_PROPERTY宏定义属性的一些主要关键字的意义如下</li>
<li>READ: 指定一个读取属性值的函数，没有MEMBER关键字时必须设置READ</li>
<li>WRITE: 指定一个设定属性值的函数，只读属性没有WRITE设置</li>
<li>MEMBER: 指定一个成员变量与属性关联，成为可读可写的属性，无需再设置READ和WRITE</li>
<li>RESET: 是可选的，用于指定一个设置属性缺省值的函数</li>
<li>NOTIFY: 是可选的，用于设置一个信号，当属性值变化时发射此信号</li>
<li>DESIGNABLE: 表示属性是否在Qt Designer里可见，缺省为true</li>
<li>CONSTANT: 表示属性值是一个常数，对于一个对象实例，READ指定的函数返回值是常数，但是每个实例的返回值可以不一样。具有CONSTANT关键字的属性不能有WRITE和NOTIFY关键字。</li>
<li>FINAL: 表示所定义的属性不能被子类重载</li>
</ul>
<h4 id="3-1-4-信号与槽"><a href="#3-1-4-信号与槽" class="headerlink" title="3.1.4 信号与槽"></a>3.1.4 信号与槽</h4><ul>
<li><p>信号与槽是Qt的一个核心特点，也是它区别于其他框架的重要特性。信号与槽是对象间进行通信的机制，也需要由Qt的元对象系统支持才能实现的。</p>
</li>
<li><p>Qt使用信号与槽的机制实现对象间通信，它隐藏了复杂的底层实现，完成信号与槽的关联后，发射信号时并不需要知道Qt是如何找到槽函数的。Qt的信号与槽机制与Delphi和C++ Builder的”事件–响应”比较类似，但是更加灵活。</p>
</li>
<li><p>某些开发架构使用回调函数(callback)实现对象间通信。与回调函数相比，信号与槽的执行速度稍微慢一点，因为需要查找连接的对象和槽函数，但是这种差别在应用程序运行时是感觉不到的，而其提供的灵活性却比回调函数强很多。</p>
</li>
<li><p>对信号与槽的特点和用法做一些补充</p>
<ol>
<li>connect()函数的不同参数形式</li>
</ol>
<ul>
<li>QObject::connect()函数有多重参数形式，一种参数形式的函数原型是<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender, <span class="type">const</span> <span class="type">char</span> *signal, <span class="type">const</span> QObject *receiver, <span class="type">const</span> <span class="type">char</span> *method, Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>使用这种参数形式的connect()进行信号与槽函数的连接时，一般句法如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">signal</span>()), receiver, <span class="built_in">SLOT</span>(<span class="built_in">slot</span>()));</span><br></pre></td></tr></table></figure></li>
<li>这里使用了宏SIGNAL()和SLOT()指定信号和槽函数，而且如果信号和槽函数带有参数，还需要注明参数类型，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(spinNum, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">updateStatus</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure></li>
<li>另外一种参数形式的connect()函数的原型是:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender, <span class="type">const</span> QMetaMethod &amp;signal, <span class="type">const</span> QObject *receiver, <span class="type">const</span> QMetaMethod &amp;method, Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>对于具有默认参数的信号与槽(即信号名称是唯一的，没有参数不同而同名的两个信号)，可以使用这种函数指针形式进行关联，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(lineEdit, &amp;QLineEdit::textChanged, <span class="keyword">this</span>, &amp;widget::on_textChanged);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>不管是哪种参数形式的connect()函数，最后一个参数Qt::ConnectionType type，缺省值为Qt::AutoConnection。枚举类型Qt::ConnectionType表示了信号与槽之间的关联方式，有以下几种取值:</p>
<ul>
<li>Qt::AutoConnection(缺省值): 如果信号的接收者与发射者在同一个线程，就使用Qt::DirectConnection方式；否则使用Qt::QueuedConnection方式，在信号发射时自动确定关联方式</li>
<li>Qt::DirectConnection: 信号被发射时槽函数立即执行，槽函数与信号在同一个线程</li>
<li>Qt::QueuedConnection: 在事件循环回到接收者线程后执行槽函数，槽函数与信号在不同的线程。</li>
<li>Qt::BlockingQueuedConnection: 与Qt::QueuedConnection相似，只是信号线程会阻塞直到槽函数执行完毕。当信号与槽函数在同一个线程时绝对不能使用这种方式，否则会造成死锁。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>使用sender()获得信号发射者<ul>
<li>在槽函数里，使用QObject::sender()可以获取信号发射者的指针。如果知道信号发射者的类型，可以将指针投射为确定的类型，然后使用这个确定类的接口函数。</li>
</ul>
</li>
<li>自定义信号及其使用<ul>
<li>在自己设计的类里也可以自定义信号，<strong>信号就是在类定义里声明的一个函数，但是这个函数无需实现，只需要发射(emit)</strong>  </li>
<li>例如，在下面的自定义类QPerson的signals部分定义一个信号ageChanged(int)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QPerson</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">incAge</span><span class="params">()</span></span>;</span><br><span class="line">signals:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ageChanged</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li>信号函数必须是无返回值的函数，但是可以有输入参数。信号函数无需实现，只需在某些条件下发射信号。例如，在incAge()函数中发射信号，其代码如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPerson::incAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_age++;</span><br><span class="line">  <span class="function">emit <span class="title">ageChanged</span><span class="params">(m_age)</span></span>; <span class="comment">// 发射信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在incAge()函数里，当私有变量m_age变化后，发射信号ageChanged(int)，表示年龄发生了变化。至于是否有此信号相关联的槽函数，信号发射者并不管。如果在使用QPerson类对象的程序中为此信号关联了槽函数，在incAge()函数里发射此信号时，就会执行相关联的槽函数。至于是否立即执行槽函数，发射信号的线程是否等待槽函数执行完之后再执行后面的代码，与connect()函数设置信号与槽关联时设置的连接类型以及信号与槽是否在同一个线程有关。</li>
</ul>
<h3 id="3-2-Qt全局定义"><a href="#3-2-Qt全局定义" class="headerlink" title="3.2 Qt全局定义"></a>3.2 Qt全局定义</h3><ul>
<li><QtGlobal>头文件包含了Qt类库的一些全局定义，包括基本数据类型，函数和宏，一般的Qt类的头文件都会包含该文件，所以不用显示包含这个头文件也可以使用其中的定义。</li>
</ul>
<h4 id="3-2-1-数据类型定义"><a href="#3-2-1-数据类型定义" class="headerlink" title="3.2.1 数据类型定义"></a>3.2.1 数据类型定义</h4><ul>
<li>为了确保在各个平台上各数据类型都有统一确定的长度，Qt为各种常见数据类型定义了类型符号，例如qint8就是signed char的类型定义，即 typedef signed char qint8;</li>
</ul>
<h4 id="3-2-2-函数"><a href="#3-2-2-函数" class="headerlink" title="3.2.2 函数"></a>3.2.2 函数</h4><ul>
<li><QtGlobal>头文件包含一些常用函数的定义，这些函数多以模板类型作为参数，返回相应的模板类型，模板类型可以用任何其他类型替换。若是以double或float类型作为参数的，一般有两个参数版本的额同名函数，例如qFuzzyIsNull(double d)和qFuzzyIsNull(float f)。</li>
<li>还有一些基础的数学运算函数在<QtMath>头文件中定义，例如三角运算函数，弧度与角度之间的转换函数等。</li>
</ul>
<h4 id="3-2-3-宏定义"><a href="#3-2-3-宏定义" class="headerlink" title="3.2.3 宏定义"></a>3.2.3 宏定义</h4><ul>
<li><p><QtGlobal>头文件中定义了很多宏，以下是一些比较常用的</p>
</li>
<li><p>QT_VERSION</p>
<ul>
<li>这个宏展开为数值形式0xMMNNPP(MM &#x3D; major, NN &#x3D; minor, PP &#x3D; patch)表示Qt编译器版本，例如Qt编译器版本为Qt 5.9.1，则QT_VERSION为0x050901。这个宏常用于条件编译设置，根据Qt版本不同，编译不同的代码段。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> QT_VERSION &gt;= 0x040100</span></span><br><span class="line">  QIcon icon = <span class="built_in">style</span>()-&gt;<span class="built_in">standardIcon</span>(QStyle::SP_TrashIcon);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  QPixmap pixmap = <span class="built_in">style</span>()-&gt;<span class="built_in">standardPixmap</span>(QStyle::SP_TrashIcon);</span><br><span class="line">  <span class="function">QIcon <span class="title">icon</span><span class="params">(pixmap)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>QT_VERSION_CHECK</p>
<ul>
<li>这个宏展开为Qt版本号的一个整数表示，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5, 0, 0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>QT_VERSION_STR</p>
<ul>
<li>这个宏展开为Qt版本号的字符串，例如 “5.9.0”</li>
</ul>
</li>
<li><p>Q_BYTE_ORDER, Q_BIG_ENDIAN 和 Q_LITTLE_ENDIAN</p>
<ul>
<li>Q_BYTE_ORDER 表示系统内存中数据的字节序，</li>
<li>Q_BIG_ENDIAN 表示大端字节序</li>
<li>Q_LITTLE_ENDIAN 表示小端字节序。</li>
<li>在需要判断系统字节序时会用到，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> Q_BYTE_ORDER == Q_LITTLE_ENDIAN</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Q_DECL_IMPORT, Q_DECL_EXPORT</p>
<ul>
<li>在使用或设计共享库时，用于导入或到处库的内容</li>
</ul>
</li>
<li><p>Q_DECL_OVERRIDE</p>
<ul>
<li>在类定义中，用于重载一个虚函数，例如在某个类中重载虚函数paintEvent(),可以定义如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent*)</span> Q_DECL_OVERRIDE</span>;</span><br></pre></td></tr></table></figure></li>
<li>使用Q_DECL_OVERRIDE宏后，如果重载的虚函数没有进行任何重载操作，编译器将会报错。</li>
</ul>
</li>
<li><p>Q_DECL_FINAL</p>
<ul>
<li>这个宏将一个虚函数定义为最终级别，不能再被重载，或定义一个类不能再被继承，实例如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QRect</span> Q_DECL_FINAL &#123;  <span class="comment">// QRect不能再被继承</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Q_UNUSED(name)</p>
<ul>
<li>这个宏用于在函数中定义不在函数体里使用的参数，示例如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_imageSaved</span><span class="params">(<span class="type">int</span> id, <span class="type">const</span> QString &amp;filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">Q_UNUSED</span>(id);</span><br><span class="line">  LabInfo-&gt;<span class="built_in">setText</span>(<span class="string">&quot;图片保存为: &quot;</span> + filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在这个函数里，id参数没有使用。如果不用Q_UNUSED(id)定义，编译器会出现参数未使用的警告。</li>
</ul>
</li>
<li><p>foreach(variable, container)</p>
<ul>
<li>foreach用于容器类的遍历，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foreach (<span class="type">const</span> QString &amp;codecName, recorder-&gt;<span class="built_in">supportedAudioCodecs</span>())</span><br><span class="line">  ui-&gt;comboCodec-&gt;<span class="built_in">addItem</span>(codecName);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>forever</p>
<ul>
<li>forever用于构造一个无限循环，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forever &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>qDebug(const char *message, …)</p>
<ul>
<li>在debugger窗体显示信息，如果编译器设置了 Qt_NO_DEBUG_OUTPUT，则不作任何输出，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>(<span class="string">&quot;Item in list: %d&quot;</span>, myList.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>类似的宏还有 qWarning, qCritical, qFatal, qInfo等，也是用于在debugger窗体显示信息。</p>
</li>
</ul>
<h3 id="3-3-容器类"><a href="#3-3-容器类" class="headerlink" title="3.3 容器类"></a>3.3 容器类</h3><h4 id="3-3-1-容器类概述"><a href="#3-3-1-容器类概述" class="headerlink" title="3.3.1 容器类概述"></a>3.3.1 容器类概述</h4><ul>
<li><p>Qt提供了多个基于模板的容器类，这些容器类可以用于存储指定类型的数据项，例如常用的字符串列表类QStringList就是从容器类QList<QString>继承的，实现对字符串列表的添加，存储，删除等操作。</p>
</li>
<li><p>Qt的容器壁标准模板库(STL)中的容器类更轻巧，安全和易于使用。这些容器类是隐式共享和可重入的，而且他们进行了速度和存储优化，因此可以减少可执行文件的大小。此外，它们还是线程安全的，也就是说<strong>它们作为只读容器时可以被多个线程访问</strong>。</p>
</li>
<li><p>容器类是基于模板的类，如常用的容器类QList<T>，T是一个具体的类型，可以是int, float等简单的类型，也可以是QString, QDate等类，但是不能是QObject或任何其子类。T必须是一个可赋值的类型，即T必须提供一个缺省的构造函数，一个可复制构造函数和一个赋值运算符。</p>
</li>
<li><p>Qt的容器类分为顺序容器(sequential containers)和关联容器(associative containers)</p>
</li>
<li><p>容器迭代类用于遍历容器里的数据项，有Java类型的迭代类和STL类型的迭代类。Java类型的迭代类易于使用，提供高级功能，而STL类型的迭代类效率更高一些。</p>
</li>
<li><p>Qt还提供了foreach宏用于遍历容器内的所有数据项。</p>
</li>
</ul>
<h4 id="3-3-2-顺序容器类"><a href="#3-3-2-顺序容器类" class="headerlink" title="3.3.2 顺序容器类"></a>3.3.2 顺序容器类</h4><ul>
<li><p>Qt的顺序容器类有 QList, QLinkedList, QVector, QStack和QQueue</p>
</li>
<li><p>QList</p>
<ul>
<li>QList是最常用的容器类，虽然它是以数组列表(array-list)的形式实现的，但是在其前或后添加数据非常快。QList以下标索引的方式对数据项进行访问。</li>
</ul>
</li>
<li><p>QLinkedList</p>
<ul>
<li>QLinkedList<T>是链式列表(linked-list),数据项不是用连续的内存存储的，它基于迭代器访问数据项，并且插入和删除数据项的操作时间相同。<br>除了不提供基于下标索引的数据项访问外，QLinkedList的其他接口函数与QList基本相同。</li>
</ul>
</li>
<li><p>QVector</p>
<ul>
<li>QVector<T>提供动态数组的功能，以下标索引访问数据。</li>
<li>QVector的函数接口与QList几乎完全相同，QVector<T>的性能比QList<T>更高，因为QVector<T>的数据项是连续存储的。</li>
</ul>
</li>
<li><p>QStack</p>
<ul>
<li>QStack<T>是提供类似于堆栈的后入先出(LIFO)操作的容器类，push()和pop()是主要的接口函数。</li>
</ul>
</li>
<li><p>QQueue</p>
<ul>
<li>QQueue<T>是提供类似于队列先入先出(FIFO)操作的容器类。enqueue()和dequeue()是主要的操作函数</li>
</ul>
</li>
</ul>
<h4 id="3-3-3-关联容器类"><a href="#3-3-3-关联容器类" class="headerlink" title="3.3.3 关联容器类"></a>3.3.3 关联容器类</h4><ul>
<li><p>Qt还提供关联容器类 QMap, QMultiMap, QHash, QMultiHash和QSet</p>
</li>
<li><p>QMultiMap和QMultiHash支持一个键关联多个值，QHash和QMultiHash类使用散列(Hash)函数进行查找，查找速度较快</p>
</li>
<li><p>QSet</p>
<ul>
<li>QSet是基于散列列表的集合模板类，它存储数据的顺序是不定的，查找值的速度非常快。QSet<T>内部就是用QHash实现的。</li>
<li>测试一个值是否包含于这个集合，用contains()函数</li>
</ul>
</li>
<li><p>QMap</p>
<ul>
<li>QMap&lt;Key, T&gt;提供一个字典(关联数组)，一个键映射到一个值。QMap存储数据是按照键的顺序，如果不在乎存储顺序，使用QHash会更快</li>
</ul>
</li>
<li><p>QMultiMap</p>
<ul>
<li>QMultiMap是QMap的子类，是用于处理多值映射的便利类</li>
</ul>
</li>
<li><p>QHash</p>
<ul>
<li>QHash是基于散列表来实现字典功能的模板类，QHash&lt;Key, T&gt;存储的键值对具有非常快的查找速度。</li>
</ul>
</li>
<li><p>QHash与QMap的功能和用法相似，区别在于以下几点</p>
<ul>
<li>QHash比QMap的查找速度更快</li>
<li>在QMap上遍历时，数据项是按照键排序的，而QHash的数据项是任意顺序的</li>
<li>QMap的键必须提供 “&lt;” 运算符，QHash的键必须提供 “&#x3D;&#x3D;” 运算符和一个名称为 qHash() 的全局散列函数</li>
</ul>
</li>
<li><p>QMultiHash</p>
<ul>
<li>QMultiHash是QHash的子类，是哟弄个与处理多值映射的便利类，其用法与QMultiMap类似</li>
</ul>
</li>
</ul>
<h3 id="3-4-容器类的迭代"><a href="#3-4-容器类的迭代" class="headerlink" title="3.4 容器类的迭代"></a>3.4 容器类的迭代</h3><ul>
<li>迭代器(iterator)为访问容器类里的数据项提供了统一的方法，Qt有两种迭代器类: Java类型的迭代器和STL类型的迭代器</li>
<li>Java类型的迭代器更易于使用，且提供一些高级功能，而STL类型的迭代器效率更高。</li>
</ul>
<h4 id="3-4-1-Java类型迭代器"><a href="#3-4-1-Java类型迭代器" class="headerlink" title="3.4.1 Java类型迭代器"></a>3.4.1 Java类型迭代器</h4><h4 id="3-4-2-STL类型迭代器"><a href="#3-4-2-STL类型迭代器" class="headerlink" title="3.4.2 STL类型迭代器"></a>3.4.2 STL类型迭代器</h4><ul>
<li><p>STL迭代器与Qt和STL的原生算法兼容，并且进行了速度优化</p>
</li>
<li><p>对于每一个容器类，都有两个STL类型迭代器：一个用于只读访问，一个用于读写访问。无需修改数据时一定使用只读迭代器，因为它们速度更快。</p>
</li>
<li><p>STL类型的迭代器是数组的指针，所以 “++” 运算符使迭代器指向下一个数据项， “*”运算符返回数据项内容。</p>
</li>
<li><p>隐式共享(Implicit Sharing)是对象的管理方法，一个对象被隐式共享，只是传递该对象的一个指针给使用者，而不实际复制对象数据，只有在使用者修改数据时，才实质复制共享对象给使用者。</p>
</li>
<li><p>对于STL类型的容器，隐式共享还涉及到另外一个问题，即当有一个迭代器在操作一个容器变量时，不要去复制这个容器变量。</p>
</li>
</ul>
<h4 id="3-4-3-foreach关键字"><a href="#3-4-3-foreach关键字" class="headerlink" title="3.4.3 foreach关键字"></a>3.4.3 foreach关键字</h4><ul>
<li>如果只是想遍历容器中所有的项，可以使用foreach关键字。foreach是<QtGlobal>头文件中定义的一个宏。</li>
<li><strong>foreach关键字遍历一个容器变量是创建了容器的一个副本，所以不能修改原来容器变量的数据项</strong>。</li>
</ul>
<h3 id="3-5-Qt类库的模块"><a href="#3-5-Qt类库的模块" class="headerlink" title="3.5 Qt类库的模块"></a>3.5 Qt类库的模块</h3><ul>
<li>Qt类库里大量的类根据功能分为各种模块，这些模块又分为几大类<ul>
<li>Qt基本模块(Qt Essentials): 提供了Qt在所有平台上的基本功能</li>
<li>Qt附加模块(Qt Add-Ons): 实现一些特定功能的提供附加价值的模块</li>
<li>增值模块(Value-Add Modules): 单独发布的提供额外价值的模块或工具</li>
<li>技术预览模块(Technology Preview Modules): 一些处于开发阶段，但是可以作为技术预览使用的模块</li>
<li>Qt工具(Qt Tools): 帮助应用程序开发的一些工具。</li>
</ul>
</li>
</ul>
<h4 id="3-5-1-Qt基本模块"><a href="#3-5-1-Qt基本模块" class="headerlink" title="3.5.1 Qt基本模块"></a>3.5.1 Qt基本模块</h4><ul>
<li>Qt基本模块是Qt在所有平台上的基本功能，它们在所有的开发平台和目标平台上都可用，在Qt5所有版本上是源代码和二进制兼容的。具体的基本模块如下<ul>
<li>Qt Core: 其他模块都用到的核心非图形类</li>
<li>Qt GUI: 设计GUI界面的基础类，包括OpenGL</li>
<li>Qt Multimedia: 音频，视频，摄像头和广播功能的类</li>
<li>Qt Multimedia Widgets: 实现多媒体功能的界面组件类</li>
<li>Qt Network: 使网路编程更简单和轻便的类</li>
<li>Qt QML: 用于QML和JavaScript语言的类</li>
<li>Qt Quick: 用于构建具有定制用户界面的动态应用程序的声明框架</li>
<li>Qt Quick Controls: 创建桌面样式用户界面，基于Qt Quick的用户界面控件</li>
<li>Qt Quick Dialogs: 用于Qt Quick的系统对话框类型</li>
<li>Qt Quick Layouts: 用于Qt Quick 2界面元素的布局项</li>
<li>Qt SQL: 使用SQL用于数据库操作的类</li>
<li>Qt Test: 用于应用程序和库进行单元测试的类</li>
<li>Qt Widgets: 用于构建GUI界面的C++图形组件类</li>
</ul>
</li>
</ul>
<h4 id="3-5-2-Qt附加模块"><a href="#3-5-2-Qt附加模块" class="headerlink" title="3.5.2 Qt附加模块"></a>3.5.2 Qt附加模块</h4><h4 id="3-5-3-增值模块"><a href="#3-5-3-增值模块" class="headerlink" title="3.5.3 增值模块"></a>3.5.3 增值模块</h4><h4 id="3-5-4-技术预览模块"><a href="#3-5-4-技术预览模块" class="headerlink" title="3.5.4 技术预览模块"></a>3.5.4 技术预览模块</h4><h4 id="4-5-5-Qt-工具"><a href="#4-5-5-Qt-工具" class="headerlink" title="4.5.5 Qt 工具"></a>4.5.5 Qt 工具</h4><ul>
<li>Qt工具在所有支持的平台上都可以使用，用于帮助应用程序的开发和设计<ul>
<li>Qt Designer: 用于扩展Qt Designer的类</li>
<li>Qt Help: 在应用程序中集成在线文档的类，实现类似于Qt Assistant的功能</li>
<li>Qt UI Tools: 操作Qt Designer生成的窗体的类</li>
</ul>
</li>
</ul>
<h2 id="第四章-常用界面设计组件"><a href="#第四章-常用界面设计组件" class="headerlink" title="第四章 常用界面设计组件"></a>第四章 常用界面设计组件</h2><h2 id="第五章-Model-View结构"><a href="#第五章-Model-View结构" class="headerlink" title="第五章 Model&#x2F;View结构"></a>第五章 Model&#x2F;View结构</h2><ul>
<li>Model&#x2F;View(模型&#x2F;视图)结构是Qt中用界面组件显示与编辑数据结构的一种结构，视图(View)是显示和编辑数据的界面组件，模型(Model)是视图与原始数据之间的接口。Model&#x2F;View结构的典型应用是在是数据库应用程序中。</li>
<li>主要的视图组件有 QListVew, QTreeView和QTableView</li>
</ul>
<h2 id="第六章-对话框与多窗体设计"><a href="#第六章-对话框与多窗体设计" class="headerlink" title="第六章 对话框与多窗体设计"></a>第六章 对话框与多窗体设计</h2><ul>
<li>在一个完整的应用程序设计中，不可避免地会涉及多个窗体，对话框的设计和调用，如何设计和调用这些对话框和窗体是搞清楚一个庞大的应用程序设计的基础。本章将介绍对话框和多窗体设计，调用方式，数据传递等问题，主要包括以下几点<ul>
<li>Qt 提供的标准对话框的使用，例如打开文件对话框，选择颜色对话框，字体对话框，消息提示和确认选择对话框等</li>
<li>自定义对话框的设计和调用，如何获取返回值，在对话框中如何操作主窗体等</li>
<li>在一个应用程序中如何设计多种窗体，基于QDialog,QWidget和QMainWindow创建的窗体的调用方式有哪些，它们之间有什么区别</li>
<li>如何创建一个在多页组件中管理的多窗体应用，类似于现在流行的多页浏览器的界面效果，子窗体如何与主窗体实现交互</li>
<li>如何创建MDI(Multi-document interface)应用程序</li>
<li>如何创建一个带有启动界面(Splash)和登录界面的窗体，如何保存和读取应用程序设置的参数。</li>
</ul>
</li>
</ul>
<h2 id="第七章-文件系统和文件读写"><a href="#第七章-文件系统和文件读写" class="headerlink" title="第七章 文件系统和文件读写"></a>第七章 文件系统和文件读写</h2><ul>
<li>文件的读写是很多程序具有的功能，甚至某些应用程序就是围绕着某一种格式文件的处理而开发的，所以文件读写是应用程序开发的一个基本功能。</li>
<li>本章介绍Qt中如何实现文本文件，二进制文件的读写，以及文件和目录的管理功能。</li>
</ul>
<h2 id="第八章-绘图"><a href="#第八章-绘图" class="headerlink" title="第八章 绘图"></a>第八章 绘图</h2><ul>
<li>GUI用户界面的优势是通过可视化的界面元素为用户提供遍历的操作，界面上的按钮，编辑框等各种界面组件其实都是通过绘图而得到的。Qt的二维绘图基本功能是使用QPainter在绘图设备上绘图，绘图设备包括QWidget,QPixmap等，通过绘制一些基本的点，线，圆等基本形状组成自己需要的图形，得到的图形是不可交互操作的图形。</li>
<li>Qt还提供了Graphics View架构，使用GraphicsView, QGraphicsScene和各种QGraphicsItem类绘图，在一个场景中可以绘制大量图件，且每个图件是可选择，可交互的，如同矢量图编辑软件那样可以操作每个图件。Graphics View架构为用户绘制复杂的组件化图形提供了便利。</li>
</ul>
<h2 id="第九章-Qt-Charts"><a href="#第九章-Qt-Charts" class="headerlink" title="第九章 Qt Charts"></a>第九章 Qt Charts</h2><ul>
<li>Qt Charts是Qt提供的图表模块，在Qt 5.7以前只有商业版才有Qt Charts，但是从Qt 5.7开始，社区版本也包含了Qt Charts。Qt Charts可以很方便的绘制常见的折线图，柱状图，饼图等图表。</li>
</ul>
<h2 id="第十章-Data-Visualization"><a href="#第十章-Data-Visualization" class="headerlink" title="第十章 Data Visualization"></a>第十章 Data Visualization</h2><ul>
<li>Data Visualization是Qt提供的用于数据三维显示的模块。在Qt 5.7以前只有商业版才有Qt Visualization，但是从Qt 5.7开始，社区版本也包含了Qt Visualization</li>
<li>Data Visualization用于数据的三维显示，包括三维柱状图，三维空间散点，三维曲面等。</li>
</ul>
<h2 id="第十一章-数据库"><a href="#第十一章-数据库" class="headerlink" title="第十一章 数据库"></a>第十一章 数据库</h2><ul>
<li>Qt SQL模块提供数据库编程的支持，Qt支持多种常见的数据库，例如 MySQL, Oracle, MS SQL Server, SQlite等。Qt SQL模块包括多个类，可以实现数据库连接，SQL语句执行，数据获取与界面显示等功能，数据与界面之间使用Model&#x2F;View架构，从而可以方便的实现数据的界面显示和操作。</li>
</ul>
<h2 id="第十二章-自定义插件和库"><a href="#第十二章-自定义插件和库" class="headerlink" title="第十二章 自定义插件和库"></a>第十二章 自定义插件和库</h2><ul>
<li>当UI设计器提供的界面组件不满足实际需求时，可以从QWidget继承自定义界面组件。有两种方法使用自定义界面组件，一种是提升发(promotion)；另一种是为UI设计器设计自定义界面组件的Widget插件，直接安装到UI设计器的组件面板里。</li>
</ul>
<h2 id="第十三章-多线程"><a href="#第十三章-多线程" class="headerlink" title="第十三章 多线程"></a>第十三章 多线程</h2><ul>
<li>Qt为多线程提供了完整的支持。QThread是线程类，是实现多线程操作的核心类，一般从QThread继承定义自己的线程类。线程之间的同步是其交互的主要问题，Qt提供了QMutex，QMutexLocker,QReadWriteLock,QwaitCondition,QSemaphore等多种类用于实现线程之间的同步。Qt还有Qt Concurrent模块，提供一些高级的API实现多线程编程而无需使用QMutex, QwaitCondition和QSemaphore等基础操作。使用Qt Concurrent实现的多线程程序可以自动根据处理器内核个数调整线程个数。</li>
<li>本章主要介绍用QThread实现多线程编程的方法，以及用QMutex，QWaitCondition,QSemaphore等实现线程同步的方法。</li>
</ul>
<h3 id="13-1-QThread创建多线程程序"><a href="#13-1-QThread创建多线程程序" class="headerlink" title="13.1 QThread创建多线程程序"></a>13.1 QThread创建多线程程序</h3><h4 id="13-1-1-QThread类功能简介"><a href="#13-1-1-QThread类功能简介" class="headerlink" title="13.1.1 QThread类功能简介"></a>13.1.1 QThread类功能简介</h4><ul>
<li><p>QThread类提供不依赖于平台的管理线程的方法。一个QThread类的对象管理一个线程，一般从QThread继承一个自定义类，并重定义虚函数run()，在run()函数里实现线程需要完成的任务。</p>
</li>
<li><p>将应用程序的线程称为主线程，额外创建的线程称为工作线程。一般在主线程里创建工作线程，并调用start()开始执行工作线程的任务。start()会在内部调用run()函数，进入工作线程的事件循环，在run()函数里调用exit()或quit()可以结束线程的事件循环，或者在主线程里调用terminate()强制结束线程。</p>
</li>
<li><p>QThread类的主要接口函数，信号和槽函数如下</p>
<ul>
<li>公共函数<ul>
<li>bool isFinished(): 线程是否结束</li>
<li>bool isRunning(): 线程是否正在运行</li>
<li>Priority priority(): 返回线程的优先级</li>
<li>void setPriority(Priority priority): 设置线程的优先级</li>
<li>void exit(int returnCode &#x3D; 0): 退出线程的事件循环，退出码为 returnCode，0表示成功退出，否则表示有错误</li>
<li>bool wait(unsigned long time): 阻止线程执行，直到线程结束(从run()函数返回)，或等待时间超过time(毫秒)</li>
</ul>
</li>
<li>公共槽函数<ul>
<li>void quit(): 退出线程的事件循环，并返回代码0，等效于exit(0)</li>
<li>void start(Priority priority): 内部调用run()开始执行线程，操作系统根据priority参数进行调度</li>
<li>void terminate(): 终止线程的运行，但不是立即结束线程，而是等待操作系统结束线程。使用terminate()之后应使用wait()</li>
</ul>
</li>
<li>信号<ul>
<li>void finished(): 在线程就要结束时发射此信号</li>
<li>void started(): 在线程开始执行，run()函数被调用之前发射此信号</li>
</ul>
</li>
<li>静态公共成员<ul>
<li>int idelThreadCount(): 返回系统上能够运行的线程的理想个数</li>
<li>void msleep(unsigned long msecs): 强制当前线程休眠msecs毫秒</li>
<li>void sleep(unsigned long secs): 强制当前线程休眠secs秒</li>
<li>void usleep(unsigned long usecs): 强制当前线程休眠usecs微妙</li>
</ul>
</li>
<li>保护函数<ul>
<li>virtual void run(): start()调用run()函数开始线程任务的执行，所以在run()函数里实现线程的任务功能</li>
<li>int exec(): 由run()函数调用，进入此线程的事件循环，等待exit()退出。</li>
</ul>
</li>
</ul>
</li>
<li><p>QThread是QObject的子类，所以可以使用信号和槽机制。QThread自身定义了started()和finished()两个信号，started()信号在线程开始执行之前发射，也就是在run()函数被调用之前，finished()信号在线程就要结束时发射。</p>
</li>
</ul>
<h3 id="13-2-线程同步"><a href="#13-2-线程同步" class="headerlink" title="13.2 线程同步"></a>13.2 线程同步</h3><h4 id="13-2-1-线程同步的概念"><a href="#13-2-1-线程同步的概念" class="headerlink" title="13.2.1 线程同步的概念"></a>13.2.1 线程同步的概念</h4><ul>
<li>在多线程应用程序中，由于多个线程的存在，线程之间可能需要访问同一个变量，或一个线程需要等待另外一个线程完成某个操作后才产生相应的动作。</li>
</ul>
<h4 id="13-2-2-基于互斥量的线程同步"><a href="#13-2-2-基于互斥量的线程同步" class="headerlink" title="13.2.2 基于互斥量的线程同步"></a>13.2.2 基于互斥量的线程同步</h4><ul>
<li><p>QMutex和QMutexLocker是基于互斥量的线程同步类，QMutex定义的实例是一个互斥量，QMutex主要提供3个函数</p>
<ul>
<li>lock(): 锁定互斥量，如果另外一个线程锁定了这个互斥量，它将阻塞执行直到其他线程解锁这个互斥量。</li>
<li>unlock(): 解锁一个互斥量，需要与lock()配对使用</li>
<li>tryLock(): 试图锁定一个互斥量，如果成功锁定就返回true；如果其他线程已经锁定了这个互斥量，就返回false，但不阻塞程序执行。</li>
</ul>
</li>
<li><p>定义的互斥量mutex相当于一个标牌，可以这样来理解互斥量: 列车上的卫生间一次智能进一个人，当一个人尝试进入卫生间就是lock()，如果有人占用，它就只能等待；等里面的人出来，腾出了卫生间是unlock()，这个等待的人才可以进入并且锁住卫生间的门，就是lock()，使用完卫生间之后他再出来时就是unlock()</p>
</li>
<li><p>QMutex需要配对使用lock()和unlock()来实现代码段的保护，在一些逻辑复杂的代码段或可能发生一场的代码中，配对就可能出错。</p>
</li>
<li><p>QMutexLocker是另外一个简化了互斥量处理的类。QMutexLocker的构造函数接受一个互斥量作为参数并将其锁定，QMutexLocker的析构函数则将此互斥量解锁，所以在QMutexLocker实例变量的生存期内的代码段得到保护，自动进行互斥量的锁定和解锁。(与C++的自动锁原理一样，构造函数锁住互斥量，析构函数释放互斥量)</p>
</li>
</ul>
<h4 id="13-2-3-基于QReadWriteLock的线程同步"><a href="#13-2-3-基于QReadWriteLock的线程同步" class="headerlink" title="13.2.3 基于QReadWriteLock的线程同步"></a>13.2.3 基于QReadWriteLock的线程同步</h4><ul>
<li><p>使用互斥量时存在一个问题: 每次只能有一个线程获得互斥量的权限。如果在一个程序中有多个线程读取某个变量，使用互斥量时也需要排队。而实际上若只是读取一个变量，是可以让多个线程同时访问的，这样互斥量就会降低程序的性能。</p>
</li>
<li><p>Qt提供了QReadWriteLock类，它是基于读或写的模式进行代码段锁定的，在多个线程读写一个共享数据时，可以解决上面所说的互斥量存在的问题。</p>
</li>
<li><p>QReadWriteLock以读或写锁定的同步方法允许以读或写的方式保护一段代码，它可以允许多个线程以只读方式同步访问资源，但是只要有一个线程以写方式访问资源，其他线程必须等待直到写操作结束。</p>
</li>
<li><p>QReadWriteLock提供一下几个主要的函数</p>
<ul>
<li>lockForRead(): 以只读方式锁定资源，如果有其他线程以写入方式锁定，这个函数会阻塞</li>
<li>lockForWrite(): 以写入方式锁定资源，如果本线程或其他线程以读或写模式锁定资源，这个函数就会阻塞。</li>
<li>unlock(): 解锁</li>
<li>tryLockForRead():  是lockForRead()的非阻塞版本</li>
<li>tryLockForWrite(): 是lockForRead()的非阻塞版本</li>
</ul>
</li>
<li><p>QReadLocker和QWriteLocker是QReadWriteLock的简便形式，如同QMutexLocker是QMutex的简便版本一样，无需与unlock()配对使用。使用QReadLocker和QWriterLocker。</p>
</li>
</ul>
<h4 id="13-2-4-基于QWaitCondition的线程同步"><a href="#13-2-4-基于QWaitCondition的线程同步" class="headerlink" title="13.2.4 基于QWaitCondition的线程同步"></a>13.2.4 基于QWaitCondition的线程同步</h4><ul>
<li><p>在多线程的程序中，多个线程之间的同步实际上就是他们之间的协调问题。前面采用的互斥量和基于QReadWriteLock的方法都是对资源的锁定和解锁，避免同时访问资源时发生冲突。在一个线程解锁资源后，不能及时通知其他线程。</p>
</li>
<li><p>QWaitCondition提供了另外一种改进的线程同步方法，QWaitCondition与QMutex结合，可以使一个线程在满足一定条件时通知其他多个线程，使他们及时做出响应，这样比只使用互斥量效率更高一些。</p>
</li>
<li><p>QWaitCondition提供如下一些函数</p>
<ul>
<li>wait(Qmutex *lockedMutex): 解锁互斥量lockedMutex，并阻塞等待唤醒条件，被唤醒后锁定lockedMutex并退出函数</li>
<li>wakeAll(): 唤醒所有处于等待状态的线程，线程唤醒的顺序不确定，由操作系统的调度策略决定</li>
<li>wakeOne(): 唤醒一个处于等待状态的线程，唤醒哪个线程不确定，由操作系统的调度策略决定</li>
</ul>
</li>
<li><p>QWaitCondition一般用于 “生产者&#x2F;消费者(producer&#x2F;consumer)”模型中。</p>
</li>
</ul>
<h4 id="13-2-5-基于信号量的线程同步"><a href="#13-2-5-基于信号量的线程同步" class="headerlink" title="13.2.5 基于信号量的线程同步"></a>13.2.5 基于信号量的线程同步</h4><ul>
<li><p>信号量(Semaphore)是另一种限制对共享资源进行访问的线程同步机制，它与互斥量(Mutex)相似，但是有区别。一个互斥量只能被锁定依次，而信号量可以多次使用。信号量通常用来保护一定数量的相同的资源，例如数据采集时的双缓冲区。</p>
</li>
<li><p>QSemaphore是实现信号量功能的类，它提供以下几个基本的函数</p>
<ul>
<li>acquire(int n): 尝试获得n个资源。如果没有这么多资源，线程将阻塞直到有n个资源可用</li>
<li>release(int n): 释放n个资源，如果信号量的资源已全部可用之后再release()，就可以创建更多的资源，增加可用资源的个数</li>
<li>int available(): 返回当前信号量可用的资源个数，这个个数永远不可能为负数，如果为0，就说明当前没有资源可用</li>
<li>bool tryAcquire(int n &#x3D; 1): 尝试获取n个资源，不成功时不阻塞线程。</li>
</ul>
</li>
<li><p>在定义QSemaphore的实例时，可以传递一个数值作为初始可用的资源个数。</p>
</li>
</ul>
<h2 id="第十四章-网络编程"><a href="#第十四章-网络编程" class="headerlink" title="第十四章 网络编程"></a>第十四章 网络编程</h2><ul>
<li>Qt网络模块提供了用于编写TCP&#x2F;IP客户端和服务端程序的各种类，例如用于TCP通信的QTcpSocket和QTcpServer，用于UDP通信的QudpSocket，还有用于实现HTTp，FTP等普通网络协议的高级类，例如QNetworkRequest，QNetworkReply和QNetworkAccessManager。</li>
</ul>
<h3 id="14-1-主机信息查询"><a href="#14-1-主机信息查询" class="headerlink" title="14.1 主机信息查询"></a>14.1 主机信息查询</h3><h4 id="14-1-1-QHostInfo-和-QNetworkInterface-类"><a href="#14-1-1-QHostInfo-和-QNetworkInterface-类" class="headerlink" title="14.1.1 QHostInfo 和 QNetworkInterface 类"></a>14.1.1 QHostInfo 和 QNetworkInterface 类</h4><ul>
<li><p>查询一个主机的MAC地址或IP地址是网络应用程序中经常用到的功能。</p>
</li>
<li><p>QHostInfo的静态函数 localHostName() 可获取本机的主机名，静态函数 fromName() 可以通过主机名获取IP地址，静态函数 lookupHost() 可以通过一个主机名，以异步方式查找这个主机的IP地址。</p>
</li>
<li><p>QNetworkInterface 可以获得运行应用程序的主机的所有IP地址和网络接口列表。静态函数 allInterfaces() 返回主机上所有的网络接口的列表，一个网络接口可能包括多个的IP地址，每个IP地址与掩码或广播地址关联。如果无需直到子网掩码和广播的IP地址，使用静态函数 allAddresses() 可以获得主机上的所有IP地址列表。</p>
</li>
</ul>
<h3 id="14-2-TCP通信"><a href="#14-2-TCP通信" class="headerlink" title="14.2 TCP通信"></a>14.2 TCP通信</h3><h4 id="14-2-1-TCP通信概述"><a href="#14-2-1-TCP通信概述" class="headerlink" title="14.2.1 TCP通信概述"></a>14.2.1 TCP通信概述</h4><ul>
<li>TCP(Transmission Control Protocol)是一种被大多数Internet网络协议(例如HTTP和FTP)用于数据传输的低级网络协议，它是可靠的，面向流，面向连接的传输协议，特别适合用于连续数据传输。</li>
</ul>
<h3 id="14-3-QUdpSocket-实现-UDP通信"><a href="#14-3-QUdpSocket-实现-UDP通信" class="headerlink" title="14.3 QUdpSocket 实现 UDP通信"></a>14.3 QUdpSocket 实现 UDP通信</h3><h4 id="14-3-1-UDP通信概述"><a href="#14-3-1-UDP通信概述" class="headerlink" title="14.3.1 UDP通信概述"></a>14.3.1 UDP通信概述</h4><ul>
<li>UDP(User Datagram Protocol，用户数据包协议)是轻量的，不可靠的，面向数据报(datagram)，无连接的协议，它可以用于对可靠性要求不高的场合。与TCP通信不同，两个程序之间进行UDP通信无需预先建立持久的socket连接，UDP每次发送数据报都需要指定目标地址和端口。</li>
<li>UDP消息传送有单播，广播，组播三种模式<ul>
<li>单播(unicast)模式: 一个UDP客户端发出的数据包只发送到另一个指定地址和端口的UDP客户端，是一对一的数据传输</li>
<li>广播(broadcast)模式：一个UDP客户端发出的数据包，在同一个网络范围内其他所有的UDP客户端都可以收到。</li>
<li>组播(multicast)模式: 也称多播。UDP客户端加入到另一个组播IP地址指定的多播组，成员向组播地址发送的数据包组内成员都可以接收到。</li>
</ul>
</li>
<li>使用广播和多播模式，UDP可以实现一些比较灵活的通信功能，而TCP通信只有单播模式，没有广播和多播模式。所以UDP通信虽然不能保证数据传输的准确性，但是具有灵活性，一般的即时通信软件都是基于UDP通信的。</li>
</ul>
<h3 id="14-4-基于HTTP协议的网络应用程序"><a href="#14-4-基于HTTP协议的网络应用程序" class="headerlink" title="14.4 基于HTTP协议的网络应用程序"></a>14.4 基于HTTP协议的网络应用程序</h3><h4 id="14-4-1-实现高层网络操作的类"><a href="#14-4-1-实现高层网络操作的类" class="headerlink" title="14.4.1 实现高层网络操作的类"></a>14.4.1 实现高层网络操作的类</h4><ul>
<li>Qt网络模块提供一些类实现OSI七层网络模型中高层的网络协议，例如HTTP，FTP，SNMP等，这些类主要是QNetworkRequest, QNetworkReply和QNetowrkAccessManager</li>
</ul>
<h2 id="第十五章-多媒体"><a href="#第十五章-多媒体" class="headerlink" title="第十五章 多媒体"></a>第十五章 多媒体</h2><ul>
<li>多媒体功能指的主要是计算机的音频和视频的输入，输出，显示和播放等功能，Qt的多媒体模块为音频和视频播放，录音，摄像头拍照和录像等提供支持，甚至还提供数字收音机的支持。</li>
</ul>
<h3 id="15-1-Qt多媒体模块功能概述"><a href="#15-1-Qt多媒体模块功能概述" class="headerlink" title="15.1 Qt多媒体模块功能概述"></a>15.1 Qt多媒体模块功能概述</h3><ul>
<li>利用Qt多媒体模块提供的各种类，可以实现一般的音频，视频的输入和输出。</li>
</ul>
<h2 id="第十六章-应用程序设计辅助功能"><a href="#第十六章-应用程序设计辅助功能" class="headerlink" title="第十六章 应用程序设计辅助功能"></a>第十六章 应用程序设计辅助功能</h2><ul>
<li>本章介绍Qt应用程序设计的一些辅助功能，包括设计多语言界面，使用样式表定制界面和组件的外观，使用QStyle设置界面外观，以及应用程序发布等。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/22/notebook/MicrosoftVisualStudio/2024-08-22-1-1-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/22/notebook/MicrosoftVisualStudio/2024-08-22-1-1-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1-1-理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-22T09:00:00+08:00">2024-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MicrosoftVisualStudio/" itemprop="url" rel="index"><span itemprop="name">MicrosoftVisualStudio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>关于windows下C++集成开发工具 Microsoft Visual Studio的学习笔记</li>
</ul>
<h2 id="项目和解决方案"><a href="#项目和解决方案" class="headerlink" title="项目和解决方案"></a>项目和解决方案</h2><ul>
<li>解决方案是一个容器，用于组织一个或多个相关的代码项目，例如，类库项目和对应的测试项目。</li>
<li>在Visual Studio中，解决方案不是答案。解决方案仅仅是Visual Studio用来组织一个或多个相关项目的容器。打开某个解决方案时，Visual Studio会自动加载该解决方案包含的所有项目。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/20/notebook/Compiler/2024-08-20-%E5%B8%B8%E8%A7%81C%E5%92%8CCPP%E7%BC%96%E8%AF%91%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/20/notebook/Compiler/2024-08-20-%E5%B8%B8%E8%A7%81C%E5%92%8CCPP%E7%BC%96%E8%AF%91%E5%99%A8/" class="post-title-link" itemprop="url">C和CPP常见编译器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-20 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-20T09:00:00+08:00">2024-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>常见的C和C++编译器相关笔记</li>
<li>目前常见的编译器有<ul>
<li>GCC</li>
<li>LLVM + clang</li>
<li>TCC</li>
<li>MSVC</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/20/notebook/Compiler/2024-08-20-%E5%B8%B8%E8%A7%81C%E5%92%8CCPP%E7%BC%96%E8%AF%91%E5%99%A8/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/05/notebook/Compiler/2024-08-05-ld_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/05/notebook/Compiler/2024-08-05-ld_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">ld_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-05 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-05T09:00:00+08:00">2024-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ld链接器相关理论基础</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/05/notebook/Compiler/2024-08-05-ld_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/04/notebook/Tools/2024-08-04-%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/04/notebook/Tools/2024-08-04-%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">流媒体技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-04 11:00:00" itemprop="dateCreated datePublished" datetime="2024-08-04T11:00:00+08:00">2024-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>流媒体相关笔记</li>
</ul>
<h2 id="ZLMediaKit-关于流媒体的知识点"><a href="#ZLMediaKit-关于流媒体的知识点" class="headerlink" title="ZLMediaKit 关于流媒体的知识点"></a>ZLMediaKit 关于流媒体的知识点</h2><h3 id="流媒体简介"><a href="#流媒体简介" class="headerlink" title="流媒体简介"></a>流媒体简介</h3><ul>
<li>流媒体(streaming media)是指将一连串的媒体数据压缩后，经过网络分段发送数据，在网上即时传输影音以供观赏的一种技术与过程，此技术使得数据包得以像流水一样发送；如果不使用此技术，就必须在使用前下载整个媒体文件，这种对于实时性要求比较高的场景而言，显然是不现实的，所以流媒体技术为此孕育而生。</li>
<li>传统的视频监控，IPTV，以及这几年兴起的视频直播，网络授课都属于流媒体的范畴，从广义上来讲，视频通话，视频会议也属于流媒体。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/01/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-08-01-%E4%B8%B4%E6%97%B6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/01/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-08-01-%E4%B8%B4%E6%97%B6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">临时笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-01 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-01T09:00:00+08:00">2024-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Personal/" itemprop="url" rel="index"><span itemprop="name">Personal</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MFC-WTL-ATL-STL联系与区别"><a href="#MFC-WTL-ATL-STL联系与区别" class="headerlink" title="MFC,WTL,ATL,STL联系与区别"></a>MFC,WTL,ATL,STL联系与区别</h2><ul>
<li>C++是一门语言，它与平台无关。只要能提供C++编译器(或者交叉编译器)的平台，就能使用C++变成。基本上常见的操作系统都有C++编译器或者交叉编译器。</li>
<li>VC++，不是语言，而是一个工具软件。他甚至不是编译器，而是一个开发环境(VC++的编译器实际上只是一个可执行文件cl.exe)，用这个环境能帮你用C++快速的开发出各种win32的程序。</li>
<li>C++具有语言标准，这个标准由ISO批准的。所谓标准就是任何C++编译器都应该遵守的，包括cl.exe。所以，学好标准的C++就能再任何平台上开发。但是各个编译器除了支持标准外，还在不与标准冲突的范围内进行了语法扩充，当然是为了能够更高效方便的开发程序。</li>
<li>只有语言能做的事情非常少，在操作系统上跑需要各种现有的程序的支持，这些支持通常以库的形式表现出来。例如C标准库，C++标准库。这两个是标准的。非标准的就像所说的MFC之类的。</li>
<li>下面比较这几个库</li>
</ul>
<h3 id="STL-标准模板库"><a href="#STL-标准模板库" class="headerlink" title="STL(标准模板库)"></a>STL(标准模板库)</h3><ul>
<li>STL的代码从广义上讲分为三类：algorithm(算法)，container(容器)和iterator(迭代器)</li>
</ul>
<h3 id="ATL-活动模板库"><a href="#ATL-活动模板库" class="headerlink" title="ATL(活动模板库)"></a>ATL(活动模板库)</h3><ul>
<li>ATL，ActiveX Template Library. 是一个产生C++&#x2F;COM代码的框架，就如同C语言是产生一个汇编代码的框架。ATL又不同于MFC，它完全面向COM组件，其技术路线也不同于MFC。</li>
<li>MFC使用的是C++中的继承，封装，嵌套等常规技术，而ATL使用了C++中模板，多继承等高级技术，甚至还用到了STL</li>
<li>COM component(COM组件)，是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发技术。在COM构架下，人们可以开发出各种各样的功能专一的组件，然后将他们按照需要组合起来，以便随时进行系统的升级和定制；可以在多个应用系统中重复利用同一个组件；可以方便的将应用系统扩展到网络环境下</li>
</ul>
<h3 id="WTL-Windows-Template-Library"><a href="#WTL-Windows-Template-Library" class="headerlink" title="WTL(Windows Template Library)"></a>WTL(Windows Template Library)</h3><ul>
<li>WTL，构架于ATL之上，采用C++模板技术来包装大部分窗口控制，并给出一个与MFC相似的应用框架。</li>
</ul>
<h3 id="MFC"><a href="#MFC" class="headerlink" title="MFC"></a>MFC</h3><ul>
<li>MFC，Microsoft Foundation Classes. 实际上是微软提供的，用于在C++环境下编写应用程序的一个框架和引擎。</li>
<li>VC++是Windows下开发人员使用的专业C++ SDK(SDK, Standard SoftWare Develop Kit,专业软件开发平台)，MFC就是挂在它之上的一个辅助软件开发包。</li>
<li><strong>注意C++与VC++的区别</strong>：<ul>
<li>C++是一种程序设计语言，是一种大家都承认的软件编制的通用规范</li>
<li>VC++只是一个编译器，或者说是一中编译器＋源程序编辑器的IDE</li>
</ul>
</li>
<li>MFC是Win API与C++的结合。API，即微软提供的Windows下应用程序的编程接口，是一种软件编程的规范，但不是一种程序开发语言本身，可以允许用户使用各种各样的第三方的编程语言对Windows下应用程序的开发，是这些被开发出来的应用程序能在Windows下运行，比如VB，VC++，Java，Delphi。</li>
<li>编程语言函数本质上全部源于API，因此用他们开发出来的应用程序都能工作在Windows的消息机制和绘图里，遵循Windows作为一个操作系统的内部实现，这其实也是一种必要。微软如果不提供API，这个世界上对Windows编程的工作就不会存在，微软的产品就会迅速从时尚变为垃圾。</li>
<li>上面说到MFC是微软对API函数的专用C++封装，这种结合一方面让用户使用微软的专业C++ SDK来进行Windows下应用程序的开发变得很容易，因为MFC是对API的封装，微软做了大量的工作，隐藏了好多程序开发人员在Windows下用C++ &amp; MFC编制软件时的大量细节，例如应用程序实现消息的处理，设备环境绘图，这种结合是以方便为目的的，必定要付出一定代价，因此就造成了MFC对类封装中的一定程度的冗余。</li>
<li>最后要明白MFC不只是一个功能单纯的界面开发系统，它提供的类绝大部分用来进行界面开发，关联一个窗口的侗族，但它提供的类中也有好多类不与一个窗口关联，即类的作用不是一个界面类，不实现一个窗口对象的控制，而是一些在Windows中实现内部处理的类，例如数据库的管理类等。学习中最应该花费时间的是消息和设备环境，对C++和MFC的学习中最难的部分是指针，C++面向对象程序设计的其他部分，例如数据类型，流程控制都不难。</li>
</ul>
<h2 id="C-类的成员变量是在堆区还是在栈区"><a href="#C-类的成员变量是在堆区还是在栈区" class="headerlink" title="C++类的成员变量是在堆区还是在栈区"></a>C++类的成员变量是在堆区还是在栈区</h2><h3 id="C-内存分配基础"><a href="#C-内存分配基础" class="headerlink" title="C++内存分配基础"></a>C++内存分配基础</h3><ul>
<li>在理解C++类的成员变量存储位置之前，我们先要了解C++中的几种主要内存区域<ul>
<li>栈区(Stack): 栈区内存由编译器自动分配和释放，存储函数的局部变量，参数等。栈区内存具有生命周期短，分配效率高的特点</li>
<li>堆区(Heap): 堆区内存由程序员手动分配和释放(使用new和delete)。堆区内存的生命周期由程序员控制，适合存储需要长时间存在的数据</li>
<li>静态存储区(Static Storage): 该区域存储静态数据成员和全局变量，内存分配在程序开始时进行，直到程序结束时才释放</li>
<li>代码区和常量区: 存储程序代码和常量数据</li>
</ul>
</li>
</ul>
<h3 id="类的成员变量存储位置"><a href="#类的成员变量存储位置" class="headerlink" title="类的成员变量存储位置"></a>类的成员变量存储位置</h3><ul>
<li>类的成员变量的存储位置取决于类的实例(对象)如何创建。主要有以下几种情况</li>
</ul>
<ol>
<li><p>栈上分配的对象</p>
<ul>
<li>当一个对象在栈上分配时，成员变量也存储在栈上</li>
</ul>
</li>
<li><p>堆上分配的对象</p>
<ul>
<li>当使用new关键字动态分配一个对象时，对象和其成员变量会存储在堆上。</li>
</ul>
</li>
<li><p>静态存储区的对象</p>
<ul>
<li>如果一个对象是全局变量或静态变量，那么它会被分配在静态存储区。</li>
<li>这些对象的内存在程序开始时分配，并且在程序运行期间一直存在，直到程序结束时才会释放。因此，静态对象和全局对象的成员变量存储在静态存储区中。</li>
</ul>
</li>
</ol>
<h2 id="C-BEGIN-DECLS-是什么"><a href="#C-BEGIN-DECLS-是什么" class="headerlink" title="C __BEGIN_DECLS 是什么"></a>C __BEGIN_DECLS 是什么</h2><p><code>__BEGIN_DECLS</code> 和 <code>__END_DECLS</code> 是在C语言和C++代码混合时使用的宏。它们用于确保 C 头文件在被 C++ 编译器编译时能够正确处理 C 函数原型。</p>
<p>当在 C++ 环境中包含 C 头文件时，需要用 <code>extern &quot;C&quot;</code> 来告诉 C++ 编译器这些声明是 C 语言的，以便正确处理名字修饰（name mangling）。<code>__BEGIN_DECLS</code> 和 <code>__END_DECLS</code> 宏正是为了简化这一过程而设计的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __BEGIN_DECLS extern <span class="string">&quot;C&quot;</span> &#123;</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __END_DECLS &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __BEGIN_DECLS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __END_DECLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这段代码的含义是：</p>
<ul>
<li>如果编译器是 C++ 编译器 (<code>__cplusplus</code> 被定义)，则 <code>__BEGIN_DECLS</code> 被定义为 <code>extern &quot;C&quot; &#123;</code>，<code>__END_DECLS</code> 被定义为 <code>&#125;</code>。</li>
<li>如果编译器是 C 编译器，则这两个宏都定义为空。</li>
</ul>
<p>使用这些宏可以这样写一个头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_HEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_HEADER_H</span></span><br><span class="line"></span><br><span class="line">__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_function</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">__END_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MY_HEADER_H</span></span></span><br></pre></td></tr></table></figure>

<p>当这个头文件在 C++ 代码中被包含时，<code>my_function</code> 的声明会被包含在 <code>extern &quot;C&quot;</code> 块中，从而避免了 C++ 名字修饰问题。在 C 代码中，宏会被定义为空，所以对代码没有影响。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/30/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-07-30-C++%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/30/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-07-30-C++%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">C++共享内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-30 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-30T09:00:00+08:00">2024-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Personal/" itemprop="url" rel="index"><span itemprop="name">Personal</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux系统下进程键通讯方式之共享内存，相关笔记</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><ul>
<li>共享内存(shared memory)指在多处理器的计算机系统中，可以被不同中央处理器访问的大容量内存。由于多个CPU需要快速访问存储器，这样就要对存储器进行缓存。由于其他处理器可能也要访问，任一缓存数据更新后，共享内存就需要立即更新，否则不同处理器可能用到不同的数据。</li>
<li>共享内存的类似方案有分布内存，分布共享内存，用以解决同类问题。</li>
<li>共享内存区是可用IPC形式中最快的。一旦这样的内存区映射到共享它的进程的地址空间，这些进程间数据的传递就不再涉及内核。然而往该共享内存区存放消息或从中取走消息的进程间通常需要某种形式的同步。我们在第三部分讨论了各种形式的同步：互斥锁，条件变量，读写锁，记录锁，信号量。</li>
<li>这里说的： 不再涉及内核的含义是: 进程不再通过执行任何进入内核的系统调用来彼此传递数据。显然，内核必须建立允许各个进程共享该内存区的内存映射关系，然后一直管理该内存区。</li>
</ul>
<h2 id="相关的方法"><a href="#相关的方法" class="headerlink" title="相关的方法"></a>相关的方法</h2><ul>
<li>&lt;sys&#x2F;mman.h&gt;头文件<ul>
<li>mmap()函数</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/23/notebook/Tools/2024-07-23-%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/23/notebook/Tools/2024-07-23-%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">视频教程笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-23 11:00:00" itemprop="dateCreated datePublished" datetime="2024-07-23T11:00:00+08:00">2024-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>录制视频教程，std::vector相关笔记</li>
</ul>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li><p>看一下笔记，按照笔记复习。</p>
</li>
<li><p>小结</p>
<ul>
<li>std::vector 动态数组，动态增长的原理 1.5(2)倍增长，增长的流程，大概说一下。</li>
<li>size() 和 capacity() 的区别，</li>
<li>push_back 和 emplace_back() 的区别</li>
<li>支持随机访问，常量时间复杂度，</li>
<li>插入，删除操作是跟数据大小有关。</li>
<li>下一个视频，复习一下 std::vector , std::list, std::deque, 主要是 std::vector 和 std::list的区别</li>
</ul>
</li>
</ul>
<h2 id="list-array-deque-vector"><a href="#list-array-deque-vector" class="headerlink" title="list, array, deque, vector"></a>list, array, deque, vector</h2><ul>
<li><p>list 相关的笔记</p>
</li>
<li><p>小结</p>
<ul>
<li>list 不能提供随机访问，也不能提供指针运算，只能通过 ++p 或 –p 来遍历list</li>
<li>充分利用插入和删除常量时间复杂度的特性，两个list的合并 merge() , 或者是一个 list 的splice()</li>
<li>array 固定大小，在栈上分配内存，vector则是访问自由存储区，相对来说，效率会更高一些，</li>
<li>缺点 swap() array是线性时间复杂度，vector是常量时间复杂度，</li>
<li>与C风格的数组比较，优点就是封装了一些常用的方法，例如size(), empty()</li>
<li>deque</li>
</ul>
</li>
<li><p>下一步</p>
<ul>
<li>关联式容器: map, set, pair,  multimap, multiset</li>
<li>无序式关联容器： unordered_map, unordered_set,</li>
<li>堆栈的一些概念，内存模型，类，虚函数表，this指针，成员函数的地址，怎么调用成员函数的。</li>
</ul>
</li>
</ul>
<h2 id="map-set"><a href="#map-set" class="headerlink" title="map, set"></a>map, set</h2><ul>
<li><p>容器，分为序列容器和关联容器</p>
<ul>
<li>序列容器: vector, array, list, deque</li>
<li>关联容器<ul>
<li>有序关联容器: map, set, multimap, multiset</li>
<li>无序关联容器: unordered_map, unordered_set, unordered_multimap, unordered_multiset</li>
</ul>
</li>
</ul>
</li>
<li><p>小结</p>
<ul>
<li>。。。</li>
</ul>
</li>
<li><p>下一步</p>
<ul>
<li>cuda， cudnn， tensorrt</li>
<li>深拷贝，<ul>
<li>memcpy,strcpy,strlen()<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>排序<ul>
<li>std::sort() lambda() </li>
<li>algorithm<ul>
<li>std::sort</li>
<li>std::merge</li>
<li>std::find_if</li>
<li>std::for_each</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>cuda<ul>
<li>NVIDIA,</li>
<li>异构</li>
</ul>
</li>
<li>C++ 内存模型，堆栈一些概念</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/20/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-07-20-C++STL%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/20/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-07-20-C++STL%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">C++ STL教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-20 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-20T09:00:00+08:00">2024-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>C++ 标准模板库(Standard Template Library, STL)是一套功能强大的C++模板类和函数的集合，它提供了一系列通用的，可复用的算法和数据结构。</p>
</li>
<li><p>STL的设计基于泛型编程，这意味着使用模板可以编写出独立于任何特定数据类型的代码。</p>
</li>
<li><p>STL分为多个组件，包括容器(Containers)，迭代器(Iterators)，算法(Algorithms)，函数对象(Function Objects)和适配器(Adapters)等</p>
</li>
<li><p>使用STL的好处</p>
<ul>
<li>代码复用: STL提供了大量通用数据和算法，可以减少重复编写代码的工作</li>
<li>性能优化: STL中的算法和数据结构都经过了优化，以提供最佳的性能</li>
<li>泛型编程: 使用模板，STL支持泛型编程，使得算法和数据结构可以适用于任何数据类型</li>
<li>易于维护: STL的设计使得代码更加模板化，易于阅读和维护</li>
</ul>
</li>
<li><p>C++标准模板库的核心包括以下重要组件</p>
<ul>
<li>容器(Containers): 容器是STL中最基本的组件之一，提供了各种数据结构，包括向量(vector)，链表(list)，队列(queue)，栈(stack)，集合(set)，映射(map)等。这些容器具有不同的特性和用途，可以根据实际需求选择合适的容器</li>
<li>算法(Algorithms): STL提供了大量的算法，用于对容器中的元素进行各种操作，包括排序，搜索，复制，移动，变换等。这些算法在使用时不需要关心容器的具体类型，只需要指定要操作的范围即可。</li>
<li>迭代器(iterators): 迭代器用于遍历容器中的元素，允许以统一的方式访问容器中的元素，而不用关心容器的内部实现细节。STL提供了多种类型的迭代器，包括随机访问迭代器，双向迭代器，前向迭代器和输入输出迭代器等</li>
<li>函数对象(Function Objects): 函数对象是可以像函数一样调用的对象，可以用于算法中的各种操作。STL提供了多种函数对象，包括一元函数对象 ，二元函数对象，谓词等，可以满足不同的需求</li>
<li>适配器(Adapters): 适配器用于将一种容器或迭代器适配成另一种容器或迭代器，以满足特定的需求。STL提供了多种适配器，包括栈适配器(stack adapter)，队列适配器(queue adapter)和优先队列适配器(priority queue adapter)等。</li>
</ul>
</li>
<li><p>Containers are used to store the data</p>
</li>
<li><p>Algorithms are used to process the data</p>
</li>
<li><p>Functors are used to write custom algorithms</p>
</li>
<li><p>Iterators are used to navigate through the data</p>
</li>
<li><p>All of them are part of STL</p>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/07/20/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-07-20-C++STL%E6%95%99%E7%A8%8B/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/18/notebook/OpenCV/opencv_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-07-18_VideoWriter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/18/notebook/OpenCV/opencv_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-07-18_VideoWriter/" class="post-title-link" itemprop="url">VideoWrite</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-18T09:00:00+08:00">2024-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenCV/" itemprop="url" rel="index"><span itemprop="name">OpenCV</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cv::VideoWrite类相关笔记</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/07/18/notebook/OpenCV/opencv_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-07-18_VideoWriter/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/17/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-07-17-linux_2_97_strace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/17/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-07-17-linux_2_97_strace/" class="post-title-link" itemprop="url">linux_2_96_strace</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-17 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-17T09:00:00+08:00">2024-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>strace命令相关笔记</li>
</ul>
<h2 id="linux-strace命令是什么"><a href="#linux-strace命令是什么" class="headerlink" title="linux strace命令是什么"></a>linux strace命令是什么</h2><p><code>strace</code> 是 Linux 下的一个用于诊断和调试程序的命令，它可以跟踪系统调用和接收的信号。<code>strace</code> 工具允许你查看一个进程执行期间所有的系统调用和它们的返回值，这对理解程序的行为和调试问题非常有帮助。</p>
<p>以下是 <code>strace</code> 的一些常见用法：</p>
<ol>
<li><p><strong>跟踪一个程序的系统调用</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -o output.txt program_name</span><br></pre></td></tr></table></figure>
<p>这会启动 <code>program_name</code> 并将所有的系统调用记录到 <code>output.txt</code> 文件中。</p>
</li>
<li><p><strong>跟踪一个已经在运行的进程</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p pid</span><br></pre></td></tr></table></figure>
<p>其中 <code>pid</code> 是进程的 ID。这会附加到已经运行的进程并开始跟踪它的系统调用。</p>
</li>
<li><p><strong>只跟踪特定类型的系统调用</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=open,<span class="built_in">read</span>,write program_name</span><br></pre></td></tr></table></figure>
<p>这将只跟踪 <code>open</code>、<code>read</code> 和 <code>write</code> 系统调用。</p>
</li>
<li><p><strong>打印每个系统调用所花费的时间</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -T program_name</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>跟踪系统调用和信号</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -c program_name</span><br></pre></td></tr></table></figure>
<p>这会总结系统调用的次数、出错次数和执行时间。</p>
</li>
</ol>
<p>示例：使用 <code>strace</code> 跟踪 <code>ls</code> 命令的系统调用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>这个命令会在终端中打印出 <code>ls</code> 命令执行期间所有的系统调用和它们的返回值。</p>
<p><code>strace</code> 是一个非常强大的工具，特别是在调试程序、分析系统性能和排查系统问题时非常有用。</p>
<h2 id="linux-strace命令-详解"><a href="#linux-strace命令-详解" class="headerlink" title="linux strace命令 详解"></a>linux strace命令 详解</h2><p><code>strace</code> 是一个强大的 Linux 工具，用于诊断和调试程序。它能够跟踪系统调用（syscalls）和信号（signals），从而帮助用户了解程序的行为、查找问题根源、调试错误等。以下是 <code>strace</code> 的详细使用说明和示例。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="跟踪一个程序的系统调用"><a href="#跟踪一个程序的系统调用" class="headerlink" title="跟踪一个程序的系统调用"></a>跟踪一个程序的系统调用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace program_name</span><br></pre></td></tr></table></figure>

<p>这会启动 <code>program_name</code> 并在终端上显示其所有系统调用。</p>
<h4 id="将输出重定向到文件"><a href="#将输出重定向到文件" class="headerlink" title="将输出重定向到文件"></a>将输出重定向到文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -o output.txt program_name</span><br></pre></td></tr></table></figure>

<p>将系统调用输出记录到 <code>output.txt</code> 文件中。</p>
<h4 id="跟踪已经运行的进程"><a href="#跟踪已经运行的进程" class="headerlink" title="跟踪已经运行的进程"></a>跟踪已经运行的进程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p pid</span><br></pre></td></tr></table></figure>

<p>其中 <code>pid</code> 是进程的 ID。这会附加到已经运行的进程并开始跟踪它的系统调用。</p>
<h3 id="过滤系统调用"><a href="#过滤系统调用" class="headerlink" title="过滤系统调用"></a>过滤系统调用</h3><h4 id="只跟踪特定类型的系统调用"><a href="#只跟踪特定类型的系统调用" class="headerlink" title="只跟踪特定类型的系统调用"></a>只跟踪特定类型的系统调用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=open,<span class="built_in">read</span>,write program_name</span><br></pre></td></tr></table></figure>

<p>这将只跟踪 <code>open</code>、<code>read</code> 和 <code>write</code> 系统调用。</p>
<h4 id="跟踪所有文件相关的系统调用"><a href="#跟踪所有文件相关的系统调用" class="headerlink" title="跟踪所有文件相关的系统调用"></a>跟踪所有文件相关的系统调用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=file program_name</span><br></pre></td></tr></table></figure>

<p>这会跟踪所有与文件操作相关的系统调用，例如 <code>open</code>、<code>read</code>、<code>write</code> 等。</p>
<h4 id="跟踪所有网络相关的系统调用"><a href="#跟踪所有网络相关的系统调用" class="headerlink" title="跟踪所有网络相关的系统调用"></a>跟踪所有网络相关的系统调用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=network program_name</span><br></pre></td></tr></table></figure>

<p>这会跟踪所有与网络操作相关的系统调用，例如 <code>socket</code>、<code>connect</code>、<code>send</code>、<code>recv</code> 等。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><h4 id="打印每个系统调用所花费的时间"><a href="#打印每个系统调用所花费的时间" class="headerlink" title="打印每个系统调用所花费的时间"></a>打印每个系统调用所花费的时间</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -T program_name</span><br></pre></td></tr></table></figure>

<p>在输出中包含每个系统调用所花费的时间。</p>
<h4 id="打印时间戳"><a href="#打印时间戳" class="headerlink" title="打印时间戳"></a>打印时间戳</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -t program_name</span><br></pre></td></tr></table></figure>

<p>在每个系统调用前面加上时间戳。</p>
<h4 id="显示相对时间戳"><a href="#显示相对时间戳" class="headerlink" title="显示相对时间戳"></a>显示相对时间戳</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -r program_name</span><br></pre></td></tr></table></figure>

<p>在每个系统调用前面显示相对于前一个系统调用的时间间隔。</p>
<h3 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h3><h4 id="汇总系统调用的次数、出错次数和执行时间"><a href="#汇总系统调用的次数、出错次数和执行时间" class="headerlink" title="汇总系统调用的次数、出错次数和执行时间"></a>汇总系统调用的次数、出错次数和执行时间</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -c program_name</span><br></pre></td></tr></table></figure>

<p>程序执行完毕后，输出汇总统计信息。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="跟踪-ls-命令的系统调用"><a href="#跟踪-ls-命令的系统调用" class="headerlink" title="跟踪 ls 命令的系统调用"></a>跟踪 <code>ls</code> 命令的系统调用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/bin/ls&quot;, [&quot;ls&quot;], 0x7ffccf5a8c38 /* 20 vars */) = 0</span><br><span class="line">brk(NULL)                               = 0x56325f1ff000</span><br><span class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fbb6141f000</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="跟踪一个已经运行的进程"><a href="#跟踪一个已经运行的进程" class="headerlink" title="跟踪一个已经运行的进程"></a>跟踪一个已经运行的进程</h4><p>假设进程 ID 为 1234：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p 1234</span><br></pre></td></tr></table></figure>

<h4 id="只跟踪-open-和-read-系统调用"><a href="#只跟踪-open-和-read-系统调用" class="headerlink" title="只跟踪 open 和 read 系统调用"></a>只跟踪 <code>open</code> 和 <code>read</code> 系统调用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=open,<span class="built_in">read</span> <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<h3 id="常见系统调用解释"><a href="#常见系统调用解释" class="headerlink" title="常见系统调用解释"></a>常见系统调用解释</h3><ul>
<li><code>execve</code>: 执行程序。</li>
<li><code>open</code>: 打开文件。</li>
<li><code>read</code>: 读取文件。</li>
<li><code>write</code>: 写入文件。</li>
<li><code>close</code>: 关闭文件描述符。</li>
<li><code>brk</code>: 调整数据段末尾位置，用于内存分配。</li>
<li><code>mmap</code>: 内存映射，用于文件或设备的内存访问。</li>
</ul>
<p><code>strace</code> 是一个非常强大的工具，特别是在调试程序、分析系统性能和排查系统问题时非常有用。它的输出可以帮助开发者理解程序的行为，找出问题的根源并进行优化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/16/notebook/Tools/2024-07-16-Zabbix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/16/notebook/Tools/2024-07-16-Zabbix/" class="post-title-link" itemprop="url">Zabbix</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-16 11:00:00" itemprop="dateCreated datePublished" datetime="2024-07-16T11:00:00+08:00">2024-07-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>zabbix工具相关笔记</li>
</ul>
<h2 id="Zabbix是什么"><a href="#Zabbix是什么" class="headerlink" title="Zabbix是什么"></a>Zabbix是什么</h2><p>Zabbix 是一个开源的企业级监控解决方案，旨在监控和跟踪 IT 基础设施的健康和性能。它提供了多种功能来帮助管理员监控网络、服务器、应用程序、云服务等。以下是 Zabbix 的一些主要特点：</p>
<ol>
<li><p><strong>全面的监控</strong>：Zabbix 能够监控各种类型的网络设备、服务器、虚拟机、云服务和应用程序。它支持多种协议，如 SNMP、IPMI、JMX、HTTP、SSH、Telnet 等。</p>
</li>
<li><p><strong>数据收集和分析</strong>：Zabbix 可以收集大量的性能和可用性数据，并对这些数据进行存储和分析。它提供了强大的数据可视化工具，如图表、仪表盘和报告。</p>
</li>
<li><p><strong>告警和通知</strong>：Zabbix 支持复杂的告警机制，可以根据预定义的条件触发告警，并通过多种渠道（如邮件、短信、Slack、Telegram 等）发送通知。</p>
</li>
<li><p><strong>自动化和自愈</strong>：Zabbix 提供了自动化功能，可以在检测到问题时自动执行预定义的操作，如重启服务或执行脚本，以实现自愈。</p>
</li>
<li><p><strong>高扩展性</strong>：Zabbix 设计为高扩展性，可以支持从小型环境到大型企业环境的监控需求。它支持分布式监控和代理模式，能够轻松扩展。</p>
</li>
<li><p><strong>开源和社区支持</strong>：Zabbix 是开源软件，拥有活跃的社区和广泛的用户基础。社区提供了大量的插件、模板和文档，帮助用户快速上手和扩展功能。</p>
</li>
</ol>
<p>Zabbix 的灵活性和强大的功能使其成为许多企业和组织选择的监控解决方案。无论是用于监控网络设备、服务器性能，还是应用程序健康，Zabbix 都能提供可靠的支持。</p>
<h2 id="zabbix-详解"><a href="#zabbix-详解" class="headerlink" title="zabbix 详解"></a>zabbix 详解</h2><h3 id="什么是-Zabbix？"><a href="#什么是-Zabbix？" class="headerlink" title="什么是 Zabbix？"></a>什么是 Zabbix？</h3><p>Zabbix 是一个开源的监控软件工具，旨在监控和跟踪 IT 基础设施、网络、服务器、虚拟机、应用程序和云服务的健康状况和性能。它提供了一整套功能，从数据收集、存储、分析到告警和自动化操作。由于其高扩展性和灵活性，Zabbix 可以满足从小型组织到大型企业的不同需求。</p>
<h3 id="主要功能和特点"><a href="#主要功能和特点" class="headerlink" title="主要功能和特点"></a>主要功能和特点</h3><h4 id="1-数据收集和监控"><a href="#1-数据收集和监控" class="headerlink" title="1. 数据收集和监控"></a>1. <strong>数据收集和监控</strong></h4><ul>
<li><strong>广泛的支持</strong>：支持多种协议和技术，如 SNMP、IPMI、JMX、HTTP、SSH、Telnet 等，可以监控各种设备和应用程序。</li>
<li><strong>主动监控</strong>：通过代理（Agent）和代理代理（Proxy）模式，支持分布式监控，能够在网络的不同部分进行监控。</li>
<li><strong>被动监控</strong>：支持从设备和应用程序中获取数据，适用于需要从设备中获取状态和性能信息的场景。</li>
</ul>
<h4 id="2-数据存储和处理"><a href="#2-数据存储和处理" class="headerlink" title="2. 数据存储和处理"></a>2. <strong>数据存储和处理</strong></h4><ul>
<li><strong>历史数据存储</strong>：Zabbix 可以存储大量的历史数据，支持长期的数据保留和分析。</li>
<li><strong>灵活的数据处理</strong>：通过自定义的触发器和阈值，能够对监控数据进行实时处理和分析。</li>
</ul>
<h4 id="3-告警和通知"><a href="#3-告警和通知" class="headerlink" title="3. 告警和通知"></a>3. <strong>告警和通知</strong></h4><ul>
<li><strong>复杂的告警机制</strong>：支持根据预定义的条件和阈值触发告警，告警可以基于多个条件进行组合和过滤。</li>
<li><strong>多渠道通知</strong>：支持通过邮件、短信、IM（如 Slack、Telegram 等）和脚本发送通知，确保管理员能够及时收到告警信息。</li>
<li><strong>告警升级</strong>：支持告警的升级和降级，确保重要问题能够及时得到关注和处理。</li>
</ul>
<h4 id="4-数据可视化"><a href="#4-数据可视化" class="headerlink" title="4. 数据可视化"></a>4. <strong>数据可视化</strong></h4><ul>
<li><strong>图表和仪表盘</strong>：提供强大的图表和仪表盘功能，能够直观地展示监控数据和趋势。</li>
<li><strong>报告和分析</strong>：支持生成各种报告，帮助管理员了解系统的健康状况和性能。</li>
</ul>
<h4 id="5-自动化和自愈"><a href="#5-自动化和自愈" class="headerlink" title="5. 自动化和自愈"></a>5. <strong>自动化和自愈</strong></h4><ul>
<li><strong>自动操作</strong>：支持在检测到问题时自动执行预定义的操作，如重启服务、执行脚本等。</li>
<li><strong>自愈功能</strong>：通过自动化操作实现系统的自愈，减少人为干预，提高系统的可靠性。</li>
</ul>
<h4 id="6-高扩展性"><a href="#6-高扩展性" class="headerlink" title="6. 高扩展性"></a>6. <strong>高扩展性</strong></h4><ul>
<li><strong>分布式监控</strong>：支持代理和代理代理模式，能够扩展到大规模的分布式环境中进行监控。</li>
<li><strong>高可用性</strong>：通过集群和冗余设计，确保监控系统的高可用性和可靠性。</li>
</ul>
<h4 id="7-开源和社区支持"><a href="#7-开源和社区支持" class="headerlink" title="7. 开源和社区支持"></a>7. <strong>开源和社区支持</strong></h4><ul>
<li><strong>开源许可</strong>：Zabbix 是开源软件，拥有 GPL 许可，用户可以自由使用、修改和分发。</li>
<li><strong>活跃的社区</strong>：拥有庞大且活跃的用户和开发者社区，提供丰富的插件、模板和文档资源，用户可以从社区中获取支持和帮助。</li>
</ul>
<h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ul>
<li><strong>网络监控</strong>：监控路由器、交换机、防火墙等网络设备的性能和状态。</li>
<li><strong>服务器监控</strong>：监控物理服务器和虚拟机的 CPU、内存、磁盘等资源的使用情况。</li>
<li><strong>应用程序监控</strong>：监控数据库、Web 服务器、邮件服务器等应用程序的性能和健康状况。</li>
<li><strong>云服务监控</strong>：监控 AWS、Azure 等云服务的资源使用情况和性能。</li>
</ul>
<h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><h4 id="1-系统要求"><a href="#1-系统要求" class="headerlink" title="1. 系统要求"></a>1. <strong>系统要求</strong></h4><ul>
<li><strong>操作系统</strong>：支持多种操作系统，如 Linux、Windows 等。</li>
<li><strong>数据库</strong>：需要一个数据库来存储监控数据，支持 MySQL、PostgreSQL、Oracle 等。</li>
<li><strong>Web 服务器</strong>：需要一个 Web 服务器来运行 Zabbix 的前端界面，支持 Apache、Nginx 等。</li>
</ul>
<h4 id="2-安装步骤"><a href="#2-安装步骤" class="headerlink" title="2. 安装步骤"></a>2. <strong>安装步骤</strong></h4><ul>
<li><strong>数据库安装和配置</strong>：安装并配置所需的数据库。</li>
<li><strong>Zabbix 服务器安装</strong>：安装 Zabbix 服务器组件。</li>
<li><strong>Zabbix 前端安装</strong>：安装并配置 Web 服务器和 Zabbix 前端。</li>
<li><strong>Zabbix 代理安装</strong>：在需要监控的设备上安装 Zabbix 代理。</li>
</ul>
<h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. <strong>配置</strong></h4><ul>
<li><strong>添加主机和模板</strong>：在 Zabbix 前端界面中添加需要监控的主机，并应用相应的监控模板。</li>
<li><strong>设置触发器和告警</strong>：配置触发器和告警规则，定义告警条件和通知方式。</li>
<li><strong>创建图表和仪表盘</strong>：根据监控需求创建图表和仪表盘，直观展示监控数据。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Zabbix 是一个功能强大且灵活的监控解决方案，适用于各种 IT 环境。从网络设备和服务器的监控，到应用程序和云服务的监控，Zabbix 都能提供可靠的支持。通过其全面的数据收集、分析、告警和自动化功能，Zabbix 帮助企业提高 IT 基础设施的可见性和可靠性，从而更好地保障业务的连续性和性能。</p>
<h2 id="zabbix-使用-示例"><a href="#zabbix-使用-示例" class="headerlink" title="zabbix 使用 示例"></a>zabbix 使用 示例</h2><p>以下是一个简单的 Zabbix 使用示例，展示如何安装、配置和使用 Zabbix 来监控一台服务器的基本性能指标。</p>
<h3 id="示例环境"><a href="#示例环境" class="headerlink" title="示例环境"></a>示例环境</h3><ul>
<li><strong>Zabbix Server</strong>：Ubuntu 20.04</li>
<li><strong>监控对象</strong>：一台运行 Ubuntu 20.04 的服务器</li>
</ul>
<h3 id="步骤-1：安装-Zabbix-Server"><a href="#步骤-1：安装-Zabbix-Server" class="headerlink" title="步骤 1：安装 Zabbix Server"></a>步骤 1：安装 Zabbix Server</h3><ol>
<li><p><strong>更新系统包</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade -y</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装 Zabbix 存储库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.zabbix.com/zabbix/6.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_6.0-2+ubuntu20.04_all.deb</span><br><span class="line"><span class="built_in">sudo</span> dpkg -i zabbix-release_6.0-2+ubuntu20.04_all.deb</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装 Zabbix Server、前端和数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install zabbix-server-mysql zabbix-frontend-php zabbix-apache-conf zabbix-agent</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装并配置 MySQL 数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install mysql-server</span><br><span class="line"><span class="built_in">sudo</span> mysql_secure_installation</span><br></pre></td></tr></table></figure>

<p>进入 MySQL 命令行，创建数据库和用户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE zabbix <span class="keyword">CHARACTER SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;zabbix&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> zabbix.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;zabbix&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>导入初始架构和数据</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置 Zabbix Server 连接到数据库</strong></p>
<p>编辑配置文件 <code>/etc/zabbix/zabbix_server.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DBPassword=password</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动 Zabbix Server 和代理</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart zabbix-server zabbix-agent apache2</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> zabbix-server zabbix-agent apache2</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="步骤-2：安装和配置-Zabbix-Agent-在被监控服务器上"><a href="#步骤-2：安装和配置-Zabbix-Agent-在被监控服务器上" class="headerlink" title="步骤 2：安装和配置 Zabbix Agent 在被监控服务器上"></a>步骤 2：安装和配置 Zabbix Agent 在被监控服务器上</h3><ol>
<li><p><strong>在被监控服务器上安装 Zabbix Agent</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.zabbix.com/zabbix/6.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_6.0-2+ubuntu20.04_all.deb</span><br><span class="line"><span class="built_in">sudo</span> dpkg -i zabbix-release_6.0-2+ubuntu20.04_all.deb</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install zabbix-agent</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置 Zabbix Agent</strong></p>
<p>编辑配置文件 <code>/etc/zabbix/zabbix_agentd.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server=&lt;Zabbix Server IP&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动 Zabbix Agent</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart zabbix-agent</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> zabbix-agent</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="步骤-3：在-Zabbix-前端配置监控"><a href="#步骤-3：在-Zabbix-前端配置监控" class="headerlink" title="步骤 3：在 Zabbix 前端配置监控"></a>步骤 3：在 Zabbix 前端配置监控</h3><ol>
<li><p><strong>访问 Zabbix 前端</strong></p>
<p>在浏览器中访问 <code>http://&lt;Zabbix Server IP&gt;/zabbix</code>，按照提示完成初始设置。</p>
</li>
<li><p><strong>登录 Zabbix 前端</strong></p>
<p>使用默认用户名 <code>Admin</code> 和密码 <code>zabbix</code> 登录。</p>
</li>
<li><p><strong>添加主机</strong></p>
<ul>
<li>导航到 <code>Configuration</code> -&gt; <code>Hosts</code> -&gt; <code>Create host</code>。</li>
<li>填写主机名、组和 IP 地址。</li>
<li>在 <code>Templates</code> 标签中，选择 <code>Template OS Linux</code> 模板。</li>
</ul>
</li>
<li><p><strong>检查监控数据</strong></p>
<ul>
<li>导航到 <code>Monitoring</code> -&gt; <code>Latest data</code>。</li>
<li>选择刚刚添加的主机，查看收集到的监控数据。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上步骤，你已经成功安装并配置了 Zabbix 服务器和代理，并添加了一台被监控的服务器。你可以通过 Zabbix 前端界面查看监控数据，设置告警规则，以及创建图表和仪表盘来直观展示数据。</p>
<p>Zabbix 提供了强大的功能和灵活性，可以监控各种类型的 IT 资源和服务。根据实际需求，你可以进一步定制 Zabbix 的配置和功能，以满足特定的监控需求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/13/notebook/Video/2024-07-13-%E6%B5%81%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/13/notebook/Video/2024-07-13-%E6%B5%81%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">流媒体基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-13 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-13T09:00:00+08:00">2024-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Video/" itemprop="url" rel="index"><span itemprop="name">Video</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>流媒体相关理论基础笔记</li>
</ul>
<h2 id="推流是什么"><a href="#推流是什么" class="headerlink" title="推流是什么"></a>推流是什么</h2><p>推流（Streaming）是指将音视频内容通过网络实时传输到远程服务器或客户端，使得用户可以在不下载完整文件的情况下进行实时播放。推流技术广泛应用于直播、视频会议、在线教育、远程监控等领域。</p>
<h3 id="推流的基本原理"><a href="#推流的基本原理" class="headerlink" title="推流的基本原理"></a>推流的基本原理</h3><ol>
<li><p><strong>采集</strong>：</p>
<ul>
<li>通过摄像头、麦克风或其他输入设备采集音视频数据。</li>
</ul>
</li>
<li><p><strong>编码</strong>：</p>
<ul>
<li>将采集到的音视频数据压缩编码，以减少数据量。常用的视频编码格式有 H.264、H.265，音频编码格式有 AAC、MP3 等。</li>
</ul>
</li>
<li><p><strong>封装</strong>：</p>
<ul>
<li>将编码后的音视频数据封装成适合传输的流媒体格式，如 FLV、HLS 等。</li>
</ul>
</li>
<li><p><strong>传输</strong>：</p>
<ul>
<li>将封装后的流媒体数据通过网络传输到流媒体服务器。常用的传输协议有 RTMP、HTTP、WebRTC 等。</li>
</ul>
</li>
<li><p><strong>分发和播放</strong>：</p>
<ul>
<li>流媒体服务器接收推流数据后，进行处理和分发。用户端可以通过播放器软件或网页实时接收并播放流媒体内容。</li>
</ul>
</li>
</ol>
<h3 id="常用的推流协议和工具"><a href="#常用的推流协议和工具" class="headerlink" title="常用的推流协议和工具"></a>常用的推流协议和工具</h3><h4 id="推流协议"><a href="#推流协议" class="headerlink" title="推流协议"></a>推流协议</h4><ol>
<li><p><strong>RTMP（Real-Time Messaging Protocol）</strong>：</p>
<ul>
<li>广泛应用于直播推流，尤其是与 Adobe Flash 配合使用。尽管 Flash 技术逐渐被淘汰，但 RTMP 仍然被很多直播平台所支持。</li>
</ul>
</li>
<li><p><strong>HLS（HTTP Live Streaming）</strong>：</p>
<ul>
<li>由苹果公司开发，广泛应用于点播和直播流媒体服务。使用 HTTP 协议进行传输，兼容性好，特别适合在不同设备和网络条件下使用。</li>
</ul>
</li>
<li><p><strong>WebRTC（Web Real-Time Communication）</strong>：</p>
<ul>
<li>支持实时音视频通信，适用于视频通话、视频会议等场景。WebRTC 具有低延迟、点对点通信等优点。</li>
</ul>
</li>
</ol>
<h4 id="推流工具"><a href="#推流工具" class="headerlink" title="推流工具"></a>推流工具</h4><ol>
<li><p><strong>OBS（Open Broadcaster Software）</strong>：</p>
<ul>
<li>免费开源的推流和录屏软件，支持多种推流协议和平台。适合游戏直播、网络直播等场景。</li>
</ul>
</li>
<li><p><strong>FFmpeg</strong>：</p>
<ul>
<li>强大的多媒体处理工具，支持音视频采集、编码、封装和推流。适合高级用户和开发者。</li>
</ul>
</li>
<li><p><strong>Wirecast</strong>：</p>
<ul>
<li>专业的直播推流软件，提供丰富的功能和插件，适用于高质量直播需求。</li>
</ul>
</li>
<li><p><strong>Streamlabs OBS</strong>：</p>
<ul>
<li>基于 OBS 开发的推流工具，集成了更多直播相关的功能和插件，适合游戏直播和网络主播。</li>
</ul>
</li>
</ol>
<h3 id="示例：使用-FFmpeg-推流"><a href="#示例：使用-FFmpeg-推流" class="headerlink" title="示例：使用 FFmpeg 推流"></a>示例：使用 FFmpeg 推流</h3><p>假设你想使用 FFmpeg 将本地视频文件推流到 RTMP 服务器，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input.mp4 -c:v libx264 -c:a aac -strict experimental -f flv rtmp://example.com/live/stream_key</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>-re</code>：按实时速率读取输入文件。</li>
<li><code>-i input.mp4</code>：指定输入文件。</li>
<li><code>-c:v libx264</code>：使用 H.264 编码器。</li>
<li><code>-c:a aac</code>：使用 AAC 音频编码器。</li>
<li><code>-strict experimental</code>：允许使用实验性 AAC 编码器。</li>
<li><code>-f flv</code>：指定输出格式为 FLV。</li>
<li><code>rtmp://example.com/live/stream_key</code>：RTMP 服务器地址和流密钥。</li>
</ul>
<h3 id="推流应用场景"><a href="#推流应用场景" class="headerlink" title="推流应用场景"></a>推流应用场景</h3><ul>
<li><strong>游戏直播</strong>：通过推流软件将游戏画面和声音实时传输到直播平台，观众可以实时观看游戏过程。</li>
<li><strong>在线教育</strong>：教师通过摄像头和麦克风实时讲解课程内容，学生可以通过网络实时观看和互动。</li>
<li><strong>视频会议</strong>：通过推流技术，多个用户可以实时进行音视频交流，适用于远程办公和在线会议。</li>
<li><strong>远程监控</strong>：通过摄像头实时推流监控画面，用户可以通过网络随时查看监控区域的情况。</li>
</ul>
<p>推流技术为各种实时音视频应用提供了基础支持，使得用户能够在不同设备和网络条件下享受到流畅的实时音视频体验。</p>
<h2 id="拉流-取流是什么"><a href="#拉流-取流是什么" class="headerlink" title="拉流&#x2F;取流是什么"></a>拉流&#x2F;取流是什么</h2><p>拉流（Pull Streaming）或取流（Fetching Stream）是指从服务器端获取实时音视频流并在客户端进行播放的过程。与推流（Push Streaming）相对应，拉流是接收端的操作，常用于观看直播、视频会议、监控等场景。</p>
<h3 id="拉流的基本原理"><a href="#拉流的基本原理" class="headerlink" title="拉流的基本原理"></a>拉流的基本原理</h3><ol>
<li><p><strong>连接服务器</strong>：</p>
<ul>
<li>客户端通过指定的协议和地址连接到流媒体服务器。</li>
</ul>
</li>
<li><p><strong>请求流</strong>：</p>
<ul>
<li>客户端向服务器发送请求，要求获取特定的流媒体内容。</li>
</ul>
</li>
<li><p><strong>接收流</strong>：</p>
<ul>
<li>服务器将实时的音视频数据发送给客户端。</li>
</ul>
</li>
<li><p><strong>解码和播放</strong>：</p>
<ul>
<li>客户端接收数据后，进行解码并播放音视频内容。</li>
</ul>
</li>
</ol>
<h3 id="常用的拉流协议和工具"><a href="#常用的拉流协议和工具" class="headerlink" title="常用的拉流协议和工具"></a>常用的拉流协议和工具</h3><h4 id="拉流协议"><a href="#拉流协议" class="headerlink" title="拉流协议"></a>拉流协议</h4><ol>
<li><p><strong>RTMP（Real-Time Messaging Protocol）</strong>：</p>
<ul>
<li>常用于直播流的传输，尤其是与 Adobe Flash 配合使用。许多直播平台仍然支持 RTMP。</li>
</ul>
</li>
<li><p><strong>HLS（HTTP Live Streaming）</strong>：</p>
<ul>
<li>由苹果公司开发，广泛应用于点播和直播流媒体服务。使用 HTTP 协议进行传输，兼容性好，特别适合在不同设备和网络条件下使用。</li>
</ul>
</li>
<li><p><strong>DASH（Dynamic Adaptive Streaming over HTTP）</strong>：</p>
<ul>
<li>一种基于 HTTP 的自适应流媒体传输协议，可以根据网络条件动态调整视频质量。</li>
</ul>
</li>
<li><p><strong>WebRTC（Web Real-Time Communication）</strong>：</p>
<ul>
<li>支持实时音视频通信，适用于视频通话、视频会议等场景。具有低延迟、点对点通信等优点。</li>
</ul>
</li>
</ol>
<h4 id="拉流工具"><a href="#拉流工具" class="headerlink" title="拉流工具"></a>拉流工具</h4><ol>
<li><p><strong>VLC Media Player</strong>：</p>
<ul>
<li>开源的多媒体播放器，支持多种流媒体协议，常用于播放 RTMP、HLS 等流媒体内容。</li>
</ul>
</li>
<li><p><strong>FFmpeg</strong>：</p>
<ul>
<li>强大的多媒体处理工具，支持音视频采集、编码、封装和拉流。适合高级用户和开发者。</li>
</ul>
</li>
<li><p><strong>OBS（Open Broadcaster Software）</strong>：</p>
<ul>
<li>虽然主要用于推流，也可以配置为接收和播放拉流内容。</li>
</ul>
</li>
<li><p><strong>Web 浏览器</strong>：</p>
<ul>
<li>现代浏览器支持 HLS、DASH 和 WebRTC，可以直接在网页中播放流媒体内容。</li>
</ul>
</li>
</ol>
<h3 id="示例：使用-FFmpeg-拉流"><a href="#示例：使用-FFmpeg-拉流" class="headerlink" title="示例：使用 FFmpeg 拉流"></a>示例：使用 FFmpeg 拉流</h3><p>假设你想使用 FFmpeg 从 RTMP 服务器拉取流媒体并保存到本地文件，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp://example.com/live/stream_key -c copy output.mp4</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>-i rtmp://example.com/live/stream_key</code>：指定输入流地址。</li>
<li><code>-c copy</code>：直接复制流媒体数据，不进行重新编码。</li>
<li><code>output.mp4</code>：指定输出文件名和格式。</li>
</ul>
<h3 id="示例：使用-VLC-拉流"><a href="#示例：使用-VLC-拉流" class="headerlink" title="示例：使用 VLC 拉流"></a>示例：使用 VLC 拉流</h3><p>假设你想使用 VLC 播放 HLS 流媒体，可以按以下步骤操作：</p>
<ol>
<li>打开 VLC Media Player。</li>
<li>选择“媒体”菜单，然后选择“打开网络串流”。</li>
<li>在网络 URL 输入框中输入 HLS 流地址，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/live/stream.m3u8</span><br></pre></td></tr></table></figure></li>
<li>点击“播放”按钮，VLC 将开始播放流媒体内容。</li>
</ol>
<h3 id="拉流应用场景"><a href="#拉流应用场景" class="headerlink" title="拉流应用场景"></a>拉流应用场景</h3><ul>
<li><strong>观看直播</strong>：用户通过拉流技术从直播服务器获取实时音视频流，观看直播节目、体育赛事、游戏直播等。</li>
<li><strong>视频会议</strong>：会议参与者通过拉流技术获取其他参与者的音视频流，实现实时交流。</li>
<li><strong>远程监控</strong>：监控系统通过拉流技术从摄像头获取实时视频流，监控人员可以随时查看监控区域的情况。</li>
<li><strong>在线教育</strong>：学生通过拉流技术观看教师的实时讲解和课程内容，进行在线学习。</li>
</ul>
<p>拉流技术是流媒体应用的重要组成部分，使用户能够在不同设备和网络条件下实时获取和播放音视频内容，为各种实时互动和直播应用提供了支持。</p>
<h2 id="流媒体服务器是什么"><a href="#流媒体服务器是什么" class="headerlink" title="流媒体服务器是什么"></a>流媒体服务器是什么</h2><p>流媒体服务器是一种专门用于传输和分发音视频内容的服务器。它可以处理实时音视频流的接收、转码、存储和分发，使得用户能够通过网络实时观看或收听音视频内容。流媒体服务器在直播、点播、视频会议和远程教育等场景中发挥着关键作用。</p>
<h3 id="流媒体服务器的主要功能"><a href="#流媒体服务器的主要功能" class="headerlink" title="流媒体服务器的主要功能"></a>流媒体服务器的主要功能</h3><ol>
<li><p><strong>接收推流</strong>：</p>
<ul>
<li>接收来自客户端或设备的实时音视频流（推流）。这些流可以来自摄像头、麦克风、编码器或其他推流设备。</li>
</ul>
</li>
<li><p><strong>转码</strong>：</p>
<ul>
<li>将音视频流转码为不同的格式或码率，以适应不同的网络条件和设备。例如，将高分辨率视频转码为多种分辨率和码率，以便用户根据自己的网络状况选择最佳的播放质量。</li>
</ul>
</li>
<li><p><strong>存储</strong>：</p>
<ul>
<li>将流媒体内容存储在服务器上，以便后续点播。存储的内容可以是完整的视频文件，也可以是分片的流媒体文件（如 HLS 的 TS 分片）。</li>
</ul>
</li>
<li><p><strong>分发拉流</strong>：</p>
<ul>
<li>将流媒体内容分发给客户端（拉流）。客户端可以是播放器、浏览器、移动应用等。</li>
</ul>
</li>
<li><p><strong>负载均衡</strong>：</p>
<ul>
<li>管理多个流媒体服务器，以处理大量的并发请求，确保系统的稳定性和高可用性。</li>
</ul>
</li>
<li><p><strong>安全性</strong>：</p>
<ul>
<li>提供访问控制、加密和认证等安全措施，确保流媒体内容的安全传输和访问。</li>
</ul>
</li>
</ol>
<h3 id="常见的流媒体服务器软件"><a href="#常见的流媒体服务器软件" class="headerlink" title="常见的流媒体服务器软件"></a>常见的流媒体服务器软件</h3><ol>
<li><p><strong>Nginx + RTMP 模块</strong>：</p>
<ul>
<li>Nginx 是一个高性能的 HTTP 服务器和反向代理服务器，通过 RTMP 模块扩展，可以实现 RTMP 推流和拉流功能。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/arut/nginx-rtmp-module">Nginx RTMP Module</a></li>
</ul>
</li>
<li><p><strong>Wowza Streaming Engine</strong>：</p>
<ul>
<li>商用的流媒体服务器，支持多种流媒体协议和功能，适用于企业级应用。</li>
<li><a target="_blank" rel="noopener" href="https://www.wowza.com/">Wowza</a></li>
</ul>
</li>
<li><p><strong>Red5</strong>：</p>
<ul>
<li>开源的流媒体服务器，支持 RTMP 和 WebRTC 等协议，适用于实时音视频通信。</li>
<li><a target="_blank" rel="noopener" href="https://red5pro.com/">Red5</a></li>
</ul>
</li>
<li><p><strong>Flussonic</strong>：</p>
<ul>
<li>商用的流媒体服务器，支持多种协议和高级功能，如转码、存储和分发。</li>
<li><a target="_blank" rel="noopener" href="https://flussonic.com/">Flussonic</a></li>
</ul>
</li>
<li><p><strong>Kurento</strong>：</p>
<ul>
<li>开源的 WebRTC 流媒体服务器，适用于视频会议和实时通信应用。</li>
<li><a target="_blank" rel="noopener" href="https://www.kurento.org/">Kurento</a></li>
</ul>
</li>
<li><p><strong>Adobe Media Server</strong>：</p>
<ul>
<li>商用的流媒体服务器，支持 RTMP 和 HLS 等协议，适用于专业的流媒体应用。</li>
<li><a target="_blank" rel="noopener" href="https://www.adobe.com/products/adobe-media-server-family.html">Adobe Media Server</a></li>
</ul>
</li>
</ol>
<h3 id="示例：使用-Nginx-RTMP-模块搭建流媒体服务器"><a href="#示例：使用-Nginx-RTMP-模块搭建流媒体服务器" class="headerlink" title="示例：使用 Nginx + RTMP 模块搭建流媒体服务器"></a>示例：使用 Nginx + RTMP 模块搭建流媒体服务器</h3><ol>
<li><p><strong>安装 Nginx 和 RTMP 模块</strong>：</p>
<ul>
<li>在 Ubuntu 系统上，首先安装必要的依赖：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install build-essential libpcre3 libpcre3-dev libssl-dev</span><br></pre></td></tr></table></figure></li>
<li>下载并编译 Nginx 和 RTMP 模块：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.19.6.tar.gz</span><br><span class="line">wget https://github.com/arut/nginx-rtmp-module/archive/master.zip</span><br><span class="line">tar -zxvf nginx-1.19.6.tar.gz</span><br><span class="line">unzip master.zip</span><br><span class="line"><span class="built_in">cd</span> nginx-1.19.6</span><br><span class="line">./configure --add-module=../nginx-rtmp-module-master --with-http_ssl_module</span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>配置 Nginx</strong>：</p>
<ul>
<li>编辑 Nginx 配置文件（通常位于 <code>/usr/local/nginx/conf/nginx.conf</code>）：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>;</span><br><span class="line">        <span class="attribute">chunk_size</span> <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">application</span> live &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">record</span> <span class="literal">off</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>启动 Nginx</strong>：</p>
<ul>
<li>启动 Nginx 流媒体服务器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>推流和拉流</strong>：</p>
<ul>
<li>使用推流工具（如 OBS 或 FFmpeg）将流媒体推送到服务器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input.mp4 -c:v libx264 -c:a aac -strict experimental -f flv rtmp://your_server_ip/live/stream_key</span><br></pre></td></tr></table></figure></li>
<li>使用拉流工具（如 VLC）从服务器获取流媒体：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp://your_server_ip/live/stream_key</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>流媒体服务器在现代网络音视频应用中起到了至关重要的作用，通过合理的部署和配置，可以实现高效、稳定和安全的实时音视频传输。</p>
<h2 id="linux-循环推流-详解"><a href="#linux-循环推流-详解" class="headerlink" title="linux 循环推流 详解"></a>linux 循环推流 详解</h2><p>在 Linux 上进行循环推流意味着将一个视频文件不断地推送到流媒体服务器，以便进行持续播放。这通常用于 24&#x2F;7 直播、广告循环播放等场景。使用 <code>FFmpeg</code> 是实现这一功能的常见方法，因为它非常灵活且支持多种音视频处理任务。</p>
<h3 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h3><h4 id="安装-FFmpeg"><a href="#安装-FFmpeg" class="headerlink" title="安装 FFmpeg"></a>安装 FFmpeg</h4><p>如果尚未安装 FFmpeg，请先进行安装：</p>
<p>对于 Debian&#x2F;Ubuntu 系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install ffmpeg</span><br></pre></td></tr></table></figure>

<p>对于 CentOS&#x2F;RHEL 系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install epel-release</span><br><span class="line"><span class="built_in">sudo</span> yum install ffmpeg</span><br></pre></td></tr></table></figure>

<h4 id="编写循环推流脚本"><a href="#编写循环推流脚本" class="headerlink" title="编写循环推流脚本"></a>编写循环推流脚本</h4><p>以下是一个简单的 Bash 脚本示例，用于实现视频文件的循环推流：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推流地址</span></span><br><span class="line">RTMP_URL=<span class="string">&quot;rtmp://example.com/live/stream_key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频文件路径</span></span><br><span class="line">VIDEO_FILE=<span class="string">&quot;input.mp4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环推流</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    ffmpeg -re -stream_loop -1 -i <span class="string">&quot;<span class="variable">$VIDEO_FILE</span>&quot;</span> -c:v libx264 -c:a aac -f flv <span class="string">&quot;<span class="variable">$RTMP_URL</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;推流失败，等待 5 秒后重试...&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 5</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>RTMP_URL</code>：指定 RTMP 服务器的推流地址。</li>
<li><code>VIDEO_FILE</code>：指定要推流的视频文件。</li>
<li><code>while true; do ... done</code>：无限循环执行推流命令。</li>
<li><code>ffmpeg -re -stream_loop -1 -i &quot;$VIDEO_FILE&quot; -c:v libx264 -c:a aac -f flv &quot;$RTMP_URL&quot;</code>：<ul>
<li><code>-re</code>：按实时速率读取输入文件。</li>
<li><code>-stream_loop -1</code>：无限循环输入文件。</li>
<li><code>-i &quot;$VIDEO_FILE&quot;</code>：指定输入文件。</li>
<li><code>-c:v libx264</code>：使用 H.264 视频编码器。</li>
<li><code>-c:a aac</code>：使用 AAC 音频编码器。</li>
<li><code>-f flv &quot;$RTMP_URL&quot;</code>：指定输出格式为 FLV，并推送到 RTMP 服务器。</li>
</ul>
</li>
<li><code>if [ $? -ne 0 ]; then ...</code>：如果 FFmpeg 命令失败，等待 5 秒后重试。</li>
</ul>
<h4 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h4><p>保存上述脚本为 <code>loop_stream.sh</code>，然后赋予其执行权限并运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x loop_stream.sh</span><br><span class="line">./loop_stream.sh</span><br></pre></td></tr></table></figure>

<h4 id="处理特殊情况"><a href="#处理特殊情况" class="headerlink" title="处理特殊情况"></a>处理特殊情况</h4><p>有时你可能需要在每次循环结束后对推流进行一些清理工作，或者在推流过程中处理网络中断等情况。可以通过捕捉信号或检查推流状态来实现更复杂的逻辑。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">RTMP_URL=<span class="string">&quot;rtmp://example.com/live/stream_key&quot;</span></span><br><span class="line">VIDEO_FILE=<span class="string">&quot;input.mp4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕捉退出信号以进行清理</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&#x27;echo &quot;脚本终止&quot;; exit 0&#x27;</span> SIGINT SIGTERM</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    ffmpeg -re -stream_loop -1 -i <span class="string">&quot;<span class="variable">$VIDEO_FILE</span>&quot;</span> -c:v libx264 -c:a aac -f flv <span class="string">&quot;<span class="variable">$RTMP_URL</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;推流失败，等待 5 秒后重试...&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 5</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>此脚本在接收到中断信号（如 <code>Ctrl+C</code>）时会优雅地退出。</p>
<h3 id="其他考虑"><a href="#其他考虑" class="headerlink" title="其他考虑"></a>其他考虑</h3><ul>
<li><strong>性能优化</strong>：根据实际需求调整 FFmpeg 编码参数，以优化推流性能。</li>
<li><strong>监控和日志</strong>：可以将推流日志重定向到文件，并使用监控工具（如 <code>supervisord</code>、<code>systemd</code>）来确保推流脚本的运行和自动重启。</li>
<li><strong>多文件循环播放</strong>：如果需要循环播放多个视频文件，可以修改脚本以支持多文件循环。例如，使用 <code>ffmpeg</code> 的 <code>concat</code> 过滤器。</li>
</ul>
<h3 id="多文件循环播放示例"><a href="#多文件循环播放示例" class="headerlink" title="多文件循环播放示例"></a>多文件循环播放示例</h3><p>以下是一个多文件循环播放的脚本示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">RTMP_URL=<span class="string">&quot;rtmp://example.com/live/stream_key&quot;</span></span><br><span class="line">VIDEO_FILES=(<span class="string">&quot;video1.mp4&quot;</span> <span class="string">&quot;video2.mp4&quot;</span> <span class="string">&quot;video3.mp4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕捉退出信号以进行清理</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&#x27;echo &quot;脚本终止&quot;; exit 0&#x27;</span> SIGINT SIGTERM</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> VIDEO_FILE <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;VIDEO_FILES[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        ffmpeg -re -i <span class="string">&quot;<span class="variable">$VIDEO_FILE</span>&quot;</span> -c:v libx264 -c:a aac -f flv <span class="string">&quot;<span class="variable">$RTMP_URL</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;推流失败，等待 5 秒后重试...&quot;</span></span><br><span class="line">            <span class="built_in">sleep</span> 5</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>此脚本会按顺序循环播放 <code>VIDEO_FILES</code> 列表中的每个视频文件，并在所有文件播放完毕后重新开始。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/12/notebook/Tools/2024-07-12-live555/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/12/notebook/Tools/2024-07-12-live555/" class="post-title-link" itemprop="url">live555</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-12 14:00:00" itemprop="dateCreated datePublished" datetime="2024-07-12T14:00:00+08:00">2024-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>live555开源工具的相关笔记</li>
</ul>
<h2 id="live555是什么"><a href="#live555是什么" class="headerlink" title="live555是什么"></a>live555是什么</h2><p>LIVE555 是一个开源的多媒体流媒体库，主要用于实现 RTP&#x2F;RTCP、RTSP 和 SIP 协议。它提供了一系列的 C++ 类，用于创建多媒体流媒体应用程序，例如流媒体服务器和客户端。LIVE555 可以用于流式传输各种多媒体格式，包括 H.264 视频、AAC 音频等。</p>
<p>LIVE555 的主要特点包括：</p>
<ol>
<li><strong>跨平台支持</strong>：支持多种操作系统，包括 Windows、macOS、Linux 等。</li>
<li><strong>高效性</strong>：使用 C++ 编写，具有高效的性能。</li>
<li><strong>灵活性</strong>：提供了丰富的 API，开发者可以根据需要进行定制。</li>
<li><strong>支持多种协议</strong>：支持 RTP&#x2F;RTCP、RTSP 和 SIP 协议，使其可以与许多不同类型的流媒体应用程序兼容。</li>
<li><strong>开源</strong>：LIVE555 是开源软件，可以免费使用和修改。</li>
</ol>
<p>通常，LIVE555 被用作开发实时流媒体应用程序的基础组件，例如视频监控系统、实时视频会议系统等。</p>
<h2 id="live555-详解"><a href="#live555-详解" class="headerlink" title="live555 详解"></a>live555 详解</h2><p>LIVE555 是一个开源的多媒体流媒体库，广泛应用于实时流媒体传输和接收。它由 Ross Finlayson 维护，主要用来处理 RTP&#x2F;RTCP、RTSP 和 SIP 协议，并支持多种多媒体格式的流式传输。以下是 LIVE555 的详细介绍：</p>
<h3 id="1-主要组件"><a href="#1-主要组件" class="headerlink" title="1. 主要组件"></a>1. 主要组件</h3><h4 id="a-BasicUsageEnvironment"><a href="#a-BasicUsageEnvironment" class="headerlink" title="a. BasicUsageEnvironment"></a>a. BasicUsageEnvironment</h4><p>这是 LIVE555 提供的基础环境，处理事件循环和日志记录。它为应用程序提供了一个使用基础 API 的上下文。</p>
<h4 id="b-Groupsock"><a href="#b-Groupsock" class="headerlink" title="b. Groupsock"></a>b. Groupsock</h4><p>该模块处理网络套接字的组播和单播通信，封装了 IP 地址和端口的处理逻辑。</p>
<h4 id="c-RTSPClient"><a href="#c-RTSPClient" class="headerlink" title="c. RTSPClient"></a>c. RTSPClient</h4><p>该模块用于实现 RTSP 客户端功能，能够发送 RTSP 请求（如 DESCRIBE、SETUP、PLAY、PAUSE 和 TEARDOWN）并处理 RTSP 响应。</p>
<h4 id="d-RTSPServer"><a href="#d-RTSPServer" class="headerlink" title="d. RTSPServer"></a>d. RTSPServer</h4><p>该模块用于实现 RTSP 服务器功能，能够接收和处理来自客户端的 RTSP 请求，并管理媒体流会话。</p>
<h4 id="e-MediaSession"><a href="#e-MediaSession" class="headerlink" title="e. MediaSession"></a>e. MediaSession</h4><p>该模块表示一个媒体会话，包含一个或多个媒体子会话（MediaSubsession），每个子会话表示一个媒体流（例如视频流或音频流）。</p>
<h4 id="f-MediaSink"><a href="#f-MediaSink" class="headerlink" title="f. MediaSink"></a>f. MediaSink</h4><p>该模块处理媒体数据的接收和处理，通常用于播放或保存媒体流。</p>
<h4 id="g-MediaSource"><a href="#g-MediaSource" class="headerlink" title="g. MediaSource"></a>g. MediaSource</h4><p>该模块用于生成媒体数据，可以从文件、设备或其他来源读取数据。</p>
<h3 id="2-主要协议支持"><a href="#2-主要协议支持" class="headerlink" title="2. 主要协议支持"></a>2. 主要协议支持</h3><h4 id="a-RTP-RTCP"><a href="#a-RTP-RTCP" class="headerlink" title="a. RTP&#x2F;RTCP"></a>a. RTP&#x2F;RTCP</h4><p>RTP（实时传输协议）用于实时传输多媒体数据，而 RTCP（RTP 控制协议）用于监控数据传输的质量和提供会话控制。</p>
<h4 id="b-RTSP"><a href="#b-RTSP" class="headerlink" title="b. RTSP"></a>b. RTSP</h4><p>RTSP（实时流协议）是一种网络控制协议，用于建立和控制媒体流会话。RTSP 类似于 HTTP，但专门设计用于流媒体控制。</p>
<h4 id="c-SIP"><a href="#c-SIP" class="headerlink" title="c. SIP"></a>c. SIP</h4><p>SIP（会话初始协议）用于建立、修改和终止多媒体会话（如 IP 电话呼叫）。</p>
<h3 id="3-支持的多媒体格式"><a href="#3-支持的多媒体格式" class="headerlink" title="3. 支持的多媒体格式"></a>3. 支持的多媒体格式</h3><p>LIVE555 支持多种多媒体格式的流式传输，包括但不限于：</p>
<ul>
<li>H.264 视频</li>
<li>MPEG 视频</li>
<li>AAC 音频</li>
<li>AMR 音频</li>
<li>JPEG 图像</li>
</ul>
<h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><ul>
<li><strong>实时视频监控系统</strong>：例如 IP 摄像机和网络视频录像机（NVR）。</li>
<li><strong>实时视频会议系统</strong>：例如视频会议软件和硬件设备。</li>
<li><strong>流媒体服务器</strong>：例如媒体流服务器，能够实时传输多媒体内容给客户端。</li>
<li><strong>多媒体播放器</strong>：能够接收和播放来自流媒体服务器的实时媒体流。</li>
</ul>
<h3 id="5-示例代码"><a href="#5-示例代码" class="headerlink" title="5. 示例代码"></a>5. 示例代码</h3><p>以下是一个简单的 RTSP 客户端示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;BasicUsageEnvironment.hh&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liveMedia.hh&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">afterPlaying</span><span class="params">(<span class="type">void</span>* clientData)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Placeholder for post-playback actions</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create the usage environment</span></span><br><span class="line">    TaskScheduler* scheduler = BasicTaskScheduler::<span class="built_in">createNew</span>();</span><br><span class="line">    UsageEnvironment* env = BasicUsageEnvironment::<span class="built_in">createNew</span>(*scheduler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the RTSP client</span></span><br><span class="line">    RTSPClient* rtspClient = RTSPClient::<span class="built_in">createNew</span>(*env, <span class="string">&quot;rtsp://example.com/stream&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the event loop</span></span><br><span class="line">    env-&gt;<span class="built_in">taskScheduler</span>().<span class="built_in">doEventLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cleanup</span></span><br><span class="line">    <span class="keyword">delete</span> rtspClient;</span><br><span class="line">    env-&gt;<span class="built_in">reclaim</span>();</span><br><span class="line">    <span class="keyword">delete</span> scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何创建一个简单的 RTSP 客户端，连接到 RTSP 流媒体服务器并进入事件循环。</p>
<h3 id="6-文档和资源"><a href="#6-文档和资源" class="headerlink" title="6. 文档和资源"></a>6. 文档和资源</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.live555.com/">LIVE555 官方网站</a></li>
<li><a target="_blank" rel="noopener" href="http://www.live555.com/liveMedia/">LIVE555 文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rgaufman/live555">GitHub 代码仓库</a></li>
</ul>
<p>通过这些资源，您可以获得更多关于 LIVE555 的详细信息和使用指南。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/12/notebook/Tools/2024-07-12-LZ4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/12/notebook/Tools/2024-07-12-LZ4/" class="post-title-link" itemprop="url">lz4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-12 14:00:00" itemprop="dateCreated datePublished" datetime="2024-07-12T14:00:00+08:00">2024-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>LZ4库相关笔记</li>
</ul>
<h2 id="lz4-h-是什么"><a href="#lz4-h-是什么" class="headerlink" title="lz4.h 是什么"></a>lz4.h 是什么</h2><p><code>lz4.h</code> 是 LZ4 压缩库的头文件。LZ4 是一种非常快速的无损压缩算法，专为高性能和高压缩率设计。LZ4 库主要用于数据压缩和解压缩操作，适用于需要快速处理大量数据的应用程序。</p>
<p>LZ4 库的头文件 <code>lz4.h</code> 定义了所有必要的函数和数据结构，使得开发者可以在他们的 C 或 C++ 项目中轻松地使用 LZ4 压缩和解压缩功能。这个头文件通常包含以下内容：</p>
<ol>
<li><strong>数据类型和结构</strong>：定义了用于压缩和解压缩过程的数据类型和结构体。</li>
<li><strong>宏和常量</strong>：定义了库中使用的一些常量和宏。</li>
<li><strong>函数声明</strong>：声明了库中提供的所有函数，包括压缩和解压缩函数。</li>
</ol>
<p>常用的函数包括：</p>
<ul>
<li><code>LZ4_compress_default()</code></li>
<li><code>LZ4_decompress_safe()</code></li>
<li><code>LZ4_compressBound()</code></li>
</ul>
<p>这些函数分别用于默认压缩、解压缩和计算压缩缓冲区的最大大小。</p>
<p>以下是一个使用 <code>lz4.h</code> 的简单示例，演示如何进行压缩和解压缩：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lz4.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 原始数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* input = <span class="string">&quot;Hello, LZ4 compression!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> inputSize = <span class="built_in">strlen</span>(input) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩缓冲区</span></span><br><span class="line">    <span class="type">int</span> maxCompressedSize = LZ4_compressBound(inputSize);</span><br><span class="line">    <span class="type">char</span>* compressedData = (<span class="type">char</span>*)<span class="built_in">malloc</span>(maxCompressedSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩数据</span></span><br><span class="line">    <span class="type">int</span> compressedDataSize = LZ4_compress_default(input, compressedData, inputSize, maxCompressedSize);</span><br><span class="line">    <span class="keyword">if</span> (compressedDataSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Compression failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(compressedData);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩缓冲区</span></span><br><span class="line">    <span class="type">char</span>* decompressedData = (<span class="type">char</span>*)<span class="built_in">malloc</span>(inputSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩数据</span></span><br><span class="line">    <span class="type">int</span> decompressedSize = LZ4_decompress_safe(compressedData, decompressedData, compressedDataSize, inputSize);</span><br><span class="line">    <span class="keyword">if</span> (decompressedSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Decompression failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(compressedData);</span><br><span class="line">        <span class="built_in">free</span>(decompressedData);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出解压缩后的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Decompressed data: %s\n&quot;</span>, decompressedData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="built_in">free</span>(compressedData);</span><br><span class="line">    <span class="built_in">free</span>(decompressedData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用 LZ4 库进行数据的压缩和解压缩操作。</p>
<h2 id="LZ4-库是什么"><a href="#LZ4-库是什么" class="headerlink" title="LZ4 库是什么"></a>LZ4 库是什么</h2><p>LZ4 库是一个开源的压缩算法库，专注于提供高效、快速的无损压缩和解压缩功能。LZ4 是一种非常快的压缩算法，能够在保持高压缩速度的同时提供良好的压缩率。它特别适用于需要快速处理大量数据的应用程序，例如日志压缩、传输数据的实时压缩、存储系统等。</p>
<p>LZ4 库具有以下几个主要特点：</p>
<ol>
<li><strong>高速压缩和解压缩</strong>：LZ4 以其极快的压缩和解压缩速度而闻名，通常在几百MB&#x2F;s到几GB&#x2F;s的范围内。</li>
<li><strong>无损压缩</strong>：LZ4 是无损压缩算法，这意味着压缩和解压缩过程中数据不会丢失。</li>
<li><strong>简单易用</strong>：LZ4 库提供了简单易用的 API，可以很容易地集成到 C、C++ 项目中。它还提供了其他语言的绑定，例如 Python、Java 等。</li>
<li><strong>小内存占用</strong>：LZ4 的压缩和解压缩过程对内存的占用很小，适合在内存受限的环境中使用。</li>
</ol>
<h3 id="LZ4-库的使用"><a href="#LZ4-库的使用" class="headerlink" title="LZ4 库的使用"></a>LZ4 库的使用</h3><p>LZ4 库主要提供了两个核心函数：<code>LZ4_compress_default</code> 和 <code>LZ4_decompress_safe</code>。</p>
<h4 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h4><p><code>LZ4_compress_default</code> 函数用于压缩数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LZ4_compress_default</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* source, <span class="type">char</span>* dest, <span class="type">int</span> sourceSize, <span class="type">int</span> maxDestSize)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>source</code>：指向要压缩的源数据。</li>
<li><code>dest</code>：指向压缩后存储数据的目标缓冲区。</li>
<li><code>sourceSize</code>：源数据的大小。</li>
<li><code>maxDestSize</code>：目标缓冲区的最大大小。</li>
</ul>
<p>返回值是压缩后的数据大小，如果返回值为 0 或负值，则表示压缩失败。</p>
<h4 id="解压缩数据"><a href="#解压缩数据" class="headerlink" title="解压缩数据"></a>解压缩数据</h4><p><code>LZ4_decompress_safe</code> 函数用于解压缩数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LZ4_decompress_safe</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* source, <span class="type">char</span>* dest, <span class="type">int</span> compressedSize, <span class="type">int</span> maxDecompressedSize)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>source</code>：指向要解压缩的压缩数据。</li>
<li><code>dest</code>：指向解压缩后存储数据的目标缓冲区。</li>
<li><code>compressedSize</code>：压缩数据的大小。</li>
<li><code>maxDecompressedSize</code>：目标缓冲区的最大大小。</li>
</ul>
<p>返回值是解压缩后的数据大小，如果返回值为负值，则表示解压缩失败。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面是一个简单的示例，展示了如何使用 LZ4 库进行数据的压缩和解压缩：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lz4.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 原始数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* input = <span class="string">&quot;Hello, LZ4 compression!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> inputSize = <span class="built_in">strlen</span>(input) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩缓冲区</span></span><br><span class="line">    <span class="type">int</span> maxCompressedSize = LZ4_compressBound(inputSize);</span><br><span class="line">    <span class="type">char</span>* compressedData = (<span class="type">char</span>*)<span class="built_in">malloc</span>(maxCompressedSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩数据</span></span><br><span class="line">    <span class="type">int</span> compressedDataSize = LZ4_compress_default(input, compressedData, inputSize, maxCompressedSize);</span><br><span class="line">    <span class="keyword">if</span> (compressedDataSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Compression failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(compressedData);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩缓冲区</span></span><br><span class="line">    <span class="type">char</span>* decompressedData = (<span class="type">char</span>*)<span class="built_in">malloc</span>(inputSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩数据</span></span><br><span class="line">    <span class="type">int</span> decompressedSize = LZ4_decompress_safe(compressedData, decompressedData, compressedDataSize, inputSize);</span><br><span class="line">    <span class="keyword">if</span> (decompressedSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Decompression failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(compressedData);</span><br><span class="line">        <span class="built_in">free</span>(decompressedData);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出解压缩后的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Decompressed data: %s\n&quot;</span>, decompressedData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="built_in">free</span>(compressedData);</span><br><span class="line">    <span class="built_in">free</span>(decompressedData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用 LZ4 库的压缩和解压缩函数来处理字符串数据。</p>
<h2 id="LZ4库-编译安装"><a href="#LZ4库-编译安装" class="headerlink" title="LZ4库 编译安装"></a>LZ4库 编译安装</h2><p>要编译和安装 LZ4 库，你可以按照以下步骤进行。这里假设你使用的是 Unix 系统，例如 Linux 或 macOS。如果你使用的是 Windows 系统，可以参考对应的指南。</p>
<h3 id="1-下载-LZ4-源代码"><a href="#1-下载-LZ4-源代码" class="headerlink" title="1. 下载 LZ4 源代码"></a>1. 下载 LZ4 源代码</h3><p>首先，你需要从 LZ4 的 GitHub 仓库下载源代码。你可以使用 <code>git</code> 命令来克隆仓库，或者直接从 GitHub 网站下载压缩包。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lz4/lz4.git</span><br><span class="line"><span class="built_in">cd</span> lz4</span><br></pre></td></tr></table></figure>

<h3 id="2-编译-LZ4-库"><a href="#2-编译-LZ4-库" class="headerlink" title="2. 编译 LZ4 库"></a>2. 编译 LZ4 库</h3><p>进入 LZ4 源代码目录后，使用以下命令来编译库。LZ4 使用 <code>make</code> 工具来管理编译过程。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>这个命令会编译所有的源文件并生成可执行文件和库文件。</p>
<h3 id="3-安装-LZ4-库"><a href="#3-安装-LZ4-库" class="headerlink" title="3. 安装 LZ4 库"></a>3. 安装 LZ4 库</h3><p>编译完成后，你可以使用以下命令来安装 LZ4 库。默认情况下，库会安装到系统的标准位置（例如 <code>/usr/local</code>）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<p>如果你希望将库安装到自定义位置，可以使用 <code>PREFIX</code> 选项来指定目标路径：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> make install PREFIX=/path/to/your/installation/directory</span><br></pre></td></tr></table></figure>

<h3 id="4-验证安装"><a href="#4-验证安装" class="headerlink" title="4. 验证安装"></a>4. 验证安装</h3><p>你可以使用以下命令来验证 LZ4 是否安装成功：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lz4 -V</span><br></pre></td></tr></table></figure>

<p>这个命令会输出 LZ4 的版本信息，表明 LZ4 已成功安装。</p>
<h3 id="5-在项目中使用-LZ4-库"><a href="#5-在项目中使用-LZ4-库" class="headerlink" title="5. 在项目中使用 LZ4 库"></a>5. 在项目中使用 LZ4 库</h3><p>在你的 C&#x2F;C++ 项目中，你需要包含 LZ4 的头文件并链接 LZ4 库。假设你已经安装 LZ4，并且头文件和库文件位于系统的标准位置，你可以使用以下示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lz4.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 原始数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* input = <span class="string">&quot;Hello, LZ4 compression!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> inputSize = <span class="built_in">strlen</span>(input) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩缓冲区</span></span><br><span class="line">    <span class="type">int</span> maxCompressedSize = LZ4_compressBound(inputSize);</span><br><span class="line">    <span class="type">char</span>* compressedData = (<span class="type">char</span>*)<span class="built_in">malloc</span>(maxCompressedSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩数据</span></span><br><span class="line">    <span class="type">int</span> compressedDataSize = LZ4_compress_default(input, compressedData, inputSize, maxCompressedSize);</span><br><span class="line">    <span class="keyword">if</span> (compressedDataSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Compression failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(compressedData);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩缓冲区</span></span><br><span class="line">    <span class="type">char</span>* decompressedData = (<span class="type">char</span>*)<span class="built_in">malloc</span>(inputSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩数据</span></span><br><span class="line">    <span class="type">int</span> decompressedSize = LZ4_decompress_safe(compressedData, decompressedData, compressedDataSize, inputSize);</span><br><span class="line">    <span class="keyword">if</span> (decompressedSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Decompression failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(compressedData);</span><br><span class="line">        <span class="built_in">free</span>(decompressedData);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出解压缩后的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Decompressed data: %s\n&quot;</span>, decompressedData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="built_in">free</span>(compressedData);</span><br><span class="line">    <span class="built_in">free</span>(decompressedData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译这个示例代码时，记得链接 LZ4 库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o example example.c -llz4</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，你应该能够成功地编译、安装和使用 LZ4 库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/12/notebook/Tools/2024-07-12-ascend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/12/notebook/Tools/2024-07-12-ascend/" class="post-title-link" itemprop="url">ascend</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-12 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-12T09:00:00+08:00">2024-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ascend相关笔记</li>
</ul>
<h2 id="ascend是什么"><a href="#ascend是什么" class="headerlink" title="ascend是什么"></a>ascend是什么</h2><ul>
<li>2023年5月6日，在昇腾AI开发者峰会上，华为正式发布了面向算子开发场景的昇腾Ascend C编程语言。Ascend C原生支持C&#x2F;C++编程规范，通过多层接口抽象、并行编程范式、孪生调试等技术，极大提高了算子的开发效率，帮助AI开发者低成本完成算子开发和模型调优部署。</li>
<li>和CUDA开发的算子运行在GPU上一样，基于Ascend C开发的算子，可以通过异构计算架构CANN（Compute Architecture for Neural Networks）运行在昇腾AI处理器（可简称NPU）上。CANN是使能昇腾AI处理器的一个软件栈，通过软硬件协同优化，能够充分发挥昇腾AI处理器的强大算力。从下面的架构图可以清楚的看到，使用Ascend C编程语言开发的算子通过编译器编译和运行时调度，最终运行在昇腾AI处理器上。<br><img src="/./ascend.png" alt="架构图"></li>
<li>我们知道，通用计算就是我们常写的一些在CPU上运行的计算，它擅长逻辑控制和串行计算，而AI计算相对通用计算来说，更擅长并行计算，可支持大规模的计算密集型任务。</li>
<li>最小计算代码能同时计算多个数据的乘加，更近一步，如果使用Cube计算单元，只需要一条语句就能完成一个矩阵乘的计算，这就是我们所说的SIMD（单指令多数据）。因此，我们通常使用AI处理器来进行大量的并行计算。</li>
<li>NPU不能独立运行，需要与CPU协同工作，可以看成是CPU的协处理器，CPU负责整个操作系统运行，管理各类资源并进行复杂的逻辑控制，而NPU主要负责并行计算任务。在基于CPU+NPU的异构计算架构中，NPU与CPU通过PCIe总线连接在一起来协同工作，CPU所在位置称为主机端（host），而NPU所在位置称为设备端（device）</li>
</ul>
<h2 id="ascend-C编程范式"><a href="#ascend-C编程范式" class="headerlink" title="ascend C编程范式"></a>ascend C编程范式</h2><ul>
<li>Ascend C 编程范式是一种流水线式的编程范式，把算子核内的处理程序，分成多个流水任务，通过队列(Queue)完成任务间通信和同步，并通过统一的内存管理模块(Pipe)管理任务间通信内存。流水编程范式应用了流水线并行计算方法。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/10/notebook/Docker/2024-07-10-docker_4_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/10/notebook/Docker/2024-07-10-docker_4_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">docker_4_常见问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-10 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-10T09:00:00+08:00">2024-07-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-01 08:52:19" itemprop="dateModified" datetime="2025-05-01T08:52:19+08:00">2025-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>记录docker部署下遇到的问题及解决方法</li>
</ul>
<h2 id="docker-拉取镜像超时"><a href="#docker-拉取镜像超时" class="headerlink" title="docker 拉取镜像超时"></a>docker 拉取镜像超时</h2><ul>
<li><p>编辑或新建 &#x2F;etc&#x2F;docker&#x2F;daemon.json</p>
</li>
<li><p>粘贴以下内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.registry.cyou&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker-cf.registry.cyou&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://dockercf.jsdelivr.fyi&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.jsdelivr.fyi&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://dockertest.jsdelivr.fyi&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://dockerproxy.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.nju.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.iscas.ac.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.rainbond.cc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://do.nark.eu.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://dc.j8.work&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://gst6rzl9.mirror.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http://mirrors.ustc.edu.cn/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http://mirrors.sohu.com/&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;registry.docker-cn.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;docker.mirrors.ustc.edu.cn&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启docker</p>
<ul>
<li>sudo systemctl docker</li>
</ul>
</li>
<li><p>验证是否生效</p>
<ul>
<li>docker info</li>
</ul>
</li>
<li><p>镜像源要够多</p>
<ul>
<li>不是所有镜像都是用于你当前的网络环境，多加几个备用，不仅速度快，还能防止单点故障</li>
</ul>
</li>
<li><p>添加 insecure-registries</p>
<ul>
<li>有些镜像源不支持HTTPS，或你所在的网络环境中存在中间人干扰，Docker默认不会信任这些源。通过加上insecure-registries，明确告诉Docker信任</li>
</ul>
</li>
<li><p>debug和experimental参数</p>
<ul>
<li>这两个不是解决问题的核心，但是建议开启debug:true。可以打印更多日志方便后续排查</li>
</ul>
</li>
<li><p>引用</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_76849350/article/details/147227440">https://blog.csdn.net/2301_76849350/article/details/147227440</a></li>
</ul>
</li>
</ul>
<h2 id="docker容器日志导致主机磁盘空间满了"><a href="#docker容器日志导致主机磁盘空间满了" class="headerlink" title="docker容器日志导致主机磁盘空间满了"></a>docker容器日志导致主机磁盘空间满了</h2><h3 id="什么是Docker日志"><a href="#什么是Docker日志" class="headerlink" title="什么是Docker日志"></a>什么是Docker日志</h3><ul>
<li>在Docker中，日志是容器生成的所有输出，该输出保存在主机计算机上的日志文件中。这些日志文件可以帮助了解Docker容器的健康问题，调试问题，并监视应用程序行为。Docker在linux上，容器日志一般存放在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;container_id&#x2F; 下面</li>
</ul>
<h3 id="为什么需要清理Docker日志"><a href="#为什么需要清理Docker日志" class="headerlink" title="为什么需要清理Docker日志"></a>为什么需要清理Docker日志</h3><ul>
<li>Docker日志文件可以变得相当大，因为他们持续记录容器生成的所有输出。如果不定期的清理这些日志文件，他们将占用大量的磁盘空间。在服务器上，磁盘空间非常重要。如果磁盘空间不足，将导致系统崩溃或者性能下降。此外，当Docker容器日志过大时，可能会导致调试问题过于复杂或深度，使用Docker日志分析工具成为不可避免的任务。</li>
</ul>
<h3 id="如何清理Docker日志"><a href="#如何清理Docker日志" class="headerlink" title="如何清理Docker日志"></a>如何清理Docker日志</h3><ul>
<li><p>清理Docker日志的最佳方法是通过Docker提供的内置支持在容器运行时管理日志级别并限制日志大小。但是，如果需要清理已经存在的日志文件，则可以用以下方法</p>
</li>
<li><p>使用Docker命令清理</p>
<ul>
<li>清空所有容器的日志文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune --filter &quot;until=24h&quot;</span><br></pre></td></tr></table></figure></li>
<li>这将会删除已经停止容器的日志，最后使用时间超过24h的容器的日志将会被保留，也可以将24h这个参数按需更改。</li>
</ul>
</li>
<li><p>手动清理Docker日志</p>
<ul>
<li>需要找出要删除的容器ID<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure></li>
<li>该命令将返回运行的，停止的和删除的容器列表，以及他们的container id， image 和 names</li>
<li>在主机上找到日志文件，Docker日志文件通常在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;容器ID&#x2F;容器ID-json.log路径下，其中container_id为需要清理的容器ID</li>
<li>清空日志文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /dev/null &gt; /var/lib/docker/containers/容器ID/容器ID-json.log</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="启动时设置日志文件大小"><a href="#启动时设置日志文件大小" class="headerlink" title="启动时设置日志文件大小"></a>启动时设置日志文件大小</h3><ul>
<li>参考 docker 官方的文档，重启docker启动时增加参数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --log-opt max-size=10m --log-opt max-file=3 alpine ash</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
