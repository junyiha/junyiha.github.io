<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/15/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A2%86%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A2%86%E5%9F%9F/" class="post-title-link" itemprop="url">机器人领域</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>机器人学中的数学</li>
</ul>
<h2 id="工业机器人领域使用到的数学"><a href="#工业机器人领域使用到的数学" class="headerlink" title="工业机器人领域使用到的数学"></a>工业机器人领域使用到的数学</h2><p>工业机器人领域涉及到多个数学分支，这些数学工具用于机器人的建模、运动规划、控制系统设计等方面。以下是在工业机器人领域常用的数学：</p>
<ol>
<li><p><strong>线性代数（Linear Algebra）：</strong> 工业机器人中广泛使用线性代数来表示和处理坐标变换、运动学和动力学问题。矩阵和向量的运算在描述机器人的位姿、关节角度以及执行器的运动方面非常有用。</p>
</li>
<li><p><strong>几何学（Geometry）：</strong> 机器人的运动学建模涉及到坐标系变换、旋转矩阵、齐次坐标等几何概念。几何学的知识用于描述和计算机器人末端执行器的位置和姿态。</p>
</li>
<li><p><strong>微积分（Calculus）：</strong> 运动规划、轨迹生成和优化算法通常需要微积分的方法。例如，对机器人的路径进行优化时，需要计算速度、加速度等。</p>
</li>
<li><p><strong>数值分析（Numerical Analysis）：</strong> 工业机器人控制系统通常需要进行数值计算，如逆运动学求解、路径规划、动力学模拟等。数值分析提供了有效和稳定的算法来解决这些问题。</p>
</li>
<li><p><strong>控制理论（Control Theory）：</strong> 控制理论用于设计机器人的控制系统，包括反馈控制、PID控制器、状态空间控制等。这些方法有助于保持机器人在目标轨迹上的准确性和稳定性。</p>
</li>
<li><p><strong>优化理论（Optimization Theory）：</strong> 优化方法在工业机器人中的应用很广泛，例如路径规划、运动优化、参数优化等。这有助于提高机器人的效率和性能。</p>
</li>
<li><p><strong>刚体运动学（Rigid Body Kinematics）：</strong> 刚体运动学用于描述机器人末端执行器的位置、速度和加速度，以及机器人关节的运动学性质。</p>
</li>
<li><p><strong>机器学习和人工智能（Machine Learning and AI）：</strong> 近年来，机器学习和人工智能在机器人领域的应用逐渐增多，包括视觉识别、自主导航、智能控制等。</p>
</li>
</ol>
<p>这些数学工具的综合运用使得工业机器人能够执行更复杂、精确和灵活的任务，提高了生产效率和质量。</p>
<h2 id="弧度和角度转换关系"><a href="#弧度和角度转换关系" class="headerlink" title="弧度和角度转换关系"></a>弧度和角度转换关系</h2><p>弧度（radians）和角度（degrees）之间的转换关系可以通过以下公式表示：</p>
<ol>
<li><p><strong>从角度到弧度的转换</strong>：</p>
<p>弧度 &#x3D; 角度 × π &#x2F; 180</p>
<p>其中，π（pi）是圆周率，约等于3.14159265359。</p>
<p>例如，将角度 90 度转换为弧度：</p>
<p>弧度 &#x3D; 90 × π &#x2F; 180 &#x3D; π &#x2F; 2 弧度</p>
</li>
<li><p><strong>从弧度到角度的转换</strong>：</p>
<p>角度 &#x3D; 弧度 × 180 &#x2F; π</p>
<p>例如，将弧度 π&#x2F;2 转换为角度：</p>
<p>角度 &#x3D; (π &#x2F; 2) × 180 &#x2F; π &#x3D; 90 度</p>
</li>
</ol>
<p>这些公式允许你在弧度和角度之间进行相互转换。这在数学、物理学、工程学以及机器人学等领域中非常常见，因为不同的问题和公式可能使用不同的单位，所以需要进行转换以便正确地处理数据。</p>
<h2 id="机器人学-弧度-角度-转换"><a href="#机器人学-弧度-角度-转换" class="headerlink" title="机器人学 弧度 角度 转换"></a>机器人学 弧度 角度 转换</h2><p>在机器人学和计算机图形学中，经常需要在弧度（radians）和角度（degrees）之间进行转换，以便在不同的数学和编程上下文中使用。以下是弧度和角度之间的常见转换方法：</p>
<ol>
<li><p><strong>从角度到弧度的转换</strong>：</p>
<p>如果你有一个角度（以度为单位），想要将其转换为弧度（以弧度为单位），可以使用以下公式：</p>
<p>[ \text{弧度} &#x3D; \frac{\text{角度} \times \pi}{180} ]</p>
<p>例如，如果要将角度 90 度转换为弧度：</p>
<p>[ \text{弧度} &#x3D; \frac{90 \times \pi}{180} &#x3D; \frac{\pi}{2} \text{ radians} ]</p>
</li>
<li><p><strong>从弧度到角度的转换</strong>：</p>
<p>如果你有一个弧度（以弧度为单位），想要将其转换为角度（以度为单位），可以使用以下公式：</p>
<p>[ \text{角度} &#x3D; \frac{\text{弧度} \times 180}{\pi} ]</p>
<p>例如，如果要将弧度 (\frac{\pi}{2}) 转换为角度：</p>
<p>[ \text{角度} &#x3D; \frac{\frac{\pi}{2} \times 180}{\pi} &#x3D; 90^\circ ]</p>
</li>
</ol>
<p>这些转换公式是标准的数学关系，用于在角度和弧度之间进行转换。在机器人学和计算机图形学中，通常需要根据具体问题将角度和弧度进行相互转换，以便进行正确的计算和旋转操作。确保在程序中使用适当的单位，以避免单位混淆和错误的计算。</p>
<h2 id="机器人学-轴角为初始姿态-加上欧拉角-最终获取轴角-如何计算"><a href="#机器人学-轴角为初始姿态-加上欧拉角-最终获取轴角-如何计算" class="headerlink" title="机器人学 轴角为初始姿态 加上欧拉角 最终获取轴角 如何计算"></a>机器人学 轴角为初始姿态 加上欧拉角 最终获取轴角 如何计算</h2><p>在机器人学中，如果你有一个初始姿态（用轴角表示）和一个欧拉角，然后想要将这个欧拉角旋转添加到初始姿态中，最终获取新的轴角表示，你可以按照以下步骤进行计算：</p>
<ol>
<li><p><strong>将初始轴角（Axis-Angle）表示转换为旋转矩阵</strong>（Rotation Matrix）或四元数（Quaternion）。</p>
<ul>
<li>如果你的初始姿态使用轴角表示为 (AA_{init} &#x3D; (\mathbf{u}<em>{init}, \theta</em>{init}))，其中 (\mathbf{u}<em>{init}) 是旋转轴的单位向量，(\theta</em>{init}) 是旋转的角度，那么你可以使用轴角到旋转矩阵或四元数的转换公式将其转换为旋转矩阵 (R_{init}) 或四元数 (Q_{init})。</li>
</ul>
</li>
<li><p><strong>将欧拉角转换为旋转矩阵</strong>。</p>
<ul>
<li>如果你有欧拉角表示为 (E &#x3D; (\alpha, \beta, \gamma))，其中 (\alpha) 是滚动角，(\beta) 是俯仰角，(\gamma) 是偏航角，那么你可以使用欧拉角到旋转矩阵的转换公式将其转换为旋转矩阵 (R_{E})。</li>
</ul>
</li>
<li><p><strong>计算最终的旋转矩阵</strong>。</p>
<ul>
<li>将初始的旋转矩阵 (R_{init}) 与欧拉角的旋转矩阵 (R_{E}) 相乘，得到最终的旋转矩阵 (R_{final} &#x3D; R_{init} \cdot R_{E})。</li>
</ul>
</li>
<li><p><strong>将最终的旋转矩阵转换为轴角</strong>。</p>
<ul>
<li>最后，你可以使用旋转矩阵到轴角的转换公式，将最终的旋转矩阵 (R_{final}) 转换为轴角表示 (AA_{final} &#x3D; (\mathbf{u}<em>{final}, \theta</em>{final}))。</li>
</ul>
</li>
</ol>
<p>需要注意的是，转换公式的具体形式取决于你使用的坐标系约定和数学库（例如，Eigen、Mathematics Toolbox等）。因此，在实际应用中，请查阅相应的文档以确保正确的转换。</p>
<p>通过这个过程，你可以将初始轴角姿态与欧拉角旋转相结合，获得最终的轴角姿态。这种方法允许你在不同表示之间进行转换，并有效地管理机器人的姿态。</p>
<h2 id="机器人学-旋转矩阵-运算-详解"><a href="#机器人学-旋转矩阵-运算-详解" class="headerlink" title="机器人学 旋转矩阵 运算 详解"></a>机器人学 旋转矩阵 运算 详解</h2><p>在机器人学中，旋转矩阵是一种常用的表示方法，用于描述三维空间中的旋转操作。旋转矩阵是一个3x3的矩阵，其中每一列和每一行都是一个单位向量，用来表示旋转后的坐标系的方向。通过旋转矩阵，可以非常有效地表示和计算物体的旋转。</p>
<p>以下是关于机器人学中旋转矩阵运算的详细解释：</p>
<ol>
<li><p><strong>旋转矩阵的表示</strong>：</p>
<p>一个通用的旋转矩阵通常表示为：</p>
<p>[ R &#x3D; \begin{bmatrix} r_{11} &amp; r_{12} &amp; r_{13} \ r_{21} &amp; r_{22} &amp; r_{23} \ r_{31} &amp; r_{32} &amp; r_{33} \end{bmatrix} ]</p>
<p>其中，( R ) 是旋转矩阵，( r_{ij} ) 表示矩阵的元素，表示旋转后的坐标系的方向。</p>
</li>
<li><p><strong>旋转矩阵的性质</strong>：</p>
<ul>
<li><p>旋转矩阵是正交矩阵（orthogonal matrix），即它的列向量和行向量都是单位向量，并且相互垂直。这意味着旋转矩阵的转置等于其逆。</p>
</li>
<li><p>旋转矩阵的行和列表示了新坐标系的基向量。</p>
</li>
<li><p>旋转矩阵的行（或列）的长度不变，即 ( |r_i| &#x3D; 1 )。</p>
</li>
</ul>
</li>
<li><p><strong>旋转矩阵的运算</strong>：</p>
<ul>
<li><p>旋转矩阵可以用于将一个点从一个坐标系转换到另一个坐标系。给定一个点的坐标 ( \mathbf{p} )，通过乘以旋转矩阵 ( R )，可以得到旋转后的坐标 ( \mathbf{p}’ )：</p>
<p>[ \mathbf{p}’ &#x3D; R \cdot \mathbf{p} ]</p>
</li>
<li><p>旋转矩阵之间可以进行矩阵乘法来表示复合旋转。如果有两个旋转矩阵 ( R_1 ) 和 ( R_2 )，它们分别表示两个旋转操作，那么它们的复合旋转可以表示为：</p>
<p>[ R &#x3D; R_1 \cdot R_2 ]</p>
</li>
<li><p>旋转矩阵的逆矩阵表示相反的旋转。如果 ( R ) 表示一个旋转，那么 ( R^{-1} ) 表示相反的旋转，即将物体旋转回初始位置。</p>
</li>
</ul>
</li>
<li><p><strong>Euler角到旋转矩阵</strong>：</p>
<p>通常，可以使用欧拉角（滚动、俯仰、偏航）来构建旋转矩阵。不同的欧拉角顺序会产生不同的旋转矩阵。例如，在XYZ顺序下，可以使用以下方式构建旋转矩阵：</p>
<p>[ R &#x3D; R_z(\text{偏航角}) \cdot R_y(\text{俯仰角}) \cdot R_x(\text{滚动角}) ]</p>
<p>其中，( R_x )、( R_y ) 和 ( R_z ) 分别表示绕X、Y和Z轴的旋转矩阵。</p>
</li>
</ol>
<p>旋转矩阵是机器人学中非常重要的工具，因为它们允许精确描述和计算旋转操作，这对于机器人的定位、导航和运动控制非常关键。通过旋转矩阵，机器人可以准确地执行各种复杂的旋转操作。然而，需要注意的是，旋转矩阵的运算可能比其他表示方法（如四元数）稍显复杂，因此在实际应用中需要小心处理。</p>
<h2 id="轴角-详解"><a href="#轴角-详解" class="headerlink" title="轴角 详解"></a>轴角 详解</h2><p>轴角（Axis-Angle）表示一种在三维空间中描述旋转的方式。它使用一个轴向量和一个角度来表示旋转操作。轴角常用于计算机图形学、机器人学以及三维游戏开发等领域，因为它可以更直观地描述旋转操作，而不像欧拉角那样容易出现万向锁问题。</p>
<p>轴角由以下两个要素组成：</p>
<ol>
<li><p>轴向量（Axis Vector）：这是一个单位向量，用于定义旋转的轴线方向。轴向量通常表示为单位长度的三维向量，例如 <code>(x, y, z)</code>，其中 <code>(x, y, z)</code> 是轴的方向向量。</p>
</li>
<li><p>旋转角度（Angle）：这是绕轴线旋转的角度，通常以弧度（radians）为单位表示。角度可以是正数或负数，表示旋转的方向，通常在 0 到 2π（360度）之间。</p>
</li>
</ol>
<p>轴角表示一个旋转操作，其效果是绕轴向量指定的轴线旋转一定的角度。旋转角度的方向由轴向量的方向确定，旋转的大小由旋转角度表示。</p>
<p>轴角的表示方式可以用以下公式表示：</p>
<p>[ \text{Rotation} &#x3D; \theta \cdot \mathbf{u} ]</p>
<p>其中：</p>
<ul>
<li>( \theta ) 是旋转角度，以弧度表示。</li>
<li>( \mathbf{u} ) 是单位轴向量，表示旋转的轴。</li>
</ul>
<p>轴角的使用步骤通常如下：</p>
<ol>
<li>定义轴向量（单位向量），表示旋转的轴线方向。</li>
<li>指定旋转的角度（以弧度为单位）。</li>
<li>使用轴向量和旋转角度构建轴角表示。</li>
</ol>
<p>轴角的优点之一是它没有欧拉角的万向锁问题，因此在某些情况下更容易处理。然而，它相对较难以直观地理解，因此在实际应用中，通常会使用其他表示方法，如四元数（Quaternions），以更方便地进行旋转计算。</p>
<p>总之，轴角是一种用于描述三维空间中旋转的方法，它使用轴向量和旋转角度来表示旋转操作。</p>
<h2 id="欧拉角-详解"><a href="#欧拉角-详解" class="headerlink" title="欧拉角 详解"></a>欧拉角 详解</h2><p>欧拉角（Euler Angles）是一种用于描述物体在三维空间中旋转的方法。它是以数学家Leonhard Euler的名字命名的，用于将旋转运动分解为三个连续的旋转操作，通常分别绕X轴、Y轴和Z轴进行旋转。欧拉角是一种常见的旋转表示方法，用于计算机图形学、航空航天、机器人学、三维动画等领域。</p>
<p>欧拉角通常由三个角度组成，分别是：</p>
<ol>
<li><p><strong>滚动角（Roll）</strong>：也称为Bank角，表示绕X轴的旋转。滚动角度用来描述物体绕其自身前后轴的旋转，通常以弧度（radians）为单位表示。正角度表示顺时针旋转，负角度表示逆时针旋转。</p>
</li>
<li><p><strong>俯仰角（Pitch）</strong>：也称为Elevation角，表示绕Y轴的旋转。俯仰角度用来描述物体绕其自身左右轴的旋转，通常以弧度为单位表示。正角度表示向上旋转，负角度表示向下旋转。</p>
</li>
<li><p><strong>偏航角（Yaw）</strong>：也称为Heading角，表示绕Z轴的旋转。偏航角度用来描述物体绕其自身垂直轴的旋转，通常以弧度为单位表示。正角度表示顺时针旋转，负角度表示逆时针旋转。</p>
</li>
</ol>
<p>欧拉角的顺序很重要，因为它们定义了旋转的顺序。常见的欧拉角顺序包括：</p>
<ul>
<li>XYZ：首先绕X轴旋转，然后绕Y轴旋转，最后绕Z轴旋转。</li>
<li>ZYX：首先绕Z轴旋转，然后绕Y轴旋转，最后绕X轴旋转。</li>
<li>YXZ：首先绕Y轴旋转，然后绕X轴旋转，最后绕Z轴旋转。</li>
</ul>
<p>不同的欧拉角顺序可能导致不同的旋转结果，因此在使用欧拉角时必须确保选定了正确的顺序。</p>
<p>尽管欧拉角在许多情况下非常直观，但它们也存在一些问题，例如万向锁问题，即在某些情况下无法唯一表示旋转。为了避免这些问题，有时会使用其他旋转表示方法，如四元数（Quaternions）。</p>
<p>总之，欧拉角是一种用于描述三维空间中旋转的常见方法，它由三个角度组成，表示绕X、Y和Z轴的旋转。欧拉角的顺序非常重要，并且在某些情况下可能存在问题，因此在使用时需要谨慎选择。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Network/2024-05-22-network_1_%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Network/2024-05-22-network_1_%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">network_1_网络理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>网络基础知识和基础理论</li>
</ul>
<h2 id="网关是什么"><a href="#网关是什么" class="headerlink" title="网关是什么"></a>网关是什么</h2><p>在计算机网络中，网关（Gateway）是连接两个不同网络的设备或软件。它充当连接不同网络之间的桥梁，使得数据可以在这些网络之间传输。网关可以是硬件设备，如路由器，也可以是运行特定网络协议的计算机或服务器。</p>
<p>网关的作用是转发数据包，根据目标地址将数据从一个网络传输到另一个网络。它还可以执行一些额外的功能，如网络地址转换（NAT）、防火墙安全过滤、代理服务等。网关在网络通信中扮演着重要的角色，使得不同网络之间能够有效地通信和交换信息。</p>
<h2 id="网关详解"><a href="#网关详解" class="headerlink" title="网关详解"></a>网关详解</h2><p>网关是指在计算机网络中连接两个不同网络的设备或软件。它在网络中扮演着转换数据、连接不同网络并进行数据交换的重要角色。</p>
<p>以下是关于网关的详细解释：</p>
<ol>
<li><p><strong>连接不同网络：</strong> 网关允许不同类型或不同协议的网络进行通信。它可以连接局域网（LAN）与广域网（WAN）、不同厂商的设备、不同网络协议（如以太网、Wi-Fi、蓝牙等）的网络之间。</p>
</li>
<li><p><strong>数据转发：</strong> 网关接收从源网络发来的数据包，并根据目标地址的信息将这些数据包转发到目标网络中。它根据特定的路由规则和网络协议进行数据包的转发。</p>
</li>
<li><p><strong>协议转换：</strong> 网关可以执行协议转换的功能，将一个网络协议的数据转换为另一个网络协议的数据。这种转换允许不同类型的网络进行交流，即使它们使用不同的通信标准和协议。</p>
</li>
<li><p><strong>安全性：</strong> 网关通常包含安全功能，比如防火墙和网络地址转换（NAT）。防火墙可以监控和控制数据包的流量，确保网络安全。NAT 可以隐藏网络内部设备的真实 IP 地址，增强网络的安全性。</p>
</li>
<li><p><strong>路由功能：</strong> 网关可以根据路由表或配置的路由规则来决定数据包的最佳传输路径，以便有效地将数据包从源网络传输到目标网络。</p>
</li>
<li><p><strong>代理服务：</strong> 网关可以提供代理服务，允许客户端通过网关访问互联网。代理服务还可以对互联网上的请求进行缓存和过滤，提高网络性能和安全性。</p>
</li>
</ol>
<p>总的来说，网关在计算机网络中扮演着非常重要的角色，它连接和协调不同网络之间的通信，同时提供了一些安全和管理功能，确保网络通信的顺畅和安全。</p>
<h2 id="uri-详解"><a href="#uri-详解" class="headerlink" title="uri 详解"></a>uri 详解</h2><p>URI（Uniform Resource Identifier）是一种用于标识和定位资源的字符串表示形式。它是互联网上广泛使用的标准，用于唯一地标识资源，包括网页、图片、视频、文件等。URI 是由 RFC 3986（通用资源标识符：通用语法）定义的。</p>
<p>URI 的一般格式为：<code>scheme:[//authority]path[?query][#fragment]</code></p>
<p>其中各部分的含义如下：</p>
<ol>
<li><p>Scheme（协议）：表示资源的访问协议，如 <code>http</code>、<code>https</code>、<code>ftp</code> 等。它通常用于指定资源的访问方式。例如：<code>http://www.example.com</code></p>
</li>
<li><p>Authority（权限）：表示资源的权限部分，包括主机名和可选的端口号。它通常用于指定资源所在的服务器或主机。例如：<code>www.example.com:8080</code></p>
</li>
<li><p>Path（路径）：表示资源在服务器上的路径。它通常用于指定资源在服务器文件系统中的位置。例如：<code>/path/to/resource</code></p>
</li>
<li><p>Query（查询）：表示资源的查询部分，用于传递参数给资源。它通常用于向服务器传递额外的信息。例如：<code>?id=123&amp;name=example</code></p>
</li>
<li><p>Fragment（片段）：表示资源的片段标识符，用于指定资源的某个特定片段。它通常用于定位 HTML 页面中的某个锚点。例如：<code>#section1</code></p>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>下面是几个 URI 的示例：</p>
<ol>
<li><p><code>https://www.example.com/index.html</code></p>
<ul>
<li>Scheme: <code>https</code></li>
<li>Authority: <code>www.example.com</code></li>
<li>Path: <code>/index.html</code></li>
</ul>
</li>
<li><p><code>ftp://ftp.example.com/files/data.zip</code></p>
<ul>
<li>Scheme: <code>ftp</code></li>
<li>Authority: <code>ftp.example.com</code></li>
<li>Path: <code>/files/data.zip</code></li>
</ul>
</li>
<li><p><code>https://www.example.com/search?q=uri+explanation</code></p>
<ul>
<li>Scheme: <code>https</code></li>
<li>Authority: <code>www.example.com</code></li>
<li>Path: <code>/search</code></li>
<li>Query: <code>q=uri+explanation</code></li>
</ul>
</li>
<li><p><code>https://www.example.com/index.html#section2</code></p>
<ul>
<li>Scheme: <code>https</code></li>
<li>Authority: <code>www.example.com</code></li>
<li>Path: <code>/index.html</code></li>
<li>Fragment: <code>#section2</code></li>
</ul>
</li>
</ol>
<p>URI 的重要性在于它提供了一种标准的方式来标识和定位互联网上的资源，使得用户可以通过统一的格式来访问和处理各种不同类型的资源。</p>
<hr>
<h2 id="url-详解"><a href="#url-详解" class="headerlink" title="url 详解"></a>url 详解</h2><p>URL（Uniform Resource Locator）是一种具体的 URI（Uniform Resource Identifier），用于定位和标识互联网上的资源。URL 是由 RFC 3986（通用资源标识符：通用语法）定义的，它是 URI 的一种常见形式。</p>
<p>URL 的一般格式为：<code>scheme://username:password@host:port/path?query#fragment</code></p>
<p>其中各部分的含义如下：</p>
<ol>
<li><p>Scheme（协议）：表示资源的访问协议，如 <code>http</code>、<code>https</code>、<code>ftp</code> 等。它通常用于指定资源的访问方式。例如：<code>https://www.example.com</code></p>
</li>
<li><p>Username 和 Password（用户名和密码）：表示资源的认证信息，用于访问受限资源时进行身份验证。它们是可选的，并用于提供访问资源所需的用户名和密码。例如：<code>ftp://user:password@example.com</code></p>
</li>
<li><p>Host 和 Port（主机名和端口号）：表示资源所在的主机名和可选的端口号。它通常用于指定资源所在的服务器或主机。例如：<code>https://www.example.com:8080</code></p>
</li>
<li><p>Path（路径）：表示资源在服务器上的路径。它通常用于指定资源在服务器文件系统中的位置。例如：<code>/path/to/resource</code></p>
</li>
<li><p>Query（查询）：表示资源的查询部分，用于传递参数给资源。它通常用于向服务器传递额外的信息。例如：<code>?id=123&amp;name=example</code></p>
</li>
<li><p>Fragment（片段）：表示资源的片段标识符，用于指定资源的某个特定片段。它通常用于定位 HTML 页面中的某个锚点。例如：<code>#section1</code></p>
</li>
</ol>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>下面是几个 URL 的示例：</p>
<ol>
<li><p><code>https://www.example.com/index.html</code></p>
<ul>
<li>Scheme: <code>https</code></li>
<li>Host: <code>www.example.com</code></li>
<li>Path: <code>/index.html</code></li>
</ul>
</li>
<li><p><code>ftp://ftp.example.com/files/data.zip</code></p>
<ul>
<li>Scheme: <code>ftp</code></li>
<li>Host: <code>ftp.example.com</code></li>
<li>Path: <code>/files/data.zip</code></li>
</ul>
</li>
<li><p><code>https://www.example.com/search?q=url+explanation</code></p>
<ul>
<li>Scheme: <code>https</code></li>
<li>Host: <code>www.example.com</code></li>
<li>Path: <code>/search</code></li>
<li>Query: <code>q=url+explanation</code></li>
</ul>
</li>
<li><p><code>https://www.example.com/index.html#section2</code></p>
<ul>
<li>Scheme: <code>https</code></li>
<li>Host: <code>www.example.com</code></li>
<li>Path: <code>/index.html</code></li>
<li>Fragment: <code>#section2</code></li>
</ul>
</li>
</ol>
<p>URL 是互联网上资源的标准定位方式，它允许用户通过特定的地址来访问和处理不同类型的资源，如网页、图片、视频、文件等。</p>
<h2 id="RPC-工作方式-详解"><a href="#RPC-工作方式-详解" class="headerlink" title="RPC 工作方式 详解"></a>RPC 工作方式 详解</h2><p>RPC（Remote Procedure Call，远程过程调用）的工作方式如下：</p>
<ol>
<li><p><strong>客户端调用</strong>: 客户端应用程序调用本地的客户端存根（Client Stub），就像调用本地函数一样。客户端存根负责将函数调用转化为网络消息。</p>
</li>
<li><p><strong>消息传输</strong>: 客户端存根将封装好的消息通过网络发送到远程服务器。</p>
</li>
<li><p><strong>服务器端接收</strong>: 远程服务器接收到客户端发送的消息。</p>
</li>
<li><p><strong>服务器端存根处理</strong>: 服务器端存根（Server Stub）接收到消息后，解析出远程调用的函数、参数和其他必要信息。</p>
</li>
<li><p><strong>函数调用</strong>: 服务器端存根调用本地的服务器函数，执行请求的操作。</p>
</li>
<li><p><strong>结果返回</strong>: 服务器函数执行完毕后，将结果打包成消息发送回客户端。</p>
</li>
<li><p><strong>客户端接收</strong>: 客户端接收到服务器返回的消息。</p>
</li>
<li><p><strong>客户端存根处理</strong>: 客户端存根解析服务器返回的消息，提取结果数据。</p>
</li>
<li><p><strong>结果返回给应用程序</strong>: 客户端存根将结果返回给客户端应用程序，应用程序继续执行后续的逻辑。</p>
</li>
</ol>
<p>在这个过程中，RPC 的关键是将本地的函数调用转换为网络消息，并在远程服务器上执行相应的函数，然后将结果返回给客户端。这使得客户端和服务器之间的远程调用过程像本地函数调用一样简单和透明。</p>
<p>RPC 的实现通常包括以下几个组件：</p>
<ul>
<li><p><strong>接口定义</strong>: 定义可远程调用的函数接口、参数和返回值的数据类型。这些接口通常使用 IDL（Interface Definition Language，接口定义语言）来描述。</p>
</li>
<li><p><strong>存根生成</strong>: 根据接口定义生成客户端和服务器端的存根（Stub）代码。存根代码负责将本地函数调用转换为网络消息，并将消息发送到对应的远程服务器。</p>
</li>
<li><p><strong>序列化和反序列化</strong>: 在远程调用过程中，参数和返回值需要在网络传输前进行序列化（编码），并在接收后进行反序列化（解码）。序列化将数据转换为可传输的格式，反序列化将传输的数据还原为可处理的形式。</p>
</li>
<li><p><strong>网络传输</strong>: 使用底层的网络通信协议（如 TCP&#x2F;IP）在客户端和服务器之间进行消息传输。这通常涉及消息的封装、发送、接收和解析。</p>
</li>
<li><p><strong>错误处理</strong>: RPC 也包含错误处理机制，例如处理网络故障、超时、服务不可用等情况。当远程调用失败或出现异常时，错误信息可以被传递回客户端进行处理。</p>
</li>
</ul>
<p>需要注意的是，具体的 RPC 实现可能有所不同，不同的 RPC 框架和协议会有各自的特点和机制。这些框架提供了更高级的抽象和功能，使得分布式系统开发更加方便和高效。</p>
<p>希望这些详解能够帮助您更好地理解 RPC 的工作方式！如果您有更多问题，请随时提问。</p>
<h2 id="RPC-详解"><a href="#RPC-详解" class="headerlink" title="RPC 详解"></a>RPC 详解</h2><p>RPC（Remote Procedure Call，远程过程调用）是一种通信协议和编程模型，用于实现分布式系统中不同节点之间的远程调用。它允许在不同计算机或进程之间像调用本地函数一样调用远程函数，隐藏了底层网络通信的细节。</p>
<p>以下是关于 RPC 的详解：</p>
<ol>
<li><p><strong>远程调用</strong>: RPC 允许客户端应用程序调用位于远程服务器上的函数，就像调用本地函数一样。客户端应用程序不需要关心底层的网络通信和远程函数的具体实现细节。</p>
</li>
<li><p><strong>编程模型</strong>: RPC 提供了一种编程模型，使得开发人员能够以类似本地函数调用的方式编写分布式应用程序。开发人员可以定义接口和函数签名，并在客户端和服务器上实现相应的逻辑。</p>
</li>
<li><p><strong>接口定义</strong>: 在 RPC 中，接口定义起着关键的作用。接口定义描述了可供远程调用的函数及其参数和返回值的数据类型。接口定义通常使用 IDL（Interface Definition Language，接口定义语言）来描述，如 Protocol Buffers、IDL、Thrift 等。</p>
</li>
<li><p><strong>存根和代理</strong>: 在使用 RPC 时，需要生成客户端和服务器端的存根（Stub）和代理（Proxy）代码。存根代码负责将远程调用转换为网络消息并发送给服务器，而代理代码负责接收远程调用请求并将其转发给本地函数。</p>
</li>
<li><p><strong>序列化和反序列化</strong>: 在进行远程调用时，参数和返回值需要进行序列化和反序列化。序列化将数据转换为可以在网络上传输的格式，而反序列化将接收到的数据还原为可处理的形式。</p>
</li>
<li><p><strong>网络传输</strong>: RPC 使用底层的网络通信协议（如 TCP&#x2F;IP）来实现远程调用的传输。客户端通过网络发送请求消息给服务器，服务器接收请求消息并执行相应的函数，然后将结果返回给客户端。</p>
</li>
<li><p><strong>错误处理</strong>: RPC 也涉及错误处理机制。当远程调用失败或出现异常时，RPC 会返回适当的错误码或异常信息给客户端，以便进行错误处理和恢复。</p>
</li>
</ol>
<p>RPC 在分布式系统中广泛应用，用于实现不同节点之间的协作和通信。它提供了一种方便和透明的方式来调用远程函数，使得分布式应用程序开发更加简化和高效。</p>
<p>常见的 RPC 框架包括 gRPC、Apache Thrift、JSON-RPC、XML-RPC 等。这些框架提供了不同的功能和特性，可以根据具体需求选择合适的 RPC 框架。</p>
<p>希望这些详解能帮助您更好地理解 RPC！如果您有更多问题，请随时提问。</p>
<h2 id="RPC-是什么"><a href="#RPC-是什么" class="headerlink" title="RPC 是什么"></a>RPC 是什么</h2><p>RPC（Remote Procedure Call，远程过程调用）是一种通信协议和编程模型，用于实现分布式系统中不同节点之间的远程调用。它使得在不同计算机或进程之间能够像调用本地函数一样调用远程函数，隐藏了底层网络通信的细节。</p>
<p>以下是关于 RPC 的一些详解：</p>
<ol>
<li><p><strong>远程调用</strong>：RPC 允许应用程序在不同的计算机或进程之间进行远程调用。客户端应用程序可以像调用本地函数一样调用远程服务器上的函数，而无需了解底层的网络通信细节。</p>
</li>
<li><p><strong>编程模型</strong>：RPC 提供了一种编程模型，使得开发人员能够以类似本地函数调用的方式编写分布式应用程序。开发人员可以定义接口和函数签名，并在客户端和服务器上实现相应的逻辑。</p>
</li>
<li><p><strong>通信协议</strong>：RPC 使用特定的通信协议来实现远程调用。常见的 RPC 协议包括 gRPC、Apache Thrift、JSON-RPC、XML-RPC 等。这些协议定义了消息的格式、序列化和网络传输的方式。</p>
</li>
<li><p><strong>序列化</strong>：在 RPC 中，参数和返回值需要在客户端和服务器之间进行序列化和反序列化。序列化是将数据转换为可传输的格式，反序列化是将传输的数据还原为可处理的形式。</p>
</li>
<li><p><strong>网络通信</strong>：RPC 通过底层的网络通信实现远程调用。客户端通过网络发送请求消息给服务器，服务器接收请求消息并执行相应的函数，然后将结果返回给客户端。</p>
</li>
<li><p><strong>跨语言支持</strong>：RPC 可以支持多种编程语言之间的远程调用。通过使用通用的 RPC 协议和序列化机制，不同语言的应用程序可以相互通信和调用。</p>
</li>
<li><p><strong>分布式系统</strong>：RPC 在分布式系统中广泛应用，用于实现不同节点之间的协作和通信。它可以用于构建大规模、高可靠性的分布式应用程序架构。</p>
</li>
</ol>
<p>RPC 是一种常见的分布式系统通信模型，它简化了分布式应用程序的开发过程，使得不同节点之间的远程调用更加方便和透明。</p>
<p>希望这些详解对 RPC 有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="TLS-详解"><a href="#TLS-详解" class="headerlink" title="TLS 详解"></a>TLS 详解</h2><p>TLS（Transport Layer Security）是一种用于保护网络通信安全性的加密协议。它建立在传输层协议（如 TCP）之上，用于在客户端和服务器之间创建安全的通信通道。以下是关于 TLS 的详解：</p>
<ol>
<li><p><strong>安全通信</strong>：TLS 的主要目标是确保通信的机密性、完整性和身份验证。它使用加密算法对数据进行加密，以防止未经授权的访问者获取敏感信息。同时，TLS 还使用消息摘要和数字签名等技术来保证数据的完整性，防止数据被篡改。</p>
</li>
<li><p><strong>握手过程</strong>：TLS 使用握手过程来建立安全连接。在握手过程中，客户端和服务器之间进行协商，包括选择加密算法、交换密钥、进行身份验证等。握手过程涉及多个步骤，例如协议版本协商、证书交换、密钥协商和密钥确认等。</p>
</li>
<li><p><strong>证书和公钥基础设施（PKI）</strong>：TLS 使用数字证书来实现身份验证和密钥交换。数字证书由受信任的证书颁发机构（CA）签发，包含服务器的公钥和其他身份信息。客户端可以验证服务器证书的有效性，以确保与合法服务器建立连接。</p>
</li>
<li><p><strong>加密算法</strong>：TLS 支持多种加密算法，用于保护通信数据的机密性。常见的加密算法包括对称加密算法（如AES）、非对称加密算法（如RSA）和哈希算法（如SHA）。在握手过程中，客户端和服务器协商选择适合的加密算法和密钥长度。</p>
</li>
<li><p><strong>版本和演进</strong>：TLS 有多个版本，包括 TLS 1.0、TLS 1.1、TLS 1.2 和 TLS 1.3。每个版本都有不同的功能和安全性。TLS 1.3 是最新的版本，引入了许多改进和安全增强，提供更快的握手速度和更强的密码套件。</p>
</li>
<li><p><strong>应用场景</strong>：TLS 广泛应用于各种安全通信场景，如网上银行、电子商务、电子邮件、VPN（虚拟私人网络）等。它为通信双方提供了保护数据隐私和确保通信安全的机制，防止数据泄露、篡改和中间人攻击。</p>
</li>
<li><p><strong>HTTPS</strong>：TLS 在 Web 安全中起着重要的作用，它与 HTTP 协议结合形成 HTTPS（HTTP Secure）。HTTPS 使用 TLS 加密和身份验证来保护 Web 浏览器和服务器之间的数据传输，确保网站的安全性和用户的隐私。</p>
</li>
</ol>
<p>TLS 是一种重要的安全协议，被广泛应用于保护网络通信的安全性。它提供了加密、身份验证和数据完整性保护的功能，为通信双方提供了安全可靠的通信通道。</p>
<p>希望这些详解对 TLS 有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="TLS-是什么"><a href="#TLS-是什么" class="headerlink" title="TLS 是什么"></a>TLS 是什么</h2><p>TLS（Transport Layer Security）是一种用于保护网络通信安全性的加密协议。它是 SSL（Secure Sockets Layer）协议的继任者，并被广泛应用于互联网上的各种安全通信场景。</p>
<p>以下是关于 TLS 的一些详解：</p>
<ol>
<li><p><strong>安全通信</strong>：TLS 用于在网络通信中实现安全和私密的数据传输。它通过加密通信内容，确保数据在传输过程中不被窃听、篡改或伪造。</p>
</li>
<li><p><strong>协议层</strong>：TLS 位于网络通信的传输层之上，与传输层协议（如 TCP）一起工作，为上层应用提供安全的通信通道。</p>
</li>
<li><p><strong>加密和身份验证</strong>：TLS 使用加密算法对通信内容进行加密，确保数据的保密性。同时，TLS 还提供身份验证机制，用于验证通信双方的身份，并防止中间人攻击。</p>
</li>
<li><p><strong>证书和密钥交换</strong>：TLS 使用数字证书来验证服务器的身份，并协商加密密钥。证书由受信任的证书颁发机构（CA）签发，包含服务器公钥和相关信息。</p>
</li>
<li><p><strong>握手过程</strong>：TLS 通过握手过程建立安全连接。在握手过程中，客户端和服务器之间进行协议版本协商、身份验证、密钥交换和协商加密算法等操作，以建立共享密钥和参数。</p>
</li>
<li><p><strong>支持的应用协议</strong>：TLS 不仅可以保护基于 TCP 的应用层协议（如 HTTP、SMTP、IMAP），还可以保护其他传输层协议，如 UDP 的 DTLS（Datagram Transport Layer Security）。</p>
</li>
<li><p><strong>版本和演变</strong>：TLS 有多个版本，包括 TLS 1.0、TLS 1.1、TLS 1.2 和 TLS 1.3。每个版本都有不同的功能和安全性，随着时间的推移，TLS 协议不断演进以修复漏洞并提供更好的安全性。</p>
</li>
</ol>
<p>TLS 在互联网上广泛应用于保护敏感数据的传输，如网上银行、电子商务、电子邮件等。它为通信双方提供了一种安全、私密和可靠的通信机制，防止数据泄露和篡改，保护用户隐私和信息安全。</p>
<p>希望这些详解对 TLS 有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="SNTP-server-详解"><a href="#SNTP-server-详解" class="headerlink" title="SNTP server 详解"></a>SNTP server 详解</h2><p>SNTP（Simple Network Time Protocol）服务器是一种用于提供时间同步服务的网络服务器。它基于网络通信协议，允许计算机和其他网络设备通过网络获取准确的时间信息。</p>
<p>以下是 SNTP 服务器的一些详解：</p>
<ol>
<li><p><strong>时间同步服务</strong>：SNTP 服务器的主要功能是提供时间同步服务。它接收来自客户端的时间同步请求，并返回准确的时间戳作为响应。客户端可以通过与 SNTP 服务器通信，获取服务器上的当前时间，并将本地时间与服务器时间进行校准，以确保计算机和网络设备的时间与参考时间保持一致。</p>
</li>
<li><p><strong>网络时间协议</strong>：SNTP 服务器基于网络时间协议（NTP）标准或其简化版本。NTP 是一种用于在计算机网络中同步时间的协议，而SNTP 则是 NTP 的简化版本，去除了一些复杂的功能和算法，主要用于提供基本的时间同步服务。</p>
</li>
<li><p><strong>时间源</strong>：SNTP 服务器通常连接到一个时间源，以获取准确的时间信息。时间源可以是国家时间标准机构（如NIST）的服务器，也可以是互联网上的其他可靠时间服务器。服务器通过与时间源进行通信，获取准确的时间，并将其提供给客户端。</p>
</li>
<li><p><strong>时间精度</strong>：SNTP 服务器的时间精度取决于所使用的时间源和服务器的硬件和软件配置。一般情况下，SNTP 服务器可以提供较高的时间精度，通常在毫秒或亚毫秒级别。</p>
</li>
<li><p><strong>应用场景</strong>：SNTP 服务器被广泛应用于需要时间同步的各种网络设备和系统中。它们包括计算机网络、服务器、路由器、交换机、工业自动化系统等。这些设备和系统需要保持时间一致性，以确保协调的操作、事件记录和一致的时间戳。</p>
</li>
<li><p><strong>配置和管理</strong>：SNTP 服务器的配置和管理可以通过设置服务器软件或设备上的相关参数来完成。可以指定时间源、同步频率、服务器身份验证、时间校准方式等。</p>
</li>
</ol>
<p>需要注意的是，SNTP 服务器是一种基本的时间同步服务，如果需要更高精度和更复杂的时间同步功能，可以考虑使用更强大的 NTP 服务器。</p>
<p>希望这些详解对 SNTP 服务器有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="SNTP-server-是什么"><a href="#SNTP-server-是什么" class="headerlink" title="SNTP server 是什么"></a>SNTP server 是什么</h2><p>SNTP（Simple Network Time Protocol）服务器是一种提供时间同步服务的网络服务器。SNTP 是一种基于网络的时间同步协议，它允许计算机和其他网络设备通过网络获取准确的时间信息。</p>
<p>SNTP 服务器的主要功能是响应客户端的时间同步请求，并向客户端提供准确的时间戳。客户端可以通过与 SNTP 服务器进行通信，获取服务器上的当前时间，并将本地时间与服务器时间进行校准，以确保计算机和网络设备的时间与参考时间保持一致。</p>
<p>SNTP 服务器通常连接到一个时间源（如国家时间标准机构或互联网上的其他可靠时间服务器），以获取准确的时间信息。服务器可以使用各种时间同步方法，如网络协议（如NTP、SNTP）、GPS（全球定位系统）或其他时钟源，来确保提供精确的时间。</p>
<p>SNTP 服务器的应用场景包括网络中的各种设备和系统，例如计算机网络、服务器、路由器、交换机、工业自动化系统等，它们需要时间同步以进行协调的操作和事件记录。</p>
<p>需要注意的是，SNTP 是 NTP（Network Time Protocol）的简化版本，去除了一些复杂的功能和算法，主要用于提供基本的时间同步服务。如果需要更高精度和更复杂的时间同步功能，可以考虑使用 NTP 协议。</p>
<p>希望对 SNTP 服务器有了更好的理解！如果您有更多问题，请随时提问。</p>
<h2 id="http-info-cern-ch"><a href="#http-info-cern-ch" class="headerlink" title="http://info.cern.ch/"></a><a target="_blank" rel="noopener" href="http://info.cern.ch/">http://info.cern.ch/</a></h2><p><a target="_blank" rel="noopener" href="http://info.cern.ch/">http://info.cern.ch/</a> 是一个网站，它被认为是世界上第一个公开的网站。它由欧洲核子研究组织（CERN）的计算机科学家蒂姆·伯纳斯-李（Tim Berners-Lee）于1991年创建。这个网站最初是为了分享关于CERN项目的信息和文档，以及介绍万维网（World Wide Web）的概念和原理。</p>
<p>蒂姆·伯纳斯-李是万维网的发明者之一，他在CERN工作期间创建了第一个网页浏览器和服务器，并且将这些技术开放给了公众。这个网站的主页上展示了一些简单的超链接，以及一些关于万维网的介绍性文本。</p>
<p>虽然这个网站的内容相对简单，但它标志着万维网的起源，并且对互联网的发展产生了深远的影响。如今，CERN的网站已经发展成为一个包含大量科学研究和实验信息的综合性门户网站，而<a target="_blank" rel="noopener" href="http://info.cern.ch/%E5%88%99%E4%BD%9C%E4%B8%BA%E4%B8%87%E7%BB%B4%E7%BD%91%E7%9A%84%E5%8E%86%E5%8F%B2%E9%81%97%E8%BF%B9%E8%A2%AB%E4%BF%9D%E7%95%99%E4%B8%8B%E6%9D%A5%EF%BC%8C%E4%BB%A5%E7%BA%AA%E5%BF%B5%E4%B8%87%E7%BB%B4%E7%BD%91%E7%9A%84%E8%AF%9E%E7%94%9F%E3%80%82">http://info.cern.ch/则作为万维网的历史遗迹被保留下来，以纪念万维网的诞生。</a></p>
<h2 id="TCP-服务-和-HTTP-服务"><a href="#TCP-服务-和-HTTP-服务" class="headerlink" title="TCP 服务 和 HTTP 服务"></a>TCP 服务 和 HTTP 服务</h2><p>TCP服务和HTTP服务都是基于TCP协议的网络服务，但它们在协议和功能上有一些区别。</p>
<p><strong>TCP服务</strong>：</p>
<ul>
<li>TCP（传输控制协议）是一种面向连接的协议，用于在网络上可靠地传输数据。</li>
<li>TCP服务通过在服务器和客户端之间建立持久的双向通信连接来传输数据。</li>
<li>TCP服务通常基于自定义的应用层协议，可以通过定义特定的数据格式和通信规则来进行数据交换。</li>
<li>TCP服务可以是自定义的、专用的服务，用于在应用程序之间进行数据传输和通信。</li>
</ul>
<p><strong>HTTP服务</strong>：</p>
<ul>
<li>HTTP（超文本传输协议）是一种应用层协议，用于在 Web 上传输超文本文档和其他资源。</li>
<li>HTTP服务使用TCP作为传输协议，通过建立连接并使用HTTP协议进行通信。</li>
<li>HTTP服务使用请求-响应模型，客户端发送HTTP请求，服务器返回HTTP响应。</li>
<li>HTTP服务遵循特定的语法和规范，定义了请求方法（GET、POST等）、头部字段（如Content-Type、User-Agent等）和响应状态码（如200 OK、404 Not Found等）等。</li>
</ul>
<p>总结：<br>TCP服务是一种通用的、自定义的数据传输服务，而HTTP服务是一种基于TCP的特定协议，用于在Web上进行文档和资源的传输。TCP服务可以用于构建各种自定义的应用程序通信，而HTTP服务则专注于Web应用程序的数据交换和传输。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">线性代数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>线性代数相关笔记</li>
</ul>
<h2 id="线性代数是什么"><a href="#线性代数是什么" class="headerlink" title="线性代数是什么"></a>线性代数是什么</h2><p>线性代数是数学的一个分支，主要研究向量空间和线性映射的代数结构。它涉及向量、矩阵、线性方程组、线性变换等概念，并在各种学科和应用领域中有广泛的应用。以下是线性代数的一些主要概念：</p>
<ol>
<li><p><strong>向量（Vector）：</strong> 向量是有大小和方向的量，常用箭头表示。在线性代数中，向量通常表示为一列有序数，例如 ( \mathbf{v} &#x3D; \begin{bmatrix} v_1 \ v_2 \ \vdots \ v_n \end{bmatrix} )。</p>
</li>
<li><p><strong>向量空间（Vector Space）：</strong> 向量空间是一组满足一定条件的向量的集合，其中定义了向量的加法和数乘运算，并满足一些基本性质。</p>
</li>
<li><p><strong>矩阵（Matrix）：</strong> 矩阵是一个二维的数组，由数值组成。在线性代数中，矩阵通常用于表示线性变换，解线性方程组等。</p>
</li>
<li><p><strong>线性变换（Linear Transformation）：</strong> 线性变换是一个将一个向量空间映射到另一个向量空间的函数，满足线性性质。线性变换可以用矩阵表示。</p>
</li>
<li><p><strong>行列式（Determinant）：</strong> 行列式是一个与方阵相关的数值，用于描述线性变换对体积伸缩的影响。它在计算矩阵的逆、解线性方程组等方面很重要。</p>
</li>
<li><p><strong>特征值与特征向量（Eigenvalues and Eigenvectors）：</strong> 对于一个线性变换，特征值描述了变换的伸缩因子，而特征向量则是在变换下保持方向不变的向量。</p>
</li>
<li><p><strong>内积空间和外积空间（Inner Product Space and Outer Product Space）：</strong> 内积空间定义了向量之间的内积（点乘）运算，而外积空间定义了向量之间的外积运算。</p>
</li>
</ol>
<p>线性代数在科学、工程、计算机科学等多个领域中都具有重要作用。它为许多数学问题的建模和求解提供了强大的工具，同时也是其他高阶数学分支的基础。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Network/2024-05-22-http_1_%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Network/2024-05-22-http_1_%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">http_1_协议基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>HTTP协议理论基础知识</li>
</ul>
<h2 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h2><ul>
<li><p>分块传输编码(Chunked transfer encoding)是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP&#x2F;1.1）中提供。</p>
</li>
<li><p>通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度。数据的长度很重要，因为客户端需要知道哪里是应答消息的结束，以及后续应答消息的开始。然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。通常数据块的大小是一致的，但也不总是这种情况。</p>
</li>
<li><p>分块传输编码的原理</p>
<ul>
<li>HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的</li>
<li>分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。</li>
<li>HTTP服务器有时使用压缩 （gzip或deflate）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。</li>
</ul>
</li>
<li><p>分块传输编码的格式</p>
<ul>
<li>如果一个HTTP消息（包括客户端发送的请求消息或服务器返回的应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束</li>
<li>每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个CRLF （回车及换行），然后是数据本身，最后块CRLF结束。在一些实现中，块大小和CRLF之间填充有白空格（0x20）。</li>
<li>最后一块是单行，由块大小（0），一些可选的填充白空格，以及CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段</li>
<li>消息最后以CRLF结尾</li>
</ul>
</li>
</ul>
<h2 id="HTTP-Content-Type"><a href="#HTTP-Content-Type" class="headerlink" title="HTTP Content-Type"></a>HTTP Content-Type</h2><ul>
<li><p>Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。</p>
</li>
<li><p>Content-Type 标头告诉客户端实际返回的内容的内容类型。</p>
</li>
<li><p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Type: multipart/form-data; boundary=something</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见的媒体格式类型如下：</p>
<ul>
<li>text&#x2F;html ： HTML格式</li>
<li>text&#x2F;plain ：纯文本格式</li>
<li>text&#x2F;xml ： XML格式</li>
<li>image&#x2F;gif ：gif图片格式</li>
<li>image&#x2F;jpeg ：jpg图片格式</li>
<li>image&#x2F;png：png图片格式</li>
</ul>
</li>
<li><p>以application开头的媒体格式类型：</p>
<ul>
<li>application&#x2F;xhtml+xml ：XHTML格式</li>
<li>application&#x2F;xml： XML数据格式</li>
<li>application&#x2F;atom+xml ：Atom XML聚合格式</li>
<li>application&#x2F;json： JSON数据格式</li>
<li>application&#x2F;pdf：pdf格式</li>
<li>application&#x2F;msword ： Word文档格式</li>
<li>application&#x2F;octet-stream ： 二进制流数据（如常见的文件下载）</li>
<li>application&#x2F;x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据的格式）</li>
</ul>
</li>
<li><p>另外一种常见的媒体格式是上传文件之时使用的：</p>
</li>
<li><p>multipart&#x2F;form-data ： 需要在表单中进行文件上传时，就需要使用该格式</p>
</li>
</ul>
<h2 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h2><p>HTTP 请求报文由请求行（Request Line）、请求头部（Headers）和请求主体（Body）三部分组成。下面是 HTTP 请求报文的一般格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;请求方法&gt; &lt;请求目标&gt; &lt;协议版本&gt;</span><br><span class="line">&lt;请求头部字段&gt;: &lt;值&gt;</span><br><span class="line">&lt;请求头部字段&gt;: &lt;值&gt;</span><br><span class="line">...</span><br><span class="line">&lt;空行&gt;</span><br><span class="line">&lt;请求主体&gt;</span><br></pre></td></tr></table></figure>

<p>其中，各部分的含义如下：</p>
<ol>
<li>请求方法（Request Method）：表示客户端请求的动作类型，常见的方法有 GET、POST、PUT、DELETE 等。</li>
<li>请求目标（Request Target）：指定请求的目标资源的位置，可以是一个 URL 或绝对路径。</li>
<li>协议版本（Protocol Version）：指定所使用的 HTTP 协议的版本，通常是 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</li>
<li>请求头部字段（Headers）：包含了关于请求的附加信息，每个字段都以字段名和对应的值组成，每个字段占据一行。</li>
<li>空行：表示请求头部结束的标志，用于与请求主体进行分隔。</li>
<li>请求主体（Body）：可选的，包含了实际要发送给服务器的数据，比如表单数据或上传的文件内容。</li>
</ol>
<p>以下是一个示例 HTTP 请求报文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /api/users HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 48</span><br><span class="line"></span><br><span class="line">&#123;&quot;username&quot;: &quot;john_doe&quot;, &quot;password&quot;: &quot;secretpassword&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中：</p>
<ul>
<li>请求方法为 <code>POST</code>，请求目标为 <code>/api/users</code>，协议版本为 <code>HTTP/1.1</code>。</li>
<li>请求头部包含了 <code>Host</code>、<code>Content-Type</code> 和 <code>Content-Length</code> 等字段，用于指定主机名、请求体的类型和长度等信息。</li>
<li>空行表示请求头部结束。</li>
<li>请求主体为一个 JSON 格式的字符串，包含了用户名和密码的数据。</li>
</ul>
<p>请注意，请求报文中的每一行都应该以回车符（\r）和换行符（\n）作为行结束符号。请求头部字段和值之间使用冒号和空格进行分隔（例如 <code>Content-Type: application/json</code>）。</p>
<p>以上是 HTTP 请求报文的基本结构，实际的请求报文内容和格式会根据具体的请求需求和要求而有所不同。</p>
<hr>
<h2 id="HTTP-协议文档"><a href="#HTTP-协议文档" class="headerlink" title="HTTP 协议文档"></a>HTTP 协议文档</h2><p>HTTP协议的官方文档是由互联网工程任务组（IETF）发布的一系列文档，主要包括以下两个规范：</p>
<ol>
<li><p>HTTP&#x2F;1.1规范：HTTP&#x2F;1.1是当前广泛使用的HTTP协议版本。其规范文档定义了HTTP&#x2F;1.1协议的语义、语法、请求方法、状态码、首部字段、缓存机制等各个方面的内容。HTTP&#x2F;1.1的规范文档由RFC 2616定义。</p>
<p>可以通过以下链接访问HTTP&#x2F;1.1的规范文档：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616">RFC 2616 - Hypertext Transfer Protocol – HTTP&#x2F;1.1</a></li>
</ul>
</li>
<li><p>HTTP&#x2F;2规范：HTTP&#x2F;2是HTTP协议的下一代版本，旨在提供更高的性能和效率。它引入了二进制协议、多路复用、头部压缩、服务器推送等新特性。HTTP&#x2F;2的规范文档由RFC 7540定义。</p>
<p>可以通过以下链接访问HTTP&#x2F;2的规范文档：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7540">RFC 7540 - Hypertext Transfer Protocol Version 2 (HTTP&#x2F;2)</a></li>
</ul>
</li>
</ol>
<p>除了上述主要的HTTP协议规范文档外，IETF还发布了其他与HTTP相关的文档，包括扩展协议、安全性、代理、缓存等方面的规范和建议。</p>
<p>可以通过IETF的官方网站访问这些文档的在线版本：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/wg/httpbis/documents/">IETF - Hypertext Transfer Protocol (HTTP) Working Group</a></li>
</ul>
<p>注意：HTTP&#x2F;1.1的规范文档（RFC 2616）发布于1999年，并于2014年被废弃。后续对HTTP&#x2F;1.1的修订和更新工作由HTTPbis工作组负责，并将最新的规范文档发布为一系列独立的RFC文档。因此，最新的HTTP&#x2F;1.1规范文档应该参考HTTPbis工作组发布的相关文档。</p>
<hr>
<h2 id="HTTP-表单是什么"><a href="#HTTP-表单是什么" class="headerlink" title="HTTP 表单是什么"></a>HTTP 表单是什么</h2><p>HTTP表单（HTTP form）是一种用于在Web应用程序中收集和提交用户数据的机制。它是基于HTTP协议的一种数据传输方式，通过在Web页面上展示给用户一组输入字段（例如文本框、复选框、下拉列表等），用户可以在这些字段中输入数据，并将数据提交到服务器进行处理。</p>
<p>HTTP表单常用于实现用户注册、登录、搜索、提交评论等交互性操作。用户在表单中输入数据后，通过点击提交按钮，表单数据将被封装为HTTP请求发送给服务器。服务器接收到请求后，可以解析表单数据，并根据需要进行相应的处理，例如保存数据到数据库、执行搜索操作、生成动态内容等。</p>
<p>HTTP表单通过使用HTML（Hypertext Markup Language）和一些特定的表单元素来定义和呈现表单。HTML表单元素包括<code>&lt;form&gt;</code>标签、<code>&lt;input&gt;</code>标签、<code>&lt;select&gt;</code>标签、<code>&lt;textarea&gt;</code>标签等，它们用于定义表单的结构、各种输入字段以及提交按钮。</p>
<p>在提交表单时，可以使用不同的HTTP请求方法，常见的有GET和POST方法。GET方法将表单数据附加在URL的查询字符串中，而POST方法将表单数据包含在请求的主体中。这取决于表单的性质和数据的敏感性。</p>
<p>在服务器端，可以使用不同的技术（如PHP、Python、Java等）来处理接收到的表单数据。这些技术提供了解析和处理表单数据的函数、类或库，使开发人员能够轻松地处理表单提交的数据，并进行相应的业务逻辑操作。</p>
<p>总结起来，HTTP表单是一种用于在Web应用程序中收集和提交用户数据的机制，它利用HTML表单元素定义和呈现表单，通过HTTP协议将用户输入的数据发送到服务器进行处理。</p>
<hr>
<h2 id="HTTP协议-表单数据"><a href="#HTTP协议-表单数据" class="headerlink" title="HTTP协议 表单数据"></a>HTTP协议 表单数据</h2><p>HTTP 协议中的表单数据是通过 POST 请求或 GET 请求来传输的，具体的格式和处理方式如下：</p>
<ol>
<li><p>GET 请求传输表单数据：</p>
<ul>
<li>表单数据会被附加在 URL 的查询字符串中，即通过 URL 参数传递。</li>
<li>数据以键值对的形式出现，使用<code>key=value</code>的格式。</li>
<li>多个键值对之间使用<code>&amp;</code>符号进行分隔。</li>
</ul>
</li>
<li><p>POST 请求传输表单数据：</p>
<ul>
<li>表单数据会被放置在请求体中，并通过 Content-Type 头部指定数据的编码方式，常见的编码方式有 application&#x2F;x-www-form-urlencoded 和 multipart&#x2F;form-data。</li>
<li>application&#x2F;x-www-form-urlencoded 编码方式：<ul>
<li>表单数据以键值对的形式出现，使用<code>key=value</code>的格式。</li>
<li>多个键值对之间使用<code>&amp;</code>符号进行分隔。</li>
</ul>
</li>
<li>multipart&#x2F;form-data 编码方式：<ul>
<li>表单数据会以多部分的形式进行传输。</li>
<li>每个部分都有自己的头部信息，包括 Content-Disposition 和 Content-Type。</li>
<li>表单字段会出现在各自的部分中，以字段名作为标识。</li>
<li>文件上传时，文件数据会以二进制形式出现在对应的部分中。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>对于服务器端的处理，常见的 Web 框架会提供相应的解析和处理表单数据的功能，开发者可以根据框架的文档和要求来编写处理表单数据的代码。</p>
<p>需要注意的是，HTTP 协议的表单数据传输并不加密，因此在传输敏感信息时应使用安全的 HTTPS 协议来保护数据的安全性。</p>
<h2 id="application-x-www-form-urlencoded-详解"><a href="#application-x-www-form-urlencoded-详解" class="headerlink" title="application&#x2F;x-www-form-urlencoded 详解"></a>application&#x2F;x-www-form-urlencoded 详解</h2><p><code>application/x-www-form-urlencoded</code>是一种常见的MIME类型，用于在HTTP请求中传输表单数据。它是一种URL编码的数据格式，适用于通过HTTP POST请求将表单数据发送到服务器。</p>
<p>详细解释<code>application/x-www-form-urlencoded</code>的含义如下：</p>
<ol>
<li><p>数据格式：<code>application/x-www-form-urlencoded</code>表示表单数据以URL编码的形式进行传输。它使用特定的编码规则将表单字段和值进行编码，并使用”&amp;”符号分隔字段。例如，假设有一个表单字段<code>name</code>的值为<code>John Doe</code>，编码后的数据格式将是<code>name=John%20Doe</code>。</p>
</li>
<li><p>字符编码：<code>application/x-www-form-urlencoded</code>使用URL编码对特殊字符进行转义。这样可以确保数据能够在HTTP请求中正确传输，不会被解析为URL的特殊字符或者参数分隔符。</p>
</li>
<li><p>请求方法：<code>application/x-www-form-urlencoded</code>通常与HTTP POST请求方法一起使用。表单数据会被封装在请求的主体部分，并以<code>key=value</code>的形式进行传输。服务器端可以根据具体的编程语言或框架，解析这些键值对数据并进行处理。</p>
</li>
<li><p>Content-Type头部：在HTTP请求中，<code>Content-Type</code>头部用于指定请求主体的媒体类型。当使用<code>application/x-www-form-urlencoded</code>传输表单数据时，可以设置<code>Content-Type</code>头部为<code>application/x-www-form-urlencoded</code>来标识数据格式。</p>
</li>
</ol>
<p>使用示例：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/submit-form</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">name</span>=John%<span class="number">20</span>Doe&amp;email=johndoe%<span class="number">40</span>example.com&amp;message=Hello%<span class="number">20</span>World</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们通过HTTP POST请求将表单数据发送到<code>example.com/submit-form</code>路径。请求头部指定了<code>Content-Type: application/x-www-form-urlencoded</code>，表示表单数据以<code>application/x-www-form-urlencoded</code>格式进行传输。请求主体部分包含了编码后的表单数据。</p>
<p>总结：<code>application/x-www-form-urlencoded</code>是一种URL编码的数据格式，常用于HTTP POST请求中传输表单数据。它使用特定的编码规则对字段和值进行编码，并以<code>key=value</code>的形式传输数据。服务器端可以根据Content-Type头部为<code>application/x-www-form-urlencoded</code>来解析和处理这些数据。</p>
<hr>
<h2 id="HTTP协议-响应报文"><a href="#HTTP协议-响应报文" class="headerlink" title="HTTP协议 响应报文"></a>HTTP协议 响应报文</h2><p>HTTP协议中的响应报文包含多个字段，每个字段都有特定的作用和含义。以下是HTTP响应报文中常见的字段及其详细解释：</p>
<ol>
<li><p>状态行（Status Line）：状态行包含了HTTP协议的版本号、状态码和状态消息。它的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>其中，<code>HTTP/1.1</code>表示使用的HTTP版本号，<code>200</code>是状态码，<code>OK</code>是状态消息。</p>
</li>
<li><p>响应头（Response Headers）：响应头包含了关于响应的附加信息。它的格式为<code>字段名: 值</code>，每个字段占据一行。常见的响应头字段包括：</p>
<ul>
<li><code>Content-Type</code>：指定响应体的媒体类型，例如<code>text/html</code>表示HTML文档。</li>
<li><code>Content-Length</code>：指定响应体的长度，以字节为单位。</li>
<li><code>Date</code>：指定响应发送的日期和时间。</li>
<li><code>Server</code>：指定服务器的软件名称和版本号。</li>
<li><code>Set-Cookie</code>：用于在客户端存储会话信息的HTTP Cookie。</li>
</ul>
</li>
<li><p>空行（Blank Line）：空行用于分隔响应头和响应体。</p>
</li>
<li><p>响应体（Response Body）：响应体包含了实际的响应数据，例如网页的HTML内容或者文件的内容。</p>
</li>
</ol>
<p>需要注意的是，除了以上常见的字段之外，HTTP响应报文还可以包含其他自定义的字段，具体的字段内容和含义可以根据应用程序和服务器的需求进行定义和解析。</p>
<hr>
<h2 id="HTTP-Cache-Control"><a href="#HTTP-Cache-Control" class="headerlink" title="HTTP Cache-Control"></a>HTTP Cache-Control</h2><p>HTTP的Cache-Control字段用于控制缓存的行为，指示缓存如何处理响应以及如何在将来的请求中使用缓存。Cache-Control字段可以在HTTP请求头和响应头中使用。</p>
<p>在HTTP请求头中，Cache-Control字段用于指示客户端对服务器的请求希望如何进行缓存。常见的指令包括：</p>
<ul>
<li><code>no-cache</code>：表示客户端要求服务器每次都提供最新的响应，不使用缓存副本。</li>
<li><code>no-store</code>：表示客户端和中间缓存都不应该存储请求或响应的任何副本。</li>
<li><code>max-age=&lt;seconds&gt;</code>：表示响应的有效时间，以秒为单位。客户端可以在这个时间内使用缓存副本而不向服务器发起新的请求。</li>
<li><code>min-fresh=&lt;seconds&gt;</code>：表示客户端希望在指定的时间内获取新的响应，而不使用缓存。如果缓存的响应的新鲜度低于指定的时间，客户端将向服务器发起新的请求。</li>
<li><code>max-stale[=&lt;seconds&gt;]</code>：表示客户端允许使用过期的缓存副本，即使超过了缓存的有效时间。可选的秒数表示允许的最大过期时间。</li>
<li><code>only-if-cached</code>：表示客户端只接受缓存的响应，不向服务器发起新的请求。</li>
</ul>
<p>在HTTP响应头中，Cache-Control字段用于指示缓存如何处理响应。常见的指令包括：</p>
<ul>
<li><code>public</code>：表示响应可以被任何缓存（包括客户端和中间缓存）缓存。</li>
<li><code>private</code>：表示响应只能被客户端缓存，中间缓存不能缓存该响应。</li>
<li><code>no-cache</code>：表示响应可以被缓存，但必须先与服务器确认其有效性。</li>
<li><code>no-store</code>：表示响应不能被缓存，客户端和中间缓存都不应该存储该响应。</li>
<li><code>max-age=&lt;seconds&gt;</code>：表示响应的有效时间，以秒为单位。</li>
<li><code>s-maxage=&lt;seconds&gt;</code>：表示响应在共享缓存（如代理服务器）中的有效时间，以秒为单位。</li>
</ul>
<p>以上是Cache-Control字段的一些常见指令和用法，可以根据具体的需求和情况进行灵活设置，以实现更好的缓存控制和性能优化。</p>
<hr>
<h2 id="HTTP-Cache-control-must-revalidate"><a href="#HTTP-Cache-control-must-revalidate" class="headerlink" title="HTTP Cache-control must-revalidate"></a>HTTP Cache-control must-revalidate</h2><p>HTTP头字段”Cache-Control: must-revalidate”用于指示客户端在使用缓存响应之前必须与服务器进行重新验证，即使缓存的响应具有新鲜的过期时间。</p>
<p>当响应中包含”Cache-Control: must-revalidate”指令时，意味着缓存的响应在未经服务器重新验证之前不应被视为有效。客户端必须向服务器发送一个条件请求（通常是带有”If-Modified-Since”或”If-None-Match”头字段），以检查缓存的响应是否仍然有效。</p>
<p>如果服务器以304 Not Modified状态码响应，表示缓存的响应仍然有效，客户端可以使用缓存副本。然而，如果服务器响应了新版本的资源或不同的状态码，客户端需要相应地更新其缓存。</p>
<p>“Cache-Control: must-revalidate”指令在确保缓存的响应是最新且准确的情况下非常有用。通过要求重新验证，它有助于保持客户端和服务器之间的数据一致性。</p>
<p>以下是带有”Cache-Control: must-revalidate”指令的HTTP响应头的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: must-revalidate</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br></pre></td></tr></table></figure>

<p>在上述示例中，”Cache-Control: must-revalidate”头字段指示客户端在使用缓存响应之前必须重新验证。</p>
<p>需要注意的是，”must-revalidate”只是Cache-Control头字段的一个指令，还可以有其他指令，如”max-age”或”no-cache”等，用于修改缓存行为。这些指令的组合可以提供对特定资源的缓存处理进行精细控制。</p>
<hr>
<h2 id="HTTP-Cache-control-max-age"><a href="#HTTP-Cache-control-max-age" class="headerlink" title="HTTP Cache-control max-age"></a>HTTP Cache-control max-age</h2><p>HTTP头字段”Cache-Control: max-age”用于指定缓存的响应在被认为过期之前的最长时间（以秒为单位）。</p>
<p>“max-age”指令用于定义响应的新鲜度期限，即客户端可以在该期限内使用缓存的响应而无需向服务器发送请求。如果一个资源的缓存副本在”max-age”指定的时间内仍然有效，则客户端可以使用该缓存副本而无需向服务器进行请求。</p>
<p>以下是一个使用”Cache-Control: max-age”的HTTP响应头的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: max-age=3600</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br></pre></td></tr></table></figure>

<p>在上述示例中，”Cache-Control: max-age&#x3D;3600”指示客户端可以在3600秒（1小时）内使用该缓存的响应而无需向服务器发送请求。如果在此期限内发起的请求与此资源相关，则客户端可以直接使用缓存副本。</p>
<p>“max-age”指令是相对于响应的日期和时间来计算的。当客户端接收到带有”max-age”指令的响应时，它会根据响应的日期和时间以及”max-age”指定的秒数来计算出响应的有效期限。</p>
<p>需要注意以下几点：</p>
<ol>
<li><p>“max-age”指令优先级高于其他指令，如”no-cache”或”must-revalidate”。如果同时存在这些指令，”max-age”会覆盖它们。</p>
</li>
<li><p>“max-age”指令不依赖于服务器的时间，而是依赖于响应中的日期和时间。这可以避免因为客户端和服务器之间的时钟不一致而导致缓存失效。</p>
</li>
<li><p>如果同时存在”Expires”头字段和”max-age”指令，”max-age”优先级更高。”max-age”用于指定相对时间，而”Expires”用于指定绝对时间。</p>
</li>
</ol>
<p>总结起来，”Cache-Control: max-age”指令用于指定缓存的响应在被认为过期之前的最长时间。客户端可以在指定的时间内使用缓存副本而无需发送请求。这可以提高性能并减轻服务器负载，特别是对于不经常更改的静态资源。</p>
<hr>
<h2 id="HTTP-Pragma"><a href="#HTTP-Pragma" class="headerlink" title="HTTP Pragma"></a>HTTP Pragma</h2><p>HTTP Pragma字段是一种HTTP头字段，用于向服务器传递特定的指令或控制信息。它是HTTP&#x2F;1.0版本中引入的，目的是为了提供与缓存相关的指令。</p>
<p>在HTTP请求头中，Pragma字段可以用于向服务器发送请求指令。在实践中，Pragma字段很少被使用，因为在HTTP&#x2F;1.1中引入了更强大和灵活的Cache-Control字段来管理缓存。常见的Pragma指令包括：</p>
<ul>
<li><code>no-cache</code>：表示客户端要求服务器每次都提供最新的响应，不使用缓存副本。与Cache-Control中的<code>no-cache</code>指令功能类似。</li>
</ul>
<p>在HTTP响应头中，Pragma字段用于向客户端传递响应的指令或信息。在实践中，Pragma字段同样很少被使用，因为Cache-Control字段已经提供了更广泛和强大的缓存控制功能。</p>
<p>需要注意的是，HTTP&#x2F;1.1规范中建议不再使用Pragma字段来控制缓存，而是使用Cache-Control字段。因此，当处理HTTP协议时，应优先考虑Cache-Control字段，而将Pragma字段视为过时和不推荐使用的。</p>
<hr>
<h2 id="HTTP-Expires"><a href="#HTTP-Expires" class="headerlink" title="HTTP Expires"></a>HTTP Expires</h2><p>HTTP Expires字段是一种响应头字段，用于指定响应的过期时间。它告诉客户端在过期时间之前可以直接使用缓存的响应，而无需向服务器发起新的请求。</p>
<p>Expires字段的值是一个日期时间，表示响应的过期时间点。客户端可以在该时间点之前使用缓存的响应。如果客户端在过期时间之后发起请求，缓存将被视为无效，客户端需要向服务器获取最新的响应。</p>
<p>例如，下面是一个使用Expires字段的响应头示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Expires: Thu, 17 Jun 2023 12:00:00 GMT</span><br></pre></td></tr></table></figure>

<p>在这个例子中，Expires字段的值是”Thu, 17 Jun 2023 12:00:00 GMT”，表示响应的过期时间为2023年6月17日12:00:00 GMT。在过期时间之前，客户端可以直接使用缓存的响应。</p>
<p>需要注意的是，Expires字段的缺点是它使用的是服务器的时间，而客户端的时间可能与服务器的时间不一致。为了解决这个问题，HTTP&#x2F;1.1引入了Cache-Control字段，其中的<code>max-age</code>指令提供了更可靠的缓存过期时间控制，并以秒为单位指定相对时间。相比之下，Expires字段更适用于在HTTP&#x2F;1.0环境下进行缓存控制。在HTTP&#x2F;1.1中，Cache-Control字段被认为是更优先和更可靠的缓存控制机制。</p>
<hr>
<h2 id="HTTP-Content-Type-1"><a href="#HTTP-Content-Type-1" class="headerlink" title="HTTP Content-Type"></a>HTTP Content-Type</h2><p>HTTP Content-Type是一种HTTP头字段，用于指示传输的实体（如请求体或响应体）的媒体类型（Media Type）。它告诉接收方如何解析和处理实体的内容。</p>
<p>Content-Type字段通常出现在HTTP请求头和响应头中。在请求头中，它指示客户端发送的实体的媒体类型。在响应头中，它指示服务器返回的实体的媒体类型。</p>
<p>Content-Type字段的值通常由两部分组成：</p>
<ol>
<li>主类型（Main Type）：表示实体的大类，例如文本（text）、图像（image）、音频（audio）、视频（video）、应用程序（application）等。</li>
<li>子类型（Sub Type）：表示主类型下的具体细分，例如文本可以是纯文本（plain）或HTML文档（html），图像可以是JPEG（jpeg）或PNG（png）等。</li>
</ol>
<p>Content-Type字段的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: 主类型/子类型</span><br></pre></td></tr></table></figure>

<p>例如，下面是一些常见的Content-Type值示例：</p>
<ul>
<li>文本类型：<ul>
<li>纯文本：<code>text/plain</code></li>
<li>HTML文档：<code>text/html</code></li>
<li>XML文档：<code>text/xml</code></li>
</ul>
</li>
<li>图像类型：<ul>
<li>JPEG图像：<code>image/jpeg</code></li>
<li>PNG图像：<code>image/png</code></li>
<li>GIF图像：<code>image/gif</code></li>
</ul>
</li>
<li>音频类型：<ul>
<li>MP3音频：<code>audio/mpeg</code></li>
<li>WAV音频：<code>audio/wav</code></li>
</ul>
</li>
<li>视频类型：<ul>
<li>MPEG视频：<code>video/mpeg</code></li>
<li>MP4视频：<code>video/mp4</code></li>
</ul>
</li>
<li>应用程序类型：<ul>
<li>JSON数据：<code>application/json</code></li>
<li>PDF文档：<code>application/pdf</code></li>
</ul>
</li>
</ul>
<p>通过Content-Type字段，客户端和服务器可以彼此了解和解释实体的内容类型，从而正确处理和解析数据。这对于正确显示网页、处理文件上传、进行API通信等非常重要。</p>
<h2 id="HTTP-Content-Type-multipart-x-mixed-replace"><a href="#HTTP-Content-Type-multipart-x-mixed-replace" class="headerlink" title="HTTP Content-Type multipart&#x2F;x-mixed-replace"></a>HTTP Content-Type multipart&#x2F;x-mixed-replace</h2><p>HTTP Content-Type字段中的<code>multipart/x-mixed-replace</code>是一种特殊的媒体类型，用于在单个HTTP响应中连续发送多个部分（或实体）。它常用于实时流式传输或服务器推送，其中每个部分都代表一个独立的数据块或事件。</p>
<p><code>multipart/x-mixed-replace</code>的工作原理是，服务器发送一系列的部分，每个部分都有自己的Content-Type和内容。接收方（通常是浏览器）会逐个解析和处理这些部分，并按照其各自的Content-Type进行相应的处理。</p>
<p>每个部分由一个唯一的分隔符（boundary）分隔。分隔符是一个随机生成的字符串，用于标识部分的起始和结束。在响应中，Content-Type字段中的boundary参数指定了分隔符。</p>
<p>下面是一个示例HTTP响应头，展示了使用<code>multipart/x-mixed-replace</code>的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: multipart/x-mixed-replace; boundary=boundary123</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>multipart/x-mixed-replace</code>指定了响应使用该媒体类型。<code>boundary=boundary123</code>指定了分隔符为”boundary123”。</p>
<p>响应体的内容将按照以下格式进行发送：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--boundary123</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">&lt;JPEG image data&gt;</span><br><span class="line">--boundary123</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">Some text data</span><br><span class="line">--boundary123--</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先发送了一个JPEG图像部分，然后是一个纯文本部分。每个部分都以<code>--boundary123</code>开头，并以<code>--boundary123--</code>表示结束。</p>
<p>客户端会解析每个部分，并根据各自的Content-Type进行相应的处理，例如显示图像或显示文本数据。</p>
<p><code>multipart/x-mixed-replace</code>的特点是，在接收到一个部分后，客户端会立即丢弃之前接收到的部分。这使得它适用于实时更新的场景，如视频流、监控摄像头等，因为客户端只处理最新的部分，而不会保留之前的部分。</p>
<p>注意：由于<code>multipart/x-mixed-replace</code>在HTTP&#x2F;1.1中没有官方标准，不同的实现可能会有差异。因此，对于具体使用情况，最好查阅相关文档或参考实现的要求。</p>
<hr>
<h2 id="HTTP-Content-Length"><a href="#HTTP-Content-Length" class="headerlink" title="HTTP Content-Length"></a>HTTP Content-Length</h2><p>HTTP Content-Length是一个HTTP响应头字段，用于指示响应体的长度（以字节为单位）。它告诉接收方在接收完指定长度的数据后停止接收，可以用于确定完整的响应体的大小。</p>
<p>Content-Length字段的值是一个十进制整数，表示响应体的字节长度。例如，Content-Length: 1024表示响应体的长度为1024字节。</p>
<p>使用Content-Length字段的好处是接收方可以根据指定的长度来正确读取和处理响应体。这在处理固定长度的数据时非常有用，如文件下载、二进制数据传输等。</p>
<p>以下是一个使用Content-Length字段的HTTP响应头示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 4096</span><br></pre></td></tr></table></figure>

<p>在这个示例中，Content-Length字段的值为4096，表示响应体的长度为4096字节。</p>
<p>需要注意的是，Content-Length字段仅适用于具有确定长度的响应体。对于动态生成的或以流式传输的方式提供的响应，Content-Length字段可能无法准确指示响应体的总长度。在这种情况下，通常使用分块传输编码（chunked transfer encoding）或其他适当的机制来指示响应体的传输方式和结束。</p>
<p>另外，Content-Length字段通常不会出现在HTTP请求头中，因为请求体的长度往往由客户端动态确定，并在请求头中使用Transfer-Encoding或其他字段进行传输长度的指示。</p>
<hr>
<h2 id="HTTP-Connection"><a href="#HTTP-Connection" class="headerlink" title="HTTP Connection"></a>HTTP Connection</h2><p>HTTP Connection字段（或头字段）是一个HTTP请求头和响应头中的字段，用于指示是否需要在请求或响应完成后关闭TCP连接或保持连接打开。</p>
<p>在HTTP&#x2F;1.0中，Connection字段的值可以是”keep-alive”或”close”，分别表示保持连接打开或关闭连接。如果使用”keep-alive”，则表示客户端或服务器希望保持TCP连接打开，以便在后续请求或响应中复用该连接。如果使用”close”，则表示请求或响应完成后关闭连接。</p>
<p>以下是一个示例，在HTTP&#x2F;1.0中使用Connection字段的请求头和响应头：</p>
<p>请求头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /example HTTP/1.0</span><br><span class="line">Host: www.example.com</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>响应头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p>在HTTP&#x2F;1.1中，Connection字段的语义有所变化。它成为一个逐跳（hop-by-hop）头字段，用于指示仅对单个连接有效，而不是整个传输链路。常见的Connection字段值包括：</p>
<ul>
<li>“keep-alive”：表示请求或响应后保持连接打开，以便进行后续请求或响应的复用。</li>
<li>“close”：表示请求或响应完成后关闭连接。</li>
<li>其他特定的头字段：表示请求或响应中有特定的头字段需要逐跳处理，如”Upgrade”、”Transfer-Encoding”等。</li>
</ul>
<p>以下是一个示例，在HTTP&#x2F;1.1中使用Connection字段的请求头和响应头：</p>
<p>请求头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /example HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>响应头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p>需要注意的是，HTTP&#x2F;1.1默认使用持久连接（persistent connection），即默认情况下会保持连接打开。如果不希望保持连接打开，可以在请求头或响应头中使用”Connection: close”指示关闭连接。</p>
<p>在HTTP&#x2F;2中，Connection字段被废弃，取而代之的是使用专门的帧（frame）来管理连接的生命周期。连接的打开和关闭由协议自身管理，而不需要应用层显式地指示。</p>
<p>总之，HTTP Connection字段用于指示是否保持连接打开或关闭，具体的语义和行为取决于HTTP协议版本和字段的值。</p>
<hr>
<h2 id="HTTP-响应报文字段Server"><a href="#HTTP-响应报文字段Server" class="headerlink" title="HTTP 响应报文字段Server"></a>HTTP 响应报文字段Server</h2><p>HTTP响应报文中的<code>Server</code>字段是一个可选的响应头字段，用于指示提供HTTP响应的服务器软件或应用程序的名称和版本信息。</p>
<p><code>Server</code>字段的值通常是服务器软件的名称和版本号的组合。例如，<code>Server: Apache/2.4.29</code>表示使用的是Apache HTTP Server软件的2.4.29版本。</p>
<p>这个字段可以提供有关服务器的一些信息，但并不是强制要求的，因此服务器可以选择是否在响应中包含<code>Server</code>字段。</p>
<p>以下是一个示例HTTP响应头，展示了使用<code>Server</code>字段的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache/2.4.29</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>Server: Apache/2.4.29</code>指示服务器使用的是Apache HTTP Server软件的2.4.29版本。</p>
<p>需要注意的是，由于<code>Server</code>字段提供了有关服务器的信息，因此在安全性方面需要谨慎处理。恶意用户可能会利用这些信息来进行攻击或针对特定的服务器漏洞。</p>
<p>出于安全性的考虑，一些服务器管理员可能选择隐藏或修改<code>Server</code>字段的值，以减少被攻击的风险。这可以通过配置服务器软件或使用专门的安全模块来实现。</p>
<p>总结：<code>Server</code>字段是HTTP响应报文中的一个可选字段，用于指示提供响应的服务器软件或应用程序的名称和版本信息。它提供了有关服务器的一些信息，但在安全性方面需要注意保护。</p>
<hr>
<h2 id="HTTP-Access-Control-Allow-Origin"><a href="#HTTP-Access-Control-Allow-Origin" class="headerlink" title="HTTP Access-Control-Allow-Origin"></a>HTTP Access-Control-Allow-Origin</h2><p>HTTP Access-Control-Allow-Origin是一个HTTP响应头字段，用于指示允许访问资源的跨域请求源。</p>
<p>在跨域资源共享（CORS）机制中，浏览器会在发送跨域请求时向服务器发送一个预检请求（OPTIONS请求），以确定是否允许该跨域请求。服务器在预检请求的响应中可以包含Access-Control-Allow-Origin字段，用于指定允许访问资源的来源。</p>
<p>Access-Control-Allow-Origin字段的值可以是以下三种情况之一：</p>
<ol>
<li><p>具体的源：可以指定一个具体的来源，例如<code>Access-Control-Allow-Origin: https://www.example.com</code>，表示只允许来自<code>https://www.example.com</code>的请求访问资源。</p>
</li>
<li><p>通配符（*）：可以使用通配符来表示允许任何来源的请求访问资源，例如<code>Access-Control-Allow-Origin: *</code>。</p>
</li>
<li><p>不包含该字段：如果响应中不包含Access-Control-Allow-Origin字段，或者该字段的值为空，浏览器会阻止跨域请求访问资源。</p>
</li>
</ol>
<p>需要注意的是，服务器返回的Access-Control-Allow-Origin字段仅在预检请求的响应中才起作用。对于实际的跨域请求，浏览器会根据预检请求中的结果来判断是否允许访问资源。</p>
<p>以下是一个示例，展示了Access-Control-Allow-Origin字段的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Origin: https://www.example.com</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br></pre></td></tr></table></figure>

<p>在上述示例中，Access-Control-Allow-Origin字段的值为<code>https://www.example.com</code>，表示只允许来自该来源的请求访问资源。</p>
<p>通过设置Access-Control-Allow-Origin字段，服务器可以控制哪些跨域请求被允许访问资源，提供了一种基于服务器端的跨域访问控制机制。</p>
<hr>
<h2 id="HTTP-Access-Control-Allow-Methods"><a href="#HTTP-Access-Control-Allow-Methods" class="headerlink" title="HTTP Access-Control-Allow-Methods"></a>HTTP Access-Control-Allow-Methods</h2><p>HTTP Access-Control-Allow-Methods是一个HTTP响应头字段，用于指示服务器支持的跨域请求方法。</p>
<p>在跨域资源共享（CORS）机制中，浏览器会发送一个预检请求（OPTIONS请求）到服务器，以确定是否允许特定跨域请求。预检请求中会包含一个Access-Control-Request-Method字段，用于指示实际请求所使用的方法（如GET、POST、PUT、DELETE等）。</p>
<p>服务器在预检请求的响应中可以包含Access-Control-Allow-Methods字段，用于指示服务器支持的跨域请求方法。</p>
<p>Access-Control-Allow-Methods字段的值是一个逗号分隔的HTTP方法列表，表示服务器允许的跨域请求方法。例如，<code>Access-Control-Allow-Methods: GET, POST, PUT</code>表示服务器允许使用GET、POST和PUT方法的跨域请求。</p>
<p>以下是一个示例，展示了Access-Control-Allow-Methods字段的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Origin: https://www.example.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br></pre></td></tr></table></figure>

<p>在上述示例中，Access-Control-Allow-Methods字段的值为<code>GET, POST, PUT</code>，表示服务器支持GET、POST和PUT方法的跨域请求。</p>
<p>通过设置Access-Control-Allow-Methods字段，服务器可以明确指定支持的跨域请求方法，从而对跨域请求进行细粒度的控制。</p>
<p>需要注意的是，Access-Control-Allow-Methods字段只在预检请求的响应中起作用。对于实际的跨域请求，浏览器会根据预检请求的结果来判断是否允许使用特定的请求方法。</p>
<p>此外，服务器还可以使用其他相关的响应头字段，如Access-Control-Allow-Headers和Access-Control-Allow-Credentials，来进一步控制和配置跨域资源共享。</p>
<p>总结：HTTP Access-Control-Allow-Methods是一个HTTP响应头字段，用于指示服务器支持的跨域请求方法。通过设置该字段，服务器可以明确指定允许的跨域请求方法，实现跨域资源共享的细粒度控制。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Network/2024-05-22-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Network/2024-05-22-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">网络设备基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>常用的网络设备基础知识</li>
</ul>
<h2 id="网络交换机"><a href="#网络交换机" class="headerlink" title="网络交换机"></a>网络交换机</h2><ul>
<li><p>网络交换机(Network switch)是一种网络硬件，通过报文交换接收和转发数据到目标设备，它能够在计算机网络上连接不同的设备。一般也简称为交换机</p>
</li>
<li><p>交换机是一种多端口的网桥，在数据链路层使用MAC地址转发数据。通过加入路由功能，一些交换机也可以在网络层转发数据，这种交换机一般被称为三层交换机或者多层交换机。</p>
</li>
<li><p>以太网交换机是网络交换机最常见的形式。第一个以太网交换机由Kalpana公司（1994年被思科收购）推出。在其他类型的网络中，交换机也普遍存在，如光纤通道、异步传输模式和InfiniBand。</p>
</li>
<li><p>中继器会在其所有端口转发相同的数据，让设备自行判断哪些是自己需要的数据，交换机则不同，它只会将数据转发到需要接收的设备</p>
</li>
<li><p>工作原理</p>
<ul>
<li>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过将MAC地址和端口对应，形成一张MAC表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</li>
<li>交换机对数据包的转发是建立在MAC地址——物理地址基础之上的，对于IP网络协议来说，它是透明的，即交换机在转发数据包时，不知道也无须知道信源机和信宿机的IP地址，只需知其物理地址。</li>
<li>交换机在操作过程当中会不断的收集资料去建立它本身的一个地址表，这个表相当简单，它说明了某个MAC地址是在哪个端口上被发现的，所以当交换机收到一个TCP&#x2F;IP 数据包时，它便会查看该数据包的目的MAC地址，核对自己的地址表以确认应该从哪个端口把数据包发出去。由于这个过程比较简单，加上这功能由一崭新硬件进行——ASIC，因此速度相当快。一般只需几十微秒，交换机便可决定一个IP数据包该往哪里送</li>
<li>如果目的地MAC地址不能在地址表中找到时，交换机会把IP 数据包“扩散”出去，即把它从每一个端口中提交去，就如交换机在处理一个收到的广播数据包时一样。二层交换机的弱点正是它处理广播数据包的手法不太有效，比方说，当一个交换机收到一个从TCP&#x2F;IP工作站上发出来的广播数据包时，他便会把该数据包传到所有其他端口去，哪怕有些端口上连的是IPX或DECnet工作站。这样一来，非TCP&#x2F;IP节点的带宽便会受到负面的影响，就算同样的TCP&#x2F;IP节点，如果他们的子网跟发送那个广播数据包的工作站的子网相同，那么他们也会无缘无故地收到一些与他们毫不相干的网络广播，整个网络的效率因此会大打折扣</li>
</ul>
</li>
<li><p>工作方式</p>
<ul>
<li>收到某网段（设为A）MAC地址为X的计算机发给MAC地址为Y的计算机的数据包。交换机从而记下了MAC地址X在网段A。这称为学习（learning）。</li>
<li>交换机还不知道MAC地址Y在哪个网段上，于是向除了A以外的所有网段转发该数据包。这称为泛洪（flooding）。</li>
<li>MAC地址Y的计算机收到该数据包，向MAC地址X发出确认包。交换机收到该包后，从而记录下MAC地址Y所在的网段</li>
<li>交换机向MAC地址X转发确认包。这称为转发（forwarding）</li>
<li>交换机收到一个数据包，查表后发现该数据包的来源地址与目的地址属于同一网段。交换机将不处理该数据包。这称为过滤（filtering）</li>
<li>交换机内部的MAC地址-网段查询表的每条记录采用时间戳记录最后一次访问的时间。早于某个阈值（用户可配置）的记录被清除。这称为老化（aging）。</li>
</ul>
</li>
<li><p>对于全交换（full-switch）局域网，交换机每个端口只连接一台设备，因此不会发生碰撞。交换机也不需要做过滤</p>
</li>
<li><p>工作在OSI不同层级的交换技术</p>
</li>
<li><p>现代商业交换机主要使用以太网接口。提供多端口的二层桥接是以太网交换机的核心功能，而很多交换机也提供其他层级的服务，这种不仅仅提供了桥接功能的交换机也被称为多层交换机。多层交换机可以在许多层级上学习拓扑结构，也可以在一层或多层上进行转发。</p>
</li>
<li><p>一层</p>
<ul>
<li>一层网络设备传输数据而不控制任何流量，比如集线器。任何进入端口数据包会被转发到除进入端口之外的其他所有端口。具体而言，即每个比特或码元被转发时是原封不动的。由于每个数据包被分发到所有端口，其冲突会影响到整个网络，进而限制了它的整体的能力。 到21世纪初，集线器和低端交换机的价格差异很小。[1]对于特定应用，集线器在一段时间内还是能够发挥作用的，比如给数据包分析器提供网络流量的副本。网络分流器还有交换机的端口镜像也可以实现同样功能</li>
</ul>
</li>
<li><p>二层</p>
<ul>
<li>二层交换机依据硬件地址（MAC 地址）在数据链路层（第二层）传送网络帧。 二层交换机对于路由器和主机是“透明的”，主要遵从802.1d 标准。该标准规定交换机通过观察每个端口的数据帧获得源MAC 地址，交换机在内部的高速缓存中建立MAC 地址与端口的映射表。当交换机接受的数据帧的目的地址在该映射表中被查到，交换机便将该数据帧送往对应的端口。如果它查不到，便将该数据帧广播到该端口所属虚拟局域网（VLAN）的所有端口，如果有回应数据包，交换机便将在映射表中增加新的对应关系。当交换机初次加入网络中时，由于映射表是空的，所以，所有的数据帧将发往虚拟局域网内的全部端口直到交换机“学习”到各个MAC 地址为止。这样看来，交换机刚刚启动时与传统的共享式集线器作用相似的，直到映射表建立起来后，才能真正发挥它的性能。这种方式改变了共享式以太网抢行的方式，如同在不同的行驶方向上铺架了立交桥，去往不同方向的车可以同时通行，因此大大提高了流量。从VLAN的角度来看，由于只有子网内部的节点竞争带宽，所以性能得到提高。主机1 访问主机2 同时，主机3 可以访问主机4 。当各个部门具有自己独立的服务器时，这一优势更加明显。但是这种环境正发生巨大的变化，因为服务器趋向于集中管理，另外，这一模式也不适合Internet的应用。不同VLAN之间的通讯需要通过路由器来完成，另外为了实现不同的网段之间通讯也需要路由器进行互连。</li>
</ul>
</li>
<li><p>三层 </p>
<ul>
<li>三层交换机则可以处理第三层网络层协议，用于连接不同网段，通过对缺省网关的查询学习来建立两个网段之间的直接连接</li>
<li>三层交换机可以实现路由器的全部或部分功能，但只能用于同一类型的局域网子网之间的互连。这样，三层交换机可以像二层交换机那样通过MAC地址标识数据包，也可以像传统路由器那样在两个局域网子网之间进行功能较弱的路由转发，它的路由转发不是通过软件来维护的路由表，而是通过专用的ASIC芯片处理这些转发；</li>
</ul>
</li>
<li><p>四层</p>
<ul>
<li>四层交换机可以处理第四层传输层协议，可以将会话与一个具体的IP地址绑定，以实现虚拟IP</li>
</ul>
</li>
<li><p>七层</p>
<ul>
<li>更加智能的交换器，可以充分利用频宽资源来过滤，识别和处理应用层数据转换的交换设备</li>
</ul>
</li>
<li><p>网络交换机带宽分为： 10Mb&#x2F;s、100Mb&#x2F;s、1Gb&#x2F;s、10Gb&#x2F;s、40Gb&#x2F;s、100Gb&#x2F;s。Mbps换算MB&#x2F;s：1Mbps&#x3D;0.125MB&#x2F;s。</p>
</li>
</ul>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><ul>
<li><p>路由器(Router)是将运算设备（例如电脑）及网络连线至其他网络的联网设备。路由器有三个主要功能，分别是</p>
<ul>
<li>确定路径：路由器可以决定从来源到目的地所采用的路径，这个作业称为路由。</li>
<li>资料转传：路由器会将资料转传至所选路径的下一个设备，重复这个过程，最终资料可以抵达目的地。运算设备和路由器可能位于相同的网络或不同的网络。</li>
<li>负载平衡：路由器有时会用多个不同路径，发送相同资料报文副本。其目的是为了减少因资料丢失而造成错误、并建立备援及管理流量。</li>
</ul>
</li>
<li><p>比较技术性的解释是路由器是种电信网络设备，提供路由与转送两种重要机制，</p>
<ul>
<li>可以决定报文由来源端到目的端所经过的路径（host到host之间的传输路径），这个过程称为路由；</li>
<li>将路由器输入端的报文移送至适当的路由器输出端（在路由器内部进行），这称为转送。</li>
</ul>
</li>
<li><p>路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）。</p>
</li>
<li><p>路由器可连接两个以上个别网络的设备。</p>
</li>
<li><p>由于位于两个或更多个网络的交汇处，从而可在它们之间传递分组（一种数据的组织形式）。路由器与交换机在概念上有一定重叠但也有不同：</p>
<ul>
<li>交换机泛指工作于任何网络层次的数据中继设备（尽管多指网桥），</li>
<li>而路由器则更专注于网络层</li>
</ul>
</li>
<li><p>路由器与交换机有四个主要差别</p>
<ul>
<li>第一，路由器是OSI第三层的产品，而交換机则是第二层，第二层主要功能是将网络上各个电脑的MAC地址记在MAC地址表中，当局域网中的电脑要经过交換机去交换传递资料时，就查询交換机上的MAC地址表中的信息，并将报文发送给指定的电脑，而不会像第一层的产品（如集线器）发送给每台在网络中的电脑。</li>
<li>第二，路由器能在多条路径中选择最佳的路径，提升交换数据的传输速率。在发送报文时，路由表会被一同发送，该表存储了前往某一网络的最佳路径，如该路径的“路由度量值”，参考路由表可获得这个过程的详细描述。</li>
<li>第三，路由器可连接超过两个以上不同的网络，而交換机只能连接两个。</li>
<li>第四，路由器具有IP分享器功能，主要是让多台设备用同一条ADSL&#x2F;光纤宽带线路来上网，功能包括共享IP，宽带管理，自动分配IP等等，如在共享IP功能中，不同设备可共享同一个公共IP同时上网；在局域网中，路由器则会指定一组的Class C的私有IP，可让254台设备同时上网。</li>
</ul>
</li>
<li><p>路由器的种类</p>
<ul>
<li>边缘路由器(edge router)<ul>
<li>将设备连接到互联网的路由器。</li>
</ul>
</li>
<li>核心路由器<ul>
<li>如在ISP网络中，只负责与其他路由器之间传递数据</li>
</ul>
</li>
<li>单臂路由器(one-armed-router)<ul>
<li>一种特殊类型的路由器，可用来在多个虚拟局域网（Virtual LAN）之间传递数据包</li>
<li>在无线ad-hoc网络中的每台主机自己进行路由和数据转发，而在有线网络中通常一个广播域就有一台路由器。</li>
<li>近来，许多路由的功能被加入到局域网交换机（实质是高速网桥）上，从而创造出“三层交换机”，可以以接近线速的速度来转发流量。</li>
<li>路由器也被当作Internet网关，主要用在小型网络中如家庭或小型办公室。这种设备使用的Internet连接往往是互联网宽带连接如线缆调制解调器和DSL。这种路由器连接两个网络，WAN和LAN并有自己的路由表。尽管在家庭应用中并不需要太多路由功能（因为只存在WAN和LAN），但这些小型路由器仍然支持路由信息协议。额外地，这种路由器还支持DHCP、网络地址转换、DMZ和防火墙功能，也有一些支持内容过滤和VPN。通常这种路由器和线缆或DSL调制解调器协同工作，但调制解调功能也可以内置在这种路由器中。这种路由器往往同时具有阻止特定外部请求的安全特性。</li>
<li>大型的路由器一般安装在数据中心、电信公司或ISP的机房内。这些路由器将许多网络用大量的带宽连接起来。根据分工的不同，这些路由器可以支持路由协议中的几种，包括IS-IS、OSPF、IGRP、EIGRP、RIP、BGP。</li>
</ul>
</li>
<li>无线网络路由器<ul>
<li>无线网络路由器是一种用来连系有线和无线网络的通讯设备，它可以通过无线方式（如，Wi-Fi）连接终端设备（如，手机、笔记本电脑），进而建立计算机网络。</li>
<li>有的电信运营商为客户安装宽带时会提供含有Wi-Fi的路由器，通过简单地设置拨号可以实现宽带的共享。</li>
<li>无线方式较有线方式更易受环境影响。如，在户外使用无线，其速度可能受天气影响。</li>
<li>其它的无线方式有：红外线、蓝牙、卫星微波等</li>
</ul>
</li>
<li>策略路由<ul>
<li>策略路由比常规路由更灵活，常规路由基于目标网络进行的数据包转发，策略路由则额外定义数据转发规则，包含策略与操作（路由图），如会检查该接口接收到的所有数据包，是否符合路由图中的策略。对不符合的进行处理；符合的则按路由图策略中，对应的操作进行处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><ul>
<li><p>网关(Gateway)是计算机网络中的一种设备或服务器，用于连接不同网络或协议之间进行数据转发和处理。</p>
</li>
<li><p>网关是一种能够在不同网络或协议之间进行数据交换的设备或服务器。网关可以实现不同网络之间的互联互通，也可以实现不同协议之间的转换和适配。网关可以根据不同的功能和层次进行分类，例如物理层网关、数据链路层网关、网络层网关、传输层网关、应用层网关等[1]。网关可以提供多种服务，例如路由、安全、负载均衡、缓存、压缩、加密、认证、授权、过滤、转码等</p>
</li>
<li><p>网关的工作机制</p>
<ul>
<li>网关的工作机制与代理非常相似，它能够接收客户端的请求，并像拥有资源的源服务器一样对请求进行处理或转发。客户端可能无法察觉到通信目标是一个网关，而不是一个源服务器。网关可以根据不同的需求，对请求和响应进行不同的处理，例如修改请求头或响应头，改变请求方法或响应状态码，增加或删除请求参数或响应内容等[3]。网关还可以根据不同的协议，对数据进行编码或解码，例如将HTTP协议转换成FTP协议，或将TCP协议转换成UDP协议等。</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>家庭或小型企业网络中的网关：这种网关通常用于连接局域网和互联网，实现内外网的通信。它可以提供路由、防火墙、NAT、DHCP等功能，保证网络的安全和稳定。</li>
<li>物联网中的智能网关：这种网关用于连接物联网设备和云端平台，实现数据的采集、处理和传输。它可以提供协议转换、数据压缩、数据分析、数据安全等功能，提高物联网系统的性能和效率</li>
<li>语音通信中的语音网关：这种网关用于连接传统电话网络和IP网络，实现语音信号的转换和传输。它可以提供模拟&#x2F;数字信号转换、编解码器选择、信令协商等功能，保证语音通信的质量和兼容性</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Network/2024-05-22-network_2_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Network/2024-05-22-network_2_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">network_2_网络协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>计算机网络协议是在计算机网络中进行通信和数据交换的规则和约定集合。它定义了计算机网络中数据的格式、传输方式、错误检测和纠正、网络设备的工作方式以及网络中各个实体之间的通信流程等。</p>
<p>下面是一些常见的计算机网络协议：</p>
<ol>
<li><p><strong>TCP&#x2F;IP协议</strong>：TCP&#x2F;IP协议是互联网的核心协议，它包括TCP（传输控制协议）和IP（Internet协议）两个主要协议。TCP协议提供可靠的、面向连接的数据传输，而IP协议负责在网络中寻址和路由数据包。</p>
</li>
<li><p><strong>HTTP协议</strong>：HTTP（超文本传输协议）是应用层协议，用于在Web浏览器和Web服务器之间传输超文本文档。它是无状态的，通过请求-响应模型进行通信。</p>
</li>
<li><p><strong>HTTPS协议</strong>：HTTPS（安全超文本传输协议）是在HTTP基础上加入了安全层的协议，使用SSL&#x2F;TLS加密算法保证通信的安全性。</p>
</li>
<li><p><strong>FTP协议</strong>：FTP（文件传输协议）用于在客户端和服务器之间传输文件。它支持文件上传、下载、删除和重命名等操作。</p>
</li>
<li><p><strong>SMTP协议</strong>：SMTP（简单邮件传输协议）用于在网络中发送和传输电子邮件。它定义了电子邮件的格式和传输方式。</p>
</li>
<li><p><strong>POP3协议</strong>：POP3（邮局协议版本3）是用于接收电子邮件的协议，它允许用户从邮件服务器上下载邮件。</p>
</li>
<li><p><strong>DNS协议</strong>：DNS（域名系统）协议用于将域名解析为相应的IP地址。它提供了域名到IP地址之间的映射服务。</p>
</li>
<li><p><strong>ICMP协议</strong>：ICMP（Internet控制消息协议）用于在IP网络中传输错误报文和状态信息。它用于网络故障诊断和管理。</p>
</li>
</ol>
<p>以上只是一小部分常见的计算机网络协议，实际上还有许多其他的协议和标准，用于不同的网络通信需求和场景。这些协议共同构成了计算机网络的基础，使得不同设备和系统能够进行有效的通信和数据交换。</p>
<h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h2><h3 id="Web服务原理和技术"><a href="#Web服务原理和技术" class="headerlink" title="Web服务原理和技术"></a>Web服务原理和技术</h3><ul>
<li><p>Web Service，是面向服务计算模式的一部分，用于互联网上的信息交换</p>
</li>
<li><p>Web Service的主题非常广泛，非常复杂，涉及许多概念，协议和技术，而且它们源自不同的学科，诸如分布式计算系统，计算机网络，计算机体系结构，中间件，软件工程，编程语言，数据库系统，安全性和知识表示等，并且它们以各种错综复杂的方式组合在一起。</p>
</li>
<li><p>此外，还需要一些处理业务流程与组织的新技术，这些新技术既要发现企业存在的问题，又要在实际应用中解决这些问题</p>
</li>
</ul>
<h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><ul>
<li><p>Web服务是一种服务导向架构的技术，通过标准的Web协议提供服务，目的是保证不同平台的应用服务可以互操作</p>
</li>
<li><p>根据W3C的定义，Web服务（Web service）应当是一个软件系统，用以支持网络间不同机器的互动操作</p>
</li>
<li><p>网络服务通常是许多应用程序接口（API）所组成的，它们透过网络，例如国际互联网（Internet）的远程服务器端，执行客户所提交服务的请求</p>
</li>
<li><p>尽管W3C的定义涵盖诸多相异且无法介分的系统，不过通常我们指有关于<strong>主从式架构</strong>（Client-server）之间根据SOAP协议进行传递XML格式消息</p>
</li>
<li><p>无论定义还是实现，Web服务过程中会由服务器提供一个机器可读的描述（通常基于WSDL）以辨识服务器所提供的WEB服务</p>
<ul>
<li><code>SOAP</code>, 一个基于XML的可扩展消息信封格式，需同时绑定一个网络传输协议。这个协议通常是HTTP或HTTPS，但也可能是SMTP或XMPP。</li>
<li><code>WSDL</code>, 一个XML格式文档，用以描述服务端口访问方式和使用协议的细节。通常用来辅助生成服务器和客户端代码及配置信息。</li>
<li><code>UDDI</code>, 一个用来发布和搜索WEB服务的协议，应用程序可借由此协议在设计或运行时找到目标WEB服务。</li>
<li>这些标准由这些组织制订：W3C负责XML、SOAP及WSDL；OASIS负责UDDI。</li>
</ul>
</li>
</ul>
<h3 id="阮一峰网络日志"><a href="#阮一峰网络日志" class="headerlink" title="阮一峰网络日志"></a>阮一峰网络日志</h3><ul>
<li><p>想要理解Web service，必须先理解什么是Service（服务）</p>
</li>
<li><p>传统上，我们把计算机后台程序（Daemon）提供的功能，称为”服务”（service）</p>
</li>
<li><p>比如，让一个杀毒软件在后台运行，它会自动监控系统，那么这种自动监控就是一个”服务”。</p>
</li>
<li><p>通俗地说，”服务”就是<strong>计算机可以提供的某一种功能</strong>。</p>
</li>
<li><p>根据来源的不同，”服务”又可以分成两种：</p>
<ul>
<li>一种是”本地服务”（使用同一台机器提供的服务，不需要网络）</li>
<li>另一种是”网络服务”（使用另一台计算机提供的服务，必须通过网络才能完成）</li>
</ul>
</li>
<li><p>举例来说</p>
<ul>
<li>我现在有一批图片，需要把它们的大小缩小一半。那么，我们可以把”缩放图片”看成是一种服务。</li>
<li>你可以使用”本地服务”，在自己计算机上用软件缩小图片，也可以使用”网络服务”，将图片上传到某个网站，让服务器替你缩小图片，完成后再通过网络送回给你。</li>
<li>这就好比，一件事你可以自己做，也可以交给另一个人去做。肚子饿了，你可以自己做饭，也可以打电话去订一份比萨，让店家替你做好送上门。</li>
</ul>
</li>
<li><p>“网络服务”（Web Service）的本质，就是通过<strong>网络调用其他网站的资源</strong></p>
</li>
<li><p>如果一个软件的主要部分采用了”网络服务”，即它把存储或计算环节”外包”给其他网站了，那么我们就说这个软件属于Web Service架构</p>
</li>
<li><p>Web Service架构的基本思想，就是尽量把非核心功能交给其他人去做，自己全力开发核心功能。</p>
</li>
</ul>
<h2 id="使用Web服务的方式"><a href="#使用Web服务的方式" class="headerlink" title="使用Web服务的方式"></a>使用Web服务的方式</h2><ul>
<li><p>Web服务实际上是一组工具，并有多种不同的方法调用之。</p>
</li>
<li><p><strong>三种最普遍的手段是</strong>：远程过程调用（RPC），服务导向架构（SOA）以及表述性状态转移（REST）。</p>
</li>
<li><p>远程过程调用</p>
<ul>
<li>Web服务提供一个分布式函数或方法接口供用户调用，这是一种比较传统的方式。通常，在WSDL中对RPC接口进行定义（类似于早期的XML-RPC）。</li>
<li>尽管最初的Web服务广泛采用RPC方式部署，但针对其过于紧密之耦合性的批评声也随之不断。这是因为<strong>RPC式WEB服务实质上是利用一个简单的映射</strong>，以把用户请求直接转化成为一个特定语言编写的函数或方法。</li>
<li>如今，多数服务提供商认定此种方式在未来将难有作为，在他们的推动下，WS-I基本协议集（WS-I Basic Profile）已不再支持远程过程调用。</li>
</ul>
</li>
<li><p>服务导向架构</p>
<ul>
<li>现在，业界比较关注的是遵从服务导向架构（Service-oriented architecture，SOA）概念来构筑WEB服务。</li>
<li>在服务导向架构中，通讯由消息驱动，而不再是某个动作（方法调用）。这种WEB服务也被称作面向消息的服务</li>
<li>SOA式WEB服务得到了大部分主要软件供应商以及业界专家的支持和肯定。</li>
<li>作为与RPC方式的最大差别，SOA方式<strong>更加关注如何去连接服务而不是去特定某个实现的细节</strong>。WSDL定义了联络服务的必要内容</li>
</ul>
</li>
<li><p>表述性状态转移</p>
<ul>
<li>表述性状态转移式（Representational state transfer，REST）Web服务类似于HTTP或其他类似协议，它们<strong>把接口限定在一组广为人知的标准动作中</strong>（比如HTTP的GET、PUT、DELETE）以供调用。</li>
<li>此类WEB服务关注与那些稳定的资源的互动，而不是消息或动作</li>
<li>此种服务可以通过WSDL来描述SOAP消息内容，通过HTTP限定动作接口；或者完全在SOAP中对动作进行抽象。</li>
</ul>
</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h3 id="维基百科-1"><a href="#维基百科-1" class="headerlink" title="维基百科"></a>维基百科</h3><ul>
<li><p>WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。</p>
</li>
<li><p>WebSocket协议在2011年由IETF标准化为RFC 6455，后由RFC 7936补充规范。<strong>Web IDL中的WebSocket API由W3C标准化</strong></p>
</li>
<li><p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。</p>
</li>
<li><p>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输</p>
</li>
</ul>
<h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>WebSocket是一种与HTTP不同的协议。两者都位于OSI模型的应用层，并且都依赖于传输层的TCP协议</p>
</li>
<li><p>为了实现兼容性，WebSocket握手使用HTTP Upgrade头从HTTP协议更改为WebSocket协议。</p>
</li>
<li><p>WebSocket协议支持Web浏览器（或其他客户端应用程序）与Web服务器之间的交互，具有较低的开销，便于实现客户端与服务器的实时数据传输</p>
</li>
<li><p>服务器可以通过标准化的方式来实现，而无需客户端首先请求内容，并允许消息在保持连接打开的同时来回传递。</p>
</li>
<li><p>通过这种方式，可以在客户端和服务器之间进行双向持续对话。 </p>
</li>
<li><p>通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。</p>
</li>
<li><p>另外，Comet之类的技术以非标准化的方式实现了类似的双向通信</p>
<ul>
<li>Comet是一种用于web的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求，</li>
<li>目前有两种实现方式，长轮询和iframe流。</li>
</ul>
</li>
<li><p>与HTTP不同，WebSocket提供全双工通信。</p>
</li>
<li><p>此外，WebSocket还可以在TCP之上实现消息流。TCP单独处理字节流，没有固有的消息概念。 </p>
</li>
<li><p>在WebSocket之前，使用Comet可以实现全双工通信。</p>
</li>
<li><p>但是Comet存在TCP握手和HTTP头的开销，因此对于小消息来说效率很低。WebSocket协议旨在解决这些问题。</p>
</li>
<li><p>WebSocket协议规范将ws（WebSocket）和wss（WebSocket Secure）定义为两个新的统一资源标识符（URI）方案，分别对应明文和加密连接。</p>
</li>
<li><p>除了方案名称和片段ID（不支持#）之外，其余的URI组件都被定义为此URI的通用语法。</p>
</li>
</ul>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul>
<li><p>早期，很多网站为了实现<strong>推送技术</strong>，所用的技术都是<strong>轮询</strong>。</p>
</li>
<li><p>推送技术（英语：Push technology），或者说是是一种基于Internet通信方式的服务器推送，其中要求通信的请求是由发布者或中央服务器发起。与 pull&#x2F;get 形成对比，额外消息传输的相应一般由接收者或客户端发起。</p>
</li>
<li><p>轮询,是指由浏览器每隔一段时间（如每秒）向服务器发出HTTP请求，然后服务器返回最新的数据给客户端。</p>
</li>
<li><p>这种传统的模式带来很明显的缺点，即:</p>
<ul>
<li>浏览器需要不断的向服务器发出请求，然而HTTP请求与回复可能会包含较长的头部，其中真正有效的数据可能只是很小的一部分，所以这样会消耗很多带宽资源</li>
</ul>
</li>
<li><p><strong>比较新的轮询技术是Comet</strong>。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的HTTP长连接也会消耗服务器资源</p>
</li>
<li><p>在这种情况下，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯</p>
</li>
<li><p>Websocket与HTTP和HTTPS使用相同的TCP端口，可以绕过大多数防火墙的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。</p>
</li>
</ul>
<h4 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h4><ul>
<li><p>WebSocket 是独立的、创建在TCP上的协议。</p>
</li>
<li><p>Websocket 通过 HTTP&#x2F;1.1 协议的101状态码进行握手。</p>
</li>
<li><p>为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称<strong>握手</strong>（Handshaking）。</p>
</li>
<li><p>典型的WebSocket握手请求</p>
<ul>
<li>客户端请求：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></li>
<li>服务器回应：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字段说明：</p>
<ul>
<li>Connection必须设置Upgrade，表示客户端希望连接升级。</li>
<li>Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li>
<li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。<ul>
<li>把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行Base64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。</li>
<li>如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li>
</ul>
</li>
<li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li>
<li>Origin字段是必须的。如果缺少origin字段，WebSocket服务器需要回复HTTP 403 状态码（禁止访问）。</li>
<li>其他一些定义在HTTP协议中的字段，如Cookie等，也可以在Websocket中使用</li>
</ul>
</li>
</ul>
<h3 id="阮一峰网络日志-1"><a href="#阮一峰网络日志-1" class="headerlink" title="阮一峰网络日志"></a>阮一峰网络日志</h3><ul>
<li><p>已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p>
</li>
<li><p>因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p>
</li>
<li><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p>
</li>
<li><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。</p>
</li>
<li><p>我们只能使用”<strong>轮询</strong>“：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室</p>
</li>
<li><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p>
</li>
<li><p>因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的</p>
</li>
</ul>
<h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了</p>
</li>
<li><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</p>
</li>
<li><p>其他特点包括：</p>
<ul>
<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</li>
<li>数据格式比较轻量，性能开销小，通信高效。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li>
</ul>
</li>
</ul>
<h2 id="Web3和区块链"><a href="#Web3和区块链" class="headerlink" title="Web3和区块链"></a>Web3和区块链</h2><ul>
<li><p>互联网迄今有两个阶段：Web 1.0 和 Web 2.0</p>
</li>
<li><p>下一个阶段自然就是 Web 3.0（简称 Web3）</p>
</li>
<li><p>Web 1.0 阶段，用户是单纯的内容消费者，内容由网站提供，网站让你看什么，你就看什么，典型例子就是新闻门户网站。</p>
</li>
<li><p>Web 2.0 阶段，用户是内容的生产者，网站只是一个向用户提供服务的平台，典型的 Web 2.0 平台有维基百科、抖音、微信等等</p>
</li>
<li><p>Web3 的很多特征还不明确，但是国外很多文章认为，它跟区块链有关。</p>
<ul>
<li>Web 1.0 是用户读取互联网，Web 2.0 是用户写入互联网，Web3 是用户生活在互联网</li>
<li>娱乐、工作、学习、消费、交际，都在网上发生。网站不仅提供服务，还是一个生活空间，人们的一部分生活可以在网上完成</li>
<li>在教育网站学习，在会议网站开会，在社交网站交友，在游戏网站玩乐。所有网站共同构成了一个无所不包的网络世界</li>
</ul>
</li>
<li><p>所有网站的生活功能，如果能够连在一起，让用户无缝地从一个场景进入另一个场景，那就构成了一个虚拟世界。这大概就是最近很热门的元宇宙（metaverse）的样子</p>
</li>
<li><p>到了那个阶段，用户不再是访问网站，而是进入虚拟世界，过着虚拟的线上生活</p>
</li>
<li><p>这样的虚拟世界，显然不能被一家或几家巨头垄断，否则我们就会依赖这些巨头，不得不遵守它制定的规则。当你的生活都在虚拟世界里面，某一天巨头突然决定关闭你的账号，你的虚拟人生岂不嘎然而止了！</p>
</li>
<li><p>这就是很多人<strong>提出 Web3 应该是分布式的原因</strong>。这有两层含义：</p>
<ul>
<li>它不是集中式的，就没有单一的公司可以控制它；</li>
<li>任何一种服务都有多家提供商，通过分布式协议连起来，用户可以极小的成本，从一个提供商转移到另一个服务商。</li>
</ul>
</li>
<li><p>如果 Web3 确定是分布式的，那么区块链简直就是天然的基础设施。因为<strong>区块链是分布式数据库的一种实现</strong>，本身就是分布式的，而且信息一旦上链，就无法修改</p>
</li>
<li><p>这解决了 Web3 的核心问题：不同网站的数据交换。 </p>
</li>
<li><p>不同网站都可以自由读写同一个用户的数据，并且这些数据是可以信赖的，从而保证用户进入另一个网站，就好像进入同一个世界的不同地区</p>
</li>
<li><p>一旦 Web3 构建于区块链之上，按照区块链的设计，用户需要有一个数字钱包，它是你在虚拟世界的身份证和银行账户。</p>
</li>
<li><p>你的身份、财产、消费，都通过这个数字钱包来标识。网站通过数字钱包的 ID，来识别你是谁</p>
</li>
<li><p>我翻开谷歌一查,这WEB3.0就没有一个正常的解释， 歪歪斜斜的搜索结果每页上都写着 “去中心化” “分布式” “用户拥有” “区块链” “虚拟经济” “价值重塑” “Token” 几个大词，我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本上都写着两个字“炒币”</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/PointCloud/2024-05-22-PointCloud_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/PointCloud/2024-05-22-PointCloud_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">PointCloud_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PointCloud/" itemprop="url" rel="index"><span itemprop="name">PointCloud</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>点云相关的理论基础笔记</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/PointCloud/2024-05-22-PointCloud_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Qt/2024-05-22-qt_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Qt/2024-05-22-qt_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">qt_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>QT 应用程序开发 理论基础</li>
</ul>
<h2 id="怎么理解Qt的信号与槽机制"><a href="#怎么理解Qt的信号与槽机制" class="headerlink" title="怎么理解Qt的信号与槽机制"></a>怎么理解Qt的信号与槽机制</h2><p>Qt的信号与槽机制是Qt中最重要的特性之一，它用于实现对象间的通信。在Qt中，信号与槽是事件驱动的核心，允许对象在特定事件发生时，向其他对象发出信号，并触发与之相关的槽函数。理解信号与槽机制可以帮助你更好地掌握Qt框架中的对象交互方式。</p>
<h3 id="1-信号（Signal）"><a href="#1-信号（Signal）" class="headerlink" title="1. 信号（Signal）"></a>1. <strong>信号（Signal）</strong></h3><p>信号是由Qt对象发出的，用于表示某个事件的发生或状态的变化。例如，一个按钮的点击事件就是一个信号。当按钮被点击时，它会发出一个信号。</p>
<p>信号不需要知道谁接收它，也不需要直接与接收者沟通。它只负责“发出”事件通知，告诉其它对象事件已经发生。</p>
<h3 id="2-槽（Slot）"><a href="#2-槽（Slot）" class="headerlink" title="2. 槽（Slot）"></a>2. <strong>槽（Slot）</strong></h3><p>槽是一个普通的成员函数，用于响应信号。当某个信号发出时，与该信号相关联的槽函数会被自动调用。槽可以是任何符合函数签名的普通成员函数，也可以是全局函数或lambda表达式。</p>
<p>槽的作用是处理信号发出的事件，并做出响应。</p>
<h3 id="3-连接信号与槽"><a href="#3-连接信号与槽" class="headerlink" title="3. 连接信号与槽"></a>3. <strong>连接信号与槽</strong></h3><p>信号与槽之间通过<code>QObject::connect()</code>函数进行连接。当信号发出时，Qt框架会自动找到连接的槽并执行它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), receiver, <span class="built_in">SLOT</span>(<span class="built_in">onButtonClick</span>()));</span><br></pre></td></tr></table></figure>
<p>在这个例子中，当<code>sender</code>（例如一个按钮）发出<code>clicked</code>信号时，<code>receiver</code>的<code>onButtonClick()</code>槽函数会被调用。</p>
<h3 id="4-自动连接"><a href="#4-自动连接" class="headerlink" title="4. 自动连接"></a>4. <strong>自动连接</strong></h3><p>在Qt中，如果信号和槽的参数类型匹配，Qt会自动进行信号和槽的连接，而不需要显式调用<code>connect()</code>。例如，<code>QPushButton</code>有一个<code>clicked()</code>信号，它和<code>QDialog</code>中的<code>accept()</code>槽可以自动连接。</p>
<h3 id="5-信号与槽的参数"><a href="#5-信号与槽的参数" class="headerlink" title="5. 信号与槽的参数"></a>5. <strong>信号与槽的参数</strong></h3><p>信号和槽可以传递参数。信号的参数会传递给槽，槽函数的参数类型必须与信号的参数类型匹配。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), receiver, <span class="built_in">SLOT</span>(<span class="built_in">updateValue</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>
<p>在这个例子中，当<code>sender</code>的<code>valueChanged</code>信号发出时，<code>int</code>类型的参数会传递给<code>receiver</code>的<code>updateValue(int)</code>槽。</p>
<h3 id="6-信号与槽的特性"><a href="#6-信号与槽的特性" class="headerlink" title="6. 信号与槽的特性"></a>6. <strong>信号与槽的特性</strong></h3><ul>
<li><strong>类型安全</strong>：Qt的信号与槽机制是类型安全的，即只有信号和槽参数类型匹配时，连接才会成功。</li>
<li><strong>异步</strong>：信号和槽的调用是异步的，槽函数会在信号发出时被自动调用，线程间通信时也可以使用信号与槽机制。</li>
<li><strong>多个连接</strong>：一个信号可以连接多个槽，多个信号可以连接到同一个槽。</li>
</ul>
<h3 id="7-应用场景"><a href="#7-应用场景" class="headerlink" title="7. 应用场景"></a>7. <strong>应用场景</strong></h3><ul>
<li><strong>UI响应</strong>：比如按钮点击、鼠标事件等。</li>
<li><strong>跨线程通信</strong>：信号与槽机制可以跨线程传递消息，帮助你在不同线程间传递数据或通知。</li>
<li><strong>自定义事件</strong>：在开发中自定义信号与槽，处理特殊的业务逻辑。</li>
</ul>
<p>总结来说，Qt的信号与槽机制是一种松耦合的通信方式，使得对象之间的交互变得更加灵活和可维护。通过这种机制，不同的对象之间能够相互传递信息而无需了解彼此的具体实现。</p>
<h2 id="QT按钮组件"><a href="#QT按钮组件" class="headerlink" title="QT按钮组件"></a>QT按钮组件</h2><ul>
<li>QT中有六种按钮组件，分别是按压按钮QPushButton、工具按钮QToolButton、单选按钮QRadioButton、多选按钮QCheckBox、命令链接按钮QCommandLinkButton、按钮盒QButtonBox</li>
</ul>
<h2 id="QPushButton"><a href="#QPushButton" class="headerlink" title="QPushButton"></a>QPushButton</h2><h3 id="QPushButton组件简介"><a href="#QPushButton组件简介" class="headerlink" title="QPushButton组件简介"></a>QPushButton组件简介</h3><ul>
<li>QPushButton组件用于接受用户点击事件，能够显示提示字符串，是功能性组件，需要父组件作为容器，能够在父组件中进行定位，用于执行命令或触发事件。</li>
<li>QPushButton的类继承如下：<ul>
<li>QPushButton ：public QAbstractButton ：pubic QWidget ：public QObject, public QPaintDevice</li>
</ul>
</li>
</ul>
<h3 id="QPushButton组件属性"><a href="#QPushButton组件属性" class="headerlink" title="QPushButton组件属性"></a>QPushButton组件属性</h3><ul>
<li>QPushButton 组件属性设置选项：<ul>
<li>A、name：组件对应源代码中的名字。</li>
<li>B、text：组件对应图形界面中显示的名字。</li>
<li>C、font：设置text的字体。</li>
<li>D、enabled：组件是否可用。</li>
</ul>
</li>
</ul>
<h3 id="QPushButton组件常用成员函数"><a href="#QPushButton组件常用成员函数" class="headerlink" title="QPushButton组件常用成员函数"></a>QPushButton组件常用成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton：：QPushButton（<span class="type">const</span> QString &amp;text，QWidget *parent，<span class="type">const</span> <span class="type">char</span> *name = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>构造一个名称为name，父对象为parent并且文本为text的按压按钮。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> QAbstractButton：：setText（<span class="type">const</span> QString &amp;）</span><br></pre></td></tr></table></figure>
<ul>
<li>设置按钮上显示的文本。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString QAbstractButton：：text（）<span class="type">const</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回按钮上显示的文本。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> QAbstractButton：：pressed（）[signal]</span><br></pre></td></tr></table></figure>
<ul>
<li>当按下按钮时，发射信号。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> QAbstractButton：：clicked（）[signal]</span><br></pre></td></tr></table></figure>
<ul>
<li>当单击按钮时，发射信号。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="type">void</span> QAbstractButton：：released（）[signal]</span><br></pre></td></tr></table></figure>
<ul>
<li>当释放按钮时，发射信号。</li>
</ul>
<h2 id="Qt程序需要配置那些内容"><a href="#Qt程序需要配置那些内容" class="headerlink" title="Qt程序需要配置那些内容"></a>Qt程序需要配置那些内容</h2><ul>
<li>Qt的几个编译工具: moc, uic, rcc.这几个工具在Qt Assistant中都可以直接搜索到介绍界面，下面简单说一下各自的功能<ul>
<li>moc: 元对象编译器(Meta Object Compiler)，用来处理带有Q_OBJECT宏的类。我们在声明class的时候，继承QObject，再私有声明Q_OBJECT宏就可以使用Qt的信号和槽了，实际上是Qt利用moc将各个类所需要的元对象代码(meta-object code)补充好了。(moc读取一个头文件，补充其中带有Q_OBJECT宏类的元对象代码，一般生成一个moc_ClassName.cpp文件)</li>
<li>uic: 用户界面编译器(User Interface Compiler)，用来编译ui界面文件的</li>
<li>rcc: 资源编译器(Resource Compiler)，把qrc文件编译成对应的C++代码</li>
</ul>
</li>
<li>所以在CMake工程中使用Qt首先要搞明白如何调用这些工具</li>
</ul>
<h3 id="moc-uic-rcc-自动调用"><a href="#moc-uic-rcc-自动调用" class="headerlink" title="moc uic rcc 自动调用"></a>moc uic rcc 自动调用</h3><ul>
<li><p>首先对于 moc uic rcc处理的方法</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>设置了这几个变量之后，会在需要时自动调用这几个编译器。</p>
</li>
<li><p>在添加 exe 时的语法:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(TestQtCMake WIN32 src/main.cpp src/mainWindow.cpp src/mainwindow.h src/mainwindow.ui)</span><br></pre></td></tr></table></figure></li>
<li><p>其中 WIN32 的参数可能需要提示一下</p>
<ul>
<li>如果提供了 WIN32，则将设置WIN32_EXECUTABLE变量为ON，此时将生成一个界面程序而不是控制台程序。</li>
</ul>
</li>
</ul>
<h3 id="添加Qt模块和生成执行文件"><a href="#添加Qt模块和生成执行文件" class="headerlink" title="添加Qt模块和生成执行文件"></a>添加Qt模块和生成执行文件</h3><ul>
<li><p>添加库，使用了 find_package()函数，示例如下</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Widgets REQUIRED)</span><br></pre></td></tr></table></figure></li>
<li><p>首先，要使用find_package()函数，需要提供一个.cmake文件，如何让CMake知道这个文件，可以采用两个方法</p>
<ul>
<li>设置环境变量CMAKE_PREFIX_PATH为Qt5安装位置，这是官方Qt-CMake教程中的推荐做法</li>
<li>设置CMake中Qt5_DIR变量，值为QT5Config.cmake文件的位置。示例如下<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(Qt5_DIR D:\Qt514\<span class="number">5.14</span>.<span class="number">0</span>\msvc2017_64\lib\cmake\Qt5)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>从上方目录可以看出来，这个.cmake文件是不同Qt版本和不同编译平台都有一套，所以对于官方推荐做法笔者并不是很推荐，难不成当需要换平台的时候还需要去改环境变量</p>
</li>
<li><p>将Qt库链接到可执行文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(TestQtCMake Qt5::Widgets)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="运行时依赖处理"><a href="#运行时依赖处理" class="headerlink" title="运行时依赖处理"></a>运行时依赖处理</h3><ul>
<li>对于缺少dll文件，可以在环境变量中是设置Path，把Qt的bin目录添加进来</li>
<li>在windows平台使用官方的 windeployqt 工具，就在上述的bin目录下，传入exe文件路径就可以将该exe依赖的Qt文件全部打包到目录下，命令示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windeployqt.exe TestQtCMake.exe</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>要在CMake中使用Qt，需要以下几步<ul>
<li>设置变量CMAKE_AUTO***为ON以启动 rcc uic moc编译器</li>
<li>设置变量QT5_DIR变量定位.cmake文件，使用find_package()函数定位Qt的库文件，使用target_link_libraries()函数链接Qt库</li>
<li>使用windeployqt工具打包依赖项</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Qt/2024-09-05-qt_5_quick_designer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Qt/2024-09-05-qt_5_quick_designer/" class="post-title-link" itemprop="url">quick designer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>quick designer 使用笔记</li>
</ul>
<h2 id="Qt项目界面文件-ui-及其作用"><a href="#Qt项目界面文件-ui-及其作用" class="headerlink" title="Qt项目界面文件(.ui)及其作用"></a>Qt项目界面文件(.ui)及其作用</h2><ul>
<li><p>Qt项目中，后缀为.ui的文件是可视化设计的窗体的定义文件，例如widget.ui。双击项目文件目录树中的文件widget.ui，会打开一个集成在Qt Creator中的Qt Designer对窗体进行可视化设计。</p>
</li>
<li><p>widget.ui文件，是窗体界面定义文件，是一个XML文件，定义了窗口上的所有组件的属性设置，布局，及其信号与槽函数的关联等。用UI设计器可视化设计的界面都由Qt自动解析，并以XML文件的形式保存下来。在设计界面时，只需在UI设计器里进行可视化设计即可。</p>
</li>
<li><p>ui_widget.h文件，是对widget.ui文件编译后生成的一个文件，ui_widget.h会出现在编译后的目录下，或与widget.ui同目录</p>
</li>
<li><p>ui_widget.h并不会出现在QtCreator的项目文件目录树里，当然可以手动将ui_widget.h添加到项目中</p>
</li>
<li><p>注意，ui_widget.h是对widget.ui文件编译后自动生成的,widget.ui又是通过UI设计器可视化设计生成的。所有，对ui_widget.h手动进行修改没有什么意义，所有涉及界面的修改都应该直接在UI设计器里进行。</p>
</li>
<li><p>查看ui_widget.h文件的内容，发现它主要做了以下的一些工作</p>
<ul>
<li>定义了一个类Ui_Widget，用于封装可视化设计的界面</li>
<li>自动生成了界面各个组件的类成员变量定义。在public部分为界面上每个组件定义了一个指针变量，变量的名称就是设置的objectName。例如，在窗体上放置了一个QLable和一个QPushButton并命名后，自动生成的定义是: QLabel *LabDemo; QPushButton *btnClose;</li>
<li>定义了setupUi()函数，这个函数用于创建各个界面组件，并设置其位置，大小，文字内容，字体等属性，设置信号与槽的关联。setupUi()函数体的第一部分是根据可视化设计的界面内容，用C++代码创建界面上各组件，并设置其属性<ul>
<li>接下来，setupUi()调用了函数retranslateUi(Widget)，用来设置界面各组件的文字内容属性，例如标签的问题，按键的文字，窗体的标题等。将界面上的文字设置的内容独立出来作为一个函数retranslateUi()，在设计多语言界面时会用到这个函数</li>
<li>setupUi()函数的第三部分是设置信号与槽的关联。</li>
<li>所以，在Widget的构造函数里调用ui-&gt;setupUi(this),就实现了窗体上组件的创建，属性设置，信号与槽的关联。</li>
</ul>
</li>
<li>定义namespace Ui,并定义一个从Ui_Widget继承的类Widget<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Ui</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span>::<span class="keyword">public</span> Ui_Widget&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>提示，ui_widget.h文件里实现界面功能的类是Ui_Widget。再定义一个类Widget从Ui_Widget继承而来，并定义在namespace Ui里，这样Ui::Widget与widget.h里的类Widget同名，但是用namespace区分开来。所以，界面的Ui::Widget类与文件widget.h里定义的Widget类实际上是两个类，但是Qt的处理让用户感觉不到Ui::Widget类的存在，只需要直到在Widget类里用ui指针可以访问可视化设计的界面组件就可以了。</p>
</li>
</ul>
<h2 id="把Qt的界面文件-ui文件-生成源文件-h或-cpp"><a href="#把Qt的界面文件-ui文件-生成源文件-h或-cpp" class="headerlink" title="把Qt的界面文件(.ui文件)生成源文件(.h或.cpp)"></a>把Qt的界面文件(.ui文件)生成源文件(.h或.cpp)</h2><ul>
<li>在用Qt做开发时，为了方便快速，一般都使用Qt设计师界面类来做界面相关的布局，这个类在当前工程中是没有.cpp或.h文件的，但主类又有引入了这个头文件，点开转到定义或声明时，时打不开的。</li>
<li>下面的一种办法<ul>
<li>新建一个工程，包含ui文件，然后打开ui文件拖入想要的控件，保存，编译ui文件</li>
<li>在qt安装路径下找到 uic.exe 文件，使用这个工具将ui文件生成.h或.cpp文件。例如<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uic.exe test.ui -o test.h</span><br><span class="line">uic.exe test.ui -o test.cpp</span><br></pre></td></tr></table></figure></li>
<li>.h或.cpp这两个文件只要一个就可以了</li>
<li>把刚才生成的.h文件导入当前工程，然后打开刚刚生成的源码，可以看到整个类的所有属性和所有成员函数</li>
</ul>
</li>
</ul>
<h2 id="Qt-quick-designer-详解"><a href="#Qt-quick-designer-详解" class="headerlink" title="Qt quick designer 详解"></a>Qt quick designer 详解</h2><h1 id="Qt-Quick-Designer-详解"><a href="#Qt-Quick-Designer-详解" class="headerlink" title="Qt Quick Designer 详解"></a>Qt Quick Designer 详解</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><strong>Qt Quick Designer</strong> 是 Qt Creator 集成开发环境（IDE）中的一个可视化设计工具，专用于设计和开发基于 <strong>Qt Quick（QML）</strong> 的用户界面。它提供了所见即所得（WYSIWYG）的编辑环境，使开发者能够通过拖放组件、调整属性等方式，快速构建现代化、响应式的用户界面，而无需手动编写大量的 QML 代码。</p>
<hr>
<h2 id="二、Qt-Quick-和-QML-简介"><a href="#二、Qt-Quick-和-QML-简介" class="headerlink" title="二、Qt Quick 和 QML 简介"></a>二、Qt Quick 和 QML 简介</h2><p>在深入了解 Qt Quick Designer 之前，先简单回顾一下 Qt Quick 和 QML：</p>
<ul>
<li><p><strong>Qt Quick</strong>：是 Qt 框架中用于创建动态用户界面的技术，特别适用于触摸屏和移动设备应用。它结合了 QML 和 JavaScript，实现了高性能的界面渲染和丰富的动画效果。</p>
</li>
<li><p><strong>QML（Qt Modeling Language）</strong>：是一种基于 JavaScript 的声明式语言，专门用于设计用户界面。通过 QML，可以以简洁直观的方式描述界面元素、布局和交互行为。</p>
</li>
</ul>
<hr>
<h2 id="三、Qt-Quick-Designer-的主要功能"><a href="#三、Qt-Quick-Designer-的主要功能" class="headerlink" title="三、Qt Quick Designer 的主要功能"></a>三、Qt Quick Designer 的主要功能</h2><h3 id="1-拖放式界面设计"><a href="#1-拖放式界面设计" class="headerlink" title="1. 拖放式界面设计"></a>1. 拖放式界面设计</h3><ul>
<li><strong>组件面板</strong>：提供了丰富的预定义 UI 组件，如按钮、文本、图像、列表等。</li>
<li><strong>拖放操作</strong>：直接将组件从面板拖拽到设计区域，快速构建界面布局。</li>
</ul>
<h3 id="2-属性编辑器"><a href="#2-属性编辑器" class="headerlink" title="2. 属性编辑器"></a>2. 属性编辑器</h3><ul>
<li><strong>实时调整</strong>：选中组件后，可以在属性编辑器中修改其属性，如大小、位置、颜色等。</li>
<li><strong>绑定支持</strong>：支持属性绑定，可以将组件的属性与数据模型或其他组件属性关联。</li>
</ul>
<h3 id="3-层次结构视图"><a href="#3-层次结构视图" class="headerlink" title="3. 层次结构视图"></a>3. 层次结构视图</h3><ul>
<li><strong>组件管理</strong>：展示当前界面中所有组件的层次关系，方便组织和管理。</li>
<li><strong>快速导航</strong>：通过层次结构视图，快速定位并选中特定的界面元素。</li>
</ul>
<h3 id="4-动画和过渡"><a href="#4-动画和过渡" class="headerlink" title="4. 动画和过渡"></a>4. 动画和过渡</h3><ul>
<li><strong>动画编辑器</strong>：可视化地创建和调整动画效果，支持时间轴和关键帧。</li>
<li><strong>状态和过渡</strong>：定义组件的不同状态，并设置状态之间的过渡动画。</li>
</ul>
<h3 id="5-实时预览"><a href="#5-实时预览" class="headerlink" title="5. 实时预览"></a>5. 实时预览</h3><ul>
<li><strong>即时反馈</strong>：无需编译，即可在设计器中实时查看界面效果。</li>
<li><strong>多设备预览</strong>：支持模拟不同设备的屏幕尺寸和分辨率，确保界面自适应性。</li>
</ul>
<h3 id="6-代码与设计视图同步"><a href="#6-代码与设计视图同步" class="headerlink" title="6. 代码与设计视图同步"></a>6. 代码与设计视图同步</h3><ul>
<li><strong>双向编辑</strong>：在设计视图和代码视图之间切换，所有更改都会同步更新。</li>
<li><strong>代码提示</strong>：在代码视图中提供智能提示和自动补全，加速手动编码过程。</li>
</ul>
<hr>
<h2 id="四、使用-Qt-Quick-Designer-的步骤"><a href="#四、使用-Qt-Quick-Designer-的步骤" class="headerlink" title="四、使用 Qt Quick Designer 的步骤"></a>四、使用 Qt Quick Designer 的步骤</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><ul>
<li><strong>新建项目</strong>：在 Qt Creator 中，选择“新建项目”，并选择“Qt Quick 应用程序”模板。</li>
<li><strong>配置项目</strong>：按照向导提示，设置项目名称、位置和其他配置。</li>
</ul>
<h3 id="2-设计界面"><a href="#2-设计界面" class="headerlink" title="2. 设计界面"></a>2. 设计界面</h3><ul>
<li><strong>打开主 QML 文件</strong>：在项目导航器中，找到 <code>Main.qml</code> 文件，双击打开。</li>
<li><strong>切换到设计视图</strong>：在编辑器窗口顶部，选择“设计”选项卡。</li>
</ul>
<h3 id="3-添加和配置组件"><a href="#3-添加和配置组件" class="headerlink" title="3. 添加和配置组件"></a>3. 添加和配置组件</h3><ul>
<li><strong>添加组件</strong>：从组件面板中拖放所需的组件到设计区域。</li>
<li><strong>设置属性</strong>：选中组件，在属性编辑器中调整其属性，如位置、大小、样式等。</li>
</ul>
<h3 id="4-管理组件层次"><a href="#4-管理组件层次" class="headerlink" title="4. 管理组件层次"></a>4. 管理组件层次</h3><ul>
<li><strong>调整层次结构</strong>：在层次结构视图中，通过拖放改变组件的父子关系。</li>
<li><strong>命名组件</strong>：为组件设置 <code>id</code>，方便在代码中引用。</li>
</ul>
<h3 id="5-添加交互和动画"><a href="#5-添加交互和动画" class="headerlink" title="5. 添加交互和动画"></a>5. 添加交互和动画</h3><ul>
<li><strong>定义状态</strong>：在状态编辑器中添加新的状态，描述组件在不同情况下的表现。</li>
<li><strong>创建动画</strong>：使用动画编辑器，为属性变化添加动画效果。</li>
</ul>
<h3 id="6-预览和测试"><a href="#6-预览和测试" class="headerlink" title="6. 预览和测试"></a>6. 预览和测试</h3><ul>
<li><strong>实时预览</strong>：点击预览按钮，查看界面的实时效果。</li>
<li><strong>调试</strong>：使用 Qt Creator 的调试工具，检测和解决潜在的问题。</li>
</ul>
<hr>
<h2 id="五、与代码编辑的结合"><a href="#五、与代码编辑的结合" class="headerlink" title="五、与代码编辑的结合"></a>五、与代码编辑的结合</h2><h3 id="1-代码视图"><a href="#1-代码视图" class="headerlink" title="1. 代码视图"></a>1. 代码视图</h3><ul>
<li><strong>查看代码</strong>：在设计器中，随时切换到代码视图，查看生成的 QML 代码。</li>
<li><strong>手动编辑</strong>：直接在代码中添加逻辑或自定义组件。</li>
</ul>
<h3 id="2-双向同步"><a href="#2-双向同步" class="headerlink" title="2. 双向同步"></a>2. 双向同步</h3><ul>
<li><strong>设计与代码一致性</strong>：所有在设计视图中的更改都会反映到代码视图中，反之亦然。</li>
<li><strong>冲突解决</strong>：当手动编辑的代码无法在设计视图中解析时，设计器会给出提示。</li>
</ul>
<hr>
<h2 id="六、优势与应用场景"><a href="#六、优势与应用场景" class="headerlink" title="六、优势与应用场景"></a>六、优势与应用场景</h2><h3 id="1-提高开发效率"><a href="#1-提高开发效率" class="headerlink" title="1. 提高开发效率"></a>1. 提高开发效率</h3><ul>
<li><strong>快速构建</strong>：拖放式设计减少了手动编码的时间，加快了界面开发速度。</li>
<li><strong>直观性</strong>：所见即所得的编辑方式，使得界面设计更直观。</li>
</ul>
<h3 id="2-降低学习难度"><a href="#2-降低学习难度" class="headerlink" title="2. 降低学习难度"></a>2. 降低学习难度</h3><ul>
<li><strong>适合初学者</strong>：对于不熟悉 QML 或编程的新手，Qt Quick Designer 提供了友好的入门途径。</li>
<li><strong>丰富的组件库</strong>：预定义的组件和样式，降低了设计复杂界面的门槛。</li>
</ul>
<h3 id="3-促进团队协作"><a href="#3-促进团队协作" class="headerlink" title="3. 促进团队协作"></a>3. 促进团队协作</h3><ul>
<li><strong>设计师参与</strong>：界面设计师可以直接使用 Qt Quick Designer 进行原型设计和界面布局。</li>
<li><strong>开发与设计分离</strong>：开发者和设计师可以各自专注于逻辑实现和界面美化。</li>
</ul>
<hr>
<h2 id="七、注意事项"><a href="#七、注意事项" class="headerlink" title="七、注意事项"></a>七、注意事项</h2><h3 id="1-理解生成的代码"><a href="#1-理解生成的代码" class="headerlink" title="1. 理解生成的代码"></a>1. 理解生成的代码</h3><ul>
<li><strong>代码质量</strong>：尽管设计器生成的代码可用，但手动检查和优化代码有助于提高应用性能。</li>
<li><strong>学习 QML</strong>：深入理解 QML 语言，有助于更好地利用 Qt Quick Designer。</li>
</ul>
<h3 id="2-兼容性问题"><a href="#2-兼容性问题" class="headerlink" title="2. 兼容性问题"></a>2. 兼容性问题</h3><ul>
<li><strong>Qt 版本</strong>：确保使用的 Qt Creator 和 Qt 版本与项目需求一致，避免兼容性问题。</li>
<li><strong>平台差异</strong>：在不同平台上测试界面，确保跨平台一致性。</li>
</ul>
<h3 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3. 性能优化"></a>3. 性能优化</h3><ul>
<li><strong>避免过度嵌套</strong>：过深的组件嵌套可能影响性能，需合理组织界面结构。</li>
<li><strong>谨慎使用动画</strong>：大量或复杂的动画效果可能导致性能问题，应适度使用。</li>
</ul>
<hr>
<h2 id="八、结论"><a href="#八、结论" class="headerlink" title="八、结论"></a>八、结论</h2><p>Qt Quick Designer 是开发 Qt Quick 应用程序的强大工具，提供了高效、直观的界面设计方式。通过结合拖放式设计、属性编辑、动画创建和代码同步等功能，它简化了用户界面的开发流程，适合从初学者到资深开发者的各种需求。熟练掌握 Qt Quick Designer，将有助于快速构建高质量的跨平台应用程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Robotics/2024-05-22-robotics_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Robotics/2024-05-22-robotics_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">robotics_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Robotics/" itemprop="url" rel="index"><span itemprop="name">Robotics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>机器人学相关理论基础</li>
</ul>
<h2 id="手眼标定中移动相机的标定是相机坐标系与末端坐标系吗？"><a href="#手眼标定中移动相机的标定是相机坐标系与末端坐标系吗？" class="headerlink" title="手眼标定中移动相机的标定是相机坐标系与末端坐标系吗？"></a>手眼标定中移动相机的标定是相机坐标系与末端坐标系吗？</h2><p>是的，在<strong>移动相机（Eye-in-Hand）</strong>的手眼标定中，<strong>标定的是相机坐标系相对于末端坐标系的变换矩阵</strong>。  </p>
<hr>
<h2 id="1-变换矩阵的定义"><a href="#1-变换矩阵的定义" class="headerlink" title="1. 变换矩阵的定义"></a><strong>1. 变换矩阵的定义</strong></h2><p>在<strong>Eye-in-Hand</strong>（移动相机）手眼标定中，通常涉及以下坐标系：</p>
<ul>
<li><strong>基地坐标系 ( B )</strong>（Base Frame）：固定在机械臂的底座上。</li>
<li><strong>末端坐标系 ( E )</strong>（End-Effector Frame）：固定在机械臂末端（即法兰盘或工具的坐标系）。</li>
<li><strong>相机坐标系 ( C )</strong>（Camera Frame）：相机安装在机械臂末端，与机械臂一起运动。</li>
<li><strong>标定板坐标系 ( W )</strong>（World Frame）：标定板的坐标系，通常固定在环境中的某个已知位置。</li>
</ul>
<p>在手眼标定中，我们要求解：<br>[<br>{}^E T_C<br>]<br>其中：</p>
<ul>
<li><strong>( {}^E T_C )</strong>：<strong>相机坐标系相对于末端坐标系的变换矩阵</strong>，用于描述相机相对于机械臂末端的固定安装位置。</li>
</ul>
<hr>
<h2 id="2-变换关系推导"><a href="#2-变换关系推导" class="headerlink" title="2. 变换关系推导"></a><strong>2. 变换关系推导</strong></h2><p>在<strong>Eye-in-Hand</strong>系统中，物体坐标 ( P_W ) 在不同坐标系中的变换关系如下：<br>[<br>P_B &#x3D; {}^B T_E \cdot {}^E T_C \cdot {}^C T_W \cdot P_W<br>]<br>其中：</p>
<ul>
<li><strong>( {}^B T_E )</strong>：基地坐标系到末端坐标系的变换（已知，来自机械臂的运动学计算）。</li>
<li><strong>( {}^E T_C )</strong>：末端坐标系到相机坐标系的变换（<strong>未知，需要标定</strong>）。</li>
<li><strong>( {}^C T_W )</strong>：相机坐标系到标定板坐标系的变换（可通过相机拍摄标定板计算得出）。</li>
<li><strong>( {}^B T_W )</strong>：基地坐标系到标定板坐标系的变换（已知，通过标定板的固定位置确定）。</li>
</ul>
<p>为了求解<strong>相机相对于末端的安装位姿</strong> ( {}^E T_C )，可以通过以下公式：<br>[<br>{}^E T_C &#x3D; ({}^B T_E)^{-1} \cdot {}^B T_W \cdot ({}^C T_W)^{-1}<br>]</p>
<ul>
<li>机械臂运动提供 ( {}^B T_E )（来自机械臂的位姿反馈）。</li>
<li>视觉检测提供 ( {}^C T_W )（通过相机检测标定板获取）。</li>
<li>物理测量提供 ( {}^B T_W )（标定板位置相对于机械臂基地）。</li>
</ul>
<hr>
<h2 id="3-手眼标定的实现流程"><a href="#3-手眼标定的实现流程" class="headerlink" title="3. 手眼标定的实现流程"></a><strong>3. 手眼标定的实现流程</strong></h2><h3 id="步骤-1：数据采集"><a href="#步骤-1：数据采集" class="headerlink" title="步骤 1：数据采集"></a><strong>步骤 1：数据采集</strong></h3><ul>
<li>让机械臂的末端移动到多个不同的已知姿态 ( {}^B T_E )。</li>
<li>每个姿态下，相机拍摄标定板，获取标定板在相机坐标系下的位姿 ( {}^C T_W )。</li>
</ul>
<h3 id="步骤-2：计算变换矩阵"><a href="#步骤-2：计算变换矩阵" class="headerlink" title="步骤 2：计算变换矩阵"></a><strong>步骤 2：计算变换矩阵</strong></h3><ul>
<li>通过 Tsai-Lenz 方法或最小二乘优化方法，解算 ( {}^E T_C )。</li>
</ul>
<h3 id="步骤-3：验证精度"><a href="#步骤-3：验证精度" class="headerlink" title="步骤 3：验证精度"></a><strong>步骤 3：验证精度</strong></h3><ul>
<li>使用已知的物体位置，验证手眼标定结果是否准确。</li>
</ul>
<hr>
<h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a><strong>4. 结论</strong></h2><p>在<strong>移动相机（Eye-in-Hand）</strong>的手眼标定中，最终求解的是<strong>相机坐标系相对于末端坐标系的变换矩阵 ( {}^E T_C )</strong>，它用于描述相机相对于机械臂末端的固定位置，并用于视觉引导、抓取等任务。</p>
<h2 id="机械臂种的世界坐标系的作用"><a href="#机械臂种的世界坐标系的作用" class="headerlink" title="机械臂种的世界坐标系的作用"></a>机械臂种的世界坐标系的作用</h2><h3 id="机械臂中的世界坐标系的作用"><a href="#机械臂中的世界坐标系的作用" class="headerlink" title="机械臂中的世界坐标系的作用"></a><strong>机械臂中的世界坐标系的作用</strong></h3><p>在机器人学中，<strong>世界坐标系（World Coordinate System, W）</strong>是一个全局参考坐标系，它在机械臂的应用中起着至关重要的作用，主要用于<strong>统一不同坐标系、任务规划、视觉定位</strong>等。  </p>
<hr>
<h2 id="1-世界坐标系的定义"><a href="#1-世界坐标系的定义" class="headerlink" title="1. 世界坐标系的定义"></a><strong>1. 世界坐标系的定义</strong></h2><ul>
<li>世界坐标系 ( W ) 是整个机械臂工作环境中的一个<strong>固定</strong>的全局参考坐标系。</li>
<li>其原点、方向通常根据任务需求确定，例如：<ul>
<li>设定在<strong>机械臂基地坐标系 ( B )</strong> 处，方便对齐机器人本体。</li>
<li>设定在<strong>生产线的某个固定点</strong>，便于多个机器人协作。</li>
<li>设定在<strong>视觉系统的标定板</strong>，以便对接视觉坐标信息。</li>
</ul>
</li>
</ul>
<p>世界坐标系可以通过<strong>齐次变换矩阵</strong> ( {}^W T_X ) 来表示<strong>任何其他坐标系</strong>（如基地坐标系、末端坐标系等）相对于世界坐标系的变换关系。</p>
<hr>
<h2 id="2-世界坐标系的主要作用"><a href="#2-世界坐标系的主要作用" class="headerlink" title="2. 世界坐标系的主要作用"></a><strong>2. 世界坐标系的主要作用</strong></h2><h3 id="2-1-统一不同坐标系"><a href="#2-1-统一不同坐标系" class="headerlink" title="2.1 统一不同坐标系"></a><strong>2.1 统一不同坐标系</strong></h3><p>机械臂系统涉及多个坐标系，如：</p>
<ul>
<li><strong>基地坐标系（Base Frame, B）</strong></li>
<li><strong>末端坐标系（End-Effector Frame, E）</strong></li>
<li><strong>工具坐标系（Tool Frame, T）</strong></li>
<li><strong>相机坐标系（Camera Frame, C）</strong></li>
<li><strong>物体坐标系（Object Frame, O）</strong></li>
</ul>
<p>世界坐标系作为一个全局基准，可以将所有坐标系转换到同一基准下，使它们相互配合。例如：<br>[<br>P_W &#x3D; {}^W T_B \cdot {}^B T_E \cdot {}^E T_T \cdot P_T<br>]<br>这个公式表示：工具坐标系中的某个点 ( P_T ) 经过多次变换后，最终转换到世界坐标系下的点 ( P_W )。</p>
<hr>
<h3 id="2-2-机器人任务规划"><a href="#2-2-机器人任务规划" class="headerlink" title="2.2 机器人任务规划"></a><strong>2.2 机器人任务规划</strong></h3><ul>
<li>在工业应用中，任务点通常在世界坐标系下定义，比如：<ul>
<li>机械臂要在<strong>流水线上某个固定点抓取物体</strong>，该点通常用世界坐标系表示。</li>
<li>焊接任务中的焊点坐标、喷涂任务中的轨迹，都是基于世界坐标系设定的。</li>
</ul>
</li>
<li>通过设定目标点在世界坐标系下的位置 ( P_W )，机械臂可以通过逆运动学计算合适的关节角度去执行任务。</li>
</ul>
<hr>
<h3 id="2-3-视觉引导（手眼协调）"><a href="#2-3-视觉引导（手眼协调）" class="headerlink" title="2.3 视觉引导（手眼协调）"></a><strong>2.3 视觉引导（手眼协调）</strong></h3><ul>
<li><strong>固定相机（Eye-to-Hand）</strong>：相机通常固定在环境中（例如装在一个架子上），它的坐标系需要转换到世界坐标系，以便机械臂理解物体位置。</li>
<li><strong>运动相机（Eye-in-Hand）</strong>：相机安装在机械臂末端，检测到的物体坐标首先是相机坐标系下的，必须转换到世界坐标系，才能进行全局路径规划。</li>
<li>例如，物体在相机坐标系下的位置 ( P_C ) 需要转换到世界坐标系：<br>[<br>P_W &#x3D; {}^W T_C \cdot P_C<br>]<br>这样机械臂就能在世界坐标系中理解目标物体的位置，并进行抓取。</li>
</ul>
<hr>
<h3 id="2-4-多机器人协作"><a href="#2-4-多机器人协作" class="headerlink" title="2.4 多机器人协作"></a><strong>2.4 多机器人协作</strong></h3><ul>
<li>在多机器人协作场景中，每个机械臂通常有自己的<strong>基地坐标系</strong>，但为了让它们协作，需要有一个公共的<strong>世界坐标系</strong>。</li>
<li>例如，两个机械臂协作搬运物体：<ul>
<li>机械臂 A 需要将物体放置到某个世界坐标点 ( P_W )。</li>
<li>机械臂 B 需要从 ( P_W ) 处接住物体。</li>
</ul>
</li>
<li>这种情况下，世界坐标系可以作为统一参考，使两个机械臂的操作无缝对接。</li>
</ul>
<hr>
<h3 id="2-5-机器人路径规划"><a href="#2-5-机器人路径规划" class="headerlink" title="2.5 机器人路径规划"></a><strong>2.5 机器人路径规划</strong></h3><ul>
<li>机器人路径通常是在世界坐标系下定义的，比如：<ul>
<li>让机械臂按照某条轨迹（如直线、圆弧）移动。</li>
<li>进行避障计算，确保路径不会与环境发生碰撞。</li>
</ul>
</li>
<li>通过世界坐标系，机械臂可以从当前姿态 ( {}^W T_E ) 规划一条到达目标位姿 ( {}^W T_{E,goal} ) 的路径。</li>
</ul>
<hr>
<h2 id="3-世界坐标系与其他坐标系的关系"><a href="#3-世界坐标系与其他坐标系的关系" class="headerlink" title="3. 世界坐标系与其他坐标系的关系"></a><strong>3. 世界坐标系与其他坐标系的关系</strong></h2><table>
<thead>
<tr>
<th>坐标系</th>
<th>作用</th>
<th>典型变换</th>
</tr>
</thead>
<tbody><tr>
<td><strong>世界坐标系（W）</strong></td>
<td>统一多个坐标系，定义全局任务</td>
<td>( {}^W T_B ), ( {}^W T_O )</td>
</tr>
<tr>
<td><strong>基地坐标系（B）</strong></td>
<td>机械臂的固定参考点</td>
<td>( {}^B T_E )</td>
</tr>
<tr>
<td><strong>末端坐标系（E）</strong></td>
<td>机械臂末端工具的姿态</td>
<td>( {}^E T_T )</td>
</tr>
<tr>
<td><strong>工具坐标系（T）</strong></td>
<td>机械臂安装的工具（如夹爪）</td>
<td>( {}^T T_O )</td>
</tr>
<tr>
<td><strong>相机坐标系（C）</strong></td>
<td>视觉检测目标的坐标系</td>
<td>( {}^C T_O )</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h2><ul>
<li><strong>世界坐标系是整个机械臂系统的全局参考坐标系</strong>，用于统一不同的局部坐标系。</li>
<li>在<strong>任务规划、视觉定位、多机器人协作、路径规划</strong>等场景中，世界坐标系起到了核心作用。</li>
<li><strong>所有坐标系之间的转换</strong>（如基地、末端、工具、相机）最终都可以统一到世界坐标系，以实现复杂的机器人任务。</li>
</ul>
<p>如果你有具体的应用场景（如视觉引导、机器人抓取等），可以提供更多细节，我可以帮助你进一步优化计算和实现方案！ 🚀</p>
<h2 id="详细解释关节空间和笛卡尔空间"><a href="#详细解释关节空间和笛卡尔空间" class="headerlink" title="详细解释关节空间和笛卡尔空间"></a>详细解释关节空间和笛卡尔空间</h2><h3 id="关节空间（Joint-Space）与笛卡尔空间（Cartesian-Space）详解"><a href="#关节空间（Joint-Space）与笛卡尔空间（Cartesian-Space）详解" class="headerlink" title="关节空间（Joint Space）与笛卡尔空间（Cartesian Space）详解"></a><strong>关节空间（Joint Space）与笛卡尔空间（Cartesian Space）详解</strong></h3><p>在机器人运动学中，机械臂的运动可以用两种不同的方式来描述：<strong>关节空间（Joint Space）</strong>和<strong>笛卡尔空间（Cartesian Space）</strong>。这两种表示方式各有优缺点，适用于不同的运动控制方法。</p>
<hr>
<h2 id="1-关节空间（Joint-Space）"><a href="#1-关节空间（Joint-Space）" class="headerlink" title="1. 关节空间（Joint Space）"></a><strong>1. 关节空间（Joint Space）</strong></h2><p>关节空间是用<strong>机械臂各个关节的角度或位移</strong>来表示机械臂的姿态和位置的方式。</p>
<h3 id="1-1-关节空间的定义"><a href="#1-1-关节空间的定义" class="headerlink" title="1.1 关节空间的定义"></a><strong>1.1 关节空间的定义</strong></h3><p>对于一个具有 ( n ) 个自由度（DOF, Degrees of Freedom）的机械臂，关节空间的状态可以表示为一个 ( n ) 维向量：<br>[<br>\mathbf{q} &#x3D; [q_1, q_2, …, q_n]^T<br>]<br>其中：</p>
<ul>
<li>( q_i ) 是第 ( i ) 个关节的角度（如果是旋转关节）或线性位移（如果是滑动关节）。</li>
<li>这个向量完全描述了机械臂当前的配置。</li>
</ul>
<h3 id="1-2-关节空间的特点"><a href="#1-2-关节空间的特点" class="headerlink" title="1.2 关节空间的特点"></a><strong>1.2 关节空间的特点</strong></h3><ul>
<li>关节空间中的点表示<strong>每个关节的角度或位移</strong>，而不是机械臂末端的物理位置。</li>
<li>机械臂的运动通常由<strong>关节角度插值</strong>控制，而不是直接在三维空间内进行规划。</li>
<li>机械臂的运动受<strong>关节约束</strong>，如角度范围、速度限制、加速度限制等。</li>
</ul>
<h3 id="1-3-关节空间的优缺点"><a href="#1-3-关节空间的优缺点" class="headerlink" title="1.3 关节空间的优缺点"></a><strong>1.3 关节空间的优缺点</strong></h3><p>✅ <strong>优点：</strong></p>
<ul>
<li>直接对应于<strong>机器人驱动系统</strong>，可以更直接地控制关节电机。</li>
<li>运动规划计算简单，关节插值可以平稳执行。</li>
<li>易于避免关节角度限制、奇异点等问题。</li>
</ul>
<p>❌ <strong>缺点：</strong></p>
<ul>
<li>不直观，无法直接确定末端在三维空间中的位置。</li>
<li>可能会导致非直线运动，路径不一定最优。</li>
</ul>
<h3 id="1-4-关节空间的应用"><a href="#1-4-关节空间的应用" class="headerlink" title="1.4 关节空间的应用"></a><strong>1.4 关节空间的应用</strong></h3><ul>
<li><strong>逆运动学（Inverse Kinematics, IK）计算</strong>：给定末端位置，求解对应的关节角度。</li>
<li><strong>关节空间路径规划</strong>：如关节插值运动（Joint Interpolation）。</li>
<li><strong>关节级控制</strong>：如PID控制、力控制等。</li>
</ul>
<hr>
<h2 id="2-笛卡尔空间（Cartesian-Space）"><a href="#2-笛卡尔空间（Cartesian-Space）" class="headerlink" title="2. 笛卡尔空间（Cartesian Space）"></a><strong>2. 笛卡尔空间（Cartesian Space）</strong></h2><p>笛卡尔空间是用<strong>末端执行器的位姿（位置 + 方向）</strong>来描述机械臂的状态的方式。</p>
<h3 id="2-1-笛卡尔空间的定义"><a href="#2-1-笛卡尔空间的定义" class="headerlink" title="2.1 笛卡尔空间的定义"></a><strong>2.1 笛卡尔空间的定义</strong></h3><p>机械臂的末端位姿通常由<strong>位置（Position）</strong>和<strong>方向（Orientation）</strong>两部分组成：<br>[<br>\mathbf{X} &#x3D; [x, y, z, \alpha, \beta, \gamma]^T<br>]<br>其中：</p>
<ul>
<li>( (x, y, z) ) 是末端执行器在世界坐标系或基地坐标系中的三维位置。</li>
<li>( (\alpha, \beta, \gamma) ) 是末端的<strong>欧拉角</strong>（或四元数表示的旋转方向）。</li>
<li>也可以用<strong>齐次变换矩阵（Homogeneous Transformation Matrix）</strong>表示：<br>[<br>T &#x3D;<br>\begin{bmatrix}<br>R &amp; t \<br>0 &amp; 1<br>\end{bmatrix}<br>]<br>其中：<ul>
<li>( R ) 是 ( 3 \times 3 ) 旋转矩阵</li>
<li>( t ) 是 ( 3 \times 1 ) 位置向量</li>
</ul>
</li>
</ul>
<h3 id="2-2-笛卡尔空间的特点"><a href="#2-2-笛卡尔空间的特点" class="headerlink" title="2.2 笛卡尔空间的特点"></a><strong>2.2 笛卡尔空间的特点</strong></h3><ul>
<li><strong>直观</strong>，描述的是机械臂<strong>末端</strong>在三维空间中的实际位置。</li>
<li>机械臂的运动规划可以直接在工作空间中进行。</li>
<li>需要通过<strong>逆运动学（IK）</strong>求解关节角度。</li>
</ul>
<h3 id="2-3-笛卡尔空间的优缺点"><a href="#2-3-笛卡尔空间的优缺点" class="headerlink" title="2.3 笛卡尔空间的优缺点"></a><strong>2.3 笛卡尔空间的优缺点</strong></h3><p>✅ <strong>优点：</strong></p>
<ul>
<li>直观，易于规划路径，例如直线运动、圆弧运动等。</li>
<li>适用于<strong>末端伺服控制</strong>（如视觉伺服）。</li>
<li>可以直接与<strong>外部坐标系（如世界坐标系）</strong>关联，适用于机器人协作。</li>
</ul>
<p>❌ <strong>缺点：</strong></p>
<ul>
<li>机械臂的运动需要求解<strong>逆运动学</strong>（IK），可能导致计算复杂或无解（如奇异点问题）。</li>
<li>可能无法保证运动的可行性（如超出关节运动范围）。</li>
<li>计算复杂度较高，控制上不如关节空间直接。</li>
</ul>
<h3 id="2-4-笛卡尔空间的应用"><a href="#2-4-笛卡尔空间的应用" class="headerlink" title="2.4 笛卡尔空间的应用"></a><strong>2.4 笛卡尔空间的应用</strong></h3><ul>
<li><strong>机器人视觉伺服</strong>（Vision-Based Servoing）</li>
<li><strong>笛卡尔路径规划</strong>（直线运动、插值）</li>
<li><strong>手眼标定</strong>（Hand-Eye Calibration）</li>
<li><strong>力控制任务</strong>（例如焊接、打磨、装配等）</li>
</ul>
<hr>
<h2 id="3-关节空间-vs-笛卡尔空间的对比"><a href="#3-关节空间-vs-笛卡尔空间的对比" class="headerlink" title="3. 关节空间 vs 笛卡尔空间的对比"></a><strong>3. 关节空间 vs 笛卡尔空间的对比</strong></h2><table>
<thead>
<tr>
<th><strong>比较项</strong></th>
<th><strong>关节空间（Joint Space）</strong></th>
<th><strong>笛卡尔空间（Cartesian Space）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>关节角度&#x2F;位移</td>
<td>末端执行器的位置和方向</td>
</tr>
<tr>
<td><strong>描述方式</strong></td>
<td>( q &#x3D; [q_1, q_2, …, q_n]^T )</td>
<td>( X &#x3D; [x, y, z, \alpha, \beta, \gamma]^T )</td>
</tr>
<tr>
<td><strong>计算难度</strong></td>
<td>低（直接控制关节）</td>
<td>高（需要逆运动学求解）</td>
</tr>
<tr>
<td><strong>直观性</strong></td>
<td>低（需要关节角度计算）</td>
<td>高（直接表示末端位置）</td>
</tr>
<tr>
<td><strong>路径控制</strong></td>
<td>关节插值（可能产生曲线）</td>
<td>笛卡尔插值（可以精确控制直线、圆弧）</td>
</tr>
<tr>
<td><strong>控制方式</strong></td>
<td>关节级控制</td>
<td>末端级控制</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>机器人关节运动控制</td>
<td>视觉伺服、直线插值运动</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-关节空间到笛卡尔空间的转换"><a href="#4-关节空间到笛卡尔空间的转换" class="headerlink" title="4. 关节空间到笛卡尔空间的转换"></a><strong>4. 关节空间到笛卡尔空间的转换</strong></h2><p>由于机器人通常接受<strong>关节空间指令</strong>，但任务多在<strong>笛卡尔空间</strong>定义，因此两者之间的转换十分重要。</p>
<h3 id="4-1-关节空间-→-笛卡尔空间（正运动学，FK）"><a href="#4-1-关节空间-→-笛卡尔空间（正运动学，FK）" class="headerlink" title="4.1 关节空间 → 笛卡尔空间（正运动学，FK）"></a><strong>4.1 关节空间 → 笛卡尔空间（正运动学，FK）</strong></h3><p>已知关节角度 ( \mathbf{q} )，求出末端位姿 ( \mathbf{X} )：<br>[<br>\mathbf{X} &#x3D; FK(\mathbf{q})<br>]<br>使用 <strong>Denavit-Hartenberg（DH）参数</strong> 或 <strong>数值计算</strong>方法求解。</p>
<h3 id="4-2-笛卡尔空间-→-关节空间（逆运动学，IK）"><a href="#4-2-笛卡尔空间-→-关节空间（逆运动学，IK）" class="headerlink" title="4.2 笛卡尔空间 → 关节空间（逆运动学，IK）"></a><strong>4.2 笛卡尔空间 → 关节空间（逆运动学，IK）</strong></h3><p>已知末端位姿 ( \mathbf{X} )，求出关节角度 ( \mathbf{q} )：<br>[<br>\mathbf{q} &#x3D; IK(\mathbf{X})<br>]<br>需要求解 <strong>逆运动学（IK）</strong>，可能存在多解、无解或奇异点。</p>
<hr>
<h2 id="5-典型应用案例"><a href="#5-典型应用案例" class="headerlink" title="5. 典型应用案例"></a><strong>5. 典型应用案例</strong></h2><h3 id="案例-1：机器人抓取"><a href="#案例-1：机器人抓取" class="headerlink" title="案例 1：机器人抓取"></a><strong>案例 1：机器人抓取</strong></h3><ul>
<li>目标点通常在<strong>笛卡尔空间</strong>（如相机检测的物体位置）。</li>
<li>需要转换到<strong>关节空间</strong>执行运动。</li>
</ul>
<h3 id="案例-2：机器人焊接"><a href="#案例-2：机器人焊接" class="headerlink" title="案例 2：机器人焊接"></a><strong>案例 2：机器人焊接</strong></h3><ul>
<li>需要沿着直线或曲线焊接（笛卡尔空间路径）。</li>
<li>需要求解逆运动学，将路径转换为关节角度。</li>
</ul>
<hr>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h2><ul>
<li><strong>关节空间（Joint Space）</strong>：直接控制关节角度，计算简单但路径不直观。</li>
<li><strong>笛卡尔空间（Cartesian Space）</strong>：描述末端位置，直观但需要逆运动学计算。</li>
<li><strong>路径规划通常在笛卡尔空间进行</strong>，但最终需要转换到关节空间执行。</li>
<li><strong>两者相互转换是机器人控制的核心技术</strong>。</li>
</ul>
<p>如果你有具体的应用场景（如机器人抓取、焊接等），可以提供更详细的规划和代码示例！ 🚀</p>
<h2 id="详细解释-机械臂末端坐标系与基地坐标系"><a href="#详细解释-机械臂末端坐标系与基地坐标系" class="headerlink" title="详细解释 机械臂末端坐标系与基地坐标系"></a>详细解释 机械臂末端坐标系与基地坐标系</h2><h3 id="机械臂末端坐标系与基地坐标系的详细解释"><a href="#机械臂末端坐标系与基地坐标系的详细解释" class="headerlink" title="机械臂末端坐标系与基地坐标系的详细解释"></a><strong>机械臂末端坐标系与基地坐标系的详细解释</strong></h3><p>在机器人学中，坐标系的定义对于精确控制机械臂的运动至关重要。通常，机械臂涉及多个坐标系，其中<strong>基地坐标系（Base Frame）</strong>和<strong>末端坐标系（End-Effector Frame）</strong>是最重要的两个坐标系，它们用于描述机械臂在空间中的姿态和位置。</p>
<hr>
<h2 id="1-机械臂坐标系的定义"><a href="#1-机械臂坐标系的定义" class="headerlink" title="1. 机械臂坐标系的定义"></a><strong>1. 机械臂坐标系的定义</strong></h2><p>在工业机器人或机械臂系统中，常见的坐标系有：</p>
<ul>
<li><strong>基地坐标系（Base Frame）</strong>：固定在机械臂的底座上，用于定义整个机械臂的参考坐标系。</li>
<li><strong>关节坐标系（Joint Frames）</strong>：每个关节都有一个局部坐标系，跟随关节运动。</li>
<li><strong>末端执行器坐标系（End-Effector Frame）</strong>：固定在机械臂末端（如机械爪、焊枪、相机等）上，描述末端执行器的位置和方向。</li>
<li><strong>世界坐标系（World Frame）</strong>（可选）：如果多个机器人或传送带协作，可能还会定义一个全局的世界坐标系。</li>
</ul>
<p>本次主要讨论 <strong>基地坐标系与末端坐标系</strong>。</p>
<hr>
<h2 id="2-机械臂基地坐标系（Base-Frame）"><a href="#2-机械臂基地坐标系（Base-Frame）" class="headerlink" title="2. 机械臂基地坐标系（Base Frame）"></a><strong>2. 机械臂基地坐标系（Base Frame）</strong></h2><p><strong>基地坐标系（Base Frame）</strong>是整个机械臂的全局参考坐标系，它通常<strong>固定在机械臂的底座上</strong>，不会随关节或末端运动而改变。</p>
<h3 id="基地坐标系的特点："><a href="#基地坐标系的特点：" class="headerlink" title="基地坐标系的特点："></a><strong>基地坐标系的特点：</strong></h3><ul>
<li>是整个机械臂的参考坐标系，所有关节、末端坐标系都基于它进行计算。</li>
<li><strong>固定不动</strong>，不会随机械臂的运动而改变。</li>
<li>通常定义在机械臂的底部，以便有一个稳定的参考点。</li>
<li>用于计算机械臂的正运动学（Forward Kinematics, FK）和逆运动学（Inverse Kinematics, IK）。</li>
</ul>
<h3 id="基地坐标系的定义方式"><a href="#基地坐标系的定义方式" class="headerlink" title="基地坐标系的定义方式"></a><strong>基地坐标系的定义方式</strong></h3><p>通常，基地坐标系的原点设定在机械臂底座的中心，Z 轴朝上或垂直于地面，X 轴和 Y 轴平行于地面，如下所示：</p>
<h4 id="常见的基地坐标系定义（右手坐标系）："><a href="#常见的基地坐标系定义（右手坐标系）：" class="headerlink" title="常见的基地坐标系定义（右手坐标系）："></a><strong>常见的基地坐标系定义（右手坐标系）：</strong></h4><p>[<br>O_b &#x3D; (x_b, y_b, z_b)<br>]</p>
<ul>
<li><strong>X 轴</strong>：向前或沿传送带方向。</li>
<li><strong>Y 轴</strong>：向左或侧向。</li>
<li><strong>Z 轴</strong>：垂直向上，与重力方向相反。</li>
</ul>
<hr>
<h2 id="3-机械臂末端执行器坐标系（End-Effector-Frame）"><a href="#3-机械臂末端执行器坐标系（End-Effector-Frame）" class="headerlink" title="3. 机械臂末端执行器坐标系（End-Effector Frame）"></a><strong>3. 机械臂末端执行器坐标系（End-Effector Frame）</strong></h2><p><strong>末端坐标系（End-Effector Frame）</strong>定义在<strong>机械臂末端（End-Effector）上</strong>，并随机械臂的运动而改变位置和方向。</p>
<h3 id="末端坐标系的特点："><a href="#末端坐标系的特点：" class="headerlink" title="末端坐标系的特点："></a><strong>末端坐标系的特点：</strong></h3><ul>
<li><strong>随机械臂末端运动而变化</strong>，在不同关节角度时，末端坐标系的相对位置和方向也不同。</li>
<li><strong>用于描述机械臂末端工具的位置和姿态</strong>，通常用于编写路径规划、抓取任务等。</li>
<li><strong>需要标定</strong>，特别是安装了焊枪、吸盘、摄像头等工具时，需要知道工具相对于末端坐标系的位置偏移（TCP：Tool Center Point，工具中心点）。</li>
</ul>
<h3 id="末端坐标系的定义方式"><a href="#末端坐标系的定义方式" class="headerlink" title="末端坐标系的定义方式"></a><strong>末端坐标系的定义方式</strong></h3><p>一般情况下，末端坐标系的原点可以放置在：</p>
<ul>
<li>机械爪的中心点（抓取任务）</li>
<li>焊枪的喷嘴位置（焊接任务）</li>
<li>吸盘的中心（搬运任务）</li>
<li>相机的光轴中心（视觉任务）</li>
</ul>
<h4 id="常见的末端坐标系定义："><a href="#常见的末端坐标系定义：" class="headerlink" title="常见的末端坐标系定义："></a><strong>常见的末端坐标系定义：</strong></h4><p>[<br>O_e &#x3D; (x_e, y_e, z_e)<br>]</p>
<ul>
<li><strong>X 轴</strong>：通常指向工具的前方（沿机械爪闭合方向）。</li>
<li><strong>Y 轴</strong>：垂直于X轴，指向左侧或右侧。</li>
<li><strong>Z 轴</strong>：沿着工具的操作方向（通常是指向工具伸出的方向）。</li>
</ul>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a><strong>举例：</strong></h3><p>如果是 <strong>Eye-in-Hand（相机安装在机械臂末端）</strong>：</p>
<ul>
<li>末端坐标系的原点可以放在相机光学中心，Z 轴指向相机拍摄方向。</li>
</ul>
<p>如果是 <strong>机械爪（Gripper）</strong>：</p>
<ul>
<li>末端坐标系的原点通常设在两指机械爪的中心，Z 轴指向机械爪开合方向。</li>
</ul>
<hr>
<h2 id="4-末端坐标系与基地坐标系的关系"><a href="#4-末端坐标系与基地坐标系的关系" class="headerlink" title="4. 末端坐标系与基地坐标系的关系"></a><strong>4. 末端坐标系与基地坐标系的关系</strong></h2><p>要描述末端执行器在空间中的位置，我们需要一个从基地坐标系到末端坐标系的变换矩阵，通常表示为：</p>
<p>[<br>{}^B T_E &#x3D;<br>\begin{bmatrix}<br>R &amp; t \<br>0 &amp; 1<br>\end{bmatrix}<br>]</p>
<p>其中：</p>
<ul>
<li><strong>( {}^B T_E )</strong>：基地坐标系到末端坐标系的齐次变换矩阵</li>
<li><strong>( R )</strong>：( 3 \times 3 ) 的旋转矩阵，描述末端相对于基地的旋转</li>
<li><strong>( t )</strong>：( 3 \times 1 ) 的平移向量，描述末端在基地坐标系下的位置</li>
</ul>
<p>[<br>t &#x3D;<br>\begin{bmatrix}<br>x \<br>y \<br>z<br>\end{bmatrix}<br>]</p>
<p>其中：</p>
<ul>
<li>( x, y, z ) 是末端坐标系相对于基地坐标系的平移量（位置）。</li>
<li>( R ) 是描述末端相对于基地的旋转（通常以欧拉角、四元数或旋转矩阵表示）。</li>
</ul>
<hr>
<h2 id="5-如何计算末端坐标系在基地坐标系下的位置？"><a href="#5-如何计算末端坐标系在基地坐标系下的位置？" class="headerlink" title="5. 如何计算末端坐标系在基地坐标系下的位置？"></a><strong>5. 如何计算末端坐标系在基地坐标系下的位置？</strong></h2><p>通常，我们通过<strong>正运动学（Forward Kinematics, FK）</strong>计算末端坐标系在基地坐标系下的位姿：</p>
<h3 id="计算步骤："><a href="#计算步骤：" class="headerlink" title="计算步骤："></a><strong>计算步骤：</strong></h3><ol>
<li>获取<strong>机械臂的DH参数</strong>（Denavit-Hartenberg参数），用于描述各个关节的旋转和平移。</li>
<li>计算每个关节的<strong>变换矩阵 ( T_i )</strong>，从基座到第 ( i ) 号关节。</li>
<li>通过连乘所有变换矩阵，得到末端相对于基座的最终变换：</li>
</ol>
<p>[<br>{}^B T_E &#x3D; T_1 T_2 T_3 … T_n<br>]</p>
<p>其中：</p>
<ul>
<li>( T_1, T_2, …, T_n ) 是各个关节的变换矩阵。</li>
<li>( {}^B T_E ) 是末端执行器在基地坐标系下的位置和姿态。</li>
</ul>
<hr>
<h2 id="6-末端坐标系与基地坐标系的应用"><a href="#6-末端坐标系与基地坐标系的应用" class="headerlink" title="6. 末端坐标系与基地坐标系的应用"></a><strong>6. 末端坐标系与基地坐标系的应用</strong></h2><ul>
<li><strong>机器人路径规划</strong>：在基地坐标系下规划轨迹，再转换到末端坐标系执行。</li>
<li><strong>手眼标定（Hand-Eye Calibration）</strong>：确定相机坐标系与末端坐标系的关系。</li>
<li><strong>机器人视觉伺服</strong>：相机获取目标物体坐标，并转换到基地坐标系指导机械臂运动。</li>
<li><strong>离线编程</strong>：用CAD软件编写路径，在基地坐标系下转换成末端坐标系的指令。</li>
</ul>
<hr>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h2><ul>
<li><strong>基地坐标系（Base Frame）</strong>：固定在机械臂底座上，是所有关节和末端的参考系。</li>
<li><strong>末端坐标系（End-Effector Frame）</strong>：固定在机械臂的末端执行器上，随机械臂运动而变化。</li>
<li><strong>两者之间的关系</strong>可以通过<strong>正运动学</strong>计算，从而确定末端在基地坐标系下的位姿。</li>
</ul>
<p>如果你有具体的应用场景（如抓取、视觉对位等），可以进一步优化末端坐标系的设置！🚀</p>
<h2 id="机械臂行业"><a href="#机械臂行业" class="headerlink" title="机械臂行业"></a>机械臂行业</h2><ul>
<li><p>机械手臂是一种固定或移动式的机器，其构造通常由一系列互相链接或相对滑动的零件组成，工作方式主要通过沿着X，Y，Z轴上做线性运动以到达目标位置，从而实现物体的抓取或者移动，能够实现自动控制，可重复程序设计，多自由度(轴)</p>
</li>
<li><p>国际企业</p>
<ul>
<li>ABB</li>
<li>发那科</li>
<li>安川电机</li>
<li>ADEPT Technology</li>
<li>UR</li>
</ul>
</li>
<li><p>本土企业</p>
<ul>
<li>新松机器人</li>
<li>埃斯顿</li>
<li>大族激光</li>
<li>越疆科技</li>
<li>埃夫特</li>
<li>汇川技术</li>
<li>新时达</li>
</ul>
</li>
<li><p>机械臂的应用领域</p>
<ul>
<li>工业制造</li>
<li>医疗保健</li>
<li>军事</li>
<li>物流仓储</li>
<li>农业</li>
<li>家庭服务</li>
</ul>
</li>
</ul>
<h2 id="机器人领域-推荐著作"><a href="#机器人领域-推荐著作" class="headerlink" title="机器人领域 推荐著作"></a>机器人领域 推荐著作</h2><ul>
<li><p>机器人学导论</p>
<ul>
<li>综合性入门教材，内容涉及正&#x2F;逆运动学、静力变换、操作臂动力学、轨迹规划、机械设计、控制等。</li>
</ul>
</li>
<li><p>机器人学，机器视觉与控制-MATLAB算法基础</p>
<ul>
<li>Peter Corke编写的机器人入门教材，书中的实例很多，都使用机器人工具箱编写，配合Matlab可以边看边试！</li>
</ul>
</li>
<li><p>Principles of Robot Motion：Theory, Algorithms, and Implementations</p>
<ul>
<li>主要讲解基于传感器的规划、概率规划、定位与映射、动态与非完整系统的运动规划。</li>
</ul>
</li>
<li><p>Planning Algorithms</p>
<ul>
<li>这本书提出了多种不同规划算法的统一处理。运动规划、离散规划、不确定性规划、基于传感器的规划、可见性、决策理论规划、博弈论、信息空间、强化学习、非线性系统、轨迹规划、非完整规划和动态规划</li>
</ul>
</li>
<li><p>Rigid Body Dynamics Algorithms</p>
<ul>
<li>最佳刚体动力学算法的综合集合，Github上也拥有很多不错的资源。</li>
</ul>
</li>
<li><p>机器人操作的数学导论</p>
<ul>
<li>从数学的角度系统地介绍了机器人操作的运动学、动力学、控制及运动规划内容，主要包含旋量理论、指数积建模，机器人动力学等内容</li>
</ul>
</li>
<li><p>机器人学-建模、规划与控制</p>
<ul>
<li>深入讲解机器人的建模、轨迹运动、运动控制等内容。基础入门强烈推荐！</li>
</ul>
</li>
<li><p>机器人技术手册</p>
<ul>
<li>日本机器人学会出品，一本超全的百科全书类型。特别适合作为工具查漏翻查</li>
</ul>
</li>
<li><p>Springer Handbook of Roboticsd</p>
<ul>
<li>机器人研究人员、该领域新人和相关学科学者的权威参考</li>
</ul>
</li>
</ul>
<h2 id="机械臂中的正解FK和逆解IK是什么"><a href="#机械臂中的正解FK和逆解IK是什么" class="headerlink" title="机械臂中的正解FK和逆解IK是什么"></a>机械臂中的正解FK和逆解IK是什么</h2><p>在机械臂控制中，正解（Forward Kinematics，FK）和逆解（Inverse Kinematics，IK）是两个重要的概念。</p>
<ol>
<li><p>正解（Forward Kinematics，FK）：<br>正解是指根据机械臂的关节角度或长度等参数，推导出末端执行器（例如机械臂末端的位置和姿态）的运动学表达式或方程式的过程。FK描述了输入到机械臂关节的位置、速度或加速度等参数，从而计算出末端执行器的位置和姿态。FK用于确定机械臂末端在给定关节参数下的运动轨迹，通常是一个从关节空间到工作空间的映射。</p>
</li>
<li><p>逆解（Inverse Kinematics，IK）：<br>逆解是指根据已知末端执行器的位置和姿态，确定使机械臂末端达到这个位置和姿态所需的关节角度或长度等参数的过程。IK可以被用来解决给定目标位置和姿态时，计算出机械臂关节参数的问题。在实际应用中，逆解通常是更为复杂和困难的问题，因为一个末端位置和姿态通常对应着多个可能的解。</p>
</li>
</ol>
<p>FK和IK在机器人学和机械臂控制中扮演着重要的角色，FK用于描述机械臂的运动学特性，而IK则允许机械臂在空间中实现特定的末端目标。这些概念对于控制和规划机械臂的运动非常重要，特别是在自动化生产线、工业机器人和虚拟仿真等领域中。</p>
<h2 id="机器人-目标坐标系-末端坐标系-基底坐标系"><a href="#机器人-目标坐标系-末端坐标系-基底坐标系" class="headerlink" title="机器人 目标坐标系 末端坐标系 基底坐标系"></a>机器人 目标坐标系 末端坐标系 基底坐标系</h2><p>在机器人学中，通常使用三种坐标系来描述机器人的运动和位置：目标坐标系、末端坐标系和基底坐标系。</p>
<ol>
<li><p><strong>目标坐标系（Target Coordinate System）：</strong> 这是机器人执行任务时所需达到的目标位置的坐标系。在目标坐标系中定义了机器人需要完成的具体任务的坐标和方向信息。机器人的动作控制通常是根据目标坐标系来规划和执行的。</p>
</li>
<li><p><strong>末端坐标系（End-Effector Coordinate System）：</strong> 这是机器人末端执行器（通常是机械手、夹爪等）的坐标系。末端坐标系描述了末端执行器的位置和方向，是机器人进行具体操作时的参考坐标系。机器人执行任务时，末端坐标系的变化反映了机器人末端执行器的运动和姿态。</p>
</li>
<li><p><strong>基底坐标系（Base Coordinate System）：</strong> 这是机器人整体结构的参考坐标系。基底坐标系通常与机器人的固定部分（例如机器人底座）相关联，用于描述机器人整体的位置和方向。基底坐标系的选择对机器人运动的规划和控制起着重要的作用。</p>
</li>
</ol>
<p>这三个坐标系之间的关系和转换是机器人控制和规划中的关键问题。通过准确描述这些坐标系之间的变换关系，可以更有效地控制机器人的运动，使其在工作空间内完成任务。</p>
<h2 id="机器人-世界坐标系-基底坐标系"><a href="#机器人-世界坐标系-基底坐标系" class="headerlink" title="机器人 世界坐标系 基底坐标系"></a>机器人 世界坐标系 基底坐标系</h2><p>在机器人学中，世界坐标系和基底坐标系是两个相关但不同的概念。</p>
<ol>
<li><p><strong>世界坐标系（World Coordinate System）：</strong> 世界坐标系是一个全局坐标系，通常被用作机器人工作空间中的参考坐标系。它是一个固定的坐标系，用于描述整个机器人系统在其运动范围内的位置和方向。世界坐标系的选择通常取决于特定应用的需要，以提供方便的参考点。</p>
</li>
<li><p><strong>基底坐标系（Base Coordinate System）：</strong> 基底坐标系是机器人本身固有的坐标系，通常与机器人底座或底部连接的结构相关联。这是机器人运动的起点和参考点。机器人的关节和执行器运动通常是相对于基底坐标系进行描述的。基底坐标系的选择对机器人的运动规划和控制非常重要。</p>
</li>
</ol>
<p>在一般情况下，机器人控制和规划涉及到将基底坐标系中的运动转换到世界坐标系中，或者反之。这涉及到位姿变换，包括平移和旋转。</p>
<p>例如，如果你想让机器人执行一个在世界坐标系中指定的任务，你可能需要将任务的坐标转换为机器人基底坐标系中的坐标，以便机器人能够正确执行任务。反之，如果你想获取机器人当前的位置和方向，你可能需要将机器人基底坐标系中的信息转换为世界坐标系中的信息，以便提供一个全局的参考框架。</p>
<p>这种坐标系的变换在机器人学和自动化控制中是非常常见的，因为它允许机器人在不同坐标系中进行运动和交互。</p>
<h2 id="机器人-轨迹规划是什么"><a href="#机器人-轨迹规划是什么" class="headerlink" title="机器人 轨迹规划是什么"></a>机器人 轨迹规划是什么</h2><p>在机器人学和自动化领域，轨迹规划是指通过一系列的动作，规划出机器人从一个起始点到达目标点或完成任务的路径。这个路径通常被称为轨迹，而规划这样的轨迹则需要考虑一系列的因素，如避障、动力学、工作空间限制等。</p>
<p>轨迹规划的目标是使机器人能够在给定的环境中，以安全、有效、并且可能最优的方式达到目标。以下是轨迹规划的一些关键概念：</p>
<ol>
<li><p><strong>起始点和目标点：</strong> 轨迹规划通常始于机器人当前的位置（起始点）并以某个目标位置为终点。</p>
</li>
<li><p><strong>运动约束：</strong> 考虑到机器人的动力学、速度、加速度等方面的限制，确保规划出的轨迹是机器人能够执行的。</p>
</li>
<li><p><strong>避障：</strong> 考虑到环境中的障碍物，确保规划的轨迹不会碰撞到障碍物。这可能涉及到路径规划算法，例如 A*、Dijkstra、RRT（Rapidly Exploring Random Trees）等。</p>
</li>
<li><p><strong>工作空间：</strong> 考虑到机器人工作的空间限制，确保规划的轨迹在工作空间内。</p>
</li>
<li><p><strong>优化：</strong> 有时候，除了满足上述条件，还希望规划出的轨迹是最优的，例如最短路径或最短时间。</p>
</li>
<li><p><strong>实时性：</strong> 在某些情况下，轨迹规划需要在实时性要求下执行，以适应不断变化的环境。</p>
</li>
</ol>
<p>轨迹规划可以应用于各种类型的机器人，包括工业机械臂、移动机器人、飞行器等。不同类型的机器人可能需要不同的轨迹规划方法，因为它们的动力学和环境条件可能有很大的差异。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Robotics/2024-05-22-robotics_2_%E4%BB%BF%E7%9C%9F%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Robotics/2024-05-22-robotics_2_%E4%BB%BF%E7%9C%9F%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">robotics_2_仿真工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Robotics/" itemprop="url" rel="index"><span itemprop="name">Robotics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>机器人学的仿真工具</li>
</ul>
<h2 id="机器人仿真-robodk是什么"><a href="#机器人仿真-robodk是什么" class="headerlink" title="机器人仿真 robodk是什么"></a>机器人仿真 robodk是什么</h2><p>RoboDK（Robot Development Kit）是一种用于机器人仿真和离线编程的软件平台。它允许用户在虚拟环境中模拟和测试工业机器人的运动，以及为这些机器人生成程序代码。RoboDK支持多种不同类型的工业机器人，包括ABB、Fanuc、KUKA、Universal Robots等。</p>
<p>主要功能包括：</p>
<ol>
<li><p><strong>机器人仿真：</strong> 用户可以在RoboDK中创建一个虚拟环境，包括工作台、机器人和其他相关设备。通过仿真，用户可以预先测试和优化机器人的运动，避免在实际生产中出现问题。</p>
</li>
<li><p><strong>离线编程：</strong> RoboDK允许用户在虚拟环境中为机器人生成程序代码，然后将这些代码直接应用到实际的机器人系统中。这种离线编程的方法可以减少生产线的停机时间，提高生产效率。</p>
</li>
<li><p><strong>支持多种机器人品牌：</strong> RoboDK具有广泛的机器人品牌支持，使其适用于多种不同类型的工业机器人。用户可以选择并模拟其特定品牌和型号的机器人。</p>
</li>
<li><p><strong>路径规划和碰撞检测：</strong> RoboDK能够进行路径规划和碰撞检测，确保生成的机器人程序在实际操作中是安全和有效的。</p>
</li>
</ol>
<p>总的来说，RoboDK是一个用于机器人系统仿真和离线编程的强大工具，可帮助用户优化他们的制造流程，提高生产效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-Postgresql_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-Postgresql_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Postgresql_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>PostgresQL 关系型数据库</li>
</ul>
<h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><ul>
<li>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</li>
<li>每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。</li>
<li>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。</li>
<li>所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数+ 据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</li>
<li>ORDBMS（对象关系数据库系统）是面向对象技术与传统的关系数据库相结合的产物，查询处理是 ORDBMS 的重要组成部分，它的性能+ 优劣将直接影响到DBMS 的性能。</li>
<li>ORDBMS在原来关系数据库的基础上，增加了一些新的特性。</li>
<li>RDBMS 是关系数据库管理系统，是建立实体之间的联系，最后得到的是关系表。</li>
<li>OODBMS 面向对象数据库管理系统，将所有实体都看成对象，并将这些对象类进行封装，对象之间的通信通过消息 OODBMS 对象关系数据库在实质上还是关系数据库</li>
</ul>
<h2 id="ORDBMS-术语"><a href="#ORDBMS-术语" class="headerlink" title="ORDBMS 术语"></a>ORDBMS 术语</h2><ul>
<li>在我们开始学习 PostgreSQL 数据库前，让我们先了解下 ORDBMS 的一些术语：<ul>
<li>数据库: 数据库是一些关联表的集合。</li>
<li>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li>
<li>列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li>
<li>行：一行（&#x3D;元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li>
<li>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li>
<li>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
<li>外键：外键用于关联两个表。</li>
<li>复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>
<li>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
<li>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数+ 据的一致性。</li>
</ul>
</li>
</ul>
<h2 id="PostgreSQL-特征"><a href="#PostgreSQL-特征" class="headerlink" title="PostgreSQL 特征"></a>PostgreSQL 特征</h2><ul>
<li>函数：通过函数，可以在数据库服务器端执行指令程序。</li>
<li>索引：用户可以自定义索引方法，或使用内置的 B 树，哈希表与 GiST 索引。</li>
<li>触发器：触发器是由SQL语句查询所触发的事件。如：一个INSERT语句可能触发一个检查数据完整性的触发器。触发器通常由INSERT或UPDATE语句触发。 多版本并发控制：PostgreSQL使用多版本并发控制（MVCC，Multiversion concurrency control）系统进行并发控制，该系统向每个用户提供了一个数据库的”快照”，用户在事务内所作的每个修改，对于其他的用户都不可见，直到该事务成功提交。</li>
<li>规则：规则（RULE）允许一个查询能被重写，通常用来实现对视图（VIEW）的操作，如插入（INSERT）、更新（UPDATE）、删除（DELETE）。</li>
<li>数据类型：包括文本、任意精度的数值数组、JSON 数据、枚举类型、XML 数据等。</li>
<li>全文检索：通过 Tsearch2 或 OpenFTS，8.3版本中内嵌 Tsearch2。</li>
<li>NoSQL：JSON，JSONB，XML，HStore 原生支持，至 NoSQL 数据库的外部数据包装器。</li>
<li>数据仓库：能平滑迁移至同属 PostgreSQL 生态的 GreenPlum，DeepGreen，HAWK 等，使用 FDW 进行 ETL。</li>
</ul>
<h2 id="Linux-上安装-PostgreSQL-Ubuntu-安装-PostgreSQL"><a href="#Linux-上安装-PostgreSQL-Ubuntu-安装-PostgreSQL" class="headerlink" title="Linux 上安装 PostgreSQL (Ubuntu 安装 PostgreSQL)"></a>Linux 上安装 PostgreSQL (Ubuntu 安装 PostgreSQL)</h2><ul>
<li><p>Ubuntu 可以使用 apt-get 安装 PostgreSQL：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install postgresql postgresql-client</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完毕后，系统会创建一个数据库超级用户 postgres，密码为空。</p>
<ul>
<li><h1 id="sudo-i-u-postgres"><a href="#sudo-i-u-postgres" class="headerlink" title="sudo -i -u postgres"></a>sudo -i -u postgres</h1></li>
</ul>
</li>
<li><p>这时使用以下命令进入 postgres，输出以下信息，说明安装成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$ psql</span><br><span class="line">psql (9.5.17)</span><br><span class="line">Type <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">postgres=# </span><br></pre></td></tr></table></figure></li>
<li><p>输入以下命令退出 PostgreSQL 提示符：</p>
<ul>
<li>\q</li>
</ul>
</li>
<li><p>PostgreSQL 安装完成后默认是已经启动的，但是也可以通过下面的方式来手动启动服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> /etc/init.d/postgresql start   <span class="comment"># 开启</span></span><br><span class="line"><span class="built_in">sudo</span> /etc/init.d/postgresql stop    <span class="comment"># 关闭</span></span><br><span class="line"><span class="built_in">sudo</span> /etc/init.d/postgresql restart <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sql_2_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sql_2_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">sql_2_基本语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sql编程语言的基本语法</li>
</ul>
<h2 id="1-3-SQL-SELECT语句"><a href="#1-3-SQL-SELECT语句" class="headerlink" title="1.3 SQL SELECT语句"></a>1.3 SQL SELECT语句</h2><ul>
<li><p>SELECT 语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。</p>
</li>
<li><p>SQL SELECT 语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>SELECT * FROM table_name;</code></li>
</ul>
</li>
<li><p>参数说明：</p>
<ul>
<li>column1, column2, …：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。</li>
<li>table_name：要查询的表名称。</li>
</ul>
</li>
<li><p>大多数数据库软件系统都允许使用编程函数在结果集中进行导航，比如：Move-To-First-Record、Get-Record-Content、Move-To-Next-Record 等等。</p>
</li>
<li><p>类似这些编程函数不在本教程讲解之列。如需学习通过函数调用访问数据的知识，请访问我们的 ADO 教程 或者 PHP 教程。</p>
</li>
</ul>
<h2 id="1-3-SQL-SELECT-DISTINCT-语句"><a href="#1-3-SQL-SELECT-DISTINCT-语句" class="headerlink" title="1.3 SQL SELECT DISTINCT 语句"></a>1.3 SQL SELECT DISTINCT 语句</h2><ul>
<li><p>SELECT DISTINCT 语句用于返回唯一不同的值。</p>
</li>
<li><p>在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值。</p>
</li>
<li><p>SQL SELECT DISTINCT 语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></li>
<li><p>参数说明：</p>
<ul>
<li>column1, column2, …：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。</li>
<li>table_name：要查询的表名称。</li>
</ul>
</li>
<li><p>SELECT DISTINCT 实例</p>
<ul>
<li>下面的 SQL 语句仅从 “Websites” 表的 “country” 列中选取唯一不同的值，也就是去掉 “country” 列重复值：</li>
<li><code>SELECT DISTINCT country FROM Websites;</code></li>
</ul>
</li>
</ul>
<h2 id="1-3-SQL-WHERE-子句"><a href="#1-3-SQL-WHERE-子句" class="headerlink" title="1.3 SQL WHERE 子句"></a>1.3 SQL WHERE 子句</h2><ul>
<li><p>WHERE 子句用于过滤记录。</p>
</li>
<li><p>WHERE 子句用于提取那些满足指定条件的记录。</p>
</li>
<li><p>SQL WHERE 语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>参数说明：</p>
<ul>
<li>column1, column2, …：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。</li>
<li>table_name：要查询的表名称。</li>
</ul>
</li>
<li><p>WHERE 子句实例</p>
<ul>
<li>下面的 SQL 语句从 “Websites” 表中选取国家为 “CN” 的所有网站：</li>
<li><code>SELECT * FROM Websites WHERE country=&#39;CN&#39;;</code></li>
</ul>
</li>
</ul>
<h2 id="1-4-SQL-AND-OR-运算符"><a href="#1-4-SQL-AND-OR-运算符" class="headerlink" title="1.4 SQL AND &amp; OR 运算符"></a>1.4 SQL AND &amp; OR 运算符</h2><ul>
<li><p>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。</p>
</li>
<li><p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p>
</li>
<li><p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>
</li>
<li><p>AND 运算符实例</p>
<ul>
<li>下面的 SQL 语句从 “Websites” 表中选取国家为 “CN” 且alexa排名大于 “50” 的所有网站：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> alexa <span class="operator">&gt;</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>OR 运算符实例</p>
<ul>
<li>下面的 SQL 语句从 “Websites” 表中选取国家为 “USA” 或者 “CN” 的所有客户：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span></span><br><span class="line"><span class="keyword">OR</span> country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>结合 AND &amp; OR</p>
<ul>
<li>您也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）。</li>
<li>下面的 SQL 语句从 “Websites” 表中选取 alexa 排名大于 “15” 且国家为 “CN” 或 “USA” 的所有网站：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> alexa <span class="operator">&gt;</span> <span class="number">15</span></span><br><span class="line"><span class="keyword">AND</span> (country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span> <span class="keyword">OR</span> country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-5-SQL-ORDER-BY-关键字"><a href="#1-5-SQL-ORDER-BY-关键字" class="headerlink" title="1.5 SQL ORDER BY 关键字"></a>1.5 SQL ORDER BY 关键字</h2><ul>
<li><p>ORDER BY 关键字用于对结果集进行排序。</p>
</li>
<li><p>ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。</p>
</li>
<li><p>ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p>
</li>
<li><p>SQL ORDER BY 语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2, ... <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>参数解析：</p>
<ul>
<li>column1, column2, …：要排序的字段名称，可以为多个字段。</li>
<li>ASC：表示按升序排序。</li>
<li>DESC：表示按降序排序。</li>
</ul>
</li>
<li><p>ORDER BY 实例</p>
<ul>
<li>下面的 SQL 语句从 “Websites” 表中选取所有网站，并按照 “alexa” 列排序：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> alexa;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ORDER BY DESC 实例</p>
<ul>
<li>下面的 SQL 语句从 “Websites” 表中选取所有网站，并按照 “alexa” 列降序排序：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> alexa <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ORDER BY 多列</p>
<ul>
<li>下面的 SQL 语句从 “Websites” 表中选取所有网站，并按照 “country” 和 “alexa” 列排序：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> country,alexa;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-5-SQL-INSERT-INTO-语句"><a href="#1-5-SQL-INSERT-INTO-语句" class="headerlink" title="1.5 SQL INSERT INTO 语句"></a>1.5 SQL INSERT INTO 语句</h2><ul>
<li><p>INSERT INTO 语句用于向表中插入新记录。</p>
</li>
<li><p>INSERT INTO 语句可以有两种编写形式。</p>
<ul>
<li>第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure></li>
<li>第二种形式需要指定列名及被插入的值：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name (column1,column2,column3,...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>参数说明：</p>
<ul>
<li>table_name：需要插入新记录的表名。</li>
<li>column1, column2, …：需要插入的字段名。</li>
<li>value1, value2, …：需要插入的字段值。</li>
</ul>
</li>
<li><p>INSERT INTO 实例</p>
<ul>
<li>假设我们要向 “Websites” 表中插入一个新行。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> Websites (name, url, alexa, country)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;百度&#x27;</span>,<span class="string">&#x27;https://www.baidu.com/&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;CN&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>在指定的列插入数据</li>
<li>下面的 SQL 语句将插入一个新行，但是只在 “name”、”url” 和 “country” 列插入数据（id 字段会自动更新）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> Websites (name, url, country)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;stackoverflow&#x27;</span>, <span class="string">&#x27;http://stackoverflow.com/&#x27;</span>, <span class="string">&#x27;IND&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-6-SQL-UPDATE-语句"><a href="#1-6-SQL-UPDATE-语句" class="headerlink" title="1.6 SQL UPDATE 语句"></a>1.6 SQL UPDATE 语句</h2><ul>
<li><p>UPDATE 语句用于更新表中的记录。</p>
</li>
<li><p>UPDATE 语句用于更新表中已存在的记录。</p>
</li>
<li><p>SQL UPDATE 语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET column1 = value1, column2 = value2, ...</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure></li>
<li><p>参数说明：</p>
<ul>
<li>table_name：要修改的表名称。</li>
<li>column1, column2, …：要修改的字段名称，可以为多个字段。</li>
<li>value1, value2, …：要修改的值，可以为多个值。</li>
<li>condition：修改条件，用于指定哪些数据要修改</li>
</ul>
</li>
<li><p>请注意 SQL UPDATE 语句中的 WHERE 子句！</p>
</li>
<li><p>WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE 子句，所有的记录都将被更新！</p>
</li>
<li><p>SQL UPDATE 实例</p>
<ul>
<li>假设我们要把 “菜鸟教程” 的 alexa 排名更新为 5000，country 改为 USA。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Websites </span><br><span class="line"><span class="keyword">SET</span> alexa<span class="operator">=</span><span class="string">&#x27;5000&#x27;</span>, country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;菜鸟教程&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-7-SQL-DELETE-语句"><a href="#1-7-SQL-DELETE-语句" class="headerlink" title="1.7 SQL DELETE 语句"></a>1.7 SQL DELETE 语句</h2><ul>
<li><p>DELETE 语句用于删除表中的记录。</p>
</li>
<li><p>DELETE 语句用于删除表中的行。</p>
</li>
<li><p>SQL DELETE 语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>参数说明：</p>
<ul>
<li>table_name：要删除的表名称。</li>
<li>condition：删除条件，用于指定哪些数据要删除</li>
</ul>
</li>
<li><p>SQL DELETE 实例</p>
<ul>
<li>假设我们要从 “Websites” 表中删除网站名为 “Facebook” 且国家为 USA 的网站。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;Facebook&#x27;</span> <span class="keyword">AND</span> country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>删除所有数据</p>
<ul>
<li>您可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：</li>
<li><code>DELETE FROM table_name;</code></li>
</ul>
</li>
</ul>
<h2 id="sql-常用语句"><a href="#sql-常用语句" class="headerlink" title="sql 常用语句"></a>sql 常用语句</h2><p>SQL（Structured Query Language）是一种用于管理关系型数据库的编程语言。下面是一些SQL编程语言中常用的语句：</p>
<ol>
<li><p>数据库操作语句：</p>
<ul>
<li>创建数据库：<code>CREATE DATABASE database_name;</code></li>
<li>删除数据库：<code>DROP DATABASE database_name;</code></li>
<li>切换数据库：<code>USE database_name;</code></li>
</ul>
</li>
<li><p>表操作语句：</p>
<ul>
<li>创建表：<code>CREATE TABLE table_name (column1 datatype, column2 datatype, ...);</code></li>
<li>删除表：<code>DROP TABLE table_name;</code></li>
<li>修改表结构：<code>ALTER TABLE table_name ADD column_name datatype;</code></li>
</ul>
</li>
<li><p>数据操作语句：</p>
<ul>
<li>插入数据：<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);</code></li>
<li>更新数据：<code>UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition;</code></li>
<li>删除数据：<code>DELETE FROM table_name WHERE condition;</code></li>
<li>查询数据：<code>SELECT column1, column2, ... FROM table_name WHERE condition;</code></li>
</ul>
</li>
<li><p>数据过滤语句：</p>
<ul>
<li>条件过滤：使用WHERE子句进行条件筛选，例如：<code>WHERE column_name = value</code>。</li>
<li>范围过滤：使用BETWEEN和IN进行范围筛选，例如：<code>WHERE column_name BETWEEN value1 AND value2</code>。</li>
<li>模糊搜索：使用LIKE进行模糊匹配，例如：<code>WHERE column_name LIKE &#39;%value%&#39;</code>。</li>
</ul>
</li>
<li><p>数据排序和限制语句：</p>
<ul>
<li>排序数据：使用ORDER BY子句对结果进行排序，例如：<code>ORDER BY column_name ASC/DESC</code>。</li>
<li>限制结果：使用LIMIT子句限制结果集的数量，例如：<code>LIMIT n</code>。</li>
</ul>
</li>
<li><p>数据聚合和统计语句：</p>
<ul>
<li>聚合函数：使用聚合函数对数据进行计算，如COUNT、SUM、AVG、MIN、MAX等，例如：<code>SELECT COUNT(*) FROM table_name</code>。</li>
<li>分组数据：使用GROUP BY子句对结果进行分组，例如：<code>GROUP BY column_name</code>。</li>
<li>过滤分组：使用HAVING子句对分组结果进行过滤，例如：<code>HAVING condition</code>。</li>
</ul>
</li>
</ol>
<p>这些是SQL编程语言中常用的一些语句，可以用于创建和管理数据库、操作数据、查询数据和进行数据分析。具体的语法和用法可能会根据数据库管理系统的不同而有所差异，因此在实际使用时需要参考相应的数据库文档和语法规范。</p>
<hr>
<h2 id="ORDER-详解"><a href="#ORDER-详解" class="headerlink" title="ORDER 详解"></a>ORDER 详解</h2><p>在SQL中，ORDER BY子句用于对查询结果进行排序。它可以按照一个或多个列的值进行升序（ASC）或降序（DESC）排序。以下是ORDER BY子句的详细解释：</p>
<p>基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], column2 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...;</span><br></pre></td></tr></table></figure>

<ul>
<li>SELECT：用于指定要查询的列。</li>
<li>FROM：用于指定要查询的表名。</li>
<li>ORDER BY：用于指定排序规则。</li>
<li>column1, column2, …：要按照其值进行排序的列名。</li>
<li>ASC：升序排列（默认值）。</li>
<li>DESC：降序排列。</li>
</ul>
<p>示例：<br>假设有一个名为”employees”的表，包含以下列：id、name和salary。我们将使用该表作为示例来说明ORDER BY的使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>上述示例将返回按照salary列的值降序排列的结果集。结果集中的记录将按照salary的值从高到低排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> name <span class="keyword">ASC</span>, salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>上述示例将返回首先按照name列的值升序排列，如果name相同，则按照salary列的值降序排列的结果集。</p>
<p>需要注意的是，ORDER BY子句的位置应该位于查询语句的最后，以便在执行排序之前获取查询结果。</p>
<p>ORDER BY子句在SQL中非常有用，它使我们能够按照特定的列或多个列对查询结果进行排序，以满足特定的排序需求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sql_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sql_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">sql_3_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sql语法常用技巧</li>
</ul>
<h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><p>在SQL中，您可以使用<code>DELETE</code>语句来删除数据。要实现批量删除，您可以使用<code>DELETE</code>语句结合适当的条件或子查询来删除符合特定条件的多个记录。以下是一些示例：</p>
<ol>
<li><p>删除符合条件的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>
<p>将<code>table_name</code>替换为要删除记录的表名，<code>condition</code>替换为符合删除条件的条件表达式。</p>
</li>
<li><p>删除来自另一个查询的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> another_table <span class="keyword">WHERE</span> <span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure>
<p>这将删除从另一个查询结果中选择的记录。将<code>table_name</code>替换为要删除记录的表名，<code>column_name</code>替换为要匹配的列名，<code>another_table</code>替换为另一个查询的表名，<code>condition</code>替换为适当的条件。</p>
</li>
<li><p>删除所有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p>这将删除指定表中的所有记录。将<code>table_name</code>替换为要删除记录的表名。</p>
</li>
</ol>
<p>请注意，在执行批量删除操作时要谨慎。确保您理解删除操作的影响，并在执行之前备份重要数据。</p>
<p>希望这些示例能帮助您理解如何在SQL中进行批量删除。如有其他问题，请随时提问。</p>
<h2 id="查询某个表单有多少条记录"><a href="#查询某个表单有多少条记录" class="headerlink" title="查询某个表单有多少条记录"></a>查询某个表单有多少条记录</h2><ul>
<li><code>select count(*) from table_name;</code></li>
</ul>
<h3 id="mysql-5-7-不用密码也能登录的问题"><a href="#mysql-5-7-不用密码也能登录的问题" class="headerlink" title="mysql 5.7 不用密码也能登录的问题"></a>mysql 5.7 不用密码也能登录的问题</h3><ul>
<li>在ubuntu下载mysql后，用mysql命令就可以直接登录数据库了，这是因为在mysql.user表里有个plugin的字段，root这个用户的值是auth_socket, 需要把它改成mysql_native_password。</li>
<li>具体步骤如下：<ul>
<li><code>use mysql;</code></li>
<li><code>update user set authentication_string=PASSWORD(&quot;密码&quot;) where user=‘root‘;</code></li>
<li><code>update user set plugin=&quot;mysql_native_password&quot;; </code></li>
<li><code>flush privileges;</code></li>
<li><code>quit;</code></li>
</ul>
</li>
</ul>
<h2 id="SQL-脚本"><a href="#SQL-脚本" class="headerlink" title="SQL 脚本"></a>SQL 脚本</h2><ul>
<li>像编写shell脚本一样，只不过语句换成了SQL语句</li>
<li>编写完成之后，通过mysql -u root -p password 进入到sql命令窗口，执行指令<code>source /sql.sh</code>执行sql脚本</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sqlite3_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sqlite3_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">sqlite3_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sqlite3 理论知识相关笔记</li>
</ul>
<h2 id="SQLite-简介"><a href="#SQLite-简介" class="headerlink" title="SQLite 简介"></a>SQLite 简介</h2><ul>
<li><p>SQLite是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite是一个增长最快的数据库引擎，这是在普及方面的增长，与它的尺寸大小无关。SQLite 源代码不受版权限制</p>
</li>
<li><p>什么是SQLite</p>
<ul>
<li>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库不一样，您不需要在系统中配置。</li>
<li>就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件</li>
</ul>
</li>
<li><p>为什么要用SQLite</p>
<ul>
<li>不需要一个单独的服务器进程或操作的系统（无服务器的）。</li>
<li>SQLite 不需要配置，这意味着不需要安装或管理。</li>
<li>一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。</li>
<li>SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。</li>
<li>SQLite 是自给自足的，这意味着不需要任何外部的依赖。</li>
<li>SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。</li>
<li>SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。</li>
<li>SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。</li>
<li>SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。</li>
</ul>
</li>
<li><p>SQLite 命令</p>
<ul>
<li>与关系数据库进行交互的标准 SQLite 命令类似于 SQL。命令包括 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP。这些命令基于它们的操作性质可分为以下几种：</li>
<li>DDL - 数据定义语言<ul>
<li>CREATE : 创建一个新的表，一个表的视图，或者数据库中的其他对象。</li>
<li>ALERT  : 修改数据库中的某个已有的数据库对象，比如一个表。</li>
<li>DROP   : 删除整个表，或者表的视图，或者数据库中的其他对象。</li>
</ul>
</li>
<li>DML - 数据操作语言<ul>
<li>INSERT : 创建一条记录</li>
<li>UPDATE : 修改记录</li>
<li>DELETE : 删除记录</li>
</ul>
</li>
<li>DQL - 数据查询语言<ul>
<li>SELECT : 从一个或多个表中检索某些记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SQLite-命令"><a href="#SQLite-命令" class="headerlink" title="SQLite 命令"></a>SQLite 命令</h2><ul>
<li>本章将向您讲解 SQLite 编程人员所使用的简单却有用的命令。这些命令被称为 SQLite 的点命令，这些命令的不同之处在于它们不以分号 ; 结束。</li>
<li>如需获取可用的点命令的清单，可以在任何时候输入 “.help”。例如：<ul>
<li>sqlite&gt;.help</li>
</ul>
</li>
<li>.backup ?DB? FILE	<ul>
<li>备份 DB 数据库（默认是 “main”）到 FILE 文件。</li>
</ul>
</li>
<li>.bail ON|<ul>
<li>OFF	</li>
<li>发生错误后停止。默认为 OFF。</li>
</ul>
</li>
<li>.databases	<ul>
<li>列出数据库的名称及其所依附的文件。</li>
</ul>
</li>
<li>.dump ?TABLE?	<ul>
<li>以 SQL 文本格式转储数据库。如果指定了 TABLE 表，则只转储匹配 LIKE 模式的 TABLE 表。</li>
</ul>
</li>
<li>.echo ON|OFF	<ul>
<li>开启或关闭 echo 命令。</li>
</ul>
</li>
<li>.exit	<ul>
<li>退出 SQLite 提示符。</li>
</ul>
</li>
<li>.explain ON|OFF	<ul>
<li>开启或关闭适合于 EXPLAIN 的输出模式。如果没有带参数，则为 EXPLAIN on，即开启 EXPLAIN。</li>
</ul>
</li>
<li>.header(s) ON|OFF	<ul>
<li>开启或关闭头部显示。</li>
</ul>
</li>
<li>.help	<ul>
<li>显示消息。</li>
</ul>
</li>
<li>.import FILE TABLE	<ul>
<li>导入来自 FILE 文件的数据到 TABLE 表中。</li>
</ul>
</li>
<li>.indices ?TABLE?	<ul>
<li>显示所有索引的名称。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表的索引。</li>
</ul>
</li>
<li>.load FILE ?ENTRY?	<ul>
<li>加载一个扩展库。</li>
</ul>
</li>
<li>.log FILE|off	<ul>
<li>开启或关闭日志。FILE 文件可以是 stderr（标准错误）&#x2F;stdout（标准输出）。</li>
</ul>
</li>
<li>.mode MODE	<ul>
<li>设置输出模式，MODE 可以是下列之一：<ul>
<li>csv 逗号分隔的值</li>
<li>column 左对齐的列</li>
<li>html HTML 的 <table> 代码</li>
<li>insert TABLE 表的 SQL 插入（insert）语句</li>
<li>line 每行一个值</li>
<li>list 由 .separator 字符串分隔的值</li>
<li>tabs 由 Tab 分隔的值</li>
<li>tcl TCL 列表元素</li>
</ul>
</li>
</ul>
</li>
<li>.nullvalue STRING	<ul>
<li>在 NULL 值的地方输出 STRING 字符串。</li>
</ul>
</li>
<li>.output FILENAME	<ul>
<li>发送输出到 FILENAME 文件。</li>
</ul>
</li>
<li>.output stdout	<ul>
<li>发送输出到屏幕。</li>
</ul>
</li>
<li>.print STRING…	<ul>
<li>逐字地输出 STRING 字符串。</li>
</ul>
</li>
<li>.prompt MAIN CONTINUE	<ul>
<li>替换标准提示符。</li>
</ul>
</li>
<li>.quit	<ul>
<li>退出 SQLite 提示符。</li>
</ul>
</li>
<li>.read FILENAME	<ul>
<li>执行 FILENAME 文件中的 SQL。</li>
</ul>
</li>
<li>.schema ?TABLE?	<ul>
<li>显示 CREATE 语句。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表。</li>
</ul>
</li>
<li>.separator STRING	<ul>
<li>改变输出模式和 .import 所使用的分隔符。</li>
</ul>
</li>
<li>.show	<ul>
<li>显示各种设置的当前值。</li>
</ul>
</li>
<li>.stats ON|OFF	<ul>
<li>开启或关闭统计。</li>
</ul>
</li>
<li>.tables ?PATTERN?	<ul>
<li>列出匹配 LIKE 模式的表的名称。</li>
</ul>
</li>
<li>.timeout MS	<ul>
<li>尝试打开锁定的表 MS 毫秒。</li>
</ul>
</li>
<li>.width NUM NUM	<ul>
<li>为 “column” 模式设置列宽度。</li>
</ul>
</li>
<li>.timer ON|OFF	<ul>
<li>开启或关闭 CPU 定时器。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-语法"><a href="#SQLite-语法" class="headerlink" title="SQLite 语法"></a>SQLite 语法</h2><ul>
<li><p>SQLite 是遵循一套独特的称为语法的规则和准则。</p>
</li>
<li><p>大小写敏感性</p>
<ul>
<li>有个重要的点值得注意，SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。</li>
</ul>
</li>
<li><p>注释</p>
<ul>
<li>SQLite 注释是附加的注释，可以在 SQLite 代码中添加注释以增加其可读性，他们可以出现在任何空白处，包括在表达式内和其他 SQL 语句的中间，但它们不能嵌套。</li>
<li>SQL 注释以两个连续的 “-“ 字符（ASCII 0x2d）开始，并扩展至下一个换行符（ASCII 0x0a）或直到输入结束，以先到者为准。</li>
<li>您也可以使用 C 风格的注释，以 “&#x2F;<em>“ 开始，并扩展至下一个 “</em>&#x2F;“ 字符对或直到输入结束，以先到者为准。SQLite的注释可以跨越多行。</li>
<li>sqlite&gt;.help – 这是一个简单的注释</li>
</ul>
</li>
<li><p>SQLite 语句</p>
<ul>
<li>所有的 SQLite 语句可以以任何关键字开始，如 SELECT、INSERT、UPDATE、DELETE、ALTER、DROP 等，所有的语句以分号 ; 结束。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-数据类型"><a href="#SQLite-数据类型" class="headerlink" title="SQLite 数据类型"></a>SQLite 数据类型</h2><ul>
<li><p>SQLite 数据类型是一个用来指定任何对象的数据类型的属性。SQLite 中的每一列，每个变量和表达式都有相关的数据类型。</p>
</li>
<li><p>您可以在创建表的同时使用这些数据类型。SQLite 使用一个更普遍的动态类型系统。在 SQLite 中，值的数据类型与值本身是相关的，而不是与它的容器相关。</p>
</li>
<li><p>SQLite存储类</p>
<ul>
<li>每个存储在 SQLite 数据库中的值都具有以下存储类之一：</li>
<li>NULL	: 值是一个 NULL 值。</li>
<li>INTEGER	: 值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。</li>
<li>REAL	: 值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。</li>
<li>TEXT	: 值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储。</li>
<li>BLOB	: 值是一个 blob 数据，完全根据它的输入存储。</li>
</ul>
</li>
<li><p>Date与Time数据类型</p>
<ul>
<li>SQLite 没有一个单独的用于存储日期和&#x2F;或时间的存储类，但 SQLite 能够把日期和时间存储为 TEXT、REAL 或 INTEGER 值。</li>
<li>TEXT	: 格式为 “YYYY-MM-DD HH:MM:SS.SSS” 的日期。</li>
<li>REAL	: 从公元前 4714 年 11 月 24 日格林尼治时间的正午开始算起的天数。</li>
<li>INTEGER	: 从 1970-01-01 00:00:00 UTC 算起的秒数。</li>
<li>您可以以任何上述格式来存储日期和时间，并且可以使用内置的日期和时间函数来自由转换不同格式。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-创建数据库"><a href="#SQLite-创建数据库" class="headerlink" title="SQLite 创建数据库"></a>SQLite 创建数据库</h2><ul>
<li><p>SQLite 的 sqlite3 命令被用来创建新的 SQLite 数据库。您不需要任何特殊的权限即可创建一个数据。</p>
</li>
<li><p>语法</p>
<ul>
<li>sqlite3 命令的基本语法如下：<ul>
<li><code>$ sqlite3 DatabaseName.db</code></li>
</ul>
</li>
<li>通常情况下，数据库名称在 RDBMS 内应该是唯一的。</li>
<li>另外我们也可以使用 .open 来建立新的数据库文件：<ul>
<li><code>sqlite&gt;.open test.db</code></li>
</ul>
</li>
<li>上面的命令创建了数据库文件 test.db，位于 sqlite3 命令同一目录下。</li>
<li>打开已存在数据库也是用 .open 命令，以上命令如果 test.db 存在则直接会打开，不存在就创建它。</li>
</ul>
</li>
<li><p>.dump 命令</p>
<ul>
<li>您可以在命令提示符中使用 SQLite .dump 点命令来导出完整的数据库在一个文本文件中，如下所示：<ul>
<li><code>$sqlite3 testDB.db .dump &gt; testDB.sql</code></li>
</ul>
</li>
<li>上面的命令将转换整个 testDB.db 数据库的内容到 SQLite 的语句中，并将其转储到 ASCII 文本文件 testDB.sql 中。您可以通过简单的方式从生成的 testDB.sql 恢复，如下所示：<ul>
<li><code>$sqlite3 testDB.db &lt; testDB.sql</code></li>
</ul>
</li>
<li>此时的数据库是空的，一旦数据库中有表和数据，您可以尝试上述两个程序。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-附加数据库"><a href="#SQLite-附加数据库" class="headerlink" title="SQLite 附加数据库"></a>SQLite 附加数据库</h2><ul>
<li><p>假设这样一种情况，当在同一时间有多个数据库可用，您想使用其中的任何一个。SQLite 的 ATTACH DATABASE 语句是用来选择一个特定的数据库，使用该命令后，所有的 SQLite 语句将在附加的数据库下执行。</p>
</li>
<li><p>语法</p>
<ul>
<li>SQLite 的 ATTACH DATABASE 语句的基本语法如下：<ul>
<li><code>ATTACH DATABASE file_name AS database_name;</code></li>
</ul>
</li>
<li>如果数据库尚未被创建，上面的命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 ‘Alias-Name’ 绑定在一起。</li>
<li>打开的数据库和使用 ATTACH附加进来的数据库的必须位于同一文件夹下。</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>如果想附加一个现有的数据库 testDB.db，则 ATTACH DATABASE 语句将如下所示：<ul>
<li><code>sqlite&gt; ATTACH DATABASE &#39;testDB.db&#39; as &#39;TEST&#39;;</code></li>
</ul>
</li>
<li>使用 SQLite .database 命令来显示附加的数据库。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> .database</span><br><span class="line">seq  name             file</span><br><span class="line"><span class="comment">---  ---------------  ----------------------</span></span><br><span class="line"><span class="number">0</span>    main             <span class="operator">/</span>home<span class="operator">/</span>sqlite<span class="operator">/</span>testDB.db</span><br><span class="line"><span class="number">2</span>    test             <span class="operator">/</span>home<span class="operator">/</span>sqlite<span class="operator">/</span>testDB.db</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加，否则将得到一个警告消息，如下所示</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span>  ATTACH DATABASE <span class="string">&#x27;testDB.db&#x27;</span> <span class="keyword">as</span> <span class="string">&#x27;TEMP&#x27;</span>;</span><br><span class="line">Error: database TEMP <span class="keyword">is</span> already <span class="keyword">in</span> use</span><br><span class="line">sqlite<span class="operator">&gt;</span>  ATTACH DATABASE <span class="string">&#x27;testDB.db&#x27;</span> <span class="keyword">as</span> <span class="string">&#x27;main&#x27;</span>;</span><br><span class="line">Error: database main <span class="keyword">is</span> already <span class="keyword">in</span> use；</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SQLite-分离数据库"><a href="#SQLite-分离数据库" class="headerlink" title="SQLite 分离数据库"></a>SQLite 分离数据库</h2><ul>
<li><p>SQLite 的 DETACH DATABASE 语句是用来把命名数据库从一个数据库连接分离和游离出来，连接是之前使用 ATTACH 语句附加的。如果同一个数据库文件已经被附加上多个别名，DETACH 命令将只断开给定名称的连接，而其余的仍然有效。您无法分离 main 或 temp 数据库。</p>
</li>
<li><p>如果数据库是在内存中或者是临时数据库，则该数据库将被摧毁，且内容将会丢失。</p>
</li>
<li><p>语法</p>
<ul>
<li>SQLite 的 DETACH DATABASE ‘Alias-Name’ 语句的基本语法如下：<ul>
<li><code>DETACH DATABASE &#39;Alias-Name&#39;;</code></li>
</ul>
</li>
<li>在这里，’Alias-Name’ 与您之前使用 ATTACH 语句附加数据库时所用到的别名相同。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-创建表"><a href="#SQLite-创建表" class="headerlink" title="SQLite 创建表"></a>SQLite 创建表</h2><ul>
<li><p>SQLite 的 CREATE TABLE 语句用于在任何给定的数据库创建一个新表。创建基本表，涉及到命名表、定义列及每一列的数据类型。</p>
</li>
<li><p>语法</p>
<ul>
<li>CREATE TABLE 语句的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> database_name.table_name(</span><br><span class="line">   column1 datatype  <span class="keyword">PRIMARY KEY</span>(<span class="keyword">one</span> <span class="keyword">or</span> more columns),</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>CREATE TABLE 是告诉数据库系统创建一个新表的关键字。CREATE TABLE 语句后跟着表的唯一的名称或标识。您也可以选择指定带有 table_name 的 database_name。</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>下面是一个实例，它创建了一个 COMPANY 表，ID 作为主键，NOT NULL 的约束表示在表中创建纪录时这些字段不能为 NULL：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>让我们再创建一个表，我们将在随后章节的练习中使用：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">CREATE TABLE</span> DEPARTMENT(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>      <span class="keyword">NOT NULL</span>,</span><br><span class="line">   DEPT           <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">   EMP_ID         <span class="type">INT</span>      <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>您可以使用 SQLIte 命令中的 .tables 命令来验证表是否已成功创建，该命令用于列出附加数据库中的所有表。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt;.tables</span><br><span class="line">COMPANY     DEPARTMENT</span><br></pre></td></tr></table></figure></li>
<li>您可以使用 SQLite .schema 命令得到表的完整信息，如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span>.schema COMPANY</span><br><span class="line"><span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-删除表"><a href="#SQLite-删除表" class="headerlink" title="SQLite 删除表"></a>SQLite 删除表</h2><ul>
<li><p>SQLite 的 DROP TABLE 语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范。</p>
</li>
<li><p>使用此命令时要特别注意，因为一旦一个表被删除，表中所有信息也将永远丢失。</p>
</li>
<li><p>语法</p>
<ul>
<li>DROP TABLE 语句的基本语法如下。您可以选择指定带有表名的数据库名称，如下所示<ul>
<li><code>DROP TABLE database_name.table_name;</code></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Insert-语句"><a href="#SQLite-Insert-语句" class="headerlink" title="SQLite Insert 语句"></a>SQLite Insert 语句</h2><ul>
<li><p>SQLite 的 INSERT INTO 语句用于向数据库的某个表中添加新的数据行。</p>
</li>
<li><p>语法</p>
<ul>
<li>INSERT INTO 语句有两种基本语法，如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> TABLE_NAME [(column1, column2, column3,...columnN)]  </span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, value3,...valueN);</span><br></pre></td></tr></table></figure></li>
<li>在这里，column1, column2,…columnN 是要插入数据的表中的列的名称。</li>
<li>如果要为表中的所有列添加值，您也可以不需要在 SQLite 查询中指定列名称。但要确保值的顺序与列在表中的顺序一致。SQLite 的 INSERT INTO 语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> TABLE_NAME <span class="keyword">VALUES</span> (value1,value2,value3,...valueN);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用一个表来填充另一个表</p>
<ul>
<li>您可以通过在一个有一组字段的表上使用 select 语句，填充数据到另一个表中。下面是语法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> first_table_name [(column1, column2, ... columnN)] </span><br><span class="line">   <span class="keyword">SELECT</span> column1, column2, ...columnN </span><br><span class="line">   <span class="keyword">FROM</span> second_table_name</span><br><span class="line">   [<span class="keyword">WHERE</span> <span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Select-语句"><a href="#SQLite-Select-语句" class="headerlink" title="SQLite Select 语句"></a>SQLite Select 语句</h2><ul>
<li><p>SQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。</p>
</li>
<li><p>语法</p>
<ul>
<li>SQLite 的 SELECT 语句的基本语法如下：<ul>
<li><code>SELECT column1, column2, columnN FROM table_name;</code></li>
</ul>
</li>
<li>在这里，column1, column2…是表的字段，他们的值即是您要获取的。如果您想获取所有可用的字段，那么可以使用下面的语法：<ul>
<li><code>SELECT * FROM table_name;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SQLite-运算符"><a href="#SQLite-运算符" class="headerlink" title="SQLite 运算符"></a>SQLite 运算符</h2><ul>
<li><p>SQLite 运算符是什么？</p>
<ul>
<li>运算符是一个保留字或字符，主要用于 SQLite 语句的 WHERE 子句中执行操作，如比较和算术运算。</li>
<li>运算符用于指定 SQLite 语句中的条件，并在语句中连接多个条件。<ul>
<li>算术运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
</ul>
</li>
</ul>
</li>
<li><p>SQLite 算术运算符</p>
<ul>
<li>假设变量 a&#x3D;10，变量 b&#x3D;20，则：</li>
<li><code>+</code>	 : 加法 :  把运算符两边的值相加	a + b 将得到 30</li>
<li><code>-</code>	 : 减法 :  左操作数减去右操作数	a - b 将得到 -10</li>
<li><code>*</code>	 : 乘法 :  把运算符两边的值相乘	a * b 将得到 200</li>
<li><code>/</code>	 : 除法 :  左操作数除以右操作数	b &#x2F; a 将得到 2</li>
<li><code>%</code>	 : 取模 :  左操作数除以右操作数后得到的余数	b % a 将得到 0</li>
</ul>
</li>
<li><p>SQLite 比较运算符</p>
<ul>
<li>假设变量 a&#x3D;10，变量 b&#x3D;20，则：</li>
<li><code>==</code>	检查两个操作数的值是否相等，如果相等则条件为真。	(a &#x3D;&#x3D; b) 不为真。</li>
<li><code>=</code> 	检查两个操作数的值是否相等，如果相等则条件为真。	(a &#x3D; b) 不为真。</li>
<li><code>!=</code>	检查两个操作数的值是否相等，如果不相等则条件为真。	(a !&#x3D; b) 为真。</li>
<li><code>&lt;&gt;</code>	检查两个操作数的值是否相等，如果不相等则条件为真。	(a &lt;&gt; b) 为真。</li>
<li><code>&gt;</code>	    检查左操作数的值是否大于右操作数的值，如果是则条件为真。	(a &gt; b) 不为真。</li>
<li><code>&lt;</code>	    检查左操作数的值是否小于右操作数的值，如果是则条件为真。	(a &lt; b) 为真。</li>
<li><code>&gt;=</code>	检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。	(a &gt;&#x3D; b) 不为真。</li>
<li><code>&lt;=</code>	检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。	(a &lt;&#x3D; b) 为真。</li>
<li><code>!&lt;</code>	检查左操作数的值是否不小于右操作数的值，如果是则条件为真。	(a !&lt; b) 为假。</li>
<li><code>!&gt;</code>	检查左操作数的值是否不大于右操作数的值，如果是则条件为真。	(a !&gt; b) 为真。</li>
</ul>
</li>
<li><p>SQLite 逻辑运算符</p>
<ul>
<li>下面是 SQLite 中所有的逻辑运算符列表。</li>
<li>AND	AND  : 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。</li>
<li>BETWEEN	 : BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。</li>
<li>EXISTS	 : EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。</li>
<li>IN	     : IN 运算符用于把某个值与一系列指定列表的值进行比较。</li>
<li>NOT IN	 : IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。</li>
<li>LIKE	 : LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。</li>
<li>GLOB	 : GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。</li>
<li>NOT	     : NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。它是否定运算符。</li>
<li>OR	     : OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。</li>
<li>IS NULL	 : NULL 运算符用于把某个值与 NULL 值进行比较。</li>
<li>IS	     : IS 运算符与 &#x3D; 相似。</li>
<li>IS NOT	 : IS NOT 运算符与 !&#x3D; 相似。</li>
<li>||	     : 连接两个不同的字符串，得到一个新的字符串。</li>
<li>UNIQUE	 : UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。</li>
</ul>
</li>
<li><p>SQLite 位运算符</p>
<ul>
<li>下表中列出了 SQLite 语言支持的位运算符。假设变量 A&#x3D;60，变量 B&#x3D;13，则：</li>
<li><code>&amp;</code>	    : 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。	     (A &amp; B) 将得到 12，即为 0000 1100</li>
<li><code>|</code>	    : 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。	        (A | B) 将得到 61，即为 0011 1101</li>
<li><code>~</code>	    : 二进制补码运算符是一元运算符，具有”翻转”位效应，即0变成1，1变成0。	 (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</li>
<li><code>&lt;&lt;</code>	: 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。	         A &lt;&lt; 2 将得到 240，即为 1111 0000</li>
<li><code>&gt;&gt;</code>	: 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。	         A &gt;&gt; 2 将得到 15，即为 0000 1111</li>
</ul>
</li>
</ul>
<h2 id="SQLite-表达式"><a href="#SQLite-表达式" class="headerlink" title="SQLite 表达式"></a>SQLite 表达式</h2><ul>
<li><p>表达式是一个或多个值、运算符和计算值的SQL函数的组合。</p>
</li>
<li><p>SQL 表达式与公式类似，都写在查询语言中。您还可以使用特定的数据集来查询数据库。</p>
</li>
<li><p>语法</p>
<ul>
<li>假设 SELECT 语句的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">CONDITION</span> <span class="operator">|</span> EXPRESSION];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>SQLite - 布尔表达式</p>
<ul>
<li>SQLite 的布尔表达式在匹配单个值的基础上获取数据。语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> SINGLE <span class="keyword">VALUE</span> MATCHING EXPRESSION;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>SQLite - 数值表达式</p>
<ul>
<li>这些表达式用来执行查询中的任何数学运算。语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> numerical_expression <span class="keyword">as</span>  OPERATION_NAME</span><br><span class="line">[<span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">CONDITION</span>] ;</span><br></pre></td></tr></table></figure></li>
<li>在这里，numerical_expression 用于数学表达式或任何公式。下面的实例演示了 SQLite 数值表达式的用法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> (<span class="number">15</span> <span class="operator">+</span> <span class="number">6</span>) <span class="keyword">AS</span> ADDITION</span><br><span class="line">ADDITION <span class="operator">=</span> <span class="number">21</span></span><br></pre></td></tr></table></figure></li>
<li>有几个内置的函数，比如 avg()、sum()、count()，等等，执行被称为对一个表或一个特定的表列的汇总数据计算。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> &quot;RECORDS&quot; <span class="keyword">FROM</span> COMPANY; </span><br><span class="line">RECORDS <span class="operator">=</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>SQLite - 日期表达式</p>
<ul>
<li>日期表达式返回当前系统日期和时间值，这些表达式将被用于各种数据操作。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span>  <span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>;</span><br><span class="line"><span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">=</span> <span class="number">2013</span><span class="number">-03</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">35</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Where-子句"><a href="#SQLite-Where-子句" class="headerlink" title="SQLite Where 子句"></a>SQLite Where 子句</h2><ul>
<li><p>SQLite的 WHERE 子句用于指定从一个表或多个表中获取数据的条件。</p>
</li>
<li><p>如果满足给定的条件，即为真（true）时，则从表中返回特定的值。您可以使用 WHERE 子句来过滤记录，只获取需要的记录。</p>
</li>
<li><p>WHERE 子句不仅可用在 SELECT 语句中，它也可用在 UPDATE、DELETE 语句中，等等，这些我们将在随后的章节中学习到。</p>
</li>
<li><p>语法：</p>
<ul>
<li>SQLite 的带有 WHERE 子句的 SELECT 语句的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li>
<li>您还可以使用比较或逻辑运算符指定条件，比如 &gt;、&lt;、&#x3D;、LIKE、NOT，等等</li>
</ul>
</li>
<li><p>下面的 SELECT 语句列出了 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;Ki%&#x27;</span>;</span><br><span class="line">ID          NAME        AGE         ADDRESS     SALARY</span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------</span></span><br><span class="line"><span class="number">6</span>           Kim         <span class="number">22</span>          South<span class="operator">-</span>Hall  <span class="number">45000.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的 SELECT 语句列出了 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> NAME GLOB <span class="string">&#x27;Ki*&#x27;</span>;</span><br><span class="line">ID          NAME        AGE         ADDRESS     SALARY</span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------</span></span><br><span class="line"><span class="number">6</span>           Kim         <span class="number">22</span>          South<span class="operator">-</span>Hall  <span class="number">45000.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的 SELECT 语句列出了 AGE 的值为 25 或 27 的所有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> AGE <span class="keyword">IN</span> ( <span class="number">25</span>, <span class="number">27</span> );</span><br><span class="line">ID          NAME        AGE         ADDRESS     SALARY</span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------</span></span><br><span class="line"><span class="number">2</span>           Allen       <span class="number">25</span>          Texas       <span class="number">15000.0</span></span><br><span class="line"><span class="number">4</span>           Mark        <span class="number">25</span>          Rich<span class="operator">-</span>Mond   <span class="number">65000.0</span></span><br><span class="line"><span class="number">5</span>           David       <span class="number">27</span>          Texas       <span class="number">85000.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的 SELECT 语句列出了 AGE 的值既不是 25 也不是 27 的所有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> AGE <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="number">25</span>, <span class="number">27</span> );</span><br><span class="line">ID          NAME        AGE         ADDRESS     SALARY</span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------</span></span><br><span class="line"><span class="number">1</span>           Paul        <span class="number">32</span>          California  <span class="number">20000.0</span></span><br><span class="line"><span class="number">3</span>           Teddy       <span class="number">23</span>          Norway      <span class="number">20000.0</span></span><br><span class="line"><span class="number">6</span>           Kim         <span class="number">22</span>          South<span class="operator">-</span>Hall  <span class="number">45000.0</span></span><br><span class="line"><span class="number">7</span>           James       <span class="number">24</span>          Houston     <span class="number">10000.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的 SELECT 语句列出了 AGE 的值在 25 与 27 之间的所有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> AGE <span class="keyword">BETWEEN</span> <span class="number">25</span> <span class="keyword">AND</span> <span class="number">27</span>;</span><br><span class="line">ID          NAME        AGE         ADDRESS     SALARY</span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------</span></span><br><span class="line"><span class="number">2</span>           Allen       <span class="number">25</span>          Texas       <span class="number">15000.0</span></span><br><span class="line"><span class="number">4</span>           Mark        <span class="number">25</span>          Rich<span class="operator">-</span>Mond   <span class="number">65000.0</span></span><br><span class="line"><span class="number">5</span>           David       <span class="number">27</span>          Texas       <span class="number">85000.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的 SELECT 语句使用 SQL 子查询，子查询查找 SALARY &gt; 65000 的带有 AGE 字段的所有记录，后边的 WHERE 子句与 EXISTS 运算符一起使用，列出了外查询中的 AGE 存在于子查询返回的结果中的所有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> AGE <span class="keyword">FROM</span> COMPANY </span><br><span class="line">        <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> AGE <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> SALARY <span class="operator">&gt;</span> <span class="number">65000</span>);</span><br><span class="line">AGE</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的 SELECT 语句使用 SQL 子查询，子查询查找 SALARY &gt; 65000 的带有 AGE 字段的所有记录，后边的 WHERE 子句与 &gt; 运算符一起使用，列出了外查询中的 AGE 大于子查询返回的结果中的年龄的所有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY </span><br><span class="line">        <span class="keyword">WHERE</span> AGE <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> AGE <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> SALARY <span class="operator">&gt;</span> <span class="number">65000</span>);</span><br><span class="line">ID          NAME        AGE         ADDRESS     SALARY</span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------</span></span><br><span class="line"><span class="number">1</span>           Paul        <span class="number">32</span>          California  <span class="number">20000.0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SQLite-AND-OR-运算符"><a href="#SQLite-AND-OR-运算符" class="headerlink" title="SQLite AND&#x2F;OR 运算符"></a>SQLite AND&#x2F;OR 运算符</h2><ul>
<li><p>SQLite 的 AND 和 OR 运算符用于编译多个条件来缩小在 SQLite 语句中所选的数据。这两个运算符被称为连接运算符。</p>
</li>
<li><p>这些运算符为同一个 SQLite 语句中不同的运算符之间的多个比较提供了可能。</p>
</li>
<li><p>AND 运算符</p>
<ul>
<li>AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。使用 AND 运算符时，只有当所有条件都为真（true）时，整个条件为真（true）。</li>
<li>例如，只有当 condition1 和 condition2 都为真（true）时，[condition1] AND [condition2] 为真（true）。</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>带有 WHERE 子句的 AND 运算符的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [condition1] <span class="keyword">AND</span> [condition2]...<span class="keyword">AND</span> [conditionN];</span><br></pre></td></tr></table></figure></li>
<li>您可以使用 AND 运算符来结合 N 个数量的条件。SQLite 语句需要执行的动作是，无论是事务或查询，所有由 AND 分隔的条件都必须为真（TRUE）。</li>
</ul>
</li>
<li><p>OR 运算符</p>
<ul>
<li>OR 运算符也用于结合一个 SQL 语句的 WHERE 子句中的多个条件。使用 OR 运算符时，只要当条件中任何一个为真（true）时，整个条件为真（true）。</li>
<li>例如，只要当 condition1 或 condition2 有一个为真（true）时，[condition1] OR [condition2] 为真（true）。</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>带有 WHERE 子句的 OR 运算符的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [condition1] <span class="keyword">OR</span> [condition2]...<span class="keyword">OR</span> [conditionN]</span><br></pre></td></tr></table></figure></li>
<li>您可以使用 OR 运算符来结合 N 个数量的条件。SQLite 语句需要执行的动作是，无论是事务或查询，只要任何一个由 OR 分隔的条件为真（TRUE）即可。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Update-语句"><a href="#SQLite-Update-语句" class="headerlink" title="SQLite Update 语句"></a>SQLite Update 语句</h2><ul>
<li><p>SQLite 的 UPDATE 查询用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新。</p>
</li>
<li><p>语法</p>
<ul>
<li>带有 WHERE 子句的 UPDATE 查询的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2...., columnN <span class="operator">=</span> valueN</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure></li>
<li>您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。</li>
</ul>
</li>
<li><p>如果您想修改 COMPANY 表中 ADDRESS 和 SALARY 列的所有值，则不需要使用 WHERE 子句，UPDATE 查询如下：</p>
<ul>
<li><code>sqlite&gt; UPDATE COMPANY SET ADDRESS = &#39;Texas&#39;, SALARY = 20000.00;</code></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Delete-语句"><a href="#SQLite-Delete-语句" class="headerlink" title="SQLite Delete 语句"></a>SQLite Delete 语句</h2><ul>
<li><p>SQLite 的 DELETE 查询用于删除表中已有的记录。可以使用带有 WHERE 子句的 DELETE 查询来删除选定行，否则所有的记录都会被删除。</p>
</li>
<li><p>语法</p>
<ul>
<li>带有 WHERE 子句的 DELETE 查询的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure></li>
<li>您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Like-子句"><a href="#SQLite-Like-子句" class="headerlink" title="SQLite Like 子句"></a>SQLite Like 子句</h2><ul>
<li><p>SQLite 的 LIKE 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用：</p>
<ul>
<li>百分号 （%）</li>
<li>下划线 （_）</li>
</ul>
</li>
<li><p>百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。</p>
</li>
<li><p>语法</p>
<ul>
<li>% 和 _ 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_list </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">LIKE</span> <span class="string">&#x27;XXXX%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column_list </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%XXXX%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column_list </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">LIKE</span> <span class="string">&#x27;XXXX_&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column_list </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">LIKE</span> <span class="string">&#x27;_XXXX&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column_list </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">LIKE</span> <span class="string">&#x27;_XXXX_&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。</p>
</li>
<li><p>实例</p>
<ul>
<li>下面一些实例演示了 带有 ‘%’ 和 ‘_’ 运算符的 LIKE 子句不同的地方：</li>
<li><code>WHERE SALARY LIKE &#39;200%&#39;</code>	查找以 200 开头的任意值</li>
<li><code>WHERE SALARY LIKE &#39;%200%&#39;</code>	查找任意位置包含 200 的任意值</li>
<li><code>WHERE SALARY LIKE &#39;_00%&#39;</code>	查找第二位和第三位为 00 的任意值</li>
<li><code>WHERE SALARY LIKE &#39;2_%_%&#39;</code>	查找以 2 开头，且长度至少为 3 个字符的任意值</li>
<li><code>WHERE SALARY LIKE &#39;%2&#39;</code>	查找以 2 结尾的任意值</li>
<li><code>WHERE SALARY LIKE &#39;_2%3&#39;</code>	查找第二位为 2，且以 3 结尾的任意值</li>
<li><code>WHERE SALARY LIKE &#39;2___3&#39;</code>	查找长度为 5 位数，且以 2 开头以 3 结尾的任意值</li>
</ul>
</li>
<li><p>下面是一个实例，它显示 COMPANY 表中 AGE 以 2 开头的所有记录：</p>
<ul>
<li><code>sqlite&gt; SELECT * FROM COMPANY WHERE AGE  LIKE &#39;2%&#39;;</code></li>
</ul>
</li>
<li><p>下面是一个实例，它显示 COMPANY 表中 ADDRESS 文本里包含一个连字符（-）的所有记录：</p>
<ul>
<li><code>sqlite&gt; SELECT * FROM COMPANY WHERE ADDRESS  LIKE &#39;%-%&#39;;</code></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Glob-子句"><a href="#SQLite-Glob-子句" class="headerlink" title="SQLite Glob 子句"></a>SQLite Glob 子句</h2><ul>
<li><p>SQLite 的 GLOB 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。</p>
<ul>
<li><code>*</code>      ：匹配零个、一个或多个数字或字符。</li>
<li><code>?</code>      ：代表一个单一的数字或字符。</li>
<li><code>[...]</code>  ：匹配方括号内指定的字符之一。例如，[abc] 匹配 “a”、”b” 或 “c” 中的任何一个字符。</li>
<li><code>[^...]</code> ：匹配不在方括号内指定的字符之一。例如，[^abc] 匹配不是 “a”、”b” 或 “c” 中的任何一个字符的字符。</li>
</ul>
</li>
<li><p>以上这些符号可以被组合使用</p>
</li>
<li><p>语法</p>
<ul>
<li><ul>
<li>和 ? 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> GLOB <span class="string">&#x27;XXXX*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> GLOB <span class="string">&#x27;*XXXX*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> GLOB <span class="string">&#x27;XXXX?&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> GLOB <span class="string">&#x27;?XXXX&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> GLOB <span class="string">&#x27;?XXXX?&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> GLOB <span class="string">&#x27;????&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。</p>
</li>
<li><p>实例</p>
<ul>
<li>下面一些实例演示了 带有 ‘*’ 和 ‘?’ 运算符的 GLOB 子句不同的地方：<ul>
<li><code>WHERE SALARY GLOB &#39;200*&#39;</code>	查找以 200 开头的任意值</li>
<li><code>WHERE SALARY GLOB &#39;*200*&#39;</code>	查找任意位置包含 200 的任意值</li>
<li><code>WHERE SALARY GLOB &#39;?00*&#39;</code>	查找第二位和第三位为 00 的任意值</li>
<li><code>WHERE SALARY GLOB &#39;2??&#39;</code>	    查找以 2 开头，且长度为 3 个字符的任意值，例如，它可能匹配 “200”、”2A1”、”2B2” 等值。</li>
<li><code>WHERE SALARY GLOB &#39;*2&#39;</code>	    查找以 2 结尾的任意值</li>
<li><code>WHERE SALARY GLOB &#39;?2*3&#39;</code>	查找第二位为 2，且以 3 结尾的任意值</li>
<li><code>WHERE SALARY GLOB &#39;2???3&#39;</code>	查找长度为 5 位数，且以 2 开头以 3 结尾的任意值</li>
</ul>
</li>
</ul>
</li>
<li><p><code>[...]</code> 通配符</p>
<ul>
<li><code>[...]</code> 表达式用于匹配方括号内指定的字符集中的任何一个字符。</li>
</ul>
</li>
<li><p>实例 1：匹配以 “A” 或 “B” 开头的产品名称。</p>
<ul>
<li><code>SELECT * FROM products WHERE product_name LIKE &#39;[AB]%&#39;;</code></li>
</ul>
</li>
<li><p>这将匹配以 “A” 或 “B” 开头的产品名称。</p>
</li>
<li><p>实例 2：匹配以 “1”、”2” 或 “3” 开头的电话号码。</p>
<ul>
<li><code>SELECT * FROM customers WHERE phone_number LIKE &#39;[123]%&#39;;</code></li>
</ul>
</li>
<li><p>这将匹配以 “1”、”2” 或 “3” 开头的电话号码。</p>
</li>
<li><p><code>[^...]</code> 通配符</p>
<ul>
<li><code>[^...]</code> 表达式用于匹配不在方括号内指定的字符集中的任何字符。</li>
</ul>
</li>
<li><p>实例 1：匹配不以 “X” 或 “Y” 开头的产品代码。</p>
<ul>
<li><code>SELECT * FROM products WHERE product_code LIKE &#39;[^XY]%&#39;;</code></li>
</ul>
</li>
<li><p>这将匹配不以 “X” 或 “Y” 开头的产品</p>
</li>
<li><p>实例 2：匹配不包含数字字符的用户名。</p>
<ul>
<li><code>SELECT * FROM users WHERE username LIKE &#39;[^0-9]%&#39;;</code></li>
</ul>
</li>
<li><p>这将匹配不以数字字符开头的用户名。</p>
</li>
</ul>
<h2 id="SQLite-Limit-子句"><a href="#SQLite-Limit-子句" class="headerlink" title="SQLite Limit 子句"></a>SQLite Limit 子句</h2><ul>
<li><p>SQLite 的 LIMIT 子句用于限制由 SELECT 语句返回的数据数量。</p>
</li>
<li><p>语法</p>
<ul>
<li>带有 LIMIT 子句的 SELECT 语句的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT [<span class="keyword">no</span> <span class="keyword">of</span> <span class="keyword">rows</span>]</span><br></pre></td></tr></table></figure></li>
<li>下面是 LIMIT 子句与 OFFSET 子句一起使用时的语法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT [<span class="keyword">no</span> <span class="keyword">of</span> <span class="keyword">rows</span>] <span class="keyword">OFFSET</span> [<span class="type">row</span> num]</span><br></pre></td></tr></table></figure></li>
<li>SQLite 引擎将返回从下一行开始直到给定的 OFFSET 为止的所有行，如下面的最后一个实例所示</li>
</ul>
</li>
<li><p>但是，在某些情况下，可能需要从一个特定的偏移开始提取记录。下面是一个实例，从第三位开始提取 3 个记录：</p>
<ul>
<li><code>sqlite&gt; SELECT * FROM COMPANY LIMIT 3 OFFSET 2;</code></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Order-By"><a href="#SQLite-Order-By" class="headerlink" title="SQLite Order By"></a>SQLite Order By</h2><ul>
<li><p>SQLite 的 ORDER BY 子句是用来基于一个或多个列按升序或降序顺序排列数据。</p>
</li>
<li><p>语法</p>
<ul>
<li>ORDER BY 子句的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span><span class="operator">-</span>list </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>] </span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2, .. columnN] [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>];</span><br></pre></td></tr></table></figure></li>
<li>ASC 默认值，从小到大，升序排列</li>
<li>DESC 从大到小，降序排列</li>
</ul>
</li>
<li><p>您可以在 ORDER BY 子句中使用多个列，确保您使用的排序列在列清单中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">   select_list</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">   <span class="keyword">table</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    column_1 <span class="keyword">ASC</span>,</span><br><span class="line">    column_2 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>column_1 与 column_2 如果后面不指定排序规则，默认为 ASC 升序，以上语句按 column_1 升序，column_2 降序读取，等价如下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">   select_list</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">   <span class="keyword">table</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    column_1,</span><br><span class="line">    column_2 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面是一个实例，它会将结果按 NAME 和 SALARY 升序排序：</p>
<ul>
<li><code>sqlite&gt; SELECT * FROM COMPANY ORDER BY NAME, SALARY ASC;</code></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Group-By"><a href="#SQLite-Group-By" class="headerlink" title="SQLite Group By"></a>SQLite Group By</h2><ul>
<li><p>SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。</p>
</li>
<li><p>在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。</p>
</li>
<li><p>语法</p>
<ul>
<li>下面给出了 GROUP BY 子句的基本语法。GROUP BY 子句必须放在 WHERE 子句中的条件之后，必须放在 ORDER BY 子句之前。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span><span class="operator">-</span>list</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [ conditions ]</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2....columnN</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2....columnN</span><br></pre></td></tr></table></figure></li>
<li>您可以在 GROUP BY 子句中使用多个列。确保您使用的分组列在列清单中。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Having-子句"><a href="#SQLite-Having-子句" class="headerlink" title="SQLite Having 子句"></a>SQLite Having 子句</h2><ul>
<li><p>HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。</p>
</li>
<li><p>WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</p>
</li>
<li><p>语法</p>
<ul>
<li>下面是 HAVING 子句在 SELECT 查询中的位置：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br></pre></td></tr></table></figure></li>
<li>在一个查询中，HAVING 子句必须放在 GROUP BY 子句之后，必须放在 ORDER BY 子句之前。下面是包含 HAVING 子句的 SELECT 语句的语法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> [ conditions ]</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2</span><br><span class="line"><span class="keyword">HAVING</span> [ conditions ]</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>下面是一个实例，它将显示名称计数大于 2 的所有记录：</p>
<ul>
<li><code>sqlite &gt; SELECT * FROM COMPANY GROUP BY name HAVING count(name) &gt; 2;</code></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Distinct-关键字"><a href="#SQLite-Distinct-关键字" class="headerlink" title="SQLite Distinct 关键字"></a>SQLite Distinct 关键字</h2><ul>
<li><p>SQLite 的 DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。</p>
</li>
<li><p>有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。</p>
</li>
<li><p>语法</p>
<ul>
<li>用于消除重复记录的 DISTINCT 关键字的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1, column2,.....columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>现在，让我们在上述的 SELECT 查询中使用 DISTINCT 关键字：</p>
<ul>
<li><code>sqlite&gt; SELECT DISTINCT name FROM COMPANY;</code></li>
</ul>
</li>
</ul>
<h2 id="SQLite-约束"><a href="#SQLite-约束" class="headerlink" title="SQLite 约束"></a>SQLite 约束</h2><ul>
<li><p>约束是在表的数据列上强制执行的规则。这些是用来限制可以插入到表中的数据类型。这确保了数据库中数据的准确性和可靠性。</p>
</li>
<li><p>约束可以是列级或表级。列级约束仅适用于列，表级约束被应用到整个表。</p>
</li>
<li><p>以下是在 SQLite 中常用的约束</p>
<ul>
<li>NOT NULL 约束：确保某列不能有 NULL 值。</li>
<li>DEFAULT 约束：当某列没有指定值时，为该列提供默认值。</li>
<li>UNIQUE 约束：确保某列中的所有值是不同的。</li>
<li>PRIMARY Key 约束：唯一标识数据库表中的各行&#x2F;记录。</li>
<li>CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件。</li>
</ul>
</li>
<li><p>NOT NULL 约束</p>
<ul>
<li>默认情况下，列可以保存 NULL 值。如果您不想某列有 NULL 值，那么需要在该列上定义此约束，指定在该列上不允许 NULL 值。</li>
<li>NULL 与没有数据是不一样的，它代表着未知的数据。</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>例如，下面的 SQLite 语句创建一个新的表 COMPANY，并增加了五列，其中 ID、NAME 和 AGE 三列指定不接受 NULL 值：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>DEFAULT 约束</p>
<ul>
<li>DEFAULT 约束在 INSERT INTO 语句没有提供一个特定的值时，为列提供一个默认值</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>例如，下面的 SQLite 语句创建一个新的表 COMPANY，并增加了五列。在这里，SALARY 列默认设置为 5000.00。所以当 INSERT INTO 语句没有为该列提供值时，该列将被设置为 5000.00。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span>    <span class="keyword">DEFAULT</span> <span class="number">50000.00</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>UNIQUE 约束</p>
<ul>
<li>UNIQUE 约束防止在一个特定的列存在两个记录具有相同的值。在 COMPANY 表中，例如，您可能要防止两个或两个以上的人具有相同的年龄。</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>例如，下面的 SQLite 语句创建一个新的表 COMPANY，并增加了五列。在这里，AGE 列设置为 UNIQUE，所以不能有两个相同年龄的记录：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span>    <span class="keyword">DEFAULT</span> <span class="number">50000.00</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>PRIMARY KEY 约束</p>
<ul>
<li>PRIMARY KEY 约束唯一标识数据库表中的每个记录。在一个表中可以有多个 UNIQUE 列，但只能有一个主键。在设计数据库表时，主键是很重要的。主键是唯一的 ID。</li>
<li>我们使用主键来引用表中的行。可通过把主键设置为其他表的外键，来创建表之间的关系。由于”长期存在编码监督”，在 SQLite 中，主键可以是 NULL，这是与其他数据库不同的地方。</li>
<li>主键是表中的一个字段，唯一标识数据库表中的各行&#x2F;记录。主键必须包含唯一值。主键列不能有 NULL 值。</li>
<li>一个表只能有一个主键，它可以由一个或多个字段组成。当多个字段作为主键，它们被称为复合键。</li>
<li>如果一个表在任何字段上定义了一个主键，那么在这些字段上不能有两个记录具有相同的值。</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>已经看到了我们创建以 ID 作为主键的 COMAPNY 表的各种实例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>CHECK 约束</p>
<ul>
<li>CHECK 约束启用输入一条记录要检查值的条件。如果条件值为 false，则记录违反了约束，且不能输入到表</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>例如，下面的 SQLite 创建一个新的表 COMPANY，并增加了五列。在这里，我们为 SALARY 列添加 CHECK，所以工资不能为零<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> COMPANY3(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span>    <span class="keyword">CHECK</span>(SALARY <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>删除约束</p>
<ul>
<li>SQLite 支持 ALTER TABLE 的有限子集。在 SQLite 中，ALTER TABLE 命令允许用户重命名表，或向现有表添加一个新的列。重命名列，删除一列，或从一个表中添加或删除约束都是不可能的。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Join"><a href="#SQLite-Join" class="headerlink" title="SQLite Join"></a>SQLite Join</h2><ul>
<li><p>SQLite 的 Join 子句用于结合两个或多个数据库中表的记录。JOIN 是一种通过共同值来结合两个表中字段的手段。</p>
</li>
<li><p>SQL 定义了三种主要类型的连接：</p>
<ul>
<li>交叉连接 - CROSS JOIN</li>
<li>内连接 - INNER JOIN</li>
<li>外连接 - OUTER JOIN</li>
</ul>
</li>
<li><p>交叉连接 - CROSS JOIN</p>
<ul>
<li>交叉连接（CROSS JOIN）把第一个表的每一行与第二个表的每一行进行匹配。如果两个输入表分别有 x 和 y 行，则结果表有 x*y 行。由于交叉连接（CROSS JOIN）有可能产生非常大的表，使用时必须谨慎，只在适当的时候使用它们。</li>
<li>交叉连接的操作，它们都返回被连接的两个表所有数据行的笛卡尔积，返回到的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。</li>
<li>下面是交叉连接（CROSS JOIN）的语法：<ul>
<li><code>SELECT ... FROM table1 CROSS JOIN table2 ...</code></li>
</ul>
</li>
<li>基于上面的表，我们可以写一个交叉连接（CROSS JOIN），如下所示：<ul>
<li><code>sqlite&gt; SELECT EMP_ID, NAME, DEPT FROM COMPANY CROSS JOIN DEPARTMENT;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>内连接 - INNER JOIN</p>
<ul>
<li>内连接（INNER JOIN）根据连接谓词结合两个表（table1 和 table2）的列值来创建一个新的结果表。查询会把 table1 中的每一行与 table2 中的每一行进行比较，找到所有满足连接谓词的行的匹配对。当满足连接谓词时，A 和 B 行的每个匹配对的列值会合并成一个结果行。</li>
<li>内连接（INNER JOIN）是最常见的连接类型，是默认的连接类型。INNER 关键字是可选的。</li>
<li>下面是内连接（INNER JOIN）的语法：<ul>
<li><code>SELECT ... FROM table1 [INNER] JOIN table2 ON conditional_expression ...</code></li>
</ul>
</li>
<li>为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明内连接（INNER JOIN）条件。这个表达式指定一个或多个列的列表：<ul>
<li><code>SELECT ... FROM table1 JOIN table2 USING ( column1 ,... ) ...</code></li>
</ul>
</li>
<li>自然连接（NATURAL JOIN）类似于 JOIN…USING，只是它会自动测试存在两个表中的每一列的值之间相等值：<ul>
<li><code>SELECT ... FROM table1 NATURAL JOIN table2...</code></li>
</ul>
</li>
<li>基于上面的表，我们可以写一个内连接（INNER JOIN），如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="keyword">FROM</span> COMPANY <span class="keyword">INNER</span> <span class="keyword">JOIN</span> DEPARTMENT</span><br><span class="line">        <span class="keyword">ON</span> COMPANY.ID <span class="operator">=</span> DEPARTMENT.EMP_ID;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>外连接 - OUTER JOIN</p>
<ul>
<li>外连接（OUTER JOIN）是内连接（INNER JOIN）的扩展。虽然 SQL 标准定义了三种类型的外连接：LEFT、RIGHT、FULL，但 SQLite 只支持 左外连接（LEFT OUTER JOIN）。</li>
<li>外连接（OUTER JOIN）声明条件的方法与内连接（INNER JOIN）是相同的，使用 ON、USING 或 NATURAL 关键字来表达。最初的结果表以相同的方式进行计算。一旦主连接计算完成，外连接（OUTER JOIN）将从一个或两个表中任何未连接的行合并进来，外连接的列使用 NULL 值，将它们附加到结果表中。</li>
<li>下面是左外连接（LEFT OUTER JOIN）的语法：<ul>
<li><code>SELECT ... FROM table1 LEFT OUTER JOIN table2 ON conditional_expression ...</code></li>
</ul>
</li>
<li>为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明外连接（OUTER JOIN）条件。这个表达式指定一个或多个列的列表：<ul>
<li><code>SELECT ... FROM table1 LEFT OUTER JOIN table2 USING ( column1 ,... ) ...</code></li>
</ul>
</li>
<li>基于上面的表，我们可以写一个外连接（OUTER JOIN），如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="keyword">FROM</span> COMPANY <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> DEPARTMENT</span><br><span class="line">        <span class="keyword">ON</span> COMPANY.ID <span class="operator">=</span> DEPARTMENT.EMP_ID;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Unions-子句"><a href="#SQLite-Unions-子句" class="headerlink" title="SQLite Unions 子句"></a>SQLite Unions 子句</h2><ul>
<li><p>SQLite的 UNION 子句&#x2F;运算符用于合并两个或多个 SELECT 语句的结果，不返回任何重复的行。</p>
</li>
<li><p>为了使用 UNION，每个 SELECT 被选择的列数必须是相同的，相同数目的列表达式，相同的数据类型，并确保它们有相同的顺序，但它们不必具有相同的长度</p>
</li>
<li><p>语法</p>
<ul>
<li>UNION 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li>
<li>这里给定的条件根据需要可以是任何表达式。</li>
</ul>
</li>
<li><p>UNION ALL 子句</p>
<ul>
<li>UNION ALL 运算符用于结合两个 SELECT 语句的结果，包括重复行。</li>
<li>适用于 UNION 的规则同样适用于 UNION ALL 运算符。</li>
<li>UNION ALL 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li>
<li>这里给定的条件根据需要可以是任何表达式。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-NULL-值"><a href="#SQLite-NULL-值" class="headerlink" title="SQLite NULL 值"></a>SQLite NULL 值</h2><ul>
<li><p>SQLite 的 NULL 是用来表示一个缺失值的项。表中的一个 NULL 值是在字段中显示为空白的一个值。</p>
</li>
<li><p>带有 NULL 值的字段是一个不带有值的字段。NULL 值与零值或包含空格的字段是不同的，理解这点是非常重要的。</p>
</li>
<li><p>语法</p>
<ul>
<li>创建表时使用 NULL 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQLite<span class="operator">&gt;</span> <span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>在这里，NOT NULL 表示列总是接受给定数据类型的显式值。这里有两个列我们没有使用 NOT NULL，这意味着这两个列可以为 NULL。</li>
<li>带有 NULL 值的字段在记录创建的时候可以保留为空。</li>
</ul>
</li>
<li><p>NULL 值在选择数据时会引起问题，因为当把一个未知的值与另一个值进行比较时，结果总是未知的，且不会包含在最后的结果中。</p>
</li>
<li><p>实例</p>
<ul>
<li>让我们使用 UPDATE 语句来设置一些允许空值的值为 NULL，如下所示：<ul>
<li><code>sqlite&gt; UPDATE COMPANY SET ADDRESS = NULL, SALARY = NULL where ID IN(6,7);</code></li>
</ul>
</li>
<li>接下来，让我们看看 IS NOT NULL 运算符的用法，它用来列出所有 SALARY 不为 NULL 的记录：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span>  ID, NAME, AGE, ADDRESS, SALARY</span><br><span class="line">        <span class="keyword">FROM</span> COMPANY</span><br><span class="line">        <span class="keyword">WHERE</span> SALARY <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-别名"><a href="#SQLite-别名" class="headerlink" title="SQLite 别名"></a>SQLite 别名</h2><ul>
<li><p>您可以暂时把表或列重命名为另一个名字，这被称为别名。使用表别名是指在一个特定的 SQLite 语句中重命名表。重命名是临时的改变，在数据库中实际的表的名称不会改变。</p>
</li>
<li><p>列别名用来为某个特定的 SQLite 语句重命名表中的列。</p>
</li>
<li><p>语法</p>
<ul>
<li>表 别名的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2....</span><br><span class="line"><span class="keyword">FROM</span> table_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure></li>
<li>列 别名的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-触发器-Trigger"><a href="#SQLite-触发器-Trigger" class="headerlink" title="SQLite 触发器(Trigger)"></a>SQLite 触发器(Trigger)</h2><ul>
<li><p>SQLite 触发器（Trigger）是数据库的回调函数，它会在指定的数据库事件发生时自动执行&#x2F;调用。以下是关于 SQLite 的触发器（Trigger）的要点：</p>
<ul>
<li>SQLite 的触发器（Trigger）可以指定在特定的数据库表发生 DELETE、INSERT 或 UPDATE 时触发，或在一个或多个指定表的列发生更新时触发。</li>
<li>SQLite 只支持 FOR EACH ROW 触发器（Trigger），没有 FOR EACH STATEMENT 触发器（Trigger）。因此，明确指定 FOR EACH ROW 是可选的。</li>
<li>WHEN 子句和触发器（Trigger）动作可能访问使用表单 NEW.column-name 和 OLD.column-name 的引用插入、删除或更新的行元素，其中 column-name 是从与触发器关联的表的列的名称。</li>
<li>如果提供 WHEN 子句，则只针对 WHEN 子句为真的指定行执行 SQL 语句。如果没有提供 WHEN 子句，则针对所有行执行 SQL 语句。</li>
<li>BEFORE 或 AFTER 关键字决定何时执行触发器动作，决定是在关联行的插入、修改或删除之前或者之后执行触发器动作。</li>
<li>当触发器相关联的表删除时，自动删除触发器（Trigger）。</li>
<li>要修改的表必须存在于同一数据库中，作为触发器被附加的表或视图，且必须只使用 tablename，而不是 database.tablename。</li>
<li>一个特殊的 SQL 函数 RAISE() 可用于触发器程序内抛出异常。</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>创建 触发器（Trigger） 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TRIGGER</span> trigger_name [BEFORE<span class="operator">|</span>AFTER] event_name </span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="comment">-- 触发器逻辑....</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li>
<li>在这里，event_name 可以是在所提到的表 table_name 上的 INSERT、DELETE 和 UPDATE 数据库操作。您可以在表名后选择指定 FOR EACH ROW。</li>
<li>以下是在 UPDATE 操作上在表的一个或多个指定列上创建触发器（Trigger）的语法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TRIGGER</span> trigger_name [BEFORE<span class="operator">|</span>AFTER] <span class="keyword">UPDATE</span> <span class="keyword">OF</span> column_name </span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="comment">-- 触发器逻辑....</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>列出触发器（TRIGGERS）</p>
<ul>
<li>您可以从 sqlite_master 表中列出所有触发器，如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> sqlite_master</span><br><span class="line"><span class="keyword">WHERE</span> type <span class="operator">=</span> <span class="string">&#x27;trigger&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>删除触发器（TRIGGERS）</p>
<ul>
<li>下面是 DROP 命令，可用于删除已有的触发器：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> trigger_name;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-索引-Index"><a href="#SQLite-索引-Index" class="headerlink" title="SQLite 索引(Index)"></a>SQLite 索引(Index)</h2><ul>
<li><p>索引（Index）是一种特殊的查找表，数据库搜索引擎用来加快数据检索。简单地说，索引是一个指向表中数据的指针。一个数据库中的索引与一本书的索引目录是非常相似的。</p>
</li>
<li><p>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。</p>
</li>
<li><p>索引有助于加快 SELECT 查询和 WHERE 子句，但它会减慢使用 UPDATE 和 INSERT 语句时的数据输入。索引可以创建或删除，但不会影响数据。</p>
</li>
<li><p>使用 CREATE INDEX 语句创建索引，它允许命名索引，指定表及要索引的一列或多列，并指示索引是升序排列还是降序排列。</p>
</li>
<li><p>索引也可以是唯一的，与 UNIQUE 约束类似，在列上或列组合上防止重复条目。</p>
</li>
<li><p>CREATE INDEX 命令</p>
<ul>
<li>CREATE INDEX 的基本语法如下：</li>
<li><code>CREATE INDEX index_name ON table_name;</code></li>
</ul>
</li>
<li><p>单列索引</p>
<ul>
<li>单列索引是一个只基于表的一个列上创建的索引。基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>唯一索引</p>
<ul>
<li>使用唯一索引不仅是为了性能，同时也为了数据的完整性。唯一索引不允许任何重复的值插入到表中。基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">on</span> table_name (column_name);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>组合索引</p>
<ul>
<li>组合索引是基于一个表的两个或多个列上创建的索引。基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">on</span> table_name (column1, column2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>是否要创建一个单列索引还是组合索引，要考虑到您在作为查询过滤条件的 WHERE 子句中使用非常频繁的列。</p>
</li>
<li><p>如果只使用到一个列，则选择使用单列索引。如果在作为过滤的 WHERE 子句中有两个或多个列经常使用，则选择使用组合索引。</p>
</li>
<li><p>隐式索引</p>
<ul>
<li>隐式索引是在创建对象时，由数据库服务器自动创建的索引。索引自动创建为主键约束和唯一约束。</li>
</ul>
</li>
<li><p>DROP INDEX 命令</p>
<ul>
<li>一个索引可以使用 SQLite 的 DROP 命令删除。当删除索引时应特别注意，因为性能可能会下降或提高。</li>
<li>基本语法如下：<ul>
<li><code>DROP INDEX index_name;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>什么情况下要避免使用索引？</p>
<ul>
<li>虽然索引的目的在于提高数据库的性能，但这里有几个情况需要避免使用索引。使用索引时，应重新考虑下列准则：<ul>
<li>索引不应该使用在较小的表上。</li>
<li>索引不应该使用在有频繁的大批量的更新或插入操作的表上。</li>
<li>索引不应该使用在含有大量的 NULL 值的列上。</li>
<li>索引不应该使用在频繁操作的列上。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Indexed-By"><a href="#SQLite-Indexed-By" class="headerlink" title="SQLite Indexed By"></a>SQLite Indexed By</h2><ul>
<li><p>“INDEXED BY index-name” 子句规定必须需要命名的索引来查找前面表中值。</p>
</li>
<li><p>如果索引名 index-name 不存在或不能用于查询，然后 SQLite 语句的准备失败。</p>
</li>
<li><p>“NOT INDEXED” 子句规定当访问前面的表（包括由 UNIQUE 和 PRIMARY KEY 约束创建的隐式索引）时，没有使用索引。</p>
</li>
<li><p>然而，即使指定了 “NOT INDEXED”，INTEGER PRIMARY KEY 仍然可以被用于查找条目。</p>
</li>
<li><p>语法</p>
<ul>
<li>下面是 INDEXED BY 子句的语法，它可以与 DELETE、UPDATE 或 SELECT 语句一起使用：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span><span class="operator">|</span><span class="keyword">DELETE</span><span class="operator">|</span><span class="keyword">UPDATE</span> column1, column2...</span><br><span class="line">INDEXED <span class="keyword">BY</span> (index_name)</span><br><span class="line">table_name</span><br><span class="line"><span class="keyword">WHERE</span> (<span class="keyword">CONDITION</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Alter-命令"><a href="#SQLite-Alter-命令" class="headerlink" title="SQLite Alter 命令"></a>SQLite Alter 命令</h2><ul>
<li><p>SQLite 的 ALTER TABLE 命令不通过执行一个完整的转储和数据的重载来修改已有的表。您可以使用 ALTER TABLE 语句重命名表，使用 ALTER TABLE 语句还可以在已有的表中添加额外的列。</p>
</li>
<li><p>在 SQLite 中，除了重命名表和在已有的表中添加列，ALTER TABLE 命令不支持其他操作。</p>
</li>
<li><p>语法</p>
<ul>
<li>用来重命名已有的表的 ALTER TABLE 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> database_name.table_name RENAME <span class="keyword">TO</span> new_table_name;</span><br></pre></td></tr></table></figure></li>
<li>用来在已有的表中添加一个新的列的 ALTER TABLE 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> database_name.table_name <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> column_def...;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Truncate-Table"><a href="#SQLite-Truncate-Table" class="headerlink" title="SQLite Truncate Table"></a>SQLite Truncate Table</h2><ul>
<li><p>在 SQLite 中，并没有 TRUNCATE TABLE 命令，但可以使用 SQLite 的 DELETE 命令从已有的表中删除全部的数据。</p>
</li>
<li><p>语法</p>
<ul>
<li>DELETE 命令的基本语法如下：<ul>
<li><code>sqlite&gt; DELETE FROM table_name;</code></li>
</ul>
</li>
<li>但这种方法无法将递增数归零。</li>
<li>如果要将递增数归零，可以使用以下方法：<ul>
<li><code>sqlite&gt; DELETE FROM sqlite_sequence WHERE name = &#39;table_name&#39;;</code></li>
</ul>
</li>
<li>当 SQLite 数据库中包含自增列时，会自动建立一个名为 sqlite_sequence 的表。这个表包含两个列：name 和 seq。name 记录自增列所在的表，seq 记录当前序号（下一条记录的编号就是当前序号加 1）。如果想把某个自增列的序号归零，只需要修改 sqlite_sequence 表就可以了。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-视图-View"><a href="#SQLite-视图-View" class="headerlink" title="SQLite 视图(View)"></a>SQLite 视图(View)</h2><ul>
<li>视图（View）只不过是通过相关的名称存储在数据库中的一个 SQLite 语句。视图（View）实际上是一个以预定义的 SQLite 查询形式存在的表的组合。</li>
<li>视图（View）可以包含一个表的所有行或从一个或多个表选定行。视图（View）可以从一个或多个表创建，这取决于要创建视图的 SQLite 查询。</li>
<li>视图（View）是一种虚表，允许用户实现以下几点：<ul>
<li>用户或用户组查找结构数据的方式更自然或直观。</li>
<li>限制数据访问，用户只能看到有限的数据，而不是完整的表。</li>
<li>汇总各种表中的数据，用于生成报告。</li>
</ul>
</li>
<li>SQLite 视图是只读的，因此可能无法在视图上执行 DELETE、INSERT 或 UPDATE 语句。但是可以在视图上创建一个触发器，当尝试 DELETE、INSERT 或 UPDATE 视图时触发，需要做的动作在触发器内容中定义。</li>
</ul>
<h2 id="SQLite-事务-Transaction"><a href="#SQLite-事务-Transaction" class="headerlink" title="SQLite 事务(Transaction)"></a>SQLite 事务(Transaction)</h2><ul>
<li><p>事务（Transaction）是一个对数据库执行工作单元。事务（Transaction）是以逻辑顺序完成的工作单位或序列，可以是由用户手动操作完成，也可以是由某种数据库程序自动完成。</p>
</li>
<li><p>事务（Transaction）是指一个或多个更改数据库的扩展。例如，如果您正在创建一个记录或者更新一个记录或者从表中删除一个记录，那么您正在该表上执行事务。重要的是要控制事务以确保数据的完整性和处理数据库错误。</p>
</li>
<li><p>实际上，您可以把许多的 SQLite 查询联合成一组，把所有这些放在一起作为事务的一部分进行执行。</p>
</li>
<li><p>事务的属性</p>
<ul>
<li>事务（Transaction）具有以下四个标准属性，通常根据首字母缩写为 ACID：<ul>
<li>原子性（Atomicity）：确保工作单位内的所有操作都成功完成，否则，事务会在出现故障时终止，之前的操作也会回滚到以前的状态。</li>
<li>一致性（Consistency）：确保数据库在成功提交的事务上正确地改变状态。</li>
<li>隔离性（Isolation）：使事务操作相互独立和透明。</li>
<li>持久性（Durability）：确保已提交事务的结果或效果在系统发生故障的情况下仍然存在。</li>
</ul>
</li>
</ul>
</li>
<li><p>事务控制</p>
<ul>
<li>使用下面的命令来控制事务：<ul>
<li>BEGIN TRANSACTION：开始事务处理。</li>
<li>COMMIT：保存更改，或者可以使用 END TRANSACTION 命令。</li>
<li>ROLLBACK：回滚所做的更改。</li>
</ul>
</li>
<li>事务控制命令只与 DML 命令 INSERT、UPDATE 和 DELETE 一起使用。他们不能在创建表或删除表时使用，因为这些操作在数据库中是自动提交的。</li>
</ul>
</li>
<li><p>BEGIN TRANSACTION 命令</p>
<ul>
<li>事务（Transaction）可以使用 BEGIN TRANSACTION 命令或简单的 BEGIN 命令来启动。此类事务通常会持续执行下去，直到遇到下一个 COMMIT 或 ROLLBACK 命令。不过在数据库关闭或发生错误时，事务处理也会回滚。以下是启动一个事务的简单语法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>COMMIT 命令</p>
<ul>
<li>COMMIT 命令是用于把事务调用的更改保存到数据库中的事务命令。</li>
<li>COMMIT 命令把自上次 COMMIT 或 ROLLBACK 命令以来的所有事务保存到数据库。</li>
<li>COMMIT 命令的语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> TRANSACTION;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ROLLBACK 命令</p>
<ul>
<li>ROLLBACK 命令是用于撤消尚未保存到数据库的事务的事务命令。</li>
<li>ROLLBACK 命令只能用于撤销自上次发出 COMMIT 或 ROLLBACK 命令以来的事务。</li>
<li>ROLLBACK 命令的语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-子查询"><a href="#SQLite-子查询" class="headerlink" title="SQLite 子查询"></a>SQLite 子查询</h2><ul>
<li><p>子查询或称为内部查询、嵌套查询，指的是在 SQLite 查询中的 WHERE 子句中嵌入查询语句。</p>
</li>
<li><p>一个 SELECT 语句的查询结果能够作为另一个语句的输入值。</p>
</li>
<li><p>子查询可以与 SELECT、INSERT、UPDATE 和 DELETE 语句一起使用，可伴随着使用运算符如 &#x3D;、&lt;、&gt;、&gt;&#x3D;、&lt;&#x3D;、IN、BETWEEN 等。</p>
</li>
<li><p>以下是子查询必须遵循的几个规则：</p>
<ul>
<li>子查询必须用括号括起来。</li>
<li>子查询在 SELECT 子句中只能有一个列，除非在主查询中有多列，与子查询的所选列进行比较。</li>
<li>ORDER BY 不能用在子查询中，虽然主查询可以使用 ORDER BY。可以在子查询中使用 GROUP BY，功能与 ORDER BY 相同。</li>
<li>子查询返回多于一行，只能与多值运算符一起使用，如 IN 运算符。</li>
<li>BETWEEN 运算符不能与子查询一起使用，但是，BETWEEN 可在子查询内使用。</li>
</ul>
</li>
<li><p>SELECT 语句中的子查询使用</p>
<ul>
<li>子查询通常与 SELECT 语句一起使用。基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line"><span class="keyword">FROM</span>   table1 [, table2 ]</span><br><span class="line"><span class="keyword">WHERE</span>  column_name OPERATOR</span><br><span class="line">      (<span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line">      <span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">      [<span class="keyword">WHERE</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>INSERT 语句中的子查询使用</p>
<ul>
<li>子查询也可以与 INSERT 语句一起使用。INSERT 语句使用子查询返回的数据插入到另一个表中。在子查询中所选择的数据可以用任何字符、日期或数字函数修改。</li>
<li>基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name [ (column1 [, column2 ]) ]</span><br><span class="line">           <span class="keyword">SELECT</span> [ <span class="operator">*</span><span class="operator">|</span>column1 [, column2 ]</span><br><span class="line">           <span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">           [ <span class="keyword">WHERE</span> <span class="keyword">VALUE</span> OPERATOR ]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>UPDATE 语句中的子查询使用</p>
<ul>
<li>子查询可以与 UPDATE 语句结合使用。当通过 UPDATE 语句使用子查询时，表中单个或多个列被更新</li>
<li>基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">SET</span> column_name <span class="operator">=</span> new_value</span><br><span class="line">[ <span class="keyword">WHERE</span> OPERATOR [ <span class="keyword">VALUE</span> ]</span><br><span class="line">   (<span class="keyword">SELECT</span> COLUMN_NAME</span><br><span class="line">   <span class="keyword">FROM</span> TABLE_NAME)</span><br><span class="line">   [ <span class="keyword">WHERE</span>) ]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>DELETE 语句中的子查询使用</p>
<ul>
<li>子查询可以与 DELETE 语句结合使用，就像上面提到的其他语句一样。</li>
<li>基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> TABLE_NAME</span><br><span class="line">[ <span class="keyword">WHERE</span> OPERATOR [ <span class="keyword">VALUE</span> ]</span><br><span class="line">   (<span class="keyword">SELECT</span> COLUMN_NAME</span><br><span class="line">   <span class="keyword">FROM</span> TABLE_NAME)</span><br><span class="line">   [ <span class="keyword">WHERE</span>) ]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Autoincrement-自动递增"><a href="#SQLite-Autoincrement-自动递增" class="headerlink" title="SQLite Autoincrement (自动递增)"></a>SQLite Autoincrement (自动递增)</h2><ul>
<li><p>SQLite 的 AUTOINCREMENT 是一个关键字，用于表中的字段值自动递增。我们可以在创建表时在特定的列名称上使用 AUTOINCREMENT 关键字实现该字段值的自动增加。</p>
</li>
<li><p>关键字 AUTOINCREMENT 只能用于整型（INTEGER）字段。</p>
</li>
<li><p>语法</p>
<ul>
<li>AUTOINCREMENT 关键字的基本用法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> table_name(</span><br><span class="line">   column1 <span class="type">INTEGER</span> AUTOINCREMENT,</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>假设要创建的 COMPANY 表如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span>   AUTOINCREMENT,</span><br><span class="line">   NAME           TEXT      <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>       <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Explain-解释"><a href="#SQLite-Explain-解释" class="headerlink" title="SQLite Explain (解释)"></a>SQLite Explain (解释)</h2><ul>
<li><p>在 SQLite 语句之前，可以使用 “EXPLAIN” 关键字或 “EXPLAIN QUERY PLAN” 短语，用于描述表的细节。</p>
</li>
<li><p>如果省略了 EXPLAIN 关键字或短语，任何的修改都会引起 SQLite 语句的查询行为，并返回有关 SQLite 语句如何操作的信息。</p>
<ul>
<li>来自 EXPLAIN 和 EXPLAIN QUERY PLAN 的输出只用于交互式分析和排除故障。</li>
<li>输出格式的细节可能会随着 SQLite 版本的不同而有所变化。</li>
<li>应用程序不应该使用 EXPLAIN 或 EXPLAIN QUERY PLAN，因为其确切的行为是可变的且只有部分会被记录。</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>EXPLAIN 的语法如下：<ul>
<li><code>EXPLAIN [SQLite Query]</code></li>
</ul>
</li>
<li>EXPLAIN QUERY PLAN 的语法如下：<ul>
<li><code>EXPLAIN  QUERY PLAN [SQLite Query]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Vacuum"><a href="#SQLite-Vacuum" class="headerlink" title="SQLite Vacuum"></a>SQLite Vacuum</h2><ul>
<li>VACUUM 命令通过复制主数据库中的内容到一个临时数据库文件，然后清空主数据库，并从副本中重新载入原始的数据库文件。这消除了空闲页，把表中的数据排列为连续的，另外会清理数据库文件结构。</li>
<li>如果表中没有明确的整型主键（INTEGER PRIMARY KEY），VACUUM 命令可能会改变表中条目的行 ID（ROWID）。VACUUM 命令只适用于主数据库，附加的数据库文件是不可能使用 VACUUM 命令。</li>
<li>如果有一个活动的事务，VACUUM 命令就会失败。VACUUM 命令是一个用于内存数据库的任何操作。由于 VACUUM 命令从头开始重新创建数据库文件，所以 VACUUM 也可以用于修改许多数据库特定的配置参数。</li>
</ul>
<h2 id="SQLite-日期-时间"><a href="#SQLite-日期-时间" class="headerlink" title="SQLite 日期 &amp; 时间"></a>SQLite 日期 &amp; 时间</h2><ul>
<li><p>SQLite 支持以下五个日期和时间函数：</p>
</li>
<li><p><code>date(timestring, modifier, modifier, ...)</code>	                以 YYYY-MM-DD 格式返回日期。</p>
</li>
<li><p>   <code>time(timestring, modifier, modifier, ...)</code>	                以 HH:MM:SS 格式返回时间。</p>
</li>
<li><p>   <code>datetime(timestring, modifier, modifier, ...)</code>	            以 YYYY-MM-DD HH:MM:SS 格式返回。</p>
</li>
<li><p>   <code>julianday(timestring, modifier, modifier, ...)</code>	          这将返回从格林尼治时间的公元前 4714 年 11 月 24 日正午算起的天数。</p>
</li>
<li><p>   <code>strftime(format, timestring, modifier, modifier, ...)</code>	    这将根据第一个参数指定的格式字符串返回格式化的日期。具体格式见下边讲解。</p>
</li>
<li><p>上述五个日期和时间函数把时间字符串作为参数。时间字符串后跟零个或多个 modifier 修饰符。strftime() 函数也可以把格式字符串 format 作为其第一个参数。下面将为您详细讲解不同类型的时间字符串和修饰符。</p>
</li>
<li><p>时间字符串</p>
<ul>
<li>一个时间字符串可以采用下面任何一种格式：<ul>
<li>YYYY-MM-DD	                2010-12-30</li>
<li>YYYY-MM-DD HH:MM	          2010-12-30 12:10</li>
<li>YYYY-MM-DD HH:MM:SS.SSS	    2010-12-30 12:10:04.100</li>
<li>MM-DD-YYYY HH:MM	          12-30-2010 12:10</li>
<li>HH:MM	                      12:10</li>
<li>YYYY-MM-DDTHH:MM	          2010-12-30 12:10</li>
<li>HH:MM:SS	                  12:10:01</li>
<li>YYYYMMDD HHMMSS	            20101230 121001</li>
<li>now	                        2013-05-07</li>
</ul>
</li>
<li>您可以使用 “T” 作为分隔日期和时间的文字字符。</li>
</ul>
</li>
<li><p>修饰符（Modifier）</p>
<ul>
<li>时间字符串后边可跟着零个或多个的修饰符，这将改变有上述五个函数返回的日期和&#x2F;或时间。任何上述五大功能返回时间。修饰符应从左到右使用，下面列出了可在 SQLite 中使用的修饰符：<ul>
<li>NNN days</li>
<li>NNN hours</li>
<li>NNN minutes</li>
<li>NNN.NNNN seconds</li>
<li>NNN months</li>
<li>NNN years</li>
<li>start of month</li>
<li>start of year</li>
<li>start of day</li>
<li>weekday N</li>
<li>unixepoch</li>
<li>localtime</li>
<li>utc</li>
</ul>
</li>
</ul>
</li>
<li><p>格式化</p>
<ul>
<li>SQLite 提供了非常方便的函数 strftime() 来格式化任何日期和时间。您可以使用以下的替换来格式化日期和时间：</li>
<li>%d	一月中的第几天，01-31</li>
<li>%f	带小数部分的秒，SS.SSS</li>
<li>%H	小时，00-23</li>
<li>%j	一年中的第几天，001-366</li>
<li>%J	儒略日数，DDDD.DDDD</li>
<li>%m	月，00-12</li>
<li>%M	分，00-59</li>
<li>%s	从 1970-01-01 算起的秒数</li>
<li>%S	秒，00-59</li>
<li>%w	一周中的第几天，0-6 (0 is Sunday)</li>
<li>%W	一年中的第几周，01-53</li>
<li>%Y	年，YYYY</li>
<li>%%	% symbol</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>现在让我们使用 SQLite 提示符尝试不同的实例。下面是计算当前日期：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="type">date</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="number">2013</span><span class="number">-05</span><span class="number">-07</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算当前月份的最后一天：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="type">date</span>(<span class="string">&#x27;now&#x27;</span>,<span class="string">&#x27;start of month&#x27;</span>,<span class="string">&#x27;+1 month&#x27;</span>,<span class="string">&#x27;-1 day&#x27;</span>);</span><br><span class="line"><span class="number">2013</span><span class="number">-05</span><span class="number">-31</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算给定 UNIX 时间戳 1092941466 的日期和时间：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> datetime(<span class="number">1092941466</span>, <span class="string">&#x27;unixepoch&#x27;</span>);</span><br><span class="line"><span class="number">2004</span><span class="number">-08</span><span class="number">-19</span> <span class="number">18</span>:<span class="number">51</span>:<span class="number">06</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算给定 UNIX 时间戳 1092941466 相对本地时区的日期和时间：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> datetime(<span class="number">1092941466</span>, <span class="string">&#x27;unixepoch&#x27;</span>, <span class="string">&#x27;localtime&#x27;</span>);</span><br><span class="line"><span class="number">2004</span><span class="number">-08</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">51</span>:<span class="number">06</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算当前的 UNIX 时间戳：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> strftime(<span class="string">&#x27;%s&#x27;</span>,<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="number">1367926057</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算美国”独立宣言”签署以来的天数：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> julianday(<span class="string">&#x27;now&#x27;</span>) <span class="operator">-</span> julianday(<span class="string">&#x27;1776-07-04&#x27;</span>);</span><br><span class="line"><span class="number">86504.4775830326</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算从 2004 年某一特定时刻以来的秒数：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> strftime(<span class="string">&#x27;%s&#x27;</span>,<span class="string">&#x27;now&#x27;</span>) <span class="operator">-</span> strftime(<span class="string">&#x27;%s&#x27;</span>,<span class="string">&#x27;2004-01-01 02:34:56&#x27;</span>);</span><br><span class="line"><span class="number">295001572</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算当年 10 月的第一个星期二的日期：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="type">date</span>(<span class="string">&#x27;now&#x27;</span>,<span class="string">&#x27;start of year&#x27;</span>,<span class="string">&#x27;+9 months&#x27;</span>,<span class="string">&#x27;weekday 2&#x27;</span>);</span><br><span class="line"><span class="number">2013</span><span class="number">-10</span><span class="number">-01</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算从 UNIX 纪元算起的以秒为单位的时间（类似 strftime(‘%s’,’now’) ，不同的是这里有包括小数部分）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> (julianday(<span class="string">&#x27;now&#x27;</span>) <span class="operator">-</span> <span class="number">2440587.5</span>)<span class="operator">*</span><span class="number">86400.0</span>;</span><br><span class="line"><span class="number">1367926077.12598</span></span><br></pre></td></tr></table></figure></li>
<li>在 UTC 与本地时间值之间进行转换，当格式化日期时，使用 utc 或 localtime 修饰符，如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="type">time</span>(<span class="string">&#x27;12:00&#x27;</span>, <span class="string">&#x27;localtime&#x27;</span>);</span><br><span class="line"><span class="number">05</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">sqlite<span class="operator">&gt;</span>  <span class="keyword">SELECT</span> <span class="type">time</span>(<span class="string">&#x27;12:00&#x27;</span>, <span class="string">&#x27;utc&#x27;</span>);</span><br><span class="line"><span class="number">19</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-常用函数"><a href="#SQLite-常用函数" class="headerlink" title="SQLite 常用函数"></a>SQLite 常用函数</h2><ul>
<li><p>SQLite 有许多内置函数用于处理字符串或数字数据。下面列出了一些有用的 SQLite 内置函数，且所有函数都是大小写不敏感，这意味着您可以使用这些函数的小写形式或大写形式或混合形式。欲了解更多详情，请查看 SQLite 的官方文档：</p>
</li>
<li><p>SQLite COUNT 函数</p>
<ul>
<li>SQLite COUNT 聚集函数是用来计算一个数据库表中的行数。</li>
</ul>
</li>
<li><p>SQLite MAX 函数</p>
<ul>
<li>SQLite MAX 聚合函数允许我们选择某列的最大值。</li>
</ul>
</li>
<li><p>SQLite MIN 函数</p>
<ul>
<li>SQLite MIN 聚合函数允许我们选择某列的最小值。</li>
</ul>
</li>
<li><p>SQLite AVG 函数</p>
<ul>
<li>SQLite AVG 聚合函数计算某列的平均值。</li>
</ul>
</li>
<li><p>SQLite SUM 函数</p>
<ul>
<li>SQLite SUM 聚合函数允许为一个数值列计算总和。</li>
</ul>
</li>
<li><p>SQLite RANDOM 函数</p>
<ul>
<li>SQLite RANDOM 函数返回一个介于 -9223372036854775808 和 +9223372036854775807 之间的伪随机整数。</li>
</ul>
</li>
<li><p>SQLite ABS 函数</p>
<ul>
<li>SQLite ABS 函数返回数值参数的绝对值。</li>
</ul>
</li>
<li><p>SQLite UPPER 函数</p>
<ul>
<li>SQLite UPPER 函数把字符串转换为大写字母。</li>
</ul>
</li>
<li><p>SQLite LOWER 函数</p>
<ul>
<li>SQLite LOWER 函数把字符串转换为小写字母。</li>
</ul>
</li>
<li><p>SQLite LENGTH 函数</p>
<ul>
<li>SQLite LENGTH 函数返回字符串的长度。</li>
</ul>
</li>
<li><p>SQLite sqlite_version 函数</p>
<ul>
<li>SQLite sqlite_version 函数返回 SQLite 库的版本。</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>SQLite COUNT 函数</li>
<li>SQLite COUNT 聚集函数是用来计算一个数据库表中的行数。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite MAX 函数</li>
<li>SQLite MAX 聚合函数允许我们选择某列的最大值。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">max</span>(salary) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite MIN 函数</li>
<li>SQLite MIN 聚合函数允许我们选择某列的最小值。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">min</span>(salary) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite AVG 函数</li>
<li>SQLite AVG 聚合函数计算某列的平均值。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">avg</span>(salary) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite SUM 函数</li>
<li>SQLite SUM 聚合函数允许为一个数值列计算总和。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">sum</span>(salary) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite RANDOM 函数</li>
<li>SQLite RANDOM 函数返回一个介于 -9223372036854775808 和 +9223372036854775807 之间的伪随机整数。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> random() <span class="keyword">AS</span> Random;</span><br></pre></td></tr></table></figure></li>
<li>SQLite ABS 函数</li>
<li>SQLite ABS 函数返回数值参数的绝对值。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">abs</span>(<span class="number">5</span>), <span class="built_in">abs</span>(<span class="number">-15</span>), <span class="built_in">abs</span>(<span class="keyword">NULL</span>), <span class="built_in">abs</span>(<span class="number">0</span>), <span class="built_in">abs</span>(&quot;ABC&quot;);</span><br></pre></td></tr></table></figure></li>
<li>SQLite UPPER 函数</li>
<li>SQLite UPPER 函数把字符串转换为大写字母。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">upper</span>(name) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite LOWER 函数</li>
<li>SQLite LOWER 函数把字符串转换为小写字母。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">lower</span>(name) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite LENGTH 函数</li>
<li>SQLite LENGTH 函数返回字符串的长度。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name, length(name) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite sqlite_version 函数</li>
<li>SQLite sqlite_version 函数返回 SQLite 库的版本。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> sqlite_version() <span class="keyword">AS</span> <span class="string">&#x27;SQLite Version&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sql_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sql_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">sql_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sql的相关理论知识</li>
</ul>
<h2 id="ODB-详解"><a href="#ODB-详解" class="headerlink" title="ODB 详解"></a>ODB 详解</h2><p>ODB（Object-Relational Mapping Database）是一个开源的 C++ 对象关系映射（ORM）工具，用于将 C++ 对象和数据库之间进行映射。它提供了一个简洁的接口和代码生成工具，用于自动生成和维护数据库访问代码。以下是关于 ODB 的一些详解：</p>
<ol>
<li><p><strong>定义数据模型</strong>：使用 ODB，你可以使用 C++ 类来定义数据模型。通过在类声明中添加 ODB 注解，你可以指定类和成员变量与数据库表格和字段的映射关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ODB 表格声明</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> db table(<span class="string">&quot;people&quot;</span>)</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">DbTable</span> &#123;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="comment">// ODB 字段声明</span></span><br><span class="line">                <span class="meta">#<span class="keyword">pragma</span> db id</span></span><br><span class="line">                <span class="type">int</span> id;</span><br><span class="line">                std::string name;</span><br><span class="line">                <span class="type">int</span> age;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 成员变量与表格字段的映射</span></span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        std::string name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码生成工具</strong>：ODB 提供了一个代码生成工具，用于根据定义的数据模型自动生成数据库访问代码。你可以使用 ODB 编译器来处理类定义文件，并生成与数据库交互的代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odb --std c++14 --database sqlite --generate-query --generate-schema Person.hpp</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询和持久化</strong>：使用 ODB，你可以通过简单的 C++ 语法进行数据库查询和持久化操作。ODB 提供了类型安全的查询接口，支持复杂的查询条件和结果集的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">odb::query&lt;Person&gt; <span class="title">q</span><span class="params">(odb::query&lt;Person&gt;::name == <span class="string">&quot;John&quot;</span> &amp;&amp; odb::query&lt;Person&gt;::age &gt; <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">odb::result&lt;Person&gt; <span class="title">result</span><span class="params">(db.query&lt;Person&gt;(q))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; person : result) &#123;</span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person;</span><br><span class="line">person.name = <span class="string">&quot;Jane&quot;</span>;</span><br><span class="line">person.age = <span class="number">25</span>;</span><br><span class="line">db.<span class="built_in">persist</span>(person);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务处理</strong>：ODB 支持事务操作，你可以使用 <code>odb::transaction</code> 对象来管理一系列数据库操作的原子性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">odb::transaction <span class="title">txn</span><span class="params">(db)</span></span>;</span><br><span class="line">    <span class="comment">// 执行一系列的数据库操作</span></span><br><span class="line">    txn.<span class="built_in">commit</span>(); <span class="comment">// 提交事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：ODB 使用异常来处理错误情况。当出现错误时，它会抛出异常，你可以使用 try-catch 块来捕获并处理这些异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> odb::exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>ODB 提供了详细的文档和示例代码，以帮助你更深入地了解和使用它。你可以在 ODB 的官方网站上找到更多信息：<a target="_blank" rel="noopener" href="https://www.codesynthesis.com/products/odb/">https://www.codesynthesis.com/products/odb/</a></p>
<p>需要注意的是，ODB 是一个功能强大且全面的 C++ ORM 工具，它提供了许多高级特性和灵活性。使用 ODB 需要一些学习和配置的成本，但它能够显著简化和加速与数据库的交互。</p>
<p>希望这些详解能够帮助你更好地理解和使用 ODB！如果你有更多问题，请随时提问。</p>
<h2 id="ORMpp-详解"><a href="#ORMpp-详解" class="headerlink" title="ORMpp 详解"></a>ORMpp 详解</h2><p>ORMpp 是一个轻量级的 C++ ORM（对象关系映射）库，专为 SQLite3 数据库设计。它提供了简单的接口和注解，用于定义数据模型和数据库关系。以下是关于 ORMpp 的一些详解：</p>
<ol>
<li><p><strong>定义数据模型</strong>：使用 ORMpp，你可以使用 C++ 结构体或类来定义数据模型。你可以使用注解来标记成员变量，指定表格名称、字段名称、字段类型和约束等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="built_in">ORMPP_ENTITY</span>(Person) <span class="comment">// 声明实体</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ORMPP_ID</span>(<span class="type">int</span>, id) <span class="comment">// 主键字段</span></span><br><span class="line">    <span class="built_in">ORMPP_FIELD</span>(std::string, name) <span class="comment">// 字符串字段</span></span><br><span class="line">    <span class="built_in">ORMPP_FIELD</span>(<span class="type">int</span>, age) <span class="comment">// 整数字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据库迁移</strong>：ORMpp 支持数据库迁移，可以自动创建和更新数据库表格结构。你可以使用 <code>ormpp::data_migration</code> 对象来定义表格的创建、修改和删除操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ormpp::data_migration dm;</span><br><span class="line">dm.<span class="built_in">create_table</span>&lt;Person&gt;(); <span class="comment">// 创建表格</span></span><br><span class="line">dm.<span class="built_in">add_column</span>&lt;Person&gt;(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;TEXT&quot;</span>); <span class="comment">// 添加字段</span></span><br><span class="line">dm.<span class="built_in">drop_table</span>&lt;Person&gt;(); <span class="comment">// 删除表格</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询构建器</strong>：ORMpp 提供了查询构建器，使得构建 SQL 查询变得更加简单。你可以使用链式方法来构建查询条件、排序和限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ormpp::sql_query query;</span><br><span class="line">query.<span class="built_in">select</span>(<span class="string">&quot;*&quot;</span>).<span class="built_in">from</span>&lt;Person&gt;().<span class="built_in">where</span>(ormpp::<span class="built_in">c</span>(&amp;Person::age) &gt; <span class="number">18</span>).<span class="built_in">order_by</span>(<span class="string">&quot;name&quot;</span>).<span class="built_in">limit</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> results = db.<span class="built_in">query</span>(query);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务处理</strong>：ORMpp 支持事务操作，你可以使用 <code>ormpp::transaction</code> 对象来管理一系列数据库操作的原子性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">ormpp::transaction <span class="title">txn</span><span class="params">(db)</span></span>;</span><br><span class="line">    <span class="comment">// 执行一系列的数据库操作</span></span><br><span class="line">    txn.<span class="built_in">commit</span>(); <span class="comment">// 提交事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：ORMpp 使用异常来处理错误情况。当出现错误时，它会抛出异常，你可以使用 try-catch 块来捕获并处理这些异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>ORMpp 提供了清晰的文档和示例代码，以帮助你更详细地了解和使用它。你可以在 ORMpp 的 GitHub 页面上找到更多信息：<a target="_blank" rel="noopener" href="https://github.com/qicosmos/ormpp">https://github.com/qicosmos/ormpp</a></p>
<p>需要注意的是，ORMpp 是一个轻量级的 C++ ORM 库，它在简化 SQLite3 数据库的使用过程中提供了便捷的接口和功能。但在使用之前，你仍然需要熟悉 SQL 查询语句和 SQLite3 数据库的概念。</p>
<p>希望这些详解能够帮助你更好地理解和使用 ORMpp！如果你有更多问题，请随时提问。</p>
<h2 id="SQLite-Modern-C-详解"><a href="#SQLite-Modern-C-详解" class="headerlink" title="SQLite Modern C++ 详解"></a>SQLite Modern C++ 详解</h2><p>SQLite Modern C++ 是一个基于 C++11 的轻量级 SQLite3 封装库，提供了简单而直观的接口，使在 C++ 项目中使用 SQLite3 数据库更加便捷。以下是关于 SQLite Modern C++ 的一些详解：</p>
<ol>
<li><p><strong>面向对象接口</strong>：SQLite Modern C++ 提供了面向对象的接口，使用类和方法来操作数据库。你可以创建表格类来表示数据库表格，使用成员变量和方法来操作表格中的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义表格类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">Person person&#123;<span class="number">1</span>, <span class="string">&quot;John Doe&quot;</span>, <span class="number">25</span>&#125;;</span><br><span class="line">db.<span class="built_in">insert</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line"><span class="keyword">auto</span> results = db.<span class="built_in">select</span>&lt;Person&gt;(<span class="string">&quot;SELECT * FROM people&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; person : results) &#123;</span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型安全</strong>：SQLite Modern C++ 在运行时执行类型检查，确保查询和绑定的类型正确。这可以避免在 SQL 查询中出现类型不匹配的错误。</p>
</li>
<li><p><strong>查询构建器</strong>：SQLite Modern C++ 提供了查询构建器，允许你以链式方式构建 SQL 查询，而不需要手动拼接 SQL 语句。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> query = db</span><br><span class="line">    .<span class="built_in">select</span>(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">    .<span class="built_in">from</span>(<span class="string">&quot;people&quot;</span>)</span><br><span class="line">    .<span class="built_in">where</span>(<span class="string">&quot;age &gt; ?&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    .<span class="built_in">order_by</span>(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    .<span class="built_in">limit</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> results = query.<span class="built_in">execute</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务处理</strong>：SQLite Modern C++ 支持事务操作，你可以使用 <code>transaction</code> 对象来管理一系列数据库操作的原子性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">transaction <span class="title">txn</span><span class="params">(db)</span></span>;</span><br><span class="line">    <span class="comment">// 执行一系列的数据库操作</span></span><br><span class="line">    txn.<span class="built_in">commit</span>(); <span class="comment">// 提交事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：SQLite Modern C++ 使用异常来处理错误情况。当出现错误时，它会抛出异常，你可以使用 try-catch 块来捕获并处理这些异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>SQLite Modern C++ 提供了清晰的文档和示例代码，以帮助你更详细地了解和使用它。你可以在 SQLite Modern C++ 的 GitHub 页面上找到更多信息：<a target="_blank" rel="noopener" href="https://github.com/SqliteModernCpp/sqlite_modern_cpp">https://github.com/SqliteModernCpp/sqlite_modern_cpp</a></p>
<p>需要注意的是，SQLite Modern C++ 是一个轻量级的封装库，它在简化 SQLite3 数据库的使用过程中提供了便捷的接口，但在使用之前，你仍然需要熟悉 SQL 查询语句和 SQLite3 数据库的概念。</p>
<p>希望这些详解能够帮助你更好地理解和使用 SQLite Modern C++！如果你有更多问题，请随时提问。</p>
<h2 id="SQLite3-ORM-常用第三方库"><a href="#SQLite3-ORM-常用第三方库" class="headerlink" title="SQLite3 ORM 常用第三方库"></a>SQLite3 ORM 常用第三方库</h2><p>在 C++ 中，有几个常用的第三方库可用于提供 SQLite3 ORM（对象关系映射）功能。以下是一些常用的 C++ SQLite3 ORM 第三方库：</p>
<ol>
<li><p>**SQLite Modern C++**：SQLite Modern C++ 是一个轻量级的 C++ 封装库，提供了简单而直观的接口，使得在 C++ 项目中使用 SQLite3 数据库更加便捷。它支持对象关系映射和查询构建器，并提供了对数据库的增删改查操作的封装。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/SqliteModernCpp/sqlite_modern_cpp">https://github.com/SqliteModernCpp/sqlite_modern_cpp</a></p>
</li>
<li><p><strong>SQLiteCpp</strong>：SQLiteCpp 是一个基于 C++11 的 SQLite3 封装库，提供了面向对象的接口，使得在 C++ 项目中使用 SQLite3 更加简单和方便。它支持对象关系映射和事务处理，并提供了简洁的 API 来进行数据库操作。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/SRombauts/SQLiteCpp">https://github.com/SRombauts/SQLiteCpp</a></p>
</li>
<li><p><strong>ORMpp</strong>：ORMpp 是一个轻量级的 C++ ORM 库，专为 SQLite3 数据库设计。它提供了简单的接口和注解，用于定义数据模型和数据库关系。ORMpp 支持数据库迁移、查询构建器和事务处理等功能。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/iansimon/ormpp">https://github.com/iansimon/ormpp</a></p>
</li>
<li><p><strong>Qt SQL</strong>：Qt 是一个功能强大的 C++ 框架，其中的 Qt SQL 模块提供了对各种数据库的访问功能，包括 SQLite3。使用 Qt SQL，你可以通过对象关系映射和查询构建器来操作 SQLite3 数据库。</p>
<p>官方网站：<a target="_blank" rel="noopener" href="https://www.qt.io/">https://www.qt.io/</a></p>
</li>
</ol>
<p>这些库都可以帮助你在 C++ 中使用 SQLite3 数据库，并提供了不同程度的 ORM 功能。你可以根据项目需求、库的易用性和适配性来选择最适合的库。</p>
<p>需要注意的是，这些库都是第三方工具，你需要根据你的项目要求和预期的功能选择适合的库，并仔细阅读它们的文档和示例代码以了解如何使用它们。</p>
<p>希望这些信息对你有帮助！如有更多问题，请随时提问。</p>
<h2 id="C-REST-SDK-详解"><a href="#C-REST-SDK-详解" class="headerlink" title="C++ REST SDK 详解"></a>C++ REST SDK 详解</h2><p>C++ REST SDK（又称为 Casablanca）是一个功能强大的 C++ 库，用于构建基于 HTTP 的客户端和服务器应用程序。它提供了一组丰富的功能和工具，用于处理网络请求、JSON 解析、异步任务等。以下是关于 C++ REST SDK 的一些详解：</p>
<ol>
<li><p><strong>HTTP 客户端</strong>：C++ REST SDK 提供了一个强大的 HTTP 客户端库，用于发送和接收 HTTP 请求和响应。你可以通过创建 <code>http_client</code> 对象，指定请求的 URI、方法、头部、消息正文等来发起 HTTP 请求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web::http::<span class="function">client::http_client <span class="title">client</span><span class="params">(U(<span class="string">&quot;http://example.com&quot;</span>))</span></span>;</span><br><span class="line">web::http::http_response response = client.<span class="built_in">request</span>(web::http::methods::GET).<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>HTTP 服务器</strong>：C++ REST SDK 允许你创建基于 HTTP 的服务器应用程序。你可以创建一个 <code>http_listener</code> 对象，并为特定的 URI 和方法注册处理程序来处理传入的请求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">web::http::experimental::<span class="function">listener::http_listener <span class="title">listener</span><span class="params">(U(<span class="string">&quot;http://localhost:8080&quot;</span>))</span></span>;</span><br><span class="line">listener.<span class="built_in">support</span>(web::http::methods::GET, [](web::http::http_request request) &#123;</span><br><span class="line">    <span class="comment">// 处理 GET 请求</span></span><br><span class="line">&#125;);</span><br><span class="line">listener.<span class="built_in">open</span>().<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异步任务和并发</strong>：C++ REST SDK 使用异步任务模型来处理并发操作。它提供了 <code>pplx::task</code> 类，用于处理异步操作和等待任务完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pplx::task&lt;std::string&gt; task = client.<span class="built_in">request</span>(web::http::methods::GET).<span class="built_in">then</span>([](web::http::http_response response) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="built_in">extract_string</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">task.<span class="built_in">then</span>([](<span class="type">const</span> std::string&amp; content) &#123;</span><br><span class="line">    <span class="comment">// 处理异步任务结果</span></span><br><span class="line">&#125;).<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JSON 解析和序列化</strong>：C++ REST SDK 提供了用于解析和序列化 JSON 数据的工具。你可以使用 <code>web::json::value</code> 类来表示和操作 JSON 对象和数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">web::json::value json;</span><br><span class="line">json[<span class="built_in">U</span>(<span class="string">&quot;name&quot;</span>)] = web::json::value::<span class="built_in">string</span>(<span class="built_in">U</span>(<span class="string">&quot;John&quot;</span>));</span><br><span class="line">json[<span class="built_in">U</span>(<span class="string">&quot;age&quot;</span>)] = web::json::value::<span class="built_in">number</span>(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">web::json::value::<span class="type">string_t</span> name = json[<span class="built_in">U</span>(<span class="string">&quot;name&quot;</span>)].<span class="built_in">as_string</span>();</span><br><span class="line"><span class="type">int</span> age = json[<span class="built_in">U</span>(<span class="string">&quot;age&quot;</span>)].<span class="built_in">as_integer</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>其他功能</strong>：C++ REST SDK 还提供了许多其他功能，如支持 HTTPS、网络代理、cookie 管理、身份验证等。</p>
</li>
</ol>
<p>C++ REST SDK 的 GitHub 页面提供了详细的文档和示例代码，以帮助你更深入地了解和使用它：<a target="_blank" rel="noopener" href="https://github.com/microsoft/cpprestsdk">https://github.com/microsoft/cpprestsdk</a></p>
<p>C++ REST SDK 是一个强大而全面的库，适用于构建基于 HTTP 的客户端和服务器应用程序。它可以帮助你轻松处理网络请求、JSON 数据和异步操作。</p>
<p>希望这些详解能够帮助你更好地理解和使用 C++ REST SDK！如果你有更多问题，请随时提问。</p>
<h2 id="OTL-详解"><a href="#OTL-详解" class="headerlink" title="OTL 详解"></a>OTL 详解</h2><p>OTL（OCCI Template Library）是一个用于 C++ 的通用数据库访问库，它提供了高性能和灵活的接口，用于访问多种数据库。以下是关于 OTL 的一些详解：</p>
<ol>
<li><p><strong>支持多种数据库</strong>：OTL 支持多种常见的数据库系统，包括 Oracle、Microsoft SQL Server、IBM DB2、MySQL、PostgreSQL 等。你可以使用相同的接口和代码来访问不同类型的数据库，而不需要学习和使用特定数据库的 API。</p>
</li>
<li><p><strong>面向对象接口</strong>：OTL 提供了面向对象的接口，通过类和方法来操作数据库。它使用了现代 C++ 特性，如模板和 RAII（资源获取即初始化），使得代码更加清晰和易于维护。</p>
</li>
<li><p><strong>连接管理</strong>：使用 OTL，你可以通过提供连接字符串来建立和管理与数据库的连接。连接字符串包括数据库类型、主机名、端口号、用户名、密码等信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">otl_connect db;</span><br><span class="line">db.<span class="built_in">rlogon</span>(<span class="string">&quot;username/password@tnsname&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询执行</strong>：使用 OTL，你可以通过编写 SQL 查询语句来与数据库进行交互。你可以直接执行原始的 SQL 语句，也可以使用绑定变量和查询构建器来构建和执行查询。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">otl_stream stream;</span><br><span class="line">stream.<span class="built_in">open</span>(<span class="number">1</span>, <span class="string">&quot;SELECT name, age FROM users WHERE age &gt; :age&quot;</span>, db);</span><br><span class="line">stream &lt;&lt; <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stream.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    stream &gt;&gt; name &gt;&gt; age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务处理</strong>：OTL 支持事务操作，你可以使用事务对象来管理一系列数据库操作的原子性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">otl_trans <span class="title">transaction</span><span class="params">(db)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一系列的数据库操作</span></span><br><span class="line"></span><br><span class="line">transaction.<span class="built_in">commit</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：OTL 使用异常来处理错误情况。当出现错误时，它会抛出相应的异常，你可以使用 try-catch 块来捕获并处理这些异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (otl_exception&amp; ex) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>灵活性和可扩展性</strong>：OTL 具有灵活和可扩展的架构，你可以通过编写自定义的 OTL 数据库后端适配器来支持其他数据库系统。</p>
</li>
</ol>
<p>OTL 提供了详细的文档和示例代码，以帮助你更深入地了解和使用它。你可以在 OTL 的官方网站上找到更多信息：<a target="_blank" rel="noopener" href="http://otl.sourceforge.net/">http://otl.sourceforge.net/</a></p>
<p>需要注意的是，OTL 是一个相对底层的库，使用它需要对 SQL 查询语句和数据库概念有一定的了解。</p>
<p>希望这些详解能够帮助你更好地理解和使用 OTL！如果你有更多问题，请随时提问。</p>
<h2 id="SOCI-详解"><a href="#SOCI-详解" class="headerlink" title="SOCI 详解"></a>SOCI 详解</h2><p>SOCI（The C++ Database Access Library）是一个通用的数据库访问库，它提供了简单和一致的接口，用于在 C++ 中访问多种不同类型的数据库。下面是关于 SOCI 的一些详解：</p>
<ol>
<li><p><strong>支持多种数据库</strong>：SOCI 支持多种常见的数据库系统，包括 SQLite、MySQL、PostgreSQL、Oracle、ODBC 等。你可以使用相同的接口和代码来访问不同类型的数据库，而不需要学习和使用特定数据库的 API。</p>
</li>
<li><p><strong>面向对象接口</strong>：SOCI 提供了面向对象的接口，通过类和方法来操作数据库。它使用了现代 C++ 特性，如模板和 RAII（资源获取即初始化），使得代码更加清晰和易于维护。</p>
</li>
<li><p><strong>连接管理</strong>：使用 SOCI，你可以通过提供连接字符串来建立和管理与数据库的连接。连接字符串包括数据库类型、主机名、端口号、用户名、密码等信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">soci::session <span class="title">sql</span><span class="params">(<span class="string">&quot;mysql://user:password@localhost/mydatabase&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询执行</strong>：使用 SOCI，你可以通过编写 SQL 查询语句来与数据库进行交互。你可以直接执行原始的 SQL 语句，也可以使用绑定变量和查询构建器来构建和执行查询。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">soci::rowset&lt;row&gt; rs = (sql.prepare &lt;&lt; <span class="string">&quot;SELECT name, age FROM users WHERE age &gt; :age&quot;</span>, soci::<span class="built_in">use</span>(<span class="number">18</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; r : rs) &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    r.<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(name);</span><br><span class="line">    r.<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(age);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务处理</strong>：SOCI 支持事务操作，你可以使用事务对象来管理一系列数据库操作的原子性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">soci::transaction <span class="title">tr</span><span class="params">(sql)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一系列的数据库操作</span></span><br><span class="line"></span><br><span class="line">tr.<span class="built_in">commit</span>(); <span class="comment">// 提交事务</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：SOCI 使用异常来处理错误情况。当出现错误时，它会抛出相应的异常，你可以使用 try-catch 块来捕获并处理这些异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> soci::soci_error&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>灵活性和可扩展性</strong>：SOCI 具有灵活和可扩展的架构，你可以通过编写自定义后端适配器来支持其他数据库系统。</p>
</li>
</ol>
<p>SOCI 提供了丰富的文档和示例代码，以帮助你更详细地了解和使用它。你可以在 SOCI 的官方网站上找到更多信息：<a target="_blank" rel="noopener" href="http://soci.sourceforge.net/">http://soci.sourceforge.net/</a></p>
<p>需要注意的是，SOCI 是一个相对底层的库，使用它需要对 SQL 查询语句和数据库概念有一定的了解。</p>
<p>希望这些详解能够帮助你更好地理解和使用 SOCI！如果你有更多问题，请随时提问。</p>
<h2 id="sqlitecpp-详解"><a href="#sqlitecpp-详解" class="headerlink" title="sqlitecpp 详解"></a>sqlitecpp 详解</h2><p>SQLiteCpp 是一个在 C++ 中使用 SQLite 数据库的轻量级封装库。它提供了简单且直观的面向对象的接口，使得在 C++ 项目中使用 SQLite 数据库更加便捷。</p>
<p>以下是 SQLiteCpp 的一些主要特点和用法的详解：</p>
<ol>
<li><p><strong>面向对象接口</strong>：SQLiteCpp 提供了一个面向对象的接口，通过类和方法来操作数据库。它使用了现代 C++ 特性，如 RAII（资源获取即初始化）和异常处理，使得代码更加清晰和易于维护。</p>
</li>
<li><p><strong>数据库连接</strong>：使用 SQLite::Database 类可以创建和管理与 SQLite 数据库的连接。你可以通过指定数据库文件的路径来打开数据库连接，也可以使用内存数据库。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SQLite::Database <span class="title">db</span><span class="params">(<span class="string">&quot;example.db&quot;</span>)</span></span>; <span class="comment">// 打开名为 &quot;example.db&quot; 的数据库文件连接</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询执行</strong>：你可以使用 SQLite::Statement 类执行 SQL 查询语句，并通过绑定参数和读取结果集来与数据库交互。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SQLite::Statement <span class="title">query</span><span class="params">(db, <span class="string">&quot;SELECT * FROM users WHERE age &gt; ?&quot;</span>)</span></span>;</span><br><span class="line">query.<span class="built_in">bind</span>(<span class="number">1</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (query.<span class="built_in">executeStep</span>()) &#123;</span><br><span class="line">    std::string name = query.<span class="built_in">getColumn</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> age = query.<span class="built_in">getColumn</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务处理</strong>：SQLiteCpp 支持事务操作，通过 SQLite::Transaction 类可以实现简单的事务控制，保证一系列的数据库操作的原子性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SQLite::Transaction <span class="title">transaction</span><span class="params">(db)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一系列的数据库操作</span></span><br><span class="line"></span><br><span class="line">transaction.<span class="built_in">commit</span>(); <span class="comment">// 提交事务</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据库操作</strong>：SQLiteCpp 提供了许多便捷的方法来执行数据库操作，包括插入、更新、删除等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SQLite::Statement <span class="title">insert</span><span class="params">(db, <span class="string">&quot;INSERT INTO users (name, age) VALUES (?, ?)&quot;</span>)</span></span>;</span><br><span class="line">insert.<span class="built_in">bind</span>(<span class="number">1</span>, <span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">insert.<span class="built_in">bind</span>(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line">insert.<span class="built_in">exec</span>(); <span class="comment">// 执行插入操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：SQLiteCpp 在出现错误时会抛出异常，你可以使用 try-catch 块来捕获并处理这些异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>SQLiteCpp 提供了丰富的文档和示例代码，以帮助你更详细地了解和使用它。你可以在它的 GitHub 页面上找到更多信息：<a target="_blank" rel="noopener" href="https://github.com/SRombauts/SQLiteCpp">https://github.com/SRombauts/SQLiteCpp</a></p>
<p>需要注意的是，尽管 SQLiteCpp 简化了在 C++ 中使用 SQLite 数据库的过程，你仍然需要熟悉 SQL 查询语句和 SQLite 数据库的概念。</p>
<p>希望这些详解能够帮助你更好地理解和使用 SQLiteCpp！如果你有更多问题，请随时提问。</p>
<h2 id="sqlite3-orm-第三方工具-推荐"><a href="#sqlite3-orm-第三方工具-推荐" class="headerlink" title="sqlite3 orm 第三方工具 推荐"></a>sqlite3 orm 第三方工具 推荐</h2><p>在 C++ 中，有几个流行的第三方工具可用于提供 SQLite3 ORM（对象关系映射）功能。以下是一些常用的 C++ SQLite3 ORM 第三方库：</p>
<ol>
<li><p>SQLiteCpp：SQLiteCpp 是一个轻量级的 C++ 封装库，提供了对 SQLite 数据库的面向对象访问接口。它使用现代 C++ 特性，简化了与 SQLite 数据库的交互，支持查询构建、事务处理等功能。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/SRombauts/SQLiteCpp">https://github.com/SRombauts/SQLiteCpp</a></p>
</li>
<li><p>SOCI：SOCI 是一个通用的数据库访问库，支持多种数据库，包括 SQLite。它提供了面向对象的接口，可以简化数据库操作，包括查询、插入、更新等。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/SOCI/soci">https://github.com/SOCI/soci</a></p>
</li>
<li><p>OTL：OTL（OCCI Template Library）是一个通用的数据库访问库，也支持 SQLite 数据库。它提供了面向对象的接口，支持事务处理、预编译语句等功能。</p>
<p>官方网站：<a target="_blank" rel="noopener" href="http://otl.sourceforge.net/">http://otl.sourceforge.net/</a></p>
</li>
<li><p>C++ REST SDK：C++ REST SDK 是一个功能强大的 C++ 库，提供了丰富的功能，包括 HTTP 客户端&#x2F;服务器、JSON 解析、异步任务等。它也提供了对 SQLite 数据库的支持，可以用作 ORM。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/microsoft/cpprestsdk">https://github.com/microsoft/cpprestsdk</a></p>
</li>
</ol>
<p>这些库都可以帮助你在 C++ 中使用 SQLite3 数据库，并提供了不同程度的 ORM 功能。你可以根据项目的需求、库的易用性和适配性来选择最适合的库。</p>
<p>需要注意的是，这些库都是第三方工具，你需要根据你的项目要求和预期的功能选择适合的库，并仔细阅读它们的文档和示例代码以了解如何使用它们。</p>
<p>希望这些推荐对你有所帮助！如有更多问题，请随时提问。</p>
<h2 id="sql语法和mysql-关系"><a href="#sql语法和mysql-关系" class="headerlink" title="sql语法和mysql 关系"></a>sql语法和mysql 关系</h2><p>SQL（Structured Query Language）是一种用于管理关系型数据库系统的编程语言。它提供了一套标准化的语法和操作，用于查询、操作和管理数据库中的数据。MySQL是一个开源的关系型数据库管理系统（RDBMS），它支持使用SQL语言进行数据库操作。</p>
<p>SQL语法定义了一组规则和约定，用于编写查询和操作数据库的语句。它包括以下几个主要方面：</p>
<ol>
<li><p>数据定义语言（DDL）：DDL用于定义数据库的结构和模式。它包括创建数据库、创建表、定义表的列和约束等操作。例如，使用DDL语句可以创建一个名为”employees”的表，定义其列和数据类型：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据操作语言（DML）：DML用于插入、更新和删除数据库中的数据。它包括INSERT、UPDATE和DELETE语句，用于执行相应的操作。例如，使用DML语句可以向”employees”表中插入一条新记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> employees (id, name, age, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;John Doe&#x27;</span>, <span class="number">30</span>, <span class="number">50000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据查询语言（DQL）：DQL用于从数据库中检索数据。它包括SELECT语句，用于查询和过滤数据。例如，使用DQL语句可以查询”employees”表中年龄大于等于25岁的员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据控制语言（DCL）：DCL用于控制数据库用户的访问权限和安全性。它包括GRANT和REVOKE语句，用于授予和撤销用户的权限。例如，使用DCL语句可以授予用户”john”对”employees”表的SELECT权限：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> employees <span class="keyword">TO</span> john;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>MySQL是一个流行的关系型数据库管理系统，它实现了SQL语言标准，并提供了额外的功能和扩展。MySQL支持大多数SQL语法的标准化操作，如DDL、DML、DQL和DCL。通过MySQL，你可以创建和管理数据库，创建表和索引，执行查询和数据操作，以及控制用户的权限。</p>
<p>总而言之，SQL是一种用于管理关系型数据库的标准化语言，而MySQL是一个实现了SQL标准的关系型数据库管理系统。通过使用SQL语法，你可以在MySQL数据库中执行各种操作，包括创建和定义数据库结构、插入、更新和删除数据，以及查询和检索数据。</p>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul>
<li>SQL 是用于访问和处理数据库的标准的计算机语言。</li>
<li>在本教程中，您将学到如何使用 SQL 访问和处理数据系统中的数据，这类数据库包括：MySQL、SQL Server、Access、Oracle、Sybase、DB2 等等。</li>
</ul>
<h2 id="1-1-SQL-简介"><a href="#1-1-SQL-简介" class="headerlink" title="1.1 SQL 简介"></a>1.1 SQL 简介</h2><ul>
<li>SQL (Structured Query Language:结构化查询语言) 是用于管理关系数据库管理系统（RDBMS）。 </li>
<li>SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</li>
</ul>
<h3 id="1-1-1-SQL-是什么"><a href="#1-1-1-SQL-是什么" class="headerlink" title="1.1.1 SQL 是什么"></a>1.1.1 SQL 是什么</h3><ul>
<li>SQL 指结构化查询语言，全称是 Structured Query Language。</li>
<li>SQL 让您可以访问和处理数据库，包括数据插入、查询、更新和删除。</li>
<li>SQL 在1986年成为 ANSI（American National Standards Institute 美国国家标准化组织）的一项标准，在 1987 年成为国际标准化组织（ISO）标准。</li>
</ul>
<h3 id="1-1-2-SQL-能做什么"><a href="#1-1-2-SQL-能做什么" class="headerlink" title="1.1.2 SQL 能做什么"></a>1.1.2 SQL 能做什么</h3><ul>
<li>SQL 面向数据库执行查询</li>
<li>SQL 可从数据库取回数据</li>
<li>SQL 可在数据库中插入新的记录</li>
<li>SQL 可更新数据库中的数据</li>
<li>SQL 可从数据库删除记录</li>
<li>SQL 可创建新数据库</li>
<li>SQL 可在数据库中创建新表</li>
<li>SQL 可在数据库中创建存储过程</li>
<li>SQL 可在数据库中创建视图</li>
<li>SQL 可以设置表、存储过程和视图的权限</li>
</ul>
<h3 id="1-1-3-SQL-是一种标准-但是…"><a href="#1-1-3-SQL-是一种标准-但是…" class="headerlink" title="1.1.3 SQL 是一种标准 - 但是…"></a>1.1.3 SQL 是一种标准 - 但是…</h3><ul>
<li><p>虽然 SQL 是一门 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言，但是仍然存在着多种不同版本的 SQL 语言。</p>
</li>
<li><p>然而，为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的命令（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等）。</p>
</li>
<li><p>注释：除了 SQL 标准之外，大部分 SQL 数据库程序都拥有它们自己的专有扩展！</p>
</li>
</ul>
<h3 id="1-1-4-RDBMS"><a href="#1-1-4-RDBMS" class="headerlink" title="1.1.4 RDBMS"></a>1.1.4 RDBMS</h3><ul>
<li>RDBMS 指关系型数据库管理系统，全称 Relational Database Management System。</li>
<li>RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server、IBM DB2、Oracle、MySQL 以及 Microsoft Access。</li>
<li>RDBMS 中的数据存储在被称为表的数据库对象中。</li>
<li>表是相关的数据项的集合，它由列和行组成。</li>
</ul>
<h2 id="1-2-SQL-语法"><a href="#1-2-SQL-语法" class="headerlink" title="1.2 SQL 语法"></a>1.2 SQL 语法</h2><h3 id="1-2-1-数据库表"><a href="#1-2-1-数据库表" class="headerlink" title="1.2.1 数据库表"></a>1.2.1 数据库表</h3><ul>
<li>一个数据库通常包含一个或多个表。每个表有一个名字标识（例如:”Websites”）,表包含带有数据的记录（行）。</li>
</ul>
<h3 id="1-2-2-SQL-语句"><a href="#1-2-2-SQL-语句" class="headerlink" title="1.2.2 SQL 语句"></a>1.2.2 SQL 语句</h3><ul>
<li><p>SQL 对大小写不敏感：SELECT 与 select 是相同的。</p>
</li>
<li><p>某些数据库系统要求在每条 SQL 语句的末端使用分号。</p>
</li>
<li><p>分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。</p>
</li>
</ul>
<h3 id="1-2-3-一些最重要的-SQL-命令"><a href="#1-2-3-一些最重要的-SQL-命令" class="headerlink" title="1.2.3 一些最重要的 SQL 命令"></a>1.2.3 一些最重要的 SQL 命令</h3><ul>
<li>SELECT - 从数据库中提取数据</li>
<li>UPDATE - 更新数据库中的数据</li>
<li>DELETE - 从数据库中删除数据</li>
<li>INSERT INTO - 向数据库中插入新数据</li>
<li>CREATE DATABASE - 创建新数据库</li>
<li>ALTER DATABASE - 修改数据库</li>
<li>CREATE TABLE - 创建新表</li>
<li>ALTER TABLE - 变更（改变）数据库表</li>
<li>DROP TABLE - 删除表</li>
<li>CREATE INDEX - 创建索引（搜索键）</li>
<li>DROP INDEX - 删除索引</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sqlpp11_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sqlpp11_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">sqlpp11_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sqlpp11 理论基础</li>
</ul>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>sqlpp11 是一个 C++ 编程库，提供了一种类型安全的 SQL 查询构建和执行方式。它使用 C++ 的强类型系统和模板元编程技术，允许开发者以类型安全的方式构建 SQL 查询，同时提供了对多种关系型数据库的支持。</p>
<p>以下是关于 sqlpp11 的一些详细说明：</p>
<p><strong>1. 类型安全的 SQL 查询构建：</strong> sqlpp11 允许开发者使用 C++ 类型和表达式来构建 SQL 查询，这种方式可以在编译时捕获错误和类型不匹配，并提供更好的代码安全性和可维护性。</p>
<p><strong>2. 支持多种关系型数据库：</strong> sqlpp11 支持多种常见的关系型数据库，如 MySQL、PostgreSQL、SQLite 和 Microsoft SQL Server 等，使开发者可以使用相同的接口和查询语法来操作不同的数据库系统。</p>
<p><strong>3. 查询表达式和条件：</strong> sqlpp11 提供了丰富的查询表达式和条件，包括等于、不等于、小于、大于、逻辑运算符等，以及通用函数和聚合函数等，使开发者可以构建复杂的查询条件和数据转换。</p>
<p><strong>4. 插入、更新和删除数据：</strong> sqlpp11 提供了方便的接口和语法来执行插入、更新和删除数据的操作，使开发者可以通过简单的代码调用来完成数据库操作。</p>
<p><strong>5. 事务支持：</strong> sqlpp11 支持数据库事务的操作，允许开发者在事务中执行一系列的数据库操作，并保证数据的一致性和完整性。</p>
<p><strong>6. 数据库迁移支持：</strong> sqlpp11 提供了数据库迁移的支持，允许开发者定义数据库表结构的变化和版本控制，以方便数据库结构的升级和维护。</p>
<p>使用 sqlpp11，开发者可以在 C++ 程序中以一种类型安全的方式构建和执行 SQL 查询，而无需手动编写 SQL 语句。这样可以减少错误和调试的工作量，提高代码的可读性和可维护性。然而，使用 sqlpp11 仍然需要对关系型数据库和 SQL 语法有一定的了解，以便正确地构建查询和操作数据库。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sqlite3_4_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sqlite3_4_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">sqlite3_4_常见问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sqlite3使用过程中遇到的理论，问题和解决方法</li>
</ul>
<h2 id="database-is-locked"><a href="#database-is-locked" class="headerlink" title="database is locked"></a>database is locked</h2><p>“sqlite3 database is locked” 是指在使用 SQLite 数据库时遇到了并发访问的冲突。当一个进程或连接正在执行写操作（例如插入、更新或删除数据）时，SQLite 会将数据库文件锁定，以防止其他进程同时对同一数据库执行写操作，以维护数据的完整性。</p>
<p>如果在一个进程中对数据库文件执行写操作时，另一个进程或连接也试图执行写操作，就会发生冲突，此时就会出现 “sqlite3 database is locked” 错误。</p>
<p>这种情况通常出现在以下几种情况下：</p>
<ol>
<li>并发访问：多个进程或连接同时尝试对同一个数据库执行写操作。</li>
<li>错误的连接管理：在一个连接中开始了一个事务（transaction），但没有正确地提交或回滚该事务，导致其他连接无法访问数据库。</li>
<li>长时间的写操作：一个进程或连接执行了一个耗时很长的写操作，阻塞了其他进程或连接的写操作。</li>
</ol>
<p>解决 “sqlite3 database is locked” 错误的方法包括：</p>
<ol>
<li>确保正确管理连接和事务：在使用完数据库连接后，应该及时关闭连接或者正确地提交或回滚事务，以释放数据库锁定。</li>
<li>等待并重试：如果出现锁定错误，可以通过等待一段时间后再次尝试执行操作，以便等待其他进程或连接释放数据库锁定。</li>
<li>优化并发访问：如果并发访问是一个常见问题，可以考虑优化数据库结构、调整访问模式或使用锁定机制来避免冲突。</li>
</ol>
<p>需要注意的是，”sqlite3 database is locked” 错误通常是由并发访问引起的，因此在设计和编写应用程序时，应该考虑到数据库并发访问的情况，并采取适当的措施来避免冲突。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sqlite3_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sqlite3_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">sqlite3_3_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sqlite3 常用技巧</li>
</ul>
<h2 id="设置唯一列-约束"><a href="#设置唯一列-约束" class="headerlink" title="设置唯一列 约束"></a>设置唯一列 约束</h2><p>在 SQLite3 中，可以通过添加 <code>UNIQUE</code> 约束来设置唯一列，确保列中的值在表中是唯一的。这意味着您不能在该列中插入重复的值。</p>
<p>以下是在 SQLite3 中设置唯一列的方法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> table_name (</span><br><span class="line">  column1 data_type <span class="keyword">UNIQUE</span>,</span><br><span class="line">  column2 data_type,</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>column1</code> 被设置为唯一列。如果在 <code>column1</code> 中插入一个已经存在的值，SQLite3 将会抛出一个错误并拒绝插入。</p>
<p>需要注意的是，唯一约束可以应用于单个列，也可以应用于多个列。如果将多个列一起设置为唯一约束，这些列的组合值在表中将是唯一的。</p>
<p>例如，将多个列设置为唯一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> table_name (</span><br><span class="line">  column1 data_type,</span><br><span class="line">  column2 data_type,</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">UNIQUE</span>(column1, column2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>column1</code> 和 <code>column2</code> 的组合值将是唯一的。</p>
<p>另外，如果您想在已有的表中添加唯一约束，可以使用 <code>ALTER TABLE</code> 命令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> constraint_name <span class="keyword">UNIQUE</span> (column1);</span><br></pre></td></tr></table></figure>

<p>请注意，在添加唯一约束之前，您需要确保列中的数据没有重复值，否则会导致添加约束失败。</p>
<p>总的来说，通过添加 <code>UNIQUE</code> 约束，可以在 SQLite3 中设置唯一列，确保表中的特定列的值是唯一的，避免插入重复的数据。</p>
<h2 id="设置主键和自增"><a href="#设置主键和自增" class="headerlink" title="设置主键和自增"></a>设置主键和自增</h2><p>在 SQLite3 中，设置主键和自增可以通过以下方式实现：</p>
<h3 id="设置主键："><a href="#设置主键：" class="headerlink" title="设置主键："></a>设置主键：</h3><p>在 SQLite3 中，主键可以通过在列定义中添加 <code>PRIMARY KEY</code> 约束来设置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> table_name (</span><br><span class="line">  column1 data_type <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  column2 data_type,</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>column1</code> 被设置为主键。</p>
<h3 id="设置自增："><a href="#设置自增：" class="headerlink" title="设置自增："></a>设置自增：</h3><p>在 SQLite3 中，可以使用 <code>INTEGER</code> 数据类型和 <code>AUTOINCREMENT</code> 关键字来设置自增列。自增列在插入数据时会自动递增，确保数据的唯一性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> table_name (</span><br><span class="line">  id <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span> AUTOINCREMENT,</span><br><span class="line">  column1 data_type,</span><br><span class="line">  column2 data_type,</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>id</code> 列被设置为自增列，并作为主键。需要注意的是，<code>AUTOINCREMENT</code> 关键字只适用于主键列，且如果列设置为自增，插入数据时不需要为该列提供值，数据库会自动为其生成递增的值。</p>
<p>请注意，在 SQLite3 中，如果不显式地指定主键和自增列，SQLite3 会默认为每个表创建一个名为 “rowid” 的隐藏列，它将作为主键并自动递增。因此，如果不特别需要指定主键名称，可以直接使用默认的 “rowid” 列。</p>
<p>总之，以上就是在 SQLite3 中设置主键和自增的方法。根据您的需求，可以选择显式地指定主键和自增列的名称，也可以使用默认的 “rowid” 列来满足自增的需求。</p>
<ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">algorithm       camera          task            user            warning_record</span><br><span class="line">sqlite&gt; CREATE TABLE event_subscribers (<span class="built_in">id</span> INT AUTO_INCREMENT PRIMARY KEY,  name TEXT, address TEXT, appKeyId TEXT, appKeySecret TEXT);</span><br><span class="line">sqlite&gt; .schema event_subscribers </span><br><span class="line">CREATE TABLE event_subscribers (<span class="built_in">id</span> INT AUTO_INCREMENT PRIMARY KEY,  name TEXT, address TEXT, appKeyId TEXT, appKeySecret TEXT);</span><br><span class="line">sqlite&gt; insert into event_subscribers (name, address, appKeyId, appKeyScret) values (<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;http://helloworld.cn&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">Parse error: table event_subscribers has no column named appKeyScret</span><br><span class="line">sqlite&gt;  insert into event_subscribers (name, address, appKeyId, appKeySecret) values (<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;http://helloworld.cn&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">sqlite&gt; <span class="keyword">select</span> * from event_subscribers;</span><br><span class="line">|aaa|http://helloworld.cn|bbb|ccc</span><br><span class="line">sqlite&gt; insert into event_subscribers (name, address, appKeyId, appKeySecret) values (<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;http://helloworld.cn&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">sqlite&gt; <span class="keyword">select</span> * from event_subscribers;</span><br><span class="line">|aaa|http://helloworld.cn|bbb|ccc</span><br><span class="line">|aaa|http://helloworld.cn|bbb|ccc</span><br><span class="line">sqlite&gt; drop event_subscribers;</span><br><span class="line">Parse error: near <span class="string">&quot;event_subscribers&quot;</span>: syntax error</span><br><span class="line">  drop event_subscribers;</span><br><span class="line">       ^--- error here</span><br><span class="line">sqlite&gt; drop table event_subscribers;</span><br><span class="line">sqlite&gt; CREATE TABLE event_subscribers (<span class="built_in">id</span> INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, address TEXT, appKeyId TEXT, appKeySecret TEXT);</span><br><span class="line">sqlite&gt; insert into event_subscribers (name, address, appKeyId, appKeySecret) values (<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;http://helloworld.cn&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">sqlite&gt; <span class="keyword">select</span> * from event_subscribers;</span><br><span class="line">1|aaa|http://helloworld.cn|bbb|ccc</span><br><span class="line">sqlite&gt; insert into event_subscribers (name, address, appKeyId, appKeySecret) values (<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;http://helloworld.cn&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">sqlite&gt; <span class="keyword">select</span> * from event_subscribers;</span><br><span class="line">1|aaa|http://helloworld.cn|bbb|ccc</span><br><span class="line">2|aaa|http://helloworld.cn|bbb|ccc</span><br><span class="line">sqlite&gt; </span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sqlpp11_2_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sqlpp11_2_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">sqlpp11_2_编程技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sqlpp11 常用的编程技巧</li>
</ul>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>以下是一个简单的示例，演示如何在 C++ 中使用 sqlpp11 进行数据库查询：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlpp11/sqlpp11.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlpp11/mysql/connection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SQLPP_ALIAS_PROVIDER</span>(left);</span><br><span class="line"><span class="built_in">SQLPP_ALIAS_PROVIDER</span>(right);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建数据库连接</span></span><br><span class="line">    sqlpp::<span class="function">mysql::connection <span class="title">db</span><span class="params">(<span class="string">&quot;database&quot;</span>, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;host&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义表对象和别名</span></span><br><span class="line">    <span class="keyword">auto</span> user = test::user&#123;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> u = test::user.<span class="built_in">as</span>(left);</span><br><span class="line">    <span class="keyword">auto</span> v = test::user.<span class="built_in">as</span>(right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行查询操作</span></span><br><span class="line">    <span class="keyword">auto</span> query = db.<span class="built_in">select</span>(u.name)</span><br><span class="line">                     .<span class="built_in">from</span>(u)</span><br><span class="line">                     .<span class="built_in">join</span>(v)</span><br><span class="line">                     .<span class="built_in">on</span>(u.id == v.id)</span><br><span class="line">                     .<span class="built_in">where</span>(u.age &gt;= <span class="number">18</span>)</span><br><span class="line">                     .<span class="built_in">group_by</span>(u.name)</span><br><span class="line">                     .<span class="built_in">order_by</span>(u.name.<span class="built_in">asc</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印查询结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row : query) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; row.name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们假设使用了名为 “database” 的 MySQL 数据库，并提供了正确的用户名、密码和主机信息。</p>
<p>该示例演示了如何进行简单的数据库查询操作。我们定义了一个名为 “user” 的表对象，并使用别名 <code>u</code> 和 <code>v</code> 来引用该表。然后，我们使用 <code>db.select()</code> 来选择查询字段，使用 <code>db.from()</code> 来指定要查询的表，使用 <code>db.join()</code> 和 <code>db.on()</code> 进行表连接操作，使用 <code>db.where()</code> 来指定查询条件，使用 <code>db.group_by()</code> 和 <code>db.order_by()</code> 来进行分组和排序。</p>
<p>最后，我们通过遍历查询结果，并输出每一行的 “name” 字段。</p>
<p>请注意，以上示例只是一个简单的演示，实际使用时需要根据数据库的实际结构和需求进行相应的修改和配置。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
