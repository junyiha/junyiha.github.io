<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/15/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/EtherCat/2024-05-22-ethercat_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/EtherCat/2024-05-22-ethercat_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">EtherCat 理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/EtherCat/" itemprop="url" rel="index"><span itemprop="name">EtherCat</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ethercat的理论基础知识</li>
</ul>
<h2 id="可能出现从站依次松闸现象的原因有哪些"><a href="#可能出现从站依次松闸现象的原因有哪些" class="headerlink" title="可能出现从站依次松闸现象的原因有哪些"></a>可能出现从站依次松闸现象的原因有哪些</h2><p>EtherCAT 从站<strong>依次松闸</strong>（即从站的执行机构或电机控制器按顺序解锁&#x2F;启动，而不是同时执行）可能由以下原因引起：</p>
<hr>
<h2 id="1-主站状态机控制问题"><a href="#1-主站状态机控制问题" class="headerlink" title="1. 主站状态机控制问题"></a><strong>1. 主站状态机控制问题</strong></h2><ul>
<li>EtherCAT 从站需要经过 <strong>Init → Pre-Op → Safe-Op → OP</strong> 状态转换才能正式运行。</li>
<li>如果主站没有同时对所有从站发送 <strong>状态切换命令</strong>，可能导致<strong>从站依次进入 OP 状态</strong>，从而导致依次松闸。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 在主站程序中，确保所有从站在<strong>同一周期</strong>内切换到 OP 状态，而不是顺序执行。</p>
<hr>
<h2 id="2-同步机制（Distributed-Clocks-DC）问题"><a href="#2-同步机制（Distributed-Clocks-DC）问题" class="headerlink" title="2. 同步机制（Distributed Clocks, DC）问题"></a><strong>2. 同步机制（Distributed Clocks, DC）问题</strong></h2><ul>
<li><strong>从站时钟不同步</strong>：如果使用 <strong>DC（分布式时钟）模式</strong>，但从站的时钟没有正确同步，不同从站可能会在不同的时间点进入 OP 状态。</li>
<li><strong>时钟漂移</strong>：某些从站可能会<strong>比其他从站慢</strong>进入 OP 状态，导致松闸的时间差异。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 在主站配置中检查 DC 设置，确保所有从站的时钟同步。<br>✅ 通过 <code>dcOffset</code> 进行时钟补偿，使所有从站的启动时间一致。</p>
<hr>
<h2 id="3-PDO-映射或过程数据更新问题"><a href="#3-PDO-映射或过程数据更新问题" class="headerlink" title="3. PDO 映射或过程数据更新问题"></a><strong>3. PDO 映射或过程数据更新问题</strong></h2><ul>
<li>EtherCAT 采用 <strong>PDO（过程数据对象）</strong> 进行输入&#x2F;输出数据交换。</li>
<li>如果 <strong>PDO 更新不一致</strong> 或者 <strong>某些从站的数据没有及时刷新</strong>，会导致<strong>某些从站较晚接收到松闸指令</strong>。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 在主站配置中，确保所有从站的 PDO <strong>在同一周期内更新</strong>。<br>✅ 使用 <strong>周期同步模式（Cyclic Synchronous Mode）</strong> 以确保所有从站同时执行操作。</p>
<hr>
<h2 id="4-设备响应时间差异"><a href="#4-设备响应时间差异" class="headerlink" title="4. 设备响应时间差异"></a><strong>4. 设备响应时间差异</strong></h2><ul>
<li>不同从站的<strong>硬件响应时间不同</strong>（如伺服驱动器、电磁阀、继电器等）。</li>
<li>某些从站可能需要<strong>更长的初始化时间</strong>，导致它们比其他从站<strong>晚进入 OP 状态</strong>。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 在主站程序中，<strong>等待所有从站进入 OP 状态后再统一发送松闸指令</strong>。<br>✅ 使用 <strong>EtherCAT 总线诊断工具</strong> 检查从站进入 OP 状态的时间是否一致。</p>
<hr>
<h2 id="5-网络拓扑和通信延迟"><a href="#5-网络拓扑和通信延迟" class="headerlink" title="5. 网络拓扑和通信延迟"></a><strong>5. 网络拓扑和通信延迟</strong></h2><ul>
<li>EtherCAT 采用<strong>菊花链结构</strong>，如果<strong>总线负载过高</strong>或<strong>链路有异常</strong>，可能导致数据包在不同从站之间传输时间不同。</li>
<li>这种情况下，<strong>靠近主站的从站可能会比远离主站的从站更早收到指令</strong>，导致依次松闸。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 使用 EtherCAT 网络分析工具（如 Wireshark + EtherCAT 插件）检查数据包延迟。<br>✅ 在<strong>高负载场景下</strong>，优化 PDO 更新频率，避免总线数据阻塞。  </p>
<hr>
<h2 id="6-设备上电顺序不一致"><a href="#6-设备上电顺序不一致" class="headerlink" title="6. 设备上电顺序不一致"></a><strong>6. 设备上电顺序不一致</strong></h2><ul>
<li>如果<strong>从站上电时间不同</strong>，即某些设备比其他设备<strong>晚启动</strong>，则可能导致它们进入 OP 状态的时间不同。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 确保所有从站<strong>同时上电</strong>，或者在主站程序中<strong>等待所有设备启动后再进入 OP 状态</strong>。</p>
<hr>
<h2 id="7-触发信号或启动命令不同步"><a href="#7-触发信号或启动命令不同步" class="headerlink" title="7. 触发信号或启动命令不同步"></a><strong>7. 触发信号或启动命令不同步</strong></h2><ul>
<li>如果松闸依赖于<strong>外部触发信号</strong>（如数字输入 DI、PLC 触发），而该信号的传播或执行时间不同，也会导致从站<strong>依次解锁</strong>。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 检查<strong>触发信号</strong>是否<strong>同步</strong>发送到所有从站。<br>✅ 在主站逻辑中，使用 <strong>全局触发信号</strong> 或 <strong>基于 DC 的同步触发</strong> 来确保所有设备同时执行动作。</p>
<hr>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>EtherCAT 从站依次松闸的常见原因包括：</p>
<table>
<thead>
<tr>
<th><strong>原因类别</strong></th>
<th><strong>可能问题</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>主站状态机</strong></td>
<td>主站未同步切换 OP</td>
<td>在主站程序中确保所有从站同步进入 OP</td>
</tr>
<tr>
<td><strong>DC 时钟同步</strong></td>
<td>时钟未同步、漂移</td>
<td>确保所有从站 DC 同步</td>
</tr>
<tr>
<td><strong>PDO 更新</strong></td>
<td>数据未及时刷新</td>
<td>确保所有从站的 PDO 在同一周期内更新</td>
</tr>
<tr>
<td><strong>设备响应时间</strong></td>
<td>设备处理速度不同</td>
<td>统一等待所有设备进入 OP</td>
</tr>
<tr>
<td><strong>网络拓扑</strong></td>
<td>总线负载高，数据延迟</td>
<td>优化数据更新频率，检查总线健康状态</td>
</tr>
<tr>
<td><strong>上电顺序</strong></td>
<td>设备启动时间不同</td>
<td>确保所有从站同时上电</td>
</tr>
<tr>
<td><strong>触发信号不同步</strong></td>
<td>触发时间不同</td>
<td>使用 DC 触发或全局信号同步</td>
</tr>
</tbody></table>
<p>如果 EtherCAT 从站出现 <strong>依次松闸</strong> 现象，可以从 <strong>主站状态机、DC 时钟、PDO 更新、网络拓扑、设备响应、触发信号</strong> 等方面进行检查和优化。</p>
<h2 id="EtherCAT-从站有几种状态"><a href="#EtherCAT-从站有几种状态" class="headerlink" title="EtherCAT 从站有几种状态"></a>EtherCAT 从站有几种状态</h2><p>在 EtherCAT（Ethernet for Control Automation Technology）协议中，<strong>从站（Slave）</strong> 具有 <strong>四种状态（State Machine）</strong>，每个状态代表不同的操作模式。  </p>
<hr>
<h2 id="EtherCAT-从站的-4-种状态"><a href="#EtherCAT-从站的-4-种状态" class="headerlink" title="EtherCAT 从站的 4 种状态"></a><strong>EtherCAT 从站的 4 种状态</strong></h2><p>从站状态由 <strong>AL 状态机（Application Layer State Machine）</strong> 控制，状态包括：</p>
<ol>
<li><strong>初始化（Init）</strong></li>
<li><strong>预操作（Pre-Operational, Pre-Op）</strong></li>
<li><strong>安全操作（Safe-Operational, Safe-Op）</strong></li>
<li><strong>操作（Operational, OP）</strong></li>
</ol>
<p>EtherCAT <strong>主站（Master）</strong> 通过 <strong>AL 控制寄存器</strong> 控制从站的状态转换。</p>
<hr>
<h3 id="1-初始化（Init）"><a href="#1-初始化（Init）" class="headerlink" title="1. 初始化（Init）"></a><strong>1. 初始化（Init）</strong></h3><ul>
<li><strong>功能</strong>：从站上电后进入 <strong>初始状态</strong>，此时只进行 <strong>基础通信配置</strong>，还不能进行过程数据（Process Data）交换。</li>
<li><strong>特性</strong>：<ul>
<li>只能访问 <strong>物理层和链路层</strong>（EtherCAT 层）。</li>
<li>仅支持 <strong>CoE&#x2F;SDO</strong>（对象字典）等<strong>配置数据通信</strong>。</li>
<li>从站必须完成 <strong>寄存器初始化</strong> 和 <strong>EEPROM 读取</strong>。</li>
</ul>
</li>
<li><strong>状态转换</strong>：<ul>
<li><strong>进入 Pre-Op</strong>：主站发送 <code>Init → Pre-Op</code> 命令。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-预操作（Pre-Operational-Pre-Op）"><a href="#2-预操作（Pre-Operational-Pre-Op）" class="headerlink" title="2. 预操作（Pre-Operational, Pre-Op）"></a><strong>2. 预操作（Pre-Operational, Pre-Op）</strong></h3><ul>
<li><strong>功能</strong>：在该状态下，从站允许主站访问<strong>对象字典（Object Dictionary）</strong> 进行参数配置，但仍不能交换过程数据。</li>
<li><strong>特性</strong>：<ul>
<li>允许<strong>CoE（CANopen over EtherCAT）</strong> 进行<strong>SDO 参数传输</strong>。</li>
<li>不能进行实时过程数据交换（PDO 无效）。</li>
<li>适用于 <strong>参数下载、设备初始化</strong> 等任务。</li>
</ul>
</li>
<li><strong>状态转换</strong>：<ul>
<li><strong>进入 Safe-Op</strong>：主站配置完成后，发送 <code>Pre-Op → Safe-Op</code> 命令。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-安全操作（Safe-Operational-Safe-Op）"><a href="#3-安全操作（Safe-Operational-Safe-Op）" class="headerlink" title="3. 安全操作（Safe-Operational, Safe-Op）"></a><strong>3. 安全操作（Safe-Operational, Safe-Op）</strong></h3><ul>
<li><strong>功能</strong>：从站可以进行<strong>输入数据的读取</strong>，但不能修改输出数据（即，不能改变执行机构的状态）。</li>
<li><strong>特性</strong>：<ul>
<li>允许主站<strong>读取</strong>从站的输入数据。</li>
<li>但不允许主站<strong>写入</strong>从站的输出数据（防止设备误动作）。</li>
<li>适用于<strong>调试过程</strong>，确保系统在操作前数据正确。</li>
</ul>
</li>
<li><strong>状态转换</strong>：<ul>
<li><strong>进入 OP（Operational）</strong>：主站确认输入数据正确后，发送 <code>Safe-Op → OP</code> 命令。</li>
<li><strong>返回 Pre-Op</strong>：如果数据异常，主站可发送 <code>Safe-Op → Pre-Op</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-操作（Operational-OP）"><a href="#4-操作（Operational-OP）" class="headerlink" title="4. 操作（Operational, OP）"></a><strong>4. 操作（Operational, OP）</strong></h3><ul>
<li><strong>功能</strong>：从站进入<strong>全功能状态</strong>，主站可以<strong>读取输入数据、写入输出数据</strong>，正式运行 EtherCAT 过程数据（PDO）。</li>
<li><strong>特性</strong>：<ul>
<li>允许<strong>完整过程数据通信</strong>（输入&#x2F;输出）。</li>
<li>适用于<strong>正常生产、设备运行</strong>。</li>
</ul>
</li>
<li><strong>状态转换</strong>：<ul>
<li><strong>返回 Safe-Op</strong>：如果出现紧急情况（如数据错误），主站可发送 <code>OP → Safe-Op</code> 命令。</li>
<li><strong>返回 Pre-Op</strong>：如果主站要修改配置，主站可发送 <code>OP → Pre-Op</code> 命令。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="状态转换流程"><a href="#状态转换流程" class="headerlink" title="状态转换流程"></a><strong>状态转换流程</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Init → Pre-Op（初始化完成，进入参数配置）</span><br><span class="line">2. Pre-Op → Safe-Op（参数配置完成，输入数据可用）</span><br><span class="line">3. Safe-Op → OP（进入全功能模式，允许数据输入/输出）</span><br><span class="line">4. OP → Safe-Op/Pre-Op/Init（错误或主站请求降级）</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ethercat.org/download/press/ethercat_state_machine.png"></p>
<hr>
<h2 id="异常状态处理"><a href="#异常状态处理" class="headerlink" title="异常状态处理"></a><strong>异常状态处理</strong></h2><p>如果从站发生错误，它可能：</p>
<ul>
<li><strong>进入 “错误状态”（Error）</strong>（通常表现为 Safe-Op 或 Init）。</li>
<li><strong>重启后回到 Init 状态</strong>，等待重新进入 OP。</li>
</ul>
<p>主站可以通过：</p>
<ul>
<li><strong>检查 AL 状态寄存器</strong></li>
<li><strong>读取诊断信息</strong></li>
<li><strong>尝试重新配置</strong></li>
</ul>
<p>来判断从站的状态并进行恢复。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>EtherCAT 从站有 4 种状态：</p>
<table>
<thead>
<tr>
<th><strong>状态</strong></th>
<th><strong>能否进行 PDO 通信？</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Init</strong></td>
<td>❌ 不能</td>
<td>上电、基础通信</td>
</tr>
<tr>
<td><strong>Pre-Op</strong></td>
<td>❌ 不能</td>
<td>参数配置</td>
</tr>
<tr>
<td><strong>Safe-Op</strong></td>
<td>✅ 只能读取输入</td>
<td>调试、验证</td>
</tr>
<tr>
<td><strong>OP（Operational）</strong></td>
<td>✅ 允许输入&#x2F;输出</td>
<td>正常运行</td>
</tr>
</tbody></table>
<p>EtherCAT 主站通过 <strong>状态机控制</strong> 从站，确保从 <strong>初始化 → 预操作 → 安全操作 → 运行</strong> 的<strong>安全平稳过渡</strong>。</p>
<h2 id="ethercat-主站与从站通讯协议"><a href="#ethercat-主站与从站通讯协议" class="headerlink" title="ethercat 主站与从站通讯协议"></a>ethercat 主站与从站通讯协议</h2><p>EtherCAT（<strong>Ethernet for Control Automation Technology</strong>）是一种基于<strong>以太网</strong>的实时工业网络协议，广泛用于<strong>运动控制、I&#x2F;O、传感器、机器人</strong>等领域。EtherCAT 的核心是<strong>主站（Master）</strong>和<strong>从站（Slave）</strong>之间的高速数据交换，采用<strong>主从架构</strong>。  </p>
<hr>
<h2 id="1-EtherCAT-通讯协议架构"><a href="#1-EtherCAT-通讯协议架构" class="headerlink" title="1. EtherCAT 通讯协议架构"></a><strong>1. EtherCAT 通讯协议架构</strong></h2><p>EtherCAT 采用<strong>以太网帧</strong>进行通信，但与标准以太网不同，EtherCAT 具有以下特点：</p>
<ul>
<li><strong>主站（Master）</strong> 负责发送和处理EtherCAT 数据包，不需要专用芯片，可由普通网卡或专用控制器实现。</li>
<li><strong>从站（Slave）</strong> 设备按照帧数据处理规则响应主站请求，通常使用<strong>EtherCAT专用芯片</strong>（如<strong>ET1100</strong>）。</li>
<li><strong>循环拓扑</strong> 方式（支持菊花链、环形、树形等），数据帧沿<strong>单向传输</strong>。</li>
<li><strong>帧穿透</strong> 机制：数据包在传输时直接在从站设备间传递，无需存储转发。</li>
</ul>
<hr>
<h2 id="2-EtherCAT-通讯流程"><a href="#2-EtherCAT-通讯流程" class="headerlink" title="2. EtherCAT 通讯流程"></a><strong>2. EtherCAT 通讯流程</strong></h2><p>EtherCAT 通讯采用主站主动轮询方式：</p>
<ol>
<li><p><strong>主站发送EtherCAT帧</strong></p>
<ul>
<li>主站生成数据帧，并包含多个<strong>过程数据对象（PDO）</strong>。</li>
<li>帧内携带多个从站的数据请求&#x2F;指令。</li>
</ul>
</li>
<li><p><strong>从站解析和处理帧</strong></p>
<ul>
<li>帧经过从站时，<strong>从站在数据帧上直接读写相关数据区域</strong>，而不是接收整个帧再处理。</li>
<li>这极大提升了通信效率，避免了传统以太网的<strong>存储转发</strong>延迟。</li>
</ul>
</li>
<li><p><strong>主站接收并解析返回数据</strong></p>
<ul>
<li>当帧经过所有从站后，数据会返回给主站，主站读取修改后的数据。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-EtherCAT-帧结构"><a href="#3-EtherCAT-帧结构" class="headerlink" title="3. EtherCAT 帧结构"></a><strong>3. EtherCAT 帧结构</strong></h2><p>EtherCAT 帧基于标准<strong>IEEE 802.3 以太网帧</strong>，但采用特殊的<strong>EtherType &#x3D; 0x88A4</strong>，表示是EtherCAT数据帧。</p>
<p>EtherCAT 数据帧结构如下：</p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>长度（字节）</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>目标MAC地址</td>
<td>6</td>
<td>目的设备MAC</td>
</tr>
<tr>
<td>源MAC地址</td>
<td>6</td>
<td>发送设备MAC</td>
</tr>
<tr>
<td>EtherType</td>
<td>2</td>
<td>固定为 0x88A4</td>
</tr>
<tr>
<td>EtherCAT数据</td>
<td>46-1500</td>
<td>实际数据，包含多个命令</td>
</tr>
<tr>
<td>CRC校验</td>
<td>4</td>
<td>以太网帧校验</td>
</tr>
</tbody></table>
<p>EtherCAT数据部分主要包含：</p>
<ul>
<li><strong>命令头（CMD Header）</strong><ul>
<li>包含<strong>命令类型（LRW、APRD、APWR、BRD等）</strong>，目标<strong>从站地址</strong>，数据长度等信息。</li>
</ul>
</li>
<li><strong>过程数据（Process Data）</strong><ul>
<li>具体的输入&#x2F;输出数据内容。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-主要EtherCAT通信命令"><a href="#4-主要EtherCAT通信命令" class="headerlink" title="4. 主要EtherCAT通信命令"></a><strong>4. 主要EtherCAT通信命令</strong></h2><p>EtherCAT 主站与从站的通讯主要基于以下<strong>命令类型</strong>：</p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>缩写</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>逻辑读取</td>
<td><strong>LRD</strong></td>
<td>读取过程数据</td>
</tr>
<tr>
<td>逻辑写入</td>
<td><strong>LWR</strong></td>
<td>写入过程数据</td>
</tr>
<tr>
<td>逻辑读写</td>
<td><strong>LRW</strong></td>
<td>读写数据，最常用</td>
</tr>
<tr>
<td>自动增量读取</td>
<td><strong>APRD</strong></td>
<td>按自动增量地址读取</td>
</tr>
<tr>
<td>自动增量写入</td>
<td><strong>APWR</strong></td>
<td>按自动增量地址写入</td>
</tr>
<tr>
<td>自动增量读写</td>
<td><strong>APRW</strong></td>
<td>读写数据，并自动增量</td>
</tr>
<tr>
<td>广播读取</td>
<td><strong>BRD</strong></td>
<td>读取所有从站数据</td>
</tr>
<tr>
<td>广播写入</td>
<td><strong>BWR</strong></td>
<td>写入所有从站数据</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-EtherCAT-工作模式"><a href="#5-EtherCAT-工作模式" class="headerlink" title="5. EtherCAT 工作模式"></a><strong>5. EtherCAT 工作模式</strong></h2><p>EtherCAT 主要有以下<strong>4种工作模式</strong>：</p>
<h3 id="1）自由运行模式（Free-Run-Mode）"><a href="#1）自由运行模式（Free-Run-Mode）" class="headerlink" title="1）自由运行模式（Free Run Mode）"></a><strong>1）自由运行模式（Free Run Mode）</strong></h3><ul>
<li>主站<strong>不停发送数据</strong>，不依赖同步时钟。</li>
<li>适用于简单IO控制，不需要高精度同步。</li>
</ul>
<h3 id="2）同步管理模式（SM-Sync-Mode）"><a href="#2）同步管理模式（SM-Sync-Mode）" class="headerlink" title="2）同步管理模式（SM Sync Mode）"></a><strong>2）同步管理模式（SM Sync Mode）</strong></h3><ul>
<li>通过<strong>同步管理器（Sync Manager）</strong>控制数据交换。</li>
<li>适用于<strong>离散IO</strong>，但同步性较低。</li>
</ul>
<h3 id="3）分布式时钟模式（DC-Mode）"><a href="#3）分布式时钟模式（DC-Mode）" class="headerlink" title="3）分布式时钟模式（DC Mode）"></a><strong>3）分布式时钟模式（DC Mode）</strong></h3><ul>
<li>采用<strong>从站时钟同步机制</strong>，主站下发时间戳，从站调整本地时钟。</li>
<li>适用于<strong>高精度运动控制</strong>，同步精度可达<strong>纳秒级</strong>。</li>
</ul>
<h3 id="4）周期同步模式（Cyclic-Sync-Mode）"><a href="#4）周期同步模式（Cyclic-Sync-Mode）" class="headerlink" title="4）周期同步模式（Cyclic Sync Mode）"></a><strong>4）周期同步模式（Cyclic Sync Mode）</strong></h3><ul>
<li>类似DC模式，但主站以<strong>固定周期</strong>发送数据。</li>
<li>适用于<strong>实时性要求高的应用</strong>（如伺服驱动）。</li>
</ul>
<hr>
<h2 id="6-EtherCAT与其他工业总线对比"><a href="#6-EtherCAT与其他工业总线对比" class="headerlink" title="6. EtherCAT与其他工业总线对比"></a><strong>6. EtherCAT与其他工业总线对比</strong></h2><table>
<thead>
<tr>
<th><strong>总线类型</strong></th>
<th><strong>通信方式</strong></th>
<th><strong>同步精度</strong></th>
<th><strong>通信速率</strong></th>
<th><strong>优点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CANopen</td>
<td>轮询+事件触发</td>
<td>毫秒级</td>
<td>1Mbps</td>
<td>成熟稳定，成本低</td>
</tr>
<tr>
<td>PROFINET</td>
<td>以太网+RT&#x2F;IRT</td>
<td>微秒级</td>
<td>100Mbps</td>
<td>兼容性好，普及广</td>
</tr>
<tr>
<td>EtherCAT</td>
<td>主站轮询</td>
<td>纳秒级</td>
<td>100Mbps</td>
<td>高速、低延迟</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-EtherCAT-应用场景"><a href="#7-EtherCAT-应用场景" class="headerlink" title="7. EtherCAT 应用场景"></a><strong>7. EtherCAT 应用场景</strong></h2><ul>
<li><strong>运动控制</strong><ul>
<li>伺服驱动、电机控制</li>
<li>CNC机床、机器人控制</li>
</ul>
</li>
<li><strong>工业自动化</strong><ul>
<li>PLC与IO模块连接</li>
<li>传感器数据采集</li>
</ul>
</li>
<li><strong>半导体制造</strong><ul>
<li>高精度同步传输</li>
</ul>
</li>
<li><strong>汽车测试</strong><ul>
<li>车辆HIL仿真测试系统</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a><strong>8. 结论</strong></h2><p>EtherCAT 作为高性能工业以太网协议，具有<strong>低延迟、高同步精度</strong>的特点，广泛应用于<strong>实时控制领域</strong>。主站通过<strong>轮询</strong>与从站通信，从站在<strong>数据帧穿透</strong>机制下直接修改数据，提高了通信效率，是目前<strong>工业4.0和智能制造</strong>的核心技术之一。</p>
<h2 id="ethercat-是什么-详细解释"><a href="#ethercat-是什么-详细解释" class="headerlink" title="ethercat 是什么 详细解释"></a>ethercat 是什么 详细解释</h2><h3 id="EtherCAT-详解"><a href="#EtherCAT-详解" class="headerlink" title="EtherCAT 详解"></a>EtherCAT 详解</h3><p><strong>EtherCAT</strong>（<strong>以太网控制自动化技术</strong>）是一种基于以太网的高性能实时工业通信协议，专为工业自动化系统设计。它由德国Beckhoff公司于2003年开发，现已成为工业自动化领域的重要标准（IEC 61158）。</p>
<hr>
<h4 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h4><ol>
<li><p><strong>实时性与高效性</strong>  </p>
<ul>
<li><strong>数据帧“飞行处理”机制</strong>：主站发送的以太网帧依次经过每个从站设备，各从站实时提取或插入数据（类似“快递包裹”在传输过程中被动态处理），大幅减少通信延迟，典型周期低至100 μs。</li>
<li><strong>带宽利用率高</strong>：单个帧可携带多个设备的数据，支持最大1486字节的有效载荷。</li>
</ul>
</li>
<li><p><strong>主从架构</strong>  </p>
<ul>
<li><strong>主站（Master）</strong>：控制网络，生成和解析数据帧（如PLC、IPC）。</li>
<li><strong>从站（Slave）</strong>：执行具体任务（如伺服驱动器、I&#x2F;O模块），每个从站有唯一地址，支持热插拔。</li>
</ul>
</li>
<li><p><strong>分布式时钟同步</strong>  </p>
<ul>
<li>主站与从站通过精确的时间戳同步，实现<strong>纳秒级时钟偏差</strong>，确保多设备协同（如机器人多轴同步）。</li>
</ul>
</li>
<li><p><strong>灵活拓扑结构</strong>  </p>
<ul>
<li>支持线型、树型、星型拓扑，并可混合使用，适应复杂工业环境布线需求。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a><strong>技术细节</strong></h4><ul>
<li><p><strong>协议结构</strong><br>EtherCAT帧嵌入标准以太网帧（类型字段<code>0x88A4</code>），兼容常规以太网硬件（需从站支持EtherCAT专用芯片如ESC）。</p>
</li>
<li><p><strong>通信模式</strong>  </p>
<ul>
<li><strong>过程数据通信（PDO）</strong>：实时传输控制信号（如电机位置）。</li>
<li><strong>邮箱数据通信（SDO）</strong>：非实时配置参数或传输文件。</li>
</ul>
</li>
<li><p><strong>分布式时钟（DC）机制</strong><br>主站选定参考时钟，从站测量链路延迟并动态调整本地时钟，确保全网络时间同步。</p>
</li>
</ul>
<hr>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul>
<li><strong>性能</strong>：支持≤1000节点，循环周期低至微秒级。</li>
<li><strong>成本效益</strong>：基于标准以太网硬件，无需专用交换机。</li>
<li><strong>兼容性</strong>：支持CoE（CANopen over EtherCAT）、FoE（文件传输）等应用层协议。</li>
<li><strong>扩展性</strong>：通过EtherCAT分支器（如EBUS）可扩展复杂网络。</li>
</ul>
<hr>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ol>
<li><strong>工业机器人</strong>：多关节同步控制，路径精度优化。</li>
<li><strong>数控机床</strong>：高精度加工，实时反馈刀具状态。</li>
<li><strong>包装机械</strong>：高速生产线上的同步启停与张力控制。</li>
<li><strong>能源管理</strong>：分布式光伏逆变器的实时监控。</li>
</ol>
<hr>
<h4 id="标准化与生态"><a href="#标准化与生态" class="headerlink" title="标准化与生态"></a><strong>标准化与生态</strong></h4><ul>
<li><strong>ETG（EtherCAT技术协会）</strong>：全球拥有7,000+会员，推动协议标准化。</li>
<li><strong>开发工具</strong>：如Beckhoff TwinCAT、CODESYS，支持PLC编程与网络配置。</li>
<li><strong>硬件支持</strong>：TI、Infineon等提供ESC芯片，多家厂商推出兼容I&#x2F;O模块、驱动器。</li>
</ul>
<hr>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>EtherCAT凭借其实时性、灵活性和高性价比，成为工业4.0的核心通信技术之一，尤其适用于需要高速同步和复杂控制的场景。随着边缘计算和TSN（时间敏感网络）的融合，其未来在智能制造中的应用将更加广泛。</p>
<h2 id="ethercat-和-xenomai-分别是什么-详细解释"><a href="#ethercat-和-xenomai-分别是什么-详细解释" class="headerlink" title="ethercat 和 xenomai 分别是什么 详细解释"></a>ethercat 和 xenomai 分别是什么 详细解释</h2><p>EtherCAT 和 Xenomai 是两个在工业自动化和实时系统中广泛应用的关键技术，但它们的功能和应用领域不同。以下是详细解释：</p>
<hr>
<h3 id="1-EtherCAT"><a href="#1-EtherCAT" class="headerlink" title="1. EtherCAT"></a><strong>1. EtherCAT</strong></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><strong>EtherCAT</strong>（Ethernet for Control Automation Technology）是一种基于以太网的<strong>实时工业通信协议</strong>，专为工业自动化中的高速、高精度控制设计。它由德国 Beckhoff 公司开发，现已成为国际标准（IEC 61158）。</p>
<h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a><strong>核心特性</strong></h4><ol>
<li><p><strong>实时性</strong>  </p>
<ul>
<li>数据帧在传输过程中被从站设备（Slave）<strong>“实时处理”</strong>，而非存储转发，显著降低通信延迟（典型周期低至 100 μs）。</li>
<li>支持分布式时钟（Distributed Clocks, DC），实现全系统的时间同步（精度可达纳秒级）。</li>
</ul>
</li>
<li><p><strong>高效带宽利用</strong>  </p>
<ul>
<li>数据帧在传输过程中被多个从站设备依次读取和写入，单帧可完成对所有设备的读写操作，减少带宽占用。</li>
</ul>
</li>
<li><p><strong>灵活拓扑结构</strong>  </p>
<ul>
<li>支持线型、树型、星型等多种拓扑，无需专用交换机，降低成本。</li>
</ul>
</li>
<li><p><strong>主从架构</strong>  </p>
<ul>
<li><strong>主站（Master）</strong>：控制通信周期，发起数据交换（如 PLC、工业 PC）。</li>
<li><strong>从站（Slave）</strong>：执行具体任务（如伺服驱动器、I&#x2F;O模块）。</li>
</ul>
</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h4><ul>
<li>主站发送一个以太网帧，从站设备在帧通过时<strong>直接提取或插入数据</strong>，无需等待完整帧传输完毕。</li>
<li>数据帧在环型或线型拓扑中依次传递，最终由主站回收并处理。</li>
</ul>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul>
<li>运动控制（如多轴伺服驱动）</li>
<li>分布式 I&#x2F;O 系统</li>
<li>可编程逻辑控制器（PLC）</li>
<li>机器人控制系统</li>
</ul>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul>
<li>高性价比（基于标准以太网硬件）</li>
<li>低延迟、高同步精度</li>
<li>适用于大规模分布式系统</li>
</ul>
<hr>
<h3 id="2-Xenomai"><a href="#2-Xenomai" class="headerlink" title="2. Xenomai"></a><strong>2. Xenomai</strong></h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><strong>Xenomai</strong> 是一个开源的<strong>实时操作系统框架</strong>（Real-Time Operating System Framework），旨在为 Linux 提供<strong>硬实时（Hard Real-Time）</strong>能力。它通过内核扩展和协作调度机制，使普通 Linux 系统能够满足严格实时性要求。</p>
<h4 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a><strong>核心特性</strong></h4><ol>
<li><p><strong>双核架构（Cobalt Core）</strong>  </p>
<ul>
<li><strong>实时核（Xenomai）</strong>：处理硬实时任务（如中断响应、定时器）。</li>
<li><strong>非实时核（Linux）</strong>：运行普通任务（如网络通信、文件系统）。</li>
</ul>
</li>
<li><p><strong>Adéos 中间层</strong>  </p>
<ul>
<li>作为硬件抽象层，接管中断并优先分配给 Xenomai 实时核，确保实时任务的确定性。</li>
</ul>
</li>
<li><p><strong>实时 API 支持</strong>  </p>
<ul>
<li>提供多种实时编程接口（如 POSIX、VxWorks 风格的 API），支持跨平台实时应用开发。</li>
<li>与 Linux 原生 API（如 pthreads）兼容。</li>
</ul>
</li>
<li><p><strong>硬实时性能</strong>  </p>
<ul>
<li>中断响应延迟通常低于 10 μs，适用于微秒级精度的控制任务。</li>
</ul>
</li>
</ol>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h4><ul>
<li>Xenomai 通过修改 Linux 内核（或作为内核模块），在硬件中断和 Linux 内核之间插入实时调度层。</li>
<li>实时任务运行在 Xenomai 核，直接访问硬件资源，避免 Linux 内核的调度延迟。</li>
</ul>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul>
<li>机器人关节控制</li>
<li>CNC 机床</li>
<li>高速数据采集系统</li>
<li>航空航天控制系统</li>
</ul>
<h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul>
<li>低成本（基于开源 Linux）</li>
<li>兼容现有 Linux 生态</li>
<li>硬实时性能接近专用 RTOS（如 VxWorks）</li>
</ul>
<hr>
<h3 id="3-EtherCAT-与-Xenomai-的结合"><a href="#3-EtherCAT-与-Xenomai-的结合" class="headerlink" title="3. EtherCAT 与 Xenomai 的结合"></a><strong>3. EtherCAT 与 Xenomai 的结合</strong></h3><p>在工业控制系统中，两者常结合使用：  </p>
<ul>
<li><strong>Xenomai</strong> 提供实时操作系统环境，确保控制任务的确定性。</li>
<li><strong>EtherCAT</strong> 作为实时通信协议，连接主站（如运行 Xenomai 的工控机）与从站设备（如伺服驱动器）。</li>
</ul>
<h4 id="典型架构示例"><a href="#典型架构示例" class="headerlink" title="典型架构示例"></a><strong>典型架构示例</strong></h4><ol>
<li><strong>硬件</strong>：工业 PC（主站） + EtherCAT 从站设备（伺服驱动器、I&#x2F;O模块）。  </li>
<li><strong>软件</strong>：  <ul>
<li>Xenomai 实时核处理运动控制算法、中断响应。  </li>
<li>EtherCAT 主站协议栈（如 IgH EtherCAT Master）运行在 Xenomai 实时环境中，确保通信周期精确。  </li>
<li>Linux 非实时核处理人机界面（HMI）和网络通信。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>EtherCAT</strong>：实时工业以太网协议，解决高速、高精度设备通信问题。  </li>
<li><strong>Xenomai</strong>：实时操作系统框架，为 Linux 提供硬实时能力。  </li>
<li><strong>协同价值</strong>：在复杂控制系统中，Xenomai 保障实时任务执行，EtherCAT 实现高效设备通信，共同构建高性能工业自动化平台。</li>
</ul>
<h2 id="EtherCAT"><a href="#EtherCAT" class="headerlink" title="EtherCAT"></a>EtherCAT</h2><ul>
<li><p><code>EtherCAT</code>是<code>Ethernet for Control Automation Technolog</code>的简称，是一个实时控制的开放标准。</p>
</li>
<li><p><code>ETG</code>, <code>EtherCAT技术小组</code>，该组织是<code>Beckhoff</code>为支持和推广<code>EtherCAT</code>而成立的。<code>ETG</code>网站是关于<code>EtherCAT</code>的信息来源。</p>
</li>
</ul>
<h3 id="EtherCAT-xenomai-安装"><a href="#EtherCAT-xenomai-安装" class="headerlink" title="EtherCAT xenomai 安装"></a>EtherCAT xenomai 安装</h3><ul>
<li><del><code>notes/PDF/EtherCAT（ubuntu18.04，linux4.9.38，xenomai3.1，igh1.52）配置完整流程.docx</code></del> </li>
<li>pdf文档配置menuconfig时步骤不完整，坑！！！</li>
<li>另一个地址:<code>https://www.icode9.com/content-3-916631.html</code></li>
</ul>
<h3 id="固定RxPDOs"><a href="#固定RxPDOs" class="headerlink" title="固定RxPDOs"></a>固定<code>RxPDOs</code></h3><ul>
<li><p><code>notes/PDF/AP系列驱动器+EtherCAT+手册V1.0.pdf -- P12</code></p>
</li>
<li><p>**对于<code>CSP</code>(循环同步位置)**0x6060的操作方式&#x3D;8：</p>
<ul>
<li>接收PDO 4 ： 0x1700<ul>
<li><code>0x6040</code> – 控制字</li>
<li><code>0x607A</code> – 轨迹目标位置</li>
<li><code>0x60B1</code> – 速度偏移</li>
<li><code>0x60B2</code> – 转矩偏移</li>
</ul>
</li>
</ul>
</li>
<li><p>对于<code>CSV</code>(循环同步速度)0x6060的操作模式&#x3D;9：</p>
<ul>
<li>接收PDO 5：0x1701<ul>
<li><code>0x6040</code> – 控制字</li>
<li><code>0x60FF</code> – 目标速度</li>
<li><code>0x60B2</code> – 转矩偏移量</li>
</ul>
</li>
</ul>
</li>
<li><p>对于<code>CST</code>(循环同步转矩)0x6060的操作方式&#x3D;10：</p>
<ul>
<li>接收PDO 6：0x1702<ul>
<li><code>0x6040</code> – 控制字</li>
<li><code>0x60FF</code> – 目标速度</li>
<li><code>0x60B2</code> – 转矩偏移量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="固定TxPDO"><a href="#固定TxPDO" class="headerlink" title="固定TxPDO"></a>固定<code>TxPDO</code></h3><ul>
<li>发送PDO 5：0x1B00<ul>
<li><code>0x6041</code> – 16 – 状态字</li>
<li><code>0x6064</code> – 32 – 实际电机位置</li>
<li><code>0x60F4</code> – 32 – 位置循环错误（跟随错误）</li>
<li><code>0x606C</code> – 32 – 实际电机速度</li>
<li><code>0x6077</code> – 16 – 转矩实际值</li>
</ul>
</li>
</ul>
<h3 id="请求主站"><a href="#请求主站" class="headerlink" title="请求主站"></a>请求主站</h3><ul>
<li><p>用户程序通过<code>ecrt_request_master</code>请求主站设备，该函数调用<code>ecrt_request_master_err()</code>，取得<code>master</code>设备，并执行<code>ec_master_enter_operation_phase()</code>函数</p>
</li>
<li><p>请求主站设备完成后，开始<strong>创建数据域</strong>，调用<code>ecrt_master_create_domain()</code></p>
</li>
<li><p>创建数据域成功后，分别完成对各从站设备的配置，配置内容包括：<code>PDO</code>映射，<code>SM</code>配置，<code>FFMU</code>配置和<code>DC</code>配置</p>
</li>
<li><p>用户程序调用的入口是<code>ecrt.h</code>和相关的库文件，通过<code>ioctl</code>以驱动的形式实现，与<code>master</code>文件夹中的部分函数稍有区别</p>
</li>
</ul>
<h3 id="从站配置"><a href="#从站配置" class="headerlink" title="从站配置"></a>从站配置</h3><ul>
<li>从站配置是应用层通过<code>ecrt_master_slave_config()</code>函数添加到主站的<code>config</code>链表中</li>
</ul>
<h2 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h2><ul>
<li><p>过程数据对象(<code>Process Data Object, PDO</code>)，是用来传输实时数据的，提供对设备应用对象的直接访问通道，它用来传输实时短帧数据，具有较高的优先权。</p>
</li>
<li><p><code>PDO</code>传输的数据必须少于或等于8个字节，<code>PDO</code>的<strong>CAN报文数据域</strong>中每个字节都用作数据传输，因此，在应用层上不包含传输控制信息，报文利用率极高。</p>
</li>
<li><p><code>PDO</code>通信是基于生产者&#x2F;消费者的通讯模式，每个<code>PDO</code>有一个唯一的标识符且可以通过一个节点发送，但有多个节点可以接收。<code>PDO</code>的接收不需要消费者确认。</p>
<ul>
<li>由生产者发送的<code>PDO</code>称为发送PDO<code>(TPDO)</code></li>
<li>由消费者接收的<code>PDO</code>称为接收PDO<code>(RPDO)</code></li>
</ul>
</li>
<li><p>每个<code>PDO</code>在对象字典中由两个对象描述： 通信参数和映射参数</p>
<ul>
<li><code>PDO</code>通信参数指明使用哪个<code>COB-ID</code>，传输类型，禁用时间和定时时间</li>
<li><code>PDO</code>映射参数用于设定<code>PDO</code>报文中的数据的映射关系，确定要传输的数据在<code>CAN</code>报文数据域中的定位。该参数允许<code>PDO</code>的生产者和消费者知道正在传输什么信息，而不需要在<code>CAN</code>报文中增加额外的协议控制信息，使传输的效率达到最高。一个<code>PDO</code>最多可以映射64个对象</li>
</ul>
</li>
<li><p><code>PDO</code>通讯具有三种出发模式：内部事件驱动或内部定时器触发，同步触发，远程请求触发</p>
<ul>
<li><strong>内部事件驱动或内部定时触发。</strong>通讯由某一事件触发。例如数字I&#x2F;O口状态改变，超过预先设定的值，定时器中断等都会触发节点发送一个<code>PDO</code>。这种模式可使总线负载达到最小，在相对低的波特率下获得比较高的通讯特性。</li>
<li><strong>同步触发。</strong>同步触发<code>PDO</code>是指<code>CANopen</code>节点收到由管理节点发出的同步报文（同步对象Sync）之后，根据触发报文条件向总线发出<code>PDO</code>报文。同步传输又分为周期性和非周期性。周期性是指<code>CANopen</code>节点收到一定数量的同步报文之后才开始发送；非周期性<code>PDO</code>是指<code>PDO</code>触发条件成立之后，当收到下一个同步对象后马上发送<code>PDO</code></li>
<li><strong>远程请求触发。</strong><code>PDO</code>消费者可以给<code>PDO</code>生产者发送远程<code>PDO</code>请求，相应<code>PDO</code>生产者将对远程帧作出相应，向总线上发送相应的<code>PDO</code>数据。</li>
</ul>
</li>
<li><p><code>PDO</code>通讯时的触发模式由<code>PDO</code>通信参数中的传输类型来确定，传输类型是一个8位无符号整数，这个传输类型值的大小与<code>PDO</code>触发方式的对应关系</p>
</li>
<li><p>主站和从站<code>PDO</code>通信的机制</p>
<ul>
<li><code>PDO</code>的基本概念及其在对象字典中的索引，在主站和从战采用<code>PDO</code>通信方式时，思路是 – 先配置主站的<code>PDO</code>的通信参数(COB-ID,数据传输类型)，再配置从站的通信参数与主站一致，这样就建立了主站与从站的<code>PDO</code>通信的关系。然后再通过字典配置主站<code>PDO</code>映射参数，配置完成后从主站就可以通过<code>PDO</code>通信传输数据。</li>
</ul>
</li>
<li><p><code>PDO</code>传输的“总指挥”就是对象字典。<code>PDO</code>发送什么数据，接收什么数据，什么时候发送和接收，发送和接收的数据都放在哪儿，都是由对象字典配置。</p>
</li>
</ul>
<h2 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h2><ul>
<li>CAN是控制器局域网络(<code>Controller Area Network, CAN</code>)的简称，是由以研发和生产汽车电子产品著称的德国<code>BOSCH</code>公司开发的，并最终称为国际标准，是国际上应用最广泛的<strong>现场总线</strong>之一</li>
</ul>
<h2 id="EtherCAT-使用与解析–关于ethercat应用层使用"><a href="#EtherCAT-使用与解析–关于ethercat应用层使用" class="headerlink" title="EtherCAT 使用与解析–关于ethercat应用层使用"></a>EtherCAT 使用与解析–关于ethercat应用层使用</h2><ul>
<li><p>url – <code>https://blog.csdn.net/lswdcyy/article/details/105441470</code></p>
</li>
<li><p>下载<code>ethercat</code>源码并且安装好之后，测试<code>ethercat</code>使用可以遵循以下步骤</p>
</li>
<li><p>开启<code>ethercat</code>系统 – <code>sudo /etc/init.d/ethercat start</code></p>
<ul>
<li>执行这一步需要确保一点 – 按照<code>ethercat</code>源码中的<code>README</code>指导将一些需要的文件复制以及创建软连接到<code>/opt/init.d/ethercat</code>以及<code>/opt/sysconfig/ethercat</code>两个文件，前者是系统启动文件，后者是系统配置文件</li>
<li>系统配置文件，是一份变量定义文件，在系统启动脚本中执行，定义两类变量，一个是主站MAC地址(<code>MASTER0_DEVICE</code>)，一个是使用的模块驱动名称(<code>DEVICE_MODULES</code>)</li>
</ul>
</li>
<li><p>开启系统后，要在应用层进行对主站模块的使用，本质上是通过开启<code>/dev/EtherCAT</code>字符设备，而后基于<code>ioctl</code>方式调用内核主站模块各种功能</p>
<ul>
<li>开启系统后，用户主要需要进行从站配置与PDO映射，域操作功能，然后就可以进行PDO交换了</li>
<li><strong>主站程序运行在内核空间，应用层需要一种方式实现对内核调用。通过打开主站创建的字符设备<code>/dev/EtherCAT</code>就是这个作用</strong></li>
<li>主要用到的函数<ul>
<li><code>ec_master_t *ecrt_request_master(unsigned int master_index);</code> – <ul>
<li><strong>负责打开字符设备文件，传入参数为使用主站索引</strong>（使用<code>/etc/init.d/ethercat</code>开启系统的时候可以一次性传入多个MAC地址从而开启多个主站，不同主站创建不同的字符设备，例如<code>/dev/EtherCAT0, /dev/EtherCAT1...</code>），</li>
<li>而这个索引就是用于开启对应的字符设备，从而使用不同的主站，使用<code>open接口</code>打开，然后返回文件描述符，该文件描述符用于<code>ioctl</code>调用对应主站功能。另外在申请到主站后就不再允许进行总线的重新扫描，固化了主站连接的从站链表，而且设置从站状态当前申请状态为<code>PREOP</code></li>
</ul>
</li>
<li><code>ec_domain_t *ecrt_master_create_domain(ec_master_t* master);</code><ul>
<li><strong>负责创建域，</strong><code>domain</code>与<code>PDO</code>映射有密切联系，在激活的位置详谈</li>
<li>这个函数具体内容就是直接在内核空间中创建一块<code>ec_domain</code>空间并且将该空间连接到主站<code>domain</code>链表尾部</li>
</ul>
</li>
<li><code>ec_slave_config_t *ecrt_master_slave_config(ec_master_t* master, uint16_t alias, uint16_t position, uint32_t vendor_id, uint32_t product_code);</code><ul>
<li><strong>从站配置函数</strong>，</li>
<li>主站模块中的从站链表，它们之间的关系为：从站配置是应用层通过<code>ecrt_master_slave_config()</code>函数添加到主站的<code>configs</code>链表中的，而从站链表<code>slaves</code>则是通过<code>ethercat</code>主站状态机通过扫描<code>ethercat</code>总线得到的，两者的共同之处在于<strong>从站配置过程的<code>alias, position, VID, PID</code>，这些在主站扫描到的从站链表中都是有一份参数的，当应用层设置配置和主站扫描到从站信息相匹配的时候，那就将从站与从站配置相联系</strong>（这时候会将主站扫描的<code>SII</code>信息关于<code>sync</code>关联的<code>PDO</code>信息复制到从站配置中，也就是默认<code>PDO</code>配置）；这样，就可以通过从站配置寻找到主站模块中从站配置信息，进而获取到从站信息。</li>
</ul>
</li>
<li><code>int ecrt_slave_config_reg_pdo_entry(ec_slave_config_t *sc, uint16_t index, uint8_t subindex, ec_domain_t *domain, unsigned int *bit position);</code><ul>
<li><strong>从站配置<code>PDO</code>函数</strong></li>
<li>需要注意的一点 – 在主站正式激活之前，所有配置<code>PDO</code>相关的其实并没有相对应的空间申请操作，一切都是进行的计算，计算<code>PDO</code>需要多大空间，计算<code>domains</code>的逻辑位置，计算<code>FMMU</code>的逻辑位置，计算<code>PDO</code>的逻辑位置，直到主站正式激活，主站会根据自身已经申请的域链表<code>domains</code>，获取所有域所需要的空间大小，而后对每个域进行逻辑地址分配，每个域中再对每个<code>FMMU</code>进行逻辑地址分配。</li>
<li>接口参数<ul>
<li><code>uint16_t index</code> – 对象字典索引</li>
<li><code>uint8_t subindex</code> – 对象字典子索引</li>
<li><code>ec_domain_t *domain</code> – 使用的域</li>
<li><code>unsigned int* bit_position</code> – 一个Byte中的偏移量，当PDO映射逻辑地址不是完整的Byte时有用</li>
</ul>
</li>
<li>首先，通过从站应用层配置索引可以获取到主站的从站配置链表中对应的从站配置，而后根据配置目标domain的索引获取到主站的domains链表对应的域，这样就可以实现应用层的从站配置和domain切换到主站对应的从站配置和domain，然后进行pdo映射操作。</li>
<li>每次进行PDO映射的时候，并不是只对设置的一个对象进行处理，而是直接将整个sync关联的PDO都进行批次化处理。所以，本质上来讲，PDO配置映射就是确定PDO的逻辑地址位置</li>
</ul>
</li>
<li><code>int ecrt_master_activate(ec_master_t *master);</code><ul>
<li><strong>函数为正式激活的函数</strong></li>
<li>主站注册的domains链表整体大小计算；经过PDO注册映射之后，对主站中关联的每个domains都是相互独立的，并且每个domains都只是一个计算得到的值，其实并没有需要的空间申请，因此在主站激活的时候会将全部domians需要的空间进行统一申请。具体申请到的PDO映射逻辑空间存放在字符设备打开文件的priv指针处，关于字符设备的file-&gt;priv在字符设备打开eccdev_open的时候进行指定。然后按照主站连接的domains链表顺序对每个domian起始地址进行设置：主要是domain的逻辑起始地址，domain的大小，以及domain中的FMMU的逻辑地址重新设置，最终，domain和FMMU的逻辑起始地址都是在主站全部domains环境下的逻辑起始地址。为了进行PDO映射，在主站激活过程中还对每个domain需要的子报文进行空间申请。在计算子报文需要个数的时候，各个domain计算各自需要的子报文需要，这样就可以满足不同domain的PDO交换周期是可以单独设置的；在domain计算自己需要的子报文个数的时候，计算是以FMMU为一个基本单位进行计算的，每个子报文可承载的数据大小为1486Byte，然后根据一个子报文中FMMU的输入输出情况设置子报文类型，也就是EC_DATAGRAM_LRD类型子报文，EC_DATAGRAM_LRR类型子报文以及EC_DATAGRAM_LRW类型子报文。然后将这些子报文添加到domain的datagram_pairs链表中。当然，整体过程中，domain映射空间和子报文使用的数据空间都是同一段空间。</li>
<li>完成主站的domains域空间处理，之后就停止主站的空闲阶段线程（等待空间阶段线程退出）</li>
<li>开启主站的操作阶段线程，该线程和空闲阶段线程相比不同之处–在于将主站子报文队列组合发送移动到用户手中进行处理</li>
</ul>
</li>
<li><code>uint8_t *ecrt_domain_data(ec_domain_t *domain);</code><ul>
<li><strong>返回domain在逻辑空间的逻辑地址</strong></li>
</ul>
</li>
<li><code>void ecrt_domain_queue(ec_domain_t *domain);</code><ul>
<li><strong>将对应domain空间使用的子报文排列到主站子报文发送链表中</strong></li>
</ul>
</li>
<li><code>void ecrt_master_send(ec_master_t *master);</code><ul>
<li><strong>将主站的子报文发送链表的子报文进行发送</strong>，在发送过程中，默认的会将从站状态机子报文和主站状态机子报文进行排队发送</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ecrt-h头文件接口"><a href="#ecrt-h头文件接口" class="headerlink" title="ecrt.h头文件接口"></a><code>ecrt.h</code>头文件接口</h2><ul>
<li><p><code>ecrt_master_receive()</code></p>
<ul>
<li>功能：从硬件获取接收到的帧并处理数据报。通过调用中断服务例程查询网络设备接收到的帧。提取收到的数据报并将结果发送到队列中的数据报对象。接收到的数据报和超时的数据报将被标记并退出队列</li>
<li>函数原型：<code>void ecrt_master_receive(ec_master_t* master);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_domain_process()</code></p>
<ul>
<li>功能：确定域数据报的状态。评估接收到的数据报的工作计数器，并在必要时输出统计信息。必须在<code>ecrt_master_receive()</code>接收域数据报之后调用此函数，以便<code>ecrt_domain_state()</code>返回上一次进程数据交换的结果。</li>
<li>函数原型：<code>void ecrt_domain_process(ec_domain_t *domain);</code></li>
<li>参数：<code>domain</code> – 域</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>EC_READ_U16()</code></p>
<ul>
<li>功能：宏函数，计算整数数据，同样还有<code>EC_READ_U32()</code></li>
</ul>
</li>
<li><p><code>EC_WRITE_U16()</code></p>
<ul>
<li>功能：宏函数，将整型数据写入内存。内存大小是<code>ecrt_slave_config_create_sdo_request()</code>的参数。</li>
</ul>
</li>
<li><p><code>ecrt_master_sync_reference_clock()</code></p>
<ul>
<li>功能：将DC参考时钟偏移补偿数据报排队发送，参考时钟将上次取消<code>ecrt_master_application_time()</code>提供的应用程序时间同步</li>
<li>函数原型：<code>void ecrt_master_sync_reference_clock(ec_master_t *master)</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_master_sync_slave_clocks()</code></p>
<ul>
<li>功能：将DC时钟偏移补偿数据报排队发送，所有的子时钟与基准时钟同步</li>
<li>函数原型：<code>void ecrt_master_sync_slave_clocks(ec_master_t* master);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_domain_queue()</code></p>
<ul>
<li>功能：<strong>将主数据报队列中的所有域数据报排队</strong>。调用此函数可标记域的数据报以便在<code>ecrt_master_send()</code>的下一次调用</li>
<li>函数原型：<code>void ecrt_domain_queue(ec_domain_t* domain);</code></li>
<li>参数：<code>domain</code> – 域</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_master_send()</code></p>
<ul>
<li>功能：<strong>发送队列中的所有数据报</strong>。该方法接收所有排队等待传输的数据报，将他们放入帧中，并将他们传递给以太网设备进行发送</li>
<li>函数原型：<code>void ecrt_master_send(ec_master_t* master);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_master_application_time()</code></p>
<ul>
<li>功能：设置应用程序时间。在使用分布式时钟操作从机时，主机必须知道应用程序的时间。时间不是由主机本身增加的，因此必须循环调用此方法</li>
<li>函数原型：<code>void ecrt_master_application_time(ec_master_t* master, uint64_t app_time);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机；<code>app_time</code> – 应用时间</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_release_master()</code></p>
<ul>
<li>功能：释放请求的<code>ethercat</code>主机</li>
<li>函数原型：<code>void ecrt_release_master(ec_master_t* master);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
</ul>
<h2 id="关于PDO映射"><a href="#关于PDO映射" class="headerlink" title="关于PDO映射"></a>关于PDO映射</h2><ul>
<li><p><code>https://www.codeleading.com/article/95113301360/#:~:text=%E5%BD%93%E7%84%B6%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%B0%B1%E6%98%AF%E4%BD%BF%E7%94%A8ecrt_slave_config_pdos,%28%29%E5%87%BD%E6%95%B0%E5%AF%B9%E4%BB%8E%E7%AB%99%E9%85%8D%E7%BD%AE%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE%EF%BC%8C%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BC%9A%E5%B0%86%E5%8E%9F%E6%9C%ACSII%E5%A4%8D%E5%88%B6%E5%88%B0%E7%9A%84%E4%BB%8E%E7%AB%99%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84sync%E8%BF%9B%E8%A1%8C%E6%B8%85%E9%99%A4%EF%BC%8C%E8%80%8C%E5%90%8E%E4%BE%9D%E6%8D%AE%E6%96%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE%EF%BC%9A%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%84%E5%A6%82%E4%B8%8B%EF%BC%9A</code></p>
</li>
<li><p>对于PDO映射，首先它是已经有了一个sync中关联PDO的链表的前提下才进行的PDO映射。</p>
</li>
<li><p>使用<code>ecrt_slave_config_pdos()</code>函数进行PDO的在<code>sync</code>中的配置</p>
<ul>
<li>之所以有这样一个步骤，是因为主站状态部分，主站状态机在扫描SII信息时会提取<code>TxPDO</code>和<code>RxPDO</code>到从站的同步管理器(SII信息中有PDO和sync相关的信息)；然后再使用<code>ecrt_master_slave_config()</code>进行函数配置的时候会将对应从站的sync相关的PDO(<code>master-&gt;slaves-&gt;sync</code>)复制到从站配置部分，这样即使不去人为的配置同步管理器和PDO的映射关系，也没有什么影响</li>
</ul>
</li>
<li><p><code>ecrt_slave_config_pdos()</code></p>
<ul>
<li>函数对从站配置进行设置，会将原本SII复制到从站配置中的sync进行清除，而后依据新的配置进行设置，（目的就是为了对从站同步管理器的自定义设置）</li>
<li>需要使用到的参数分别是<code>sync, pdo, pdo_entry</code>结构体，三者关系是<code>sync</code>索引<code>PDO</code>， <code>PDO</code>索引<code>PDO_entry</code></li>
<li>从站如何获取PDO配置，可以使用<code>sudo ethercat cstruct</code>命令进行该信息的提取</li>
<li>针对每个<code>ec_sync_info_t</code>输入结构数组进行PDO映射处理，分为三个层次<ul>
<li>sync层次 – sync层次主要配置同步管理器的方向和看门狗设置</li>
<li>PDO层次 – 处理PDO的时候需要两个过程，一个是对之前的PDO配置进行清除，另一个是将自定义配置的<code>PDO</code>设置到从站配置的同步管理器链表中，这个过程还会查询之前的默认配置，将之前<code>PDO</code>中的<code>PDO_entry</code>复制到<code>PDO</code>中</li>
</ul>
</li>
</ul>
</li>
<li><p>以上两种PDO配置并不冲突，可以理解为前者是从站的默认配置，后者是用户为了个性化自定义配置（有无均可，只不过自定义的化可能会有冗余信息）</p>
</li>
</ul>
<h2 id="主站和从站"><a href="#主站和从站" class="headerlink" title="主站和从站"></a>主站和从站</h2><ul>
<li>参考：<ul>
<li><code>https://blog.csdn.net/qq923433160/article/details/83781812</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>主站的实现可采用嵌入式和PC机两种方式，均需配备标准以太网MAC控制器，传输介质可使用100BASE-TX规范的5类UTP线缆。</p>
</li>
<li><p>EtherCAT从站设备除了具备通信功能外，还需具备对从站设备的控制功能。常见的从站设备有I&#x2F;O端子、伺服设备、微处理器等。</p>
</li>
<li><p>EtherCAT主站运行需具备以下几个基本功能：</p>
<ul>
<li>读取从站设备描述XML文件并对其进行解析，获取其中配置参数</li>
<li>捕获和发送EtherCAT数据帧，完成EtherCAT子报文解析、打包等</li>
<li>管理从站设备状态，运行状态机，完成主从站状态机设置和维护</li>
<li>可进行非周期性数据通信，完成系统参数配置，处理通讯过程中突发事件</li>
<li>实现周期性过程数据通信，实现数据实时交换，实时监控从站状态，从站反馈 信号实时处理等功能。</li>
</ul>
</li>
</ul>
<h2 id="控制卡"><a href="#控制卡" class="headerlink" title="控制卡"></a>控制卡</h2><ul>
<li>参考：<ul>
<li><code>https://www.cnblogs.com/cariohu/p/15508175.html</code></li>
</ul>
</li>
</ul>
<h3 id="控制卡分类"><a href="#控制卡分类" class="headerlink" title="控制卡分类"></a>控制卡分类</h3><ul>
<li><p>控制器或者控制卡的性能主要取决于控制算法，不同厂家控制卡的性能差别可能非常大。</p>
</li>
<li><p>目前常见工业应用中比较高端的有以色列ACS，美国Aerotech，这是属于第一梯队的，其他国外的流行品牌还有elmo、PMAC、Galil、欧姆龙等。国内的有固高、雷赛、正运动、柏楚等，与国外产品相比仍然有一定差距，但也在不断突破。</p>
</li>
<li><p>根据控制器传递命令给驱动器的方式，可以分为：总线型、模拟量型、PWM型、脉冲型控制卡。</p>
</li>
<li><p>目前，总线型控制卡是最主流的，各大厂家的口号都是一网到底，这个网就是指的总线，就是通过一根总线把所有模块都接上去，确实方便。其他三种类型控制卡也有各自的特色，所以都并行存在于主流市场</p>
</li>
</ul>
<h3 id="总线控制卡"><a href="#总线控制卡" class="headerlink" title="总线控制卡"></a>总线控制卡</h3><ul>
<li><p>常见的总线接口有，<strong>EtherCAT</strong>、CAN、Modbus、Profinet、EPA、SERCOS-Ⅲ等。</p>
</li>
<li><p>总线有这么多种，他们之间是否有联系，又有哪些区别呢？这是我们学习总线之前需要搞清楚的问题，不然总是会心里没底，或者是错误的把总线混搭一起，这些是新手的必经之路。</p>
</li>
<li><p>要想搞清楚不同总线之间的区别与联系，我们就得从总线通讯的组成或者是框架去看</p>
<ul>
<li>通讯的概念出现的很早，早期的电话电报就是一种通讯方式，但工业上的通讯应用都是OSI七层模型。OSI(open system interconnect)即开放系统的互连，这个是二十世纪七十年代的产物，当时就是为了解决各系统之间通讯的问题。</li>
<li>OSI七层模型图，从模型中我们可以看到，通讯最终是转化为比特流发送出去，我们说的通讯速率就是比特流的速率，比如百兆网络100Mbit&#x2F;s。比特流的传输载体是物理层，是我们看的见摸得着的线缆以及接口芯片等。</li>
<li>物理层往上是数据链路层，数据链路层的职责是负责将具体的数据转化成比特流，然后通过物理层的硬件发送。可以简单理解为，硬件的编码与解码，比如要发送数字8，那么数字8的比特流高低电平是怎样的；当收到一串比特流后，应该转换为哪个数字，这个就靠数据链路层完成的，数据链路层也是硬件。 </li>
<li>数据链路层再往上，还有五层。这五层都有一个特点，他们都是软件层，是运行在处理器上的软件代码，这五层完成数据报的解析，编组，归类，最终到显示。</li>
</ul>
</li>
<li><p>当我们用因特网看视频时，这些层就在周而复始发送请求，解析数据，并最终刷新到显示界面。这五层搞起来确实有点复杂，有些时候其实是不需要的，比如我们知道数据的具体含义，我们就不需要再去分组整理数量，直接使用即可，工业通讯应用正是符合这个特点。</p>
</li>
<li><p>尤其是针对运动控制或者过程控制总线，层太多不仅没用，反而会增加成本，并且运动控制或者过程控制这种专用总线上数据的含义都是严格一一对应的，不需各种分组分段解析啥的。所以，将五层压缩为一层，叫应用层。</p>
</li>
<li><p>物理层，数据链路层，应用层都有各自的功能，三层功能没有重叠部分。</p>
</li>
<li><p>发送工作流程是当数据到达后应用层后把数据放到对应的存储区，数据需要发送时到对应区域取出数据，交给数据链路层，比特流经物理层发送出去；</p>
</li>
<li><p>接收工作流程就是反过来，物理层上的比特流被数据链路层解析为正确的数值，放到对应的存储区域，应用层需要数据的时候取走数据即可。</p>
</li>
<li><p>所以，运动控制或者过程控制总线，这种专用总线都是三层模型，三层模型的功能：</p>
<ul>
<li>应用层：搬运数据，完成控制功能</li>
<li>数据链路层：承上启下，生成比特流，以及解析比特流</li>
<li>物理层：比特流传输载体</li>
</ul>
</li>
<li><p>当我们接触或者学习新的总线时，主要是搞清楚总线的框架，即这三层的情况是怎样的。只有搞清楚了这三层，你才不会被各种新鲜名词所吓倒，你才不会去随便混搭总线。搞清楚了总线通讯模型后，我们看下当前最火的两个总线，EtherCAT和CAN总线。</p>
</li>
<li><p>为什么EtherCAT和CAN总线这么火？</p>
</li>
</ul>
<h4 id="CAN总线"><a href="#CAN总线" class="headerlink" title="CAN总线"></a>CAN总线</h4><ul>
<li><p>首先，是CAN总线起步早，博世公司1986年推出，当时主要是面向汽车行业。注意这里我说的是CAN总线，不是CANOPEN总线，CANOPEN只是基于CAN总线的应用层协议，汽车行业基于CAN总线的应用层协议是J1939。经过汽车行业的多年应用，大家发现这个总线的优点很多，速度快，1Mbit在现在看确实不快，但在那个年代还是非常牛的；有COB-ID，有仲裁机制，高优先级的数据可以先传输，低优先级是数据后发送，排队的数据在总线空闲的时候会自动发送，无需人为干预；差分传输，数据传输可靠性高；理论上可以在总线上挂任意多节点；成本低，几块钱的MCU就自带CAN控制器，现在一般同时支持CAN2.0A和2.0B。</p>
</li>
<li><p>既然CAN总线有这么多优点，那就得充分利用上，紧接着有个组织叫CIA(CAN in Automation)起草了基于CANopen的设备及通讯子协议定义DS 301(Draft Standard 301)，也就是我们经常说的301协定。DS301只是CANopen的一个基础规范，具体到细分领域有，I&#x2F;O模组的DS401，运动控制的DS402。讲到这里就出现了我们期盼已久的CANopen协议，之所以火就是因为起步早，又赶上了电机运动控制的蓬勃发展时期，靠谱好用，便宜，易上手。其实基于CAN总线的应用层协议还有北美船舶行业通讯协议，广州周立功公司的iCAN，但这个两个协议都不在运动控制系统中出现。其实协议就是这么简单，你也可以基于CAN总线创立自己的协议，只要有人用，你就很了不起。</p>
</li>
<li><p>这里简单讲下CANopen DS402的相关知识，方便我们后面的理解。DS402里面有一些概念，对象字典，Node-ID，COB-ID，SDO，PDO，NMT，Heartbeat，状态机，Master，Slave，我们都简单介绍下。</p>
<ul>
<li>DS402中规定网络中各设备是主从关系，即Master-Slave模式，原则上只能有一个Master，负责整个网络的管理。其实CAN总线上的都是节点，没有主从的概念，主从的概念是在DS402中规定的，这一点我们要清楚。</li>
<li><strong>对象字典我们可以理解为寄存器表</strong>，只不过DS402已经规定了这个寄存器表的组织结构，包括一部分地址必须给协议使用，如0x6040,0x6041这些都是规定好的。有了对象字典我们就知道每个对象代表的是什么意思，每个厂家都按这个去设计。传输数据的时候我们得知道这个是哪个从站设备的数据，就需要有个Node-ID，简单说就是设备的编号。</li>
<li>假如不同设备同时要传输同样对象字典的数据，那我们该怎样区分呢？这个时候就有COB-ID，COB-ID是对应的编码加上Node-ID，如0x600表示SDO读，对应节点1组合后的COB-ID就是0x600+0x01&#x3D;0x601，节点2则为0x602，以此类推。这样我们就可以通过COB-ID来直接操作数据了，而无需关心是哪个节点的，如果数据同时需要发送，那么总线的仲裁机制就会起作用，COB-ID越小的优先级越高，优先发送，等待的数据在前面的数据发送完之后会自动重发。</li>
</ul>
</li>
<li><p>数据的传输分为两种</p>
<ul>
<li>一种是SDO，就是有问才有答，查询一次回复一次，类似服务生一样。</li>
<li>另一种是PDO，叫过程数据，提前配置好了数据的传输方式后数据就会自动上传，如可以设置数据的最小间隔时间，同步、异步、RTR等。</li>
</ul>
</li>
<li><p>SDO和PDO都是为了传输数据，但PDO传输的是过程数据，更精简，传输数据的效率会更高，<strong>如循环同步模式肯定是PDO传输数据</strong></p>
</li>
<li><p>NMT是网络管理的意思，主站负责管理整个网络，如各节点的状态切换等。</p>
</li>
<li><p>状态机是控制节点切换的，如在非使能状态到使能状态应该怎么响应，这个是状态机管理的。</p>
</li>
<li><p>最后一个是Hearbeat，当然也有NodeGuarding，这两个都是反馈节点的状态。当总线在工作的时候我们得知道节点是否还在线，Hearbeat就类似我们的心跳，间隔多长时间必须收到一次心跳，超出设定时间没收到心跳则表示该节点已死亡。</p>
</li>
<li><p>NodeGuarding是另外一种监测方式，它有主站和从站的互动，这是不同于Hearbeat的，就是主站要发命令给从站，从站也要回应命令，也是要求在规定的时间内，目前Hearbeat用的更多一些。</p>
</li>
</ul>
<h4 id="EtherCAT总线"><a href="#EtherCAT总线" class="headerlink" title="EtherCAT总线"></a>EtherCAT总线</h4><ul>
<li><p>EthterCAT的字面意思就是以太网自动化控制技术。简单点说就是基于以太网，完成自动化控制功能，但肯定与普通以太网还是有区别的。</p>
</li>
<li><p>他们的传输介质是一样的，都是RJ45网口+网线，但EtherCAT网络的数据链路层芯片是专门设计的，其目的是为了提高总线的性能。比如，增加了DC同步单元，数据自动转发，还有FMMU单元，SM单元，详细的情况可以去查询相关资料。</p>
</li>
<li><p>DC同步单元的时钟都是ns为单位，可以满足非常高的同步要求，然后以太网的通讯速度又非常快，现在1000Mbit&#x2F;s都已经不是事了，在每个传输周期可以有非常大量的数据交互。这些都是基于硬件的，做应用的人可以不用关心，我们还是讲讲上层协议。</p>
</li>
<li><p>对硬件感兴趣的可以参考AX58100、ET1100芯片的数据手册，山东大学李正军教授的《EtherCAT工业以太网应用技术》非常不错，里面有详细的介绍，值得一看，这里就不展开讲了。</p>
</li>
<li><p>基于EtherCAT总线的应用层协议有FoE、CoE、SoE、EoE、AoE、VoE，各个协议的具体描述如下表2-2：</p>
<ul>
<li>FoE, File over EtherCAT     –  在EtherCAT总线上传输文件的协议</li>
<li>CoE, CANopen over EtherCAT  –  在EtherCAT总线上执行CANopen协议</li>
<li>SoE, SERCOS over EtherCAT   –  在EtherCAT总线上执行SERCOS协议</li>
<li>EoE, Ethernet over EtherCAT –  在EtherCAT总线上执行Ethernet协议</li>
<li>AoE  –  访问底层现场总线的从站设备的对象字典，如对连接到EtherCAT-CAN网关设备的CAN从站</li>
<li>VoE  –  供应商自定义协议，基于邮箱</li>
</ul>
</li>
<li><p>这些都是运行在EhterCAT总线基础上的应用层协议，各个协议分管与自己相关的工作。</p>
</li>
<li><p>我们现在常用的EtherCAT伺服驱动器，说白了就是把CANopen应用层协议搬到了EtherCAT总线之上。由于EhterCAT总线的高传输速度，所以这个时候可以有更高的控制信号频率，就会有更好的控制效果。</p>
</li>
<li><p>讲到这里，我们可以发现，同样的协议可以在不同的总线上，同样的总线也可以用不同的协议。所以，<strong>当我们讨论总线的时候也要讨论总线的应用层协议</strong>，即我们前文提到的三层模型，只有三层模型都一样的系统才能完美对接。对总线就介绍这么多，原理都是一样的，其他总线可以按照这个方法学习，事半功倍。</p>
</li>
<li><p>有了这样可靠性高，同步性好，控制频率可以很高的总线，现在控制指令的频率到8Khz已经不是问题了。控制卡的指令就可以很快很准的发送给总线上的驱动单元，最终达到好的控制效果。总线型控制系统的所有指令，位置反馈，指示状态，错误代码等等，都是由通讯来完成交互的，这一点和传统的控制方式有很大的区别。</p>
</li>
</ul>
<h2 id="驱动支持的各种模式详解"><a href="#驱动支持的各种模式详解" class="headerlink" title="驱动支持的各种模式详解"></a>驱动支持的各种模式详解</h2><ul>
<li><p>早期非总线的驱动器一般是支持三个工作模式，位置模式，速度模式和电流模式，这个都比较简单，配置好模式，给对应的指令即可工作。</p>
</li>
<li><p>这些模式一般都可以接收模拟量和PWM命令，位置模式还可以接收脉冲命令，这个就不展开讲了，参对应驱动的手册即可知道特定模式支持哪些类型的命令输入。这种驱动最大的缺点就是接线复杂，控制卡离驱动不能太远，还需要考虑控制线缆抗干扰，不利于分布式现场的情况。这种一般是应用于小型独立式设备，设备相对比较小，线缆不会太长，干扰问题比较好解决。</p>
</li>
<li><p>随着总线型驱动器的出现，驱动器的工作模式增加了好几个。没有特殊说明的话，这里的总线指的是CAN总线和EtherCAT总线。</p>
</li>
<li><p>基于这两个总线的驱动器一般都支持如表3-1所示的模式，当然还有PVT模式，IPM模式，但这些现在已经都不太常见了，有需要的可以查阅相关资料。   </p>
<ul>
<li>HM   –  回零模式</li>
<li>PVM  –  带规划的速度模式</li>
<li>PPM  –  带规划的位置模式</li>
<li>CSP  –  循环同步的位置模式</li>
<li>CSV  –  循环同步的速度模式</li>
<li>CST  –  循环同步的转矩模式</li>
</ul>
</li>
<li><p>HM模式是回零模式，驱动器已经内置好了各种回零方式。如先找负限位再找index方式；用限位作为回零原点方式；碰到硬限位回零方式等等。这些回零方式的程序已经在驱动器内部实现好了，我们只需要配置好相关参数，启动回零即可，回零过程都是驱动器内部程序完成。同时，也有状态变量可以监控当前的回零状态，是否完成，是否有报错等。</p>
</li>
<li><p>PVM和PPM是带规划的速度和位置模式，规划的意思就是根据用户设定的加减速度去启动和停止运动。这个两个模式很简单，有点像非总线伺服驱动器的速度模式和位置模式，这里不详细介绍了。</p>
</li>
<li><p>我们重点介绍下循环同步模式，循环同步的意思就是以一个固定的时间间隔，周而复始的发送数据和同步指令。为什么要搞这个玩法呢？PVM PPM不香吗？这是我们学习新知识前需要考虑的问题，搞清楚了背景，理解起来会更有帮助。</p>
<ul>
<li>我们先想下，控制卡+非总线伺服驱动器是怎样实现多轴同步的，是多个驱动的控制命令在同一个DSP中运算，这样时间上就不会有偏差，确保每次都是几乎同一时间把指令发送给驱动器。如果是多个DSP有各自控制的驱动器，这些驱动器之间做同步运动，比如插补，效果都会差于一个DSP内部轴同步的效果，除非你把多个DSP任一时刻都同步起来，同样的时间做同样的运算，这样也许会是一样的效果。</li>
<li>而我们这里说的循环同步就是干这个事情，总线型驱动器与控制卡或者叫master之间的连接只有一条通讯线，无论这条通讯线是CAN总线的半双工，或是EtherCAT总线的全双工，再加100Mbit&#x2F;s的带宽，数据传输总会有先后顺序，这个事实没法改变。假如总线上的所有驱动器都以收到指令数据的那一刻去执行指令，那么驱动器之间就无法很好同步了。</li>
<li>那么应该怎么办呢？人是真的聪明，总会想办法去解决问题，天才的工程师提出了一个解决方案。所有驱动器都先收指令数据，但不要立马执行，等待一个命令再执行，这个就是同步命令，这样就完美的解决了总线上数据传输有先后顺序的问题。大家都是先把数据准备好，然后等待同步命令，这个就好比百米赛跑一样，大家都先准备好，等待发令枪再跑，这样就是公平的。至于最终跑的结果怎样看个人水平，驱动器最终执行的效果怎样也是看驱动器的性能，感觉这个启发真是源于生活，最终又服务于生活。</li>
</ul>
</li>
<li><p>讲完什么是循环同步后，我们看下循环同步的三个模式到底是啥。</p>
</li>
<li><p>首先说CSP，循环同步的位置模式：</p>
<ul>
<li>这个模式接收的是控制卡下发的位置指令，但这个位置不是随便发的，需要根据位置轨迹解算为一个一个点，这个是需要上位机解算的。</li>
<li>上位解算点的这个过程叫粗插，就是粗线条的给出一些点，这些点不是驱动伺服环路能直接使用的，驱动器在接收到这些点后需要再进行精插，最终变成伺服环路能直接执行的位置点。</li>
<li>精插是相对于粗插来说的，精插是以伺服周期为基准时间单位，精细的将轨迹分成很多个位置点，形成一个位置表，每个伺服周期去这个表中取一个值执行即可。</li>
<li>我们以一个T形加减速，有匀速过程的点到点运动为例来剖析CSP模式的细节。如图3-15，是一个点到点运动，位置—时间和速度—时间关系图，加速和减速阶段的轨迹是曲线，匀速阶段是直线。再看下位置图中的插值点，这些点之间的时间是均匀间隔的，每到一个时间点位置轨迹与时间轴围成一个面积，这个面积就是我们在CSP模式发送给驱动器的位置指令，随着时间的增加，这个面积会越来越大。</li>
<li>只要这些插值点是均匀的，指令发送的时间是准确的，满足这两个条件的情况下，电机的转动必然是平滑的。这两个条件中的任何一个不满足，电机的转动都是会顿挫的。</li>
<li>如果插值点不均匀，比如有的时候插值点是间隔10ms，有的时候插值点是20ms。最明显的结果就是电机运动不平滑，那么为什么会不平滑呢？我们知道位置轨迹连续则位置轨迹的导数或者叫曲线的曲率才不会有突变，位置轨迹导数对应着的是速度，速度不突变则电机运转平稳。如果我的插值点时间突然增加或者缩短，则必然会导致曲率突变，这是上位在解算轨迹点需要注意的问题。</li>
<li>尤其是任意轨迹曲线，曲率的突变非常厉害，即使在均匀的插值情况下，电机运转可能都会抖动明显。所以，对任意曲线的插值，还有需要针对锐角以及曲率突变的点做优化，比如用圆弧过度锐角，或者降低运动速度。</li>
<li>到这里我们对CSP的整个细节基本讲完了，在使用过程中，我们还需注意循环同步指令的周期以及指令到达是否准时。指令的周期不应过短，要让驱动器有精插的空间，比如驱动伺服环路400us，那么你就不要给低于400us的同步周期，当然很多驱动也不支持这么短的同步周期，即使支持也不要这样给。同步指令要有硬时性，或者实时性好，我们一般以us为单位，尽可能的准时，指令不准时同样会导致电机运动的时候顿挫严重，甚至驱动器报错。</li>
<li>到这里我们讲完了整个CSP模式的要点，在使用CSP模式的时候如果电机运转不平滑，该怎样去找问题，这才是我们要关注的核心。看到这里应该有一种豁然开朗的感觉，就证明你完全理解了循环同步位置模式的精髓。</li>
</ul>
</li>
<li><p>讲完CSP模式，后面的CSV和CST模式就简单了，我们先看看CSV模式：</p>
<ul>
<li>CSV是循环同步的速度模式，控制卡下发的是速度指令，这个速度指令和位置指令一样，也不是随便给的。需要对速度曲线进行插值，解算每个周期应该给驱动的速度指令，对位置轨迹求导数就是速度，也就有了速度曲线。</li>
<li>同CSP一样，控制卡或者上位也只是粗插，伺服环路还会根据指令和周期的时间进行精插，最终就变成了伺服环路可以执行的指令。</li>
<li>同样，CSV模式对指令的实时性要求同CSP一样，不准时的指令就会导致电机运转的时候顿挫，顿挫就是速度突变造成的，分析方法和CSP模式一样，这里不再赘述</li>
</ul>
</li>
<li><p>看完CSV，我们再看看CST：</p>
<ul>
<li>这个模式和前面两个的共同之处是都为循环同步模式，不同之处是CST模式的指令直接被伺服环路所用，中间没有精插的过程。由于这个不同，CST模式的指令实时性不好的时候我们也很难发现，因为CST模式对应的是电机的电流，电流对应的是电机的输出转矩，电流的突变就是转矩的突变。</li>
<li>转矩的是突变对应三种情况：<ul>
<li>一种是电机输出转矩大于负载转矩，电机加速</li>
<li>另一种是电机输出转矩等于负载转矩，电机还是静止；</li>
<li>甚至是电机输出转矩小于负载转矩，电机被负载拖动，运动控制中这种一般很少</li>
</ul>
</li>
<li>指令实时性不好很难被发现，并不是说CST模式对指令实时性没有要求，既然叫循环同步模式，那就是有这个要求。</li>
</ul>
</li>
<li><p>总结下三个循环同步模式，循环同步模式的出现，使得我们对任意轨迹的指令规划变得非常方便，就是对曲线插值，获得各时刻应该下发的指令。它使我们更加靠近了伺服环路的工作原理，伺服环路其实也是一直在插，不断的解算各个伺服周期的命令，然后算法以读表的方式不断的读取各个周期的指令。</p>
</li>
<li><p>讲到这里，整个驱动器的相关知识就介绍完了。简单总结就是，驱动器有硬件和固件两部分，硬件部分负责控制电机的换向，电流调节，反馈信号采集等；固件部分或者叫软件部分，则是通过硬件的各种反馈信号，周而复的运算，并将运算结果输出到硬件。其实整个伺服系统工作的过程，就是一个不断纠偏的过程，大了就小点，小了就大点，没有真正的静止，一直运动，只是在几个脉冲来回移动，这才是伺服系统的精髓，没有真正的静止。</p>
</li>
</ul>
<h2 id="EtherCAT-配置流程"><a href="#EtherCAT-配置流程" class="headerlink" title="EtherCAT 配置流程"></a>EtherCAT 配置流程</h2><ol>
<li>init master</li>
<li>init slave</li>
<li>init pdo</li>
<li>init pdo_entry</li>
<li>config pdo_entry</li>
<li>config pdo</li>
<li>config slave </li>
<li>config master</li>
<li>config sdo</li>
<li>lock memory</li>
<li>start master</li>
<li>start slave</li>
</ol>
<h2 id="EtherCAT-通讯流程"><a href="#EtherCAT-通讯流程" class="headerlink" title="EtherCAT 通讯流程"></a>EtherCAT 通讯流程</h2><ol>
<li>master receive </li>
<li>slave receive </li>
<li>pdo read update</li>
<li>control strategy</li>
<li>pdo write update</li>
<li>master sync</li>
<li>slave send </li>
<li>master send</li>
</ol>
<h2 id="PDO-1"><a href="#PDO-1" class="headerlink" title="PDO"></a>PDO</h2><ul>
<li>pdo 可以分为三级<ul>
<li>SM(sync manager)，每个SM可以同步多个 pdo</li>
<li>pdo，每个 pdo 包含多个 pdo entry</li>
<li>pdo entry，每个 pdo entry 对应一个 index 和 subindex</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Eigen3/2024-05-22-Eigen_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Eigen3/2024-05-22-Eigen_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Eigen_2_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen3/" itemprop="url" rel="index"><span itemprop="name">Eigen3</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Eigen 库常用的编程技巧</li>
</ul>
<h2 id="eigen3-两个矩阵相乘-示例详解"><a href="#eigen3-两个矩阵相乘-示例详解" class="headerlink" title="eigen3 两个矩阵相乘 示例详解"></a>eigen3 两个矩阵相乘 示例详解</h2><p>Eigen是一个C++模板库，用于线性代数操作，包括矩阵相乘。Eigen的3.x版本中提供了一个简洁而强大的矩阵相乘接口，用于进行矩阵乘法运算。下面是一个简单的示例，展示如何在Eigen中进行两个矩阵的相乘。</p>
<p>首先，确保你已经安装了Eigen库，并且包含了适当的头文件。通常，你需要在代码中包含类似这样的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>然后，你可以使用Eigen库来执行矩阵相乘操作。以下是一个示例代码，假设你已经创建了两个矩阵 A 和 B，并且想要计算它们的乘积 C。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建矩阵 A 和 B</span></span><br><span class="line">    <span class="function">Eigen::MatrixXd <span class="title">A</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;  <span class="comment">// 3x3 矩阵</span></span><br><span class="line">    <span class="function">Eigen::MatrixXd <span class="title">B</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;  <span class="comment">// 3x3 矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化矩阵 A 和 B</span></span><br><span class="line">    A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">         <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    B &lt;&lt; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>,</span><br><span class="line">         <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>,</span><br><span class="line">         <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算矩阵相乘 C = A * B</span></span><br><span class="line">    Eigen::MatrixXd C = A * B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Matrix B:\n&quot;</span> &lt;&lt; B &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Matrix C (A * B):\n&quot;</span> &lt;&lt; C &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了两个3x3的矩阵 A 和 B，并使用<code>&lt;&lt;</code>操作符初始化它们。然后，我们使用<code>*</code>运算符将矩阵 A 和 B 相乘，将结果存储在矩阵 C 中。</p>
<p>最后，我们打印了矩阵 A、B 和 C 的值。你会看到矩阵 C 包含了矩阵 A 和 B 的乘积。</p>
<p>这只是一个简单的示例，展示了如何在Eigen中进行矩阵相乘操作。Eigen提供了丰富的线性代数功能，包括各种矩阵运算和分解，使其成为处理线性代数问题的强大工具。</p>
<h2 id="Eigen-Vector3d-获取元素值"><a href="#Eigen-Vector3d-获取元素值" class="headerlink" title="Eigen::Vector3d 获取元素值"></a>Eigen::Vector3d 获取元素值</h2><p>在Eigen C++库中，<code>Eigen::Vector3d</code> 是一个表示三维向量的类。要获取<code>Eigen::Vector3d</code> 对象的元素值，你可以使用<code>operator[]</code>或者成员函数<code>x()</code>, <code>y()</code> 和 <code>z()</code>。下面是一些示例代码：</p>
<ol>
<li><p>使用 <code>operator[]</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> x = v[<span class="number">0</span>];  <span class="comment">// 获取第一个元素</span></span><br><span class="line">    <span class="type">double</span> y = v[<span class="number">1</span>];  <span class="comment">// 获取第二个元素</span></span><br><span class="line">    <span class="type">double</span> z = v[<span class="number">2</span>];  <span class="comment">// 获取第三个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用成员函数 <code>x()</code>, <code>y()</code> 和 <code>z()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> x = v.<span class="built_in">x</span>();  <span class="comment">// 获取第一个元素</span></span><br><span class="line">    <span class="type">double</span> y = v.<span class="built_in">y</span>();  <span class="comment">// 获取第二个元素</span></span><br><span class="line">    <span class="type">double</span> z = v.<span class="built_in">z</span>();  <span class="comment">// 获取第三个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>两种方法都可以用来获取向量的元素值。选择哪种方法取决于你的偏好和代码的上下文。使用 <code>operator[]</code> 更类似于访问普通的数组，而使用成员函数则更加直观，因为它们使用了更具描述性的名称。</p>
<h2 id="Eigen-Vector3f-示例"><a href="#Eigen-Vector3f-示例" class="headerlink" title="Eigen::Vector3f 示例"></a>Eigen::Vector3f 示例</h2><p>以下是一个简单的示例，演示了如何使用Eigen库中的<code>Eigen::Vector3f</code>来执行向量计算操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明两个三维浮点数向量</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">v1</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">v2</span><span class="params">(<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量加法</span></span><br><span class="line">    Eigen::Vector3f sum = v1 + v2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量点积</span></span><br><span class="line">    <span class="type">float</span> dotProduct = v<span class="number">1.</span><span class="built_in">dot</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量叉积</span></span><br><span class="line">    Eigen::Vector3f crossProduct = v<span class="number">1.</span><span class="built_in">cross</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v1: &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v2: &quot;</span> &lt;&lt; v<span class="number">2.</span><span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum.<span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dot product: &quot;</span> &lt;&lt; dotProduct &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cross product: &quot;</span> &lt;&lt; crossProduct.<span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先包含了Eigen库的头文件，并声明了两个三维浮点数向量 <code>v1</code> 和 <code>v2</code>。然后，我们执行了向量加法、点积和叉积操作，并输出了结果。</p>
<p>请确保您已经正确安装了Eigen库，并且能够通过编译器访问该库。在实际应用中，您可以使用<code>g++</code>或其他支持C++的编译器来编译和运行这段示例代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/EtherCat/2024-05-22-ethercat_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/EtherCat/2024-05-22-ethercat_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">EtherCat_2_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/EtherCat/" itemprop="url" rel="index"><span itemprop="name">EtherCat</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ethercat常用函数</li>
</ul>
<h2 id="ethercat"><a href="#ethercat" class="headerlink" title="ethercat"></a>ethercat</h2><h2 id="1-1-启动，设置"><a href="#1-1-启动，设置" class="headerlink" title="1.1 启动，设置"></a>1.1 启动，设置</h2><ul>
<li><p>ethercat都是在root用户下执行命令</p>
</li>
<li><p>设置从站</p>
<ul>
<li>ethercat alias -p 2 0:2</li>
</ul>
</li>
<li><p>启动ethercat</p>
<ul>
<li><code>/etc/init.d/ethercat start</code></li>
</ul>
</li>
<li><p>查看状态</p>
<ul>
<li><code>ethercat slv</code></li>
</ul>
</li>
</ul>
<h2 id="1-2-调试命令"><a href="#1-2-调试命令" class="headerlink" title="1.2 调试命令"></a>1.2 调试命令</h2><ul>
<li><p>查看从站状态码</p>
<ul>
<li><code>ethercat upload -t int16 -p 0 0x603f 00</code></li>
</ul>
</li>
<li><p>查看从站位置：</p>
<ul>
<li><code>ethercat upload -t int32 -p 0 0x6064 00</code></li>
</ul>
</li>
</ul>
<h2 id="1-2-demo-webserver-c-分析"><a href="#1-2-demo-webserver-c-分析" class="headerlink" title="1.2 demo_webserver.c 分析"></a>1.2 demo_webserver.c 分析</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="ec-pdo-entry-info-t"><a href="#ec-pdo-entry-info-t" class="headerlink" title="ec_pdo_entry_info_t"></a><code>ec_pdo_entry_info_t</code></h2><ul>
<li>简介：PDO条目配置信息。这是<code>ec_pdo_info_t</code>中的<code>entries</code>字段的数据类型</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">uint16_t</span> index;      <span class="comment">/**&lt; PDO entry index. */</span></span><br><span class="line">  <span class="type">uint8_t</span>  subindex;   <span class="comment">/**&lt; PDO entry subindex. */</span></span><br><span class="line">  <span class="type">uint8_t</span>  bit_length; <span class="comment">/**&lt; Size of the PDO entry in bit. */</span></span><br><span class="line">&#125; <span class="type">ec_pdo_entry_info_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-pdo-info-t"><a href="#ec-pdo-info-t" class="headerlink" title="ec_pdo_info_t"></a><code>ec_pdo_info_t</code></h2><ul>
<li>简介：PDO配置信息。这是<code>ec_sync_info_t</code>中的<code>pdos</code>字段的数据类型</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">uint16_t</span> index;              <span class="comment">/**&lt; PDO index. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n_entries;      <span class="comment">/**&lt; 要映射的entries PDO条目数 (0表示使用默认映射，这只能在从服务器处于总线配置时完成)*/</span></span><br><span class="line">  <span class="type">ec_pdo_entry_info_t</span> *entries;<span class="comment">/**&lt; 要映射的PDO项数组。可以是NULL，或者必须包含至少n_entries个值*/</span></span><br><span class="line">&#125; <span class="type">ec_pdo_info_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-sync-info-t"><a href="#ec-sync-info-t" class="headerlink" title="ec_sync_info_t"></a><code>ec_sync_info_t</code></h2><ul>
<li>简介：同步管理器配置信息。这可以用于配置多个同步管理器，包括PDO分配和PDO映射。它被作为<code>ecrt_slave_config_pdos()</code>函数的输入参数使用</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span> index;  <span class="comment">/**&lt; 同步管理器索引。Sync manager index.Must be less than #EC_MAX_SYNC_MANAGERS for a valid sync manager,but can also be \a 0xff to mark the end of the list. */</span></span><br><span class="line">  <span class="type">ec_direction_t</span> dir;  <span class="comment">/**&lt;同步管理器方向 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>   n_pdos;  <span class="comment">/**&lt; PDOs在pdos结构体数组中的数量 */</span></span><br><span class="line">  <span class="type">ec_pdo_info_t</span>  *pdos;  <span class="comment">/**&lt;带有要分配的pdo的数组。所包含的PDOs必须不少于n_pdos</span></span><br><span class="line"><span class="comment">  ec_watchdog_mode_t watchdog_mode;  /**&lt; 看门狗模式 */</span></span><br><span class="line">&#125; <span class="type">ec_sync_info_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-master-t"><a href="#ec-master-t" class="headerlink" title="ec_master_t"></a><code>ec_master_t</code></h2><ul>
<li>简介：主站</li>
</ul>
<h2 id="ecrt-master-state-t"><a href="#ecrt-master-state-t" class="headerlink" title="ecrt_master_state_t"></a><code>ecrt_master_state_t</code></h2><ul>
<li>简介：主站状态，这个是用于函数<code>ecrt_master_state()</code>函数的输出参数</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> slaves_responding;  <span class="comment">// 所有Ethernet设备响应从站的总和</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> al_states : <span class="number">4</span>;      <span class="comment">// 所有从站的应用层状态。状态被编码在较低的4位。如果设置了一个比特位，就意味着至少有一个从站在主线上响应：Bit 0: \a INIT；Bit 1: \a PREOP；Bit 2: \a SAFEOP；Bit 3: \a OP */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> link_up : <span class="number">1</span>;        <span class="comment">// true，如果至少有一个 Ethernet link是在线的，则为true</span></span><br><span class="line">&#125; <span class="type">ec_master_state_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-slave-config-t"><a href="#ec-slave-config-t" class="headerlink" title="ec_slave_config_t"></a><code>ec_slave_config_t</code></h2><ul>
<li>简介：从站配置</li>
</ul>
<h2 id="ec-slave-config-state-t"><a href="#ec-slave-config-state-t" class="headerlink" title="ec_slave_config_state_t"></a><code>ec_slave_config_state_t</code></h2><ul>
<li>简介：从站配置状态。它用于函数<code>ecrt_slave_config_state()</code>的输出参数</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> online : <span class="number">1</span>;      <span class="comment">// 这个从站是在线的</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> operational : <span class="number">1</span>; <span class="comment">// 这个从站通过指定配置进入OP状态</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> al_state : <span class="number">4</span>;    <span class="comment">// 应用层的从站状态：1: \a INIT；2: \a PREOP；4: \a SAFEOP；8: \a OP</span></span><br><span class="line">&#125; <span class="type">ec_slave_config_state_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-domain-t"><a href="#ec-domain-t" class="headerlink" title="ec_domain_t"></a><code>ec_domain_t</code></h2><ul>
<li>简介：域</li>
</ul>
<h2 id="ec-wc-state-t"><a href="#ec-wc-state-t" class="headerlink" title="ec_wc_state_t"></a><code>ec_wc_state_t</code></h2><ul>
<li>简介：域工作计数器状态说明。这个是在<code>ec_domain_state_t</code>中使用</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  EC_WC_ZERO = <span class="number">0</span>,   <span class="comment">// 没有交换注册的过程数据</span></span><br><span class="line">  EC_WC_INCOMPLETE, <span class="comment">// 交换了一些已注册的过程数据(部分过程数据)</span></span><br><span class="line">  EC_WC_COMPLETE    <span class="comment">// 交换了所有已注册的过程数据</span></span><br><span class="line">&#125; <span class="type">ec_wc_state_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-domain-state-t"><a href="#ec-domain-state-t" class="headerlink" title="ec_domain_state_t"></a><code>ec_domain_state_t</code></h2><ul>
<li>简介：域状态。它被作为函数<code>ecrt_domain_state()</code>的输出参数使用</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> working_counter;   <span class="comment">// 最后一个工作计数器的值</span></span><br><span class="line">  <span class="type">ec_wc_state_t</span> ws_state;         <span class="comment">// 工作计数器状态说明</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> redundancy_active; <span class="comment">// 冗余链路正在使用</span></span><br><span class="line">&#125; <span class="type">ec_domain_state_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ec-pdo-entry-reg-t"><a href="#ec-pdo-entry-reg-t" class="headerlink" title="ec_pdo_entry_reg_t"></a><code>ec_pdo_entry_reg_t</code></h2><ul>
<li>简介：列出PDO条目批量注册的记录类型。此类型用于<code>ecrt_domain_reg_pdo_entry_list()</code>的数组参数。</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">uint16_t</span> alias;             <span class="comment">// 从站别名地址</span></span><br><span class="line">  <span class="type">uint16_t</span> position;          <span class="comment">// 从站位置</span></span><br><span class="line">  <span class="type">uint32_t</span> vendor_id;         <span class="comment">// 从站供销商ID</span></span><br><span class="line">  <span class="type">uint32_t</span> product_code;      <span class="comment">// 从站产品码</span></span><br><span class="line">  <span class="type">uint16_t</span> index;             <span class="comment">// PDO条目索引</span></span><br><span class="line">  <span class="type">uint8_t</span>  subindex;          <span class="comment">// PDO条目子索引</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *offset;       <span class="comment">// 指向在进程数据中存储PDO条目(字节-)偏移量的变量的指针。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *bit_position; <span class="comment">// 指向一个变量的指针，用于在\a偏移量内存储位位置(0-7)。可以为NULL，在这种情况下，如果PDO条目不字节对齐会引发错误</span></span><br><span class="line">&#125; <span class="type">ec_pdo_entry_reg_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h2 id="ecrt-master-create-domain"><a href="#ecrt-master-create-domain" class="headerlink" title="ecrt_master_create_domain"></a><code>ecrt_master_create_domain</code></h2><ul>
<li>简介：创建一个新的过程数据域。对于流程数据交换，至少需要一个流程数据域。这个方法创建一个新的过程数据域，并返回一个指向新域对象的指针。这个对象能够在循环操作中用于注册PDOs和交换PDOs</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ec_domain_t</span> *<span class="title">ecrt_master_create_domain</span><span class="params">( <span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ecrt-request-master"><a href="#ecrt-request-master" class="headerlink" title="ecrt_request_master"></a><code>ecrt_request_master</code></h2><ul>
<li>简介：请求EtherCAT主机进行实时操作。<ul>
<li>在应用程序可以访问EtherCAT主机之前，它必须预留一个专用的主机。</li>
<li>在用户空间，这是<code>ecrt_open_master()</code>和<code>ecrt_master_reserve()</code>的方便函数。</li>
<li>这个函数必须是应用程序使用EtherCAT时必须调用的第一个函数</li>
<li>该函数以master的索引作为参数。第一个主节点的索引为0，第n个主节点的索引为n- 1。</li>
<li>在加载master时，必须指定master的数量。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ec_master_t</span> *<span class="title">ecrt_request_master</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> master_index)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ecrt-master-sdo-upload"><a href="#ecrt-master-sdo-upload" class="headerlink" title="ecrt_master_sdo_upload"></a><code>ecrt_master_sdo_upload</code></h2><ul>
<li>简介：执行SDO上传请求从从站读取数据。<ul>
<li>此请求由主状态机处理。</li>
<li>他的方法会阻塞，直到请求被处理，并且不能在实时上下文中调用。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_sdo_upload</span><span class="params">(<span class="type">ec_master_t</span> *master, <span class="type">uint16_t</span> slave_position, <span class="type">uint16_t</span> index, <span class="type">uint8_t</span> subindex, <span class="type">uint8_t</span> *target, <span class="type">size_t</span> target_size, <span class="type">size_t</span> *result_size, <span class="type">uint32_t</span> *abort_code)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>          –  EtherCAT主站</li>
<li><code>slave_position</code>  –  从站位置</li>
<li><code>index</code>           –  SDO索引</li>
<li><code>subindex</code>        –  SDO的子索引</li>
<li><code>target</code>          –  上传的目标缓冲区。</li>
<li><code>target_size</code>     –  目标缓冲区的大小</li>
<li><code>result_size</code>     –  已经上传的数据大小</li>
<li><code>abort_code</code>      –  SDO上传的中止代码。</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功 –  0</li>
<li>失败 –  &lt; 0</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-sdo-download"><a href="#ecrt-master-sdo-download" class="headerlink" title="ecrt_master_sdo_download"></a><code>ecrt_master_sdo_download</code></h2><ul>
<li>简介：执行SDO下载请求，将数据写入从站。<ul>
<li>此请求由主状态机处理。</li>
<li>他的方法会阻塞，直到请求被处理，并且不能在实时上下文中调用。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_sdo_download</span><span class="params">(<span class="type">ec_master_t</span> *master, <span class="type">uint16_t</span> slave_position, <span class="type">uint16_t</span> index, <span class="type">uint8_t</span> subindex, <span class="type">uint8_t</span> *data, <span class="type">size_t</span> data_size, <span class="type">uint32_t</span> *abort_code)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>          –  EtherCAT主站</li>
<li><code>slave_position</code>  –  从站位置</li>
<li><code>index</code>           –  SDO索引</li>
<li><code>subindex</code>        –  SDO的子索引</li>
<li><code>data</code>            –  要下载的数据缓冲区</li>
<li><code>data_size</code>       –  数据缓冲区大小</li>
<li><code>abort_code</code>      –  SDO上传的中止代码。</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功 –  0</li>
<li>失败 –  &lt; 0</li>
</ul>
</li>
</ul>
<h2 id="ecrt-domain-reg-pdo-entry-list"><a href="#ecrt-domain-reg-pdo-entry-list" class="headerlink" title="ecrt_domain_reg_pdo_entry_list"></a><code>ecrt_domain_reg_pdo_entry_list</code></h2><ul>
<li>简介：为一个域注册一堆PDO条目。此方法必须在<code>ecrt_master_activate()</code>之前在非实时上下文中调用。</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_domain_reg_pdo_entry_list</span><span class="params">(<span class="type">ec_domain_t</span> *domain, <span class="type">const</span> <span class="type">ec_pdo_entry_reg_t</span> *pdo_entry_regs)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>domain</code>  – 域</li>
<li><code>pdo_entry_regs</code>  – PDO注册数组。注册数组必须以一个空结构体结束，或者将\a索引字段设置为0 !</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – 0</li>
<li>失败  – 其他</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-activate"><a href="#ecrt-master-activate" class="headerlink" title="ecrt_master_activate"></a><code>ecrt_master_activate</code></h2><ul>
<li>简介：完成配置阶段并为循环操作做准备。<ul>
<li>这个函数告诉主机配置阶段已经完成，将开始实时操作。</li>
<li>该函数为域分配内部内存，并为域成员计算逻辑FMMU地址。</li>
<li>它告诉主状态机现在要应用总线配置。</li>
<li>调用此函数后，实时应用程序负责循环调用<code>ecrt_master_send()</code>和<code>ecrt_master_receive()</code>以确保总线通信。</li>
<li>在调用这个函数之前，由主线程负责，所以这些函数可能不会被调用!</li>
<li>该方法本身分配内存，不应该在实时上下文中调用。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_activate</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  EtherCAT 主站</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – 0</li>
<li>失败  – &lt; 0</li>
</ul>
</li>
</ul>
<h2 id="ecrt-domain-data"><a href="#ecrt-domain-data" class="headerlink" title="ecrt_domain_data"></a><code>ecrt_domain_data</code></h2><ul>
<li>简介：返回域的过程数据。<ul>
<li>在内核上下文中:<ul>
<li>如果使用<code>ecrt_domain_external_memory()</code>提供外部内存，则返回的指针将包含该内存的地址。</li>
<li>否则它将指向内部分配的内存。</li>
<li>在后一种情况下，在<code>ecrt_master_activate()</code>之前不能调用此方法。</li>
</ul>
</li>
<li>在用户空间上下文中:<ul>
<li>必须在<code>ecrt_master_activate()</code>之后调用此方法以获取映射的域进程数据内存。</li>
</ul>
</li>
</ul>
</li>
<li>声明：<code>uint8_t *ecrt_domain_data(ec_domain_t *domain);</code></li>
<li>参数：<ul>
<li><code>domain</code>  –  域</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回指向过程数据内存区域的指针</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-select-reference-clock"><a href="#ecrt-master-select-reference-clock" class="headerlink" title="ecrt_master_select_reference_clock"></a><code>ecrt_master_select_reference_clock</code></h2><ul>
<li>简介：为分布式时钟选择参考时钟。如果这个方法没有被某个主时钟调用，或者从时钟配置指针为NULL，那么第一个具有DC功能的从时钟将提供参考时钟。</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_select_reference_clock</span><span class="params">(<span class="type">ec_master_t</span> *master, <span class="type">ec_slave_config_t</span> *sc)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  EtherCAT 主站</li>
<li><code>sc</code>      –  Slave的Slave配置要引用的Slave(或NULL)。</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – 0</li>
<li>失败  –  负数，错误码</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-application-time"><a href="#ecrt-master-application-time" class="headerlink" title="ecrt_master_application_time"></a><code>ecrt_master_application_time</code></h2><ul>
<li>简介：设置应用时间。在使用分布式时钟操作从服务器时，主服务器必须知道应用程序的时间。主程序本身不会增加时间，因此必须循环调用此方法。<ul>
<li>传递给该方法的时间用于计算从服务器的SYNC0&#x2F;1中断的阶段。它应该经常在实时周期的同一点被调用。因此，建议在计算开始时调用它，以避免由于执行时间的变化而导致的偏差。</li>
<li>该时间用于设置从机的系统时间偏移和循环操作开始时间寄存器，以及通过ecrt_master_sync_reference_clock()将DC参考时钟同步到应用程序时间。</li>
<li>时间定义为从2000-01-01 00:00开始的纳秒。可以使用EC_TIMEVAL2NANO()宏来转换epoch时间，但这不是必需的，因为绝对值无关紧要</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_application_time</span><span class="params">(<span class="type">ec_master_t</span> *master, <span class="type">uint64_t</span> app_time)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  EtherCAT 主站</li>
<li><code>app_time</code>  –  应用时间</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-sync-reference-clock"><a href="#ecrt-master-sync-reference-clock" class="headerlink" title="ecrt_master_sync_reference_clock"></a><code>ecrt_master_sync_reference_clock</code></h2><ul>
<li>简介：将DC参考时钟漂移补偿数据报排队发送。参考时钟将被同步到由最后一次调用取消ecrt_master_application_time()提供的应用程序时间。</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_sync_reference_clock</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  EtherCAT 主站</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-sync-slave-clocks"><a href="#ecrt-master-sync-slave-clocks" class="headerlink" title="ecrt_master_sync_slave_clocks"></a><code>ecrt_master_sync_slave_clocks</code></h2><ul>
<li>简介：将DC时钟漂移补偿数据报排队发送。所有从时钟同步到参考时钟。</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_sync_slave_clocks</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  EtherCAT 主站</li>
</ul>
</li>
</ul>
<h2 id="ecrt-release-master"><a href="#ecrt-release-master" class="headerlink" title="ecrt_release_master"></a><code>ecrt_release_master</code></h2><ul>
<li>简介：释放一个请求的EtherCAT主机。<ul>
<li>在使用后，必须释放master，以便其他应用程序可以使用它。</li>
<li>此方法释放所有已创建的数据结构。它不应该在实时上下文中调用。</li>
<li>如果主站被激活，则内部调用<code>ecrt_master_deactivate()</code>。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_release_master</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  EtherCAT 主站</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-receive"><a href="#ecrt-master-receive" class="headerlink" title="ecrt_master_receive"></a><code>ecrt_master_receive</code></h2><ul>
<li>简介：从硬件中获取接收到的帧并处理数据报。<ul>
<li>通过调用中断服务例程查询网络设备接收的帧。</li>
<li>提取接收到的数据报，并将结果分派到队列中的数据报对象。</li>
<li>接收到的数据报和超时的数据报将被标记，并退出队列</li>
<li>必须在<code>ecrt_master_activate()</code>返回后由实时应用程序循环调用。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_receive</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ecrt-domain-process"><a href="#ecrt-domain-process" class="headerlink" title="ecrt_domain_process"></a><code>ecrt_domain_process</code></h2><ul>
<li>简介：确定域的数据报的状态。<ul>
<li>计算接收到的数据报的工作计数器，并在必要时输出统计信息。</li>
<li>这必须在<code>ecrt_master_receive()</code>接收域数据报之后调用，以便使<code>ecrt_domain_state()</code>返回最后一次进程数据交换的结果。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_domain_process</span><span class="params">(<span class="type">ec_domain_t</span> *domain)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ecrt-domain-queue"><a href="#ecrt-domain-queue" class="headerlink" title="ecrt_domain_queue"></a><code>ecrt_domain_queue</code></h2><ul>
<li>简介：(Re-)将所有域数据报放在主数据报队列中。调用此函数来标记域的数据报，以便在下一次调用<code>ecrt_master_send()</code>时进行交换</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_domain_queue</span><span class="params">(<span class="type">ec_domain_t</span> *domain)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ecrt-master-send"><a href="#ecrt-master-send" class="headerlink" title="ecrt_master_send"></a><code>ecrt_master_send</code></h2><ul>
<li>简介：发送队列中的所有数据报。<ul>
<li>该方法获取所有已排队等待传输的数据报，将它们放入帧中，并将它们传递给以太网设备进行发送。</li>
<li>必须在<code>ecrt_master_activate()</code>返回后由应用程序循环调用。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_send</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ecrt-domain-state"><a href="#ecrt-domain-state" class="headerlink" title="ecrt_domain_state"></a><code>ecrt_domain_state</code></h2><ul>
<li>简介：读取域的状态。<ul>
<li>在给定的\a状态结构中存储域状态。</li>
<li>利用该方法，可以实时监控过程数据交换情况。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_domain_state</span><span class="params">(<span class="type">const</span> <span class="type">ec_domain_t</span> *domain, <span class="type">ec_domain_state_t</span> *state)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>domain</code>  –  域</li>
<li><code>state</code>   –  指向用于存储信息的状态对象的指针。</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-state"><a href="#ecrt-master-state" class="headerlink" title="ecrt_master_state"></a><code>ecrt_master_state</code></h2><ul>
<li>简介：读取当前主站的状态。<ul>
<li>在给定的\a状态结构中存储主站状态。</li>
<li>此方法返回一个全局状态。对于冗余总线拓扑中特定于链路的状态，请使用<code>ecrt_master_link_state()</code>方法。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_state</span><span class="params">(<span class="type">const</span> <span class="type">ec_master_t</span> *master, <span class="type">ec_master_state_t</span> *state)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>master</code>  –  主站</li>
<li><code>state</code>   –  指向用于存储信息的状态对象的指针</li>
</ul>
</li>
</ul>
<h2 id="ecrt-slave-config-state"><a href="#ecrt-slave-config-state" class="headerlink" title="ecrt_slave_config_state"></a><code>ecrt_slave_config_state</code></h2><ul>
<li>简介：输出从站配置的状态。<ul>
<li>在给定的\a状态结构中存储状态信息。状态信息由主状态机更新，因此可能需要几个周期，直到它发生变化。</li>
<li>如果需要实时监控进程数据交换的状态，则应该使用<code>ecrt_domain_state()</code>。</li>
</ul>
</li>
<li>声明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_slave_config_state</span><span class="params">(<span class="type">const</span> <span class="type">ec_slave_config_t</span> *sc, <span class="type">ec_slave_config_state_t</span> *state)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li><code>sc</code>  –  从站配置</li>
<li><code>state</code>  –  需要写入的状态对象</li>
</ul>
</li>
</ul>
<h2 id="ecrt-request-master-1"><a href="#ecrt-request-master-1" class="headerlink" title="ecrt_request_master"></a>ecrt_request_master</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_request_master() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于请求 EtherCAT 主站的实例</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ec_master_t</span>* <span class="title">ecrt_request_master</span><span class="params">(<span class="type">uint32_t</span> master_id)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master_id：一个无符号 32 位整数，表示所请求的 EtherCAT 主站的 ID</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 ec_master_t* 类型的指针，指向请求的 EtherCAT 主站实例。</li>
<li>失败时，返回 NULL</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_request_master() 函数用于请求 EtherCAT 主站的实例，以便后续使用 EtherCAT Master Library 的其他函数进行 EtherCAT 网络的配置和操作。</li>
<li>在调用 ecrt_request_master() 函数之前，需要确保 EtherCAT Master Library 已被正确初始化。</li>
<li>master_id 参数指定所请求的 EtherCAT 主站的 ID。在系统中存在多个 EtherCAT 主站时，可以使用不同的 ID 来区分它们。</li>
<li>请求成功后，将返回指向请求的 EtherCAT 主站实例的指针。通过该指针，可以对 EtherCAT 主站进行配置、管理和操作。</li>
<li>返回的 EtherCAT 主站实例指针将用作其他 EtherCAT Master Library 函数的参数，以标识要操作的 EtherCAT 主站。</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，ecrt_request_master() 函数只是请求 EtherCAT 主站实例的第一步。在使用 EtherCAT Master Library 进行 EtherCAT 网络的配置和操作之前，还需要使用其他函数进行更详细的初始化和配置，如 ecrt_master_open()、ecrt_master_activate() 等函数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-create-domain-1"><a href="#ecrt-master-create-domain-1" class="headerlink" title="ecrt_master_create_domain"></a>ecrt_master_create_domain</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_create_domain() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于创建 EtherCAT 主站的数据域（Domain）</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ec_domain_t</span>* <span class="title">ecrt_master_create_domain</span><span class="params">(<span class="type">ec_master_t</span>* master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向已请求的 EtherCAT 主站实例的 ec_master_t* 类型指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 ec_domain_t* 类型的指针，指向创建的 EtherCAT 数据域（Domain）实例。</li>
<li>失败时，返回 NULL</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_create_domain() 函数用于创建 EtherCAT 主站的数据域，用于管理 EtherCAT 从站设备的数据通信。</li>
<li>在调用 ecrt_master_create_domain() 函数之前，需要先通过 ecrt_request_master() 函数请求 EtherCAT 主站的实例。</li>
<li>参数 master 是指向已请求的 EtherCAT 主站实例的指针，用于指定创建数据域的主站。</li>
<li>创建数据域后，可以使用其他 EtherCAT Master Library 函数来配置和管理数据域，如添加从站设备、映射对象字典、读取和写入数据等。</li>
<li>返回的数据域实例指针将用作其他 EtherCAT Master Library 函数的参数，以标识要操作的数据域</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，ecrt_master_create_domain() 函数只是创建数据域的第一步。在使用数据域进行数据通信之前，还需要使用其他函数进行更详细的配置和映射，如 ecrt_domain_register()、ecrt_domain_queue() 等函数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-slave-config"><a href="#ecrt-master-slave-config" class="headerlink" title="ecrt_master_slave_config"></a>ecrt_master_slave_config</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_slave_config() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于配置 EtherCAT 主站中的从站设备</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ec_slave_config_t</span>* <span class="title">ecrt_master_slave_config</span><span class="params">(<span class="type">ec_master_t</span>* master, <span class="type">uint16_t</span> alias, <span class="type">uint16_t</span> position, <span class="type">uint32_t</span> vendor_id, <span class="type">uint32_t</span> product_code)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向已请求的 EtherCAT 主站实例的 ec_master_t* 类型指针。</li>
<li>alias：一个无符号 16 位整数，表示从站设备的别名（Alias）。</li>
<li>position：一个无符号 16 位整数，表示从站设备的位置（Position）。</li>
<li>vendor_id：一个无符号 32 位整数，表示从站设备的供应商 ID。</li>
<li>product_code：一个无符号 32 位整数，表示从站设备的产品码</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 ec_slave_config_t* 类型的指针，指向配置的从站设备实例。</li>
<li>失败时，返回 NULL</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_slave_config() 函数用于配置 EtherCAT 主站中的从站设备。</li>
<li>在调用 ecrt_master_slave_config() 函数之前，需要先通过 ecrt_request_master() 函数请求 EtherCAT 主站的实例。</li>
<li>参数 master 是指向已请求的 EtherCAT 主站实例的指针，用于指定要配置的主站。</li>
<li>参数 alias 和 position 是从站设备的别名和位置，用于唯一标识从站设备在 EtherCAT 网络中的位置。</li>
<li>参数 vendor_id 和 product_code 是从站设备的供应商 ID 和产品码，用于识别特定的从站设备。</li>
<li>配置从站设备后，可以使用其他 EtherCAT Master Library 函数来访问和操作该设备，如读取和写入从站设备的对象字典数据等。</li>
<li>返回的从站设备实例指针将用作其他 EtherCAT Master Library 函数的参数，以标识要操作的从站设备</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，ecrt_master_slave_config() 函数只是配置从站设备的一部分。在配置从站设备后，还需要使用其他函数进行更详细的初始化和设置，如 ecrt_slave_config_pdos()、ecrt_slave_config_sdo() 等函数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-slave-config-pdos"><a href="#ecrt-slave-config-pdos" class="headerlink" title="ecrt_slave_config_pdos"></a>ecrt_slave_config_pdos</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_slave_config_pdos() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于配置从站设备的过程数据对象（Process Data Objects，PDOs）</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_slave_config_pdos</span><span class="params">(<span class="type">ec_slave_config_t</span>* config, <span class="type">int</span> direction, <span class="type">const</span> <span class="type">ec_pdo_entry_reg_t</span>* entries)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>config：指向已配置的从站设备实例的 ec_slave_config_t* 类型指针。</li>
<li>direction：整数，表示 PDO 的方向。可以是以下值之一<ul>
<li>EC_DIR_OUTPUT：表示输出 PDO。</li>
<li>EC_DIR_INPUT：表示输入 PDO</li>
</ul>
</li>
<li>entries：指向 ec_pdo_entry_reg_t 结构的指针，定义了要配置的 PDO 条目</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回一个负数表示错误码。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_slave_config_pdos() 函数用于配置从站设备的 PDOs，即定义输入和输出数据的结构和格式。</li>
<li>在调用 ecrt_slave_config_pdos() 函数之前，需要先通过 ecrt_master_slave_config() 函数配置从站设备。</li>
<li>参数 config 是指向已配置的从站设备实例的指针，用于指定要配置的从站设备。</li>
<li>参数 direction 指定 PDO 的方向，可以是输出（发送给从站设备）或输入（从从站设备接收）。</li>
<li>参数 entries 是指向 ec_pdo_entry_reg_t 结构的指针，用于定义要配置的 PDO 条目。</li>
<li>ec_pdo_entry_reg_t 结构定义了 PDO 条目的索引、子索引、数据类型、长度等信息，用于描述从站设备的数据结构。</li>
<li>通过调用 ecrt_slave_config_pdos() 函数，可以将 PDO 条目注册到指定的方向上，并配置从站设备的数据通信</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，PDO 的配置涉及到更详细的数据结构和通信配置，如 PDO 映射、PDO 类型、PDO 数据长度等。具体的操作流程和函数使用方式应根据实际需求和 EtherCAT Master Library 的文档进行进一步的学习和了解</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-domain-reg-pdo-entry-list-1"><a href="#ecrt-domain-reg-pdo-entry-list-1" class="headerlink" title="ecrt_domain_reg_pdo_entry_list"></a>ecrt_domain_reg_pdo_entry_list</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_domain_reg_pdo_entry_list() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于在数据域（Domain）中注册 PDO 条目列表</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_domain_reg_pdo_entry_list</span><span class="params">(<span class="type">ec_domain_t</span>* domain, <span class="type">const</span> <span class="type">ec_pdo_entry_reg_t</span>* entries)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>domain：指向已创建的数据域（Domain）实例的 ec_domain_t* 类型指针。</li>
<li>entries：指向 ec_pdo_entry_reg_t 结构的指针，定义了要注册的 PDO 条目列表</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回一个负数表示错误码</li>
</ul>
</li>
<li><p>说明：</p>
<ul>
<li>ecrt_domain_reg_pdo_entry_list() 函数用于在数据域中注册 PDO 条目列表，将 PDO 条目与数据域进行关联。</li>
<li>在调用 ecrt_domain_reg_pdo_entry_list() 函数之前，需要先通过 ecrt_master_create_domain() 函数创建数据域。</li>
<li>参数 domain 是指向已创建的数据域实例的指针，用于指定要注册 PDO 条目的数据域。</li>
<li>参数 entries 是指向 ec_pdo_entry_reg_t 结构的指针，定义了要注册的 PDO 条目列表。</li>
<li>ec_pdo_entry_reg_t 结构定义了 PDO 条目的索引、子索引、数据类型、长度等信息，用于描述从站设备的数据结构。</li>
<li>通过调用 ecrt_domain_reg_pdo_entry_list() 函数，可以将 PDO 条目列表注册到指定的数据域中，以便进行数据通信</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，PDO 条目的注册与数据域的映射和通信相关。在注册 PDO 条目列表后，需要使用其他函数来配置和管理数据域，如 ecrt_domain_queue()、ecrt_domain_state() 等函数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-slave-config-dc"><a href="#ecrt-slave-config-dc" class="headerlink" title="ecrt_slave_config_dc"></a>ecrt_slave_config_dc</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_slave_config_dc() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于配置从站设备的分布式时钟（Distributed Clock）</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_slave_config_dc</span><span class="params">(<span class="type">ec_slave_config_t</span>* config, <span class="type">uint32_t</span> sync0_shift, <span class="type">uint32_t</span> sync1_shift, <span class="type">uint32_t</span> sync0_cycle_time, <span class="type">uint32_t</span> sync1_cycle_time)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>config：指向已配置的从站设备实例的 ec_slave_config_t* 类型指针。</li>
<li>sync0_shift：一个无符号 32 位整数，表示 Sync 0 时钟的相位偏移。</li>
<li>sync1_shift：一个无符号 32 位整数，表示 Sync 1 时钟的相位偏移。</li>
<li>sync0_cycle_time：一个无符号 32 位整数，表示 Sync 0 时钟的周期时间。</li>
<li>sync1_cycle_time：一个无符号 32 位整数，表示 Sync 1 时钟的周期时间</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回一个负数表示错误码</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_slave_config_dc() 函数用于配置从站设备的分布式时钟，以便与 EtherCAT 网络的同步机制进行协调。</li>
<li>在调用 ecrt_slave_config_dc() 函数之前，需要先通过 ecrt_master_slave_config() 函数配置从站设备。</li>
<li>参数 config 是指向已配置的从站设备实例的指针，用于指定要配置的从站设备。</li>
<li>参数 sync0_shift 和 sync1_shift 是用于同步时钟的相位偏移值，以微秒为单位。这些值决定了从站设备与主站之间的同步关系。</li>
<li>参数 sync0_cycle_time 和 sync1_cycle_time 是 Sync 0 和 Sync 1 时钟的周期时间，以纳秒为单位。这些值决定了同步时钟的周期性。</li>
<li>通过调用 ecrt_slave_config_dc() 函数，可以配置从站设备的分布式时钟参数，以确保从站设备在 EtherCAT 网络中的同步性能</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，分布式时钟的配置涉及到与 EtherCAT 网络的同步机制和时钟同步周期的相关设置</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-activate-1"><a href="#ecrt-master-activate-1" class="headerlink" title="ecrt_master_activate"></a>ecrt_master_activate</h2><ul>
<li><p>简介</p>
<ul>
<li>ecrt_master_activate() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于激活 EtherCAT 主站。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_activate</span><span class="params">(<span class="type">ec_master_t</span>* master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向已请求的 EtherCAT 主站实例的 ec_master_t* 类型指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回一个负数表示错误码。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_activate() 函数用于激活 EtherCAT 主站，启动 EtherCAT 网络通信。</li>
<li>在调用 ecrt_master_activate() 函数之前，需要先通过 ecrt_request_master() 函数请求 EtherCAT 主站的实例，并完成主站的配置和初始化。</li>
<li>参数 master 是指向已请求的 EtherCAT 主站实例的指针，用于指定要激活的主站。</li>
<li>激活主站后，可以使用其他 EtherCAT Master Library 函数来访问和操作从站设备，如读取和写入从站设备的对象字典数据等。</li>
<li>主站激活后，开始进行 EtherCAT 网络的实时通信，主站与从站设备之间进行数据交换和同步</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，激活主站是启动 EtherCAT 网络通信的关键步骤。在激活主站之前，需要确保主站的配置和初始化工作已经完成，并且从站设备已经正确配置和连接到 EtherCAT 网络</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-domain-data-1"><a href="#ecrt-domain-data-1" class="headerlink" title="ecrt_domain_data"></a>ecrt_domain_data</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_domain_data() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于获取数据域（Domain）的数据缓冲区指针</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ecrt_domain_data</span><span class="params">(<span class="type">ec_domain_t</span>* domain)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>domain：指向已创建的数据域（Domain）实例的 ec_domain_t* 类型指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回 void* 类型的指针，指向数据域的数据缓冲区</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_domain_data() 函数用于获取数据域的数据缓冲区指针，以便读取和写入数据。</li>
<li>在调用 ecrt_domain_data() 函数之前，需要先通过 ecrt_master_create_domain() 函数创建数据域。</li>
<li>参数 domain 是指向已创建的数据域实例的指针，用于指定要获取数据的数据域。</li>
<li>通过调用 ecrt_domain_data() 函数，可以获取数据域的数据缓冲区指针，从而进行数据的读取和写入。</li>
<li>数据缓冲区的类型取决于数据域的配置，可以是一个数组或结构体，用于存储与从站设备进行通信的数据</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，数据域的数据缓冲区指针可以用于直接读取和写入数据，但在进行数据操作之前，需要确保 EtherCAT 主站已经激活并与从站设备进行通信</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-release-master-1"><a href="#ecrt-release-master-1" class="headerlink" title="ecrt_release_master"></a>ecrt_release_master</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_release_master() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于释放已分配的主站资源</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_release_master</span><span class="params">(<span class="type">ec_master_t</span>* master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向已分配的 EtherCAT 主站实例的 ec_master_t* 类型指针</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_release_master() 函数用于释放已分配的 EtherCAT 主站资源。</li>
<li>在使用 EtherCAT 主站进行通信时，需要先使用 ecrt_request_master() 函数来请求主站资源，并在使用完毕后调用 ecrt_release_master() 函数来释放这些资源。</li>
<li>参数 master 是指向已分配的 EtherCAT 主站实例的指针，用于指定要释放的主站资源。</li>
<li>调用 ecrt_release_master() 函数后，主站资源将被释放，该资源将可用于其他目的。</li>
<li>在释放主站资源之前，应确保已完成所有与从站设备的通信和操作，并确保不再需要使用主站</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，在使用 EtherCAT 主站进行通信时，应始终遵循正确的初始化、配置、通信和释放资源的流程。确保按照 EtherCAT Master Library 的文档和指导进行正确的函数调用和顺序。</li>
</ul>
</li>
</ul>
<h2 id="ecrt-master-application-time-1"><a href="#ecrt-master-application-time-1" class="headerlink" title="ecrt_master_application_time"></a>ecrt_master_application_time</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_application_time() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于设置 EtherCAT 主站的应用程序时间</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_application_time</span><span class="params">(<span class="type">uint64_t</span> cycletime)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>cycletime：以纳秒为单位表示的 EtherCAT 主站的应用程序周期时间</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果设置成功，返回 0。</li>
<li>如果设置失败，返回一个负数，表示错误的原因</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_application_time() 函数用于设置 EtherCAT 主站的应用程序时间，即 EtherCAT 通信的周期时间。</li>
<li>要使用 ecrt_master_application_time() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>cycletime 参数指定 EtherCAT 主站的应用程序周期时间，以纳秒为单位。它定义了 EtherCAT 网络中的数据交换周期。</li>
<li>在 EtherCAT 网络中，所有从站设备都按照相同的应用程序周期时间进行通信。</li>
<li>通过调用 ecrt_master_application_time() 函数，可以设置主站的应用程序周期时间，以确保从站设备之间的同步性。</li>
<li>设置应用程序周期时间后，主站将按照该周期周期性地发送和接收数据，从而实现同步和通信。</li>
<li>返回值为 0 表示设置成功，否则表示设置失败，可以根据返回值进行错误处理</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_master_application_time() 函数进行 EtherCAT 主站的应用程序时间设置时，需要确保对应的 EtherCAT 主站驱动库支持该功能，并且遵循相关的使用要求和限制</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-receive-1"><a href="#ecrt-master-receive-1" class="headerlink" title="ecrt_master_receive"></a>ecrt_master_receive</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_receive() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于接收从站设备发送的数据</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_receive</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向 EtherCAT 主站的指针，表示要接收数据的主站</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果接收数据成功，返回 0。</li>
<li>如果接收数据失败，返回一个负数，表示错误的原因</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_receive() 函数用于从 EtherCAT 主站接收从站设备发送的数据。</li>
<li>要使用 ecrt_master_receive() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>通过调用 ecrt_master_receive() 函数，可以从主站接收数据，并将其存储在主站的内部数据结构中，以供后续处理和访问。</li>
<li>接收的数据通常是从站设备发送的输入数据或状态信息。</li>
<li>ecrt_master_receive() 函数会阻塞当前线程，直到接收到数据或发生错误。</li>
<li>返回值为 0 表示接收数据成功，否则表示接收数据失败，可以根据返回值进行错误处理</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_master_receive() 函数接收从站设备发送的数据时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且在调用该函数之前已经进行了相关的配置和启动操作。具体的使用方法和注意事项，应该根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-domain-process-1"><a href="#ecrt-domain-process-1" class="headerlink" title="ecrt_domain_process"></a>ecrt_domain_process</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_domain_process() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于处理 EtherCAT 领域（Domain）的数据</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_domain_process</span><span class="params">(<span class="type">ec_domain_t</span> *domain)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>domain：指向要处理的 EtherCAT 领域的指针。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果处理成功，返回 0。</li>
<li>如果处理失败，返回一个负数，表示错误的原因。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_domain_process() 函数用于处理 EtherCAT 领域中的数据，即实现从站设备的数据交换。</li>
<li>要使用 ecrt_domain_process() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>通过调用 ecrt_domain_process() 函数，可以将 EtherCAT 领域中的数据发送给从站设备，并从从站设备接收数据。</li>
<li>在 EtherCAT 网络中，一个领域包含了一组 PDO（Process Data Object），每个 PDO 包含了从站设备的输入或输出数据。</li>
<li>调用 ecrt_domain_process() 函数时，主站会将领域中的数据发送到各个从站设备，并等待从站设备发送响应数据。</li>
<li>ecrt_domain_process() 函数会阻塞当前线程，直到数据交换完成或发生错误。</li>
<li>返回值为 0 表示处理成功，否则表示处理失败，可以根据返回值进行错误处理</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_domain_process() 函数处理 EtherCAT 领域的数据时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且 EtherCAT 主站和从站设备已经正确配置和启动。具体的使用方法和注意事项，应该根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-state-1"><a href="#ecrt-master-state-1" class="headerlink" title="ecrt_master_state"></a>ecrt_master_state</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_state() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于获取 EtherCAT 主站的状态信息</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ec_master_state_t</span> <span class="title">ecrt_master_state</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向 EtherCAT 主站的指针，表示要获取状态信息的主站</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>ec_master_state_t 类型的值，表示 EtherCAT 主站的状态信息</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_state() 函数用于获取 EtherCAT 主站的状态信息，如主站是否启动、错误状态等。</li>
<li>要使用 ecrt_master_state() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>通过调用 ecrt_master_state() 函数，可以获取主站的当前状态信息。</li>
<li>返回的 ec_master_state_t 类型的值包含了主站的各种状态信息，如启动状态、错误状态、从站数量等。</li>
<li>ec_master_state_t 是一个结构体，包含了以下成员变量：<ul>
<li>int slaves_responding：应答的从站数量。</li>
<li>int al_states：AL 状态。</li>
<li>int link_up：链路是否连接。</li>
<li>int linking：链路状态。</li>
<li>int operational：主站是否进入操作状态。</li>
<li>int error_flag：错误标志。</li>
<li>int slave_states：从站状态</li>
</ul>
</li>
<li>您可以通过访问返回的 ec_master_state_t 结构体的成员变量来获取各个状态信息。</li>
<li>使用 ecrt_master_state() 函数可以帮助您监控和了解 EtherCAT 主站的状态，以便进行适当的处理和错误处理</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_master_state() 函数获取 EtherCAT 主站状态信息时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且主站已经正确配置和启动。具体的使用方法和注意事项，应根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-slave-config-state-1"><a href="#ecrt-slave-config-state-1" class="headerlink" title="ecrt_slave_config_state"></a>ecrt_slave_config_state</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_slave_config_state() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于获取 EtherCAT 从站配置对象的状态信息</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ec_slave_config_state_t</span> <span class="title">ecrt_slave_config_state</span><span class="params">(<span class="type">ec_slave_config_t</span> *slave_config)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>slave_config：指向 EtherCAT 从站配置对象的指针，表示要获取状态信息的从站配置对象</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>ec_slave_config_state_t 类型的值，表示 EtherCAT 从站配置对象的状态信息</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_slave_config_state() 函数用于获取 EtherCAT 从站配置对象的状态信息，如从站是否应答、错误状态等。</li>
<li>要使用 ecrt_slave_config_state() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>通过调用 ecrt_slave_config_state() 函数，可以获取从站配置对象的当前状态信息。</li>
<li>返回的 ec_slave_config_state_t 类型的值包含了从站配置对象的各种状态信息，如从站是否应答、错误状态、应答延迟等。</li>
<li>ec_slave_config_state_t 是一个结构体，包含了以下成员变量：<ul>
<li>int online：从站是否在线。</li>
<li>int operational：从站是否进入操作状态。</li>
<li>int al_state：从站的 AL 状态。</li>
<li>int state：从站的状态。</li>
<li>int error_flag：错误标志。</li>
<li>int response_delay：应答延迟</li>
</ul>
</li>
<li>您可以通过访问返回的 ec_slave_config_state_t 结构体的成员变量来获取各个状态信息。</li>
<li>使用 ecrt_slave_config_state() 函数可以帮助您监控和了解 EtherCAT 从站配置对象的状态，以便进行适当的处理和错误处理</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_slave_config_state() 函数获取 EtherCAT 从站配置对象状态信息时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且相关的从站配置对象已经正确配置和启动。具体的使用方法和注意事项，应根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-sync-reference-clock-1"><a href="#ecrt-master-sync-reference-clock-1" class="headerlink" title="ecrt_master_sync_reference_clock"></a>ecrt_master_sync_reference_clock</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_sync_reference_clock() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于同步 EtherCAT 主站的参考时钟。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_sync_reference_clock</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向 EtherCAT 主站的指针，表示要同步参考时钟的主站。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_sync_reference_clock() 函数用于同步 EtherCAT 主站的参考时钟，以确保整个 EtherCAT 网络的同步性。</li>
<li>要使用 ecrt_master_sync_reference_clock() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>在 EtherCAT 网络中，参考时钟用于同步主站和从站设备的通信，以保证数据的准确性和一致性。</li>
<li>调用 ecrt_master_sync_reference_clock() 函数时，主站会发送同步命令，从而启动参考时钟的同步过程。</li>
<li>在同步过程中，主站会等待从站设备应答并进行相应的时钟调整，以达到整个网络的同步。</li>
<li>一旦参考时钟同步完成，主站和从站设备之间的通信将在同一时基上进行。</li>
<li>ecrt_master_sync_reference_clock() 函数通常在 EtherCAT 网络启动之前被调用，以确保网络中的设备在通信开始之前具有一致的时钟。</li>
<li>请注意，EtherCAT 网络中的参考时钟同步是非常重要的，因为它直接影响到数据的传输和同步性能</li>
</ul>
</li>
<li><p>注:</p>
<ul>
<li>需要注意的是，使用 ecrt_master_sync_reference_clock() 函数进行参考时钟同步时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且主站和从站设备已经正确配置和启动。具体的使用方法和注意事项，应根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-sync-slave-clocks-1"><a href="#ecrt-master-sync-slave-clocks-1" class="headerlink" title="ecrt_master_sync_slave_clocks"></a>ecrt_master_sync_slave_clocks</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_sync_slave_clocks() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于同步 EtherCAT 从站的时钟</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_master_sync_slave_clocks</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向 EtherCAT 主站的指针，表示要同步从站时钟的主站</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_sync_slave_clocks() 函数用于同步 EtherCAT 主站下所有从站的时钟，以确保整个 EtherCAT 网络中从站设备之间的时钟同步。</li>
<li>要使用 ecrt_master_sync_slave_clocks() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>在 EtherCAT 网络中，从站设备的时钟同步是重要的，以保证数据的传输和同步性能。</li>
<li>调用 ecrt_master_sync_slave_clocks() 函数时，主站会发送同步命令，通知所有从站设备进行时钟调整。</li>
<li>从站设备会根据主站发送的同步命令进行时钟调整，以达到整个网络的同步。</li>
<li>一旦从站时钟同步完成，主站和从站设备之间的通信将在同一时基上进行。</li>
<li>ecrt_master_sync_slave_clocks() 函数通常在 EtherCAT 网络启动之前被调用，以确保网络中的所有从站设备在通信开始之前具有一致的时钟。</li>
<li>请注意，EtherCAT 网络中从站的时钟同步对于数据的传输和同步性能非常重要</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_master_sync_slave_clocks() 函数进行从站时钟同步时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且主站和从站设备已经正确配置和启动。具体的使用方法和注意事项，应根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-domain-queue-1"><a href="#ecrt-domain-queue-1" class="headerlink" title="ecrt_domain_queue"></a>ecrt_domain_queue</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_domain_queue() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于将数据写入 EtherCAT 数据域（Domain）</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ecrt_domain_queue</span><span class="params">(<span class="type">ec_domain_t</span> *domain)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>domain：指向 EtherCAT 数据域（Domain）的指针，表示要将数据写入的数据域</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_domain_queue() 函数用于将数据写入 EtherCAT 数据域，以进行数据传输和同步。</li>
<li>要使用 ecrt_domain_queue() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>EtherCAT 数据域是用于存储和传输与从站设备通信的数据的内存区域。</li>
<li>通过调用 ecrt_domain_queue() 函数，可以将待发送的数据放入数据域中，以待发送到从站设备。</li>
<li>调用 ecrt_domain_queue() 函数后，数据将进入数据域的发送队列，等待适当的时间点发送到从站设备。</li>
<li>一旦数据被发送到从站设备，从站设备将读取并处理这些数据，以进行数据交换和通信。</li>
<li>使用 ecrt_domain_queue() 函数可以实现周期性的数据传输和同步，以满足实时控制系统的要求</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_domain_queue() 函数进行数据域写入时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且相关的数据域已经正确配置和启动。具体的使用方法和注意事项，应根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ecrt-master-send-1"><a href="#ecrt-master-send-1" class="headerlink" title="ecrt_master_send"></a>ecrt_master_send</h2><ul>
<li><p>简介：</p>
<ul>
<li>ecrt_master_send() 是 EtherCAT 主站驱动库（EtherCAT Master Library）中的一个函数，用于发送数据到 EtherCAT 从站设备。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ethercat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ecrt_master_send</span><span class="params">(<span class="type">ec_master_t</span> *master)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>master：指向 EtherCAT 主站的指针，表示要发送数据的主站</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>ecrt_master_send() 函数返回一个整数值，表示发送操作的结果。通常情况下，0 表示成功，负数表示失败</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>ecrt_master_send() 函数用于向 EtherCAT 从站设备发送数据，以进行数据传输和通信。</li>
<li>要使用 ecrt_master_send() 函数，需要包含头文件 &lt;ethercat.h&gt;。</li>
<li>在 EtherCAT 网络中，主站负责向从站设备发送数据，并处理从站设备的应答。</li>
<li>通过调用 ecrt_master_send() 函数，可以触发主站向从站设备发送先前通过 ecrt_domain_queue() 函数放置在数据域中的数据。</li>
<li>当调用 ecrt_master_send() 函数时，主站将按照预定的通信周期发送数据到从站设备。</li>
<li>ecrt_master_send() 函数会阻塞主线程，直到发送操作完成或发生错误。</li>
<li>发送操作完成后，可以通过调用 ecrt_master_state() 函数来检查发送的结果状态</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 ecrt_master_send() 函数发送数据时，需要确保 EtherCAT 主站驱动库已经成功初始化，并且相关的数据域已经正确配置和启动。具体的使用方法和注意事项，应根据您所使用的 EtherCAT 主站驱动库的文档和示例进行适当的调整和使用</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/GitHub/2024-05-22-Github/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/GitHub/2024-05-22-Github/" class="post-title-link" itemprop="url">Github</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GitHub/" itemprop="url" rel="index"><span itemprop="name">GitHub</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>github 平台使用</li>
</ul>
<h2 id="使用https"><a href="#使用https" class="headerlink" title="使用https"></a>使用https</h2><ul>
<li><p>清除所有的git配置</p>
<ul>
<li>sudo aptitude purge git</li>
</ul>
</li>
<li><p>在github生成token，它具有访问项目的权限</p>
</li>
<li><p>安装gh工具</p>
<ul>
<li>sudo apt install gh</li>
</ul>
</li>
<li><p>配置个人信息</p>
<ul>
<li>gh auth login</li>
<li>username: </li>
<li>token</li>
</ul>
</li>
<li><p>git使用https</p>
</li>
</ul>
<h2 id="git-clone-出错"><a href="#git-clone-出错" class="headerlink" title="git clone 出错"></a>git clone 出错</h2><ul>
<li>今天克隆GitHub仓库中的项目时，执行git clone git:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;Tangram-Android.git却失败报错：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &#x27;Tangram-Android&#x27;...</span><br><span class="line">fatal: unable to access &#x27;http://github.com/alibaba/Tangram-Android.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure></li>
<li>解决方法，需要执行以下两个步骤：<ul>
<li>输入git config –global http.sslVerify “false”，解除SSL验证；</li>
<li>将地址https:&#x2F;&#x2F;改为git:&#x2F;&#x2F;，避开SSL验证。</li>
</ul>
</li>
</ul>
<h2 id="git连接到github远程仓库，并提交代码至远程仓库"><a href="#git连接到github远程仓库，并提交代码至远程仓库" class="headerlink" title="git连接到github远程仓库，并提交代码至远程仓库"></a>git连接到github远程仓库，并提交代码至远程仓库</h2><ul>
<li><p>设置用户名和邮箱</p>
<ul>
<li><code>git config --global user.name &quot;elliot53&quot;</code></li>
<li><code>git config --global user.email &quot;1604244855@qq.com&quot;</code></li>
</ul>
</li>
<li><p>查看配置的用户名和邮箱</p>
<ul>
<li><code>git config user.name</code></li>
<li><code>git config user.email</code></li>
</ul>
</li>
<li><p>生成SSH Key密钥</p>
<ul>
<li><code>ssh-keygen -t rsa -C &quot;1604244855@qq.com&quot;</code></li>
<li>连续按下三次回车，密钥会在第一次回车的时候，输出密钥文件将要保存的位置</li>
</ul>
</li>
<li><p>获取SSH Key密钥</p>
<ul>
<li><code>cat /root/.ssh/rsa.pub</code></li>
<li>选中并复制全部密钥（ssh-rsa开始，一直到.com结束）</li>
</ul>
</li>
<li><p>配置github密钥</p>
<ul>
<li>打开github-settings</li>
<li>选择SSH and GPG keys</li>
<li>点击New SSH key </li>
<li>填入title和key</li>
</ul>
</li>
<li><p>在本地仓库配置远程仓库地址，本地仓库链接远程仓库</p>
<ul>
<li>复制远程仓库的ssh地址</li>
<li><code>git remote add origin_ssh ssh@github.com/elliot53/notes.git</code></li>
</ul>
</li>
<li><p>测试链接是否成功</p>
<ul>
<li><code>ssh -T git@github.com</code></li>
</ul>
</li>
<li><p>脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;elliot53&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;1604244855@qq.com&quot;</span></span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;1604244855@qq.com&quot;</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br><span class="line">git remote add origin_ssh ssh@github.com/elliot53/notes.git</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="什么是GitHub-Actions"><a href="#什么是GitHub-Actions" class="headerlink" title="什么是GitHub Actions"></a>什么是GitHub Actions</h2><ul>
<li><p>一个简单的需求，是在仓库出现更改时自动更新构建与部署博客。其实，监视仓库并在由改动时自动执行一系列动作是非常广泛的需求。软件开发工作中，经常需要对新添加的代码随时进行测试，或者进行部署，都是通过这样的自动化流程实现的。</p>
</li>
<li><p>实际上，这类服务还有个专业名词: 持续集成(Continuous Intergration)&#x2F;持续部署(Continuous Deploy)，简称CI&#x2F;CD</p>
</li>
<li><p>此前，最广泛使用的CI服务当属于Travis CI;现在GitHub也推出了自家的CI服务GitHub Actions。</p>
</li>
<li><p>当仓库收到新的更新(push)时,GitHub会根据仓库中.github&#x2F;workflows文件夹下的YAML配置文件启动CI流程</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Logger/2024-05-22-glog_log4cpluc_spdlog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Logger/2024-05-22-glog_log4cpluc_spdlog/" class="post-title-link" itemprop="url">glog_log4cpluc_spdlog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Logger/" itemprop="url" rel="index"><span itemprop="name">Logger</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>深入探讨三个流行的C++日志库： glog, log4cplug, spdlog</li>
<li>glog、log4cplus 和 spdlog，这三个日志库各有千秋，它们在性能、功能和易用性方面都有各自的优势</li>
<li>探讨它们如何处理日志滚动、如何配置日志清理策略，以及如何实现自定义的日志管理策略</li>
</ul>
<h2 id="glog-日志库"><a href="#glog-日志库" class="headerlink" title="glog 日志库"></a>glog 日志库</h2><ul>
<li><p>glog，即Google Logging Library，是由Google开发的一款高效的日志库，广泛应用于C++项目中。它提供了丰富的日志记录功能，包括日志级别、条件日志、日志滚动等。</p>
</li>
<li><p>glog 是一个为了满足高性能需求而设计的日志库，它支持多线程环境，能够在不同的日志级别上打印信息，并且支持日志滚动。日志滚动是一种常见的日志管理策略，用于防止日志文件无限制地增长，占用过多的磁盘空间</p>
</li>
<li><p>glog 支持基于文件大小的日志滚动。当日志文件达到预设的大小限制时，glog 会自动将当前日志文件重命名为备份文件，并创建一个新的日志文件继续写入。这个过程是自动的，对程序运行无影响。</p>
</li>
<li><p>虽然 glog 支持日志滚动，但它并不直接提供日志清理的功能。这意味着随着时间的推移，日志文件会不断累积，可能会占用大量的磁盘空间。为了解决这个问题，你可能需要依赖外部工具或者自己编写脚本来定期清理旧的日志文件。</p>
</li>
<li><p>虽然 glog 本身不提供日志清理的功能，但你可以通过实现自定义的清理策略来管理日志文件。这通常涉及到文件系统操作，如检查文件的创建时间、大小等属性，然后根据你的清理策略删除旧的日志文件</p>
</li>
</ul>
<h2 id="log4cplus"><a href="#log4cplus" class="headerlink" title="log4cplus"></a>log4cplus</h2><ul>
<li><p>log4cplus 是一个灵活且易于使用的日志库，它提供了丰富的日志记录功能，包括日志级别、日志格式化、日志滚动和日志清理等。它的设计哲学是使日志记录尽可能地简单而不失灵活性</p>
</li>
<li><p>log4cplus 提供了多种日志滚动策略，包括基于文件大小的滚动 (RollingFileAppender) 和基于时间的滚动 (DailyRollingFileAppender 和 TimeBasedRollingFileAppender)</p>
</li>
<li><p>RollingFileAppender 允许日志文件在达到指定大小时滚动。你可以配置 MaxFileSize 和 MaxBackupIndex 来控制日志文件的最大大小和备份文件的数量。</p>
</li>
<li><p>DailyRollingFileAppender 和 TimeBasedRollingFileAppender 提供了基于时间的日志滚动策略，允许你按照每天或者更精细的时间间隔来滚动日志文件。</p>
</li>
<li><p>log4cplus 的日志清理策略通常与日志滚动策略结合使用。通过配置 MaxBackupIndex，你可以限制保留的备份文件数量，从而实现基于文件个数的日志清理</p>
</li>
<li><p>然而，log4cplus 不直接提供基于时间的日志清理策略。如果你需要根据日志文件的创建时间或最后修改时间来清理日志，你可能需要实现自定义的 Appender 或者使用外部工具</p>
</li>
<li><p>log4cplus 支持通过 XML 或 properties 文件来配置日志管理策略，这使得你可以在不修改代码的情况下调整日志行为</p>
</li>
<li><p>如果 log4cplus 提供的日志管理策略不能满足你的需求，你可以通过继承 Appender 类来实现自定义的日志清理策略。</p>
</li>
<li><p>你需要重写 append() 方法，在这里实现你的日志清理逻辑。例如，你可以检查日志文件的创建时间或大小，并在达到一定条件时删除旧的日志文件</p>
</li>
</ul>
<h2 id="spdlog"><a href="#spdlog" class="headerlink" title="spdlog"></a>spdlog</h2><ul>
<li>spdlog 是一个快速、轻量级的日志库，它支持多线程、异步日志记录。它的设计哲学是“快速和简单”，旨在提供一个直观而强大的日志记录工具</li>
<li>spdlog 提供了多种日志滚动策略，包括按大小滚动和按时间滚动。</li>
<li>这种滚动策略会在日志文件达到一定大小时滚动日志。你可以配置 max_size 和 max_files 来控制日志文件的最大总大小和保留的日志文件的最大数量。</li>
<li>这种滚动策略会在每天的某个特定时间滚动日志。你可以配置 rotation_hour 和 rotation_minute 来决定每天滚动日志的时间。</li>
<li>spdlog 的配置通常是通过代码进行的，你需要在代码中创建和配置 Logger 和 Sink。</li>
<li>虽然 spdlog 提供了一些内置的滚动策略，但你也可以实现自己的 Sink 来实现自定义的清理策略</li>
</ul>
<h2 id="比较和总结-Comparison-and-Conclusion"><a href="#比较和总结-Comparison-and-Conclusion" class="headerlink" title="比较和总结 (Comparison and Conclusion)"></a>比较和总结 (Comparison and Conclusion)</h2><h3 id="性能比较-Performance-Comparison"><a href="#性能比较-Performance-Comparison" class="headerlink" title="性能比较 (Performance Comparison)"></a>性能比较 (Performance Comparison)</h3><ul>
<li><p>在性能方面，spdlog 通常被认为是最快的，因为它是为高性能而设计的，支持异步日志记录。glog 和 log4cplus 的性能也不错，但通常略低于 spdlog</p>
</li>
<li><p>glog：虽然 glog 提供了丰富的功能和灵活的配置，但这也使得它在性能上有所牺牲。特别是在高并发的环境下，glog 的性能可能会受到影响。</p>
</li>
<li><p>log4cplus：log4cplus 提供了更丰富的功能，包括多种 Appender 和 Layout，但这也意味着更多的性能开销。尽管如此，对于大多数应用来说，这种性能差异是可以接受的。</p>
</li>
<li><p>spdlog：spdlog 是专为高性能设计的，支持异步日志记录，能够在高并发环境下提供极高的日志记录性能。</p>
</li>
</ul>
<h3 id="功能比较-Feature-Comparison"><a href="#功能比较-Feature-Comparison" class="headerlink" title="功能比较 (Feature Comparison)"></a>功能比较 (Feature Comparison)</h3><ul>
<li><p>在功能方面，log4cplus 提供了最丰富的特性，包括多种 Appender、Layout 和日志滚动策略。glog 和 spdlog 在功能上略有不足，但仍然能满足大多数日志记录需求。</p>
</li>
<li><p>glog：提供基本的日志记录功能，支持按大小滚动日志，但在日志清理和滚动策略方面略显不足。</p>
</li>
<li><p>log4cplus：提供最丰富的功能和配置选项，支持多种日志滚动和清理策略，是功能最全面的选择。</p>
</li>
<li><p>spdlog：虽然在功能上不如 log4cplus 丰富，但 spdlog 提供了高性能的异步日志记录功能，非常适合性能敏感的应用。</p>
</li>
</ul>
<h3 id="使用场景建议-Usage-Scenario-Recommendations"><a href="#使用场景建议-Usage-Scenario-Recommendations" class="headerlink" title="使用场景建议 (Usage Scenario Recommendations)"></a>使用场景建议 (Usage Scenario Recommendations)</h3><ul>
<li>glog：适用于需要简单、高效日志记录的场景，特别是在 Google 的生态系统中。</li>
<li>log4cplus：适用于需要丰富功能和灵活配置的企业级应用，尤其是在需要复杂日志管理策略的场景。</li>
<li>spdlog：适用于性能敏感、需要高速日志记录的应用，如游戏、高频交易等。</li>
</ul>
<h3 id="总结-Conclusion"><a href="#总结-Conclusion" class="headerlink" title="总结 (Conclusion)"></a>总结 (Conclusion)</h3><ul>
<li>选择合适的日志库对于确保应用程序的稳定性和性能至关重要。glog、log4cplus 和 spdlog 都是优秀的 C++ 日志库，各有其优势和应用场景。通过本文的比较和分析，希望读者能够根据自己的具体需求，做出明智的选择。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/JSON/2024-05-22-json_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/JSON/2024-05-22-json_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">json_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JSON/" itemprop="url" rel="index"><span itemprop="name">JSON</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>JSON，指的是JavaScript对象表示法(JavaScript Object Notation)</li>
<li>JSON是轻量级的文本数据交换格式</li>
<li>JSON独立于语言，JSON使用Javascript语法来描述数据对象，但是JSON仍然独立于语言和平台。JSON解析器和JSON库支持许多种不同的编程语言。目前非常多的动态编程语言都支持JSON</li>
<li>JSON具有自我描述性，更容易理解</li>
</ul>
<h2 id="与XML相同之处"><a href="#与XML相同之处" class="headerlink" title="与XML相同之处"></a>与XML相同之处</h2><ul>
<li>JSON和XML都用于接收Web服务端的数据</li>
<li>JSON是纯文本</li>
<li>JSON具有自我描述性（人类可读）</li>
<li>JSON具有层级结构（值中存在值）</li>
<li>JSON可通过JavaScript进行解析</li>
<li>JSON数据可使用AJAX进行传输</li>
</ul>
<h2 id="JSON语法规则"><a href="#JSON语法规则" class="headerlink" title="JSON语法规则"></a>JSON语法规则</h2><ul>
<li><p>JSON语法是JavaScript对象表示语法的子集</p>
</li>
<li><p>数据在名称&#x2F;值对中</p>
</li>
<li><p>数据由逗号<code>,</code>分隔</p>
</li>
<li><p>使用斜杠<code>\</code>来转义字符</p>
</li>
<li><p>大括号<code>&#123;&#125;</code>保存对象</p>
</li>
<li><p>中括号<code>[]</code>保存数组，数组可以包含多个对象</p>
</li>
<li><p>JSON的两种结构</p>
<ul>
<li>对象：大括号<code>&#123;&#125;</code>保存的对象是一个无序的名称&#x2F;值对集合。一个对象以左括号<code>&#123;</code>开始，右括号<code>&#125;</code>结束。每个键后跟一个冒号<code>:</code>，名称&#x2F;值对使用逗号<code>,</code>分隔。</li>
<li>数组：中括号<code>[]</code>保存的数组是值(value)的有序集合。一个数组以左中括号<code>[</code>开始，右中括号<code>]</code>结束，值之间使用逗号<code>,</code>分隔。值(value)可以是双引号括起来的字符串，数值，true, false, null, 对象或者数组，它们是可以嵌套的</li>
</ul>
</li>
</ul>
<h2 id="JSON名称-值对"><a href="#JSON名称-值对" class="headerlink" title="JSON名称&#x2F;值对"></a>JSON名称&#x2F;值对</h2><ul>
<li>JSON数据的书写格式是:<code>key:value</code></li>
<li>名称&#x2F;值对包括字段名称（在双引号中），后面写一个冒号，然后值：<code>&quot;name&quot;:&quot;abc&quot;</code>，等价于JavaScript语句：<code>name = &quot;abc&quot;</code></li>
</ul>
<h2 id="C-处理JSON的开源库"><a href="#C-处理JSON的开源库" class="headerlink" title="C++处理JSON的开源库"></a>C++处理JSON的开源库</h2><p>在C++中，有多个流行的库可以用于处理JSON数据。以下是一些常用的C++ JSON处理库：</p>
<ol>
<li><p><strong>RapidJSON</strong>: RapidJSON是一个高性能的JSON解析和生成库，提供了灵活的API和丰富的功能。它具有快速的解析速度和低内存占用，并支持DOM和SAX风格的API。</p>
</li>
<li><p><strong>jsoncpp</strong>: jsoncpp是一个简单易用的C++ JSON库，提供了方便的API用于解析和生成JSON数据。它支持将JSON数据与C++对象进行相互转换，并提供了灵活的配置选项。</p>
</li>
<li><p><strong>nlohmann&#x2F;json</strong>: nlohmann&#x2F;json是一个现代化的C++ JSON库，具有简单易用的API和高性能。它支持以类似于JavaScript的方式访问和操作JSON数据，并提供了方便的函数和操作符用于序列化和反序列化。</p>
</li>
</ol>
<p>这些库都是开源库，可以从它们的官方网站或代码托管平台获取源代码和使用文档。你可以选择适合你项目需求和编程风格的库来处理JSON数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8%E5%AD%A6/" class="post-title-link" itemprop="url">刚体运动学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>刚体运动学相关笔记</li>
</ul>
<h2 id="刚体运动学是什么"><a href="#刚体运动学是什么" class="headerlink" title="刚体运动学是什么"></a>刚体运动学是什么</h2><p>刚体运动学是研究刚体在空间中的运动和位置的学科。刚体是一个在运动过程中不发生形变的物体，即它的各个点在运动中相对位置不变。刚体运动学主要关注刚体的平动（直线运动）和转动（绕轴旋转）。</p>
<p>以下是刚体运动学的一些关键概念：</p>
<ol>
<li><p><strong>平动（Translation）：</strong> 刚体的平动是指整个刚体保持平行于自身的情况下沿直线运动。平动的描述通常涉及到刚体的质心、速度和加速度。</p>
</li>
<li><p><strong>转动（Rotation）：</strong> 刚体的转动是指刚体绕轴旋转。转动的描述通常包括角度、角速度和角加速度。刚体的转动可以是绕固定轴或绕刚体自身的质心轴。</p>
</li>
<li><p><strong>刚体的位姿（Pose）：</strong> 描述刚体在空间中的位置和姿态。通常用平移矢量（描述位置）和旋转矩阵或四元数（描述姿态）来表示。</p>
</li>
<li><p><strong>刚体的速度（Velocity）：</strong> 描述刚体各点在运动中的速度。对于平动，速度是常矢量；对于转动，速度是角速度矢量。</p>
</li>
<li><p><strong>刚体的加速度（Acceleration）：</strong> 描述刚体各点在运动中的加速度。对于平动，加速度是常矢量；对于转动，加速度是角加速度矢量。</p>
</li>
<li><p><strong>刚体的运动学方程（Equations of Motion）：</strong> 这是一组描述刚体运动的方程，通常涉及刚体的位姿、速度和加速度。</p>
</li>
<li><p><strong>刚体坐标系（Body-fixed Coordinate System）：</strong> 用于描述刚体运动的坐标系，通常固定在刚体上。刚体坐标系的选择对于简化运动学方程很有帮助。</p>
</li>
<li><p><strong>欧拉角（Euler Angles）：</strong> 一种描述刚体旋转的方法，使用三个角度来表示刚体的姿态。</p>
</li>
</ol>
<p>刚体运动学在机器人学、航空航天、机械工程、计算机图形学等领域都有着广泛的应用。在这些领域，研究刚体运动学有助于理解和控制物体在三维空间中的运动。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E5%BE%AE%E7%A7%AF%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E5%BE%AE%E7%A7%AF%E5%88%86/" class="post-title-link" itemprop="url">微积分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>微积分相关笔记</li>
</ul>
<h2 id="微积分是什么"><a href="#微积分是什么" class="headerlink" title="微积分是什么"></a>微积分是什么</h2><p>微积分是数学的一个分支，研究函数的变化率和积分。它由微分学和积分学两部分组成，两者是互相联系的。微积分在自然科学、工程学、计算机科学等领域中有着广泛的应用。</p>
<p>以下是微积分的主要概念：</p>
<ol>
<li><p><strong>导数（Derivative）：</strong> 导数表示函数在某一点的变化率，即函数在这一点的斜率。对于函数 (y &#x3D; f(x))，其导数通常表示为 (f’(x)) 或 (\frac{dy}{dx})。</p>
</li>
<li><p><strong>微分（Differential）：</strong> 微分是导数的一种近似，它描述函数在某一点附近的局部线性变化。微分可以用于近似计算函数在某一点的变化。</p>
</li>
<li><p><strong>积分（Integration）：</strong> 积分是导数的逆运算，表示函数的累积变化量。对于函数 (y &#x3D; f(x))，其积分通常表示为 (\int f(x) , dx)，表示 (f(x)) 关于 (x) 的积累总和。</p>
</li>
<li><p><strong>不定积分和定积分（Indefinite and Definite Integrals）：</strong> 不定积分是对函数积分得到的结果，带有一个积分常数；定积分是对函数在一个区间上的积分，表示函数在该区间上的总变化。</p>
</li>
<li><p><strong>微分方程（Differential Equations）：</strong> 微分方程描述了一个或多个未知函数及其导数之间的关系，是许多科学和工程问题的数学模型。</p>
</li>
<li><p><strong>链式法则、乘积法则和商法则（Chain Rule, Product Rule, Quotient Rule）：</strong> 这些是导数计算中的常用规则，用于计算复合函数、乘积和商的导数。</p>
</li>
<li><p><strong>定积分的应用（Applications of Definite Integrals）：</strong> 定积分在计算面积、弧长、体积、质心等方面有着广泛的应用。</p>
</li>
</ol>
<p>微积分为了解变化和量的累积提供了一种强大的工具，使得我们能够理解和分析函数的性质，并解决实际问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">优化理论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>优化理论相关笔记</li>
</ul>
<h2 id="优化理论是什么"><a href="#优化理论是什么" class="headerlink" title="优化理论是什么"></a>优化理论是什么</h2><p>优化理论是数学的一个分支，研究如何找到最佳解决方案的方法，以满足特定的目标和约束条件。在优化问题中，通常需要在给定的一组可行解中找到最优解，使得某个目标函数取得最大值或最小值。</p>
<p>以下是优化理论的一些关键概念：</p>
<ol>
<li><p><strong>目标函数（Objective Function）：</strong> 优化问题的目标是通过最小化或最大化一个目标函数来找到最佳解。目标函数通常表示为一组变量的函数。</p>
</li>
<li><p><strong>约束条件（Constraint）：</strong> 优化问题通常伴随一些约束条件，这些条件限制了变量的取值范围。优化的解决方案必须满足这些约束。</p>
</li>
<li><p><strong>最优解（Optimal Solution）：</strong> 最优解是在满足约束条件下，使目标函数取得最小值或最大值的解决方案。</p>
</li>
<li><p><strong>局部最优解和全局最优解（Local Optimum and Global Optimum）：</strong> 局部最优解是在某一邻域内为最优的解，而全局最优解是在整个解空间中为最优的解。</p>
</li>
<li><p><strong>线性规划（Linear Programming）：</strong> 一类优化问题，其中目标函数和约束条件都是线性的。线性规划在工程、经济学、运筹学等领域有广泛应用。</p>
</li>
<li><p><strong>非线性优化（Nonlinear Optimization）：</strong> 优化问题中目标函数或约束条件是非线性的。非线性优化方法用于解决这类问题，如牛顿法、梯度下降等。</p>
</li>
<li><p><strong>整数规划（Integer Programming）：</strong> 一类优化问题，其中变量被限制为整数值。整数规划在组合优化、资源分配等方面有应用。</p>
</li>
<li><p><strong>凸优化（Convex Optimization）：</strong> 一类特殊的优化问题，其中目标函数和约束条件都是凸函数。凸优化问题具有良好的性质，可以使用高效的算法求解。</p>
</li>
<li><p><strong>多目标优化（Multi-objective Optimization）：</strong> 在一个优化问题中有多个目标函数，需要找到一个平衡的解决方案。</p>
</li>
<li><p><strong>全局优化（Global Optimization）：</strong> 寻找整个解空间中的全局最优解，而不仅仅是局部最优解。</p>
</li>
</ol>
<p>优化理论在工程、经济学、运筹学、机器学习等领域都有广泛应用，它提供了一系列方法来解决复杂的决策和设计问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">数值分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>数值分析相关笔记</li>
</ul>
<h2 id="数值分析是什么"><a href="#数值分析是什么" class="headerlink" title="数值分析是什么"></a>数值分析是什么</h2><p>数值分析是数学的一个分支，研究使用数值计算方法解决数学问题的理论和算法。它主要涉及到通过计算机进行近似数值解的技术，尤其是在那些无法或难以通过解析方法得到精确解的问题上。数值分析在科学、工程、计算机科学等领域都有广泛的应用。</p>
<p>以下是数值分析的主要内容和概念：</p>
<ol>
<li><p><strong>数值逼近（Numerical Approximation）：</strong> 研究如何使用有限的计算资源来获得数学问题的近似解。这包括插值、拟合、级数展开等方法。</p>
</li>
<li><p><strong>数值解法（Numerical Methods）：</strong> 开发和分析通过计算机进行数值计算的算法，解决代数方程组、微分方程、积分等问题。常见的数值解法包括牛顿法、迭代法、龙格-库塔法等。</p>
</li>
<li><p><strong>误差分析（Error Analysis）：</strong> 研究数值计算中产生的误差，包括截断误差和舍入误差。误差分析有助于评估数值算法的准确性和稳定性。</p>
</li>
<li><p><strong>插值和拟合（Interpolation and Curve Fitting）：</strong> 插值方法用于估算在已知数据点之间的值，而拟合方法用于找到最佳拟合曲线或曲面。</p>
</li>
<li><p><strong>数值积分（Numerical Integration）：</strong> 使用数值方法计算函数在区间上的积分，例如通过数值方法计算定积分的近似值。</p>
</li>
<li><p><strong>数值微分（Numerical Differentiation）：</strong> 使用数值方法计算函数在某点的导数，尤其是在没有解析导数表达式的情况下。</p>
</li>
<li><p><strong>迭代法（Iterative Methods）：</strong> 通过反复迭代更新来逼近函数的解，是求解非线性方程、线性方程组等问题的常见方法。</p>
</li>
<li><p><strong>最优化方法（Optimization Methods）：</strong> 研究在给定约束下找到函数的最大值或最小值的数值方法。</p>
</li>
</ol>
<p>数值分析的应用非常广泛，包括工程设计、科学模拟、金融建模、图像处理、数据分析等领域。在这些领域，数值分析为复杂问题提供了有效的、可计算的解决方案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/" class="post-title-link" itemprop="url">平面几何</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>平面几何相关笔记</li>
</ul>
<h2 id="平面几何教材"><a href="#平面几何教材" class="headerlink" title="平面几何教材"></a>平面几何教材</h2><p>平面几何是几何学的一个分支，涉及二维空间内的点、线、面及其相互关系。以下是一些常见的平面几何教材，它们可能是针对不同年级和水平的学生：</p>
<ol>
<li><p>《高中数学（必修）：平面几何》 - 这是中国高中数学课程中常见的一本教材，涵盖了平面几何的基本概念、定理和解题方法。</p>
</li>
<li><p>《几何学原理》（Geometry: Euclid and Beyond）- 作者：Robin Hartshorne。这本书着重介绍了古典欧几里得几何，并深入讨论了几何学的一些高级主题，适合对几何学有深入兴趣的学生。</p>
</li>
<li><p>《平面几何学》（Plane Geometry）- 作者：George E. Martin。这本书通常作为大学本科阶段的平面几何学教材，内容涵盖了基本的几何学原理和证明方法。</p>
</li>
<li><p>《几何学》（Geometry）- 作者：David A. Brannan、Matthew F. Esplen、Jeremy J. Gray。这本书提供了一个广泛的几何学概述，适合高中或大学水平的学生，内容包括平面几何和立体几何。</p>
</li>
<li><p>《高中几何》（High School Geometry）- 作者：Jurgensen、Charles、Dolley。这是一本适用于高中学生的教材，涵盖了基本的平面几何概念和定理。</p>
</li>
</ol>
<p>请注意，教材的选择可能会根据学生的年级、水平和教学要求而有所不同。建议查看学校或课程的具体教学大纲，以选择最适合的教材。</p>
<h2 id="平面几何是什么"><a href="#平面几何是什么" class="headerlink" title="平面几何是什么"></a>平面几何是什么</h2><p>平面几何是几何学的一个分支，主要研究在一个平面上的几何关系和性质。在平面几何中，研究的对象包括点、直线、多边形、圆等在平面上的性质和相互关系。平面几何是欧几里德几何的一个主要组成部分，起源于古希腊的数学研究。</p>
<p>关键概念和主题包括：</p>
<ol>
<li><p><strong>点（Point）：</strong> 平面上的位置，用坐标 ( (x, y) ) 表示。</p>
</li>
<li><p><strong>直线（Line）：</strong> 无数个点的集合，可以用方程或者参数方程表示。</p>
</li>
<li><p><strong>线段（Segment）：</strong> 直线上两个点之间的部分。</p>
</li>
<li><p><strong>射线（Ray）：</strong> 一条起始于一个点并延伸到无穷远的直线上的部分。</p>
</li>
<li><p><strong>角（Angle）：</strong> 由两条射线或线段的夹角形成，通常用度数或弧度来度量。</p>
</li>
<li><p><strong>多边形（Polygon）：</strong> 由一系列连续的线段组成的封闭图形，如三角形、四边形等。</p>
</li>
<li><p><strong>圆（Circle）：</strong> 平面上所有到圆心的距离都相等的点的集合。</p>
</li>
</ol>
<p>平面几何的研究通常涉及基本的几何定理、公理和构造方法，以及通过这些基本概念推导出的各种性质。平面几何不仅是纯数学的一部分，而且在工程、建筑、计算机图形学等应用领域中有着广泛的应用。</p>
<h2 id="数学-平面几何-法向量是什么"><a href="#数学-平面几何-法向量是什么" class="headerlink" title="数学 平面几何 法向量是什么"></a>数学 平面几何 法向量是什么</h2><p>在平面几何中，一个平面的法向量是与该平面垂直的一个向量。法向量是描述平面方向和垂直性质的重要工具。</p>
<p>设平面的方程为 (ax + by + cz &#x3D; d)，其中 (a, b, c) 是平面的法向量的分量，而 (d) 是一个常数。法向量通常表示为<br>$$<br>\mathbf{N} &#x3D; \langle a, b, c \rangle<br>$$<br>。</p>
<p>平面的法向量具有以下性质：</p>
<ol>
<li>法向量与平面上的任意向量的点积为零，即<br>$$<br>\mathbf{N} \cdot \mathbf{V} &#x3D; 0<br>$$<br>，其中<br>$$<br>\mathbf{V}<br>$$<br>是平面上的一个向量。</li>
<li>法向量的方向与平面的法线方向一致。</li>
<li>法向量的长度表示平面到原点的距离，可以通过公式<br>$$<br>\frac{|d|}{\sqrt{a^2 + b^2 + c^2}}<br>$$<br>计算。</li>
</ol>
<p>法向量在平面几何中有多种应用，包括判断两平面的关系、求解平面的交点、计算平面的夹角等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">控制理论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>控制理论相关笔记</li>
</ul>
<h2 id="控制理论是什么"><a href="#控制理论是什么" class="headerlink" title="控制理论是什么"></a>控制理论是什么</h2><p>控制理论是研究如何设计并分析动态系统的一门工程和数学学科。它涉及系统的建模、分析、设计和优化，以便系统能够实现预期的性能和行为。控制理论广泛应用于自动化、机械工程、电气工程、航空航天、化工等领域。</p>
<p>以下是控制理论的一些关键概念：</p>
<ol>
<li><p><strong>系统（System）：</strong> 一个可以被观测和操控的实体，可以是物理系统、电气系统、生物系统等。系统通常由一组相互关联的元件组成。</p>
</li>
<li><p><strong>控制器（Controller）：</strong> 控制器是一个用于调节系统行为的设备或算法。它通过对系统的输入进行调整，使系统输出达到期望的目标。</p>
</li>
<li><p><strong>过程或系统的建模（System Modeling）：</strong> 将实际系统抽象为数学模型，以便进行分析和设计。模型可以是线性或非线性的，时变或时不变的，连续或离散的，等等。</p>
</li>
<li><p><strong>反馈控制（Feedback Control）：</strong> 反馈控制是指通过测量系统输出并将这些信息反馈到控制器，从而调整系统输入，使系统保持在期望的状态。</p>
</li>
<li><p><strong>开环和闭环控制（Open-Loop and Closed-Loop Control）：</strong> 在开环控制中，系统的输出不直接影响控制器的输入；而在闭环控制中，系统的输出被用于调整控制器的输入。</p>
</li>
<li><p><strong>稳定性分析（Stability Analysis）：</strong> 研究系统是否在长时间内保持有限的响应。稳定性分析是控制系统设计中的一个重要步骤。</p>
</li>
<li><p><strong>控制性能评估（Control Performance Evaluation）：</strong> 衡量控制系统在不同操作条件下的性能，包括稳定性、灵敏度、鲁棒性等。</p>
</li>
<li><p><strong>状态空间表示（State-Space Representation）：</strong> 将系统的动态行为表示为一组状态变量和它们的导数的方程，通常采用矩阵形式。</p>
</li>
<li><p><strong>PID控制（Proportional-Integral-Derivative Control）：</strong> 一种常见的控制策略，通过调整比例、积分和微分参数来实现系统的稳定性和性能。</p>
</li>
<li><p><strong>鲁棒控制（Robust Control）：</strong> 考虑系统参数变化和外部扰动时仍能保持良好性能的控制设计方法。</p>
</li>
</ol>
<p>控制理论的目标是设计稳定、高性能、鲁棒的控制系统，以满足特定应用领域的需求。控制理论在自动化系统、飞行器、机器人、工业过程控制等方面有广泛的应用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E6%95%B0%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E6%95%B0%E5%AD%A6/" class="post-title-link" itemprop="url">数学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>数学相关笔记</li>
</ul>
<h2 id="数学有哪些分支"><a href="#数学有哪些分支" class="headerlink" title="数学有哪些分支"></a>数学有哪些分支</h2><p>数学是一门广泛而深刻的学科，涵盖了多个分支和领域。以下是一些主要的数学分支：</p>
<ol>
<li><p><strong>代数学（Algebra）：</strong> 研究代数结构、方程、多项式、群论、环论等。它包括基本代数、抽象代数等方向。</p>
</li>
<li><p><strong>分析学（Analysis）：</strong> 研究极限、微积分、积分学、级数、实变函数、复变函数等。分析学分为实分析和复分析。</p>
</li>
<li><p><strong>几何学（Geometry）：</strong> 研究空间和图形的形状、大小、性质以及它们之间的关系。平面几何和空间几何是几何学的两个主要方向。</p>
</li>
<li><p><strong>概率论与数理统计（Probability and Statistics）：</strong> 研究随机事件、概率、统计推断、回归分析等，应用于数据分析、科学实验、风险管理等领域。</p>
</li>
<li><p><strong>数论（Number Theory）：</strong> 研究整数的性质，涉及素数、同余、数的分布等问题。</p>
</li>
<li><p><strong>拓扑学（Topology）：</strong> 研究空间的连通性、紧性、维度等概念，不关注度量和角度，而更注重形状和空间的变换。</p>
</li>
<li><p><strong>微分方程学（Differential Equations）：</strong> 研究方程中的导数和微分的关系，以及解这些方程的方法。包括常微分方程和偏微分方程。</p>
</li>
<li><p><strong>离散数学（Discrete Mathematics）：</strong> 研究离散结构，如集合、图论、逻辑、代数系统等。在计算机科学中有广泛应用。</p>
</li>
<li><p><strong>数学逻辑（Mathematical Logic）：</strong> 研究数学推理和证明的形式系统，包括命题逻辑、谓词逻辑等。</p>
</li>
<li><p><strong>运筹学（Operations Research）：</strong> 利用数学方法解决决策问题，包括线性规划、整数规划、动态规划等。</p>
</li>
<li><p><strong>应用数学（Applied Mathematics）：</strong> 将数学方法和技术应用于其他学科和实际问题，包括物理学、工程学、经济学等。</p>
</li>
</ol>
<p>这些数学分支之间有许多交叉和相互关联，数学的发展也在不断拓展和丰富这些领域。</p>
<h2 id="几何学是什么"><a href="#几何学是什么" class="headerlink" title="几何学是什么"></a>几何学是什么</h2><p>几何学是数学的一个分支，研究空间和图形的性质、形状、大小以及它们之间的相互关系。几何学关注的主要对象包括点、直线、平面、多边形、圆等几何图形，以及这些图形之间的相对位置和性质。</p>
<p>几何学可以分为平面几何和空间几何两个主要方向：</p>
<ol>
<li><p><strong>平面几何：</strong> 主要研究在一个平面上的几何关系和性质，包括点、直线、多边形、圆等在平面上的性质和相互关系。欧几里德几何是平面几何的一个经典分支，其中包含了许多基本的几何定理和公理。</p>
</li>
<li><p><strong>空间几何：</strong> 主要研究在三维空间中的几何关系和性质，涉及点、直线、平面、曲线、曲面等在空间中的相互关系。空间几何通常涉及更复杂的数学工具，如向量、矩阵等，用于描述和计算三维空间中的几何对象。</p>
</li>
</ol>
<p>几何学在数学中有着深远的影响，并且在许多其他学科中也有广泛的应用，如物理学、工程学、计算机图形学、地理学、建筑学等。它不仅关注于理论性质和证明，还在实际问题的建模、分析和解决方案中发挥着重要的作用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E7%A9%BA%E9%97%B4%E5%87%A0%E4%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E7%A9%BA%E9%97%B4%E5%87%A0%E4%BD%95/" class="post-title-link" itemprop="url">空间几何</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>空间几何相关笔记</li>
</ul>
<h2 id="空间几何是什么"><a href="#空间几何是什么" class="headerlink" title="空间几何是什么"></a>空间几何是什么</h2><p>空间几何是几何学的一个分支，主要研究三维空间中的几何关系和性质。在空间几何中，我们考虑点、直线、平面等基本几何元素在三维空间中的相互关系、位置、距离、角度等性质。</p>
<p>主要的几何元素包括：</p>
<ol>
<li><p><strong>点（Point）：</strong> 在三维空间中的位置，由坐标 ( (x, y, z) ) 表示。</p>
</li>
<li><p><strong>直线（Line）：</strong> 由无数个点组成，可以用方程或者参数方程表示。</p>
</li>
<li><p><strong>平面（Plane）：</strong> 由无数个点和直线组成，可以用法向量和一个点表示。</p>
</li>
<li><p><strong>曲线（Curve）：</strong> 在三维空间中的曲线，可以用参数方程或者其他方式表示。</p>
</li>
<li><p><strong>曲面（Surface）：</strong> 在三维空间中的曲面，可以用方程或者参数方程表示。</p>
</li>
<li><p><strong>体（Solid）：</strong> 在三维空间中的立体，可以用方程或者参数方程表示。</p>
</li>
</ol>
<p>空间几何研究的问题包括点与直线的位置关系、点与平面的位置关系、直线与平面的位置关系、两条直线的交点、两平面的交线等等。这些关系和性质在计算机图形学、计算机辅助设计（CAD）、工程学、物理学等领域都有广泛的应用。</p>
<p>在空间几何中，通常使用向量、矩阵、坐标系等工具来表示和计算几何对象的性质，以及解决几何问题。</p>
<h2 id="叉积法是什么"><a href="#叉积法是什么" class="headerlink" title="叉积法是什么"></a>叉积法是什么</h2><p>叉积法是一种基于向量叉积的几何计算方法。在三维空间中，给定两个向量 (\mathbf{v_1} &#x3D; (x_1, y_1, z_1)) 和 (\mathbf{v_2} &#x3D; (x_2, y_2, z_2))，它们的叉积 (\mathbf{v_1} \times \mathbf{v_2}) 是另一个向量，其计算方式为：</p>
<p>[<br>\mathbf{v_1} \times \mathbf{v_2} &#x3D; (y_1z_2 - z_1y_2, z_1x_2 - x_1z_2, x_1y_2 - y_1x_2)<br>]</p>
<p>叉积的结果是一个垂直于原始两个向量的新向量。具体来说，叉积的方向由右手法则确定：将右手的四指从第一个向量的方向转向第二个向量的方向，那么大拇指的方向就是叉积的方向。</p>
<p>在几何学和计算几何中，叉积有很多应用，其中之一就是判断点是否在平面内或者在某个区域内。在本讨论中，叉积被用来判断一个点是否在一个由向量围成的平面或体内。如果两个向量是线段的边，叉积法可以用来判断一个点是否在这两个点围成的区域内。</p>
<p>总体来说，叉积法通过计算向量的方向关系，可以判断点在向量所在的平面的哪一侧，从而用于解决空间几何问题。</p>
<h2 id="射线法是什么"><a href="#射线法是什么" class="headerlink" title="射线法是什么"></a>射线法是什么</h2><p>射线法是一种在计算几何中常用的方法，用于判断点是否在多边形内部。该方法基于射线与多边形的交点数量，通过统计交点的奇偶性来确定点是否在多边形内。</p>
<p>具体步骤如下：</p>
<ol>
<li>从待判断点发射一条射线（水平或垂直方向均可）。</li>
<li>记录射线与多边形的交点数量，每次与多边形的一条边相交就增加计数。</li>
<li>如果交点数量为奇数，那么点在多边形内部；如果为偶数，点在多边形外部。</li>
</ol>
<p>这个方法的原理是，如果一个点在多边形内部，那么从这个点发射的射线与多边形的边界会有奇数个交点，而如果在外部，则交点数量是偶数。这是因为多边形内的射线与多边形的边界相交的次数总是奇数，而在外部则总是偶数。</p>
<p>射线法的优点是简单易懂，适用于凸多边形和凹多边形。然而，对于自相交的多边形，射线法可能无法正确判断点的位置。</p>
<p>这个方法在计算机图形学、地理信息系统（GIS）等领域经常被使用。在实际编程中，需要考虑浮点数计算误差、边界条件等因素，以提高算法的准确性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A2%86%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A2%86%E5%9F%9F/" class="post-title-link" itemprop="url">机器人领域</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>机器人学中的数学</li>
</ul>
<h2 id="工业机器人领域使用到的数学"><a href="#工业机器人领域使用到的数学" class="headerlink" title="工业机器人领域使用到的数学"></a>工业机器人领域使用到的数学</h2><p>工业机器人领域涉及到多个数学分支，这些数学工具用于机器人的建模、运动规划、控制系统设计等方面。以下是在工业机器人领域常用的数学：</p>
<ol>
<li><p><strong>线性代数（Linear Algebra）：</strong> 工业机器人中广泛使用线性代数来表示和处理坐标变换、运动学和动力学问题。矩阵和向量的运算在描述机器人的位姿、关节角度以及执行器的运动方面非常有用。</p>
</li>
<li><p><strong>几何学（Geometry）：</strong> 机器人的运动学建模涉及到坐标系变换、旋转矩阵、齐次坐标等几何概念。几何学的知识用于描述和计算机器人末端执行器的位置和姿态。</p>
</li>
<li><p><strong>微积分（Calculus）：</strong> 运动规划、轨迹生成和优化算法通常需要微积分的方法。例如，对机器人的路径进行优化时，需要计算速度、加速度等。</p>
</li>
<li><p><strong>数值分析（Numerical Analysis）：</strong> 工业机器人控制系统通常需要进行数值计算，如逆运动学求解、路径规划、动力学模拟等。数值分析提供了有效和稳定的算法来解决这些问题。</p>
</li>
<li><p><strong>控制理论（Control Theory）：</strong> 控制理论用于设计机器人的控制系统，包括反馈控制、PID控制器、状态空间控制等。这些方法有助于保持机器人在目标轨迹上的准确性和稳定性。</p>
</li>
<li><p><strong>优化理论（Optimization Theory）：</strong> 优化方法在工业机器人中的应用很广泛，例如路径规划、运动优化、参数优化等。这有助于提高机器人的效率和性能。</p>
</li>
<li><p><strong>刚体运动学（Rigid Body Kinematics）：</strong> 刚体运动学用于描述机器人末端执行器的位置、速度和加速度，以及机器人关节的运动学性质。</p>
</li>
<li><p><strong>机器学习和人工智能（Machine Learning and AI）：</strong> 近年来，机器学习和人工智能在机器人领域的应用逐渐增多，包括视觉识别、自主导航、智能控制等。</p>
</li>
</ol>
<p>这些数学工具的综合运用使得工业机器人能够执行更复杂、精确和灵活的任务，提高了生产效率和质量。</p>
<h2 id="弧度和角度转换关系"><a href="#弧度和角度转换关系" class="headerlink" title="弧度和角度转换关系"></a>弧度和角度转换关系</h2><p>弧度（radians）和角度（degrees）之间的转换关系可以通过以下公式表示：</p>
<ol>
<li><p><strong>从角度到弧度的转换</strong>：</p>
<p>弧度 &#x3D; 角度 × π &#x2F; 180</p>
<p>其中，π（pi）是圆周率，约等于3.14159265359。</p>
<p>例如，将角度 90 度转换为弧度：</p>
<p>弧度 &#x3D; 90 × π &#x2F; 180 &#x3D; π &#x2F; 2 弧度</p>
</li>
<li><p><strong>从弧度到角度的转换</strong>：</p>
<p>角度 &#x3D; 弧度 × 180 &#x2F; π</p>
<p>例如，将弧度 π&#x2F;2 转换为角度：</p>
<p>角度 &#x3D; (π &#x2F; 2) × 180 &#x2F; π &#x3D; 90 度</p>
</li>
</ol>
<p>这些公式允许你在弧度和角度之间进行相互转换。这在数学、物理学、工程学以及机器人学等领域中非常常见，因为不同的问题和公式可能使用不同的单位，所以需要进行转换以便正确地处理数据。</p>
<h2 id="机器人学-弧度-角度-转换"><a href="#机器人学-弧度-角度-转换" class="headerlink" title="机器人学 弧度 角度 转换"></a>机器人学 弧度 角度 转换</h2><p>在机器人学和计算机图形学中，经常需要在弧度（radians）和角度（degrees）之间进行转换，以便在不同的数学和编程上下文中使用。以下是弧度和角度之间的常见转换方法：</p>
<ol>
<li><p><strong>从角度到弧度的转换</strong>：</p>
<p>如果你有一个角度（以度为单位），想要将其转换为弧度（以弧度为单位），可以使用以下公式：</p>
<p>[ \text{弧度} &#x3D; \frac{\text{角度} \times \pi}{180} ]</p>
<p>例如，如果要将角度 90 度转换为弧度：</p>
<p>[ \text{弧度} &#x3D; \frac{90 \times \pi}{180} &#x3D; \frac{\pi}{2} \text{ radians} ]</p>
</li>
<li><p><strong>从弧度到角度的转换</strong>：</p>
<p>如果你有一个弧度（以弧度为单位），想要将其转换为角度（以度为单位），可以使用以下公式：</p>
<p>[ \text{角度} &#x3D; \frac{\text{弧度} \times 180}{\pi} ]</p>
<p>例如，如果要将弧度 (\frac{\pi}{2}) 转换为角度：</p>
<p>[ \text{角度} &#x3D; \frac{\frac{\pi}{2} \times 180}{\pi} &#x3D; 90^\circ ]</p>
</li>
</ol>
<p>这些转换公式是标准的数学关系，用于在角度和弧度之间进行转换。在机器人学和计算机图形学中，通常需要根据具体问题将角度和弧度进行相互转换，以便进行正确的计算和旋转操作。确保在程序中使用适当的单位，以避免单位混淆和错误的计算。</p>
<h2 id="机器人学-轴角为初始姿态-加上欧拉角-最终获取轴角-如何计算"><a href="#机器人学-轴角为初始姿态-加上欧拉角-最终获取轴角-如何计算" class="headerlink" title="机器人学 轴角为初始姿态 加上欧拉角 最终获取轴角 如何计算"></a>机器人学 轴角为初始姿态 加上欧拉角 最终获取轴角 如何计算</h2><p>在机器人学中，如果你有一个初始姿态（用轴角表示）和一个欧拉角，然后想要将这个欧拉角旋转添加到初始姿态中，最终获取新的轴角表示，你可以按照以下步骤进行计算：</p>
<ol>
<li><p><strong>将初始轴角（Axis-Angle）表示转换为旋转矩阵</strong>（Rotation Matrix）或四元数（Quaternion）。</p>
<ul>
<li>如果你的初始姿态使用轴角表示为 (AA_{init} &#x3D; (\mathbf{u}<em>{init}, \theta</em>{init}))，其中 (\mathbf{u}<em>{init}) 是旋转轴的单位向量，(\theta</em>{init}) 是旋转的角度，那么你可以使用轴角到旋转矩阵或四元数的转换公式将其转换为旋转矩阵 (R_{init}) 或四元数 (Q_{init})。</li>
</ul>
</li>
<li><p><strong>将欧拉角转换为旋转矩阵</strong>。</p>
<ul>
<li>如果你有欧拉角表示为 (E &#x3D; (\alpha, \beta, \gamma))，其中 (\alpha) 是滚动角，(\beta) 是俯仰角，(\gamma) 是偏航角，那么你可以使用欧拉角到旋转矩阵的转换公式将其转换为旋转矩阵 (R_{E})。</li>
</ul>
</li>
<li><p><strong>计算最终的旋转矩阵</strong>。</p>
<ul>
<li>将初始的旋转矩阵 (R_{init}) 与欧拉角的旋转矩阵 (R_{E}) 相乘，得到最终的旋转矩阵 (R_{final} &#x3D; R_{init} \cdot R_{E})。</li>
</ul>
</li>
<li><p><strong>将最终的旋转矩阵转换为轴角</strong>。</p>
<ul>
<li>最后，你可以使用旋转矩阵到轴角的转换公式，将最终的旋转矩阵 (R_{final}) 转换为轴角表示 (AA_{final} &#x3D; (\mathbf{u}<em>{final}, \theta</em>{final}))。</li>
</ul>
</li>
</ol>
<p>需要注意的是，转换公式的具体形式取决于你使用的坐标系约定和数学库（例如，Eigen、Mathematics Toolbox等）。因此，在实际应用中，请查阅相应的文档以确保正确的转换。</p>
<p>通过这个过程，你可以将初始轴角姿态与欧拉角旋转相结合，获得最终的轴角姿态。这种方法允许你在不同表示之间进行转换，并有效地管理机器人的姿态。</p>
<h2 id="机器人学-旋转矩阵-运算-详解"><a href="#机器人学-旋转矩阵-运算-详解" class="headerlink" title="机器人学 旋转矩阵 运算 详解"></a>机器人学 旋转矩阵 运算 详解</h2><p>在机器人学中，旋转矩阵是一种常用的表示方法，用于描述三维空间中的旋转操作。旋转矩阵是一个3x3的矩阵，其中每一列和每一行都是一个单位向量，用来表示旋转后的坐标系的方向。通过旋转矩阵，可以非常有效地表示和计算物体的旋转。</p>
<p>以下是关于机器人学中旋转矩阵运算的详细解释：</p>
<ol>
<li><p><strong>旋转矩阵的表示</strong>：</p>
<p>一个通用的旋转矩阵通常表示为：</p>
<p>[ R &#x3D; \begin{bmatrix} r_{11} &amp; r_{12} &amp; r_{13} \ r_{21} &amp; r_{22} &amp; r_{23} \ r_{31} &amp; r_{32} &amp; r_{33} \end{bmatrix} ]</p>
<p>其中，( R ) 是旋转矩阵，( r_{ij} ) 表示矩阵的元素，表示旋转后的坐标系的方向。</p>
</li>
<li><p><strong>旋转矩阵的性质</strong>：</p>
<ul>
<li><p>旋转矩阵是正交矩阵（orthogonal matrix），即它的列向量和行向量都是单位向量，并且相互垂直。这意味着旋转矩阵的转置等于其逆。</p>
</li>
<li><p>旋转矩阵的行和列表示了新坐标系的基向量。</p>
</li>
<li><p>旋转矩阵的行（或列）的长度不变，即 ( |r_i| &#x3D; 1 )。</p>
</li>
</ul>
</li>
<li><p><strong>旋转矩阵的运算</strong>：</p>
<ul>
<li><p>旋转矩阵可以用于将一个点从一个坐标系转换到另一个坐标系。给定一个点的坐标 ( \mathbf{p} )，通过乘以旋转矩阵 ( R )，可以得到旋转后的坐标 ( \mathbf{p}’ )：</p>
<p>[ \mathbf{p}’ &#x3D; R \cdot \mathbf{p} ]</p>
</li>
<li><p>旋转矩阵之间可以进行矩阵乘法来表示复合旋转。如果有两个旋转矩阵 ( R_1 ) 和 ( R_2 )，它们分别表示两个旋转操作，那么它们的复合旋转可以表示为：</p>
<p>[ R &#x3D; R_1 \cdot R_2 ]</p>
</li>
<li><p>旋转矩阵的逆矩阵表示相反的旋转。如果 ( R ) 表示一个旋转，那么 ( R^{-1} ) 表示相反的旋转，即将物体旋转回初始位置。</p>
</li>
</ul>
</li>
<li><p><strong>Euler角到旋转矩阵</strong>：</p>
<p>通常，可以使用欧拉角（滚动、俯仰、偏航）来构建旋转矩阵。不同的欧拉角顺序会产生不同的旋转矩阵。例如，在XYZ顺序下，可以使用以下方式构建旋转矩阵：</p>
<p>[ R &#x3D; R_z(\text{偏航角}) \cdot R_y(\text{俯仰角}) \cdot R_x(\text{滚动角}) ]</p>
<p>其中，( R_x )、( R_y ) 和 ( R_z ) 分别表示绕X、Y和Z轴的旋转矩阵。</p>
</li>
</ol>
<p>旋转矩阵是机器人学中非常重要的工具，因为它们允许精确描述和计算旋转操作，这对于机器人的定位、导航和运动控制非常关键。通过旋转矩阵，机器人可以准确地执行各种复杂的旋转操作。然而，需要注意的是，旋转矩阵的运算可能比其他表示方法（如四元数）稍显复杂，因此在实际应用中需要小心处理。</p>
<h2 id="轴角-详解"><a href="#轴角-详解" class="headerlink" title="轴角 详解"></a>轴角 详解</h2><p>轴角（Axis-Angle）表示一种在三维空间中描述旋转的方式。它使用一个轴向量和一个角度来表示旋转操作。轴角常用于计算机图形学、机器人学以及三维游戏开发等领域，因为它可以更直观地描述旋转操作，而不像欧拉角那样容易出现万向锁问题。</p>
<p>轴角由以下两个要素组成：</p>
<ol>
<li><p>轴向量（Axis Vector）：这是一个单位向量，用于定义旋转的轴线方向。轴向量通常表示为单位长度的三维向量，例如 <code>(x, y, z)</code>，其中 <code>(x, y, z)</code> 是轴的方向向量。</p>
</li>
<li><p>旋转角度（Angle）：这是绕轴线旋转的角度，通常以弧度（radians）为单位表示。角度可以是正数或负数，表示旋转的方向，通常在 0 到 2π（360度）之间。</p>
</li>
</ol>
<p>轴角表示一个旋转操作，其效果是绕轴向量指定的轴线旋转一定的角度。旋转角度的方向由轴向量的方向确定，旋转的大小由旋转角度表示。</p>
<p>轴角的表示方式可以用以下公式表示：</p>
<p>[ \text{Rotation} &#x3D; \theta \cdot \mathbf{u} ]</p>
<p>其中：</p>
<ul>
<li>( \theta ) 是旋转角度，以弧度表示。</li>
<li>( \mathbf{u} ) 是单位轴向量，表示旋转的轴。</li>
</ul>
<p>轴角的使用步骤通常如下：</p>
<ol>
<li>定义轴向量（单位向量），表示旋转的轴线方向。</li>
<li>指定旋转的角度（以弧度为单位）。</li>
<li>使用轴向量和旋转角度构建轴角表示。</li>
</ol>
<p>轴角的优点之一是它没有欧拉角的万向锁问题，因此在某些情况下更容易处理。然而，它相对较难以直观地理解，因此在实际应用中，通常会使用其他表示方法，如四元数（Quaternions），以更方便地进行旋转计算。</p>
<p>总之，轴角是一种用于描述三维空间中旋转的方法，它使用轴向量和旋转角度来表示旋转操作。</p>
<h2 id="欧拉角-详解"><a href="#欧拉角-详解" class="headerlink" title="欧拉角 详解"></a>欧拉角 详解</h2><p>欧拉角（Euler Angles）是一种用于描述物体在三维空间中旋转的方法。它是以数学家Leonhard Euler的名字命名的，用于将旋转运动分解为三个连续的旋转操作，通常分别绕X轴、Y轴和Z轴进行旋转。欧拉角是一种常见的旋转表示方法，用于计算机图形学、航空航天、机器人学、三维动画等领域。</p>
<p>欧拉角通常由三个角度组成，分别是：</p>
<ol>
<li><p><strong>滚动角（Roll）</strong>：也称为Bank角，表示绕X轴的旋转。滚动角度用来描述物体绕其自身前后轴的旋转，通常以弧度（radians）为单位表示。正角度表示顺时针旋转，负角度表示逆时针旋转。</p>
</li>
<li><p><strong>俯仰角（Pitch）</strong>：也称为Elevation角，表示绕Y轴的旋转。俯仰角度用来描述物体绕其自身左右轴的旋转，通常以弧度为单位表示。正角度表示向上旋转，负角度表示向下旋转。</p>
</li>
<li><p><strong>偏航角（Yaw）</strong>：也称为Heading角，表示绕Z轴的旋转。偏航角度用来描述物体绕其自身垂直轴的旋转，通常以弧度为单位表示。正角度表示顺时针旋转，负角度表示逆时针旋转。</p>
</li>
</ol>
<p>欧拉角的顺序很重要，因为它们定义了旋转的顺序。常见的欧拉角顺序包括：</p>
<ul>
<li>XYZ：首先绕X轴旋转，然后绕Y轴旋转，最后绕Z轴旋转。</li>
<li>ZYX：首先绕Z轴旋转，然后绕Y轴旋转，最后绕X轴旋转。</li>
<li>YXZ：首先绕Y轴旋转，然后绕X轴旋转，最后绕Z轴旋转。</li>
</ul>
<p>不同的欧拉角顺序可能导致不同的旋转结果，因此在使用欧拉角时必须确保选定了正确的顺序。</p>
<p>尽管欧拉角在许多情况下非常直观，但它们也存在一些问题，例如万向锁问题，即在某些情况下无法唯一表示旋转。为了避免这些问题，有时会使用其他旋转表示方法，如四元数（Quaternions）。</p>
<p>总之，欧拉角是一种用于描述三维空间中旋转的常见方法，它由三个角度组成，表示绕X、Y和Z轴的旋转。欧拉角的顺序非常重要，并且在某些情况下可能存在问题，因此在使用时需要谨慎选择。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Network/2024-05-22-network_1_%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Network/2024-05-22-network_1_%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">network_1_网络理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>网络基础知识和基础理论</li>
</ul>
<h2 id="网关是什么"><a href="#网关是什么" class="headerlink" title="网关是什么"></a>网关是什么</h2><p>在计算机网络中，网关（Gateway）是连接两个不同网络的设备或软件。它充当连接不同网络之间的桥梁，使得数据可以在这些网络之间传输。网关可以是硬件设备，如路由器，也可以是运行特定网络协议的计算机或服务器。</p>
<p>网关的作用是转发数据包，根据目标地址将数据从一个网络传输到另一个网络。它还可以执行一些额外的功能，如网络地址转换（NAT）、防火墙安全过滤、代理服务等。网关在网络通信中扮演着重要的角色，使得不同网络之间能够有效地通信和交换信息。</p>
<h2 id="网关详解"><a href="#网关详解" class="headerlink" title="网关详解"></a>网关详解</h2><p>网关是指在计算机网络中连接两个不同网络的设备或软件。它在网络中扮演着转换数据、连接不同网络并进行数据交换的重要角色。</p>
<p>以下是关于网关的详细解释：</p>
<ol>
<li><p><strong>连接不同网络：</strong> 网关允许不同类型或不同协议的网络进行通信。它可以连接局域网（LAN）与广域网（WAN）、不同厂商的设备、不同网络协议（如以太网、Wi-Fi、蓝牙等）的网络之间。</p>
</li>
<li><p><strong>数据转发：</strong> 网关接收从源网络发来的数据包，并根据目标地址的信息将这些数据包转发到目标网络中。它根据特定的路由规则和网络协议进行数据包的转发。</p>
</li>
<li><p><strong>协议转换：</strong> 网关可以执行协议转换的功能，将一个网络协议的数据转换为另一个网络协议的数据。这种转换允许不同类型的网络进行交流，即使它们使用不同的通信标准和协议。</p>
</li>
<li><p><strong>安全性：</strong> 网关通常包含安全功能，比如防火墙和网络地址转换（NAT）。防火墙可以监控和控制数据包的流量，确保网络安全。NAT 可以隐藏网络内部设备的真实 IP 地址，增强网络的安全性。</p>
</li>
<li><p><strong>路由功能：</strong> 网关可以根据路由表或配置的路由规则来决定数据包的最佳传输路径，以便有效地将数据包从源网络传输到目标网络。</p>
</li>
<li><p><strong>代理服务：</strong> 网关可以提供代理服务，允许客户端通过网关访问互联网。代理服务还可以对互联网上的请求进行缓存和过滤，提高网络性能和安全性。</p>
</li>
</ol>
<p>总的来说，网关在计算机网络中扮演着非常重要的角色，它连接和协调不同网络之间的通信，同时提供了一些安全和管理功能，确保网络通信的顺畅和安全。</p>
<h2 id="uri-详解"><a href="#uri-详解" class="headerlink" title="uri 详解"></a>uri 详解</h2><p>URI（Uniform Resource Identifier）是一种用于标识和定位资源的字符串表示形式。它是互联网上广泛使用的标准，用于唯一地标识资源，包括网页、图片、视频、文件等。URI 是由 RFC 3986（通用资源标识符：通用语法）定义的。</p>
<p>URI 的一般格式为：<code>scheme:[//authority]path[?query][#fragment]</code></p>
<p>其中各部分的含义如下：</p>
<ol>
<li><p>Scheme（协议）：表示资源的访问协议，如 <code>http</code>、<code>https</code>、<code>ftp</code> 等。它通常用于指定资源的访问方式。例如：<code>http://www.example.com</code></p>
</li>
<li><p>Authority（权限）：表示资源的权限部分，包括主机名和可选的端口号。它通常用于指定资源所在的服务器或主机。例如：<code>www.example.com:8080</code></p>
</li>
<li><p>Path（路径）：表示资源在服务器上的路径。它通常用于指定资源在服务器文件系统中的位置。例如：<code>/path/to/resource</code></p>
</li>
<li><p>Query（查询）：表示资源的查询部分，用于传递参数给资源。它通常用于向服务器传递额外的信息。例如：<code>?id=123&amp;name=example</code></p>
</li>
<li><p>Fragment（片段）：表示资源的片段标识符，用于指定资源的某个特定片段。它通常用于定位 HTML 页面中的某个锚点。例如：<code>#section1</code></p>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>下面是几个 URI 的示例：</p>
<ol>
<li><p><code>https://www.example.com/index.html</code></p>
<ul>
<li>Scheme: <code>https</code></li>
<li>Authority: <code>www.example.com</code></li>
<li>Path: <code>/index.html</code></li>
</ul>
</li>
<li><p><code>ftp://ftp.example.com/files/data.zip</code></p>
<ul>
<li>Scheme: <code>ftp</code></li>
<li>Authority: <code>ftp.example.com</code></li>
<li>Path: <code>/files/data.zip</code></li>
</ul>
</li>
<li><p><code>https://www.example.com/search?q=uri+explanation</code></p>
<ul>
<li>Scheme: <code>https</code></li>
<li>Authority: <code>www.example.com</code></li>
<li>Path: <code>/search</code></li>
<li>Query: <code>q=uri+explanation</code></li>
</ul>
</li>
<li><p><code>https://www.example.com/index.html#section2</code></p>
<ul>
<li>Scheme: <code>https</code></li>
<li>Authority: <code>www.example.com</code></li>
<li>Path: <code>/index.html</code></li>
<li>Fragment: <code>#section2</code></li>
</ul>
</li>
</ol>
<p>URI 的重要性在于它提供了一种标准的方式来标识和定位互联网上的资源，使得用户可以通过统一的格式来访问和处理各种不同类型的资源。</p>
<hr>
<h2 id="url-详解"><a href="#url-详解" class="headerlink" title="url 详解"></a>url 详解</h2><p>URL（Uniform Resource Locator）是一种具体的 URI（Uniform Resource Identifier），用于定位和标识互联网上的资源。URL 是由 RFC 3986（通用资源标识符：通用语法）定义的，它是 URI 的一种常见形式。</p>
<p>URL 的一般格式为：<code>scheme://username:password@host:port/path?query#fragment</code></p>
<p>其中各部分的含义如下：</p>
<ol>
<li><p>Scheme（协议）：表示资源的访问协议，如 <code>http</code>、<code>https</code>、<code>ftp</code> 等。它通常用于指定资源的访问方式。例如：<code>https://www.example.com</code></p>
</li>
<li><p>Username 和 Password（用户名和密码）：表示资源的认证信息，用于访问受限资源时进行身份验证。它们是可选的，并用于提供访问资源所需的用户名和密码。例如：<code>ftp://user:password@example.com</code></p>
</li>
<li><p>Host 和 Port（主机名和端口号）：表示资源所在的主机名和可选的端口号。它通常用于指定资源所在的服务器或主机。例如：<code>https://www.example.com:8080</code></p>
</li>
<li><p>Path（路径）：表示资源在服务器上的路径。它通常用于指定资源在服务器文件系统中的位置。例如：<code>/path/to/resource</code></p>
</li>
<li><p>Query（查询）：表示资源的查询部分，用于传递参数给资源。它通常用于向服务器传递额外的信息。例如：<code>?id=123&amp;name=example</code></p>
</li>
<li><p>Fragment（片段）：表示资源的片段标识符，用于指定资源的某个特定片段。它通常用于定位 HTML 页面中的某个锚点。例如：<code>#section1</code></p>
</li>
</ol>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>下面是几个 URL 的示例：</p>
<ol>
<li><p><code>https://www.example.com/index.html</code></p>
<ul>
<li>Scheme: <code>https</code></li>
<li>Host: <code>www.example.com</code></li>
<li>Path: <code>/index.html</code></li>
</ul>
</li>
<li><p><code>ftp://ftp.example.com/files/data.zip</code></p>
<ul>
<li>Scheme: <code>ftp</code></li>
<li>Host: <code>ftp.example.com</code></li>
<li>Path: <code>/files/data.zip</code></li>
</ul>
</li>
<li><p><code>https://www.example.com/search?q=url+explanation</code></p>
<ul>
<li>Scheme: <code>https</code></li>
<li>Host: <code>www.example.com</code></li>
<li>Path: <code>/search</code></li>
<li>Query: <code>q=url+explanation</code></li>
</ul>
</li>
<li><p><code>https://www.example.com/index.html#section2</code></p>
<ul>
<li>Scheme: <code>https</code></li>
<li>Host: <code>www.example.com</code></li>
<li>Path: <code>/index.html</code></li>
<li>Fragment: <code>#section2</code></li>
</ul>
</li>
</ol>
<p>URL 是互联网上资源的标准定位方式，它允许用户通过特定的地址来访问和处理不同类型的资源，如网页、图片、视频、文件等。</p>
<h2 id="RPC-工作方式-详解"><a href="#RPC-工作方式-详解" class="headerlink" title="RPC 工作方式 详解"></a>RPC 工作方式 详解</h2><p>RPC（Remote Procedure Call，远程过程调用）的工作方式如下：</p>
<ol>
<li><p><strong>客户端调用</strong>: 客户端应用程序调用本地的客户端存根（Client Stub），就像调用本地函数一样。客户端存根负责将函数调用转化为网络消息。</p>
</li>
<li><p><strong>消息传输</strong>: 客户端存根将封装好的消息通过网络发送到远程服务器。</p>
</li>
<li><p><strong>服务器端接收</strong>: 远程服务器接收到客户端发送的消息。</p>
</li>
<li><p><strong>服务器端存根处理</strong>: 服务器端存根（Server Stub）接收到消息后，解析出远程调用的函数、参数和其他必要信息。</p>
</li>
<li><p><strong>函数调用</strong>: 服务器端存根调用本地的服务器函数，执行请求的操作。</p>
</li>
<li><p><strong>结果返回</strong>: 服务器函数执行完毕后，将结果打包成消息发送回客户端。</p>
</li>
<li><p><strong>客户端接收</strong>: 客户端接收到服务器返回的消息。</p>
</li>
<li><p><strong>客户端存根处理</strong>: 客户端存根解析服务器返回的消息，提取结果数据。</p>
</li>
<li><p><strong>结果返回给应用程序</strong>: 客户端存根将结果返回给客户端应用程序，应用程序继续执行后续的逻辑。</p>
</li>
</ol>
<p>在这个过程中，RPC 的关键是将本地的函数调用转换为网络消息，并在远程服务器上执行相应的函数，然后将结果返回给客户端。这使得客户端和服务器之间的远程调用过程像本地函数调用一样简单和透明。</p>
<p>RPC 的实现通常包括以下几个组件：</p>
<ul>
<li><p><strong>接口定义</strong>: 定义可远程调用的函数接口、参数和返回值的数据类型。这些接口通常使用 IDL（Interface Definition Language，接口定义语言）来描述。</p>
</li>
<li><p><strong>存根生成</strong>: 根据接口定义生成客户端和服务器端的存根（Stub）代码。存根代码负责将本地函数调用转换为网络消息，并将消息发送到对应的远程服务器。</p>
</li>
<li><p><strong>序列化和反序列化</strong>: 在远程调用过程中，参数和返回值需要在网络传输前进行序列化（编码），并在接收后进行反序列化（解码）。序列化将数据转换为可传输的格式，反序列化将传输的数据还原为可处理的形式。</p>
</li>
<li><p><strong>网络传输</strong>: 使用底层的网络通信协议（如 TCP&#x2F;IP）在客户端和服务器之间进行消息传输。这通常涉及消息的封装、发送、接收和解析。</p>
</li>
<li><p><strong>错误处理</strong>: RPC 也包含错误处理机制，例如处理网络故障、超时、服务不可用等情况。当远程调用失败或出现异常时，错误信息可以被传递回客户端进行处理。</p>
</li>
</ul>
<p>需要注意的是，具体的 RPC 实现可能有所不同，不同的 RPC 框架和协议会有各自的特点和机制。这些框架提供了更高级的抽象和功能，使得分布式系统开发更加方便和高效。</p>
<p>希望这些详解能够帮助您更好地理解 RPC 的工作方式！如果您有更多问题，请随时提问。</p>
<h2 id="RPC-详解"><a href="#RPC-详解" class="headerlink" title="RPC 详解"></a>RPC 详解</h2><p>RPC（Remote Procedure Call，远程过程调用）是一种通信协议和编程模型，用于实现分布式系统中不同节点之间的远程调用。它允许在不同计算机或进程之间像调用本地函数一样调用远程函数，隐藏了底层网络通信的细节。</p>
<p>以下是关于 RPC 的详解：</p>
<ol>
<li><p><strong>远程调用</strong>: RPC 允许客户端应用程序调用位于远程服务器上的函数，就像调用本地函数一样。客户端应用程序不需要关心底层的网络通信和远程函数的具体实现细节。</p>
</li>
<li><p><strong>编程模型</strong>: RPC 提供了一种编程模型，使得开发人员能够以类似本地函数调用的方式编写分布式应用程序。开发人员可以定义接口和函数签名，并在客户端和服务器上实现相应的逻辑。</p>
</li>
<li><p><strong>接口定义</strong>: 在 RPC 中，接口定义起着关键的作用。接口定义描述了可供远程调用的函数及其参数和返回值的数据类型。接口定义通常使用 IDL（Interface Definition Language，接口定义语言）来描述，如 Protocol Buffers、IDL、Thrift 等。</p>
</li>
<li><p><strong>存根和代理</strong>: 在使用 RPC 时，需要生成客户端和服务器端的存根（Stub）和代理（Proxy）代码。存根代码负责将远程调用转换为网络消息并发送给服务器，而代理代码负责接收远程调用请求并将其转发给本地函数。</p>
</li>
<li><p><strong>序列化和反序列化</strong>: 在进行远程调用时，参数和返回值需要进行序列化和反序列化。序列化将数据转换为可以在网络上传输的格式，而反序列化将接收到的数据还原为可处理的形式。</p>
</li>
<li><p><strong>网络传输</strong>: RPC 使用底层的网络通信协议（如 TCP&#x2F;IP）来实现远程调用的传输。客户端通过网络发送请求消息给服务器，服务器接收请求消息并执行相应的函数，然后将结果返回给客户端。</p>
</li>
<li><p><strong>错误处理</strong>: RPC 也涉及错误处理机制。当远程调用失败或出现异常时，RPC 会返回适当的错误码或异常信息给客户端，以便进行错误处理和恢复。</p>
</li>
</ol>
<p>RPC 在分布式系统中广泛应用，用于实现不同节点之间的协作和通信。它提供了一种方便和透明的方式来调用远程函数，使得分布式应用程序开发更加简化和高效。</p>
<p>常见的 RPC 框架包括 gRPC、Apache Thrift、JSON-RPC、XML-RPC 等。这些框架提供了不同的功能和特性，可以根据具体需求选择合适的 RPC 框架。</p>
<p>希望这些详解能帮助您更好地理解 RPC！如果您有更多问题，请随时提问。</p>
<h2 id="RPC-是什么"><a href="#RPC-是什么" class="headerlink" title="RPC 是什么"></a>RPC 是什么</h2><p>RPC（Remote Procedure Call，远程过程调用）是一种通信协议和编程模型，用于实现分布式系统中不同节点之间的远程调用。它使得在不同计算机或进程之间能够像调用本地函数一样调用远程函数，隐藏了底层网络通信的细节。</p>
<p>以下是关于 RPC 的一些详解：</p>
<ol>
<li><p><strong>远程调用</strong>：RPC 允许应用程序在不同的计算机或进程之间进行远程调用。客户端应用程序可以像调用本地函数一样调用远程服务器上的函数，而无需了解底层的网络通信细节。</p>
</li>
<li><p><strong>编程模型</strong>：RPC 提供了一种编程模型，使得开发人员能够以类似本地函数调用的方式编写分布式应用程序。开发人员可以定义接口和函数签名，并在客户端和服务器上实现相应的逻辑。</p>
</li>
<li><p><strong>通信协议</strong>：RPC 使用特定的通信协议来实现远程调用。常见的 RPC 协议包括 gRPC、Apache Thrift、JSON-RPC、XML-RPC 等。这些协议定义了消息的格式、序列化和网络传输的方式。</p>
</li>
<li><p><strong>序列化</strong>：在 RPC 中，参数和返回值需要在客户端和服务器之间进行序列化和反序列化。序列化是将数据转换为可传输的格式，反序列化是将传输的数据还原为可处理的形式。</p>
</li>
<li><p><strong>网络通信</strong>：RPC 通过底层的网络通信实现远程调用。客户端通过网络发送请求消息给服务器，服务器接收请求消息并执行相应的函数，然后将结果返回给客户端。</p>
</li>
<li><p><strong>跨语言支持</strong>：RPC 可以支持多种编程语言之间的远程调用。通过使用通用的 RPC 协议和序列化机制，不同语言的应用程序可以相互通信和调用。</p>
</li>
<li><p><strong>分布式系统</strong>：RPC 在分布式系统中广泛应用，用于实现不同节点之间的协作和通信。它可以用于构建大规模、高可靠性的分布式应用程序架构。</p>
</li>
</ol>
<p>RPC 是一种常见的分布式系统通信模型，它简化了分布式应用程序的开发过程，使得不同节点之间的远程调用更加方便和透明。</p>
<p>希望这些详解对 RPC 有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="TLS-详解"><a href="#TLS-详解" class="headerlink" title="TLS 详解"></a>TLS 详解</h2><p>TLS（Transport Layer Security）是一种用于保护网络通信安全性的加密协议。它建立在传输层协议（如 TCP）之上，用于在客户端和服务器之间创建安全的通信通道。以下是关于 TLS 的详解：</p>
<ol>
<li><p><strong>安全通信</strong>：TLS 的主要目标是确保通信的机密性、完整性和身份验证。它使用加密算法对数据进行加密，以防止未经授权的访问者获取敏感信息。同时，TLS 还使用消息摘要和数字签名等技术来保证数据的完整性，防止数据被篡改。</p>
</li>
<li><p><strong>握手过程</strong>：TLS 使用握手过程来建立安全连接。在握手过程中，客户端和服务器之间进行协商，包括选择加密算法、交换密钥、进行身份验证等。握手过程涉及多个步骤，例如协议版本协商、证书交换、密钥协商和密钥确认等。</p>
</li>
<li><p><strong>证书和公钥基础设施（PKI）</strong>：TLS 使用数字证书来实现身份验证和密钥交换。数字证书由受信任的证书颁发机构（CA）签发，包含服务器的公钥和其他身份信息。客户端可以验证服务器证书的有效性，以确保与合法服务器建立连接。</p>
</li>
<li><p><strong>加密算法</strong>：TLS 支持多种加密算法，用于保护通信数据的机密性。常见的加密算法包括对称加密算法（如AES）、非对称加密算法（如RSA）和哈希算法（如SHA）。在握手过程中，客户端和服务器协商选择适合的加密算法和密钥长度。</p>
</li>
<li><p><strong>版本和演进</strong>：TLS 有多个版本，包括 TLS 1.0、TLS 1.1、TLS 1.2 和 TLS 1.3。每个版本都有不同的功能和安全性。TLS 1.3 是最新的版本，引入了许多改进和安全增强，提供更快的握手速度和更强的密码套件。</p>
</li>
<li><p><strong>应用场景</strong>：TLS 广泛应用于各种安全通信场景，如网上银行、电子商务、电子邮件、VPN（虚拟私人网络）等。它为通信双方提供了保护数据隐私和确保通信安全的机制，防止数据泄露、篡改和中间人攻击。</p>
</li>
<li><p><strong>HTTPS</strong>：TLS 在 Web 安全中起着重要的作用，它与 HTTP 协议结合形成 HTTPS（HTTP Secure）。HTTPS 使用 TLS 加密和身份验证来保护 Web 浏览器和服务器之间的数据传输，确保网站的安全性和用户的隐私。</p>
</li>
</ol>
<p>TLS 是一种重要的安全协议，被广泛应用于保护网络通信的安全性。它提供了加密、身份验证和数据完整性保护的功能，为通信双方提供了安全可靠的通信通道。</p>
<p>希望这些详解对 TLS 有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="TLS-是什么"><a href="#TLS-是什么" class="headerlink" title="TLS 是什么"></a>TLS 是什么</h2><p>TLS（Transport Layer Security）是一种用于保护网络通信安全性的加密协议。它是 SSL（Secure Sockets Layer）协议的继任者，并被广泛应用于互联网上的各种安全通信场景。</p>
<p>以下是关于 TLS 的一些详解：</p>
<ol>
<li><p><strong>安全通信</strong>：TLS 用于在网络通信中实现安全和私密的数据传输。它通过加密通信内容，确保数据在传输过程中不被窃听、篡改或伪造。</p>
</li>
<li><p><strong>协议层</strong>：TLS 位于网络通信的传输层之上，与传输层协议（如 TCP）一起工作，为上层应用提供安全的通信通道。</p>
</li>
<li><p><strong>加密和身份验证</strong>：TLS 使用加密算法对通信内容进行加密，确保数据的保密性。同时，TLS 还提供身份验证机制，用于验证通信双方的身份，并防止中间人攻击。</p>
</li>
<li><p><strong>证书和密钥交换</strong>：TLS 使用数字证书来验证服务器的身份，并协商加密密钥。证书由受信任的证书颁发机构（CA）签发，包含服务器公钥和相关信息。</p>
</li>
<li><p><strong>握手过程</strong>：TLS 通过握手过程建立安全连接。在握手过程中，客户端和服务器之间进行协议版本协商、身份验证、密钥交换和协商加密算法等操作，以建立共享密钥和参数。</p>
</li>
<li><p><strong>支持的应用协议</strong>：TLS 不仅可以保护基于 TCP 的应用层协议（如 HTTP、SMTP、IMAP），还可以保护其他传输层协议，如 UDP 的 DTLS（Datagram Transport Layer Security）。</p>
</li>
<li><p><strong>版本和演变</strong>：TLS 有多个版本，包括 TLS 1.0、TLS 1.1、TLS 1.2 和 TLS 1.3。每个版本都有不同的功能和安全性，随着时间的推移，TLS 协议不断演进以修复漏洞并提供更好的安全性。</p>
</li>
</ol>
<p>TLS 在互联网上广泛应用于保护敏感数据的传输，如网上银行、电子商务、电子邮件等。它为通信双方提供了一种安全、私密和可靠的通信机制，防止数据泄露和篡改，保护用户隐私和信息安全。</p>
<p>希望这些详解对 TLS 有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="SNTP-server-详解"><a href="#SNTP-server-详解" class="headerlink" title="SNTP server 详解"></a>SNTP server 详解</h2><p>SNTP（Simple Network Time Protocol）服务器是一种用于提供时间同步服务的网络服务器。它基于网络通信协议，允许计算机和其他网络设备通过网络获取准确的时间信息。</p>
<p>以下是 SNTP 服务器的一些详解：</p>
<ol>
<li><p><strong>时间同步服务</strong>：SNTP 服务器的主要功能是提供时间同步服务。它接收来自客户端的时间同步请求，并返回准确的时间戳作为响应。客户端可以通过与 SNTP 服务器通信，获取服务器上的当前时间，并将本地时间与服务器时间进行校准，以确保计算机和网络设备的时间与参考时间保持一致。</p>
</li>
<li><p><strong>网络时间协议</strong>：SNTP 服务器基于网络时间协议（NTP）标准或其简化版本。NTP 是一种用于在计算机网络中同步时间的协议，而SNTP 则是 NTP 的简化版本，去除了一些复杂的功能和算法，主要用于提供基本的时间同步服务。</p>
</li>
<li><p><strong>时间源</strong>：SNTP 服务器通常连接到一个时间源，以获取准确的时间信息。时间源可以是国家时间标准机构（如NIST）的服务器，也可以是互联网上的其他可靠时间服务器。服务器通过与时间源进行通信，获取准确的时间，并将其提供给客户端。</p>
</li>
<li><p><strong>时间精度</strong>：SNTP 服务器的时间精度取决于所使用的时间源和服务器的硬件和软件配置。一般情况下，SNTP 服务器可以提供较高的时间精度，通常在毫秒或亚毫秒级别。</p>
</li>
<li><p><strong>应用场景</strong>：SNTP 服务器被广泛应用于需要时间同步的各种网络设备和系统中。它们包括计算机网络、服务器、路由器、交换机、工业自动化系统等。这些设备和系统需要保持时间一致性，以确保协调的操作、事件记录和一致的时间戳。</p>
</li>
<li><p><strong>配置和管理</strong>：SNTP 服务器的配置和管理可以通过设置服务器软件或设备上的相关参数来完成。可以指定时间源、同步频率、服务器身份验证、时间校准方式等。</p>
</li>
</ol>
<p>需要注意的是，SNTP 服务器是一种基本的时间同步服务，如果需要更高精度和更复杂的时间同步功能，可以考虑使用更强大的 NTP 服务器。</p>
<p>希望这些详解对 SNTP 服务器有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="SNTP-server-是什么"><a href="#SNTP-server-是什么" class="headerlink" title="SNTP server 是什么"></a>SNTP server 是什么</h2><p>SNTP（Simple Network Time Protocol）服务器是一种提供时间同步服务的网络服务器。SNTP 是一种基于网络的时间同步协议，它允许计算机和其他网络设备通过网络获取准确的时间信息。</p>
<p>SNTP 服务器的主要功能是响应客户端的时间同步请求，并向客户端提供准确的时间戳。客户端可以通过与 SNTP 服务器进行通信，获取服务器上的当前时间，并将本地时间与服务器时间进行校准，以确保计算机和网络设备的时间与参考时间保持一致。</p>
<p>SNTP 服务器通常连接到一个时间源（如国家时间标准机构或互联网上的其他可靠时间服务器），以获取准确的时间信息。服务器可以使用各种时间同步方法，如网络协议（如NTP、SNTP）、GPS（全球定位系统）或其他时钟源，来确保提供精确的时间。</p>
<p>SNTP 服务器的应用场景包括网络中的各种设备和系统，例如计算机网络、服务器、路由器、交换机、工业自动化系统等，它们需要时间同步以进行协调的操作和事件记录。</p>
<p>需要注意的是，SNTP 是 NTP（Network Time Protocol）的简化版本，去除了一些复杂的功能和算法，主要用于提供基本的时间同步服务。如果需要更高精度和更复杂的时间同步功能，可以考虑使用 NTP 协议。</p>
<p>希望对 SNTP 服务器有了更好的理解！如果您有更多问题，请随时提问。</p>
<h2 id="http-info-cern-ch"><a href="#http-info-cern-ch" class="headerlink" title="http://info.cern.ch/"></a><a target="_blank" rel="noopener" href="http://info.cern.ch/">http://info.cern.ch/</a></h2><p><a target="_blank" rel="noopener" href="http://info.cern.ch/">http://info.cern.ch/</a> 是一个网站，它被认为是世界上第一个公开的网站。它由欧洲核子研究组织（CERN）的计算机科学家蒂姆·伯纳斯-李（Tim Berners-Lee）于1991年创建。这个网站最初是为了分享关于CERN项目的信息和文档，以及介绍万维网（World Wide Web）的概念和原理。</p>
<p>蒂姆·伯纳斯-李是万维网的发明者之一，他在CERN工作期间创建了第一个网页浏览器和服务器，并且将这些技术开放给了公众。这个网站的主页上展示了一些简单的超链接，以及一些关于万维网的介绍性文本。</p>
<p>虽然这个网站的内容相对简单，但它标志着万维网的起源，并且对互联网的发展产生了深远的影响。如今，CERN的网站已经发展成为一个包含大量科学研究和实验信息的综合性门户网站，而<a target="_blank" rel="noopener" href="http://info.cern.ch/%E5%88%99%E4%BD%9C%E4%B8%BA%E4%B8%87%E7%BB%B4%E7%BD%91%E7%9A%84%E5%8E%86%E5%8F%B2%E9%81%97%E8%BF%B9%E8%A2%AB%E4%BF%9D%E7%95%99%E4%B8%8B%E6%9D%A5%EF%BC%8C%E4%BB%A5%E7%BA%AA%E5%BF%B5%E4%B8%87%E7%BB%B4%E7%BD%91%E7%9A%84%E8%AF%9E%E7%94%9F%E3%80%82">http://info.cern.ch/则作为万维网的历史遗迹被保留下来，以纪念万维网的诞生。</a></p>
<h2 id="TCP-服务-和-HTTP-服务"><a href="#TCP-服务-和-HTTP-服务" class="headerlink" title="TCP 服务 和 HTTP 服务"></a>TCP 服务 和 HTTP 服务</h2><p>TCP服务和HTTP服务都是基于TCP协议的网络服务，但它们在协议和功能上有一些区别。</p>
<p><strong>TCP服务</strong>：</p>
<ul>
<li>TCP（传输控制协议）是一种面向连接的协议，用于在网络上可靠地传输数据。</li>
<li>TCP服务通过在服务器和客户端之间建立持久的双向通信连接来传输数据。</li>
<li>TCP服务通常基于自定义的应用层协议，可以通过定义特定的数据格式和通信规则来进行数据交换。</li>
<li>TCP服务可以是自定义的、专用的服务，用于在应用程序之间进行数据传输和通信。</li>
</ul>
<p><strong>HTTP服务</strong>：</p>
<ul>
<li>HTTP（超文本传输协议）是一种应用层协议，用于在 Web 上传输超文本文档和其他资源。</li>
<li>HTTP服务使用TCP作为传输协议，通过建立连接并使用HTTP协议进行通信。</li>
<li>HTTP服务使用请求-响应模型，客户端发送HTTP请求，服务器返回HTTP响应。</li>
<li>HTTP服务遵循特定的语法和规范，定义了请求方法（GET、POST等）、头部字段（如Content-Type、User-Agent等）和响应状态码（如200 OK、404 Not Found等）等。</li>
</ul>
<p>总结：<br>TCP服务是一种通用的、自定义的数据传输服务，而HTTP服务是一种基于TCP的特定协议，用于在Web上进行文档和资源的传输。TCP服务可以用于构建各种自定义的应用程序通信，而HTTP服务则专注于Web应用程序的数据交换和传输。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Math/2024-05-22-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Math/2024-05-22-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">线性代数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>线性代数相关笔记</li>
</ul>
<h2 id="线性代数是什么"><a href="#线性代数是什么" class="headerlink" title="线性代数是什么"></a>线性代数是什么</h2><p>线性代数是数学的一个分支，主要研究向量空间和线性映射的代数结构。它涉及向量、矩阵、线性方程组、线性变换等概念，并在各种学科和应用领域中有广泛的应用。以下是线性代数的一些主要概念：</p>
<ol>
<li><p><strong>向量（Vector）：</strong> 向量是有大小和方向的量，常用箭头表示。在线性代数中，向量通常表示为一列有序数，例如 ( \mathbf{v} &#x3D; \begin{bmatrix} v_1 \ v_2 \ \vdots \ v_n \end{bmatrix} )。</p>
</li>
<li><p><strong>向量空间（Vector Space）：</strong> 向量空间是一组满足一定条件的向量的集合，其中定义了向量的加法和数乘运算，并满足一些基本性质。</p>
</li>
<li><p><strong>矩阵（Matrix）：</strong> 矩阵是一个二维的数组，由数值组成。在线性代数中，矩阵通常用于表示线性变换，解线性方程组等。</p>
</li>
<li><p><strong>线性变换（Linear Transformation）：</strong> 线性变换是一个将一个向量空间映射到另一个向量空间的函数，满足线性性质。线性变换可以用矩阵表示。</p>
</li>
<li><p><strong>行列式（Determinant）：</strong> 行列式是一个与方阵相关的数值，用于描述线性变换对体积伸缩的影响。它在计算矩阵的逆、解线性方程组等方面很重要。</p>
</li>
<li><p><strong>特征值与特征向量（Eigenvalues and Eigenvectors）：</strong> 对于一个线性变换，特征值描述了变换的伸缩因子，而特征向量则是在变换下保持方向不变的向量。</p>
</li>
<li><p><strong>内积空间和外积空间（Inner Product Space and Outer Product Space）：</strong> 内积空间定义了向量之间的内积（点乘）运算，而外积空间定义了向量之间的外积运算。</p>
</li>
</ol>
<p>线性代数在科学、工程、计算机科学等多个领域中都具有重要作用。它为许多数学问题的建模和求解提供了强大的工具，同时也是其他高阶数学分支的基础。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Network/2024-05-22-http_1_%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Network/2024-05-22-http_1_%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">http_1_协议基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>HTTP协议理论基础知识</li>
</ul>
<h2 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h2><ul>
<li><p>分块传输编码(Chunked transfer encoding)是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP&#x2F;1.1）中提供。</p>
</li>
<li><p>通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度。数据的长度很重要，因为客户端需要知道哪里是应答消息的结束，以及后续应答消息的开始。然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。通常数据块的大小是一致的，但也不总是这种情况。</p>
</li>
<li><p>分块传输编码的原理</p>
<ul>
<li>HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的</li>
<li>分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。</li>
<li>HTTP服务器有时使用压缩 （gzip或deflate）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。</li>
</ul>
</li>
<li><p>分块传输编码的格式</p>
<ul>
<li>如果一个HTTP消息（包括客户端发送的请求消息或服务器返回的应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束</li>
<li>每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个CRLF （回车及换行），然后是数据本身，最后块CRLF结束。在一些实现中，块大小和CRLF之间填充有白空格（0x20）。</li>
<li>最后一块是单行，由块大小（0），一些可选的填充白空格，以及CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段</li>
<li>消息最后以CRLF结尾</li>
</ul>
</li>
</ul>
<h2 id="HTTP-Content-Type"><a href="#HTTP-Content-Type" class="headerlink" title="HTTP Content-Type"></a>HTTP Content-Type</h2><ul>
<li><p>Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。</p>
</li>
<li><p>Content-Type 标头告诉客户端实际返回的内容的内容类型。</p>
</li>
<li><p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Type: multipart/form-data; boundary=something</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见的媒体格式类型如下：</p>
<ul>
<li>text&#x2F;html ： HTML格式</li>
<li>text&#x2F;plain ：纯文本格式</li>
<li>text&#x2F;xml ： XML格式</li>
<li>image&#x2F;gif ：gif图片格式</li>
<li>image&#x2F;jpeg ：jpg图片格式</li>
<li>image&#x2F;png：png图片格式</li>
</ul>
</li>
<li><p>以application开头的媒体格式类型：</p>
<ul>
<li>application&#x2F;xhtml+xml ：XHTML格式</li>
<li>application&#x2F;xml： XML数据格式</li>
<li>application&#x2F;atom+xml ：Atom XML聚合格式</li>
<li>application&#x2F;json： JSON数据格式</li>
<li>application&#x2F;pdf：pdf格式</li>
<li>application&#x2F;msword ： Word文档格式</li>
<li>application&#x2F;octet-stream ： 二进制流数据（如常见的文件下载）</li>
<li>application&#x2F;x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据的格式）</li>
</ul>
</li>
<li><p>另外一种常见的媒体格式是上传文件之时使用的：</p>
</li>
<li><p>multipart&#x2F;form-data ： 需要在表单中进行文件上传时，就需要使用该格式</p>
</li>
</ul>
<h2 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h2><p>HTTP 请求报文由请求行（Request Line）、请求头部（Headers）和请求主体（Body）三部分组成。下面是 HTTP 请求报文的一般格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;请求方法&gt; &lt;请求目标&gt; &lt;协议版本&gt;</span><br><span class="line">&lt;请求头部字段&gt;: &lt;值&gt;</span><br><span class="line">&lt;请求头部字段&gt;: &lt;值&gt;</span><br><span class="line">...</span><br><span class="line">&lt;空行&gt;</span><br><span class="line">&lt;请求主体&gt;</span><br></pre></td></tr></table></figure>

<p>其中，各部分的含义如下：</p>
<ol>
<li>请求方法（Request Method）：表示客户端请求的动作类型，常见的方法有 GET、POST、PUT、DELETE 等。</li>
<li>请求目标（Request Target）：指定请求的目标资源的位置，可以是一个 URL 或绝对路径。</li>
<li>协议版本（Protocol Version）：指定所使用的 HTTP 协议的版本，通常是 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</li>
<li>请求头部字段（Headers）：包含了关于请求的附加信息，每个字段都以字段名和对应的值组成，每个字段占据一行。</li>
<li>空行：表示请求头部结束的标志，用于与请求主体进行分隔。</li>
<li>请求主体（Body）：可选的，包含了实际要发送给服务器的数据，比如表单数据或上传的文件内容。</li>
</ol>
<p>以下是一个示例 HTTP 请求报文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /api/users HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 48</span><br><span class="line"></span><br><span class="line">&#123;&quot;username&quot;: &quot;john_doe&quot;, &quot;password&quot;: &quot;secretpassword&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中：</p>
<ul>
<li>请求方法为 <code>POST</code>，请求目标为 <code>/api/users</code>，协议版本为 <code>HTTP/1.1</code>。</li>
<li>请求头部包含了 <code>Host</code>、<code>Content-Type</code> 和 <code>Content-Length</code> 等字段，用于指定主机名、请求体的类型和长度等信息。</li>
<li>空行表示请求头部结束。</li>
<li>请求主体为一个 JSON 格式的字符串，包含了用户名和密码的数据。</li>
</ul>
<p>请注意，请求报文中的每一行都应该以回车符（\r）和换行符（\n）作为行结束符号。请求头部字段和值之间使用冒号和空格进行分隔（例如 <code>Content-Type: application/json</code>）。</p>
<p>以上是 HTTP 请求报文的基本结构，实际的请求报文内容和格式会根据具体的请求需求和要求而有所不同。</p>
<hr>
<h2 id="HTTP-协议文档"><a href="#HTTP-协议文档" class="headerlink" title="HTTP 协议文档"></a>HTTP 协议文档</h2><p>HTTP协议的官方文档是由互联网工程任务组（IETF）发布的一系列文档，主要包括以下两个规范：</p>
<ol>
<li><p>HTTP&#x2F;1.1规范：HTTP&#x2F;1.1是当前广泛使用的HTTP协议版本。其规范文档定义了HTTP&#x2F;1.1协议的语义、语法、请求方法、状态码、首部字段、缓存机制等各个方面的内容。HTTP&#x2F;1.1的规范文档由RFC 2616定义。</p>
<p>可以通过以下链接访问HTTP&#x2F;1.1的规范文档：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616">RFC 2616 - Hypertext Transfer Protocol – HTTP&#x2F;1.1</a></li>
</ul>
</li>
<li><p>HTTP&#x2F;2规范：HTTP&#x2F;2是HTTP协议的下一代版本，旨在提供更高的性能和效率。它引入了二进制协议、多路复用、头部压缩、服务器推送等新特性。HTTP&#x2F;2的规范文档由RFC 7540定义。</p>
<p>可以通过以下链接访问HTTP&#x2F;2的规范文档：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7540">RFC 7540 - Hypertext Transfer Protocol Version 2 (HTTP&#x2F;2)</a></li>
</ul>
</li>
</ol>
<p>除了上述主要的HTTP协议规范文档外，IETF还发布了其他与HTTP相关的文档，包括扩展协议、安全性、代理、缓存等方面的规范和建议。</p>
<p>可以通过IETF的官方网站访问这些文档的在线版本：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/wg/httpbis/documents/">IETF - Hypertext Transfer Protocol (HTTP) Working Group</a></li>
</ul>
<p>注意：HTTP&#x2F;1.1的规范文档（RFC 2616）发布于1999年，并于2014年被废弃。后续对HTTP&#x2F;1.1的修订和更新工作由HTTPbis工作组负责，并将最新的规范文档发布为一系列独立的RFC文档。因此，最新的HTTP&#x2F;1.1规范文档应该参考HTTPbis工作组发布的相关文档。</p>
<hr>
<h2 id="HTTP-表单是什么"><a href="#HTTP-表单是什么" class="headerlink" title="HTTP 表单是什么"></a>HTTP 表单是什么</h2><p>HTTP表单（HTTP form）是一种用于在Web应用程序中收集和提交用户数据的机制。它是基于HTTP协议的一种数据传输方式，通过在Web页面上展示给用户一组输入字段（例如文本框、复选框、下拉列表等），用户可以在这些字段中输入数据，并将数据提交到服务器进行处理。</p>
<p>HTTP表单常用于实现用户注册、登录、搜索、提交评论等交互性操作。用户在表单中输入数据后，通过点击提交按钮，表单数据将被封装为HTTP请求发送给服务器。服务器接收到请求后，可以解析表单数据，并根据需要进行相应的处理，例如保存数据到数据库、执行搜索操作、生成动态内容等。</p>
<p>HTTP表单通过使用HTML（Hypertext Markup Language）和一些特定的表单元素来定义和呈现表单。HTML表单元素包括<code>&lt;form&gt;</code>标签、<code>&lt;input&gt;</code>标签、<code>&lt;select&gt;</code>标签、<code>&lt;textarea&gt;</code>标签等，它们用于定义表单的结构、各种输入字段以及提交按钮。</p>
<p>在提交表单时，可以使用不同的HTTP请求方法，常见的有GET和POST方法。GET方法将表单数据附加在URL的查询字符串中，而POST方法将表单数据包含在请求的主体中。这取决于表单的性质和数据的敏感性。</p>
<p>在服务器端，可以使用不同的技术（如PHP、Python、Java等）来处理接收到的表单数据。这些技术提供了解析和处理表单数据的函数、类或库，使开发人员能够轻松地处理表单提交的数据，并进行相应的业务逻辑操作。</p>
<p>总结起来，HTTP表单是一种用于在Web应用程序中收集和提交用户数据的机制，它利用HTML表单元素定义和呈现表单，通过HTTP协议将用户输入的数据发送到服务器进行处理。</p>
<hr>
<h2 id="HTTP协议-表单数据"><a href="#HTTP协议-表单数据" class="headerlink" title="HTTP协议 表单数据"></a>HTTP协议 表单数据</h2><p>HTTP 协议中的表单数据是通过 POST 请求或 GET 请求来传输的，具体的格式和处理方式如下：</p>
<ol>
<li><p>GET 请求传输表单数据：</p>
<ul>
<li>表单数据会被附加在 URL 的查询字符串中，即通过 URL 参数传递。</li>
<li>数据以键值对的形式出现，使用<code>key=value</code>的格式。</li>
<li>多个键值对之间使用<code>&amp;</code>符号进行分隔。</li>
</ul>
</li>
<li><p>POST 请求传输表单数据：</p>
<ul>
<li>表单数据会被放置在请求体中，并通过 Content-Type 头部指定数据的编码方式，常见的编码方式有 application&#x2F;x-www-form-urlencoded 和 multipart&#x2F;form-data。</li>
<li>application&#x2F;x-www-form-urlencoded 编码方式：<ul>
<li>表单数据以键值对的形式出现，使用<code>key=value</code>的格式。</li>
<li>多个键值对之间使用<code>&amp;</code>符号进行分隔。</li>
</ul>
</li>
<li>multipart&#x2F;form-data 编码方式：<ul>
<li>表单数据会以多部分的形式进行传输。</li>
<li>每个部分都有自己的头部信息，包括 Content-Disposition 和 Content-Type。</li>
<li>表单字段会出现在各自的部分中，以字段名作为标识。</li>
<li>文件上传时，文件数据会以二进制形式出现在对应的部分中。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>对于服务器端的处理，常见的 Web 框架会提供相应的解析和处理表单数据的功能，开发者可以根据框架的文档和要求来编写处理表单数据的代码。</p>
<p>需要注意的是，HTTP 协议的表单数据传输并不加密，因此在传输敏感信息时应使用安全的 HTTPS 协议来保护数据的安全性。</p>
<h2 id="application-x-www-form-urlencoded-详解"><a href="#application-x-www-form-urlencoded-详解" class="headerlink" title="application&#x2F;x-www-form-urlencoded 详解"></a>application&#x2F;x-www-form-urlencoded 详解</h2><p><code>application/x-www-form-urlencoded</code>是一种常见的MIME类型，用于在HTTP请求中传输表单数据。它是一种URL编码的数据格式，适用于通过HTTP POST请求将表单数据发送到服务器。</p>
<p>详细解释<code>application/x-www-form-urlencoded</code>的含义如下：</p>
<ol>
<li><p>数据格式：<code>application/x-www-form-urlencoded</code>表示表单数据以URL编码的形式进行传输。它使用特定的编码规则将表单字段和值进行编码，并使用”&amp;”符号分隔字段。例如，假设有一个表单字段<code>name</code>的值为<code>John Doe</code>，编码后的数据格式将是<code>name=John%20Doe</code>。</p>
</li>
<li><p>字符编码：<code>application/x-www-form-urlencoded</code>使用URL编码对特殊字符进行转义。这样可以确保数据能够在HTTP请求中正确传输，不会被解析为URL的特殊字符或者参数分隔符。</p>
</li>
<li><p>请求方法：<code>application/x-www-form-urlencoded</code>通常与HTTP POST请求方法一起使用。表单数据会被封装在请求的主体部分，并以<code>key=value</code>的形式进行传输。服务器端可以根据具体的编程语言或框架，解析这些键值对数据并进行处理。</p>
</li>
<li><p>Content-Type头部：在HTTP请求中，<code>Content-Type</code>头部用于指定请求主体的媒体类型。当使用<code>application/x-www-form-urlencoded</code>传输表单数据时，可以设置<code>Content-Type</code>头部为<code>application/x-www-form-urlencoded</code>来标识数据格式。</p>
</li>
</ol>
<p>使用示例：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/submit-form</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">name</span>=John%<span class="number">20</span>Doe&amp;email=johndoe%<span class="number">40</span>example.com&amp;message=Hello%<span class="number">20</span>World</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们通过HTTP POST请求将表单数据发送到<code>example.com/submit-form</code>路径。请求头部指定了<code>Content-Type: application/x-www-form-urlencoded</code>，表示表单数据以<code>application/x-www-form-urlencoded</code>格式进行传输。请求主体部分包含了编码后的表单数据。</p>
<p>总结：<code>application/x-www-form-urlencoded</code>是一种URL编码的数据格式，常用于HTTP POST请求中传输表单数据。它使用特定的编码规则对字段和值进行编码，并以<code>key=value</code>的形式传输数据。服务器端可以根据Content-Type头部为<code>application/x-www-form-urlencoded</code>来解析和处理这些数据。</p>
<hr>
<h2 id="HTTP协议-响应报文"><a href="#HTTP协议-响应报文" class="headerlink" title="HTTP协议 响应报文"></a>HTTP协议 响应报文</h2><p>HTTP协议中的响应报文包含多个字段，每个字段都有特定的作用和含义。以下是HTTP响应报文中常见的字段及其详细解释：</p>
<ol>
<li><p>状态行（Status Line）：状态行包含了HTTP协议的版本号、状态码和状态消息。它的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>其中，<code>HTTP/1.1</code>表示使用的HTTP版本号，<code>200</code>是状态码，<code>OK</code>是状态消息。</p>
</li>
<li><p>响应头（Response Headers）：响应头包含了关于响应的附加信息。它的格式为<code>字段名: 值</code>，每个字段占据一行。常见的响应头字段包括：</p>
<ul>
<li><code>Content-Type</code>：指定响应体的媒体类型，例如<code>text/html</code>表示HTML文档。</li>
<li><code>Content-Length</code>：指定响应体的长度，以字节为单位。</li>
<li><code>Date</code>：指定响应发送的日期和时间。</li>
<li><code>Server</code>：指定服务器的软件名称和版本号。</li>
<li><code>Set-Cookie</code>：用于在客户端存储会话信息的HTTP Cookie。</li>
</ul>
</li>
<li><p>空行（Blank Line）：空行用于分隔响应头和响应体。</p>
</li>
<li><p>响应体（Response Body）：响应体包含了实际的响应数据，例如网页的HTML内容或者文件的内容。</p>
</li>
</ol>
<p>需要注意的是，除了以上常见的字段之外，HTTP响应报文还可以包含其他自定义的字段，具体的字段内容和含义可以根据应用程序和服务器的需求进行定义和解析。</p>
<hr>
<h2 id="HTTP-Cache-Control"><a href="#HTTP-Cache-Control" class="headerlink" title="HTTP Cache-Control"></a>HTTP Cache-Control</h2><p>HTTP的Cache-Control字段用于控制缓存的行为，指示缓存如何处理响应以及如何在将来的请求中使用缓存。Cache-Control字段可以在HTTP请求头和响应头中使用。</p>
<p>在HTTP请求头中，Cache-Control字段用于指示客户端对服务器的请求希望如何进行缓存。常见的指令包括：</p>
<ul>
<li><code>no-cache</code>：表示客户端要求服务器每次都提供最新的响应，不使用缓存副本。</li>
<li><code>no-store</code>：表示客户端和中间缓存都不应该存储请求或响应的任何副本。</li>
<li><code>max-age=&lt;seconds&gt;</code>：表示响应的有效时间，以秒为单位。客户端可以在这个时间内使用缓存副本而不向服务器发起新的请求。</li>
<li><code>min-fresh=&lt;seconds&gt;</code>：表示客户端希望在指定的时间内获取新的响应，而不使用缓存。如果缓存的响应的新鲜度低于指定的时间，客户端将向服务器发起新的请求。</li>
<li><code>max-stale[=&lt;seconds&gt;]</code>：表示客户端允许使用过期的缓存副本，即使超过了缓存的有效时间。可选的秒数表示允许的最大过期时间。</li>
<li><code>only-if-cached</code>：表示客户端只接受缓存的响应，不向服务器发起新的请求。</li>
</ul>
<p>在HTTP响应头中，Cache-Control字段用于指示缓存如何处理响应。常见的指令包括：</p>
<ul>
<li><code>public</code>：表示响应可以被任何缓存（包括客户端和中间缓存）缓存。</li>
<li><code>private</code>：表示响应只能被客户端缓存，中间缓存不能缓存该响应。</li>
<li><code>no-cache</code>：表示响应可以被缓存，但必须先与服务器确认其有效性。</li>
<li><code>no-store</code>：表示响应不能被缓存，客户端和中间缓存都不应该存储该响应。</li>
<li><code>max-age=&lt;seconds&gt;</code>：表示响应的有效时间，以秒为单位。</li>
<li><code>s-maxage=&lt;seconds&gt;</code>：表示响应在共享缓存（如代理服务器）中的有效时间，以秒为单位。</li>
</ul>
<p>以上是Cache-Control字段的一些常见指令和用法，可以根据具体的需求和情况进行灵活设置，以实现更好的缓存控制和性能优化。</p>
<hr>
<h2 id="HTTP-Cache-control-must-revalidate"><a href="#HTTP-Cache-control-must-revalidate" class="headerlink" title="HTTP Cache-control must-revalidate"></a>HTTP Cache-control must-revalidate</h2><p>HTTP头字段”Cache-Control: must-revalidate”用于指示客户端在使用缓存响应之前必须与服务器进行重新验证，即使缓存的响应具有新鲜的过期时间。</p>
<p>当响应中包含”Cache-Control: must-revalidate”指令时，意味着缓存的响应在未经服务器重新验证之前不应被视为有效。客户端必须向服务器发送一个条件请求（通常是带有”If-Modified-Since”或”If-None-Match”头字段），以检查缓存的响应是否仍然有效。</p>
<p>如果服务器以304 Not Modified状态码响应，表示缓存的响应仍然有效，客户端可以使用缓存副本。然而，如果服务器响应了新版本的资源或不同的状态码，客户端需要相应地更新其缓存。</p>
<p>“Cache-Control: must-revalidate”指令在确保缓存的响应是最新且准确的情况下非常有用。通过要求重新验证，它有助于保持客户端和服务器之间的数据一致性。</p>
<p>以下是带有”Cache-Control: must-revalidate”指令的HTTP响应头的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: must-revalidate</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br></pre></td></tr></table></figure>

<p>在上述示例中，”Cache-Control: must-revalidate”头字段指示客户端在使用缓存响应之前必须重新验证。</p>
<p>需要注意的是，”must-revalidate”只是Cache-Control头字段的一个指令，还可以有其他指令，如”max-age”或”no-cache”等，用于修改缓存行为。这些指令的组合可以提供对特定资源的缓存处理进行精细控制。</p>
<hr>
<h2 id="HTTP-Cache-control-max-age"><a href="#HTTP-Cache-control-max-age" class="headerlink" title="HTTP Cache-control max-age"></a>HTTP Cache-control max-age</h2><p>HTTP头字段”Cache-Control: max-age”用于指定缓存的响应在被认为过期之前的最长时间（以秒为单位）。</p>
<p>“max-age”指令用于定义响应的新鲜度期限，即客户端可以在该期限内使用缓存的响应而无需向服务器发送请求。如果一个资源的缓存副本在”max-age”指定的时间内仍然有效，则客户端可以使用该缓存副本而无需向服务器进行请求。</p>
<p>以下是一个使用”Cache-Control: max-age”的HTTP响应头的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: max-age=3600</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br></pre></td></tr></table></figure>

<p>在上述示例中，”Cache-Control: max-age&#x3D;3600”指示客户端可以在3600秒（1小时）内使用该缓存的响应而无需向服务器发送请求。如果在此期限内发起的请求与此资源相关，则客户端可以直接使用缓存副本。</p>
<p>“max-age”指令是相对于响应的日期和时间来计算的。当客户端接收到带有”max-age”指令的响应时，它会根据响应的日期和时间以及”max-age”指定的秒数来计算出响应的有效期限。</p>
<p>需要注意以下几点：</p>
<ol>
<li><p>“max-age”指令优先级高于其他指令，如”no-cache”或”must-revalidate”。如果同时存在这些指令，”max-age”会覆盖它们。</p>
</li>
<li><p>“max-age”指令不依赖于服务器的时间，而是依赖于响应中的日期和时间。这可以避免因为客户端和服务器之间的时钟不一致而导致缓存失效。</p>
</li>
<li><p>如果同时存在”Expires”头字段和”max-age”指令，”max-age”优先级更高。”max-age”用于指定相对时间，而”Expires”用于指定绝对时间。</p>
</li>
</ol>
<p>总结起来，”Cache-Control: max-age”指令用于指定缓存的响应在被认为过期之前的最长时间。客户端可以在指定的时间内使用缓存副本而无需发送请求。这可以提高性能并减轻服务器负载，特别是对于不经常更改的静态资源。</p>
<hr>
<h2 id="HTTP-Pragma"><a href="#HTTP-Pragma" class="headerlink" title="HTTP Pragma"></a>HTTP Pragma</h2><p>HTTP Pragma字段是一种HTTP头字段，用于向服务器传递特定的指令或控制信息。它是HTTP&#x2F;1.0版本中引入的，目的是为了提供与缓存相关的指令。</p>
<p>在HTTP请求头中，Pragma字段可以用于向服务器发送请求指令。在实践中，Pragma字段很少被使用，因为在HTTP&#x2F;1.1中引入了更强大和灵活的Cache-Control字段来管理缓存。常见的Pragma指令包括：</p>
<ul>
<li><code>no-cache</code>：表示客户端要求服务器每次都提供最新的响应，不使用缓存副本。与Cache-Control中的<code>no-cache</code>指令功能类似。</li>
</ul>
<p>在HTTP响应头中，Pragma字段用于向客户端传递响应的指令或信息。在实践中，Pragma字段同样很少被使用，因为Cache-Control字段已经提供了更广泛和强大的缓存控制功能。</p>
<p>需要注意的是，HTTP&#x2F;1.1规范中建议不再使用Pragma字段来控制缓存，而是使用Cache-Control字段。因此，当处理HTTP协议时，应优先考虑Cache-Control字段，而将Pragma字段视为过时和不推荐使用的。</p>
<hr>
<h2 id="HTTP-Expires"><a href="#HTTP-Expires" class="headerlink" title="HTTP Expires"></a>HTTP Expires</h2><p>HTTP Expires字段是一种响应头字段，用于指定响应的过期时间。它告诉客户端在过期时间之前可以直接使用缓存的响应，而无需向服务器发起新的请求。</p>
<p>Expires字段的值是一个日期时间，表示响应的过期时间点。客户端可以在该时间点之前使用缓存的响应。如果客户端在过期时间之后发起请求，缓存将被视为无效，客户端需要向服务器获取最新的响应。</p>
<p>例如，下面是一个使用Expires字段的响应头示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Expires: Thu, 17 Jun 2023 12:00:00 GMT</span><br></pre></td></tr></table></figure>

<p>在这个例子中，Expires字段的值是”Thu, 17 Jun 2023 12:00:00 GMT”，表示响应的过期时间为2023年6月17日12:00:00 GMT。在过期时间之前，客户端可以直接使用缓存的响应。</p>
<p>需要注意的是，Expires字段的缺点是它使用的是服务器的时间，而客户端的时间可能与服务器的时间不一致。为了解决这个问题，HTTP&#x2F;1.1引入了Cache-Control字段，其中的<code>max-age</code>指令提供了更可靠的缓存过期时间控制，并以秒为单位指定相对时间。相比之下，Expires字段更适用于在HTTP&#x2F;1.0环境下进行缓存控制。在HTTP&#x2F;1.1中，Cache-Control字段被认为是更优先和更可靠的缓存控制机制。</p>
<hr>
<h2 id="HTTP-Content-Type-1"><a href="#HTTP-Content-Type-1" class="headerlink" title="HTTP Content-Type"></a>HTTP Content-Type</h2><p>HTTP Content-Type是一种HTTP头字段，用于指示传输的实体（如请求体或响应体）的媒体类型（Media Type）。它告诉接收方如何解析和处理实体的内容。</p>
<p>Content-Type字段通常出现在HTTP请求头和响应头中。在请求头中，它指示客户端发送的实体的媒体类型。在响应头中，它指示服务器返回的实体的媒体类型。</p>
<p>Content-Type字段的值通常由两部分组成：</p>
<ol>
<li>主类型（Main Type）：表示实体的大类，例如文本（text）、图像（image）、音频（audio）、视频（video）、应用程序（application）等。</li>
<li>子类型（Sub Type）：表示主类型下的具体细分，例如文本可以是纯文本（plain）或HTML文档（html），图像可以是JPEG（jpeg）或PNG（png）等。</li>
</ol>
<p>Content-Type字段的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: 主类型/子类型</span><br></pre></td></tr></table></figure>

<p>例如，下面是一些常见的Content-Type值示例：</p>
<ul>
<li>文本类型：<ul>
<li>纯文本：<code>text/plain</code></li>
<li>HTML文档：<code>text/html</code></li>
<li>XML文档：<code>text/xml</code></li>
</ul>
</li>
<li>图像类型：<ul>
<li>JPEG图像：<code>image/jpeg</code></li>
<li>PNG图像：<code>image/png</code></li>
<li>GIF图像：<code>image/gif</code></li>
</ul>
</li>
<li>音频类型：<ul>
<li>MP3音频：<code>audio/mpeg</code></li>
<li>WAV音频：<code>audio/wav</code></li>
</ul>
</li>
<li>视频类型：<ul>
<li>MPEG视频：<code>video/mpeg</code></li>
<li>MP4视频：<code>video/mp4</code></li>
</ul>
</li>
<li>应用程序类型：<ul>
<li>JSON数据：<code>application/json</code></li>
<li>PDF文档：<code>application/pdf</code></li>
</ul>
</li>
</ul>
<p>通过Content-Type字段，客户端和服务器可以彼此了解和解释实体的内容类型，从而正确处理和解析数据。这对于正确显示网页、处理文件上传、进行API通信等非常重要。</p>
<h2 id="HTTP-Content-Type-multipart-x-mixed-replace"><a href="#HTTP-Content-Type-multipart-x-mixed-replace" class="headerlink" title="HTTP Content-Type multipart&#x2F;x-mixed-replace"></a>HTTP Content-Type multipart&#x2F;x-mixed-replace</h2><p>HTTP Content-Type字段中的<code>multipart/x-mixed-replace</code>是一种特殊的媒体类型，用于在单个HTTP响应中连续发送多个部分（或实体）。它常用于实时流式传输或服务器推送，其中每个部分都代表一个独立的数据块或事件。</p>
<p><code>multipart/x-mixed-replace</code>的工作原理是，服务器发送一系列的部分，每个部分都有自己的Content-Type和内容。接收方（通常是浏览器）会逐个解析和处理这些部分，并按照其各自的Content-Type进行相应的处理。</p>
<p>每个部分由一个唯一的分隔符（boundary）分隔。分隔符是一个随机生成的字符串，用于标识部分的起始和结束。在响应中，Content-Type字段中的boundary参数指定了分隔符。</p>
<p>下面是一个示例HTTP响应头，展示了使用<code>multipart/x-mixed-replace</code>的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: multipart/x-mixed-replace; boundary=boundary123</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>multipart/x-mixed-replace</code>指定了响应使用该媒体类型。<code>boundary=boundary123</code>指定了分隔符为”boundary123”。</p>
<p>响应体的内容将按照以下格式进行发送：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--boundary123</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">&lt;JPEG image data&gt;</span><br><span class="line">--boundary123</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">Some text data</span><br><span class="line">--boundary123--</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先发送了一个JPEG图像部分，然后是一个纯文本部分。每个部分都以<code>--boundary123</code>开头，并以<code>--boundary123--</code>表示结束。</p>
<p>客户端会解析每个部分，并根据各自的Content-Type进行相应的处理，例如显示图像或显示文本数据。</p>
<p><code>multipart/x-mixed-replace</code>的特点是，在接收到一个部分后，客户端会立即丢弃之前接收到的部分。这使得它适用于实时更新的场景，如视频流、监控摄像头等，因为客户端只处理最新的部分，而不会保留之前的部分。</p>
<p>注意：由于<code>multipart/x-mixed-replace</code>在HTTP&#x2F;1.1中没有官方标准，不同的实现可能会有差异。因此，对于具体使用情况，最好查阅相关文档或参考实现的要求。</p>
<hr>
<h2 id="HTTP-Content-Length"><a href="#HTTP-Content-Length" class="headerlink" title="HTTP Content-Length"></a>HTTP Content-Length</h2><p>HTTP Content-Length是一个HTTP响应头字段，用于指示响应体的长度（以字节为单位）。它告诉接收方在接收完指定长度的数据后停止接收，可以用于确定完整的响应体的大小。</p>
<p>Content-Length字段的值是一个十进制整数，表示响应体的字节长度。例如，Content-Length: 1024表示响应体的长度为1024字节。</p>
<p>使用Content-Length字段的好处是接收方可以根据指定的长度来正确读取和处理响应体。这在处理固定长度的数据时非常有用，如文件下载、二进制数据传输等。</p>
<p>以下是一个使用Content-Length字段的HTTP响应头示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 4096</span><br></pre></td></tr></table></figure>

<p>在这个示例中，Content-Length字段的值为4096，表示响应体的长度为4096字节。</p>
<p>需要注意的是，Content-Length字段仅适用于具有确定长度的响应体。对于动态生成的或以流式传输的方式提供的响应，Content-Length字段可能无法准确指示响应体的总长度。在这种情况下，通常使用分块传输编码（chunked transfer encoding）或其他适当的机制来指示响应体的传输方式和结束。</p>
<p>另外，Content-Length字段通常不会出现在HTTP请求头中，因为请求体的长度往往由客户端动态确定，并在请求头中使用Transfer-Encoding或其他字段进行传输长度的指示。</p>
<hr>
<h2 id="HTTP-Connection"><a href="#HTTP-Connection" class="headerlink" title="HTTP Connection"></a>HTTP Connection</h2><p>HTTP Connection字段（或头字段）是一个HTTP请求头和响应头中的字段，用于指示是否需要在请求或响应完成后关闭TCP连接或保持连接打开。</p>
<p>在HTTP&#x2F;1.0中，Connection字段的值可以是”keep-alive”或”close”，分别表示保持连接打开或关闭连接。如果使用”keep-alive”，则表示客户端或服务器希望保持TCP连接打开，以便在后续请求或响应中复用该连接。如果使用”close”，则表示请求或响应完成后关闭连接。</p>
<p>以下是一个示例，在HTTP&#x2F;1.0中使用Connection字段的请求头和响应头：</p>
<p>请求头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /example HTTP/1.0</span><br><span class="line">Host: www.example.com</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>响应头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p>在HTTP&#x2F;1.1中，Connection字段的语义有所变化。它成为一个逐跳（hop-by-hop）头字段，用于指示仅对单个连接有效，而不是整个传输链路。常见的Connection字段值包括：</p>
<ul>
<li>“keep-alive”：表示请求或响应后保持连接打开，以便进行后续请求或响应的复用。</li>
<li>“close”：表示请求或响应完成后关闭连接。</li>
<li>其他特定的头字段：表示请求或响应中有特定的头字段需要逐跳处理，如”Upgrade”、”Transfer-Encoding”等。</li>
</ul>
<p>以下是一个示例，在HTTP&#x2F;1.1中使用Connection字段的请求头和响应头：</p>
<p>请求头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /example HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>响应头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p>需要注意的是，HTTP&#x2F;1.1默认使用持久连接（persistent connection），即默认情况下会保持连接打开。如果不希望保持连接打开，可以在请求头或响应头中使用”Connection: close”指示关闭连接。</p>
<p>在HTTP&#x2F;2中，Connection字段被废弃，取而代之的是使用专门的帧（frame）来管理连接的生命周期。连接的打开和关闭由协议自身管理，而不需要应用层显式地指示。</p>
<p>总之，HTTP Connection字段用于指示是否保持连接打开或关闭，具体的语义和行为取决于HTTP协议版本和字段的值。</p>
<hr>
<h2 id="HTTP-响应报文字段Server"><a href="#HTTP-响应报文字段Server" class="headerlink" title="HTTP 响应报文字段Server"></a>HTTP 响应报文字段Server</h2><p>HTTP响应报文中的<code>Server</code>字段是一个可选的响应头字段，用于指示提供HTTP响应的服务器软件或应用程序的名称和版本信息。</p>
<p><code>Server</code>字段的值通常是服务器软件的名称和版本号的组合。例如，<code>Server: Apache/2.4.29</code>表示使用的是Apache HTTP Server软件的2.4.29版本。</p>
<p>这个字段可以提供有关服务器的一些信息，但并不是强制要求的，因此服务器可以选择是否在响应中包含<code>Server</code>字段。</p>
<p>以下是一个示例HTTP响应头，展示了使用<code>Server</code>字段的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache/2.4.29</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>Server: Apache/2.4.29</code>指示服务器使用的是Apache HTTP Server软件的2.4.29版本。</p>
<p>需要注意的是，由于<code>Server</code>字段提供了有关服务器的信息，因此在安全性方面需要谨慎处理。恶意用户可能会利用这些信息来进行攻击或针对特定的服务器漏洞。</p>
<p>出于安全性的考虑，一些服务器管理员可能选择隐藏或修改<code>Server</code>字段的值，以减少被攻击的风险。这可以通过配置服务器软件或使用专门的安全模块来实现。</p>
<p>总结：<code>Server</code>字段是HTTP响应报文中的一个可选字段，用于指示提供响应的服务器软件或应用程序的名称和版本信息。它提供了有关服务器的一些信息，但在安全性方面需要注意保护。</p>
<hr>
<h2 id="HTTP-Access-Control-Allow-Origin"><a href="#HTTP-Access-Control-Allow-Origin" class="headerlink" title="HTTP Access-Control-Allow-Origin"></a>HTTP Access-Control-Allow-Origin</h2><p>HTTP Access-Control-Allow-Origin是一个HTTP响应头字段，用于指示允许访问资源的跨域请求源。</p>
<p>在跨域资源共享（CORS）机制中，浏览器会在发送跨域请求时向服务器发送一个预检请求（OPTIONS请求），以确定是否允许该跨域请求。服务器在预检请求的响应中可以包含Access-Control-Allow-Origin字段，用于指定允许访问资源的来源。</p>
<p>Access-Control-Allow-Origin字段的值可以是以下三种情况之一：</p>
<ol>
<li><p>具体的源：可以指定一个具体的来源，例如<code>Access-Control-Allow-Origin: https://www.example.com</code>，表示只允许来自<code>https://www.example.com</code>的请求访问资源。</p>
</li>
<li><p>通配符（*）：可以使用通配符来表示允许任何来源的请求访问资源，例如<code>Access-Control-Allow-Origin: *</code>。</p>
</li>
<li><p>不包含该字段：如果响应中不包含Access-Control-Allow-Origin字段，或者该字段的值为空，浏览器会阻止跨域请求访问资源。</p>
</li>
</ol>
<p>需要注意的是，服务器返回的Access-Control-Allow-Origin字段仅在预检请求的响应中才起作用。对于实际的跨域请求，浏览器会根据预检请求中的结果来判断是否允许访问资源。</p>
<p>以下是一个示例，展示了Access-Control-Allow-Origin字段的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Origin: https://www.example.com</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br></pre></td></tr></table></figure>

<p>在上述示例中，Access-Control-Allow-Origin字段的值为<code>https://www.example.com</code>，表示只允许来自该来源的请求访问资源。</p>
<p>通过设置Access-Control-Allow-Origin字段，服务器可以控制哪些跨域请求被允许访问资源，提供了一种基于服务器端的跨域访问控制机制。</p>
<hr>
<h2 id="HTTP-Access-Control-Allow-Methods"><a href="#HTTP-Access-Control-Allow-Methods" class="headerlink" title="HTTP Access-Control-Allow-Methods"></a>HTTP Access-Control-Allow-Methods</h2><p>HTTP Access-Control-Allow-Methods是一个HTTP响应头字段，用于指示服务器支持的跨域请求方法。</p>
<p>在跨域资源共享（CORS）机制中，浏览器会发送一个预检请求（OPTIONS请求）到服务器，以确定是否允许特定跨域请求。预检请求中会包含一个Access-Control-Request-Method字段，用于指示实际请求所使用的方法（如GET、POST、PUT、DELETE等）。</p>
<p>服务器在预检请求的响应中可以包含Access-Control-Allow-Methods字段，用于指示服务器支持的跨域请求方法。</p>
<p>Access-Control-Allow-Methods字段的值是一个逗号分隔的HTTP方法列表，表示服务器允许的跨域请求方法。例如，<code>Access-Control-Allow-Methods: GET, POST, PUT</code>表示服务器允许使用GET、POST和PUT方法的跨域请求。</p>
<p>以下是一个示例，展示了Access-Control-Allow-Methods字段的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Origin: https://www.example.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br></pre></td></tr></table></figure>

<p>在上述示例中，Access-Control-Allow-Methods字段的值为<code>GET, POST, PUT</code>，表示服务器支持GET、POST和PUT方法的跨域请求。</p>
<p>通过设置Access-Control-Allow-Methods字段，服务器可以明确指定支持的跨域请求方法，从而对跨域请求进行细粒度的控制。</p>
<p>需要注意的是，Access-Control-Allow-Methods字段只在预检请求的响应中起作用。对于实际的跨域请求，浏览器会根据预检请求的结果来判断是否允许使用特定的请求方法。</p>
<p>此外，服务器还可以使用其他相关的响应头字段，如Access-Control-Allow-Headers和Access-Control-Allow-Credentials，来进一步控制和配置跨域资源共享。</p>
<p>总结：HTTP Access-Control-Allow-Methods是一个HTTP响应头字段，用于指示服务器支持的跨域请求方法。通过设置该字段，服务器可以明确指定允许的跨域请求方法，实现跨域资源共享的细粒度控制。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Network/2024-05-22-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Network/2024-05-22-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">网络设备基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>常用的网络设备基础知识</li>
</ul>
<h2 id="网络交换机"><a href="#网络交换机" class="headerlink" title="网络交换机"></a>网络交换机</h2><ul>
<li><p>网络交换机(Network switch)是一种网络硬件，通过报文交换接收和转发数据到目标设备，它能够在计算机网络上连接不同的设备。一般也简称为交换机</p>
</li>
<li><p>交换机是一种多端口的网桥，在数据链路层使用MAC地址转发数据。通过加入路由功能，一些交换机也可以在网络层转发数据，这种交换机一般被称为三层交换机或者多层交换机。</p>
</li>
<li><p>以太网交换机是网络交换机最常见的形式。第一个以太网交换机由Kalpana公司（1994年被思科收购）推出。在其他类型的网络中，交换机也普遍存在，如光纤通道、异步传输模式和InfiniBand。</p>
</li>
<li><p>中继器会在其所有端口转发相同的数据，让设备自行判断哪些是自己需要的数据，交换机则不同，它只会将数据转发到需要接收的设备</p>
</li>
<li><p>工作原理</p>
<ul>
<li>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过将MAC地址和端口对应，形成一张MAC表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</li>
<li>交换机对数据包的转发是建立在MAC地址——物理地址基础之上的，对于IP网络协议来说，它是透明的，即交换机在转发数据包时，不知道也无须知道信源机和信宿机的IP地址，只需知其物理地址。</li>
<li>交换机在操作过程当中会不断的收集资料去建立它本身的一个地址表，这个表相当简单，它说明了某个MAC地址是在哪个端口上被发现的，所以当交换机收到一个TCP&#x2F;IP 数据包时，它便会查看该数据包的目的MAC地址，核对自己的地址表以确认应该从哪个端口把数据包发出去。由于这个过程比较简单，加上这功能由一崭新硬件进行——ASIC，因此速度相当快。一般只需几十微秒，交换机便可决定一个IP数据包该往哪里送</li>
<li>如果目的地MAC地址不能在地址表中找到时，交换机会把IP 数据包“扩散”出去，即把它从每一个端口中提交去，就如交换机在处理一个收到的广播数据包时一样。二层交换机的弱点正是它处理广播数据包的手法不太有效，比方说，当一个交换机收到一个从TCP&#x2F;IP工作站上发出来的广播数据包时，他便会把该数据包传到所有其他端口去，哪怕有些端口上连的是IPX或DECnet工作站。这样一来，非TCP&#x2F;IP节点的带宽便会受到负面的影响，就算同样的TCP&#x2F;IP节点，如果他们的子网跟发送那个广播数据包的工作站的子网相同，那么他们也会无缘无故地收到一些与他们毫不相干的网络广播，整个网络的效率因此会大打折扣</li>
</ul>
</li>
<li><p>工作方式</p>
<ul>
<li>收到某网段（设为A）MAC地址为X的计算机发给MAC地址为Y的计算机的数据包。交换机从而记下了MAC地址X在网段A。这称为学习（learning）。</li>
<li>交换机还不知道MAC地址Y在哪个网段上，于是向除了A以外的所有网段转发该数据包。这称为泛洪（flooding）。</li>
<li>MAC地址Y的计算机收到该数据包，向MAC地址X发出确认包。交换机收到该包后，从而记录下MAC地址Y所在的网段</li>
<li>交换机向MAC地址X转发确认包。这称为转发（forwarding）</li>
<li>交换机收到一个数据包，查表后发现该数据包的来源地址与目的地址属于同一网段。交换机将不处理该数据包。这称为过滤（filtering）</li>
<li>交换机内部的MAC地址-网段查询表的每条记录采用时间戳记录最后一次访问的时间。早于某个阈值（用户可配置）的记录被清除。这称为老化（aging）。</li>
</ul>
</li>
<li><p>对于全交换（full-switch）局域网，交换机每个端口只连接一台设备，因此不会发生碰撞。交换机也不需要做过滤</p>
</li>
<li><p>工作在OSI不同层级的交换技术</p>
</li>
<li><p>现代商业交换机主要使用以太网接口。提供多端口的二层桥接是以太网交换机的核心功能，而很多交换机也提供其他层级的服务，这种不仅仅提供了桥接功能的交换机也被称为多层交换机。多层交换机可以在许多层级上学习拓扑结构，也可以在一层或多层上进行转发。</p>
</li>
<li><p>一层</p>
<ul>
<li>一层网络设备传输数据而不控制任何流量，比如集线器。任何进入端口数据包会被转发到除进入端口之外的其他所有端口。具体而言，即每个比特或码元被转发时是原封不动的。由于每个数据包被分发到所有端口，其冲突会影响到整个网络，进而限制了它的整体的能力。 到21世纪初，集线器和低端交换机的价格差异很小。[1]对于特定应用，集线器在一段时间内还是能够发挥作用的，比如给数据包分析器提供网络流量的副本。网络分流器还有交换机的端口镜像也可以实现同样功能</li>
</ul>
</li>
<li><p>二层</p>
<ul>
<li>二层交换机依据硬件地址（MAC 地址）在数据链路层（第二层）传送网络帧。 二层交换机对于路由器和主机是“透明的”，主要遵从802.1d 标准。该标准规定交换机通过观察每个端口的数据帧获得源MAC 地址，交换机在内部的高速缓存中建立MAC 地址与端口的映射表。当交换机接受的数据帧的目的地址在该映射表中被查到，交换机便将该数据帧送往对应的端口。如果它查不到，便将该数据帧广播到该端口所属虚拟局域网（VLAN）的所有端口，如果有回应数据包，交换机便将在映射表中增加新的对应关系。当交换机初次加入网络中时，由于映射表是空的，所以，所有的数据帧将发往虚拟局域网内的全部端口直到交换机“学习”到各个MAC 地址为止。这样看来，交换机刚刚启动时与传统的共享式集线器作用相似的，直到映射表建立起来后，才能真正发挥它的性能。这种方式改变了共享式以太网抢行的方式，如同在不同的行驶方向上铺架了立交桥，去往不同方向的车可以同时通行，因此大大提高了流量。从VLAN的角度来看，由于只有子网内部的节点竞争带宽，所以性能得到提高。主机1 访问主机2 同时，主机3 可以访问主机4 。当各个部门具有自己独立的服务器时，这一优势更加明显。但是这种环境正发生巨大的变化，因为服务器趋向于集中管理，另外，这一模式也不适合Internet的应用。不同VLAN之间的通讯需要通过路由器来完成，另外为了实现不同的网段之间通讯也需要路由器进行互连。</li>
</ul>
</li>
<li><p>三层 </p>
<ul>
<li>三层交换机则可以处理第三层网络层协议，用于连接不同网段，通过对缺省网关的查询学习来建立两个网段之间的直接连接</li>
<li>三层交换机可以实现路由器的全部或部分功能，但只能用于同一类型的局域网子网之间的互连。这样，三层交换机可以像二层交换机那样通过MAC地址标识数据包，也可以像传统路由器那样在两个局域网子网之间进行功能较弱的路由转发，它的路由转发不是通过软件来维护的路由表，而是通过专用的ASIC芯片处理这些转发；</li>
</ul>
</li>
<li><p>四层</p>
<ul>
<li>四层交换机可以处理第四层传输层协议，可以将会话与一个具体的IP地址绑定，以实现虚拟IP</li>
</ul>
</li>
<li><p>七层</p>
<ul>
<li>更加智能的交换器，可以充分利用频宽资源来过滤，识别和处理应用层数据转换的交换设备</li>
</ul>
</li>
<li><p>网络交换机带宽分为： 10Mb&#x2F;s、100Mb&#x2F;s、1Gb&#x2F;s、10Gb&#x2F;s、40Gb&#x2F;s、100Gb&#x2F;s。Mbps换算MB&#x2F;s：1Mbps&#x3D;0.125MB&#x2F;s。</p>
</li>
</ul>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><ul>
<li><p>路由器(Router)是将运算设备（例如电脑）及网络连线至其他网络的联网设备。路由器有三个主要功能，分别是</p>
<ul>
<li>确定路径：路由器可以决定从来源到目的地所采用的路径，这个作业称为路由。</li>
<li>资料转传：路由器会将资料转传至所选路径的下一个设备，重复这个过程，最终资料可以抵达目的地。运算设备和路由器可能位于相同的网络或不同的网络。</li>
<li>负载平衡：路由器有时会用多个不同路径，发送相同资料报文副本。其目的是为了减少因资料丢失而造成错误、并建立备援及管理流量。</li>
</ul>
</li>
<li><p>比较技术性的解释是路由器是种电信网络设备，提供路由与转送两种重要机制，</p>
<ul>
<li>可以决定报文由来源端到目的端所经过的路径（host到host之间的传输路径），这个过程称为路由；</li>
<li>将路由器输入端的报文移送至适当的路由器输出端（在路由器内部进行），这称为转送。</li>
</ul>
</li>
<li><p>路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）。</p>
</li>
<li><p>路由器可连接两个以上个别网络的设备。</p>
</li>
<li><p>由于位于两个或更多个网络的交汇处，从而可在它们之间传递分组（一种数据的组织形式）。路由器与交换机在概念上有一定重叠但也有不同：</p>
<ul>
<li>交换机泛指工作于任何网络层次的数据中继设备（尽管多指网桥），</li>
<li>而路由器则更专注于网络层</li>
</ul>
</li>
<li><p>路由器与交换机有四个主要差别</p>
<ul>
<li>第一，路由器是OSI第三层的产品，而交換机则是第二层，第二层主要功能是将网络上各个电脑的MAC地址记在MAC地址表中，当局域网中的电脑要经过交換机去交换传递资料时，就查询交換机上的MAC地址表中的信息，并将报文发送给指定的电脑，而不会像第一层的产品（如集线器）发送给每台在网络中的电脑。</li>
<li>第二，路由器能在多条路径中选择最佳的路径，提升交换数据的传输速率。在发送报文时，路由表会被一同发送，该表存储了前往某一网络的最佳路径，如该路径的“路由度量值”，参考路由表可获得这个过程的详细描述。</li>
<li>第三，路由器可连接超过两个以上不同的网络，而交換机只能连接两个。</li>
<li>第四，路由器具有IP分享器功能，主要是让多台设备用同一条ADSL&#x2F;光纤宽带线路来上网，功能包括共享IP，宽带管理，自动分配IP等等，如在共享IP功能中，不同设备可共享同一个公共IP同时上网；在局域网中，路由器则会指定一组的Class C的私有IP，可让254台设备同时上网。</li>
</ul>
</li>
<li><p>路由器的种类</p>
<ul>
<li>边缘路由器(edge router)<ul>
<li>将设备连接到互联网的路由器。</li>
</ul>
</li>
<li>核心路由器<ul>
<li>如在ISP网络中，只负责与其他路由器之间传递数据</li>
</ul>
</li>
<li>单臂路由器(one-armed-router)<ul>
<li>一种特殊类型的路由器，可用来在多个虚拟局域网（Virtual LAN）之间传递数据包</li>
<li>在无线ad-hoc网络中的每台主机自己进行路由和数据转发，而在有线网络中通常一个广播域就有一台路由器。</li>
<li>近来，许多路由的功能被加入到局域网交换机（实质是高速网桥）上，从而创造出“三层交换机”，可以以接近线速的速度来转发流量。</li>
<li>路由器也被当作Internet网关，主要用在小型网络中如家庭或小型办公室。这种设备使用的Internet连接往往是互联网宽带连接如线缆调制解调器和DSL。这种路由器连接两个网络，WAN和LAN并有自己的路由表。尽管在家庭应用中并不需要太多路由功能（因为只存在WAN和LAN），但这些小型路由器仍然支持路由信息协议。额外地，这种路由器还支持DHCP、网络地址转换、DMZ和防火墙功能，也有一些支持内容过滤和VPN。通常这种路由器和线缆或DSL调制解调器协同工作，但调制解调功能也可以内置在这种路由器中。这种路由器往往同时具有阻止特定外部请求的安全特性。</li>
<li>大型的路由器一般安装在数据中心、电信公司或ISP的机房内。这些路由器将许多网络用大量的带宽连接起来。根据分工的不同，这些路由器可以支持路由协议中的几种，包括IS-IS、OSPF、IGRP、EIGRP、RIP、BGP。</li>
</ul>
</li>
<li>无线网络路由器<ul>
<li>无线网络路由器是一种用来连系有线和无线网络的通讯设备，它可以通过无线方式（如，Wi-Fi）连接终端设备（如，手机、笔记本电脑），进而建立计算机网络。</li>
<li>有的电信运营商为客户安装宽带时会提供含有Wi-Fi的路由器，通过简单地设置拨号可以实现宽带的共享。</li>
<li>无线方式较有线方式更易受环境影响。如，在户外使用无线，其速度可能受天气影响。</li>
<li>其它的无线方式有：红外线、蓝牙、卫星微波等</li>
</ul>
</li>
<li>策略路由<ul>
<li>策略路由比常规路由更灵活，常规路由基于目标网络进行的数据包转发，策略路由则额外定义数据转发规则，包含策略与操作（路由图），如会检查该接口接收到的所有数据包，是否符合路由图中的策略。对不符合的进行处理；符合的则按路由图策略中，对应的操作进行处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><ul>
<li><p>网关(Gateway)是计算机网络中的一种设备或服务器，用于连接不同网络或协议之间进行数据转发和处理。</p>
</li>
<li><p>网关是一种能够在不同网络或协议之间进行数据交换的设备或服务器。网关可以实现不同网络之间的互联互通，也可以实现不同协议之间的转换和适配。网关可以根据不同的功能和层次进行分类，例如物理层网关、数据链路层网关、网络层网关、传输层网关、应用层网关等[1]。网关可以提供多种服务，例如路由、安全、负载均衡、缓存、压缩、加密、认证、授权、过滤、转码等</p>
</li>
<li><p>网关的工作机制</p>
<ul>
<li>网关的工作机制与代理非常相似，它能够接收客户端的请求，并像拥有资源的源服务器一样对请求进行处理或转发。客户端可能无法察觉到通信目标是一个网关，而不是一个源服务器。网关可以根据不同的需求，对请求和响应进行不同的处理，例如修改请求头或响应头，改变请求方法或响应状态码，增加或删除请求参数或响应内容等[3]。网关还可以根据不同的协议，对数据进行编码或解码，例如将HTTP协议转换成FTP协议，或将TCP协议转换成UDP协议等。</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>家庭或小型企业网络中的网关：这种网关通常用于连接局域网和互联网，实现内外网的通信。它可以提供路由、防火墙、NAT、DHCP等功能，保证网络的安全和稳定。</li>
<li>物联网中的智能网关：这种网关用于连接物联网设备和云端平台，实现数据的采集、处理和传输。它可以提供协议转换、数据压缩、数据分析、数据安全等功能，提高物联网系统的性能和效率</li>
<li>语音通信中的语音网关：这种网关用于连接传统电话网络和IP网络，实现语音信号的转换和传输。它可以提供模拟&#x2F;数字信号转换、编解码器选择、信令协商等功能，保证语音通信的质量和兼容性</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Network/2024-05-22-network_2_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Network/2024-05-22-network_2_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">network_2_网络协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>计算机网络协议是在计算机网络中进行通信和数据交换的规则和约定集合。它定义了计算机网络中数据的格式、传输方式、错误检测和纠正、网络设备的工作方式以及网络中各个实体之间的通信流程等。</p>
<p>下面是一些常见的计算机网络协议：</p>
<ol>
<li><p><strong>TCP&#x2F;IP协议</strong>：TCP&#x2F;IP协议是互联网的核心协议，它包括TCP（传输控制协议）和IP（Internet协议）两个主要协议。TCP协议提供可靠的、面向连接的数据传输，而IP协议负责在网络中寻址和路由数据包。</p>
</li>
<li><p><strong>HTTP协议</strong>：HTTP（超文本传输协议）是应用层协议，用于在Web浏览器和Web服务器之间传输超文本文档。它是无状态的，通过请求-响应模型进行通信。</p>
</li>
<li><p><strong>HTTPS协议</strong>：HTTPS（安全超文本传输协议）是在HTTP基础上加入了安全层的协议，使用SSL&#x2F;TLS加密算法保证通信的安全性。</p>
</li>
<li><p><strong>FTP协议</strong>：FTP（文件传输协议）用于在客户端和服务器之间传输文件。它支持文件上传、下载、删除和重命名等操作。</p>
</li>
<li><p><strong>SMTP协议</strong>：SMTP（简单邮件传输协议）用于在网络中发送和传输电子邮件。它定义了电子邮件的格式和传输方式。</p>
</li>
<li><p><strong>POP3协议</strong>：POP3（邮局协议版本3）是用于接收电子邮件的协议，它允许用户从邮件服务器上下载邮件。</p>
</li>
<li><p><strong>DNS协议</strong>：DNS（域名系统）协议用于将域名解析为相应的IP地址。它提供了域名到IP地址之间的映射服务。</p>
</li>
<li><p><strong>ICMP协议</strong>：ICMP（Internet控制消息协议）用于在IP网络中传输错误报文和状态信息。它用于网络故障诊断和管理。</p>
</li>
</ol>
<p>以上只是一小部分常见的计算机网络协议，实际上还有许多其他的协议和标准，用于不同的网络通信需求和场景。这些协议共同构成了计算机网络的基础，使得不同设备和系统能够进行有效的通信和数据交换。</p>
<h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h2><h3 id="Web服务原理和技术"><a href="#Web服务原理和技术" class="headerlink" title="Web服务原理和技术"></a>Web服务原理和技术</h3><ul>
<li><p>Web Service，是面向服务计算模式的一部分，用于互联网上的信息交换</p>
</li>
<li><p>Web Service的主题非常广泛，非常复杂，涉及许多概念，协议和技术，而且它们源自不同的学科，诸如分布式计算系统，计算机网络，计算机体系结构，中间件，软件工程，编程语言，数据库系统，安全性和知识表示等，并且它们以各种错综复杂的方式组合在一起。</p>
</li>
<li><p>此外，还需要一些处理业务流程与组织的新技术，这些新技术既要发现企业存在的问题，又要在实际应用中解决这些问题</p>
</li>
</ul>
<h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><ul>
<li><p>Web服务是一种服务导向架构的技术，通过标准的Web协议提供服务，目的是保证不同平台的应用服务可以互操作</p>
</li>
<li><p>根据W3C的定义，Web服务（Web service）应当是一个软件系统，用以支持网络间不同机器的互动操作</p>
</li>
<li><p>网络服务通常是许多应用程序接口（API）所组成的，它们透过网络，例如国际互联网（Internet）的远程服务器端，执行客户所提交服务的请求</p>
</li>
<li><p>尽管W3C的定义涵盖诸多相异且无法介分的系统，不过通常我们指有关于<strong>主从式架构</strong>（Client-server）之间根据SOAP协议进行传递XML格式消息</p>
</li>
<li><p>无论定义还是实现，Web服务过程中会由服务器提供一个机器可读的描述（通常基于WSDL）以辨识服务器所提供的WEB服务</p>
<ul>
<li><code>SOAP</code>, 一个基于XML的可扩展消息信封格式，需同时绑定一个网络传输协议。这个协议通常是HTTP或HTTPS，但也可能是SMTP或XMPP。</li>
<li><code>WSDL</code>, 一个XML格式文档，用以描述服务端口访问方式和使用协议的细节。通常用来辅助生成服务器和客户端代码及配置信息。</li>
<li><code>UDDI</code>, 一个用来发布和搜索WEB服务的协议，应用程序可借由此协议在设计或运行时找到目标WEB服务。</li>
<li>这些标准由这些组织制订：W3C负责XML、SOAP及WSDL；OASIS负责UDDI。</li>
</ul>
</li>
</ul>
<h3 id="阮一峰网络日志"><a href="#阮一峰网络日志" class="headerlink" title="阮一峰网络日志"></a>阮一峰网络日志</h3><ul>
<li><p>想要理解Web service，必须先理解什么是Service（服务）</p>
</li>
<li><p>传统上，我们把计算机后台程序（Daemon）提供的功能，称为”服务”（service）</p>
</li>
<li><p>比如，让一个杀毒软件在后台运行，它会自动监控系统，那么这种自动监控就是一个”服务”。</p>
</li>
<li><p>通俗地说，”服务”就是<strong>计算机可以提供的某一种功能</strong>。</p>
</li>
<li><p>根据来源的不同，”服务”又可以分成两种：</p>
<ul>
<li>一种是”本地服务”（使用同一台机器提供的服务，不需要网络）</li>
<li>另一种是”网络服务”（使用另一台计算机提供的服务，必须通过网络才能完成）</li>
</ul>
</li>
<li><p>举例来说</p>
<ul>
<li>我现在有一批图片，需要把它们的大小缩小一半。那么，我们可以把”缩放图片”看成是一种服务。</li>
<li>你可以使用”本地服务”，在自己计算机上用软件缩小图片，也可以使用”网络服务”，将图片上传到某个网站，让服务器替你缩小图片，完成后再通过网络送回给你。</li>
<li>这就好比，一件事你可以自己做，也可以交给另一个人去做。肚子饿了，你可以自己做饭，也可以打电话去订一份比萨，让店家替你做好送上门。</li>
</ul>
</li>
<li><p>“网络服务”（Web Service）的本质，就是通过<strong>网络调用其他网站的资源</strong></p>
</li>
<li><p>如果一个软件的主要部分采用了”网络服务”，即它把存储或计算环节”外包”给其他网站了，那么我们就说这个软件属于Web Service架构</p>
</li>
<li><p>Web Service架构的基本思想，就是尽量把非核心功能交给其他人去做，自己全力开发核心功能。</p>
</li>
</ul>
<h2 id="使用Web服务的方式"><a href="#使用Web服务的方式" class="headerlink" title="使用Web服务的方式"></a>使用Web服务的方式</h2><ul>
<li><p>Web服务实际上是一组工具，并有多种不同的方法调用之。</p>
</li>
<li><p><strong>三种最普遍的手段是</strong>：远程过程调用（RPC），服务导向架构（SOA）以及表述性状态转移（REST）。</p>
</li>
<li><p>远程过程调用</p>
<ul>
<li>Web服务提供一个分布式函数或方法接口供用户调用，这是一种比较传统的方式。通常，在WSDL中对RPC接口进行定义（类似于早期的XML-RPC）。</li>
<li>尽管最初的Web服务广泛采用RPC方式部署，但针对其过于紧密之耦合性的批评声也随之不断。这是因为<strong>RPC式WEB服务实质上是利用一个简单的映射</strong>，以把用户请求直接转化成为一个特定语言编写的函数或方法。</li>
<li>如今，多数服务提供商认定此种方式在未来将难有作为，在他们的推动下，WS-I基本协议集（WS-I Basic Profile）已不再支持远程过程调用。</li>
</ul>
</li>
<li><p>服务导向架构</p>
<ul>
<li>现在，业界比较关注的是遵从服务导向架构（Service-oriented architecture，SOA）概念来构筑WEB服务。</li>
<li>在服务导向架构中，通讯由消息驱动，而不再是某个动作（方法调用）。这种WEB服务也被称作面向消息的服务</li>
<li>SOA式WEB服务得到了大部分主要软件供应商以及业界专家的支持和肯定。</li>
<li>作为与RPC方式的最大差别，SOA方式<strong>更加关注如何去连接服务而不是去特定某个实现的细节</strong>。WSDL定义了联络服务的必要内容</li>
</ul>
</li>
<li><p>表述性状态转移</p>
<ul>
<li>表述性状态转移式（Representational state transfer，REST）Web服务类似于HTTP或其他类似协议，它们<strong>把接口限定在一组广为人知的标准动作中</strong>（比如HTTP的GET、PUT、DELETE）以供调用。</li>
<li>此类WEB服务关注与那些稳定的资源的互动，而不是消息或动作</li>
<li>此种服务可以通过WSDL来描述SOAP消息内容，通过HTTP限定动作接口；或者完全在SOAP中对动作进行抽象。</li>
</ul>
</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h3 id="维基百科-1"><a href="#维基百科-1" class="headerlink" title="维基百科"></a>维基百科</h3><ul>
<li><p>WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。</p>
</li>
<li><p>WebSocket协议在2011年由IETF标准化为RFC 6455，后由RFC 7936补充规范。<strong>Web IDL中的WebSocket API由W3C标准化</strong></p>
</li>
<li><p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。</p>
</li>
<li><p>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输</p>
</li>
</ul>
<h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>WebSocket是一种与HTTP不同的协议。两者都位于OSI模型的应用层，并且都依赖于传输层的TCP协议</p>
</li>
<li><p>为了实现兼容性，WebSocket握手使用HTTP Upgrade头从HTTP协议更改为WebSocket协议。</p>
</li>
<li><p>WebSocket协议支持Web浏览器（或其他客户端应用程序）与Web服务器之间的交互，具有较低的开销，便于实现客户端与服务器的实时数据传输</p>
</li>
<li><p>服务器可以通过标准化的方式来实现，而无需客户端首先请求内容，并允许消息在保持连接打开的同时来回传递。</p>
</li>
<li><p>通过这种方式，可以在客户端和服务器之间进行双向持续对话。 </p>
</li>
<li><p>通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。</p>
</li>
<li><p>另外，Comet之类的技术以非标准化的方式实现了类似的双向通信</p>
<ul>
<li>Comet是一种用于web的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求，</li>
<li>目前有两种实现方式，长轮询和iframe流。</li>
</ul>
</li>
<li><p>与HTTP不同，WebSocket提供全双工通信。</p>
</li>
<li><p>此外，WebSocket还可以在TCP之上实现消息流。TCP单独处理字节流，没有固有的消息概念。 </p>
</li>
<li><p>在WebSocket之前，使用Comet可以实现全双工通信。</p>
</li>
<li><p>但是Comet存在TCP握手和HTTP头的开销，因此对于小消息来说效率很低。WebSocket协议旨在解决这些问题。</p>
</li>
<li><p>WebSocket协议规范将ws（WebSocket）和wss（WebSocket Secure）定义为两个新的统一资源标识符（URI）方案，分别对应明文和加密连接。</p>
</li>
<li><p>除了方案名称和片段ID（不支持#）之外，其余的URI组件都被定义为此URI的通用语法。</p>
</li>
</ul>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul>
<li><p>早期，很多网站为了实现<strong>推送技术</strong>，所用的技术都是<strong>轮询</strong>。</p>
</li>
<li><p>推送技术（英语：Push technology），或者说是是一种基于Internet通信方式的服务器推送，其中要求通信的请求是由发布者或中央服务器发起。与 pull&#x2F;get 形成对比，额外消息传输的相应一般由接收者或客户端发起。</p>
</li>
<li><p>轮询,是指由浏览器每隔一段时间（如每秒）向服务器发出HTTP请求，然后服务器返回最新的数据给客户端。</p>
</li>
<li><p>这种传统的模式带来很明显的缺点，即:</p>
<ul>
<li>浏览器需要不断的向服务器发出请求，然而HTTP请求与回复可能会包含较长的头部，其中真正有效的数据可能只是很小的一部分，所以这样会消耗很多带宽资源</li>
</ul>
</li>
<li><p><strong>比较新的轮询技术是Comet</strong>。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的HTTP长连接也会消耗服务器资源</p>
</li>
<li><p>在这种情况下，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯</p>
</li>
<li><p>Websocket与HTTP和HTTPS使用相同的TCP端口，可以绕过大多数防火墙的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。</p>
</li>
</ul>
<h4 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h4><ul>
<li><p>WebSocket 是独立的、创建在TCP上的协议。</p>
</li>
<li><p>Websocket 通过 HTTP&#x2F;1.1 协议的101状态码进行握手。</p>
</li>
<li><p>为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称<strong>握手</strong>（Handshaking）。</p>
</li>
<li><p>典型的WebSocket握手请求</p>
<ul>
<li>客户端请求：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></li>
<li>服务器回应：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字段说明：</p>
<ul>
<li>Connection必须设置Upgrade，表示客户端希望连接升级。</li>
<li>Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li>
<li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。<ul>
<li>把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行Base64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。</li>
<li>如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li>
</ul>
</li>
<li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li>
<li>Origin字段是必须的。如果缺少origin字段，WebSocket服务器需要回复HTTP 403 状态码（禁止访问）。</li>
<li>其他一些定义在HTTP协议中的字段，如Cookie等，也可以在Websocket中使用</li>
</ul>
</li>
</ul>
<h3 id="阮一峰网络日志-1"><a href="#阮一峰网络日志-1" class="headerlink" title="阮一峰网络日志"></a>阮一峰网络日志</h3><ul>
<li><p>已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p>
</li>
<li><p>因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p>
</li>
<li><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p>
</li>
<li><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。</p>
</li>
<li><p>我们只能使用”<strong>轮询</strong>“：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室</p>
</li>
<li><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p>
</li>
<li><p>因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的</p>
</li>
</ul>
<h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了</p>
</li>
<li><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</p>
</li>
<li><p>其他特点包括：</p>
<ul>
<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</li>
<li>数据格式比较轻量，性能开销小，通信高效。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li>
</ul>
</li>
</ul>
<h2 id="Web3和区块链"><a href="#Web3和区块链" class="headerlink" title="Web3和区块链"></a>Web3和区块链</h2><ul>
<li><p>互联网迄今有两个阶段：Web 1.0 和 Web 2.0</p>
</li>
<li><p>下一个阶段自然就是 Web 3.0（简称 Web3）</p>
</li>
<li><p>Web 1.0 阶段，用户是单纯的内容消费者，内容由网站提供，网站让你看什么，你就看什么，典型例子就是新闻门户网站。</p>
</li>
<li><p>Web 2.0 阶段，用户是内容的生产者，网站只是一个向用户提供服务的平台，典型的 Web 2.0 平台有维基百科、抖音、微信等等</p>
</li>
<li><p>Web3 的很多特征还不明确，但是国外很多文章认为，它跟区块链有关。</p>
<ul>
<li>Web 1.0 是用户读取互联网，Web 2.0 是用户写入互联网，Web3 是用户生活在互联网</li>
<li>娱乐、工作、学习、消费、交际，都在网上发生。网站不仅提供服务，还是一个生活空间，人们的一部分生活可以在网上完成</li>
<li>在教育网站学习，在会议网站开会，在社交网站交友，在游戏网站玩乐。所有网站共同构成了一个无所不包的网络世界</li>
</ul>
</li>
<li><p>所有网站的生活功能，如果能够连在一起，让用户无缝地从一个场景进入另一个场景，那就构成了一个虚拟世界。这大概就是最近很热门的元宇宙（metaverse）的样子</p>
</li>
<li><p>到了那个阶段，用户不再是访问网站，而是进入虚拟世界，过着虚拟的线上生活</p>
</li>
<li><p>这样的虚拟世界，显然不能被一家或几家巨头垄断，否则我们就会依赖这些巨头，不得不遵守它制定的规则。当你的生活都在虚拟世界里面，某一天巨头突然决定关闭你的账号，你的虚拟人生岂不嘎然而止了！</p>
</li>
<li><p>这就是很多人<strong>提出 Web3 应该是分布式的原因</strong>。这有两层含义：</p>
<ul>
<li>它不是集中式的，就没有单一的公司可以控制它；</li>
<li>任何一种服务都有多家提供商，通过分布式协议连起来，用户可以极小的成本，从一个提供商转移到另一个服务商。</li>
</ul>
</li>
<li><p>如果 Web3 确定是分布式的，那么区块链简直就是天然的基础设施。因为<strong>区块链是分布式数据库的一种实现</strong>，本身就是分布式的，而且信息一旦上链，就无法修改</p>
</li>
<li><p>这解决了 Web3 的核心问题：不同网站的数据交换。 </p>
</li>
<li><p>不同网站都可以自由读写同一个用户的数据，并且这些数据是可以信赖的，从而保证用户进入另一个网站，就好像进入同一个世界的不同地区</p>
</li>
<li><p>一旦 Web3 构建于区块链之上，按照区块链的设计，用户需要有一个数字钱包，它是你在虚拟世界的身份证和银行账户。</p>
</li>
<li><p>你的身份、财产、消费，都通过这个数字钱包来标识。网站通过数字钱包的 ID，来识别你是谁</p>
</li>
<li><p>我翻开谷歌一查,这WEB3.0就没有一个正常的解释， 歪歪斜斜的搜索结果每页上都写着 “去中心化” “分布式” “用户拥有” “区块链” “虚拟经济” “价值重塑” “Token” 几个大词，我横竖睡不着，仔细看了半夜，才从字缝里看出来，满本上都写着两个字“炒币”</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
