<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/26/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/26/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/2024-05-22-1_2_%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/2024-05-22-1_2_%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">1_2_模型部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>模型部署相关笔记</li>
<li>模型部署需要的技术栈还是比较复杂的，不仅需要底层并行知识，还需要模型算法知识，不过对于两者的要求都不是很高，只需要能够看的懂最新进展，能够跟着复现就行，模型部署，最重要的还是工程能力</li>
</ul>
<h2 id="模型有几种形式"><a href="#模型有几种形式" class="headerlink" title="模型有几种形式"></a>模型有几种形式</h2><ul>
<li>模型的形式有很多种，模型部署说到底还是编程任务，使用代码来实现一套函数，只不过这个函数中的参数都被提取出来封装到了一起，称为模型。</li>
<li>也正是因为如此，不同的框架不同的代码生成的模型格式五花八门，从Pytorch到tf到mxnet等训练框架，它们保存的模型各不相同，我们首先要解决的就是统一模型的格式，这里的统一格式并不是指文件的后缀一样就可以了，而是指所要支持的算子要统一。</li>
</ul>
<h2 id="模型部署是什么"><a href="#模型部署是什么" class="headerlink" title="模型部署是什么"></a>模型部署是什么</h2><ul>
<li><p>模型部署是指将训练好的机器学习模型部署到生产环境中，以便实际应用中使用。在模型发布之前，需要将模型从训练环境中导出，然后将其部署到生产环境中，通常是作为一个服务或者一个库的形式。</p>
</li>
<li><p>在软件工程中，部署指把开发完毕的软件投入使用的过程，包括环境配置，软件安装等步骤。类似的，对于深度学习模型来说，模型部署指让训练好的模型在特定环境中运行的过程。相比于软件部署，模型部署会面临更多的难题：</p>
<ul>
<li>运行模型所需要的环境难以配置。深度学习模型通常是由一些框架编写的，例如PyTorch, TensorFlow。由于框架规模，依赖环境的限制，这些框架不适合在手机，开发板等生产环境中安装</li>
<li>深度学习模型的结构通常比较庞大，需要大量的算力才能满足实时运行的需求。模型的运行效率需要优化</li>
</ul>
</li>
<li><p>因为这些难题的存在，模型部署不能靠简单的环境配置与安装完成。经过工业界和学术界数年的探索，模型部署有了一条流行的流水线：</p>
<ul>
<li>为了让模型最终能够部署到某一环境上，开发者们可以使用任意一种深度学习框架来定义网络结构，并通过训练确定网络中的参数</li>
<li>之后，模型的结构和参数会被转换成一种只描述网络结构的中间表示，一些针对网络结构的优化会在中间表示上进行</li>
<li>最后，用面向硬件的高性能编程框架（如 CUDA，OpenCL）编写，能高效执行深度学习网络中算子的推理引擎会把中间表示转换成特定的文件格式，并在对应硬件平台上高效运行模型。</li>
</ul>
</li>
<li><p>这一条流水线解决了模型部署中的两大问题：使用对接深度学习框架和推理引擎的中间表示，开发者不必担心如何在新环境中运行各个复杂的框架；通过中间表示的网络结构优化和推理引擎对运算的底层优化，模型的运算效率大幅提升</p>
</li>
</ul>
<h2 id="如何模型部署"><a href="#如何模型部署" class="headerlink" title="如何模型部署"></a>如何模型部署</h2><ul>
<li><p>模型部署的过程通常包括以下几个步骤</p>
<ul>
<li>导出模型: 将训练好的模型导出为可部署的格式，例如PMML， ONNX， TensorFlow等</li>
<li>部署模型: 将导出的模型部署到生产环境中，通常是作为一个服务或者一个库的形式。</li>
<li>测试模型: 在生产环境中对模型进行测试，以确保其能够正常工作，并且输出结果符合预期</li>
<li>监控模型: 在生产环境中对模型进行监控，以便及时发现并解决问题</li>
</ul>
</li>
<li><p>模型发布是机器学习应用中重要的一环，它可以帮助企业快速将机器学习应用落地，并带来实际的商业价值。</p>
</li>
<li><p>模型的部署方式可以根据具体的应用场景和需求而定，以下是一些常见的模型部署方式</p>
<ul>
<li>WebAPI: 将模型部署为一个Web服务，通过HTTP请求来获取模型预测的结果。可以使用Flask,Django等</li>
<li>嵌入式设备: 将模型部署到嵌入式设备上，例如数梅派，Jetson Nano等。可以使用TensorFlow Lit, Pytorch Mobile等框架来实现</li>
<li>容器化: 将模型打包成docker镜像，然后部署到云服务器上。可以使用Kubernetes, Docker Swarm等容器编排工具来实现</li>
<li>边缘计算: 将模型部署到边缘设备上，例如智能摄像头，智能家居等。可以使用TensorFlow.js, TensorFlow Lite等框架来实现。</li>
</ul>
</li>
<li><p>无论采用哪种部署方式，都需要考虑模型的性能，安全性，可靠性，可维护性等方面的问题。</p>
</li>
</ul>
<h2 id="模型部署的应用场景"><a href="#模型部署的应用场景" class="headerlink" title="模型部署的应用场景"></a>模型部署的应用场景</h2><ul>
<li>图像识别：将图像识别模型部署到智能摄像头、安防监控系统等设备上，实现人脸识别、车牌识别等功能。</li>
<li>自然语言处理：将自然语言处理模型部署到智能客服、聊天机器人等应用中，实现自然语言理解、情感分析等功能。</li>
<li>推荐系统：将推荐系统模型部署到电商、社交网络等应用中，实现商品推荐、好友推荐等功能。</li>
<li>工业控制：将模型部署到工业生产线上，实现质量检测、故障预测等功能。</li>
<li>金融风控：将模型部署到银行、保险等金融机构中，实现风险评估、欺诈检测等功能。</li>
<li>医疗诊断：将模型部署到医疗设备中，如医学影像诊断、病理分析等应用中，实现疾病诊断、治疗方案推荐等功能。</li>
<li>智能交通：将模型部署到交通系统中，实现交通流量预测、智能路灯等功能。</li>
<li>物联网：将模型部署到物联网设备中，如智能家居、智能城市等应用中，实现环境监测、交通管理等功能。</li>
<li>游戏开发：将模型部署到游戏中，实现智能 NPC、游戏推荐等功能。</li>
</ul>
<h2 id="模型部署的注意事项"><a href="#模型部署的注意事项" class="headerlink" title="模型部署的注意事项"></a>模型部署的注意事项</h2><ul>
<li>确保模型的正确性：在部署模型之前，需要对模型进行充分的测试，以确保其能够正确地工作，并且输出结果符合预期。</li>
<li>选择适合的部署方式：不同的应用场景需要不同的部署方式，需要根据具体的需求选择适合的部署方式。</li>
<li>考虑性能和资源消耗：在部署模型时需要考虑模型的性能和资源消耗，以确保模型能够在生产环境中高效地运行。</li>
<li>考虑安全性和隐私保护：在部署模型时需要考虑安全性和隐私保护，以确保模型不会被恶意攻击或者泄露用户隐私。</li>
<li>建立监控和反馈机制：在部署模型后，需要建立监控和反馈机制，及时发现并解决模型出现的问题，以确保模型能够持续地稳定运行。</li>
</ul>
<h2 id="模型部署模型的实现类库"><a href="#模型部署模型的实现类库" class="headerlink" title="模型部署模型的实现类库"></a>模型部署模型的实现类库</h2><ul>
<li>Python中有很多方法可以实现模型部署，以下是一些常见的方法：<ul>
<li>Flask：Flask是一个轻量级的Web框架，可以用来搭建Web API。通过Flask，可以将模型部署为一个Web服务，通过HTTP请求来获取模型预测结果。</li>
<li>Django：Django是一个功能强大的Web框架，可以用来搭建Web应用程序。通过Django，可以将模型部署为一个Web应用程序，实现更复杂的业务逻辑。</li>
<li>FastAPI：FastAPI是一个高性能的Web框架，可以用来搭建Web API。与Flask相比，FastAPI具有更高的性能和更好的类型注释支持。</li>
<li>TensorFlow Serving：TensorFlow Serving是一个专门用于模型部署的框架，可以快速部署TensorFlow模型，并提供高性能的预测服务。</li>
<li>ONNX Runtime：ONNX Runtime是一个高性能的推理引擎，可以用于部署ONNX格式的模型。ONNX Runtime支持多种硬件平台和操作系统，包括CPU、GPU、FPGA等。</li>
<li>PyTorch Serving：PyTorch Serving是一个专门用于PyTorch模型部署的框架，可以快速部署PyTorch模型，并提供高性能的预测服务。</li>
<li>AWS Lambda：AWS Lambda是亚马逊云提供的一种无服务器计算服务，可以用来运行代码。通过AWS Lambda，可以将模型部署为一个无服务器应用程序，实现高可用性和低成本。</li>
</ul>
</li>
</ul>
<h2 id="模型部署后的性能评价"><a href="#模型部署后的性能评价" class="headerlink" title="模型部署后的性能评价"></a>模型部署后的性能评价</h2><ul>
<li>模型部署后，我们需要对模型的性能进行评价，以确保模型能够在生产环境中高效地运行。以下是一些常见的模型性能评价方法：<ul>
<li>响应时间：响应时间是指从接收请求到返回结果所需的时间。在模型部署后，我们需要对模型的响应时间进行评价，以确保模型能够在实时应用中快速响应。</li>
<li>吞吐量：吞吐量是指在单位时间内处理的请求数量。在模型部署后，我们需要对模型的吞吐量进行评价，以确保模型能够在高并发场景下处理大量请求。</li>
<li>准确率：准确率是指模型在测试集上的分类准确率。在模型部署后，我们需要对模型的准确率进行评价，以确保模型在生产环境中能够保持良好的预测性能。</li>
<li>内存占用：内存占用是指模型在运行时所占用的内存大小。在模型部署后，我们需要对模型的内存占用进行评价，以确保模型能够在生产环境中高效地利用资源。</li>
<li>CPU和GPU利用率：CPU和GPU利用率是指在模型运行时，CPU和GPU的利用率。在模型部署后，我们需要对CPU和GPU的利用率进行评价，以确保模型能够充分利用硬件资源。</li>
</ul>
</li>
</ul>
<h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h2><ul>
<li><p>保存为pt文件或者pth文件，pytorch导出的模型有两种方案</p>
<ul>
<li>第一种是不仅仅包含参数，还包含了模型结构，读取的时候不需要预先建立模型</li>
<li>第二种是仅仅包含参数，读取之前需要将模型建立好，通过pth文件往里面填参数。</li>
</ul>
</li>
<li><p>但是第一种方案也不是在任何地方都可以直接使用，还是要有模型定义代码，也就是说这两种模型都只能由pytorch使用。</p>
</li>
<li><p>pytorch还支持另一种导出</p>
<ul>
<li>导出成torchscript格式，这种确确实实是将模型结构和参数都保存了，不仅可以用在pytorch，还可以用在C++推理上，不过C++推理依旧需要torchlib，相当于还是离不开torch</li>
</ul>
</li>
</ul>
<h2 id="ONNX"><a href="#ONNX" class="headerlink" title="ONNX"></a>ONNX</h2><ul>
<li><p>onnx是一套开放的中间格式标准，目前大部分深度学习相关的工具都支持onnx。onnx与训练框架，推理框架都无关</p>
</li>
<li><p>onnx模型由三部分组成</p>
<ul>
<li>节点Node: 就是神经网络中一层</li>
<li>输入Input: 存储了输入矩阵的维度信息</li>
<li>初始化器Initializer: 存储了权重和参数</li>
</ul>
</li>
<li><p>三种之间互关联，相互依赖，很难修改</p>
</li>
<li><p>在编译器领域，为了支持不同的编程语言和不同的运行平台，提出了一种与编程语言和运行平台无关的中间表达语言称为IR，onnx也可以看作是深度学习领域的IR</p>
</li>
</ul>
<h2 id="推理系统"><a href="#推理系统" class="headerlink" title="推理系统"></a>推理系统</h2><ul>
<li>有了通用的模型格式，深度学习要融入到整个产品中需要设计成一个单独的系统，响应处理外界请求，这就是推理系统的工作。</li>
<li>推理系统需要考虑包括模型管理，服务接口设计，系统检测，系统调度等。推理系统更多的是将推理工作包装成一个服务，供外界使用，推理系统需要考虑的事情<ul>
<li>吞吐量</li>
<li>响应效率</li>
<li>扩展性</li>
<li>灵活性</li>
</ul>
</li>
</ul>
<h2 id="推理引擎"><a href="#推理引擎" class="headerlink" title="推理引擎"></a>推理引擎</h2><ul>
<li>推理引擎主要做的是： 优化模型，实现核心算子，开发目标平台调度引擎。</li>
<li>本来像OpenVINO和TensorRT这种是厂家做出来的，支持的平台也只有它们自己的平台。</li>
<li>随着深度学习大火，各种推理框架都发展了起来。</li>
</ul>
<h2 id="模型转换"><a href="#模型转换" class="headerlink" title="模型转换"></a>模型转换</h2><ul>
<li><p>不同的训练框架，如Tensorflow、PyTorch、MindSpore、MXNet、CNTK等，都定义了自己的模型的数据结构，推理系统需要将它们转换到统一的一种数据结构上。开发神经网络交换协议（Open Neural Network Exchange，ONNX）正是为此目的而设计的。ONNX支持广泛的机器学习运算符集合，并提供了不同训练框架的转换器，例如TensorFlow模型到ONNX模型的转换器、PyTorch模型到ONNX模型的转换器等。</p>
</li>
<li><p>模型转换本质上是将模型这种结构化的数据，从一种数据结构转换为另一种数据结构的过程。进行模型转换首先要分析两种数据结构的异同点，然后针对结构相同的数据做搬运；对于结构相似的数据做一一映射；对于结构差异较大的数据则需要根据其语义做合理的数据转换；更进一步如果两种数据结构上存在不兼容，则模型转换无法进行。</p>
</li>
<li><p>ONNX的一个优势就在于其强大的表达能力，从而大多数业界框架的模型都能够转换到ONNX的模型上来而不存在不兼容的情况。</p>
</li>
<li><p>模型可以抽象为一种图，从而模型的数据结构可以解构为以下两个要点：</p>
<ul>
<li>模型拓扑连接：从图的角度来说，就是图的边；从AI模型的角度来说，就是AI模型中的数据流和控制流等。模型数据流和控制流的定义又可以引申出子图的表达形式、模型输入输出的表达形式、控制流结构的表达形式等。比如Tensorflow1.x中的控制流表达为一种有环图，通过Enter、Exit、Switch、LoopCond、NextIteration等算子来解决成环，而ONNX通过Loop，If等算子来表达控制流，从而避免引入了有环，所以在将Tensorflow1.x的控制流模型转化为ONNX模型时，需要将Tensorflow模型中的控制流图结构融合成ONNX的While或者If算子。</li>
<li>算子原型定义：从图的角度来说，就是图的顶点；从AI模型角度来说，就是AI模型中的数据处理节点或者控制流节点。算子原型包括但不限于算子类型、算子输入输出的定义、算子属性的定义等。比如Caffe的slice算子和ONNX的slice算子的语义其实是不一致的，Caffe的slice算子应该映射到ONNX的Split算子，所以在将Caffe模型转换成ONNX模型时，需要将Caffe的Slice算子映射到ONNX的Split算子。比如Tensorflow中的中的FusedBatchNorm算子在Caffe中找不到相同语义的算子，需要将Caffe的BatchNorm算子和Scale算子组合起来才能表达相同的语义。</li>
</ul>
</li>
<li><p>在完成模型转换之后，通常地，框架会将一些不依赖于输入的工作提前去完成。这些工作包括了如常量折叠、算子融合、算子替换、算子重排等一些优化手段。这些优化手段的概念在前面的章节其实已经提及到，比如在编译器前端阶段，通常也会做常量折叠；在编译器后端阶段，通常会根据后端的硬件支持程度，对算子进行融合和拆分。但是有些优化工作只有在部署阶段才能进行或者彻底进行</p>
</li>
</ul>
<h2 id="模型部署场景"><a href="#模型部署场景" class="headerlink" title="模型部署场景"></a>模型部署场景</h2><ul>
<li>这个问题主要源于中心服务器云端部署和边缘部署两种方式的差异 <ul>
<li>云端部署常见的模式是模型部署在云端服务器，用户通过网页访问或者 API 接口调用等形式向云端服务器发出请求，云端收到请求后处理并返回结果。</li>
<li>边缘部署则主要用于嵌入式设备，主要通过将模型打包封装到 SDK，集成到嵌入式设备，数据的处理和模型推理都在终端设备上执行。</li>
</ul>
</li>
</ul>
<h2 id="模型部署方式"><a href="#模型部署方式" class="headerlink" title="模型部署方式"></a>模型部署方式</h2><ul>
<li>针对中心服务器云端部署方式和边缘部署方式，分别有两种不同的部署方案，Service部署和SDK部署。<ul>
<li>Service 部署：主要用于中心服务器云端部署，一般直接以训练的引擎库作为推理服务模式。</li>
<li>SDK 部署：主要用于嵌入式端部署场景，以 C++ 等语言实现一套高效的前后处理和推理引擎库（高效推理模式下的 Operation&#x2F;Layer&#x2F;Module 的实现），用于提供高性能推理能力。此种方式一般需要考虑模型转换（动态图静态化）、模型联合编译等进行深度优化。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>SDK 部署</th>
<th>Service 部署</th>
</tr>
</thead>
<tbody><tr>
<td>部署环境</td>
<td>SDK 引擎</td>
<td>训练框架</td>
</tr>
<tr>
<td>模型语义转换</td>
<td>需要进行前后处理和模型的算子重实现</td>
<td>一般框架内部负责语义转换</td>
</tr>
<tr>
<td>前后处理对齐算子</td>
<td>训练和部署对应两套实现，需要进行算子数值对齐</td>
<td>共用算子</td>
</tr>
<tr>
<td>计算优化</td>
<td>偏向于挖掘芯片编译器的深度优化能力</td>
<td>利用引擎已有训练优化能力</td>
</tr>
</tbody></table>
<h2 id="部署的核心优化指标"><a href="#部署的核心优化指标" class="headerlink" title="部署的核心优化指标"></a>部署的核心优化指标</h2><ul>
<li><p>部署的核心目标是合理把控成本、功耗、性价比三大要素</p>
</li>
<li><p>成本问题是部署硬件的重中之重，AI 模型部署到硬件上的成本将极大限制用户的业务承受能力。</p>
</li>
<li><p>成本问题主要聚焦于芯片的选型，比如，对比寒武纪 MLU220 和 MLU270，MLU270 主要用作数据中心级的加速卡，其算力和功耗都相对于边缘端的人工智能加速卡MLU220要低。至于 Nvida 推出的 Jetson 和 Tesla T4 也是类似思路，Tesla T4 是主打数据中心的推理加速卡，而 Jetson 则是嵌入式设备的加速卡。对于终端场景，还会根据对算力的需求进一步细分，比如表中给出的高通骁龙芯片，除 GPU 的浮点算力外，还会增加 DSP 以增加定点算力，篇幅有限，不再赘述，主要还是根据成本和业务需求来进行权衡。</p>
</li>
<li><p>在数据中心服务场景，对于功耗的约束要求相对较低；在边缘终端设备场景，硬件的功耗会影响边缘设备的电池使用时长。因此，对于功耗要求相对较高，一般来说，利用 NPU 等专用优化的加速器单元来处理神经网络等高密度计算，能节省大量功耗</p>
</li>
<li><p>不同的业务场景对于芯片的选择有所不同，以达到更高的性价比。 从公司业务来看，云端相对更加关注是多路的吞吐量优化需求，而终端场景则更关注单路的延时需要。在目前主流的 CV 领域，低比特模型相对成熟，且 INT8&#x2F;INT4 芯片因成本低，且算力比高的原因已被广泛使用；但在NLP或者语音等领域，对于精度的要求较高，低比特模型精度可能会存在难以接受的精度损失，因此 FP16 是相对更优的选择。在 CV 领域的芯片性价比选型上，在有 INT8&#x2F;INT4 计算精度的芯片里，主打低精度算力的产品是追求高性价比的主要选择之一，但这也为平衡精度和性价比提出了巨大的挑战</p>
</li>
</ul>
<h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><ul>
<li>上面简要介绍了部署的主要方式和场景，以及部署芯片的选型考量指标，接下来以 SDK 部署为例，给大家概括介绍一下 SenseParrots 在部署中的整体流程。SenseParrots 部署流程大致分为以下几个步骤：模型转换、模型量化压缩、模型打包封装 SDK。</li>
</ul>
<h3 id="模型转换-1"><a href="#模型转换-1" class="headerlink" title="模型转换"></a>模型转换</h3><ul>
<li>模型转换主要用于模型在不同框架之间的流转，常用于训练和推理场景的连接。目前主流的框架都以 ONNX 或者 caffe 为模型的交换格式，SenseParrots 也不例外。SenseParrots 的模型转换主要分为计算图生成和计算图转换两大步骤，另外，根据需要，还可以在中间插入计算图优化，对计算机进行推理加速（诸如常见的 CONV&#x2F;BN 的算子融合）</li>
<li>计算图生成是通过一次 inference 并追踪记录的方式，将用户的模型完整地翻译成静态的表达。在模型 inference 的过程中，框架会记录执行算子的类型、输入输出、超参、参数和调用该算子的模型层次，最后把 inference 过程中得到的算子信息和模型信息结合得到最终的静态计算图</li>
<li>在计算图生成之后与计算图转换之前，可以进行计算图优化，例如去除冗余 op，计算合并等。SenseParrots 原生实现了一批计算图的精简优化 pass，也开放接口鼓励用户对计算图进行自定义的处理和优化操作</li>
<li>计算图转换是指分析静态计算图的算子，对应转换到目标格式。SenseParrots 支持了多后端的转换，能够转换到各个 opset 的 ONNX、原生 caffe 和多种第三方版本的 caffe。框架通过算子转换器继承或重写的方式，让 ONNX 和 caffe 的不同版本的转换开发变得更加简单。同时，框架开放了自定义算子生成和自定义算子转换器的接口，让第三方框架开发者也能够轻松地自主开发实现 SenseParrots 到第三方框架的转换</li>
</ul>
<h3 id="模型量化压缩"><a href="#模型量化压缩" class="headerlink" title="模型量化压缩"></a>模型量化压缩</h3><ul>
<li>终端场景中，一般会有内存和速度的考虑，因此会要求模型尽量小，同时保证较高的吞吐率。除了人工针对嵌入式设备设计合适的模型，如 MobileNet 系列，通过 NAS(Neural Architecture Search) 自动搜索小模型，以及通过蒸馏&#x2F;剪枝的方式压缩模型外，一般还会使用量化来达到减小模型规模和加速的目的。</li>
<li>量化的过程主要是将原始浮点 FP32 训练出来的模型压缩到定点 INT8(或者 INT4&#x2F;INT1) 的模型，由于 INT8 只需要 8 比特来表示，因此相对于 32 比特的浮点，其模型规模理论上可以直接降为原来的 1&#x2F;4，这种压缩率是非常直观的。 另外，大部分终端设备都会有专用的定点计算单元，通过低比特指令实现的低精度算子，速度上会有很大的提升，当然，这部分还依赖协同体系结构和算法来获得更大的加速</li>
<li>量化的技术栈主要分为量化训练（QAT, Quantization Aware Training）和离线量化（PTQ, Post Training Quantization）, 两者的主要区别在于，量化训练是通过对模型插入伪量化算子（这些算子用来模拟低精度运算的逻辑），通过梯度下降等优化方式在原始浮点模型上进行微调，从来调整参数得到精度符合预期的模型。离线量化主要是通过少量校准数据集（从原始数据集中挑选 100-1000 张图，不需要训练样本的标签）获得网络的 activation 分布，通过统计手段或者优化浮点和定点输出的分布来获得量化参数，从而获取最终部署的模型。 两者各有优劣，量化训练基于原始浮点模型的训练逻辑进行训练，理论上更能保证收敛到原始模型的精度，但需要精细调参且生产周期较长；离线量化只需要基于少量校准数据，因此生产周期短且更加灵活，缺点是精度可能略逊于量化训练。 实际落地过程中，发现大部分模型通过离线量化就可以获得不错的模型精度（1% 以内的精度损失，当然这部分精度的提升也得益于优化策略的加持），剩下少部分模型可能需要通过量化训练来弥补精度损失，因此实际业务中会结合两者的优劣来应用</li>
<li>量化主要有两大难点：一是如何平衡模型的吞吐率和精度，二是如何结合推理引擎充分挖掘芯片的能力。 比特数越低其吞吐率可能会越大，但其精度损失可能也会越大，因此，如何通过算法提升精度至关重要，这也是组内的主要工作之一。另外，压缩到低比特，某些情况下吞吐率未必会提升，还需要结合推理引擎优化一起对模型进行图优化，甚至有时候会反馈如何进行网络设计，因此会是一个算法与工程迭代的过程</li>
</ul>
<h3 id="模型打包封装SDK"><a href="#模型打包封装SDK" class="headerlink" title="模型打包封装SDK"></a>模型打包封装SDK</h3><ul>
<li>实际业务落地过程中，模型可能只是产品流程中的一环，用于实现某些特定功能，其输出可能会用于流程的下一环。因此，模型打包会将模型的前后处理，一个或者多个模型整合到一起，再加入描述性的文件（前后处理的参数、模型相关参数、模型格式和版本等）来实现一个完整的功能。因此，SDK 除了需要一些通用前后处理的高效实现，对齐训练时的前后处理逻辑，还需要具有足够好的扩展性来应对不同的场景，方便业务线同学扩展新的功能。可以看到，模型打包过程更多是模型的进一步组装，将不同模型组装在一起，当需要使用的时候将这些内容解析成整个流程（pipeline）的不同阶段（stage），从而实现整个产品功能</li>
<li>另外，考虑到模型很大程度是研究员的研究成果，对外涉及保密问题，因此会对模型进行加密，以保证其安全性。加密算法的选择需要根据实际业务需求来决定，诸如不同加密算法其加解密效率不一样，加解密是否有中心验证服务器，其核心都是为了保护研究成果</li>
</ul>
<h2 id="模型推理"><a href="#模型推理" class="headerlink" title="模型推理"></a>模型推理</h2><ul>
<li><p>实际上，用训练好的模型对新数据进行预测，在机器学习工程上有一个更专业的名词叫做 推理(inference)。</p>
</li>
<li><p>通过训练集构建的神经网络对新输入数据进行预测，就是推理。</p>
</li>
<li><p>一般情况下，推理又分为: 静态推理与动态推理</p>
<ul>
<li>静态推理很好理解，我们通过集中对批量数据进行推理，并将结果存放在数据表或者数据库中。当有需要的时候，再直接通过查询来获得推理结果。</li>
<li>而动态推理一般表示我们将模型部署到服务器中。当有需要时，通过向服务器发送请求来获得模型返回的预测结果。与静态推理不同的是，动态推理的过程是实时计算的，而静态推理是提前批量处理好的。</li>
</ul>
</li>
<li><p>当然，静态和动态推理各有优缺点。静态推理适合于对大批量数据进行处理，因为动态推理面对大数据量时非常耗时。但是静态推理无法实时更新，而动态推理的结果是即时计算结果</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/FFmpeg/ffmpeg_1_%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/2024-05-22-ffmpeg_1_2_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/FFmpeg/ffmpeg_1_%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/2024-05-22-ffmpeg_1_2_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">ffmpeg_1_2_基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>FFmpeg 理论基础知识</li>
</ul>
<h2 id="ffmpeg-依赖库"><a href="#ffmpeg-依赖库" class="headerlink" title="ffmpeg 依赖库"></a>ffmpeg 依赖库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apt -y install autoconf automake libass-dev libfreetype6-dev libsdl2-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev pkg-config texinfo zlib1g-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 汇编库</span></span><br><span class="line">apt -y install yasm nasm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频库</span></span><br><span class="line">apt -y install libx264-dev libx265-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 音频库</span></span><br><span class="line">apt -y install libfdk-aac-dev libmp3lame-dev libopus-dev</span><br></pre></td></tr></table></figure>

<h2 id="ffmpeg-编译安装"><a href="#ffmpeg-编译安装" class="headerlink" title="ffmpeg 编译安装"></a>ffmpeg 编译安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ffmpeg-5.1.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部的</span></span><br><span class="line">./configure --enable-ffplay --enable-libx264 --enable-libx265 --enable-pic --enable-libvorbis --enable-libass --enable-nonfree --enable-libass --enable-libfreetype --enable-libfdk-aac --enable-shared --enable-gpl --enable-libmp3lame --enable-libopus --disable-x86asm </span><br><span class="line"></span><br><span class="line"><span class="comment"># mp3库版本不够 屏蔽掉libmp3lame库</span></span><br><span class="line">./configure --enable-ffplay --enable-libx264 --enable-libx265 --enable-pic --enable-libvorbis --enable-libass --enable-nonfree --enable-libass --enable-libfreetype --enable-libfdk-aac --enable-shared --enable-gpl --disable-libmp3lame --enable-libopus --disable-x86asm  --prefix=/data/usr/local/ffmpeg</span><br><span class="line"></span><br><span class="line">make -j16</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/FFmpeg/ffmpeg_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-ffmpeg_3_1_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/FFmpeg/ffmpeg_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/2024-05-22-ffmpeg_3_1_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">ffmpeg_3_1_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ffmpeg 常用技巧</li>
</ul>
<h2 id="ffmpeg-安装"><a href="#ffmpeg-安装" class="headerlink" title="ffmpeg 安装"></a>ffmpeg 安装</h2><ul>
<li>下载FFmpge源代码 <code>http://ffmpeg.org/download.html</code></li>
<li>安装依赖库 <code>yasm  libsdl1.2-dev libsdl2-dev</code></li>
<li>编译安装  <code>./configure --prefix=/usr/local/ffmpeg &amp;&amp; make &amp;&amp; make install</code></li>
</ul>
<h2 id="使用ffserver-将本地视频转为rtsp视频流"><a href="#使用ffserver-将本地视频转为rtsp视频流" class="headerlink" title="使用ffserver 将本地视频转为rtsp视频流"></a>使用ffserver 将本地视频转为rtsp视频流</h2><ul>
<li><p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HTTPPort 9554</span><br><span class="line">RTSPPort 554</span><br><span class="line">MaxClients 1000</span><br><span class="line">MaxBandwidth 1000</span><br><span class="line">CustomLog -</span><br><span class="line"></span><br><span class="line">&lt;Stream stat.html&gt;</span><br><span class="line">Format status</span><br><span class="line">ACL allow localhost</span><br><span class="line">ACL allow 192.167.0.0 192.167.255.255</span><br><span class="line">&lt;/Stream&gt;</span><br><span class="line"></span><br><span class="line">&lt;Stream new_year.mp4&gt;</span><br><span class="line">File &quot;/home/user/Videos/new_year.mp4&quot;</span><br><span class="line">Format rtp</span><br><span class="line">&lt;/Stream&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：<code>rtsp://192.167.15.58:554/new_year.mp4</code></p>
</li>
<li><p>参数说明</p>
<ul>
<li><code>HTTPPort 9554</code> – HTTP服务器监听的tcp端口</li>
<li><code>Port 9554</code> – 和<code>HTTPPort</code>一样，但是不推荐使用</li>
<li><code>RTSPPort 554</code> – rtsp服务器监听的tcp端口</li>
<li><code>HTTPBindAddress 0.0.0.0</code> – http服务器绑定地址</li>
<li><code>RTSPBindAddress</code> – rtsp服务器绑定的地址</li>
<li><code>MaxHTTPConnections 2000</code> – 可以同时处理的http连接数，必须在<code>MaxClients</code>之前，默认2000</li>
<li><code>MaxClients 1000</code> – 可以同时处理的请求数,默认为5</li>
<li><code>MaxBandwidth 1000</code> – 最大的传输比特率(kbps) kbit&#x2F;sec 默认为1000</li>
<li><code>CustomLog [filename/-]</code> – 日志文件，使用标准的Apache日志文件格式， <code>-</code> 代表标准输出，没有这个选项不会产生日志，<code>-d</code>启动时忽略此配置并打印在标准输出上</li>
<li><code>NoDaemon</code> – 禁止为守护进程，若要以守护进程启动去掉此属性即可</li>
<li><code>ACL allow 127.0.0.1</code> – 允许本机连接feed</li>
<li><code>Feed feed.ffm</code> – 所关联的feed文件</li>
<li><code>File filename</code> – 预先准备好的文件</li>
<li><code>Format flv/rtp</code> – 输出流的格式</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/FFmpeg/ffmpeg_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-ffmpeg_2_1_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/FFmpeg/ffmpeg_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-ffmpeg_2_1_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">ffmpeg_2_1_常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ffmpeg 常用命令和常用技巧</li>
</ul>
<h2 id="ffmpeg-多张图片编码成h264视频"><a href="#ffmpeg-多张图片编码成h264视频" class="headerlink" title="ffmpeg 多张图片编码成h264视频"></a>ffmpeg 多张图片编码成h264视频</h2><p>你可以使用FFmpeg将多张图片编码成H.264视频。以下是一个示例命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 24 -i image%d.jpg -c:v libx264 -preset slow -crf 20 output.mp4</span><br></pre></td></tr></table></figure>

<p>这个命令的解释如下：</p>
<ul>
<li><code>-framerate 24</code>：指定视频的帧率为24帧每秒。你可以根据需要调整这个值。</li>
<li><code>-i image%d.jpg</code>：指定输入图片的路径和格式。<code>%d</code>会被替换为数字序列，比如image1.jpg、image2.jpg等。</li>
<li><code>-c:v libx264</code>：指定视频编码器为libx264，即H.264编码器。</li>
<li><code>-preset slow</code>：指定编码速度为慢速，可以提高视频质量。</li>
<li><code>-crf 20</code>：设置视频的质量。CRF值越低，视频质量越高，范围一般在18-28之间。你可以根据需要调整这个值。</li>
<li><code>output.mp4</code>：指定输出视频的文件名和格式。</li>
</ul>
<p>你可以根据需要修改参数来满足你的具体需求。</p>
<h2 id="从指定时间截取指定长度视频"><a href="#从指定时间截取指定长度视频" class="headerlink" title="从指定时间截取指定长度视频"></a>从指定时间截取指定长度视频</h2><ul>
<li><p>命令：</p>
<ul>
<li><code>ffmpeg -ss 00:00:00 -t 00:00:14 -i zhuoer_face.mkv -vcodec copy -acodec copy aaa.mp4</code></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>-ss</code> : 开始截取的时间点</li>
<li><code>-t</code>  : 要截取视频的时间长度</li>
<li><code>-i</code>  : 输入的视频文件</li>
<li><code>-vcodec copy</code> : 拷贝原视频，不更改格式</li>
<li><code>-acodec copy</code> : 拷贝原音频，不更改格式</li>
<li><code>aaa.mp4</code> : 输出视频文件</li>
</ul>
</li>
</ul>
<h2 id="合并视频文件"><a href="#合并视频文件" class="headerlink" title="合并视频文件"></a>合并视频文件</h2><ul>
<li><p>命令：</p>
<ul>
<li><code>ffmpeg -f concat -i list.txt -c copy zhuoer_face_new.mp4</code></li>
</ul>
</li>
<li><p>list.txt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file aaa.mp4</span><br><span class="line">file bbb.mp4</span><br><span class="line">file ccc.mp4</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li><code>-f concat</code> : </li>
<li><code>-i list.txt</code> : 输入配置文件</li>
<li><code>-c copy</code> : 拷贝原视频，不更改格式</li>
<li><code>zhuoer_face_new.mp4</code> : 输出视频文件</li>
</ul>
</li>
</ul>
<h2 id="ffmpeg保存摄像头视频到本地"><a href="#ffmpeg保存摄像头视频到本地" class="headerlink" title="ffmpeg保存摄像头视频到本地"></a>ffmpeg保存摄像头视频到本地</h2><ul>
<li><code>ffmpeg -rtsp_transport tcp -i rtsp://admin:a1234567@192.167.0.56:554 -c copy -f mp4 -t 00:10:00 /data/output.mp4</code></li>
</ul>
<h2 id="ffmpeg缩放视频（等比例）"><a href="#ffmpeg缩放视频（等比例）" class="headerlink" title="ffmpeg缩放视频（等比例）"></a>ffmpeg缩放视频（等比例）</h2><ul>
<li><code>ffmpeg -i input-video.mp4 -vf scale=300:180 ./output.mp4</code></li>
<li>参数：<ul>
<li><code>-vf</code>  –  filter_graph, set video filters</li>
</ul>
</li>
</ul>
<h2 id="FFmpeg将视频按帧截取保存为图片"><a href="#FFmpeg将视频按帧截取保存为图片" class="headerlink" title="FFmpeg将视频按帧截取保存为图片"></a>FFmpeg将视频按帧截取保存为图片</h2><ul>
<li><code>ffmpeg -i /home/user/Videos/new_year.mp4 -r 5 -f image2 image-%03d.jpg</code></li>
<li>参数：<ul>
<li><code>-i</code>  –  指定输入源</li>
<li><code>-r</code>  –  指定抽取的帧，即从视频中每秒抽取的图片数量</li>
<li><code>-f</code>  –  fmt，强迫采用格式fmt 保存图片使用的格式</li>
<li><code>image-%03d.jpg</code>  –  指定文件的输出名字</li>
</ul>
</li>
</ul>
<h2 id="获取音视频信息"><a href="#获取音视频信息" class="headerlink" title="获取音视频信息"></a>获取音视频信息</h2><ul>
<li><code>ffprobe</code>是FFmpeg项目提供的用于分析视频信息的命令工具</li>
<li>例如:<code>ffprobe -v quiet -print_format json -show_format -show_streams test.mp4</code>可以活动json格式的输出的视频信息<ul>
<li><code>-v quiet</code> : 将日志级别设为quiet，避免日志信息污染json</li>
<li><code>-show_format</code> : 显式文件的容器信息</li>
<li><code>-show_stream</code> : 显式容器中流的信息</li>
<li><code>-show_frames</code> : 则可以显式视频中每一帧的信息</li>
</ul>
</li>
</ul>
<h2 id="使用ffmpeg进行视频处理"><a href="#使用ffmpeg进行视频处理" class="headerlink" title="使用ffmpeg进行视频处理"></a>使用ffmpeg进行视频处理</h2><ul>
<li><p>ffmpeg的命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg \</span><br><span class="line">    [global_options] \</span><br><span class="line">    [input_file_options] -i input_url \</span><br><span class="line">    [actions] \</span><br><span class="line">    [output_file_options] output_url</span><br></pre></td></tr></table></figure></li>
<li><p>可以将ffmpeg的选项分为全局选项和局部选项</p>
<ul>
<li>局部选项用于设置输入输出或滤镜等，通常位于被修饰的指令前面</li>
</ul>
</li>
<li><p>ffmpeg的基本流程为：将容器中的各流进行解码，然后重新编码为指定的格式。在编码之前，可以使用<code>filter</code>对视频进行处理</p>
</li>
<li><p>选项</p>
<ul>
<li><code>-y / -n</code> : 全局选项，<code>-y</code>表示直接覆盖已经存在的输入文件，<code>-n</code>表示若某个输出文件已经存在则退出。若没有设置<code>-y</code>或<code>-n</code>选项，且某个输出文件已经存在，ffmpeg会询问是否要覆盖输出文件</li>
<li><code>-codec , -c</code> ： 指定输入输出的编解码器，可用的编解码器参考官方文档<ul>
<li>codec指定为<code>copy</code>，<strong>则将输入流直接复制到输出流不进行编码操作</strong></li>
<li>使用<code>-c:STREAM_INDEX</code>方式可以指定某一个流的编码器，<code>STREAM_INDEX</code>为stream对象的index属性</li>
<li><code>-c:v, -vcodec</code>，可以为所有视频流指定编解码器， <code>-c:v:1</code>为第2各视频流指定编解码器</li>
<li><code>-c:a, -acodec</code>，可以为所有音频流指定编解码器， <code>-c:a:12</code>为第13个视频流指定编解码器</li>
</ul>
</li>
<li><code>-ss</code> : 用于设置流的开始视频，可以设置输入输出或滤镜，在开始时间之前的帧将被跳过部处理（输入不被解码，输出不被编码，滤镜不被处理）<ul>
<li>秒数 ： <code>-t 10, -t 24.134</code></li>
<li>时分秒 ： <code>-t 10:23, -t 21:31:00.233</code></li>
</ul>
</li>
<li><code>-t</code> ： 选项用于设置输入输出，它在<code>-i</code>前可以限制输入时长，在输入文件前可限制输出时长</li>
<li><code>-to</code> : 类似于<code>-t</code>选项，不同的是它指定结束时刻，<code>-t</code>指定持续时间</li>
<li><code>-f</code> : 强制设置输入输出的文件格式，<strong>默认情况下ffmpeg会根据文件后缀名判断格式</strong><ul>
<li><code>ffmpeg-formats</code> 命令会显示所有支持的编码格式</li>
</ul>
</li>
<li><code>-vframes</code> : 设置输出文件中包含的总帧数</li>
<li><code>-vn</code> : 不将视频流写到输出文件中</li>
<li><code>-an</code> : 不将音频流写到输出文件中</li>
<li><code>-r</code> : 设置某个流的帧率</li>
<li><code>-s</code> ： 设置帧的大小</li>
<li><code>-threads</code> : 设置处理线程数</li>
<li><code>-shortest</code> : 当最短的输入流结束后，即停止编码和输出</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-linux_1_02_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-linux_1_02_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">linux_1_02_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux系统下理论基础知识笔记</li>
</ul>
<h2 id="linux-命令执行失败的错误码的意义"><a href="#linux-命令执行失败的错误码的意义" class="headerlink" title="linux 命令执行失败的错误码的意义"></a>linux 命令执行失败的错误码的意义</h2><p>在Linux系统中，命令执行失败时通常返回一个错误码，也称为退出码（Exit Code）。这个退出码是一个8位的整数，范围从0到255。通常情况下，0表示成功，而非零值表示错误。</p>
<p>以下是一些常见的退出码及其一般的意义：</p>
<ul>
<li>0: 成功（通常表示命令成功执行）</li>
<li>1: 一般性错误（通用错误，不具体指明）</li>
<li>2: 误用shell命令（用户不正确使用shell命令）</li>
<li>126: 不可执行的命令（命令存在但不可执行）</li>
<li>127: 找不到命令（命令未找到）</li>
<li>128: 无效的退出参数（传递给exit的参数无效）</li>
<li>130: Ctrl+C终止（通常由用户按下Ctrl+C中断命令）</li>
<li>137: 被kill -9终止（进程被强制终止）</li>
<li>255: 退出状态出界（退出状态超出0-255的范围）</li>
</ul>
<p>注意，不同的命令可能有自己特定的退出码含义，你可以查阅相关文档或命令的man页面以获取更详细的信息。一般来说，成功的退出码是0，非零值表示失败或错误。</p>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><ul>
<li><code>$#</code>, 传递到脚本或函数的参数个数</li>
<li><code>$*</code>, 以一个单字符串显示所有向脚本传递的参数</li>
<li><code>$$</code>, 脚本运行的当前进程ID号</li>
<li><code>$!</code>, 后台运行的最后一个进程的ID号</li>
<li><code>$@</code>, 与<code>$*</code>相同,但是使用时加引号,并在引号中返回每个参数</li>
<li><code>$-</code>, 显示Shell使用的当前选项,与set命令功能相同</li>
<li><code>$?</code>, 显示最后命令的退出状态,0表示没有错误,其他任何值表明有错误</li>
</ul>
<h2 id="信号详情"><a href="#信号详情" class="headerlink" title="信号详情"></a>信号详情</h2><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">默认动作</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SIGHUP</td>
<td align="left">终止进程</td>
<td align="left">终端线路挂断</td>
</tr>
<tr>
<td align="left">SIGINT</td>
<td align="left">终止进程</td>
<td align="left">中断进程</td>
</tr>
<tr>
<td align="left">SIGQUIT</td>
<td align="left">建立CORE文件</td>
<td align="left">终止进程，并且生成core文件</td>
</tr>
<tr>
<td align="left">SIGILL</td>
<td align="left">建立CORE文件</td>
<td align="left">非法指令</td>
</tr>
<tr>
<td align="left">SIGTRAP</td>
<td align="left">建立CORE文件</td>
<td align="left">跟踪自陷</td>
</tr>
<tr>
<td align="left">SIGBUS</td>
<td align="left">建立CORE文件</td>
<td align="left">总线错误</td>
</tr>
<tr>
<td align="left">SIGSEGV</td>
<td align="left">建立CORE文件</td>
<td align="left">段非法错误</td>
</tr>
<tr>
<td align="left">SIGFPE</td>
<td align="left">建立CORE文件</td>
<td align="left">浮点异常</td>
</tr>
<tr>
<td align="left">SIGIOT</td>
<td align="left">建立CORE文件</td>
<td align="left">执行I&#x2F;O自陷</td>
</tr>
<tr>
<td align="left">SIGKILL</td>
<td align="left">终止进程</td>
<td align="left">杀死进程</td>
</tr>
<tr>
<td align="left">SIGPIPE</td>
<td align="left">终止进程</td>
<td align="left">向一个没有读进程的管道写数据</td>
</tr>
<tr>
<td align="left">SIGALARM</td>
<td align="left">终止进程</td>
<td align="left">计时器到时</td>
</tr>
<tr>
<td align="left">SIGTERM</td>
<td align="left">终止进程</td>
<td align="left">软件终止信号</td>
</tr>
<tr>
<td align="left">SIGSTOP</td>
<td align="left">停止进程</td>
<td align="left">非终端来的停止信号</td>
</tr>
<tr>
<td align="left">SIGTSTP</td>
<td align="left">停止进程</td>
<td align="left">终端来的停止信号</td>
</tr>
<tr>
<td align="left">SIGCONT</td>
<td align="left">忽略信号</td>
<td align="left">继续执行一个停止的进程</td>
</tr>
<tr>
<td align="left">SIGURG</td>
<td align="left">忽略信号</td>
<td align="left">I&#x2F;O紧急信号</td>
</tr>
<tr>
<td align="left">SIGIO</td>
<td align="left">忽略信号</td>
<td align="left">描述符上可以进行I&#x2F;O</td>
</tr>
<tr>
<td align="left">SIGCHLD</td>
<td align="left">忽略信号</td>
<td align="left">当子进程停止或退出时通知父进程</td>
</tr>
<tr>
<td align="left">SIGTTOU</td>
<td align="left">停止进程</td>
<td align="left">后台进程写终端</td>
</tr>
<tr>
<td align="left">SIGTTIN</td>
<td align="left">停止进程</td>
<td align="left">后台进程读终端</td>
</tr>
<tr>
<td align="left">SIGXGPU</td>
<td align="left">终止进程</td>
<td align="left">CPU时限超时</td>
</tr>
<tr>
<td align="left">SIGXFSZ</td>
<td align="left">终止进程</td>
<td align="left">文件长度过长</td>
</tr>
<tr>
<td align="left">SIGWINCH</td>
<td align="left">忽略信号</td>
<td align="left">窗口大小发生变化</td>
</tr>
<tr>
<td align="left">SIGPROF</td>
<td align="left">终止进程</td>
<td align="left">统计分布图用计时器到时</td>
</tr>
<tr>
<td align="left">SIGUSR1</td>
<td align="left">终止进程</td>
<td align="left">用户定义信号1</td>
</tr>
<tr>
<td align="left">SIGUSR2</td>
<td align="left">终止进程</td>
<td align="left">用户定义信号2</td>
</tr>
<tr>
<td align="left">SIGVTALRM</td>
<td align="left">终止进程</td>
<td align="left">虚拟计时器到时</td>
</tr>
</tbody></table>
<h2 id="linux-build-essential是什么"><a href="#linux-build-essential是什么" class="headerlink" title="linux build-essential是什么"></a>linux build-essential是什么</h2><p><code>build-essential</code> 是一个针对 Linux 系统的软件包集合，旨在提供编译和构建软件所需的基本工具和库。它通常包括一些核心的开发工具，如 <code>gcc</code> 编译器、<code>g++</code> 编译器、<code>make</code> 构建工具等。这些工具对于编译和构建大多数软件项目都是必需的。</p>
<p>在许多基于 Debian 的发行版（比如 Ubuntu）中，可以通过包管理器如 <code>apt</code> 来安装 <code>build-essential</code>。在安装了这个软件包之后，你就能够开始在你的 Linux 系统上编译和构建各种 C、C++ 或其他语言的程序。</p>
<h2 id="linux-build-essential详解"><a href="#linux-build-essential详解" class="headerlink" title="linux build-essential详解"></a>linux build-essential详解</h2><p><code>build-essential</code> 是针对 Debian 和基于 Debian 的 Linux 发行版（如 Ubuntu）的一个元包（meta-package），它捆绑了一系列用于软件编译和构建的基本工具和库。这个软件包的安装通常是在开始开发或编译源代码之前需要进行的一个重要步骤。</p>
<p>以下是 <code>build-essential</code> 软件包通常包含的一些主要组件：</p>
<ol>
<li><p><strong>编译器</strong>：</p>
<ul>
<li><code>gcc</code>：GNU Compiler Collection，用于编译 C 代码。</li>
<li><code>g++</code>：GNU C++ 编译器，用于编译 C++ 代码。</li>
</ul>
</li>
<li><p><strong>构建工具</strong>：</p>
<ul>
<li><code>make</code>：一种自动化构建工具，通过 Makefile 文件管理源代码的编译和构建过程。</li>
<li><code>dpkg-dev</code>：包含了构建 Debian 软件包所需的工具。</li>
</ul>
</li>
<li><p><strong>库文件</strong>：</p>
<ul>
<li><code>libc6-dev</code>：C 语言标准库的头文件和其他开发文件。</li>
<li>其他可能需要的开发库文件，具体依赖于项目的需求。</li>
</ul>
</li>
</ol>
<p>安装 <code>build-essential</code> 软件包可以简化软件开发和编译过程，因为它提供了必要的工具和库，使用户能够在系统上直接编译和构建源代码而无需手动安装每个单独的组件。通过包管理器（如 <code>apt</code>）安装 <code>build-essential</code> 是相对简单和方便的。</p>
<p>要安装 <code>build-essential</code> 软件包，在终端中执行以下命令（假设你的系统使用的是 <code>apt</code> 包管理器）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install build-essential</span><br></pre></td></tr></table></figure>

<p>这样做会自动安装 <code>build-essential</code> 及其所包含的工具和库，使你可以立即开始进行软件开发、编译和构建工作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-linux_1_01_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-linux_1_01_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">linux_1_01_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux系统的相关理论知识</li>
</ul>
<h2 id="linux-psmisc-软件包-详解"><a href="#linux-psmisc-软件包-详解" class="headerlink" title="linux psmisc 软件包 详解"></a>linux psmisc 软件包 详解</h2><p><code>psmisc</code> 是一个用于 Linux 操作系统的软件包，它包含了一些有用的进程管理工具，通常用于查找和操作进程。以下是有关 <code>psmisc</code> 软件包的详细信息和一些常见工具：</p>
<ol>
<li><p><strong><code>killall</code> 命令</strong>：<code>killall</code> 命令用于终止具有指定名称的进程。通常，您可以提供要终止的进程的名称，然后 <code>killall</code> 会尝试找到并终止所有与该名称匹配的进程。</p>
<p>示例用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall process_name</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>pkill</code> 命令</strong>：<code>pkill</code> 命令允许根据进程的名称或其他属性来终止进程。与 <code>killall</code> 不同，<code>pkill</code> 具有更多的灵活性，可以使用正则表达式等来匹配进程。</p>
<p>示例用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -u username process_name</span><br></pre></td></tr></table></figure>

<p>这将终止特定用户 (<code>-u</code> 参数) 启动的具有特定名称的进程。</p>
</li>
<li><p><strong><code>pstree</code> 命令</strong>：<code>pstree</code> 命令用于以树形结构显示系统上的进程，显示进程之间的父子关系，使您可以更好地了解进程之间的关联。</p>
<p>示例用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree</span><br></pre></td></tr></table></figure>

<p>这将显示整个进程树。</p>
</li>
<li><p><strong><code>fuser</code> 命令</strong>：<code>fuser</code> 命令用于查找正在使用特定文件或文件系统的进程。它可以帮助您找出哪个进程占用了文件或目录。</p>
<p>示例用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser -u filename</span><br></pre></td></tr></table></figure>

<p>这将列出正在使用指定文件的进程，并显示它们的用户名。</p>
</li>
<li><p><strong><code>peekfd</code> 命令</strong>：<code>peekfd</code> 命令用于查看进程的文件描述符。它可以用于监视进程的文件操作。</p>
<p>示例用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peekfd process_id</span><br></pre></td></tr></table></figure>

<p>这将显示指定进程的文件描述符信息。</p>
</li>
</ol>
<p><code>psmisc</code> 软件包提供了这些实用工具，可用于查找和管理进程，以及诊断与进程相关的问题。这些工具在系统管理员和开发人员之间广泛使用，用于处理进程管理任务。如果您需要执行进程管理操作或诊断进程相关问题，<code>psmisc</code> 软件包是一个有用的工具集。要在大多数 Linux 发行版中安装它，您可以使用包管理器，如 <code>apt</code>（Debian&#x2F;Ubuntu）或 <code>yum</code>（Red Hat&#x2F;CentOS）。</p>
<h2 id="常见的处理器架构"><a href="#常见的处理器架构" class="headerlink" title="常见的处理器架构"></a>常见的处理器架构</h2><p>计算机领域中有许多不同的处理器架构，每种都有其独特的特点和用途。以下是一些常见的处理器架构：</p>
<ol>
<li><p><strong>x86&#x2F;x86-64（Intel和AMD）：</strong> x86 架构是最常见的桌面和服务器处理器架构之一。x86-64 是其 64 位版本，也被称为 AMD64。它广泛用于个人计算机、工作站和服务器。</p>
</li>
<li><p><strong>ARM：</strong> ARM 架构是一种低功耗、高性能的处理器架构，广泛用于移动设备、嵌入式系统、物联网设备和一些服务器。它是许多智能手机和平板电脑的基础。</p>
</li>
<li><p><strong>PowerPC：</strong> PowerPC 架构最初由 IBM、Motorola 和苹果合作开发，用于 Macintosh 计算机。虽然在桌面领域的份额不大，但在嵌入式和服务器市场中仍有用武之地。</p>
</li>
<li><p><strong>SPARC（Scalable Processor Architecture）：</strong> SPARC 架构是由甲骨文公司开发的，用于高性能计算和企业级服务器。它具有强大的多线程能力。</p>
</li>
<li><p><strong>MIPS（Microprocessor without Interlocked Pipeline Stages）：</strong> MIPS 架构用于嵌入式系统、网络设备和某些路由器。它还曾用于一些游戏机，如索尼的 PlayStation。</p>
</li>
<li><p><strong>RISC-V：</strong> RISC-V 是一种开源的指令集架构，具有灵活性，广泛用于教育、嵌入式系统和一些自定义处理器的设计。</p>
</li>
<li><p><strong>Itanium（IA-64）：</strong> Itanium 架构是由英特尔和HP合作开发的，用于高性能计算和企业级服务器。然而，它在市场上的成功有限，已经逐渐被其他架构取代。</p>
</li>
<li><p><strong>Z系列（IBM System z）：</strong> Z 系列是 IBM 用于大型企业主机的处理器架构，用于处理高度事务性的应用程序。</p>
</li>
<li><p><strong>Alpha：</strong> Alpha 架构是由 DEC（Digital Equipment Corporation）开发的高性能 RISC 处理器架构，已经停止生产，但曾在科学计算和高性能计算中广泛使用。</p>
</li>
</ol>
<p>这只是一些常见的处理器架构，还有许多其他特定用途的架构和自定义架构，适用于各种不同的应用领域。不同的处理器架构适合不同的用途，选择取决于性能、功耗、成本和应用程序的需求。</p>
<h2 id="芯片架构-amd-x86-64-详解"><a href="#芯片架构-amd-x86-64-详解" class="headerlink" title="芯片架构 amd x86_64 详解"></a>芯片架构 amd x86_64 详解</h2><p>“AMD x86_64”，也称为”AMD64”或”x86-64”，是一种 64 位的 CPU 架构，由 AMD 公司于 2003 年首次引入。它是一种扩展的 x86 架构，用于替代传统的 32 位 x86 架构，以支持更大的内存寻址范围和更高的性能。以下是 AMD x86_64 架构的一些详细信息：</p>
<ol>
<li><p><strong>寻址范围：</strong> 最显著的优势是它可以寻址更大的内存范围。32 位系统的极限是约 4GB 内存，而 x86_64 架构可以支持数百 TB（1 TB &#x3D; 1024 GB）的内存，这使得它特别适用于大规模数据处理和高性能计算任务。</p>
</li>
<li><p><strong>寄存器：</strong> AMD x86_64 架构引入了更多的通用寄存器和 SIMD（单指令多数据）寄存器，这有助于提高并行计算性能。</p>
</li>
<li><p><strong>指令集：</strong> x86_64 架构是对传统 x86 指令集的扩展，增加了一些新的指令，以提高性能和支持更多的数据类型。它仍然能够运行 32 位的 x86 软件，通过一种称为“兼容模式”的方式。</p>
</li>
<li><p><strong>操作系统支持：</strong> 主流操作系统，包括 Windows、Linux 和 macOS，都支持 AMD x86_64 架构。这使得它成为通用计算平台的首选架构。</p>
</li>
<li><p><strong>性能：</strong> 64 位的处理能力和更多的寄存器通常导致更好的性能，特别是在处理大规模数据和复杂计算时。</p>
</li>
<li><p><strong>虚拟化：</strong> AMD x86_64 架构还增强了虚拟化支持，使得在一个物理主机上运行多个虚拟机成为可能。</p>
</li>
<li><p><strong>兼容性：</strong> 大多数现有的 32 位 x86 软件可以在 x86_64 系统上运行，通常通过一种称为“多架构支持”的方式，同时也能够运行专为 64 位系统编译的软件。</p>
</li>
</ol>
<p>总之，AMD x86_64 架构是一种高性能、高扩展性的架构，适用于各种计算任务，从桌面计算机到数据中心服务器。它已成为现代计算领域的标准之一，广泛用于各种计算场景。</p>
<h2 id="sha256码"><a href="#sha256码" class="headerlink" title="sha256码"></a>sha256码</h2><p>SHA-256（安全散列算法 256 位）是一种密码散列函数，用于将输入数据（消息）转换为 256 位（32 字节）的散列值。这个散列值通常以十六进制表示，由 64 个字符组成。SHA-256 是 SHA-2 家族中的一员，提供了高度的安全性和散列性能，广泛用于密码学、数字签名、数据完整性验证以及其他安全相关应用。</p>
<p>SHA-256 的主要特点包括：</p>
<ol>
<li><p><strong>不可逆性（One-way Function）</strong>：无法从散列值还原出原始输入数据。你可以计算散列值，但不能反向计算出输入数据。</p>
</li>
<li><p><strong>唯一性</strong>：不同的输入数据将产生不同的 SHA-256 散列值。即使输入数据仅有微小的改变，也会导致不同的散列值。</p>
</li>
<li><p><strong>固定长度</strong>：SHA-256 的输出始终是 256 位（32 字节）的散列值。</p>
</li>
<li><p><strong>抗碰撞（Collision Resistance）</strong>：在实际应用中，很难找到两个不同的输入数据产生相同的 SHA-256 散列值。</p>
</li>
</ol>
<p>SHA-256 在许多领域都有广泛的应用，包括密码学、数字签名、区块链、数据完整性验证、密码存储等。它被认为是目前非常安全的散列算法之一，因为攻击者需要耗费极大的计算资源才能破解或找到碰撞（相同散列值的两个不同输入数据）。</p>
<p>要计算数据的 SHA-256 散列值，你可以使用各种编程语言和工具库提供的函数或命令。例如，在 Linux 命令行中，你可以使用以下命令计算一个文件的 SHA-256 散列值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sha256sum</span> file_name</span><br></pre></td></tr></table></figure>

<p>其中 <code>file_name</code> 是要计算散列值的文件名。</p>
<p>请注意，SHA-256 散列值通常用于验证数据的完整性，而不是加密数据。要加密数据，通常需要使用加密算法而不是散列函数。</p>
<h2 id="dpkg-dev-详解"><a href="#dpkg-dev-详解" class="headerlink" title="dpkg-dev 详解"></a>dpkg-dev 详解</h2><p>在Ubuntu中，<code>dpkg-dev</code> 是一个软件包，提供了一些开发工具和功能，用于创建和管理 Debian 软件包。Debian 软件包是 Ubuntu 及其衍生版操作系统所使用的软件包格式。<code>dpkg-dev</code> 工具使得创建、构建和管理这些软件包变得更加容易和自动化。</p>
<p>以下是 <code>dpkg-dev</code> 的一些主要功能和用法的详细解释：</p>
<ol>
<li><p><strong>创建 Debian 软件包：</strong><br><code>dpkg-dev</code> 提供了 <code>dh_make</code> 工具，用于生成初始的 Debian 软件包模板。该工具可以根据源代码目录自动创建 <code>debian/</code> 目录和一些必要的文件，以便开始构建一个 Debian 软件包。</p>
</li>
<li><p><strong>构建 Debian 软件包：</strong><br>使用 <code>dpkg-buildpackage</code> 工具可以根据软件包的源代码和 <code>debian/</code> 目录中的控制文件，自动构建 Debian 软件包。该工具会编译源代码、创建二进制文件、打包文件和文档，并生成一个完整的 Debian 软件包。</p>
</li>
<li><p><strong>修改和更新软件包：</strong><br>在修改现有的 Debian 软件包时，<code>dpkg-dev</code> 工具提供了一些有用的工具和指南，以确保正确地进行修改并更新软件包的版本号、更新说明等信息。</p>
</li>
<li><p><strong>软件包信息和元数据：</strong><br><code>dpkg-dev</code> 包含一些工具来查看和检查软件包的信息和元数据。例如，<code>dpkg-deb</code> 工具可以用于查看软件包文件的详细信息，而 <code>dpkg-genchanges</code> 工具可以生成变更记录文件。</p>
</li>
<li><p><strong>生成软件包差异：</strong><br><code>dpkg-dev</code> 提供了 <code>dpkg-gencontrol</code> 和 <code>dpkg-genchanges</code> 等工具，用于生成二进制软件包和源代码软件包之间的差异文件，方便软件包的升级和维护。</p>
</li>
</ol>
<p>请注意，<code>dpkg-dev</code> 工具通常用于开发人员和软件打包者，而普通用户通常不需要直接使用这些工具。如果您只是想使用和安装 Debian 软件包，请使用 <code>apt</code> 命令，它是 Ubuntu 包管理器的前端，会自动处理软件包的下载、安装和依赖关系。</p>
<p>如果您对软件包的开发和打包有兴趣，可以参考 <code>dpkg-dev</code> 的文档和相关资源，了解更多详细信息和使用方法。</p>
<h2 id="ubuntu-ftp-服务器-详解"><a href="#ubuntu-ftp-服务器-详解" class="headerlink" title="ubuntu ftp 服务器 详解"></a>ubuntu ftp 服务器 详解</h2><p>在 Ubuntu 上设置 FTP 服务器通常可以使用 vsftpd（Very Secure FTP Daemon）。vsftpd 是一个非常流行的 FTP 服务器软件，它被设计为简单、安全且高效。以下是在 Ubuntu 上搭建 vsftpd FTP 服务器的详细步骤：</p>
<ol>
<li>安装 vsftpd：<br>打开终端，使用以下命令安装 vsftpd：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install vsftpd</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置 vsftpd：<br>安装完成后，您需要进行一些配置来设置 FTP 服务器的参数。主要的配置文件是 <code>/etc/vsftpd.conf</code>，您可以使用文本编辑器（如 nano 或 vim）来编辑该文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>

<p>在该文件中，您可以根据需要调整一些设置，例如：</p>
<ul>
<li><p>启用或禁用匿名访问：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=YES   <span class="comment"># 允许匿名访问</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=NO    <span class="comment"># 禁止匿名访问</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置本地用户访问：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local_enable=YES       <span class="comment"># 允许本地用户登录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置写权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write_enable=YES       <span class="comment"># 允许用户上传文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定用户根目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local_root=/home/ftp   <span class="comment"># 指定FTP用户的根目录</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>重新启动 vsftpd：<br>编辑配置文件后，保存并退出文本编辑器。然后，重新启动 vsftpd 以应用新的配置：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart vsftpd</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>防火墙设置：<br>如果您的系统上启用了防火墙（如 ufw），需要允许 FTP 的数据传输端口（默认为 20 和 21 端口）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 20/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 21/tcp</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>添加 FTP 用户（可选）：<br>如果您希望用户可以访问 FTP 服务器并上传文件，您需要在系统上创建相应的本地用户。您可以使用以下命令创建新用户并设置密码：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> adduser ftpuser  <span class="comment"># 创建名为 &quot;ftpuser&quot; 的用户</span></span><br><span class="line"><span class="built_in">sudo</span> passwd ftpuser   <span class="comment"># 设置 &quot;ftpuser&quot; 用户的密码</span></span><br></pre></td></tr></table></figure>

<p>现在，您的 Ubuntu 系统上已经成功安装和配置了 vsftpd FTP 服务器。用户可以使用 FTP 客户端连接到您的服务器，上传和下载文件。请注意，为了保障数据传输的安全，建议使用 SFTP（SSH File Transfer Protocol）或 FTPS（FTP Secure，基于 TLS&#x2F;SSL 加密）等加密的方式进行传输。</p>
<h2 id="linux-可用交换内存-与实际空闲内存-区别-详解"><a href="#linux-可用交换内存-与实际空闲内存-区别-详解" class="headerlink" title="linux 可用交换内存 与实际空闲内存 区别 详解"></a>linux 可用交换内存 与实际空闲内存 区别 详解</h2><p>在Linux系统中，有两种类型的内存可用性，分别是可用交换内存（Swap）和实际空闲内存（Free Memory）。这两者的区别如下：</p>
<ol>
<li><p>可用交换内存（Swap）：<br>可用交换内存是指交换空间（Swap Space）中未被使用的内存。交换空间是指硬盘上专门用于作为虚拟内存的一部分。当系统的物理内存（RAM）不足时，Linux系统会将一部分不常用的内存页面转移到交换空间，以释放物理内存给正在运行的进程使用。这个过程称为交换（Swap）。</p>
<p>交换空间的设置对于系统性能是有益的，因为它可以避免系统的物理内存耗尽，从而防止系统崩溃或应用程序因为内存不足而崩溃。然而，当系统频繁进行交换时，会导致性能下降，因为硬盘速度远慢于内存访问速度。</p>
<p>在Linux系统中，你可以使用<code>free</code>命令查看交换内存的情况，其中的<code>Swap</code>列显示的就是可用交换内存。</p>
</li>
<li><p>实际空闲内存（Free Memory）：<br>实际空闲内存是指当前未被任何进程使用的物理内存。它是系统中真正空闲可用的内存，可以用于立即分配给新的进程或者已经运行的进程的内存需求。实际空闲内存直接影响着系统的性能，因为足够的空闲内存可以保证系统响应速度和运行稳定性。</p>
<p>同样，你可以使用<code>free</code>命令查看实际空闲内存，其中的<code>free</code>列显示的是实际空闲内存的大小。</p>
</li>
</ol>
<p>需要注意的是，虽然可用交换内存（Swap）可以提供一种缓解内存不足的方式，但它并不能完全替代实际的物理内存。当系统过度依赖交换空间来弥补物理内存的不足时，会导致系统性能下降，因为交换到硬盘的数据访问速度较慢。因此，对于性能敏感的应用和系统，建议增加物理内存以避免频繁的交换行为。</p>
<h2 id="debian-NetworkManager-详解"><a href="#debian-NetworkManager-详解" class="headerlink" title="debian NetworkManager 详解"></a>debian NetworkManager 详解</h2><p>NetworkManager 是一个用于在 Linux 系统上管理网络连接的服务和工具集。它是一个常见的网络管理器，广泛用于各种 Linux 发行版中，包括 Debian。</p>
<p>下面是关于 NetworkManager 在 Debian 上的一些详细说明：</p>
<ol>
<li><p>功能：NetworkManager 提供了一种集中管理网络连接的方式，包括有线连接、Wi-Fi 连接、移动数据连接等。它可以自动检测和配置网络设备，管理 IP 地址、DNS 设置、路由表等网络参数，以及处理连接的自动连接、断开和重连。</p>
</li>
<li><p>配置文件：NetworkManager 的配置文件通常位于 <code>/etc/NetworkManager/</code> 目录下。其中，<code>/etc/NetworkManager/NetworkManager.conf</code> 是主要的配置文件，定义了全局配置选项。此外，每个用户的网络连接配置存储在 <code>/etc/NetworkManager/system-connections/</code> 目录下。</p>
</li>
<li><p>命令行工具：Debian 提供了一组命令行工具用于管理 NetworkManager。其中，<code>nmcli</code> 是一个强大的命令行界面工具，用于配置和管理网络连接。你可以使用 <code>nmcli</code> 查看连接状态、添加、编辑或删除网络连接配置，以及执行其他与网络管理相关的操作。</p>
</li>
<li><p>图形界面：Debian 也提供了各种图形界面工具来管理 NetworkManager。其中，<code>nm-applet</code> 是 NetworkManager 的系统托盘应用程序，提供了一个简单的界面来查看和管理网络连接。此外，许多桌面环境（如 GNOME、KDE 等）也提供自己的网络管理工具，可以与 NetworkManager 集成。</p>
</li>
<li><p>集成和兼容性：NetworkManager 与许多网络设备和协议兼容，并能与各种网络服务和工具集成。它支持以太网、Wi-Fi、移动数据（3G&#x2F;4G）等多种连接类型，并与 DHCP、DNS、VPN、PPPoE 等网络服务协议配合工作。</p>
</li>
</ol>
<p>总体而言，NetworkManager 提供了一种方便和灵活的方式来管理网络连接，在 Debian 系统中被广泛使用。它通过命令行工具和图形界面工具提供了多种管理选项，可适应各种网络环境和需求。</p>
<p>要深入了解 NetworkManager 的使用和配置，请参考 Debian 官方文档和 NetworkManager 的官方文档，以获得更详细和准确的信息。</p>
<h2 id="dummy-output"><a href="#dummy-output" class="headerlink" title="dummy output"></a>dummy output</h2><p>“dummy output” 是一个常见的术语，用于描述一个没有实际输出或功能的占位符或虚拟输出。</p>
<p>在计算机领域中，”dummy output” 通常用于表示一个虚拟的输出设备或占位符，它不会实际产生任何输出，或者仅仅是为了满足某些需求而存在。这种虚拟输出通常用于测试、模拟或占位的目的。</p>
<p>例如，在音频设备的设置中，你可能会看到一个名为 “dummy output” 的选项。这个选项表示一个虚拟的输出设备，用于模拟音频输出，而不是实际连接到物理设备。它可以用于测试音频设置或在没有物理音频设备的情况下进行音频处理。</p>
<p>类似地，在软件开发中，”dummy output” 也可以指代一个占位符或虚拟的输出对象。它可能是一个空函数、空类或其他形式的占位符，用于满足代码结构或接口的要求，但没有实际的功能或输出。</p>
<p>总的来说，”dummy output” 表示一个没有实际输出或功能的占位符或虚拟输出，通常用于测试、模拟或占位的目的。</p>
<hr>
<h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p><code>systemd</code> 是用于管理Linux系统的初始化进程和服务管理器。它是最新的系统初始化方案，用于代替传统的 <code>init</code> 系统。<code>systemd</code> 提供了一套功能丰富的命令行工具，用于管理系统服务、单元（units）、日志和其他系统资源。</p>
<p>下面是一些常用的 <code>systemd</code> 命令及其简要说明：</p>
<ol>
<li><p><code>systemctl</code>：<code>systemctl</code> 命令用于管理系统服务，包括启动、停止、重启、启用、禁用等操作。例如：</p>
<ul>
<li>启动服务：<code>systemctl start service-name</code></li>
<li>停止服务：<code>systemctl stop service-name</code></li>
<li>重启服务：<code>systemctl restart service-name</code></li>
<li>启用服务：<code>systemctl enable service-name</code></li>
<li>禁用服务：<code>systemctl disable service-name</code></li>
</ul>
</li>
<li><p><code>journalctl</code>：<code>journalctl</code> 命令用于查看系统日志，可以显示 <code>systemd</code> 单元的日志、内核消息等。例如：</p>
<ul>
<li>查看所有日志：<code>journalctl</code></li>
<li>查看特定服务的日志：<code>journalctl -u service-name</code></li>
<li>根据时间范围过滤日志：<code>journalctl --since &quot;2022-01-01&quot; --until &quot;2022-01-02&quot;</code></li>
</ul>
</li>
<li><p><code>systemd-analyze</code>：<code>systemd-analyze</code> 命令用于分析系统启动时间和性能。例如：</p>
<ul>
<li>显示启动时间：<code>systemd-analyze</code></li>
<li>显示关键路径：<code>systemd-analyze critical-chain</code></li>
<li>显示各个服务的启动时间：<code>systemd-analyze blame</code></li>
</ul>
</li>
<li><p><code>systemd-resolve</code>：<code>systemd-resolve</code> 命令用于管理系统的网络解析器和 DNS 配置。例如：</p>
<ul>
<li>查看 DNS 服务器：<code>systemd-resolve --status</code></li>
<li>清除 DNS 缓存：<code>systemd-resolve --flush-caches</code></li>
</ul>
</li>
</ol>
<p>这只是 <code>systemd</code> 提供的一小部分命令，它还具有许多其他功能和选项，可用于管理系统的各个方面。您可以通过查阅 <code>systemd</code> 的官方文档或运行 <code>man</code> 命令来获取更详细的信息，例如 <code>man systemctl</code>、<code>man journalctl</code> 等。</p>
<hr>
<h2 id="压缩与解压"><a href="#压缩与解压" class="headerlink" title="压缩与解压"></a>压缩与解压</h2><ul>
<li>将文件压缩不只是为了节省硬盘空间,同时也可以节省网络传输时间,归档文件方便管理等</li>
<li>压缩可分为无损压缩与有损压缩两种,但不管是采用何种技术模型,其本质内容都是一样的,即** 通过某种特殊的编码方式将数据信息中存在的重复度,冗余度有效地降低,从而达到数据压缩的目的** </li>
<li>在Linux中很多压缩程序只能针对一个文件进行压缩,当要压缩一大堆文件时,首先得先将一堆文件打成一个包(tar命令),然后再用压缩程序进行压缩(gzip, bzip2命令),就是说压缩会分为两步:先打包再压缩</li>
<li>打包,tar命令可以将多个文件和目录创建一个档案(归档),tar最初是用来在磁带上创建档案;tar命令也可以修改档案中的文件,或者加入新的文件;使用tar程序打出来的包常称为tar包,tar包通常以<code>.tar</code>结尾</li>
<li>归档的一般用途:<ul>
<li>把一大堆的文件和目录打包成一个tar包,便于网络传输</li>
<li>生成tar包后,再用其他的程序进行压缩</li>
</ul>
</li>
<li>压缩<ul>
<li>gzip,是GNUzip的缩写,它是一个GNU自由软件的文件压缩程序,文件经过它压缩以后以<code>.gz</code>为扩展名.</li>
<li>gzip不能用来压缩目录,需要先归档目录,然后再压缩,gzip和tar一起构成了Linux操作系统中流行的文件压缩格式(<code>.tar.gz</code>)</li>
</ul>
</li>
</ul>
<h2 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h2><ul>
<li>“一切皆文件”是Unix&#x2F;Linux的基本哲学之一,它是指Linux系统中的所有的一切都可以通过文件的方式访问和管理,即使不是文件,也以文件的形式来管理.例如硬件设备,进程,套接字等都抽象成文件,使用统一的用户接口,虽然文件类型各不相同,但是对其提供的却是同一套操作</li>
<li>这里的一切都是单项的,也即所有的东西都单向通过文件系统呈现,反向不一定可行.例如:通过新建文件的方式来创建磁盘设备是行不通的</li>
<li>在Linux中共有7种类型的文件,分为3大类:<ul>
<li><code>-</code> : 普通文件,包括文本文件和二进制文件</li>
<li><code>d</code> : 目录文件(文件夹文件)</li>
<li>特殊文件<ul>
<li><code>l</code> : 链接文件</li>
<li><code>c</code> : 字符设备文件</li>
<li><code>s</code> : 套接字(Socket)文件,用于网络通讯,一般由应用程序创建</li>
<li><code>p</code> : 命名管道文件</li>
<li><code>b</code> : 块文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Linux文件基本属性"><a href="#Linux文件基本属性" class="headerlink" title="Linux文件基本属性"></a>Linux文件基本属性</h2><ul>
<li><p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等</p>
<ul>
<li>当为 <code>d</code> 则是目录</li>
<li>当为 <code>-</code> 则是文件</li>
<li>若是 <code>l</code> 则表示为链接文档(link file)</li>
<li>若是 <code>b</code> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)</li>
<li>若是 <code>c</code> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)</li>
</ul>
</li>
<li><p>接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)</p>
</li>
<li><p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已</p>
</li>
<li><p>每个文件的属性由左边第一部分的 10 个字符来确定</p>
</li>
<li><p>从左至右用 0-9 这些数字来表示</p>
<ul>
<li>第 0 位确定文件类型，</li>
<li>第 1-3 位确定属主（该文件的所有者）拥有该文件的权限</li>
<li>第 4-6 位确定属组（所有者的同组用户）拥有该文件的权限</li>
<li>第 7-9 位确定其他用户拥有该文件的权限</li>
</ul>
</li>
<li><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户</p>
</li>
<li><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组</p>
</li>
<li><p>文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户</p>
</li>
<li><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限</p>
</li>
<li><p>Linux文件属性有两种设置方法，一种是数字，一种是符号</p>
</li>
<li><p>Linux 文件的基本权限就有九个，分别是 owner&#x2F;group&#x2F;others(拥有者&#x2F;组&#x2F;其他) 三种身份各有自己的 read&#x2F;write&#x2F;execute 权限</p>
</li>
<li><p>文件的权限字符为： -rwxrwxrwx ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限</p>
<ul>
<li>r  –  4</li>
<li>w  –  2</li>
<li>x  –  1</li>
</ul>
</li>
<li><p>每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为： -rwxrwx— 分数则是</p>
<ul>
<li>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</li>
</ul>
</li>
</ul>
<h2 id="inode索引节点"><a href="#inode索引节点" class="headerlink" title="inode索引节点"></a>inode索引节点</h2><ul>
<li><p><code>inode</code> 是理解<code>Unix/Linux</code>文件系统和硬盘存储的基础</p>
</li>
<li><p>理解<code>inode</code>,不仅有助于提高系统操作水平,还有助于体会Unix设计哲学,即如何把底层的复杂性抽象成一个简单概念,从而大大简化用户接口</p>
</li>
<li><p><code>inode</code>是什么?</p>
<ul>
<li>理解<code>inode</code>,要从文件存储说起 – 文件储存在硬盘上,硬盘的最小存储单位叫做<strong>扇区(<code>Sector</code>)</strong> ,每个扇区储存<code>512</code>字节(相当于<code>0.5KB</code>)</li>
<li>操作系统读取硬盘的时候,不会一个扇区一个扇区地读取,这样效率太低.而是<strong>一次性连续读取多个扇区,即一次性读取一个块(<code>block</code>)</strong>,这种由多个扇区组成的<strong>块</strong> ,是文件存取的最小单位.<strong>块</strong> 的大小通常是<code>4KB</code>,即连续八个扇区(<code>sector</code>)组成一个块(<code>block</code>)</li>
<li>文件数据都存储在块中,那么还需要一个地方储存文件的<strong>元信息</strong> ,比如文件的创建者,文件的创建日期,文件的大小等.<strong>这种储存文件元信息的区域就叫做<code>inode</code></strong> ,中文译名为<strong>索引节点</strong> </li>
<li>每一个文件都有对应的inode,里面包含了与该文件有关的信息</li>
</ul>
</li>
<li><p><code>inode</code>的内容:</p>
<ul>
<li><code>inode</code>包含文件的元信息,具体来说有:<ul>
<li>文件的字节数</li>
<li>文件拥有者的<code>User ID</code></li>
<li>文件用户组的<code>Group ID</code></li>
<li>文件的读,写,执行权限</li>
<li>文件的时间戳,共有三个<ul>
<li><code>ctime</code>,指inode上一次变动的时间</li>
<li><code>mtime</code>,指文件内容上一次变动的时间</li>
<li><code>atime</code>,指文件上一次打开的时间</li>
</ul>
</li>
<li>链接数,即有多少文件名指向这个<code>inode</code></li>
<li>文件数据<code>block</code>的位置</li>
</ul>
</li>
<li>可以使用<code>stat</code>命令,查看某个文件的inode信息</li>
</ul>
</li>
<li><p><code>inode</code>的大小</p>
<ul>
<li><code>inode</code>也会消耗硬盘空间,所以在格式化硬盘的时候,操作系统自动将硬盘分成两个区域,一个是数据区,存放文件数据;另一个是<code>inode</code>区(<code>inode table</code>),存放<code>inode</code>所包含的信息</li>
<li><code>inode</code>节点一般占用<code>128</code>字节或<code>256</code>字节.<code>inode</code>节点的总数,在格式化时会自动设定.一般是每<code>1KB</code>或每<code>2KB</code>就设置一个<code>inode</code></li>
</ul>
</li>
<li><p>inode号码</p>
<ul>
<li>每个<code>inode</code>都有一个号码,操作系统用<code>inode</code>号码来识别不同的文件.</li>
<li><strong><code>Unix/Linux</code>系统内部不使用文件名,而是使用<code>inode</code>号码来识别文件</strong>.对于系统来说,文件名只是inode号码便于识别的别称或者绰号.</li>
<li>表面上,用户通过文件名打开文件.实际上,系统内部将这个过程分为三步:<ul>
<li>系统找到文件名对应的<code>inode</code>号码</li>
<li>通过<code>inode</code>号码,获取<code>inode</code>信息</li>
<li>根据<code>inode</code>信息,找到文件数据所在的<code>block</code>,读出数据</li>
</ul>
</li>
<li>通过命令<code>ls -i filename</code>查看文件名对应的inode号码</li>
</ul>
</li>
<li><p>目录文件</p>
<ul>
<li><code>Unix/Linux</code>系统中,目录(<code>directory</code>)也是一种文件.打开目录,实际上就是打开目录文件</li>
<li>目录文件的结构非常简单,就是一系列目录项(<code>dirent</code>)的列表.每个目录项由两个部分组成:所包含文件的文件名,以及该文件名对应的<code>inode</code>号码</li>
<li><strong>所以在使用<code>ls -lh</code>命令查看文件夹大小时,所有的文件夹只有<code>4KB</code>大小</strong></li>
</ul>
</li>
<li><p><code>inode</code>的特殊作用</p>
<ul>
<li>由于<code>inode</code>号码与文件名分离,这种机制导致了一些<code>Unix/Linux</code>系统特有的现象</li>
<li>当文件名包含特殊字符,无法正常删除时,可以删除<code>inode</code>节点,就能直接删除文件</li>
<li>移动文件或重命名文件,只是改变文件名,不影响<code>inode</code>号码,所以在<code>Linux</code>中移动文件不论大小基本秒成</li>
<li>打开一个文件后,系统就以<code>inode</code>号码来识别文件,不再考虑文件名.因此,系统无法从<code>inode</code>号码得知文件名.</li>
</ul>
</li>
</ul>
<h2 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h2><ul>
<li>在Linux中有两种link(链接)的概念,一般称之为硬链接和软链接(或符号链接)</li>
<li>硬链接<ul>
<li>一般情况下,文件名和inode号码是”一一对应”的关系,每个inode号码对应一个文件名(每个文件默认有一个硬链接).但是Unix&#x2F;Linux系统允许多个文件名指向同一个inode号码</li>
<li>这意味着,可以用不同的文件名访问同样的内容,对文件内容进行修改后,会影响所有文件名.但是,删除一个文件名,不影响另一个文件名的访问,这种情况就被称为”硬链接(hard link)”</li>
<li>创建一个硬链接,就会为文件创建了一个新的文件名.硬链接有两个重要局限性:<ul>
<li>硬链接不能链接不在同一系统的文件,也就是说硬链接不能链接与文件不在同一磁盘分区上的文件;</li>
<li>硬链接不能链接目录</li>
</ul>
</li>
<li>一个硬链接和文件本身没有什么区别.当列出一个包含硬链接的文件时,不会有特殊的链接指示说明.当一个硬链接被删除时,文件本身的内容仍然存在(也就是说,它所占用的磁盘空间不会被重新分配),直到所有关联这个文件的硬链接都删掉.</li>
</ul>
</li>
<li>软链接:<ul>
<li>创建软链接是为了克服硬链接的局限性</li>
<li>软链接是通过创建一个特殊类型的文件(指针)链接到文件或目录,就像windows的快捷方式</li>
<li>文件A和文件B的inode号码虽然不一样,但是文件A的内容是文件B的路径.读取文件A时,系统会自动将访问指向文件B.因此,无论打开哪一个文件,最终读取的都是文件B,但是,文件A依赖于文件B而存在,如果删除了文件B,打开文件A就会报错:”No such file or directory”</li>
<li>软链接与硬链接最大的不同:文件A指向文件B的文件名,而不是文件B的inode号码</li>
</ul>
</li>
</ul>
<h2 id="安全模型与权限"><a href="#安全模型与权限" class="headerlink" title="安全模型与权限"></a>安全模型与权限</h2><ul>
<li>在linux系统中,所有的操作实质上都是在进行进程访问文件的操作.在访问文件之前需要取得相应的权限,而权限是通过Linux系统中的安全模型获得的.理论上进程所拥有的权限与执行它的用户的权限相同.其中涉及的一切内容,都是围绕这个核心进行的.</li>
<li>Linux系统中的安全模型,有两种类型:<ul>
<li>Linux系统上最初的安全模型称为** 自主访问控制(DAC, Discretionary Access Control)** </li>
<li>后来又增加设计了一个新的安全模型叫** 强制访问控制(MAC, Mandatory Access Control)** </li>
<li>MAC和DAC不是互斥的,DAC是最基本的安全模型,也是最常用的访问控制机制,是Linux必须具有的功能;而MAC是构建在DAC智商的加强安全机制,属于可选模块</li>
</ul>
</li>
<li>文件权限控制<ul>
<li>对文件的权限分三组进行控制:<ul>
<li><code>user</code>对文件属主设定的权限</li>
<li><code>group</code>对文件属组设定的权限</li>
<li><code>othre</code>对其他者设定的权限</li>
</ul>
</li>
<li>常用的可设定的权限值,包括:<ul>
<li><code>r</code> : 读权限</li>
<li><code>w</code> : 写权限</li>
<li><code>x</code> : 执行权限</li>
<li><code>s</code> : 强制位权限</li>
<li><code>t</code> : 粘滞位权限</li>
<li><code>i</code> : 不可修改权限</li>
<li><code>a</code> : 只追加权限</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><ul>
<li><code>netstat  -a  # 列出所有端口</code></li>
<li><code>netstat -at  # 列出所有tcp端口</code></li>
<li><code>netstat -au  # 列出所有udp端口</code></li>
<li><code>netstat -l   # 只显示监听端口</code></li>
<li><code>netstat -lt  # 只列出所有监听tcp端口</code></li>
<li><code>netstat -lu  # 只列出所有监听udp端口</code></li>
</ul>
<h3 id="查看指定端口"><a href="#查看指定端口" class="headerlink" title="查看指定端口"></a>查看指定端口</h3><ul>
<li><code>sudo netstat -tlnp | grep 8083</code></li>
<li><code>sudo lsof -i:8083</code></li>
</ul>
<h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><ul>
<li>apt install lsof</li>
</ul>
<h2 id="终端-控制台和shell的区别"><a href="#终端-控制台和shell的区别" class="headerlink" title="终端,控制台和shell的区别"></a>终端,控制台和shell的区别</h2><ul>
<li>终端(terminal)</li>
<li>控制台(console)<ul>
<li>控制台是计算机的基本设备,而终端是附加设备</li>
</ul>
</li>
<li>Shell俗称壳(用来区别于核)<ul>
<li>软件shell,俗称壳,是读取并解释命令的程序.</li>
<li>Shell是一个用C语言编写的程序,它是用户使用Linux的桥梁,用户通过Shell访问操作系统内核的服务</li>
</ul>
</li>
</ul>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><ul>
<li>启动<code>mysql</code><ul>
<li>使用<code>service</code>启动: <code>service mysql start</code></li>
</ul>
</li>
</ul>
<h2 id="Linux系统启动过程"><a href="#Linux系统启动过程" class="headerlink" title="Linux系统启动过程"></a>Linux系统启动过程</h2><ul>
<li>Linux系统的启动过程可以分为五个阶段:<ul>
<li>内核的引导<ul>
<li>当计算机打开电源后,首先是<code>BIOS</code>开机自检,按照<code>BIOS</code>中设置的启动设备(通常是硬盘)来启动.</li>
<li>操作系统接管硬件以后,首先读入<code>/boot</code>目录下的内核文件</li>
</ul>
</li>
<li>运行init<ul>
<li>(init程序的类型)<ul>
<li>SysV:init</li>
<li>Upstart:init</li>
<li>Systemd:systemd</li>
</ul>
</li>
<li><code>init</code>进程是系统所有进程的起点,可以把它比作系统所有进程的老祖宗,没有这个进程,系统中任何进程都不会启动.</li>
</ul>
</li>
<li>系统初始化</li>
<li>建立终端</li>
<li>用户登录系统</li>
</ul>
</li>
</ul>
<h2 id="Linux下RTC时间：系统时间与RTC实时时钟时间"><a href="#Linux下RTC时间：系统时间与RTC实时时钟时间" class="headerlink" title="Linux下RTC时间：系统时间与RTC实时时钟时间"></a>Linux下RTC时间：系统时间与RTC实时时钟时间</h2><ul>
<li>Linux系统下包含两个时间：<strong>系统时间</strong> 和 <strong>RTC时间</strong><ul>
<li>系统时间：是由主芯片的定时器进行维护的时间，一般情况下都会选择芯片上最高精度的定时器作为系统时间的定时基准，以避免在系统运行较长时间后出现大的时间偏移。特点是掉电后不保存</li>
<li>RTC时间：是指系统中包含的RTC芯片内部所维护的时间。RTC芯片都有电池+系统电源的双重供电机制，在系统正常工作时由系统供电，在系统掉电后由电池进行供电。因此系统电源掉电后RTC时间仍然能够正常运行</li>
</ul>
</li>
<li>每次Linux系统启动后在启动过程中会检测和挂在RTC驱动，在挂在后会自动从RTC芯片中读取时间并设置到系统时间中去。此后如果没有显式的通过命令去控制RTC的读写操作，系统将不会再从RTC中获取或者同步设置时间</li>
<li>Linux命令中<code>date</code>和<code>time</code>等命令都是用来设置系统时间的；而<code>hwclock</code>命令是用来设置和读写RTC时间的</li>
</ul>
<h2 id="文件系统标识"><a href="#文件系统标识" class="headerlink" title="文件系统标识"></a>文件系统标识</h2><ul>
<li><p>在<code>/etc/fstab</code>配置文件中你可以以三种不同的方法表示文件系统：内核名称，UUID或者label。</p>
</li>
<li><p>使用UUID或者是label的好处再与它们与磁盘顺序无关。</p>
</li>
<li><p>如果你在BIOS中改变了你的存储设备顺序，或者是重新拔插了存储设备，或是因为一些BIOS可能会随即地改变存储设备的顺序，那么用UUID或者是label来表示将更有效</p>
</li>
<li><p>显示分区的基本信息：<code>lsblk -f</code></p>
</li>
<li><p>内核名称：<code>fdisk -l</code> 来获得内核名称，前缀是<code>dev</code></p>
</li>
<li><p><code>UUID</code>：所有分区和设备都有唯一的UUID。<strong>它们由文件系统生成工具<code>(mkfs.*)</code>在创建文件系统时生成。</strong></p>
</li>
<li><p>路径名有空格，可以使用<code>\040</code>转义字符来表示空格（以三位八进制数来进行表示）</p>
<ul>
<li><code>UUID=47FA-4071 /home/username/Camera\040Pictures vfat defaults, noatime 0 2</code></li>
</ul>
</li>
<li><p><code>tmpfs</code></p>
<ul>
<li><code>tmpfs</code>是一个临时文件系统，驻留于你的交换分区或者是内存中（取决于你的使用情况）。使用它可以提高文件访问速度，并能够保证重启时会自动清除这些文件</li>
<li>经常使用<code>tmpfs</code>的目录有<code>/tmp, /var/lock, /var/run</code>。不要把tmpfs使用于<code>/var/tmp</code>，因为这一个目录中的临时文件在重启过程中需要被保留。</li>
<li>默认情况下，tmpfs分区被和设置为总的内存的一半，当然可以自由设定</li>
</ul>
</li>
</ul>
<h2 id="POSIX-API"><a href="#POSIX-API" class="headerlink" title="POSIX API"></a>POSIX API</h2><ul>
<li><p>POSIX，全称为<strong>可移植性操作系统接口</strong>，是一种关于信息技术的IEEE标准。它包括了系统应用程序的接口（API），以及实时扩展（C语言）</p>
</li>
<li><p>该标准的目的是定义了标准的基于UNIX操作系统的系统接口和环境来支持源代码级的可移植性。现在，标准主要提供了依赖C语言的一系列标准服务，在将来的版本中，标准将致力于提供基于不同语言的规范。</p>
</li>
<li><p>该标准对核心需求部分定义了一系列任何编程语言都通用的服务，这一部分服务主要从其功能需求方面阐述，而非定义依赖于编程语言的接口。</p>
</li>
<li><p>语言规范主要由两部分组成</p>
<ul>
<li>一部分包括了访问核心服务的编程语言的标准接口，这些核心服务为标准中基于编程语言的核心需求部分所定义</li>
<li>另一部分包含了一个特殊语言服务的标准接口。</li>
</ul>
</li>
<li><p>该标准一共被分为四个部分：</p>
<ul>
<li>陈述的范围和一系列标准参考</li>
<li>定义和总概念</li>
<li>各种接口设备</li>
<li>头文件</li>
</ul>
</li>
</ul>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><ul>
<li><p>挂载目录:</p>
<ul>
<li>工具:nfs, sshfs,</li>
</ul>
</li>
<li><p>挂载(mount):</p>
<ul>
<li>“挂载”发生在计算机想要使用任何类型的存储设备(如硬盘,CD-ROM,网络设备)之前,操作系统必须讲这个设备纳入自己的文件系统中</li>
</ul>
</li>
<li><p><code>mount -t type device dir</code> </p>
<ul>
<li>挂载操作,实际上是把设备(device)中的文件系统附加到dir上,可以通过访问dic来访问这个设备</li>
<li>其本质就是针对某一设备,分析出其文件系统结构,并根据其文件系统类型调用linux中相应的驱动,处理该设备的元数据,将这些信息附加到linux的目录树上,并呈现出来.</li>
</ul>
</li>
</ul>
<h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><ul>
<li><p>内网，就是在公司或者家庭内部，建立的一种局域网络或者是办公网络，从而实现多台电脑之间可以进行资源的共享，包括设备，资料，数据等。而外网则是由一个网关与其他的网络系统连接，相对于内网而言，这种网络称之为外部网络，也就是我们经常说到的互联网。</p>
</li>
<li><p>内网穿透，是我们在进行网络连接时的一种术语，也叫做NAT穿透，即在计算机是局域网内的时候，外网与内网的计算机的节点进行连接时所需要的连接通信，有时候就会出现内网穿透不支的情况。</p>
</li>
<li><p>内网穿透的功能就是，当我们在端口映射时设置时，内网穿透起到了地址转换的功能，也就是把公网的地址进行翻译，转成一种私有的地址，然后再采用路由的方式ADSL的宽带路由器，具有一个动态或者是固定的公网IP，最后ADSL直接在交换机上，这样所有的电脑都可以共享上网。内网穿透除了可以实现内网之间机器的网络通信功能之外，还可以解决UDP中出现的数据传输不稳定的问题</p>
</li>
<li><p>内网穿透可以通过开放的第三方端口来实现，可以安装一个NAT123端口内网穿透软件，然后再添加映射，并且配置出映射端口的信息，外网的地址是映射之后访问的域名，同时也可以是自己或者默认的域名，通过内网穿透，可以用域名进行对应的内网应用。如果是外网地址使用的是自己的域名，可以把域名的解析只想提示目标地址来使用。</p>
</li>
<li><p>简单来说，内网穿透就是在我们没有公网IP的时候，也可以通过内网穿透服务器的转发，在任何互联网（广域网）连接内网的设备。</p>
</li>
<li><p>推荐工具：Zero Tier , frp, <strong>socat命令</strong></p>
</li>
<li><p><code>ngrok</code>:</p>
<ul>
<li><code>ngrok config add-authtoken 2Fyd9ZRXPYDbBNIZQRXAPd036Un_cCTH2CsrmttkSzKE1ind</code></li>
<li><code>ngrok tcp 22 </code></li>
<li><code>ssh user@0.tcp.jp.ngrok.io -p 11111</code></li>
</ul>
</li>
</ul>
<h2 id="ubuntu18-显卡配置"><a href="#ubuntu18-显卡配置" class="headerlink" title="ubuntu18 显卡配置"></a>ubuntu18 显卡配置</h2><ol>
<li>查看显卡设备和显卡驱动 –&gt; <code>ubuntu-drivers devices</code></li>
<li>自动安装合适的显卡     –&gt; <code>sudo ubuntu-drivers autoinstall</code></li>
<li>重启系统</li>
</ol>
<h2 id="开机启动服务-脚本"><a href="#开机启动服务-脚本" class="headerlink" title="开机启动服务&#x2F;脚本"></a>开机启动服务&#x2F;脚本</h2><ul>
<li><p>系统启动时需要加载的配置文件</p>
<ul>
<li>&#x2F;etc&#x2F;profile</li>
<li>&#x2F;root&#x2F;.bash_profile</li>
<li>&#x2F;etc&#x2F;bashrc</li>
<li>&#x2F;root&#x2F;.bashrc</li>
<li>&#x2F;etc&#x2F;profile.d&#x2F;*.sh</li>
<li>&#x2F;etc&#x2F;sysconfig&#x2F;</li>
<li>&#x2F;etc&#x2F;rc.local</li>
</ul>
</li>
<li><p>自定义服务文件，添加到系统服务，通过<code>Systemctl</code>管理</p>
<ul>
<li>写服务文件，例如nginx.service, redis.service, supervisord.service<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]      --  服务说明</span><br><span class="line">Description --  描述服务</span><br><span class="line">After       --  描述服务类别</span><br><span class="line"></span><br><span class="line">[Service]    -- 服务运行参数的设置</span><br><span class="line">Type=forking -- 为后台运行的形式</span><br><span class="line">ExecStart    -- 为服务的具体运行命令</span><br><span class="line">ExecReload   -- 为服务的重启命令</span><br><span class="line">ExecStop     -- 为服务的停止命令</span><br><span class="line">PrivateTmp=True  -- 表示给服务分配独立的临时空间</span><br><span class="line">注意：启动，重启，停止命令全部要求使用绝对路径</span><br><span class="line"></span><br><span class="line">[Install]    --  服务安装的相关设置，可设置为多用户</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>文件保存在<code>/usr/lib/systemd/system/</code>路径下，权限为<code>754</code></p>
</li>
<li><p>设置开机自动启动</p>
<ul>
<li><code>systemctl enable nginx.service</code></li>
</ul>
</li>
<li><p>停止开机自启动</p>
<ul>
<li><code>systemctl disable nginx.service</code></li>
</ul>
</li>
<li><p>验证是否为开机自启动</p>
<ul>
<li><code>systemctl is-enabled nginx</code></li>
</ul>
</li>
<li><p>查看所有已经启动的服务</p>
<ul>
<li><code>systemctl list-units --type=service</code></li>
</ul>
</li>
</ul>
<h1 id="什么是socks"><a href="#什么是socks" class="headerlink" title="什么是socks"></a>什么是socks</h1><ul>
<li>socks是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是SOCKets的缩写</li>
<li>当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格。允许的话，就将客户端的请求发往外部的服务器。这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到版本4。最新协议是版本5，与前一版相比，增加支持UDP，验证以及IPv6</li>
</ul>
<h2 id="共享目录"><a href="#共享目录" class="headerlink" title="共享目录"></a>共享目录</h2><h3 id="linux之间建立共享目录"><a href="#linux之间建立共享目录" class="headerlink" title="linux之间建立共享目录"></a>linux之间建立共享目录</h3><p>如何使A服务器的某个目录挂载到B服务器的某个目录下,使其达到B服务下的目录文件一旦变更,可以实时的在A服务器的目录下体现出来?</p>
<p>Linux的解决方式</p>
<ul>
<li>将B服务器的该目录,设置为共享文件夹</li>
<li>A服务器通过mount的方式,指定对应的远程主机所抛出来的共享文件夹进行连接.</li>
</ul>
<p>原理:</p>
<ul>
<li>挂载,并非将远程服务的文件实时拷贝到目标文件夹中</li>
<li>A服务器每次对于自身挂载文件的访问,实际上都是发送了一次新的RPC请求,请求目标服务器将其对应的目录数据实时返回到A服务器的文件当中进行展示.</li>
<li>Linux中存在一个应用:NFS网络文件系统(Network File System),它是一种适用于分散式文件系统的协定,让应用程序在客户端通过网络访问位于磁盘中的数据,是在类Unix系统间实现对应的磁盘文件共享的一种方法.</li>
</ul>
<p>NFS和RPC的关系:</p>
<ul>
<li>NFS在文件传送或信息传送过程中依赖于RPC协议.</li>
<li>RPC,远程过程调用(Remote Procedure Call)是能使客户端执行其他系统中程序的一种机制.</li>
<li>NFS本身是没有提供信息传输的协议和功能,但是NFS却能让我们通过网络进行资料的分享,这是因为NFS使用了一些其他的传输协议.而这些传输协议用到这个RPC功能,可以说NFS本身就是使用RPC的一个程序.只要用到NFS的地方都要启动RPC服务,不论是NFS 服务器还是NFS客户端,因为这样服务器和客户端才能通过RPC来实现程序端口的对应.</li>
<li>可以这么理解:NFS是一个文件系统,而RPC是负责信息的传输</li>
</ul>
<h3 id="安装并配置NFS服务"><a href="#安装并配置NFS服务" class="headerlink" title="安装并配置NFS服务"></a>安装并配置NFS服务</h3><ol>
<li>安装nfs服务器端服务: <code>apt-get install nfs-kernel-server</code>        </li>
<li>编辑<code>/etc/exports</code>下的配置文件: <ol>
<li><code>sudo vim /etc/exports</code></li>
<li>添加配置信息:<code>/home/zjy/share_folder *(rw, sync, no_root_squash, no_subtree_check)</code><ol>
<li><code>/home/zjy/share_folder</code>:共享文件夹的路径</li>
<li><code>*</code> : 允许所有的网段访问,也可以使用具体的IP</li>
<li><code>rw</code> : 挂接此目录的客户端对该共享目录的权限:读,写</li>
<li><code>sync</code>:资料同步写入内存和硬盘</li>
<li><code>no_root_squash</code>:root用户具有对根目录的完全管理访问权限</li>
<li><code>no_subtree_check</code> : 不检查父目录的权限</li>
</ol>
</li>
</ol>
</li>
<li>重启服务,将会自动映射端口:<code>sudo /etc/init.d/rpcbind restart</code></li>
<li>重启nfs服务:<code>sudo /etc/init.d/nfs-kernel-server restart</code></li>
<li>创建共享文件夹</li>
<li>查看ip地址,准备给客户端挂载</li>
</ol>
<p>客户端配置:</p>
<ol>
<li>创建用于存放挂载的目录:<code>sudo mkdir /opt/share_folder</code></li>
<li>挂载服务器端共享目录:<code>sudo mount -t nfs 192.167.15.5:/mnt/A311D_share_folder /opt/share_folder</code></li>
<li>取消挂载:<code>sudo umount /opt/share_folder</code></li>
</ol>
<h2 id="etc-apt-source-list"><a href="#etc-apt-source-list" class="headerlink" title="&#x2F;etc&#x2F;apt&#x2F;source.list"></a>&#x2F;etc&#x2F;apt&#x2F;source.list</h2><h3 id="debian-9-strech-arm64"><a href="#debian-9-strech-arm64" class="headerlink" title="debian 9 strech arm64"></a>debian 9 strech arm64</h3><ul>
<li>apt源<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># debian</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian stable main contrib non-free</span><br><span class="line"># deb-src http://mirrors.ustc.edu.cn/debian stable main contrib non-free</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span><br><span class="line"># deb-src http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span><br><span class="line"></span><br><span class="line"># deb http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span><br><span class="line"># deb-src http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="apt-出现-Certificate-verification-failed"><a href="#apt-出现-Certificate-verification-failed" class="headerlink" title="apt 出现 Certificate verification failed"></a>apt 出现 Certificate verification failed</h2><ul>
<li><code>apt install ca-certificates --reinstall</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/FFmpeg/ffmpeg_4_%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-ffmpeg_4_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/FFmpeg/ffmpeg_4_%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-ffmpeg_4_1/" class="post-title-link" itemprop="url">ffmpeg_4_1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ffmpeg C开发 常用技巧</li>
</ul>
<h2 id="ffmpeg-AVPacket-初始化和反初始化"><a href="#ffmpeg-AVPacket-初始化和反初始化" class="headerlink" title="ffmpeg AVPacket 初始化和反初始化"></a>ffmpeg AVPacket 初始化和反初始化</h2><ul>
<li>av_init_packet()函数被弃用了</li>
<li>应该使用 av_packet_alloc()函数对packet进行申请，使用av_packet_free()函数继续释放</li>
</ul>
<h2 id="ffmpeg-AVFrame-转-cv-Mat"><a href="#ffmpeg-AVFrame-转-cv-Mat" class="headerlink" title="ffmpeg AVFrame 转 cv::Mat"></a>ffmpeg AVFrame 转 cv::Mat</h2><ul>
<li><p>上面函数传入的参数frame中的图像格式，可以是YUV, RGB ,等等，，经过sws_scale（）转换之后，写入cv::Mat 数据区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AVFrame 转 cv::mat  </span></span><br><span class="line"><span class="function">cv::Mat <span class="title">frame_to_mat</span><span class="params">(<span class="type">const</span> AVFrame * frame)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> width = frame-&gt;width;</span><br><span class="line">    <span class="type">int</span> height = frame-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Mat <span class="title">image</span><span class="params">(height, width, CV_8UC3)</span></span>;</span><br><span class="line">    <span class="type">int</span> cvLinesizes[<span class="number">1</span>];</span><br><span class="line">    cvLinesizes[<span class="number">0</span>] = image.<span class="built_in">step1</span>();</span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == _swsContext) &#123;</span><br><span class="line">        _swsContext = <span class="built_in">sws_getContext</span>(width, height,</span><br><span class="line">            (AVPixelFormat)frame-&gt;format, width, height,</span><br><span class="line">            AVPixelFormat::AV_PIX_FMT_BGR24, SWS_FAST_BILINEAR, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sws_scale</span>(_swsContext, frame-&gt;data, </span><br><span class="line">        frame-&gt;linesize, <span class="number">0</span>, height, &amp;image.data, cvLinesizes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一种方式 是直接将AVFrame 中的RGB数据赋值给cv::Mat</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat img;</span><br><span class="line">img = cv::<span class="built_in">Mat</span>(height, width, CV_8UC3);</span><br><span class="line">img.data =  _rgb_frame-&gt;data[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ffmpeg开发库-C-输入rtsp流地址-录制指定长度的视频到本地-编程示例"><a href="#ffmpeg开发库-C-输入rtsp流地址-录制指定长度的视频到本地-编程示例" class="headerlink" title="ffmpeg开发库 C++ 输入rtsp流地址 录制指定长度的视频到本地 编程示例"></a>ffmpeg开发库 C++ 输入rtsp流地址 录制指定长度的视频到本地 编程示例</h2><p>要使用FFmpeg的C++开发库来录制指定长度的RTSP流视频到本地，你可以使用libavcodec、libavformat等库来完成。下面是一个简单的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/time.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// av_register_all();  // 新版本弃用</span></span><br><span class="line">    <span class="built_in">avformat_network_init</span>();</span><br><span class="line"></span><br><span class="line">    AVFormatContext *pFormatCtx = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line">    AVDictionary *options = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;options, <span class="string">&quot;rtsp_transport&quot;</span>, <span class="string">&quot;tcp&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *rtsp_url = <span class="string">&quot;rtsp://example.com/stream&quot;</span>;  <span class="comment">// RTSP流地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *output_file = <span class="string">&quot;output.mp4&quot;</span>;             <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="type">int</span> duration = <span class="number">60</span>;                                   <span class="comment">// 录制时长（秒）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avformat_open_input</span>(&amp;pFormatCtx, rtsp_url, <span class="literal">NULL</span>, &amp;options) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开RTSP流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avformat_find_stream_info</span>(pFormatCtx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法获取流信息&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVFormatContext *pOutputFormatCtx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avformat_alloc_output_context2</span>(&amp;pOutputFormatCtx, <span class="literal">NULL</span>, <span class="literal">NULL</span>, output_file) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法分配输出格式上下文&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVStream *pStream = <span class="built_in">avformat_new_stream</span>(pOutputFormatCtx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pStream) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法创建输出流&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avcodec_parameters_copy</span>(pStream-&gt;codecpar, pFormatCtx-&gt;streams[<span class="number">0</span>]-&gt;codecpar) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法拷贝编解码参数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(pOutputFormatCtx-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">avio_open</span>(&amp;pOutputFormatCtx-&gt;pb, output_file, AVIO_FLAG_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;无法打开输出文件&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">avformat_write_header</span>(pOutputFormatCtx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    AVPacket packet;</span><br><span class="line">    <span class="type">int64_t</span> startTime = <span class="built_in">av_gettime</span>();</span><br><span class="line">    <span class="type">int64_t</span> endTime = startTime + duration * <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">av_read_frame</span>(pFormatCtx, &amp;packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">av_gettime</span>() &gt;= endTime) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">av_packet_rescale_ts</span>(&amp;packet, pFormatCtx-&gt;streams[<span class="number">0</span>]-&gt;time_base, pStream-&gt;time_base);</span><br><span class="line">        packet.stream_index = pStream-&gt;index;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">av_interleaved_write_frame</span>(pOutputFormatCtx, &amp;packet);</span><br><span class="line">        <span class="built_in">av_packet_unref</span>(&amp;packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_write_trailer</span>(pOutputFormatCtx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">avformat_close_input</span>(&amp;pFormatCtx);</span><br><span class="line">    <span class="built_in">avio_closep</span>(&amp;pOutputFormatCtx-&gt;pb);</span><br><span class="line">    <span class="built_in">avformat_free_context</span>(pOutputFormatCtx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_dict_free</span>(&amp;options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先初始化了FFmpeg库，然后打开了指定的RTSP流。我们创建了一个输出格式上下文，并且设置了输出文件名。然后，我们复制了输入流的编解码参数到输出流，接着开始逐帧读取输入流，并将其写入输出流。当录制时长达到指定时长后，我们退出录制，并释放相关资源。请确保将 <code>rtsp_url</code> 替换为你的 RTSP 流地址，<code>output_file</code> 为输出文件的路径和名称，<code>duration</code> 为录制时长（以秒为单位）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/FFmpeg/ffmpeg_1_%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/2024-05-22-ffmpeg_1_1_%E9%9F%B3%E8%A7%86%E9%A2%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/FFmpeg/ffmpeg_1_%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/2024-05-22-ffmpeg_1_1_%E9%9F%B3%E8%A7%86%E9%A2%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">ffmpeg_1_1_音视频理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="一、视频解码编解码的一些基本概念"><a href="#一、视频解码编解码的一些基本概念" class="headerlink" title="一、视频解码编解码的一些基本概念"></a>一、视频解码编解码的一些基本概念</h2><h3 id="数字图像的基本概念"><a href="#数字图像的基本概念" class="headerlink" title="数字图像的基本概念"></a>数字图像的基本概念</h3><ol>
<li><p>数字图像的硬件介绍</p>
<ol>
<li>图像输入设备：输入，采样量化，专用处理。（相机、摄像机、扫描仪等）</li>
</ol>
<ul>
<li>线阵相机和面阵相机<ul>
<li>面阵相机：一次拍摄一个区域，视觉检测中绝大部分应用面阵相机</li>
<li>线阵相机：一次拍摄一行像素，通过移动以及拼接来获取图像，分辨率更高，成像质量更高，价格更贵</li>
</ul>
</li>
</ul>
<ol start="2">
<li>电脑：数字图像处理（PC机，服务器集群，硬件电路等）</li>
<li>图像输出设备：专用处理，D&#x2F;A转换，输出。（打印机、显示器等）</li>
</ol>
</li>
<li><p>数字图像的几个基本概念</p>
<ol>
<li>图像的采样和量化<ul>
<li>数字化坐标值称为采样</li>
<li>数字化幅度值称为量化</li>
</ul>
</li>
<li>图像的分辨率<ul>
<li>采样的程度通常用采样率来表示，也就是通常所说的分辨率。分辨率160 × 128 的意思是水平像素数为160个，垂直像素数128个。分辨率越高，像素的数目越多，感受的图像越精密</li>
</ul>
</li>
<li>图像的灰度级<ul>
<li>最常见的图像为8位图像，灰度级为256级，即2的8次方。</li>
<li>灰度级越多，可以展现的图像细节就越多，有时候也把灰度级称为灰度分辨率。</li>
</ul>
</li>
<li>图像的坐标系<ul>
<li>在图像中，如果要表示图像中的某一个像素，可以用它的坐标来表示</li>
<li>图像原点为图像的左上角，坐标记做[0,0]</li>
<li>一副M × N的图像可以用一个矩阵来表示</li>
</ul>
</li>
<li>像素的空间关系：8-邻接和4-邻接</li>
</ol>
</li>
<li><p>数字图像的种类和色彩模型</p>
<ol>
<li>图像的种类<ol>
<li>二值图像：<ul>
<li>像素取值仅为0和1，“0“代表黑色，”1“代表白色。通常用来表示状态，如区分图像中的前景和背景</li>
</ul>
</li>
<li>灰度图像：<ul>
<li>像素取值范围为[0,255]，”0”表示纯黑，“255”表示纯白色，一些图像算法中需要使用灰度图进行运算</li>
</ul>
</li>
<li>彩色图像：<ul>
<li>显示设备通常使用RGB格式的彩色图像，即红（red）绿（green）蓝（blue）三种颜色的组合叠加起来获得各种颜色。</li>
<li>如果把RGB值看做是3个维度的坐标，构建的空间称为RGB色彩空间</li>
<li>除了RGB外，常见的色彩模型还有HSV&#x2F;HSI（数字图像算法常用），CMYK（主要用于印刷），YUV（用于图像传输）</li>
</ul>
</li>
</ol>
</li>
<li>色彩模型：通过数学模型表示颜色，所用的数学模型即颜色模型。<ol>
<li>CMYK色彩模型<ul>
<li>印刷业通过青（C）、品（M）、黄（Y）三原色油墨的不同网点面积率的叠印来表现颜色，一般采用青（C）、品（M）、黄（Y）、黑（BK）四色印刷。</li>
<li>CMYK可以看做是从黑色中减少颜色得到新的颜色，故可以称之为减色模型。而RGB是在白色上叠加颜色得到新的颜色，故称为加色模型。</li>
</ul>
</li>
<li>HSV色彩模型<ul>
<li>HSV即色相（Hue）、饱和度（Saturation）、明度（Value），又称HSI（I即intensity）。常用于图像算法中的色彩分析，对光照具有较强的鲁棒性。</li>
<li>H：用角度表示，从红色开始按逆时针方向计算，红色为0度，绿色为120度，蓝色为240度，该值表示颜色接近于哪种纯色值</li>
<li>S：通常取值范围为0%~100%。圆锥的中心为0，该值越大表示颜色越饱满，直观的说即颜色深而艳</li>
<li>V：亮度，表示颜色的明亮程度</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>图像直方图</p>
<ol>
<li>图像的直方图<ul>
<li>直方图（histogram）是图像处理中的一个非常重要工具，被广泛应用。直方图本质是概率分布的图形化，同时直方图也可以用来表示向量。</li>
<li>直方图的作用<ul>
<li>图像匹配：比较两幅图像的直方图，可以得到两幅图像的相似程度，其本质是对比灰度出现的概率是否相似  </li>
<li>判断成像质量</li>
<li>二值化阈值：所谓二值化即通过设置一个门限值，把灰度图像转换为二值化图像，通常的目的是分离前景和背景。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="视频数据的一些基本概念"><a href="#视频数据的一些基本概念" class="headerlink" title="视频数据的一些基本概念"></a>视频数据的一些基本概念</h3><ol>
<li>音视频领域早起采用模拟化技术，目前已发展为数字化技术。数字化后，音视频处理就进入了计算机技术领域，<strong>音视频处理本质上就是对计算机数据的处理</strong></li>
<li>帧内编码：帧内编码是<strong>空间域编码</strong>，利用图像空间冗余度进行图像压缩，处理的是一副独立的图像，不会跨越多幅图像。空间域编码依赖于一幅图像中<strong>相邻像素间的相似性和图案区的主要空间域频率</strong>。（JPEG标准用于静止图像，即图片，只是用了空间域压缩，只是用帧内编码。）<ul>
<li>熵与冗余<ul>
<li>在所有的实际节目素材中，存在这两种类型的信号分量：即异常的、不可预见的信号分量和可以预见的信号分量。</li>
<li>异常分量称为<strong>熵</strong>，它是信号中的<em>真正信息</em></li>
<li>其余部分称为<strong>冗余</strong>，因为它不是必须的信息。<ul>
<li>冗余可以是空间性的，例如在图像的大片区域中，邻近像素几乎具有相同的数值。</li>
<li>冗余也可以是时间性的，例如连续图像之间的相似部分。</li>
</ul>
</li>
<li>在所有的压缩系统<em>编码器</em>中都是将熵与冗余分离，只有熵被编码和传输，而在<em>解码器</em>中再从编码器的发送的信号中计算出冗余。</li>
</ul>
</li>
</ul>
</li>
<li>帧间编码，是<strong>时间域编码</strong>，利用一组连续图像间的时间性冗余度进行图像压缩。如果某帧图像可被解码器使用，那么解码器只需利用两帧图像的差异即可得到下一阵图像。<ul>
<li>比如运动平缓的几帧图像的相似性大，差异性小，而运动剧烈的几幅图像则相似性小，差异性大。当得到一帧完整的图像信息后，可以利用与后一帧图像的差异值推算得到后一帧图像，这样就实现了数据量的压缩。<strong>时间域编码依赖于连续图像帧间的相似性</strong>，尽可能利用已接受的图像来“预测”生成当前图像。（MPEG标准用于运动图像，即视频，会使用空间域编码和时间域编码，因此是帧内编码和帧间编码结合使用）</li>
</ul>
</li>
<li>I帧：I帧（Intra-coded picture,帧内编码帧，常称为<strong>关键帧</strong>）包含一副完整的图像信息，属于帧内编码图像，不含运动矢量，在解码时不需要参考其他帧图像。因此，在I帧图像出可以切换频道，而不会导致图像丢失或无法解码。I帧图像用于组织误差的累计和扩散。在闭合式GOP中，每个GOP的第一个帧一定是I帧，且当前GOP的数据不会参考前后GOP的数据。<ul>
<li>运动矢量：一组连续图像记录了目标的运动。运动矢量用于衡量两帧图像间目标的<strong>运动程度</strong>，<em>运动矢量由水平位移和垂直位移二者构成</em>。</li>
<li>闭合式GOP：<ul>
<li>GOP(Group Of Pictures,图像组)是一组连续的图像，由一个I帧和多个B&#x2F;P帧组成，是编解码存取的基本单位。GOP结构常用的两个参数M和N：M指定GOP中两个anhor frame（anchor frame指可被其他帧参考的帧，即I帧或P帧）之间的距离；N指定一个GOP的大小，例如M&#x3D;2，N&#x3D;13，GOP结构为：IBBPBBPBBPBB</li>
<li>B帧：（Bi-directionally predicted picture,双向预测编码图像帧），是帧间编码帧，利用之前和（或）之后的I帧或P帧进行<em>双向预测编码</em>。<strong>B帧不可以作为参考帧。</strong>B帧具有更高的压缩率，但需要更多的缓冲时间以及更高的CPU占用率，因此B帧适合本地存储以及视频点播，而不是用对实时性要求较高的直播系统。<ul>
<li>双向预测编码：<ul>
<li>连续的三幅图像中，目标块有垂直位置上的移动，背景块无位置移动，考虑如何得到当前帧图像（画面N）：<ul>
<li>画面N中，目标向上移动后，露出背景块</li>
<li>画面N-1中，因为背景块被目标快遮挡住了，因此没有背景块相关信息。</li>
<li>画面N+1中，完整包含背景块的数据，因此画面N可以从画面N-1中取得背景块。</li>
</ul>
</li>
<li>如何可以得到画面N？<ul>
<li>解码器可以先解码得到画面N-1和画面N+1，通过画面N-1中的目标块数据结合运动矢量即可得到画面N中的目标块数据，通过画面N+1中的背景块数据则可得到画面N中的背景块数据。</li>
<li>三幅画面的解码顺序为：N-1，N+1，N</li>
<li>三幅画面的显示顺序为N-1，N，N+1</li>
</ul>
</li>
<li><strong>画面N通过其前一幅画面N-1和后一副画面N+1推算（预测，predicted）得到，因此这种方式称为双向预测（或前向预测，双向参考）</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>P帧：（Predictive-coded picture,预测编码图像帧），是帧间编码帧，利用之前的I帧或P帧进行预测编码。</li>
<li>GOP有两种：闭合式GOP和开放式GOP<ul>
<li>闭合式GOP：闭合式GOP只需要参考本GOP内的图像即可，不需要参考前后GOP的数据。这种模式决定了，<strong>闭合式GOP的显示顺序总是以I帧开始,以P帧结束。</strong>(闭合式GOP是否一定是以P帧结束？可能未必有此定义，有些视频文件GOP以B帧结束)</li>
<li>开放式GOP：开放式GOP中的B帧解码时可能要用到其前一个GOP或后一个GOP的某些帧。码流里面包含B帧的时候才会出现开放式GOP。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>I帧,B帧,P帧的编码基本流程:</p>
<ul>
<li>I帧编码的基本流程:<ol>
<li>进行帧内预测,决定所采用的帧内预测模式</li>
<li>像素值减去预测值,得到残差</li>
<li>对残差进行变换和量化</li>
<li>变长编码和算数编码</li>
<li>重构图像并滤波,得到的图像作为其它帧的参考帧</li>
</ol>
</li>
<li>P帧和B帧编码的基本流程为:</li>
</ul>
<ol>
<li>进行运动估计,计算采用帧间编码模式的率失真函数(节)值.P帧只参考前面的帧,B帧可参考后面的帧</li>
<li>进行帧内预测,选取率失真函数值最小的帧内模式与帧间模式比较,确定采用哪种编码模式</li>
<li>计算实际值和预测值的差值</li>
<li>对残差进行变换和量化</li>
<li>熵编码,如果是帧间编码模式,编码运动矢量</li>
</ol>
<p><strong>小结</strong></p>
<ul>
<li>I帧只需考虑本帧;</li>
<li>P帧记录的是与前一帧的差别</li>
<li>B帧记录的是前一帧及后一帧的差别,能节约更多的空间,视频文件小了,但是相对来说解码的时候就比较麻烦.因为在解码时,不仅要用之前缓存的画面,而且要知道下一个I或者P的画面,对于不支持B帧解码的播放器容易卡顿.</li>
</ul>
<h3 id="FFmpeg解码涉及的一些基本概念"><a href="#FFmpeg解码涉及的一些基本概念" class="headerlink" title="FFmpeg解码涉及的一些基本概念"></a>FFmpeg解码涉及的一些基本概念</h3><ol>
<li>封装格式(container format)：可以看做是编码流（音频流、视频流等）数据的一层外壳，将编码后的数据存储于此封装格式的文件之内。<ul>
<li>封装，又称容器，<strong>所谓容器，就是存放内容的器具</strong>。 容器的本质就是文件，是特定的视频文件，如mp4，mkv，flv等格式的音视频文件,其内部存放一帧帧的视频信息和音频信息。因此，视频文件内部尝尝包含不止一个信息流，而是包含一组信息流（若干视频流和若干音频流）<ul>
<li>所谓信息流，就是随时间分布的信息，比如视频可以看成是一组随时间分布的图片。</li>
<li>视频流中的一个数据元通常被称为一帧（frame），每一种视频流都有属于自己的编解码器（encoder&#x2F;decoder,在FFmpeg中被简写为coderc），用于说明该种视频流是如何编码和解码的。</li>
<li>数据包（packets）则尝尝指从裸数据解析而来的数据片断。</li>
</ul>
</li>
<li>容器的作用：容器中可以存放音频、视频、字幕流等信息，将这些信息整合在一起，按照特定规则放置在容器中。</li>
</ul>
</li>
<li>编解码器(Codec)：数据帧（原始数据）与数据包（压缩数据）之间的转换工具<ul>
<li>数据帧（原始数据）-&gt; 编解码器（编码）-&gt; 数据包（压缩数据）</li>
<li>数据包（压缩数据）-&gt; 编解码器（解码）-&gt; 数据帧（原始数据）</li>
</ul>
</li>
<li>媒体流(Stream)：时间上的一段连续数据。一段声音数据，称为音频流；一段视频数据，称为视频流；一段字母数据，称为字幕流</li>
<li>数据帧(Data Frame)：媒体流，由若干数据帧构成；压缩格式中，数据帧是最小的处理单元。<ul>
<li>在容器中，如果有多个数据流，那么视频帧、音频帧、字母信息、交错存储，以保证实时性</li>
<li>数据帧是未压缩的原始数据，如：视频帧每一帧都是一张完整的YUV图片，音频帧是PCM格式的。</li>
</ul>
</li>
<li>数据包(Data Packet)：将数据帧压缩后就是数据包，数据帧是未压缩的原始数据，数据包是压缩后的数据。</li>
<li>复用（Mux）：将不同的媒体流，按照一定规则放入容器，复用的关键工具是：复用器（Muxer）</li>
<li>解复用（Demux）：从容器中解析不通的流出来，解复用的关键工具是：解复用器（Demuxer）</li>
</ol>
<h3 id="FFmpeg开发环境构建"><a href="#FFmpeg开发环境构建" class="headerlink" title="FFmpeg开发环境构建"></a>FFmpeg开发环境构建</h3><ol>
<li>ffmpeg官网：<a target="_blank" rel="noopener" href="https://www.ffmpeg.org/">https://www.ffmpeg.org/</a></li>
<li>SDL（Simple DirectMedia Layer）：是一套开源的跨平台多媒体开发库。SDL提供了书中控制图像、声音、输出输入的函数，封装了复杂的音视频底层操作，简化了音视频处理的难度。目前SDL多用于开发游戏、模拟器、媒体播放器等多媒体应用领域。官网: <a target="_blank" rel="noopener" href="https://www.libsdl.org/">https://www.libsdl.org/</a></li>
<li>yasm&#x2F;nasm<ul>
<li>旧版ffmpeg及x264&#x2F;x265使用yasm汇编器</li>
<li>新版ffmpeg及x264&#x2F;x265改用nasm汇编器<ul>
<li>NASM（Netwide Assembler），是一款基于英特尔x86架构的汇编与反汇编工具。官网：<a target="_blank" rel="noopener" href="https://www.nasm.us/">https://www.nasm.us/</a></li>
</ul>
</li>
</ul>
</li>
<li>x264：是开源的h264编码器，使用非常广泛。ffmpeg工程中实现了h264解码器，但是没有264编码器。因此需要安装第三方编码器x264。官网：<a target="_blank" rel="noopener" href="https://www.videolan.org/developers/x264.html">https://www.videolan.org/developers/x264.html</a></li>
<li>x265：是开源的h265编码器。ffmpeg工程中实现了h265解码器，但是没有h265编码器，因此需要安装第三方编码器x265.官网：<a target="_blank" rel="noopener" href="https://www.x265.org/">https://www.x265.org/</a> 下载地址：<a target="_blank" rel="noopener" href="https://www.videolan.org/developers/x265.html">https://www.videolan.org/developers/x265.html</a></li>
<li>libmp3lame：是开源的mp3编码器。官网：<a target="_blank" rel="noopener" href="https://lame.sourceforge.net/">https://lame.sourceforge.net/</a></li>
<li>librtmp：RTMPDump Read-Time Messaging Protocol API，又成rtmpdump，是用于处理RTMP流的工具。支持所有形式的RTMP，文档：<a target="_blank" rel="noopener" href="https://rtmpdump.mplayerhq.hu/librtmp.3.html">https://rtmpdump.mplayerhq.hu/librtmp.3.html</a> 官网：<a target="_blank" rel="noopener" href="https://rtmpdump.mplayerhq.hu/">https://rtmpdump.mplayerhq.hu/</a></li>
</ol>
<h3 id="处理音视频流的一般过程："><a href="#处理音视频流的一般过程：" class="headerlink" title="处理音视频流的一般过程："></a>处理音视频流的一般过程：</h3><ol>
<li>打开音视频文件，获取音视频流</li>
<li>从数据流中读取数据帧</li>
<li>如果数据帧不完整，就回到第二步</li>
<li>处理数据帧</li>
<li>回到第二步</li>
</ol>
<h2 id="二、FFmpeg视频解码过程"><a href="#二、FFmpeg视频解码过程" class="headerlink" title="二、FFmpeg视频解码过程"></a>二、FFmpeg视频解码过程</h2><ol>
<li>注册所支持的所有的文件（容器）格式及其对应的Codec：<code>av_register_all()</code></li>
<li>打开输入文件：<code>avformat_open_input()</code></li>
<li>解封装，从文件中提取流信息：<code>avformat_find_stream_info()</code></li>
<li>查找video stream相对应的解码器：<code>avcodec_find_decoder()</code></li>
<li>给相应解码器的上下文容器分配内存：<code>avcodec_alloc_context3() avcode_parameters_to_context()</code></li>
<li>打开解码器，并初始化解码器的上下文容器：<code>avcodec_open2()</code></li>
<li>创建SwsContext对象，并初始化:<code>av_image_fill_arrays(),sws_getContext()</code></li>
<li>为解码帧分配内存：<code>av_frame_alloc()</code></li>
<li>从流中读取数据到Packet中：<code>av_read_fream()</code></li>
<li>发送数据包到解码队列：<code>avcodec_send_packet()</code></li>
<li>接受一帧解码数据，并解码：<code>avcodec_receive_frame()</code></li>
<li>对视频帧（YUV）进行图像格式转换（RGB）:<code>sws_scale()</code></li>
</ol>
<h2 id="三、（用到的）结构体的功能和参数简要分析"><a href="#三、（用到的）结构体的功能和参数简要分析" class="headerlink" title="三、（用到的）结构体的功能和参数简要分析"></a>三、（用到的）结构体的功能和参数简要分析</h2><h3 id="关键的结构体分类："><a href="#关键的结构体分类：" class="headerlink" title="关键的结构体分类："></a>关键的结构体分类：</h3><ol>
<li>解协议（http，rtsp，rtmp，mms）<ol>
<li>AVIOContext</li>
<li>URLProtocol<ol>
<li>存储输入视音频使用的封装格式，每种协议都对应一个URLProtocol结构</li>
<li>FFmpeg中文件也被当做一种协议“file”</li>
</ol>
</li>
<li>URLContext<ol>
<li>主要存储视音频使用的协议的类型</li>
</ol>
</li>
</ol>
</li>
<li>解封装（flv,avi,rmvb,mp4)<ol>
<li>AVFormatContext<ol>
<li>主要存储视音频封装格式中包含的信息</li>
<li>几个主要变量（解码）：<ol>
<li>AVIOContext * pb ： 输入数据的缓存</li>
<li>unsigned int nb_streams : 视音频流的个数</li>
<li>AVStream **streams：视音频流</li>
<li>char filename[1024]：文件名</li>
<li>int64_t duration：时长（单位：微秒）</li>
<li>int bit_rate：比特率（单位：bps）</li>
</ol>
</li>
</ol>
</li>
<li>AVInputFormat<ol>
<li>存储输入视音频使用的封装格式</li>
<li>每种视音频封装格式都对应一个AVInputFormat结构</li>
</ol>
</li>
</ol>
</li>
<li>解码（h264, mpeg2, aac, mp3）<ol>
<li>AVStream：<ol>
<li>每一个AVStream存储一个视频&#x2F;音频流的相关数据</li>
</ol>
</li>
<li>AVCodecContext：<ol>
<li>存储该视频&#x2F;音频流使用的解码方式的相关数据</li>
<li>每个AVStream对应一个AVCodecContext</li>
</ol>
</li>
<li>AVCodec：<ol>
<li>包含视频&#x2F;音频对应的解码器,每种解码器都对应一个AVCodec结构</li>
<li>每个AVCodecContext中对应一个AVCodec</li>
</ol>
</li>
</ol>
</li>
<li>存数据<ol>
<li>视频：每个结构一般都是存一帧，音频可能是一帧，也可能是多帧</li>
<li>解码前的数据格式：AVPacket</li>
<li>解码后的数据格式：AVFrame</li>
</ol>
</li>
</ol>
<h3 id="一些相关的类及其参数"><a href="#一些相关的类及其参数" class="headerlink" title="一些相关的类及其参数"></a>一些相关的类及其参数</h3><ol>
<li>int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align);<ol>
<li>函数的作用：通过指定像素格式、图像宽、图像高来计算所需要的内存大小</li>
<li>重要参数：<ol>
<li>“align：设定内存对齐的对齐数，也就是按多大的字节对齐”</li>
</ol>
</li>
</ol>
</li>
<li>int av_image_alloc(uint8_t* pointers[4], int linesize[4], int w, int h, enum AVPixelFormat pix_fmt, int align);<ol>
<li>函数作用：按计算的内存大小申请所需要的内存</li>
<li>参数：<ol>
<li>pointers[4]：保存图像通道的地址。如果是RGB，则前三个指针分别指向R,G,B的内存地址，第四个保留不用</li>
<li>linesize[4]：保存图像每个通道的内存对齐的<strong>步长</strong>,即一行的对齐内存的宽度，此值的大小等于图像的宽度</li>
<li>w：要申请内存的图像宽度</li>
<li>h：要申请内存的图像高度</li>
<li>pix_fmt：要申请内存的图像的像素格式</li>
<li>align：用于内存对齐的值</li>
<li>@return：所申请的内存空间的总大小，如果为负值，申请失败</li>
</ol>
</li>
</ol>
</li>
<li>int av_image_fill_arrays(uint8_t ** dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align);<ol>
<li>函数作用：<ol>
<li>org: <ol>
<li>Setup the data pointers and linesizes based on the specified image parameters and provided array.（根据指定的图像参数和提供的数据设置数据指针和行宽的大小）The fields of the given image are filled in by using the src address which points to the image data buffer. Depending on the specified pixel format, one or multiple image data pointers and line sizes will be set.（给定图像的字段是使用指向图像数据缓冲区的src地址填充的，根据指定的像素格式，将设置一个或多个图像数据指针和行宽大小）</li>
</ol>
</li>
</ol>
</li>
<li>参数：<ol>
<li>dst_data[4]：data pointers to be filled in.（要填充的数据指针）<del>对申请的内存格式分为三个通道后，分别保存其地址</del></li>
<li>dst_linesize[4]：linesizes for the image in dst_data to be filled in.(dst_data中要填充的图像的行宽大小)<del>格式化的内存步长（即内存对齐后的宽度）</del></li>
<li>src：buffer which will contain or contains the actual image data can be NULL.（将包含或包含实际图像数据的缓冲区）<del>av_alloc()函数申请的内存地址</del></li>
<li>pix_fmt：the pixel format of the image.（图像的像素格式）<del>申请src内存时的像素格式</del></li>
<li>width：the width of the image in pixels. （图像的宽度，以像素为单位）<del>申请src的宽度</del></li>
<li>height：the height of the image in pixels. （图像的高度，以像素为单位）<del>申请src的高度</del></li>
<li>align：the value use in src for linesize alignment.（src中用于行大小对齐的值）<del>用于内存对齐的值</del></li>
<li>return：the size in bytes required for src.（src所需的大小，以字节为单位 ）</li>
</ol>
</li>
</ol>
</li>
<li>int avcodec_send_packet(AVCodecContext* avctx, const AVPacket* avpkt);<ol>
<li>函数功能：Supple raw packet data as input to a decoder.（提供原始数据包数据做为解码器的输入）Internally, this call will copy relevant AVCodecContext fields, which can influence decoding per-packet, and apply them when the packet is actually decoded.（在内部，此调用将复制相关的AVCodecContext字段，这些字段可能会影响到每个数据包的解码，并在数据包实际解码时应用这些字段）</li>
</ol>
</li>
<li>int avcodec_receive_frame(AVCodecContext* acvtx, AVFrame* frame)<ol>
<li>函数功能：Return decoded output data from a decoder.(从解码器返回解码数据)</li>
<li>参数：<ol>
<li>avctx: codec context.（编解码器上下文）</li>
<li>frame: This will be set to a reference-counted video or audion frame(depending on the decoder type) allocated by the decoder.（这将被设置为解码器分配的参考计数视频或音频帧，取决于解码器类型）Note that the function will always call av_frame_unref(frame) before doing anything else.（在调用av_frame_unref函数之前，它可以做任何其他的事情。）</li>
</ol>
</li>
</ol>
</li>
<li>int sws_scale(struct SwsContext* c, const uint8_t* const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t* const dst[], const int dstStride[]);<ol>
<li>函数功能：Scale the image slice in srcSlice and put the resulting scaled slice in the image in dst.（在srcSlice中缩放图像切片，并将生成缩放切片放在dst中的图像）A slice is a sequence of consecutive rows in an image.（一个切片是图像中连续行的一个序列）Slice have to be provided in sequential order, either in top-bottom or bottom-top order. If slices are provided in non-sequential order the behavior of the function is undefined.（切片必须是按顺序提供的，可以是上下顺序，也可以是下上顺序。如果切片以非顺序提供，则函数的行为未定义）</li>
<li>参数：<ol>
<li>c:the scaling context previously created with sws_getContext</li>
<li>srcSlice: the array containing the pointers to the planes of the source slice.（包含指向源切片平面的指针的数组）</li>
<li>srcStride: the array containing the stride for each plane of the source image.（包含源图像的每个平面的步长的数组）</li>
<li>srcSliceY: the position in the source image of the slice to process, that is the number(couted starting from zero) in the image of the first row of the slice.（要处理的切片的源图像的位置，即切片第一行图像张的数字（从零开始计数））</li>
<li>srcSliceH: the height of the source slice, that is the number of rows in the slice.（源切片的高度，即切片中的行数）</li>
<li>dst: the array containing the pointers to the planes of the destination image.（包含指向目标图像平面的指针的数组）</li>
<li>dstStride : the array containing the strides for each plane of the destination image.（包含目标图像的每个平面的步长的数组）</li>
<li>@return：the height of the output slice.（输出切片的高度）</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><ol>
<li>字节对齐、内存对齐<ol>
<li>现代计算机中内存空间都是按照byte划分的，从理论上将似乎对任何类型的变量额访问可以从任何地址开始，但是实际上的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常是4或者8）的背书，这就是所谓的内存对齐</li>
<li>图像在存储或传输的过程中，一般一个行宽会是某个数的倍数，行宽一般是以字节为单位的，所以便有字节对齐。（例如：一个图像的行宽为1023，想向1024对齐，差的1个字节，就是字节对齐数）<ol>
<li>行宽 &#x3D;  宽度 × 通道数</li>
<li>高度 &#x3D; 就是行数，因为每一行是在高度上是1</li>
<li>那么申请的内存大小为：height * width * channels</li>
<li>图像在电脑里存储的是二维数据，也就是数字矩阵。（不管是1通道还是3通道，都是以数字矩阵（二维）方式存储，不通的是一个像素是对应一个值还是三个值）</li>
<li>而现实中，对图像存储的描述，可以是立体的，例如三通道的图像，就是立方体，长是行宽，宽是高度，高是通道数。（<del>这样一说，好像更迷了哈哈哈，但它就是立方体，第三个坐标轴代表的是通道数</del>）</li>
</ol>
</li>
</ol>
</li>
<li>AVFrame结构体中的几个参数：<ol>
<li>width、height：Video dimensions. Video frames only. The coded dimensions(in pixels) of the video frame, i.e. the size of the rectangle that contains some well-defined values.（仅限视频帧，视频帧的编码尺寸（以像素为单位），即包含一些明确定义的值的矩形大小）</li>
<li>linesize ：for video, size in bytes of each picture line.（对于视频，每条图片行的大小（以字节为单位））for video the linesizes should be multiples of the CPUs alignment preference, this is 16 or 32 for modern destop CPUs.（对于视频，线条大小应该是CPU对齐首选项的倍数，对于现代桌面CPU，这是16或32.）</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/FFmpeg/ffmpeg_5_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-ffmpeg_5_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/FFmpeg/ffmpeg_5_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-ffmpeg_5_01/" class="post-title-link" itemprop="url">ffmpeg_5_01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ffmpeg常用函数</li>
</ul>
<h2 id="ffmpeg-sws-scale-函数-详解"><a href="#ffmpeg-sws-scale-函数-详解" class="headerlink" title="ffmpeg sws_scale() 函数 详解"></a>ffmpeg sws_scale() 函数 详解</h2><p><code>sws_scale()</code> 函数是 FFmpeg 中的一个函数，用于执行图像的像素格式转换和尺寸缩放等操作。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sws_scale</span><span class="params">(<span class="keyword">struct</span> SwsContext *c, <span class="type">const</span> <span class="type">uint8_t</span> *<span class="type">const</span> srcSlice[],</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="type">int</span> srcStride[], <span class="type">int</span> srcSliceY, <span class="type">int</span> srcSliceH,</span></span><br><span class="line"><span class="params">              <span class="type">uint8_t</span> *<span class="type">const</span> dst[], <span class="type">const</span> <span class="type">int</span> dstStride[])</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<ul>
<li><code>c</code>：指向 <code>SwsContext</code> 结构的指针，表示图像转换器上下文。</li>
<li><code>srcSlice</code> 和 <code>dst</code>：分别是源图像和目标图像的数据缓冲区。<code>srcSlice</code> 是一个指针数组，用于存储源图像的每一行数据的指针；<code>dst</code> 也是一个指针数组，用于存储目标图像的每一行数据的指针。</li>
<li><code>srcStride</code> 和 <code>dstStride</code>：分别是源图像和目标图像的行字节步长数组。<code>srcStride</code> 数组中存储了源图像每一行数据的字节步长；<code>dstStride</code> 数组中存储了目标图像每一行数据的字节步长。</li>
<li><code>srcSliceY</code> 和 <code>srcSliceH</code>：分别表示要处理的源图像的起始行号和行数。</li>
</ul>
<p>调用 <code>sws_scale()</code> 函数将会执行图像的像素格式转换和尺寸缩放等操作。该函数将源图像数据转换为目标图像数据，并根据需要进行尺寸缩放。</p>
<p>在调用该函数之前，需要先创建一个图像转换器上下文（<code>SwsContext</code>），并对其进行适当的初始化。通常情况下，可以使用 <code>sws_getContext()</code> 函数来创建一个图像转换器上下文，并指定源图像和目标图像的相关参数。</p>
<p>需要注意的是，<code>sws_scale()</code> 函数执行的是图像转换操作，因此需要确保输入和输出缓冲区的大小和格式是正确匹配的。另外，对于需要进行尺寸缩放的情况，需要根据源图像和目标图像的尺寸比例来设置相应的缩放比例。</p>
<p>使用 <code>sws_scale()</code> 函数可以实现图像的像素格式转换、尺寸缩放等功能，常用于视频处理和图像处理等应用场景。</p>
<h2 id="ffmpeg-avcodec-receive-frame-函数-详解"><a href="#ffmpeg-avcodec-receive-frame-函数-详解" class="headerlink" title="ffmpeg avcodec_receive_frame() 函数 详解"></a>ffmpeg avcodec_receive_frame() 函数 详解</h2><p><code>avcodec_receive_frame()</code> 函数是 FFmpeg 中的一个函数，用于从解码器中获取解码后的音频或视频帧。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">avcodec_receive_frame</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<ul>
<li><code>avctx</code> 是指向 <code>AVCodecContext</code> 结构的指针，表示要使用的解码器上下文。</li>
<li><code>frame</code> 是指向 <code>AVFrame</code> 结构的指针，表示要接收解码后的音频或视频帧。</li>
</ul>
<p>调用 <code>avcodec_receive_frame()</code> 函数后，将会从解码器中获取解码后的音频或视频帧，并将帧数据保存到 <code>frame</code> 中。这个函数通常用于解码过程的第二步，用于从解码器获取解码后的帧数据。</p>
<p>需要注意的是，由于解码器可能会对帧数据进行缓冲和延迟处理，因此调用该函数并不会立即返回已解码的帧数据。如果解码器内部缓冲区中没有可用的解码帧，该函数将会阻塞，直到解码器解码完成并有可用的解码帧为止。</p>
<p>在解码器解码完所有数据包后，需要调用 <code>avcodec_receive_frame()</code> 函数并传递 <code>NULL</code> 作为帧参数，以表示已经接收完所有解码帧，解码器可以进行最后的清理工作。这样做可以确保解码器在解码完所有数据包后能够正确地结束解码过程。</p>
<p>需要注意的是，<code>AVFrame</code> 结构中存储的帧数据通常是解码后的原始音频或视频数据，需要根据实际情况进行后续处理，例如播放音频或显示视频。</p>
<h2 id="ffmpeg-avcodec-send-packet-函数-详解"><a href="#ffmpeg-avcodec-send-packet-函数-详解" class="headerlink" title="ffmpeg avcodec_send_packet() 函数 详解"></a>ffmpeg avcodec_send_packet() 函数 详解</h2><p><code>avcodec_send_packet()</code> 函数是 FFmpeg 中的一个函数，用于向解码器发送压缩数据包。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">avcodec_send_packet</span><span class="params">(AVCodecContext *avctx, <span class="type">const</span> AVPacket *pkt)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>avctx</code> 是指向 <code>AVCodecContext</code> 结构的指针，表示要使用的解码器上下文；<code>pkt</code> 是指向 <code>AVPacket</code> 结构的指针，表示要发送的压缩数据包。</p>
<p>调用 <code>avcodec_send_packet()</code> 函数后，将会向解码器发送一个压缩数据包，解码器将会从这个数据包中解析出压缩的音频或视频帧，并进行解码操作。这个函数通常用于解码过程的第一步，将压缩的音视频数据发送给解码器。</p>
<p>需要注意的是，由于解码器可能会对压缩数据进行缓冲和延迟处理，因此调用该函数并不会立即触发解码操作。解码器将会在后续调用 <code>avcodec_receive_frame()</code> 函数时，从缓冲区中获取压缩数据包并进行解码。</p>
<p>在解码器解码完所有数据包后，需要调用 <code>avcodec_send_packet()</code> 函数并传递 <code>NULL</code> 作为数据包参数，以表示已经发送完所有数据包，解码器可以进行最后的解码操作。这样做可以确保解码器在解码完所有数据包后能够正确地结束解码过程。</p>
<p>需要注意的是，<code>AVPacket</code> 结构中的数据通常来自于读取媒体文件或网络流等操作，或者是从编码器中获取到的压缩数据。因此，在调用 <code>avcodec_send_packet()</code> 函数之前，需要先正确地获取到压缩数据，并将数据填充到 <code>AVPacket</code> 结构中。</p>
<h2 id="ffmpeg-sws-getContext-函数-详解"><a href="#ffmpeg-sws-getContext-函数-详解" class="headerlink" title="ffmpeg sws_getContext() 函数 详解"></a>ffmpeg sws_getContext() 函数 详解</h2><p><code>sws_getContext()</code> 是 FFmpeg 中的一个函数，用于创建和初始化图像转换器上下文（SWSContext）。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SwsContext *<span class="title function_">sws_getContext</span><span class="params">(<span class="type">int</span> srcW, <span class="type">int</span> srcH, <span class="keyword">enum</span> AVPixelFormat srcFormat,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> dstW, <span class="type">int</span> dstH, <span class="keyword">enum</span> AVPixelFormat dstFormat,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> flags, SwsFilter *srcFilter,</span></span><br><span class="line"><span class="params">                                  SwsFilter *dstFilter, <span class="type">const</span> <span class="type">double</span> *param)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<ul>
<li><code>srcW</code> 和 <code>srcH</code>：源图像的宽度和高度。</li>
<li><code>srcFormat</code>：源图像的像素格式。</li>
<li><code>dstW</code> 和 <code>dstH</code>：目标图像的宽度和高度。</li>
<li><code>dstFormat</code>：目标图像的像素格式。</li>
<li><code>flags</code>：额外的标志，用于控制图像转换的行为。</li>
<li><code>srcFilter</code> 和 <code>dstFilter</code>：分别是源图像和目标图像的滤波器。如果不使用滤波器，可以传递 <code>NULL</code>。</li>
<li><code>param</code>：用于设置特定参数的指针数组。通常情况下，可以传递 <code>NULL</code>。</li>
</ul>
<p>调用 <code>sws_getContext()</code> 函数将会创建一个图像转换器上下文，并返回一个指向该上下文的指针。通过这个上下文，您可以执行图像的像素格式转换、尺寸缩放等操作。</p>
<p>一旦创建了图像转换器上下文，您就可以使用 <code>sws_scale()</code> 函数来执行实际的图像转换操作。该函数将源图像转换为目标图像，同时进行必要的缩放和格式转换。在完成图像转换后，您需要调用 <code>sws_freeContext()</code> 函数来释放图像转换器上下文，以避免内存泄漏。</p>
<p>图像转换器上下文的创建和释放通常是在图像处理流程的开始和结束时进行的。在实际应用中，您可以根据需要多次创建和释放图像转换器上下文，以便处理不同格式和尺寸的图像。</p>
<h2 id="ffmpeg-avcodec-open2-函数-详解"><a href="#ffmpeg-avcodec-open2-函数-详解" class="headerlink" title="ffmpeg avcodec_open2() 函数 详解"></a>ffmpeg avcodec_open2() 函数 详解</h2><p><code>avcodec_open2()</code> 函数是 FFmpeg 中的一个函数，用于初始化编解码器的上下文，并打开编解码器。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">avcodec_open2</span><span class="params">(AVCodecContext *avctx, <span class="type">const</span> AVCodec *codec, AVDictionary **options)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>avctx</code> 是指向 <code>AVCodecContext</code> 结构的指针，表示要初始化和打开的编解码器的上下文；<code>codec</code> 是一个指向 <code>AVCodec</code> 结构的指针，表示要使用的编解码器；<code>options</code> 是一个指向指向 <code>AVDictionary</code> 结构的指针的指针，用于设置额外的选项。</p>
<p>调用 <code>avcodec_open2()</code> 函数后，将会根据给定的 <code>codec</code> 参数初始化并打开 <code>avctx</code> 表示的编解码器上下文。</p>
<p>这个函数在解码视频或音频之前通常需要被调用。在调用该函数之前，需要确保 <code>AVCodecContext</code> 结构已经被正确地设置了编解码器相关的参数。而且，<code>codec</code> 参数需要通过 <code>avcodec_find_decoder()</code> 或其他相关函数找到并指定为相应的解码器。</p>
<p>此外，您可以通过 <code>options</code> 参数传递一些额外的选项给编解码器。这个参数通常是一个字典，包含了一些键值对，用于设置编解码器的一些特定选项，例如编码器的配置参数、输出格式等。</p>
<p>需要注意的是，如果调用成功，<code>avcodec_open2()</code> 函数将返回零。如果发生错误，将会返回一个负值，表示打开编解码器失败的原因。</p>
<p>在使用完编解码器后，通常需要调用 <code>avcodec_close()</code> 函数来关闭编解码器并释放相关资源。</p>
<h2 id="ffmpeg-avcodec-alloc-context3-函数-详解"><a href="#ffmpeg-avcodec-alloc-context3-函数-详解" class="headerlink" title="ffmpeg avcodec_alloc_context3() 函数 详解"></a>ffmpeg avcodec_alloc_context3() 函数 详解</h2><p><code>avcodec_alloc_context3()</code> 是 FFmpeg 中的一个函数，用于分配一个新的 <code>AVCodecContext</code> 结构，并返回一个指向该结构的指针。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVCodecContext *<span class="title function_">avcodec_alloc_context3</span><span class="params">(<span class="type">const</span> AVCodec *codec)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>codec</code> 参数是一个指向 <code>AVCodec</code> 结构的指针，用于指定要分配上下文的编解码器。</p>
<p><code>AVCodecContext</code> 结构是 FFmpeg 中的一个重要结构，用于存储编解码器的状态信息、编解码参数、输入和输出格式等。在使用 FFmpeg 进行编解码操作时，通常需要先分配一个 <code>AVCodecContext</code> 结构，并对其进行适当的设置，然后才能使用该结构来执行编解码操作。</p>
<p>通过调用 <code>avcodec_alloc_context3()</code> 函数，您可以创建一个新的 <code>AVCodecContext</code> 结构。通常情况下，您可以在查找到要使用的编解码器后，调用该函数来分配一个对应的上下文，并将编解码器的相关参数复制到该上下文中。</p>
<p>需要注意的是，分配的 <code>AVCodecContext</code> 结构在使用完毕后，需要通过调用 <code>avcodec_free_context()</code> 函数来释放内存，以避免内存泄漏问题。</p>
<h2 id="ffmpeg-avcodec-find-decoder-函数-详解"><a href="#ffmpeg-avcodec-find-decoder-函数-详解" class="headerlink" title="ffmpeg avcodec_find_decoder() 函数 详解"></a>ffmpeg avcodec_find_decoder() 函数 详解</h2><p><code>avcodec_find_decoder()</code> 函数是 FFmpeg 中的一个函数，用于查找指定编解码器的解码器。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVCodec *<span class="title function_">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>id</code> 参数是要查找的编解码器的 ID。通常情况下，您可以通过查找编码视频或音频流时获取到的编码器 ID 来调用该函数。</p>
<p>该函数返回一个指向 <code>AVCodec</code> 结构的指针，该结构包含了编解码器的详细信息，包括名称、类型、支持的像素格式等。</p>
<p>使用 <code>avcodec_find_decoder()</code> 函数的典型场景是在解码视频或音频流之前，先根据流的编码器 ID 查找对应的解码器。然后，您可以使用返回的 <code>AVCodec</code> 结构中的信息来初始化解码器并进行解码操作。</p>
<p>需要注意的是，查找编解码器的过程是基于 FFmpeg 中已注册的编解码器列表进行的。因此，在使用该函数之前，您需要确保已经调用了 <code>av_register_all()</code> 或者其他相关的注册函数，以确保 FFmpeg 能够识别和访问所有可用的编解码器。</p>
<h2 id="ffmpeg-avcodec-parameters-to-context-函数-详解"><a href="#ffmpeg-avcodec-parameters-to-context-函数-详解" class="headerlink" title="ffmpeg avcodec_parameters_to_context() 函数 详解"></a>ffmpeg avcodec_parameters_to_context() 函数 详解</h2><p><code>avcodec_parameters_to_context()</code> 函数是 FFmpeg 中的一个函数，用于将 <code>AVCodecParameters</code> 结构中的编解码器参数复制到 <code>AVCodecContext</code> 结构中。</p>
<p>在 FFmpeg 中，<code>AVCodecParameters</code> 结构包含了描述音频或视频流的编码参数的信息，例如编码类型、图像大小、帧率等。而 <code>AVCodecContext</code> 结构则是编解码器的上下文，包含了编解码器的状态信息、编解码选项等。</p>
<p><code>avcodec_parameters_to_context()</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">avcodec_parameters_to_context</span><span class="params">(AVCodecContext *codec, <span class="type">const</span> AVCodecParameters *par)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>codec</code> 是指向目标 <code>AVCodecContext</code> 结构的指针，<code>par</code> 是指向源 <code>AVCodecParameters</code> 结构的指针。</p>
<p>该函数将 <code>par</code> 中的编解码器参数复制到 <code>codec</code> 中，使 <code>codec</code> 中的属性与 <code>par</code> 中的属性匹配。这样做的目的是为了使得在使用 FFmpeg 进行编解码时，可以直接使用 <code>AVCodecContext</code> 中的属性，而无需重新设置这些属性。</p>
<p>例如，您可以使用该函数将解码器参数复制到解码器的上下文中，以便初始化解码器并进行解码操作。</p>
<p>需要注意的是，调用该函数后，<code>AVCodecContext</code> 中的属性会被 <code>AVCodecParameters</code> 中的属性所覆盖。因此，在调用该函数之后，您可能需要检查 <code>AVCodecContext</code> 中的属性是否正确设置，或者根据需要进行进一步的调整。</p>
<h2 id="ffmpeg-avformat-network-init-函数-详解"><a href="#ffmpeg-avformat-network-init-函数-详解" class="headerlink" title="ffmpeg avformat_network_init() 函数  详解"></a>ffmpeg avformat_network_init() 函数  详解</h2><p><code>avformat_network_init()</code> 函数是FFmpeg库提供的一个函数，用于初始化 FFmpeg 中的网络功能。</p>
<p>以下是对 <code>avformat_network_init()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_network_init()</code> 函数的主要目的是初始化 FFmpeg 中与网络相关的组件，以便处理网络流和网络协议。这包括 HTTP、RTMP、RTP 等协议。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>在处理 FFmpeg 中的网络流或协议时，需要初始化网络子系统，以启用网络相关功能。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>该函数初始化 FFmpeg 中的网络组件，使其能够在网络协议上建立连接、发送请求和接收响应。</li>
<li>它设置了网络操作所需的必要结构和资源。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<ul>
<li>在应用程序开始时，在使用 FFmpeg 函数进行任何网络相关操作之前，通常应调用 <code>avformat_network_init()</code> 函数。</li>
<li>通常在应用程序的初始化阶段调用一次。</li>
</ul>
</li>
<li><p><strong>线程安全性</strong>：</p>
<ul>
<li>值得注意的是，<code>avformat_network_init()</code> 函数不是线程安全的。因此，如果您的应用程序是多线程的，并且在多个线程中使用 FFmpeg，应以线程安全的方式调用此函数，确保它只调用一次，并且在执行任何网络操作之前调用。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_network_init()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化网络组件</span></span><br><span class="line">    avformat_network_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里放置用于网络操作的 FFmpeg 代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    avformat_network_deinit(); <span class="comment">// 函数名中没有提到，但是有一个对应的清理函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li>此函数依赖于提供网络功能的外部库，例如 libavutil、libavcodec 等。确保这些库与您的应用程序正确链接。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_network_init()</code> 函数用于初始化 FFmpeg 中的网络组件，从而使多媒体应用程序能够处理基于网络的输入&#x2F;输出操作。在使用 FFmpeg 处理网络流或协议时，这是一个关键步骤。</p>
<h2 id="ffmpeg-avformat-network-deinit-函数-详解"><a href="#ffmpeg-avformat-network-deinit-函数-详解" class="headerlink" title="ffmpeg avformat_network_deinit() 函数  详解"></a>ffmpeg avformat_network_deinit() 函数  详解</h2><p><code>avformat_network_deinit()</code> 函数是 FFmpeg 库中的一个函数，用于释放 <code>avformat_network_init()</code> 函数所初始化的网络相关资源。以下是对 <code>avformat_network_deinit()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_network_deinit()</code> 函数的主要目的是释放由 <code>avformat_network_init()</code> 函数初始化的网络相关资源。这个函数通常用于在应用程序关闭或不再需要网络功能时进行清理。</li>
</ul>
</li>
<li><p><strong>释放资源</strong>：</p>
<ul>
<li>在使用 <code>avformat_network_init()</code> 函数初始化网络组件后，可能会分配一些资源，例如分配的内存、打开的网络连接等。<code>avformat_network_deinit()</code> 函数用于释放这些资源，以避免资源泄漏或内存泄漏。</li>
</ul>
</li>
<li><p><strong>调用时机</strong>：</p>
<ul>
<li>通常情况下，应在不再需要网络功能时调用 <code>avformat_network_deinit()</code> 函数。例如，在应用程序关闭时或者在不再需要处理网络流或协议时。</li>
</ul>
</li>
<li><p><strong>线程安全性</strong>：</p>
<ul>
<li>与 <code>avformat_network_init()</code> 函数类似，<code>avformat_network_deinit()</code> 函数也不是线程安全的。如果您的应用程序是多线程的，并且在多个线程中使用了 FFmpeg，应以线程安全的方式调用此函数。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_network_deinit()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化网络组件</span></span><br><span class="line">    avformat_network_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里放置用于网络操作的 FFmpeg 代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理网络资源</span></span><br><span class="line">    avformat_network_deinit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li>与 <code>avformat_network_init()</code> 函数相同，<code>avformat_network_deinit()</code> 函数也依赖于外部库，如 libavutil、libavcodec 等。确保这些库与您的应用程序正确链接。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_network_deinit()</code> 函数用于释放 <code>avformat_network_init()</code> 函数初始化的网络相关资源。在不再需要网络功能时，应当调用该函数以避免资源泄漏。</p>
<h2 id="ffmpeg-avformat-alloc-context-函数-详解"><a href="#ffmpeg-avformat-alloc-context-函数-详解" class="headerlink" title="ffmpeg avformat_alloc_context() 函数  详解"></a>ffmpeg avformat_alloc_context() 函数  详解</h2><p><code>avformat_alloc_context()</code> 是 FFmpeg 中的一个函数，用于分配一个 <code>AVFormatContext</code> 结构体，并进行初始化。这个结构体是 FFmpeg 中用来表示输入或输出格式上下文的重要数据结构。</p>
<p>以下是对 <code>avformat_alloc_context()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_alloc_context()</code> 函数的主要目的是为了创建一个 <code>AVFormatContext</code> 结构体，这是 FFmpeg 中用来表示音视频格式的上下文信息的数据结构。这个上下文包含了音视频流、封装格式、编解码器等相关信息。</li>
</ul>
</li>
<li><p><strong>分配和初始化</strong>：</p>
<ul>
<li>此函数分配了一个 <code>AVFormatContext</code> 结构体，并对其进行了初始化，以便后续可以使用该结构体进行音视频处理操作。</li>
</ul>
</li>
<li><p><strong>使用方法</strong>：</p>
<ul>
<li>在使用 <code>avformat_alloc_context()</code> 函数后，可以通过设置 <code>AVFormatContext</code> 结构体中的各种属性来定义音视频文件的格式和编解码器等信息。</li>
<li>在打开、创建或解析音视频文件时，通常会使用此函数来创建一个 <code>AVFormatContext</code> 结构体，并在后续的操作中传递和使用该结构体。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_alloc_context()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 分配 AVFormatContext 结构体</span></span><br><span class="line">    AVFormatContext *formatContext = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!formatContext) &#123;</span><br><span class="line">        <span class="comment">// 分配失败</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error allocating format context\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续操作，设置或使用 formatContext</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 AVFormatContext 结构体</span></span><br><span class="line">    avformat_free_context(formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_alloc_context()</code> 函数本身并不依赖外部库，但是创建的 <code>AVFormatContext</code> 结构体在使用过程中可能涉及到其他 FFmpeg 库函数，这些函数可能会依赖于其他外部库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_alloc_context()</code> 函数用于创建并初始化一个 <code>AVFormatContext</code> 结构体，该结构体在 FFmpeg 中用于表示音视频文件的格式和相关信息。在进行音视频文件处理时，通常会使用此函数来创建一个格式上下文，并在后续的操作中使用该上下文。</p>
<h2 id="ffmpeg-av-dict-set-函数-详解"><a href="#ffmpeg-av-dict-set-函数-详解" class="headerlink" title="ffmpeg av_dict_set() 函数  详解"></a>ffmpeg av_dict_set() 函数  详解</h2><p><code>av_dict_set()</code> 函数是 FFmpeg 中用于设置字典（dictionary）中键值对的函数。这个函数主要用于向字典中添加或修改键值对。</p>
<p>以下是对 <code>av_dict_set()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_dict_set()</code> 函数的主要目的是在字典中设置键值对。在 FFmpeg 中，字典通常用于存储各种元数据、选项或参数。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVDictionary **dict</code>：指向指针的指针，指向需要设置键值对的字典。这个指针可以是指向 NULL 的空指针，如果字典不存在，则会自动创建一个新的字典。</li>
<li><code>const char *key</code>：要设置的键的名称。</li>
<li><code>const char *value</code>：要设置的值。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>如果字典中已存在具有相同键的条目，则此函数将替换现有条目的值。</li>
<li>如果字典中不存在具有相同键的条目，则此函数将在字典中添加一个新的键值对。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_dict_set()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/dict.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVDictionary *dict = <span class="literal">NULL</span>; <span class="comment">// 定义一个空字典</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置键值对到字典中</span></span><br><span class="line">    av_dict_set(&amp;dict, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    av_dict_set(&amp;dict, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 av_dict_set() 后，字典中将包含以下键值对：</span></span><br><span class="line">    <span class="comment">// &quot;key1&quot; -&gt; &quot;value1&quot;</span></span><br><span class="line">    <span class="comment">// &quot;key2&quot; -&gt; &quot;value2&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放字典</span></span><br><span class="line">    av_dict_free(&amp;dict);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_dict_set()</code> 函数本身并不依赖外部库，但是创建的字典在使用过程中可能涉及到其他 FFmpeg 库函数，这些函数可能会依赖于其他外部库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_dict_set()</code> 函数用于设置字典中的键值对。通过这个函数，可以向字典中添加新的键值对，或者修改现有键的值。在处理 FFmpeg 中的元数据、选项或参数时，通常会使用这个函数来管理字典中的键值对。</p>
<h2 id="ffmpeg-avformat-open-input-函数-详解"><a href="#ffmpeg-avformat-open-input-函数-详解" class="headerlink" title="ffmpeg avformat_open_input() 函数  详解"></a>ffmpeg avformat_open_input() 函数  详解</h2><p><code>avformat_open_input()</code> 是 FFmpeg 中用于打开输入音视频文件或流的函数。这个函数负责初始化并打开一个输入格式上下文，以便后续可以进行音视频解码、编码或者其他处理操作。</p>
<p>以下是对 <code>avformat_open_input()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_open_input()</code> 函数的主要目的是打开一个输入音视频文件或者流，并为后续的音视频处理操作创建一个输入格式上下文（<code>AVFormatContext</code>）。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext **ps</code>：指向指针的指针，用于存储创建的输入格式上下文。</li>
<li><code>const char *url</code>：输入文件的 URL 或者文件名。</li>
<li><code>AVInputFormat *fmt</code>：输入文件的格式，通常可以传入 NULL 以让 FFmpeg 自动检测输入文件的格式。</li>
<li><code>AVDictionary **options</code>：附加选项，例如设置解码器选项等。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_open_input()</code> 函数会根据提供的 URL 或者文件名打开相应的音视频文件或者流，并将文件的格式信息存储在创建的输入格式上下文中。</li>
<li>如果指定了输入文件的格式（<code>fmt</code> 参数不为 NULL），则 FFmpeg 会尝试以指定的格式打开文件。否则，它将会自动检测文件的格式。</li>
<li>可以通过 <code>options</code> 参数传递一些附加选项，例如设置解码器选项、设置连接超时等。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_open_input()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入文件</span></span><br><span class="line">    <span class="type">int</span> ret = avformat_open_input(&amp;formatContext, <span class="string">&quot;input.mp4&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 打开失败</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open input file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续操作，例如解码、编码等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输入文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_open_input()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_open_input()</code> 函数用于打开输入音视频文件或者流，并创建一个输入格式上下文，以便后续进行音视频处理操作。在处理音视频文件时，通常会使用这个函数来打开输入文件，以便后续进行解码、编码或其他处理。</p>
<h2 id="ffmpeg-avformat-find-stream-info-函数-详解"><a href="#ffmpeg-avformat-find-stream-info-函数-详解" class="headerlink" title="ffmpeg avformat_find_stream_info() 函数  详解"></a>ffmpeg avformat_find_stream_info() 函数  详解</h2><p><code>avformat_find_stream_info()</code> 函数是 FFmpeg 中用于获取音视频文件或流的基本信息的函数。它会尝试从输入的音视频文件或流中提取流信息，如编解码器、时长、帧率等，并填充到 <code>AVFormatContext</code> 结构体中的 <code>streams</code> 数组中的 <code>AVStream</code> 结构体中。</p>
<p>以下是对 <code>avformat_find_stream_info()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_find_stream_info()</code> 函数的主要目的是从音视频文件或流中提取流信息。这些信息包括每个音视频流的编解码器、时长、帧率、分辨率等。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *ic</code>：指向已经打开的输入格式上下文的指针。</li>
<li><code>AVDictionary **options</code>：附加选项，用于设置解码器选项等。通常可以传入 NULL。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_find_stream_info()</code> 函数会在已打开的输入格式上下文中尝试从文件或流中读取流信息，并将这些信息填充到 <code>AVFormatContext</code> 结构体中的 <code>streams</code> 数组中的 <code>AVStream</code> 结构体中。</li>
<li>它会尝试解码几个帧来获取一些基本信息，例如帧率、分辨率等。这些信息对于后续的音视频处理操作非常重要。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。如果在读取流信息时需要进行一些解码操作，可能会返回 <code>AVERROR(EAGAIN)</code>，表示需要更多数据才能继续解码。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_find_stream_info()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入文件</span></span><br><span class="line">    <span class="type">int</span> ret = avformat_open_input(&amp;formatContext, <span class="string">&quot;input.mp4&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open input file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取流信息</span></span><br><span class="line">    ret = avformat_find_stream_info(formatContext, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to find stream information\n&quot;</span>);</span><br><span class="line">        avformat_close_input(&amp;formatContext);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流信息现在可以在 formatContext-&gt;streams 中访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输入文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_find_stream_info()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_find_stream_info()</code> 函数用于从音视频文件或流中提取流信息，并填充到 <code>AVFormatContext</code> 结构体中的 <code>streams</code> 数组中的 <code>AVStream</code> 结构体中。在处理音视频文件时，通常会在打开文件后调用这个函数，以便获取文件的基本信息，从而为后续的处理操作做准备。</p>
<h2 id="ffmpeg-avformat-alloc-output-context2-函数-详解"><a href="#ffmpeg-avformat-alloc-output-context2-函数-详解" class="headerlink" title="ffmpeg avformat_alloc_output_context2() 函数  详解"></a>ffmpeg avformat_alloc_output_context2() 函数  详解</h2><p><code>avformat_alloc_output_context2()</code> 是 FFmpeg 中用于创建输出格式上下文的函数。它用于分配并初始化一个 <code>AVFormatContext</code> 结构体，用于封装输出的音视频数据流。</p>
<p>以下是对 <code>avformat_alloc_output_context2()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_alloc_output_context2()</code> 函数的主要目的是创建一个输出格式上下文，用于封装输出的音视频数据流。这个函数通常用于编码和封装音视频文件，生成最终的音视频文件或者流。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext **ctx</code>：指向指针的指针，用于存储创建的输出格式上下文。</li>
<li><code>AVOutputFormat *oformat</code>：要使用的输出格式，通常可以传入 NULL 以让 FFmpeg 自动选择输出格式。</li>
<li><code>const char *format_name</code>：指定要输出的格式的名称，例如 “mp4”、”flv” 等。</li>
<li><code>const char *filename</code>：输出文件的路径或者 URL。</li>
<li><code>AVDictionary **options</code>：附加选项，例如设置编码器选项、容器格式选项等。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_alloc_output_context2()</code> 函数会根据指定的输出格式或者输出文件的扩展名创建一个输出格式上下文。</li>
<li>它将会为这个输出格式上下文分配内存，并对其进行初始化，以便后续可以进行音视频编码和封装操作。</li>
<li>可以通过 <code>options</code> 参数传递一些附加选项，例如设置编码器选项、容器格式选项等。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_alloc_output_context2()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出格式上下文</span></span><br><span class="line">    <span class="type">int</span> ret = avformat_alloc_output_context2(&amp;formatContext, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;output.mp4&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create output format context\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续操作，例如设置编码器、添加音视频流等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放输出格式上下文</span></span><br><span class="line">    avformat_free_context(formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_alloc_output_context2()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_alloc_output_context2()</code> 函数用于创建输出格式上下文，用于封装输出的音视频数据流。在编码和封装音视频文件时，通常会使用这个函数来创建一个输出格式上下文，以便后续进行编码和封装操作。</p>
<h2 id="ffmpeg-avformat-new-stream-函数-详解"><a href="#ffmpeg-avformat-new-stream-函数-详解" class="headerlink" title="ffmpeg avformat_new_stream() 函数  详解"></a>ffmpeg avformat_new_stream() 函数  详解</h2><p><code>avformat_new_stream()</code> 函数是 FFmpeg 中用于创建新的音视频流的函数。它用于向输出格式上下文中添加一个新的音视频流，并返回一个指向该流的指针。</p>
<p>以下是对 <code>avformat_new_stream()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_new_stream()</code> 函数的主要目的是创建一个新的音视频流，并将其添加到输出格式上下文中。这个函数通常用于在封装音视频文件时向文件中添加新的音视频流。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *s</code>：指向输出格式上下文的指针，表示要向哪个输出格式上下文中添加新的音视频流。</li>
<li><code>const AVCodec *c</code>：表示新创建的流将使用的编解码器。可以为 NULL，表示不指定编解码器，后续可以手动设置。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值是一个指向新创建的音视频流的指针（<code>AVStream*</code>）。如果创建失败或者输出格式上下文没有被分配，则返回 NULL。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_new_stream()</code> 函数会在输出格式上下文中添加一个新的音视频流，并返回一个指向该流的指针。</li>
<li>新创建的音视频流将会被添加到输出格式上下文的 <code>streams</code> 数组中，并被编号为数组中的索引值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_new_stream()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line">    AVStream *stream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出格式上下文</span></span><br><span class="line">    avformat_alloc_output_context2(&amp;formatContext, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;output.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个音视频流</span></span><br><span class="line">    stream = avformat_new_stream(formatContext, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!stream) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create new stream\n&quot;</span>);</span><br><span class="line">        avformat_free_context(formatContext);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新创建的音视频流的参数，例如编码器、分辨率、帧率等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放输出格式上下文</span></span><br><span class="line">    avformat_free_context(formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_new_stream()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_new_stream()</code> 函数用于创建一个新的音视频流，并将其添加到输出格式上下文中。在封装音视频文件时，通常会使用这个函数来向输出文件中添加新的音视频流。</p>
<h2 id="ffmpeg-avcodec-parameters-copy-函数-详解"><a href="#ffmpeg-avcodec-parameters-copy-函数-详解" class="headerlink" title="ffmpeg avcodec_parameters_copy() 函数  详解"></a>ffmpeg avcodec_parameters_copy() 函数  详解</h2><p><code>avcodec_parameters_copy()</code> 函数是 FFmpeg 中用于复制编解码器参数的函数。它用于将源编解码器参数复制到目标编解码器参数，以便在不同的上下文中重用参数。</p>
<p>以下是对 <code>avcodec_parameters_copy()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avcodec_parameters_copy()</code> 函数的主要目的是将一个编解码器参数结构体的内容复制到另一个编解码器参数结构体中。这样可以在不同的编解码器或者上下文中重用参数。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVCodecParameters *dst</code>：目标编解码器参数结构体指针，用于存储复制后的参数。</li>
<li><code>const AVCodecParameters *src</code>：源编解码器参数结构体指针，要复制的参数将从这里获取。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avcodec_parameters_copy()</code> 函数会将源编解码器参数结构体中的参数值复制到目标编解码器参数结构体中。</li>
<li>它将会复制编解码器的类型、格式、分辨率、帧率、比特率等参数。</li>
<li>这个函数通常用于在不同的上下文中重用编解码器参数，例如在转码、封装、解封装等操作中。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avcodec_parameters_copy()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVCodecParameters *dst_params = avcodec_parameters_alloc();</span><br><span class="line">    AVCodecParameters *src_params = avcodec_parameters_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设已经设置了 src_params 中的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制编解码器参数</span></span><br><span class="line">    <span class="type">int</span> ret = avcodec_parameters_copy(dst_params, src_params);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to copy codec parameters\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在 dst_params 中包含了与 src_params 相同的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    avcodec_parameters_free(&amp;dst_params);</span><br><span class="line">    avcodec_parameters_free(&amp;src_params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avcodec_parameters_copy()</code> 函数依赖于 FFmpeg 的 libavcodec 库，该库负责处理各种音视频编解码器。因此，在使用这个函数之前，需要确保正确链接了 libavcodec 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avcodec_parameters_copy()</code> 函数用于复制编解码器参数结构体的内容，以便在不同的上下文中重用参数。在处理音视频编解码器参数时，通常会使用这个函数来复制参数结构体，以确保在不同的操作中使用相同的参数设置。</p>
<h2 id="ffmpeg-avio-open-函数-详解"><a href="#ffmpeg-avio-open-函数-详解" class="headerlink" title="ffmpeg avio_open() 函数  详解"></a>ffmpeg avio_open() 函数  详解</h2><p><code>avio_open()</code> 函数是 FFmpeg 中用于打开媒体文件或者流的函数。它用于初始化 AVIOContext 结构体，以便后续可以通过该上下文读取或者写入媒体数据。</p>
<p>以下是对 <code>avio_open()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avio_open()</code> 函数的主要目的是打开媒体文件或者流，并为后续的读取或写入操作创建一个 AVIOContext 结构体。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVIOContext **s</code>：指向指针的指针，用于存储创建的 AVIOContext 结构体。</li>
<li><code>const char *url</code>：媒体文件的 URL 或者文件名。</li>
<li><code>int flags</code>：打开文件的标志位，可以指定为 <code>AVIO_FLAG_READ</code>（只读）、<code>AVIO_FLAG_WRITE</code>（只写）、<code>AVIO_FLAG_READ_WRITE</code>（读写）等。</li>
<li><code>const AVIOInterruptCB *int_cb</code>：中断回调函数，用于处理中断事件。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avio_open()</code> 函数会根据指定的 URL 或者文件名打开对应的媒体文件或者流，并为其创建一个 AVIOContext 结构体。</li>
<li>AVIOContext 结构体是用于媒体数据的输入输出上下文，它提供了读取或者写入媒体数据的接口。</li>
<li>可以通过 flags 参数指定打开文件的模式，例如只读、只写或者读写模式。</li>
<li>可以通过 int_cb 参数设置中断回调函数，用于处理中断事件。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avio_open()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVIOContext *avio_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开媒体文件</span></span><br><span class="line">    <span class="type">int</span> ret = avio_open(&amp;avio_ctx, <span class="string">&quot;input.mp4&quot;</span>, AVIO_FLAG_READ);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open input file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续操作，例如读取媒体数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭媒体文件</span></span><br><span class="line">    avio_close(avio_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avio_open()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avio_open()</code> 函数用于打开媒体文件或者流，并为后续的读取或写入操作创建一个 AVIOContext 结构体。在处理媒体文件时，通常会使用这个函数来打开文件，并通过 AVIOContext 结构体读取或者写入媒体数据。</p>
<h2 id="ffmpeg-avformat-write-header-函数-详解"><a href="#ffmpeg-avformat-write-header-函数-详解" class="headerlink" title="ffmpeg avformat_write_header() 函数  详解"></a>ffmpeg avformat_write_header() 函数  详解</h2><p><code>avformat_write_header()</code> 函数是 FFmpeg 中用于写入输出文件的头部信息的函数。在使用 FFmpeg 进行音视频编码和封装时，通常需要在开始写入数据之前调用该函数，以确保输出文件的头部信息正确设置。</p>
<p>以下是对 <code>avformat_write_header()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_write_header()</code> 函数的主要目的是将输出文件的头部信息写入到输出文件中。这个头部信息包括文件格式、流信息、编解码器信息等。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *s</code>：指向已经创建的输出格式上下文的指针。这个上下文包含了输出文件的各种信息。</li>
<li><code>const AVDictionary *options</code>：附加选项，用于设置输出文件的一些额外信息。通常可以传入 NULL。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_write_header()</code> 函数会根据输出格式上下文中的信息，将文件的头部信息写入到输出文件中。</li>
<li>头部信息包括文件格式的标识、流的编码器参数、文件的元数据等。这些信息对于后续的解码或者播放是非常重要的。</li>
<li>在调用该函数之前，需要确保已经通过其他函数设置了输出格式上下文中的各种参数，例如添加音视频流、设置编码器参数等。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_write_header()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出格式上下文，添加音视频流等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输出文件</span></span><br><span class="line">    <span class="type">int</span> ret = avio_open(&amp;formatContext-&gt;pb, <span class="string">&quot;output.mp4&quot;</span>, AVIO_FLAG_WRITE);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open output file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入文件头部信息</span></span><br><span class="line">    ret = avformat_write_header(formatContext, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error writing header\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续操作，例如写入音视频帧数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输出文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_write_header()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_write_header()</code> 函数用于将输出文件的头部信息写入到输出文件中。在使用 FFmpeg 进行音视频编码和封装时，通常会在开始写入数据之前调用该函数，以确保输出文件的头部信息正确设置。</p>
<h2 id="ffmpeg-av-gettime-函数-详解"><a href="#ffmpeg-av-gettime-函数-详解" class="headerlink" title="ffmpeg av_gettime() 函数  详解"></a>ffmpeg av_gettime() 函数  详解</h2><p><code>av_gettime()</code> 是 FFmpeg 中用于获取当前时间的函数。它返回以微秒为单位的当前系统时间，可以用于测量时间间隔、计算程序执行时间等。</p>
<p>以下是对 <code>av_gettime()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_gettime()</code> 函数的主要目的是获取当前系统时间，以微秒为单位。它通常用于测量时间间隔、计算程序执行时间等。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li>该函数没有参数。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_gettime()</code> 函数返回当前系统时间，以微秒为单位。它返回的是自某个固定时间点以来的纳秒数。</li>
<li>时间点的起始值并不重要，只要能够正确计算时间间隔即可。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为 <code>int64_t</code> 类型，表示以微秒为单位的当前系统时间。如果系统支持高精度时钟，可能会返回更高精度的时间。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_gettime()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> start_time, end_time, elapsed_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取开始时间</span></span><br><span class="line">    start_time = av_gettime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些操作，例如编解码、处理数据等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结束时间</span></span><br><span class="line">    end_time = av_gettime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算时间间隔</span></span><br><span class="line">    elapsed_time = end_time - start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印时间间隔（以微秒为单位）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Elapsed time: %&quot;</span>PRId64<span class="string">&quot; microseconds\n&quot;</span>, elapsed_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_gettime()</code> 函数依赖于 FFmpeg 的 libavutil 库，该库提供了一些常用的工具函数。因此，在使用这个函数之前，需要确保正确链接了 libavutil 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_gettime()</code> 函数用于获取当前系统时间，以微秒为单位。它可以用于测量时间间隔、计算程序执行时间等。在处理音视频数据时，通常会使用这个函数来评估处理操作的性能或者控制处理速度。</p>
<h2 id="ffmpeg-av-read-frame-函数-详解"><a href="#ffmpeg-av-read-frame-函数-详解" class="headerlink" title="ffmpeg av_read_frame() 函数  详解"></a>ffmpeg av_read_frame() 函数  详解</h2><p><code>av_read_frame()</code> 函数是 FFmpeg 中用于从输入文件中读取音视频帧数据的函数。它从已打开的输入格式上下文中读取下一帧数据，并存储在 AVPacket 结构体中。</p>
<p>以下是对 <code>av_read_frame()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_read_frame()</code> 函数的主要目的是从已打开的输入文件中读取下一帧音视频数据，并将其存储在 AVPacket 结构体中。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *s</code>：指向已经打开的输入格式上下文的指针。这个上下文包含了输入文件的各种信息。</li>
<li><code>AVPacket *pkt</code>：指向 AVPacket 结构体的指针，用于存储读取到的音视频帧数据。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_read_frame()</code> 函数会从输入文件中读取下一帧音视频数据，并将其存储在 AVPacket 结构体中。</li>
<li>输入文件中的音视频数据通常被封装为一系列的帧，每个帧都包含了一定时间范围内的音视频数据。</li>
<li>函数会自动选择合适的流，并从这些流中读取下一帧数据。如果某个流中没有数据可读，函数将会等待直到有数据可读。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果成功读取了一帧数据，则返回0；如果出现错误或者到达文件尾部，则返回负值。一般来说，返回值小于0时表示读取出错或者已到达文件结尾。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_read_frame()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket packet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入文件</span></span><br><span class="line">    <span class="type">int</span> ret = avformat_open_input(&amp;formatContext, <span class="string">&quot;input.mp4&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open input file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取帧数据</span></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(formatContext, &amp;packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理音视频帧数据，例如解码、处理等</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放帧数据</span></span><br><span class="line">        av_packet_unref(&amp;packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输入文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_read_frame()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_read_frame()</code> 函数用于从输入文件中读取音视频帧数据，并将其存储在 AVPacket 结构体中。在处理音视频文件时，通常会使用这个函数来读取文件中的音视频数据，以便后续进行解码、处理或者播放操作。</p>
<h2 id="ffmpeg-av-packet-rescale-ts-函数-详解"><a href="#ffmpeg-av-packet-rescale-ts-函数-详解" class="headerlink" title="ffmpeg av_packet_rescale_ts() 函数  详解"></a>ffmpeg av_packet_rescale_ts() 函数  详解</h2><p><code>av_packet_rescale_ts()</code> 函数是 FFmpeg 中用于重新调整 AVPacket 中时间戳（timestamp）的函数。它可以将 AVPacket 中的时间戳从一种时间基准（time base）转换到另一种时间基准，通常用于音视频流处理中的时间戳转换操作。</p>
<p>以下是对 <code>av_packet_rescale_ts()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_packet_rescale_ts()</code> 函数的主要目的是重新调整 AVPacket 中的时间戳（timestamp），将其从一个时间基准转换到另一个时间基准。这个函数通常用于音视频流处理中，用于处理不同时间基准下的音视频帧数据。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>const AVPacket *pkt</code>：指向待处理的 AVPacket 结构体的指针，其中包含了要重新调整时间戳的音视频帧数据。</li>
<li><code>AVRational tb_src</code>：源时间基准，即 AVPacket 中时间戳的原始时间基准。</li>
<li><code>AVRational tb_dst</code>：目标时间基准，即要转换成的时间基准。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_packet_rescale_ts()</code> 函数会根据源时间基准和目标时间基准，重新调整 AVPacket 中的时间戳。</li>
<li>它将会对 AVPacket 中的时间戳进行数学运算，将其转换成目标时间基准下的对应值。</li>
<li>时间戳的时间基准通常用 AVRational 结构体表示，其中包含了分子和分母，用于表示时间单位的比率。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_packet_rescale_ts()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVPacket packet;</span><br><span class="line">    AVRational tb_src, tb_dst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设已经初始化 packet 和设置了源时间基准 tb_src、目标时间基准 tb_dst</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新调整时间戳</span></span><br><span class="line">    av_packet_rescale_ts(&amp;packet, tb_src, tb_dst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续操作，例如处理 packet 中的音视频帧数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_packet_rescale_ts()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_packet_rescale_ts()</code> 函数用于重新调整 AVPacket 中的时间戳，将其从一个时间基准转换到另一个时间基准。在处理音视频流时，通常会使用这个函数来处理不同时间基准下的音视频帧数据，以确保时间戳的一致性和正确性。</p>
<h2 id="ffmpeg-av-interleaved-write-frame-函数-详解"><a href="#ffmpeg-av-interleaved-write-frame-函数-详解" class="headerlink" title="ffmpeg av_interleaved_write_frame() 函数  详解"></a>ffmpeg av_interleaved_write_frame() 函数  详解</h2><p><code>av_interleaved_write_frame()</code> 函数是 FFmpeg 中用于将音视频帧数据写入到输出文件的函数。它将音视频帧数据写入到输出文件，保证音频和视频数据交错存储，符合特定的封装格式要求。</p>
<p>以下是对 <code>av_interleaved_write_frame()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_interleaved_write_frame()</code> 函数的主要目的是将音视频帧数据写入到输出文件，并保证音频和视频数据交错存储，符合特定的封装格式要求。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *s</code>：指向已经创建的输出格式上下文的指针。这个上下文包含了输出文件的各种信息。</li>
<li><code>AVPacket *pkt</code>：指向 AVPacket 结构体的指针，其中包含了要写入到输出文件的音视频帧数据。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_interleaved_write_frame()</code> 函数会将音视频帧数据写入到输出文件。</li>
<li>在写入到输出文件时，它会保证音频和视频数据交错存储，符合特定的封装格式要求。不同的封装格式对音频和视频的存储方式有不同的要求，这个函数会自动处理这些细节。</li>
<li>该函数通常在调用了 <code>avformat_write_header()</code> 函数后，循环调用，将所有音视频帧数据写入到输出文件，直到所有数据都被写入完成，然后再调用 <code>av_write_trailer()</code> 函数完成文件尾部的写入。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果成功写入了音视频帧数据，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_interleaved_write_frame()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket packet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输出文件、写入头部信息等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环写入音视频帧数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="comment">/* 有音视频帧数据需要写入 */</span>) &#123;</span><br><span class="line">        <span class="comment">// 将音视频帧数据写入到 AVPacket 结构体 packet 中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入音视频帧数据到输出文件</span></span><br><span class="line">        <span class="type">int</span> ret = av_interleaved_write_frame(formatContext, &amp;packet);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error writing frame\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入文件尾部信息</span></span><br><span class="line">    av_write_trailer(formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输出文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_interleaved_write_frame()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_interleaved_write_frame()</code> 函数用于将音视频帧数据写入到输出文件，并保证音频和视频数据交错存储，符合特定的封装格式要求。在编码和封装音视频文件时，通常会使用这个函数将所有音视频帧数据写入到输出文件中。</p>
<h2 id="ffmpeg-av-packet-unref-函数-详解"><a href="#ffmpeg-av-packet-unref-函数-详解" class="headerlink" title="ffmpeg av_packet_unref() 函数  详解"></a>ffmpeg av_packet_unref() 函数  详解</h2><p><code>av_packet_unref()</code> 函数是 FFmpeg 中用于释放 AVPacket 结构体的函数。它将 AVPacket 结构体中的数据引用计数减一，并在计数归零时释放结构体所占用的内存空间。</p>
<p>以下是对 <code>av_packet_unref()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_packet_unref()</code> 函数的主要目的是释放 AVPacket 结构体所占用的内存空间，以便重用或释放该结构体。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVPacket *pkt</code>：指向要释放的 AVPacket 结构体的指针。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_packet_unref()</code> 函数会将 AVPacket 结构体中的数据引用计数减一。</li>
<li>当引用计数归零时，函数会释放 AVPacket 结构体所占用的内存空间。</li>
<li>这个函数通常在不再需要使用 AVPacket 结构体时调用，以确保释放内存空间，避免内存泄漏。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>该函数没有返回值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_packet_unref()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVPacket packet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 packet，例如分配内存、设置数据等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 packet 处理音视频帧数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完成后释放 packet</span></span><br><span class="line">    av_packet_unref(&amp;packet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_packet_unref()</code> 函数依赖于 FFmpeg 的 libavcodec 库，该库负责处理音视频编解码相关的操作。因此，在使用这个函数之前，需要确保正确链接了 libavcodec 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_packet_unref()</code> 函数用于释放 AVPacket 结构体所占用的内存空间。在处理音视频帧数据时，通常会使用这个函数在不再需要使用 AVPacket 结构体时释放其内存空间，以避免内存泄漏。</p>
<h2 id="ffmpeg-av-write-trailer-函数-详解"><a href="#ffmpeg-av-write-trailer-函数-详解" class="headerlink" title="ffmpeg av_write_trailer() 函数  详解"></a>ffmpeg av_write_trailer() 函数  详解</h2><p><code>av_write_trailer()</code> 函数是 FFmpeg 中用于写入封装格式的文件尾部信息的函数。在音视频文件封装过程中，通常会在所有音视频帧数据写入完成后调用该函数，以完成文件的封装过程。</p>
<p>以下是对 <code>av_write_trailer()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_write_trailer()</code> 函数的主要目的是完成封装格式的文件尾部信息的写入。这个函数在音视频文件封装过程中是必不可少的一步，它确保文件的封装过程完成。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *s</code>：指向已经创建的输出格式上下文的指针。这个上下文包含了输出文件的各种信息。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_write_trailer()</code> 函数会在所有音视频帧数据写入完成后，写入封装格式的文件尾部信息。</li>
<li>在文件尾部信息中，通常包含了一些与文件格式相关的元数据，例如索引信息、文件格式标识、流结尾标识等。</li>
<li>调用该函数后，输出文件将被关闭，不再允许写入操作。因此，该函数通常是封装过程的最后一步。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_write_trailer()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输出文件、写入头部信息等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入音视频帧数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入文件尾部信息</span></span><br><span class="line">    <span class="type">int</span> ret = av_write_trailer(formatContext);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error writing trailer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输出文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_write_trailer()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_write_trailer()</code> 函数用于写入封装格式的文件尾部信息，以完成音视频文件的封装过程。在处理音视频文件时，通常会在所有音视频帧数据写入完成后调用该函数，以确保文件的完整性和正确性。</p>
<h2 id="ffmpeg-avformat-close-input-函数-详解"><a href="#ffmpeg-avformat-close-input-函数-详解" class="headerlink" title="ffmpeg avformat_close_input() 函数  详解"></a>ffmpeg avformat_close_input() 函数  详解</h2><p><code>avformat_close_input()</code> 函数是 FFmpeg 中用于关闭已打开的输入文件的函数。它释放与输入文件相关的资源，并关闭输入文件。</p>
<p>以下是对 <code>avformat_close_input()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_close_input()</code> 函数的主要目的是关闭已打开的输入文件，并释放与输入文件相关的资源。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext **ps</code>：指向已经打开的输入格式上下文的指针的指针。在函数调用完成后，指针会被设置为 NULL。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_close_input()</code> 函数会释放与输入文件相关的资源，并关闭输入文件。</li>
<li>这个函数通常在不再需要读取输入文件时调用，以确保释放输入文件占用的资源，避免资源泄漏。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回值为整数类型，表示操作的结果。如果操作成功，则返回0；如果出现错误，则返回负值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_close_input()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入文件</span></span><br><span class="line">    <span class="type">int</span> ret = avformat_open_input(&amp;formatContext, <span class="string">&quot;input.mp4&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open input file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取音视频帧数据等操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输入文件</span></span><br><span class="line">    avformat_close_input(&amp;formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_close_input()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_close_input()</code> 函数用于关闭已打开的输入文件，并释放与输入文件相关的资源。在读取完毕输入文件并不再需要时，通常会使用这个函数关闭输入文件，以避免资源泄漏。</p>
<h2 id="ffmpeg-avio-closep-函数-详解"><a href="#ffmpeg-avio-closep-函数-详解" class="headerlink" title="ffmpeg avio_closep() 函数  详解"></a>ffmpeg avio_closep() 函数  详解</h2><p><code>avio_closep()</code> 函数是 FFmpeg 中用于关闭通过 <code>avio_open()</code> 函数打开的输入&#x2F;输出上下文的函数。它会关闭并释放相应的资源，以确保资源被正确释放，避免资源泄漏。</p>
<p>以下是对 <code>avio_closep()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avio_closep()</code> 函数的主要目的是关闭通过 <code>avio_open()</code> 函数打开的输入&#x2F;输出上下文，并释放相应的资源。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVIOContext **s</code>：指向指针的指针，用于存储输入&#x2F;输出上下文的地址。这个指针在函数调用后将被置为 NULL。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avio_closep()</code> 函数会关闭通过 <code>avio_open()</code> 函数打开的输入&#x2F;输出上下文。</li>
<li>在关闭输入&#x2F;输出上下文之前，函数会确保已经将缓冲区中的数据刷新到文件中，以确保数据的完整性。</li>
<li>关闭输入&#x2F;输出上下文后，函数会释放相应的资源，包括关闭文件描述符、释放内存等。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>该函数没有返回值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avio_closep()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVIOContext *avio_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入/输出文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输入/输出文件</span></span><br><span class="line">    avio_closep(&amp;avio_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avio_closep()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avio_closep()</code> 函数用于关闭通过 <code>avio_open()</code> 函数打开的输入&#x2F;输出上下文，并释放相应的资源。在使用 FFmpeg 处理音视频文件时，通常会使用这个函数在不再需要使用输入&#x2F;输出上下文时关闭并释放相关资源，以确保资源被正确释放，避免资源泄漏。</p>
<h2 id="ffmpeg-avformat-free-context-函数-详解"><a href="#ffmpeg-avformat-free-context-函数-详解" class="headerlink" title="ffmpeg avformat_free_context() 函数  详解"></a>ffmpeg avformat_free_context() 函数  详解</h2><p><code>avformat_free_context()</code> 函数是 FFmpeg 中用于释放 AVFormatContext 结构体及其内部资源的函数。它用于释放由 <code>avformat_alloc_context()</code> 函数分配的 AVFormatContext 结构体，以及该结构体内部所包含的流信息、封装器上下文等资源。</p>
<p>以下是对 <code>avformat_free_context()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>avformat_free_context()</code> 函数的主要目的是释放 AVFormatContext 结构体及其内部资源，以确保内存被正确释放，避免内存泄漏。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVFormatContext *s</code>：指向要释放的 AVFormatContext 结构体的指针。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>avformat_free_context()</code> 函数会释放由 <code>avformat_alloc_context()</code> 函数分配的 AVFormatContext 结构体及其内部资源。</li>
<li>在释放 AVFormatContext 结构体之前，函数会先释放该结构体内部包含的流信息、封装器上下文等资源。</li>
<li>调用这个函数后，AVFormatContext 结构体及其内部资源将不再可用，应该避免在之后的代码中再次使用它们。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>该函数没有返回值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>avformat_free_context()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVFormatContext *formatContext = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 formatContext 处理音视频文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 AVFormatContext 结构体及其内部资源</span></span><br><span class="line">    avformat_free_context(formatContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>avformat_free_context()</code> 函数依赖于 FFmpeg 的 libavformat 库，该库负责处理各种音视频格式的输入输出。因此，在使用这个函数之前，需要确保正确链接了 libavformat 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>avformat_free_context()</code> 函数用于释放 AVFormatContext 结构体及其内部资源，以确保内存被正确释放，避免内存泄漏。在处理音视频文件时，通常会使用这个函数在不再需要使用 AVFormatContext 结构体时释放相关资源。</p>
<h2 id="ffmpeg-av-dict-free-函数-详解"><a href="#ffmpeg-av-dict-free-函数-详解" class="headerlink" title="ffmpeg av_dict_free() 函数  详解"></a>ffmpeg av_dict_free() 函数  详解</h2><p><code>av_dict_free()</code> 函数是 FFmpeg 中用于释放 AVDictionary 结构体及其内部资源的函数。AVDictionary 结构体用于存储键值对数据，通常用于传递元数据、选项参数等。</p>
<p>以下是对 <code>av_dict_free()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>目的</strong>：</p>
<ul>
<li><code>av_dict_free()</code> 函数的主要目的是释放 AVDictionary 结构体及其内部资源，以确保内存被正确释放，避免内存泄漏。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>AVDictionary **m</code>：指向要释放的 AVDictionary 结构体的指针。这个指针在函数调用后将被置为 NULL。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>av_dict_free()</code> 函数会释放由 FFmpeg 分配的 AVDictionary 结构体及其内部资源。</li>
<li>在释放 AVDictionary 结构体之前，函数会先释放该结构体内部包含的键值对数据。</li>
<li>调用这个函数后，AVDictionary 结构体及其内部资源将不再可用，应该避免在之后的代码中再次使用它们。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>该函数没有返回值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>以下是一个简单示例，演示了在 C&#x2F;C++ 程序中使用 <code>av_dict_free()</code> 函数的用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/dict.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVDictionary *dict = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向字典中添加键值对数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 AVDictionary 结构体及其内部资源</span></span><br><span class="line">    av_dict_free(&amp;dict);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖性</strong>：</p>
<ul>
<li><code>av_dict_free()</code> 函数依赖于 FFmpeg 的 libavutil 库，该库提供了一些常用的工具函数。因此，在使用这个函数之前，需要确保正确链接了 libavutil 库。</li>
</ul>
</li>
</ol>
<p>总之，<code>av_dict_free()</code> 函数用于释放 AVDictionary 结构体及其内部资源，以确保内存被正确释放，避免内存泄漏。在处理音视频文件时，通常会使用这个函数在不再需要使用 AVDictionary 结构体时释放相关资源。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_05_pkg_config/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_05_pkg_config/" class="post-title-link" itemprop="url">linux_2_05_pkg_config</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>pkg-config 工具的笔记</li>
</ul>
<h2 id="linux-pkg-config-是什么"><a href="#linux-pkg-config-是什么" class="headerlink" title="linux pkg-config 是什么"></a>linux pkg-config 是什么</h2><p><code>pkg-config</code> 是一个用于帮助管理软件包依赖关系的工具，特别是在 Linux 系统上。它允许开发者查询已安装的库的信息，以便在编译和链接时正确地设置相关的编译器和链接器选项。</p>
<p>具体而言，<code>pkg-config</code> 主要有以下功能：</p>
<ol>
<li><p><strong>查询已安装库的信息：</strong> 开发者可以使用 <code>pkg-config</code> 查询已安装的库的版本、包含路径、链接标志等信息。</p>
</li>
<li><p><strong>提供正确的编译和链接选项：</strong> 在编译和链接程序时，<code>pkg-config</code> 可以生成正确的编译器和链接器选项，确保程序正确地链接到所需的库。</p>
</li>
<li><p><strong>简化构建过程：</strong> 使用 <code>pkg-config</code> 可以使构建过程更加简化和可移植。开发者可以通过查询库的信息来适应不同的系统和环境。</p>
</li>
</ol>
<p>例如，如果你想编写一个使用 GTK+ 图形库的程序，你可以使用 <code>pkg-config</code> 查询 GTK+ 库的信息，并在编译和链接时使用返回的选项，而不必手动设置这些选项。</p>
<p>以下是 <code>pkg-config</code> 命令的一些基本用法：</p>
<ul>
<li><code>pkg-config --list-all</code>: 列出系统上所有已安装的库和它们的信息。</li>
<li><code>pkg-config --cflags &lt;package&gt;</code>: 返回指定库的编译选项。</li>
<li><code>pkg-config --libs &lt;package&gt;</code>: 返回指定库的链接选项。</li>
</ul>
<p>例如，要获取 GTK+ 库的编译选项，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags gtk+-3.0</span><br></pre></td></tr></table></figure>

<p><code>pkg-config</code> 在许多 Linux 发行版中都是默认安装的，因此大多数开发者可以直接使用它来简化软件构建过程。</p>
<h2 id="pkg-config-详解"><a href="#pkg-config-详解" class="headerlink" title="pkg-config 详解"></a>pkg-config 详解</h2><p><code>pkg-config</code> 是一个在 Linux 和类 Unix 系统中用于获取编译和链接库信息的工具。它可以帮助开发者配置和编译软件项目，以便正确地链接所需的外部库和头文件。以下是关于 <code>pkg-config</code> 的详细解释：</p>
<p><strong>基本用法：</strong><br><code>pkg-config</code> 的基本用法是通过在命令行中调用它，并传递一些选项和参数来获取有关库的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config [options] package-names</span><br></pre></td></tr></table></figure>

<ul>
<li><code>options</code>：一些选项，用于控制 <code>pkg-config</code> 的行为。</li>
<li><code>package-names</code>：要查询的库的名称。它通常是你希望查找的库的名称，如 <code>opencv</code>, <code>gtk+-3.0</code> 等。</li>
</ul>
<p><strong>常用选项：</strong></p>
<ul>
<li><code>--cflags</code>：获取用于编译的头文件路径和编译器选项。</li>
<li><code>--libs</code>：获取用于链接的库路径和链接器选项。</li>
<li><code>--modversion</code>：获取库的版本号。</li>
<li><code>--list-all</code>：列出系统中所有已安装的库及其版本。</li>
</ul>
<p><strong>示例用法：</strong><br>以下是一个使用 <code>pkg-config</code> 的示例，假设你想编译一个使用 GTK+ 3 的简单程序：</p>
<ol>
<li>查询 GTK+ 3 的编译选项（头文件路径和编译器选项）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags gtk+-3.0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询 GTK+ 3 的链接选项（库路径和链接器选项）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --libs gtk+-3.0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编译程序（假设程序名为 <code>myapp</code>）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc myapp.c -o myapp `pkg-config --cflags --libs gtk+-3.0`</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><code>pkg-config</code> 确保了在编译和链接软件时，所需的库路径、头文件路径以及编译和链接选项都是正确的，减少了因为路径错误或选项不匹配而导致的问题。</li>
<li>它是一个跨平台的工具，在多个 Linux 发行版和类 Unix 系统中都可使用。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>要使用 <code>pkg-config</code>，你需要安装相关的库及其开发包（通常是以 <code>-dev</code> 或 <code>-devel</code> 结尾的包）。</li>
<li>一些库可能不支持 <code>pkg-config</code>，或者可能有不同的名称和用法，需要查阅它们的文档。</li>
</ul>
<p>总之，<code>pkg-config</code> 是一个有助于简化库配置和编译过程的工具，它可以提供关于库的编译和链接信息，减少了配置和构建软件项目的复杂性。</p>
<h2 id="pkg-config-常用选项"><a href="#pkg-config-常用选项" class="headerlink" title="pkg-config 常用选项"></a>pkg-config 常用选项</h2><p><code>pkg-config</code> 工具提供了一些常用选项，用于获取有关库的信息，例如头文件路径、库路径和版本等。以下是一些常用的 <code>pkg-config</code> 选项：</p>
<ol>
<li><code>--cflags</code>：用于获取用于编译的头文件路径和编译器选项。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags package-name</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags gtk+-3.0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>--libs</code>：用于获取用于链接的库路径和链接器选项。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --libs package-name</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --libs gtk+-3.0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>--modversion</code>：获取库的版本号。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion package-name</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion opencv</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>--list-all</code>：列出系统中所有已安装的库及其版本。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --list-all</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>--static</code>：获取静态库的链接选项。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --static package-name</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --static zlib</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>--variable</code>：获取特定变量的值，如 <code>pkg-config --variable=prefix package-name</code> 可以获取库的安装路径。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --variable=variable-name package-name</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --variable=prefix opencv</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>--exists</code>：检查库是否存在。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --exists package-name</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --exists libpng</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><code>--help</code>：获取关于 <code>pkg-config</code> 命令的帮助信息。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>这些选项可以根据你的需要来使用，它们可以帮助你获取关于特定库的编译和链接信息，以便在开发过程中正确地配置和编译你的项目。</p>
<h2 id="pkg-config-查看所有库"><a href="#pkg-config-查看所有库" class="headerlink" title="pkg-config 查看所有库"></a>pkg-config 查看所有库</h2><p>要查看系统中安装的所有库及其版本，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --list-all</span><br></pre></td></tr></table></figure>

<p>运行这个命令会列出系统中已安装的所有库的名称和版本信息。输出可能会非常长，所以你可以将输出通过分页工具如 <code>less</code> 进行分页显示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --list-all | less</span><br></pre></td></tr></table></figure>

<p>使用上述命令，你可以查看系统中已经安装的所有库，以便在开发软件项目时了解可用的库资源。</p>
<h2 id="linux-pkg-config-查看指定目录的配置文件"><a href="#linux-pkg-config-查看指定目录的配置文件" class="headerlink" title="linux pkg-config 查看指定目录的配置文件"></a>linux pkg-config 查看指定目录的配置文件</h2><p>要使用<code>pkg-config</code>命令查看指定目录的配置文件，你可以通过设置<code>PKG_CONFIG_PATH</code>环境变量来指定<code>pkg-config</code>应该搜索的目录。然后，你可以使用<code>pkg-config</code>命令来查询指定库的配置信息。</p>
<p>以下是一些步骤：</p>
<ol>
<li>设置<code>PKG_CONFIG_PATH</code>环境变量以包含你希望<code>pkg-config</code>搜索的目录。假设你希望<code>pkg-config</code>在<code>/path/to/your/dir</code>目录中搜索配置文件，你可以执行以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=/path/to/your/dir:<span class="variable">$PKG_CONFIG_PATH</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>pkg-config</code>命令查询指定库的配置信息。例如，如果你想查询<code>libfoo</code>库的配置信息，你可以执行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion libfoo</span><br></pre></td></tr></table></figure>

<p>或者，如果你想获取更多有关该库的信息，你可以执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --libs --cflags libfoo</span><br></pre></td></tr></table></figure>

<p>这将显示用于编译和链接应用程序的选项。</p>
<p>请注意，设置<code>PKG_CONFIG_PATH</code>只是临时的，仅在当前终端会话中有效。如果你希望在每次登录时都设置这个环境变量，你可以将其添加到你的shell配置文件（例如<code>~/.bashrc</code>或<code>~/.bash_profile</code>）中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_01_readme/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_01_readme/" class="post-title-link" itemprop="url">linux_2_01_readme</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>linux常用命令模块</li>
</ul>
<h2 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h2><ul>
<li><p>other</p>
<ul>
<li>linux_2_02_other</li>
</ul>
</li>
<li><p>pkg_config</p>
<ul>
<li>linux_2_05_pkg_config</li>
</ul>
</li>
<li><p>open_ssh</p>
<ul>
<li>linux_2_06_open_ssh</li>
</ul>
</li>
<li><p>objdump</p>
<ul>
<li>linux_2_07_objdump</li>
</ul>
</li>
<li><p>head</p>
<ul>
<li>linux_2_08_head</li>
</ul>
</li>
<li><p>vim</p>
<ul>
<li>linux_2_09_vim</li>
</ul>
</li>
<li><p>tmux</p>
<ul>
<li>linux_2_10_tmux</li>
</ul>
</li>
<li><p>apt</p>
<ul>
<li>linux_2_11_apt</li>
</ul>
</li>
<li><p>dpkg</p>
<ul>
<li>linux_2_12_dpkg</li>
</ul>
</li>
<li><p>free</p>
<ul>
<li>linux_2_13_free</li>
</ul>
</li>
<li><p>trap</p>
<ul>
<li>linux_2_14_trap</li>
</ul>
</li>
<li><p>read</p>
<ul>
<li>linux_2_15_read</li>
</ul>
</li>
<li><p>more</p>
<ul>
<li>linux_2_16_more</li>
</ul>
</li>
<li><p>less</p>
<ul>
<li>linux_2_17_less</li>
</ul>
</li>
<li><p>nohup</p>
<ul>
<li>linux_2_18_nohup</li>
</ul>
</li>
<li><p>split</p>
<ul>
<li>linux_2_19_split</li>
</ul>
</li>
<li><p>mktemp</p>
<ul>
<li>linux_2_20_mktemp</li>
</ul>
</li>
<li><p>wc</p>
<ul>
<li>linux_2_21_wc</li>
</ul>
</li>
<li><p>ar</p>
<ul>
<li>linux_2_22_ar</li>
</ul>
</li>
<li><p>lsmod</p>
<ul>
<li>linux_2_23_lsmod</li>
</ul>
</li>
<li><p>screen</p>
<ul>
<li>linux_2_24_screen</li>
</ul>
</li>
<li><p>source</p>
<ul>
<li>linux_2_25_source</li>
</ul>
</li>
<li><p>tar</p>
<ul>
<li>linux_2_26_tar</li>
</ul>
</li>
<li><p>df</p>
<ul>
<li>linux_2_27_df</li>
</ul>
</li>
<li><p>useradd</p>
<ul>
<li>linux_2_28_useradd</li>
</ul>
</li>
<li><p>userdel</p>
<ul>
<li>linux_2_29_userdel</li>
</ul>
</li>
<li><p>usermod</p>
<ul>
<li>linux_2_30_usermod</li>
</ul>
</li>
<li><p>grep</p>
<ul>
<li>linux_2_31_grep</li>
</ul>
</li>
<li><p>eval</p>
<ul>
<li>linux_2_32_eval</li>
</ul>
</li>
<li><p>mount</p>
<ul>
<li>linux_2_33_mount</li>
</ul>
</li>
<li><p>export</p>
<ul>
<li>linux_2_34_export</li>
</ul>
</li>
<li><p>awk</p>
<ul>
<li>linux_2_35_awk</li>
</ul>
</li>
<li><p>sed</p>
<ul>
<li>linux_2_36_sed</li>
</ul>
</li>
<li><p>whereis</p>
<ul>
<li>linux_2_37_whereis</li>
</ul>
</li>
<li><p>chown</p>
<ul>
<li>linux_2_38_chown</li>
</ul>
</li>
<li><p>which</p>
<ul>
<li>linux_2_39_which</li>
</ul>
</li>
<li><p>file</p>
<ul>
<li>linux_2_40_file</li>
</ul>
</li>
<li><p>stat</p>
<ul>
<li>linux_2_41_stat</li>
</ul>
</li>
<li><p>realpath</p>
<ul>
<li>linux_2_42_realpath</li>
</ul>
</li>
<li><p>diff</p>
<ul>
<li>linux_2_43_diff</li>
</ul>
</li>
<li><p>patch</p>
<ul>
<li>linux_2_44_patch</li>
</ul>
</li>
<li><p>expr</p>
<ul>
<li>linux_2_45_expr</li>
</ul>
</li>
<li><p>dstat</p>
<ul>
<li>linux_2_46_dstat</li>
</ul>
</li>
<li><p>tail</p>
<ul>
<li>linux_2_47_tail</li>
</ul>
</li>
<li><p>ip</p>
<ul>
<li>linux_2_48_ip</li>
</ul>
</li>
<li><p>systemctl</p>
<ul>
<li>linux_2_49_systemctl</li>
</ul>
</li>
<li><p>loginctl</p>
<ul>
<li>linux_2_50_loginctl</li>
</ul>
</li>
<li><p>lspci</p>
<ul>
<li>linux_2_51_lspci</li>
</ul>
</li>
<li><p>lsmod</p>
<ul>
<li>linux_2_52_lsmod</li>
</ul>
</li>
<li><p>gperf</p>
<ul>
<li>linux_2_53_gperf</li>
</ul>
</li>
<li><p>mkdir</p>
<ul>
<li>linux_2_54_mkdir</li>
</ul>
</li>
<li><p>rename</p>
<ul>
<li>linux_2_55_rename</li>
</ul>
</li>
<li><p>find</p>
<ul>
<li>linux_2_56_find</li>
</ul>
</li>
<li><p>init</p>
<ul>
<li>linux_2_57_init</li>
</ul>
</li>
<li><p>md5sum</p>
<ul>
<li>linux_2_58_md5sum</li>
</ul>
</li>
<li><p>readelf</p>
<ul>
<li>linux_2_59_readelf</li>
</ul>
</li>
<li><p>ldd</p>
<ul>
<li>linux_2_60_ldd</li>
</ul>
</li>
<li><p>watch</p>
<ul>
<li>linux_2_61_watch</li>
</ul>
</li>
<li><p>unset</p>
<ul>
<li>linux_2_62_unset</li>
</ul>
</li>
<li><p>ln</p>
<ul>
<li>linux_2_63_ln</li>
</ul>
</li>
<li><p>snap</p>
<ul>
<li>linux_2_64_snap</li>
</ul>
</li>
<li><p>iostat</p>
<ul>
<li>linux_2_65_iostat</li>
</ul>
</li>
<li><p>dmesg</p>
<ul>
<li>linux_2_66_dmesg</li>
</ul>
</li>
<li><p>pgrep</p>
<ul>
<li>linux_2_67_pgrep</li>
</ul>
</li>
<li><p>ps</p>
<ul>
<li>linux_2_68_ps</li>
</ul>
</li>
<li><p>top</p>
<ul>
<li>linux_2_69_top</li>
</ul>
</li>
<li><p>ss</p>
<ul>
<li>linux_2_70_ss</li>
</ul>
</li>
<li><p>date</p>
<ul>
<li>linux_2_71_date</li>
</ul>
</li>
<li><p>egrep</p>
<ul>
<li>linux_2_72_egrep</li>
</ul>
</li>
<li><p>nc</p>
<ul>
<li>linux_2_73_nc</li>
</ul>
</li>
<li><p>gprof</p>
<ul>
<li>linux_2_74_gprof</li>
</ul>
</li>
<li><p>wget</p>
<ul>
<li>linux_2_75_wget</li>
</ul>
</li>
<li><p>uname</p>
<ul>
<li>linux_2_76_uname</li>
</ul>
</li>
<li><p>valgrind</p>
<ul>
<li>linux_2_77_valgrind</li>
</ul>
</li>
<li><p>gcore</p>
<ul>
<li>linux_2_78_gcore</li>
</ul>
</li>
<li><p>pidstat</p>
<ul>
<li>linux_2_79_pidstat</li>
</ul>
</li>
<li><p>sshpass</p>
<ul>
<li>linux_2_80_sshpass</li>
</ul>
</li>
<li><p>tcpdump</p>
<ul>
<li>linux_2_81_tcpdump</li>
</ul>
</li>
<li><p>alias</p>
<ul>
<li>linux_2_82_alia</li>
</ul>
</li>
<li><p>update-alternatives</p>
<ul>
<li>linux_2_83_update-alternatives</li>
</ul>
</li>
<li><p>blkid</p>
<ul>
<li>linux_2_84_blkid.md</li>
</ul>
</li>
<li><p>autoconf</p>
<ul>
<li>linux_2_85_autoconf.md</li>
</ul>
</li>
<li><p>automake</p>
<ul>
<li>linux_2_86_automake.md</li>
</ul>
</li>
<li><p>uptime</p>
<ul>
<li>linux_2_87_uptime.md</li>
</ul>
</li>
<li><p>mii</p>
<ul>
<li>linux_2_88_mii-tool.md</li>
</ul>
</li>
<li><p>crontab</p>
<ul>
<li>linux_2_89_crontab.md</li>
</ul>
</li>
<li><p>traceroute</p>
<ul>
<li>linux_2_90_traceroute.md</li>
</ul>
</li>
<li><p>route</p>
<ul>
<li>linux_2_91_route.md</li>
</ul>
</li>
<li><p>ifconfig</p>
<ul>
<li>linux_2_92_ifconfig.md</li>
</ul>
</li>
<li><p>nslookup</p>
<ul>
<li>linux_2_93_nslookup.md</li>
</ul>
</li>
<li><p>nmap</p>
<ul>
<li>linux_2_94_nmap.md</li>
</ul>
</li>
<li><p>p7zip</p>
<ul>
<li>linux_2_95_p7zip.md</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_07_objdump/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_07_objdump/" class="post-title-link" itemprop="url">linux_2_07_objdump</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>objdump命令相关笔记</li>
</ul>
<h2 id="linux-objdump命令-详解"><a href="#linux-objdump命令-详解" class="headerlink" title="linux objdump命令 详解"></a>linux objdump命令 详解</h2><p><code>objdump</code> 是一个用于显示目标文件（object file）信息的强大工具，它通常随着 GNU binutils 工具集一起提供。<code>objdump</code> 可以用于分析二进制文件、共享库、可执行文件等，提供了很多有用的信息，包括汇编代码、符号表、段信息等。以下是一些常见的用法和选项：</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法:"></a>基本用法:</h3><ol>
<li><p><strong>查看文件信息:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -f your_file</span><br></pre></td></tr></table></figure>
<p>显示文件头的基本信息，包括目标架构、文件大小、入口点等。</p>
</li>
<li><p><strong>查看节（section）信息:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -h your_file</span><br></pre></td></tr></table></figure>
<p>显示目标文件的各个节的详细信息，包括名称、大小、VMA（虚拟内存地址）、LMA（加载内存地址）、对齐等。</p>
</li>
</ol>
<h3 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码:"></a>汇编代码:</h3><ol>
<li><p><strong>显示全部汇编代码:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d your_file</span><br></pre></td></tr></table></figure>
<p>显示目标文件中的所有汇编代码。</p>
</li>
<li><p><strong>指定节进行汇编代码显示:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d -j .text your_file</span><br></pre></td></tr></table></figure>
<p>只显示指定节（这里是 <code>.text</code> 节）的汇编代码。</p>
</li>
<li><p><strong>以反汇编形式显示:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -D your_file</span><br></pre></td></tr></table></figure>
<p>以反汇编形式显示目标文件的所有代码。</p>
</li>
</ol>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表:"></a>符号表:</h3><ol>
<li><p><strong>显示符号表:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -t your_file</span><br></pre></td></tr></table></figure>
<p>显示目标文件的符号表，包括函数、变量等。</p>
</li>
<li><p><strong>显示动态符号表:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -T your_file</span><br></pre></td></tr></table></figure>
<p>显示目标文件的动态符号表。</p>
</li>
</ol>
<h3 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项:"></a>其他选项:</h3><ol>
<li><p><strong>显示重定位信息:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -r your_file</span><br></pre></td></tr></table></figure>
<p>显示目标文件的重定位信息。</p>
</li>
<li><p><strong>输出到文件:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d your_file &gt; output.asm</span><br></pre></td></tr></table></figure>
<p>将汇编代码输出到文件。</p>
</li>
</ol>
<p>这只是 <code>objdump</code> 的一些基本用法，该工具提供了更多选项，可以根据需要进行定制。可以通过 <code>man objdump</code> 命令查看 <code>objdump</code> 的手册页，获取更详细的信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_09_vim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_09_vim/" class="post-title-link" itemprop="url">linux_2_09_vim</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>vim命令 相关笔记</li>
</ul>
<h2 id="linux-vim命令-详解"><a href="#linux-vim命令-详解" class="headerlink" title="linux vim命令 详解"></a>linux vim命令 详解</h2><p>Vim是一款功能强大的文本编辑器，支持多种操作模式和丰富的命令。以下是一些常用的Vim命令的详解：</p>
<h3 id="1-基本移动命令（Normal-Mode）："><a href="#1-基本移动命令（Normal-Mode）：" class="headerlink" title="1. 基本移动命令（Normal Mode）："></a>1. <strong>基本移动命令（Normal Mode）：</strong></h3><ul>
<li><code>h</code>：向左移动一个字符。</li>
<li><code>j</code>：向下移动一行。</li>
<li><code>k</code>：向上移动一行。</li>
<li><code>l</code>：向右移动一个字符。</li>
<li><code>w</code>：跳到下一个单词的开头。</li>
<li><code>b</code>：跳到前一个单词的开头。</li>
<li><code>e</code>：跳到当前或下一个单词的末尾。</li>
<li><code>0</code>：跳到当前行的开头。</li>
<li><code>^</code>：跳到当前行的第一个非空字符。</li>
<li><code>$</code>：跳到当前行的末尾。</li>
</ul>
<h3 id="2-插入文本（Insert-Mode）："><a href="#2-插入文本（Insert-Mode）：" class="headerlink" title="2. 插入文本（Insert Mode）："></a>2. <strong>插入文本（Insert Mode）：</strong></h3><ul>
<li><code>i</code>：在光标前插入文本。</li>
<li><code>I</code>：在当前行的开头插入文本。</li>
<li><code>a</code>：在光标后插入文本。</li>
<li><code>A</code>：在当前行的末尾插入文本。</li>
<li><code>o</code>：在当前行的下方插入新行，并进入插入模式。</li>
<li><code>O</code>：在当前行的上方插入新行，并进入插入模式。</li>
</ul>
<h3 id="3-删除和复制（Normal-Mode）："><a href="#3-删除和复制（Normal-Mode）：" class="headerlink" title="3. 删除和复制（Normal Mode）："></a>3. <strong>删除和复制（Normal Mode）：</strong></h3><ul>
<li><code>x</code>：删除光标所在位置的字符。</li>
<li><code>dd</code>：删除当前行。</li>
<li><code>yy</code>：复制当前行。</li>
<li><code>p</code>：在光标后粘贴复制的内容。</li>
<li><code>P</code>：在光标前粘贴复制的内容。</li>
</ul>
<h3 id="4-撤销和重做（Normal-Mode）："><a href="#4-撤销和重做（Normal-Mode）：" class="headerlink" title="4. 撤销和重做（Normal Mode）："></a>4. <strong>撤销和重做（Normal Mode）：</strong></h3><ul>
<li><code>u</code>：撤销上一次操作。</li>
<li><code>Ctrl + r</code>：重做上一次撤销的操作。</li>
</ul>
<h3 id="5-搜索与替换（Normal-Mode）："><a href="#5-搜索与替换（Normal-Mode）：" class="headerlink" title="5. 搜索与替换（Normal Mode）："></a>5. <strong>搜索与替换（Normal Mode）：</strong></h3><ul>
<li><code>/pattern</code>：正向搜索匹配 <code>pattern</code> 的文本。</li>
<li><code>?pattern</code>：反向搜索匹配 <code>pattern</code> 的文本。</li>
<li><code>:s/old_text/new_text/g</code>：替换当前行中所有的 <code>old_text</code> 为 <code>new_text</code>。</li>
<li><code>:%s/old_text/new_text/g</code>：全局替换文件中所有的 <code>old_text</code> 为 <code>new_text</code>。</li>
</ul>
<h3 id="6-保存和退出（Normal-Mode）："><a href="#6-保存和退出（Normal-Mode）：" class="headerlink" title="6. 保存和退出（Normal Mode）："></a>6. <strong>保存和退出（Normal Mode）：</strong></h3><ul>
<li><code>:w</code>：保存文件。</li>
<li><code>:q</code>：退出。</li>
<li><code>:wq</code>：保存并退出。</li>
<li><code>:q!</code>：强制退出，不保存修改。</li>
</ul>
<h3 id="7-显示行号和状态栏（Normal-Mode）："><a href="#7-显示行号和状态栏（Normal-Mode）：" class="headerlink" title="7. 显示行号和状态栏（Normal Mode）："></a>7. <strong>显示行号和状态栏（Normal Mode）：</strong></h3><ul>
<li><code>:set number</code>：显示行号。</li>
<li><code>:set nonumber</code>：隐藏行号。</li>
<li><code>:set ruler</code>：显示状态栏。</li>
</ul>
<h3 id="8-多窗口操作（Normal-Mode）："><a href="#8-多窗口操作（Normal-Mode）：" class="headerlink" title="8. 多窗口操作（Normal Mode）："></a>8. <strong>多窗口操作（Normal Mode）：</strong></h3><ul>
<li><code>:vsp</code>：垂直分割当前窗口。</li>
<li><code>:sp</code>：水平分割当前窗口。</li>
<li><code>Ctrl + w + (h/j/k/l)</code>：切换焦点到左&#x2F;下&#x2F;上&#x2F;右窗口。</li>
</ul>
<h3 id="9-保存会话（Normal-Mode）："><a href="#9-保存会话（Normal-Mode）：" class="headerlink" title="9. 保存会话（Normal Mode）："></a>9. <strong>保存会话（Normal Mode）：</strong></h3><ul>
<li><code>:mksession filename</code>：保存当前会话到文件 <code>filename</code>。</li>
<li><code>:source filename</code>：加载会话文件。</li>
</ul>
<h3 id="10-帮助（Normal-Mode）："><a href="#10-帮助（Normal-Mode）：" class="headerlink" title="10. 帮助（Normal Mode）："></a>10. <strong>帮助（Normal Mode）：</strong></h3><ul>
<li><code>:help</code>：打开帮助文档。</li>
<li>在帮助文档中，使用 <code>:q</code> 退出。</li>
</ul>
<p>这是一些常用的Vim命令，Vim有很多其他功能和命令，可以根据需要深入学习。在Vim中，熟练使用键盘快捷键和命令可以大大提高编辑效率。</p>
<h2 id="linux-vim命令-常用技巧"><a href="#linux-vim命令-常用技巧" class="headerlink" title="linux vim命令 常用技巧"></a>linux vim命令 常用技巧</h2><p>在Linux中使用Vim时，以下是一些常用的技巧和命令：</p>
<h3 id="1-插入模式切换："><a href="#1-插入模式切换：" class="headerlink" title="1. 插入模式切换："></a>1. <strong>插入模式切换：</strong></h3><ul>
<li><code>i</code>：在当前光标位置前插入。</li>
<li><code>I</code>：在当前行首插入。</li>
<li><code>a</code>：在当前光标位置后插入。</li>
<li><code>A</code>：在当前行尾插入。</li>
</ul>
<h3 id="2-删除和复制："><a href="#2-删除和复制：" class="headerlink" title="2. 删除和复制："></a>2. <strong>删除和复制：</strong></h3><ul>
<li><code>x</code>：删除光标所在位置的字符。</li>
<li><code>dd</code>：删除整行。</li>
<li><code>yy</code>：复制整行。</li>
<li><code>p</code>：在光标后粘贴复制的内容。</li>
<li><code>P</code>：在光标前粘贴复制的内容。</li>
</ul>
<h3 id="3-跳转和定位："><a href="#3-跳转和定位：" class="headerlink" title="3. 跳转和定位："></a>3. <strong>跳转和定位：</strong></h3><ul>
<li><code>gg</code>：跳到文件开头。</li>
<li><code>G</code>：跳到文件末尾。</li>
<li><code>:n</code>：跳到第 n 行。</li>
<li><code>Ctrl + g</code>：显示当前行号和文件信息。</li>
</ul>
<h3 id="4-搜索与替换："><a href="#4-搜索与替换：" class="headerlink" title="4. 搜索与替换："></a>4. <strong>搜索与替换：</strong></h3><ul>
<li><code>/pattern</code>：正向搜索匹配 <code>pattern</code> 的文本。</li>
<li><code>?pattern</code>：反向搜索匹配 <code>pattern</code> 的文本。</li>
<li><code>:s/old/new/g</code>：替换当前行中所有匹配的 <code>old</code> 为 <code>new</code>。</li>
<li><code>:%s/old/new/g</code>：替换文件中所有匹配的 <code>old</code> 为 <code>new</code>。</li>
</ul>
<h3 id="5-撤销和重做："><a href="#5-撤销和重做：" class="headerlink" title="5. 撤销和重做："></a>5. <strong>撤销和重做：</strong></h3><ul>
<li><code>u</code>：撤销上一步操作。</li>
<li><code>Ctrl + r</code>：重做上一步撤销的操作。</li>
</ul>
<h3 id="6-保存和退出："><a href="#6-保存和退出：" class="headerlink" title="6. 保存和退出："></a>6. <strong>保存和退出：</strong></h3><ul>
<li><code>:w</code>：保存文件。</li>
<li><code>:q</code>：退出。</li>
<li><code>:wq</code>：保存并退出。</li>
<li><code>:q!</code>：强制退出，不保存修改。</li>
</ul>
<h3 id="7-文本块操作："><a href="#7-文本块操作：" class="headerlink" title="7. 文本块操作："></a>7. <strong>文本块操作：</strong></h3><ul>
<li><code>v</code>：进入可视模式，按字符选择。</li>
<li><code>V</code>：进入可视行模式，按行选择。</li>
<li><code>Ctrl + v</code>：进入可视块模式，按块选择。</li>
<li><code>y</code>：复制选择的文本。</li>
<li><code>d</code>：删除选择的文本。</li>
<li><code>p</code>：在光标后粘贴文本。</li>
<li><code>P</code>：在光标前粘贴文本。</li>
</ul>
<h3 id="8-自动补全："><a href="#8-自动补全：" class="headerlink" title="8. 自动补全："></a>8. <strong>自动补全：</strong></h3><ul>
<li>在插入模式下，按 <code>Ctrl + n</code> 可以进行关键字自动补全。</li>
</ul>
<h3 id="9-多文件编辑："><a href="#9-多文件编辑：" class="headerlink" title="9. 多文件编辑："></a>9. <strong>多文件编辑：</strong></h3><ul>
<li><code>:e filename</code>：打开文件。</li>
<li><code>:vsp filename</code>：垂直分割窗口并打开文件。</li>
<li><code>:sp filename</code>：水平分割窗口并打开文件。</li>
<li><code>:bnext</code>：切换到下一个缓冲区。</li>
</ul>
<h3 id="10-宏录制："><a href="#10-宏录制：" class="headerlink" title="10. 宏录制："></a>10. <strong>宏录制：</strong></h3><ul>
<li><code>q&lt;register&gt;</code>：开始录制宏到指定寄存器。</li>
<li><code>q</code>：停止录制宏。</li>
<li><code>@&lt;register&gt;</code>：执行录制的宏。</li>
</ul>
<h3 id="11-折叠和展开："><a href="#11-折叠和展开：" class="headerlink" title="11. 折叠和展开："></a>11. <strong>折叠和展开：</strong></h3><ul>
<li><code>zf</code>：创建折叠。</li>
<li><code>zo</code>：展开折叠。</li>
<li><code>zc</code>：关闭折叠。</li>
</ul>
<p>这些是一些Vim中常用的技巧和命令，能够帮助你更高效地进行文本编辑。熟练掌握这些技巧可以提升你在Vim中的编辑体验。</p>
<h2 id="linux-vim命令-高级技巧"><a href="#linux-vim命令-高级技巧" class="headerlink" title="linux vim命令 高级技巧"></a>linux vim命令 高级技巧</h2><p>高级的Vim技巧涉及到更深层次的编辑和定制，下面是一些高级技巧：</p>
<h3 id="1-正则表达式搜索和替换："><a href="#1-正则表达式搜索和替换：" class="headerlink" title="1. 正则表达式搜索和替换："></a>1. <strong>正则表达式搜索和替换：</strong></h3><ul>
<li>使用正则表达式进行更灵活的搜索和替换。例如，<code>:s/\vpattern/replace/g</code>，其中 <code>\v</code> 表示启用“very magic”模式，使得正则表达式更简洁。</li>
</ul>
<h3 id="2-宏（Macro）："><a href="#2-宏（Macro）：" class="headerlink" title="2. 宏（Macro）："></a>2. <strong>宏（Macro）：</strong></h3><ul>
<li>使用宏记录和重放操作序列。录制宏：<code>q&lt;register&gt;</code>开始录制，<code>q</code>结束录制。执行宏：<code>@&lt;register&gt;</code>。</li>
</ul>
<h3 id="3-折叠："><a href="#3-折叠：" class="headerlink" title="3. 折叠："></a>3. <strong>折叠：</strong></h3><ul>
<li>使用 <code>zf</code> 创建折叠，<code>zo</code> 展开折叠，<code>zc</code> 关闭折叠。可通过 <code>zM</code> 全部折叠，<code>zR</code> 全部展开。</li>
</ul>
<h3 id="4-标签页和窗口管理："><a href="#4-标签页和窗口管理：" class="headerlink" title="4. 标签页和窗口管理："></a>4. <strong>标签页和窗口管理：</strong></h3><ul>
<li>使用 <code>:tabnew</code> 打开新标签页，<code>:tabnext</code> 切换到下一个标签页，<code>:sp</code> 和 <code>:vsp</code> 打开新窗口。使用 <code>Ctrl + w</code> 然后 <code>h/j/k/l</code> 在窗口之间移动。</li>
</ul>
<h3 id="5-会话管理："><a href="#5-会话管理：" class="headerlink" title="5. 会话管理："></a>5. <strong>会话管理：</strong></h3><ul>
<li>使用 <code>:mksession</code> 保存当前会话，<code>:source</code> 加载会话文件。这允许你保存并重新加载编辑器状态。</li>
</ul>
<h3 id="6-自动命令："><a href="#6-自动命令：" class="headerlink" title="6. 自动命令："></a>6. <strong>自动命令：</strong></h3><ul>
<li>使用 <code>autocmd</code> 命令在特定事件发生时自动执行命令。例如，在文件保存时自动运行某个命令。</li>
</ul>
<h3 id="7-自定义键盘映射："><a href="#7-自定义键盘映射：" class="headerlink" title="7. 自定义键盘映射："></a>7. <strong>自定义键盘映射：</strong></h3><ul>
<li>使用 <code>map</code> 命令将一系列命令映射到键盘快捷键。例如，<code>:map &lt;F2&gt; :w&lt;CR&gt;</code> 将 <code>&lt;F2&gt;</code> 键映射到保存文件。</li>
</ul>
<h3 id="8-插件管理器："><a href="#8-插件管理器：" class="headerlink" title="8. 插件管理器："></a>8. <strong>插件管理器：</strong></h3><ul>
<li>使用插件管理器（如Vim-Plug、Pathogen、Vundle）安装和管理Vim插件，以扩展Vim的功能。</li>
</ul>
<h3 id="9-模式和语法高亮："><a href="#9-模式和语法高亮：" class="headerlink" title="9. 模式和语法高亮："></a>9. <strong>模式和语法高亮：</strong></h3><ul>
<li>定制Vim的显示模式和语法高亮，以适应不同的文件类型。可以使用 <code>autocmd</code> 在文件类型加载时设置不同的选项。</li>
</ul>
<h3 id="10-查找文件和替换："><a href="#10-查找文件和替换：" class="headerlink" title="10. 查找文件和替换："></a>10. <strong>查找文件和替换：</strong></h3><ul>
<li>使用 <code>:find</code> 查找文件，<code>:grep</code> 在项目中搜索，<code>:vimgrep</code> 在多个文件中进行搜索，<code>:cfdo</code> 在搜索结果上执行命令。</li>
</ul>
<h3 id="11-异步运行命令："><a href="#11-异步运行命令：" class="headerlink" title="11. 异步运行命令："></a>11. <strong>异步运行命令：</strong></h3><ul>
<li>使用 <code>:terminal</code> 打开一个终端窗口，或使用插件执行异步任务，如<code>:AsyncRun</code>。</li>
</ul>
<h3 id="12-自定义颜色方案："><a href="#12-自定义颜色方案：" class="headerlink" title="12. 自定义颜色方案："></a>12. <strong>自定义颜色方案：</strong></h3><ul>
<li>修改或添加颜色方案以改变Vim的外观。可以使用 <code>:colorscheme</code> 切换颜色方案，或手动编辑 <code>.vimrc</code> 文件。</li>
</ul>
<h3 id="13-局部配置："><a href="#13-局部配置：" class="headerlink" title="13. 局部配置："></a>13. <strong>局部配置：</strong></h3><ul>
<li>使用 <code>autocmd FileType</code> 和 <code>augroup</code> 在不同的文件类型下应用不同的配置。</li>
</ul>
<p>这些高级技巧可以让你更深入地定制和利用Vim的功能。记住，Vim是非常灵活的编辑器，通过深入了解和使用其高级功能，你可以提高编辑效率和适应不同的工作流程。</p>
<h2 id="linux-vim命令-搜索相关使用技巧-详解"><a href="#linux-vim命令-搜索相关使用技巧-详解" class="headerlink" title="linux vim命令 搜索相关使用技巧 详解"></a>linux vim命令 搜索相关使用技巧 详解</h2><p>在Vim中，搜索是一个常见而强大的操作。以下是一些搜索相关的使用技巧的详解：</p>
<h3 id="1-正向搜索和反向搜索："><a href="#1-正向搜索和反向搜索：" class="headerlink" title="1. 正向搜索和反向搜索："></a>1. <strong>正向搜索和反向搜索：</strong></h3><ul>
<li><code>/pattern</code>：在光标后正向搜索匹配 <code>pattern</code> 的文本。</li>
<li><code>?pattern</code>：在光标前反向搜索匹配 <code>pattern</code> 的文本。</li>
</ul>
<h3 id="2-匹配整个单词："><a href="#2-匹配整个单词：" class="headerlink" title="2. 匹配整个单词："></a>2. <strong>匹配整个单词：</strong></h3><ul>
<li>在搜索模式下，使用 <code>\b</code> 来匹配整个单词。例如，搜索 <code>\bword\b</code> 可以匹配单独的 “word”。</li>
</ul>
<h3 id="3-忽略大小写："><a href="#3-忽略大小写：" class="headerlink" title="3. 忽略大小写："></a>3. <strong>忽略大小写：</strong></h3><ul>
<li>在搜索模式下，使用 <code>\c</code> 来忽略大小写。例如，搜索 <code>ignore\c</code> 可以匹配 “ignore”、”IGNORE”、”IgNore”等。</li>
</ul>
<h3 id="4-使用正则表达式："><a href="#4-使用正则表达式：" class="headerlink" title="4. 使用正则表达式："></a>4. <strong>使用正则表达式：</strong></h3><ul>
<li>Vim支持强大的正则表达式。例如，<code>/^\d\&#123;3\&#125;</code> 可以匹配以三个数字开头的行。</li>
</ul>
<h3 id="5-高亮搜索结果："><a href="#5-高亮搜索结果：" class="headerlink" title="5. 高亮搜索结果："></a>5. <strong>高亮搜索结果：</strong></h3><ul>
<li>在正常模式下，输入 <code>:set hlsearch</code> 可以启用搜索结果的高亮显示。使用 <code>:nohlsearch</code> 可以取消高亮显示。</li>
</ul>
<h3 id="6-搜索下一个和上一个匹配项："><a href="#6-搜索下一个和上一个匹配项：" class="headerlink" title="6. 搜索下一个和上一个匹配项："></a>6. <strong>搜索下一个和上一个匹配项：</strong></h3><ul>
<li>在正常模式下，按下 <code>n</code> 可以跳转到下一个匹配项。按下 <code>N</code> 可以跳转到上一个匹配项。</li>
</ul>
<h3 id="7-使用标签页显示搜索结果："><a href="#7-使用标签页显示搜索结果：" class="headerlink" title="7. 使用标签页显示搜索结果："></a>7. <strong>使用标签页显示搜索结果：</strong></h3><ul>
<li>使用 <code>:tabnew</code> 打开新标签页，然后执行搜索命令，可以在新标签页中显示搜索结果。</li>
</ul>
<h3 id="8-搜索并替换："><a href="#8-搜索并替换：" class="headerlink" title="8. 搜索并替换："></a>8. <strong>搜索并替换：</strong></h3><ul>
<li><code>:s/old_text/new_text/g</code>：替换当前行中所有的 <code>old_text</code> 为 <code>new_text</code>。</li>
<li><code>:%s/old_text/new_text/g</code>：全局替换文件中所有的 <code>old_text</code> 为 <code>new_text</code>。</li>
</ul>
<h3 id="9-使用搜索历史："><a href="#9-使用搜索历史：" class="headerlink" title="9. 使用搜索历史："></a>9. <strong>使用搜索历史：</strong></h3><ul>
<li>在搜索模式下，按 <code>Ctrl + r</code> 可以进入历史搜索模式，然后选择之前的搜索项。</li>
</ul>
<h3 id="10-在多个文件中搜索："><a href="#10-在多个文件中搜索：" class="headerlink" title="10. 在多个文件中搜索："></a>10. <strong>在多个文件中搜索：</strong></h3><ul>
<li>使用 <code>:grep</code> 在整个项目中搜索，或者使用 <code>:vimgrep</code> 在多个文件中进行搜索。例如，<code>:vimgrep /pattern/ *.txt</code>。</li>
</ul>
<h3 id="11-在当前文件中搜索并定位："><a href="#11-在当前文件中搜索并定位：" class="headerlink" title="11. 在当前文件中搜索并定位："></a>11. <strong>在当前文件中搜索并定位：</strong></h3><ul>
<li>使用 <code>*</code> 在光标下搜索当前单词并跳转到下一个匹配项。使用 <code>#</code> 在光标上搜索当前单词并跳转到上一个匹配项。</li>
</ul>
<h3 id="12-使用搜索匹配项进行操作："><a href="#12-使用搜索匹配项进行操作：" class="headerlink" title="12. 使用搜索匹配项进行操作："></a>12. <strong>使用搜索匹配项进行操作：</strong></h3><ul>
<li>在可视模式下选择文本，然后按 <code>*</code> 或 <code>#</code> 将光标移动到下一个或上一个匹配项。</li>
</ul>
<p>这些技巧可以让你更有效地在Vim中进行搜索操作。通过组合不同的搜索命令和选项，你可以快速定位和处理文本中的特定内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_08_head/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_08_head/" class="post-title-link" itemprop="url">linux_2_08_head</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>head命令笔记</li>
</ul>
<h2 id="linux-head命令-详解"><a href="#linux-head命令-详解" class="headerlink" title="linux head命令 详解"></a>linux head命令 详解</h2><p><code>head</code>命令在Linux和Unix系统中用于显示文件的开头部分，默认情况下显示前10行。以下是<code>head</code>命令的一些常用选项和示例：</p>
<h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>

<h3 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h3><ul>
<li><code>-n, --lines=NUM</code>：指定要显示的行数。例如，<code>-n 20</code>将显示文件的前20行。</li>
<li><code>-c, --bytes=NUM</code>：指定要显示的字节数。</li>
<li><code>-q, --quiet, --silent</code>：不显示文件名头部。</li>
<li><code>-v, --verbose</code>：始终显示文件名头部。</li>
<li><code>--help</code>：显示帮助信息。</li>
<li><code>--version</code>：显示版本信息。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><ol>
<li><p>显示文件的前10行（默认情况）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示文件的前20行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 20 filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示文件的前100字节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -c 100 filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示多个文件的前5行，并显示文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 5 -v file1.txt file2.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>不显示文件名头部：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -q filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示<code>head</code>命令的帮助信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head --help</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>如果未指定文件名，则<code>head</code>将从标准输入读取数据。你可以使用管道符 <code>|</code> 将其他命令的输出传递给<code>head</code>。</li>
</ul>
<p>这些是一些常见的<code>head</code>命令用法和选项。根据你的需求，你可以使用不同的选项来满足查看文件开头部分的要求。</p>
<h2 id="linux-head命令-常用技巧"><a href="#linux-head命令-常用技巧" class="headerlink" title="linux head命令 常用技巧"></a>linux head命令 常用技巧</h2><p>在Linux中，<code>head</code>命令是一个简单而实用的工具，用于查看文件的开头部分。以下是一些使用<code>head</code>命令的常用技巧：</p>
<ol>
<li><p><strong>查看文件的开头几行：</strong><br>默认情况下，<code>head</code>命令显示文件的前10行。你可以通过提供<code>-n</code>选项并指定行数来调整显示的行数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 20 filename  <span class="comment"># 显示文件的前20行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看文件的开头几个字节：</strong><br>使用<code>-c</code>选项可以指定要显示的字节数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -c 100 filename  <span class="comment"># 显示文件的前100个字节</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示多个文件的开头：</strong><br><code>head</code>命令可以同时处理多个文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> file1.txt file2.txt  <span class="comment"># 分别显示file1.txt和file2.txt的开头</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结合其他命令使用：</strong><br>你可以使用管道将其他命令的输出传递给<code>head</code>，以便查看前几行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> somefile.txt | <span class="built_in">head</span> -n 15  <span class="comment"># 显示somefile.txt的前15行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不显示文件名头部：</strong><br>默认情况下，<code>head</code>在显示文件开头时会显示文件名。如果你不希望显示文件名，可以使用<code>-q</code>选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -q filename  <span class="comment"># 不显示文件名</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>始终显示文件名头部：</strong><br>如果你想始终显示文件名，可以使用<code>-v</code>选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -v filename  <span class="comment"># 始终显示文件名</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看目录中的文件：</strong><br>你可以使用通配符来查看目录中所有匹配的文件的开头。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> *.txt  <span class="comment"># 显示所有以.txt结尾的文件的开头</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示特定文件类型的文件开头：</strong><br>通过组合<code>find</code>命令和<code>head</code>命令，你可以查看特定类型的文件的开头。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.log&quot;</span> -<span class="built_in">exec</span> <span class="built_in">head</span> -n 10 &#123;&#125; \;  <span class="comment"># 显示所有.log文件的前10行</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些技巧可以帮助你灵活地使用<code>head</code>命令来查看文件的开头部分，适应不同的需求。</p>
<h2 id="linux-head命令-高级技巧"><a href="#linux-head命令-高级技巧" class="headerlink" title="linux head命令 高级技巧"></a>linux head命令 高级技巧</h2><p>除了基本的用法和常见技巧之外，还有一些更高级的<code>head</code>命令用法，可以更灵活地处理文件内容。以下是一些高级技巧：</p>
<ol>
<li><p><strong>显示行号：</strong><br>使用<code>-n</code>选项可以显示行号，方便你查看文件内容的具体行数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -n filename | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态查看文件变化：</strong><br>结合<code>tail -f</code>命令，可以实时查看文件的变化。这对于监控日志文件非常有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f filename | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示文件的非文本内容：</strong><br>使用<code>xxd</code>命令将文件内容以十六进制形式显示，然后使用<code>head</code>来查看前几行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd filename | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看文件的字符编码：</strong><br>使用<code>file</code>命令查看文件的字符编码，然后使用<code>head</code>查看文件的开头。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file -i filename  <span class="comment"># 显示文件编码信息</span></span><br><span class="line"><span class="built_in">head</span> -n 10 filename  <span class="comment"># 查看文件开头</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看大文件的开头：</strong><br>对于大文件，可以使用<code>zcat</code>结合<code>head</code>命令，以便在查看压缩文件的开头时无需先解压缩。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat filename.gz | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看文件的特定部分：</strong><br>使用<code>sed</code>命令选择文件的特定行范围，然后将其传递给<code>head</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;10,20p&#x27;</span> filename | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示文件中最常见的单词：</strong><br>使用<code>tr</code>、<code>sort</code>、<code>uniq</code>和<code>head</code>命令的组合来查看文件中最常见的单词。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tr</span> -s <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;\n&#x27;</span> &lt; filename | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr | <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看文件的末尾而不是开头：</strong><br>使用<code>tail</code>命令以反向顺序查看文件的末尾，然后再使用<code>head</code>查看前几行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 20 filename | <span class="built_in">head</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些高级技巧展示了如何结合<code>head</code>命令与其他命令以满足更复杂的需求，使其成为一个更灵活和强大的文件查看工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_10_tmux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_10_tmux/" class="post-title-link" itemprop="url">linux_2_10_tmux</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>tmux命令笔记</li>
</ul>
<h2 id="linux-tmux命令-详解"><a href="#linux-tmux命令-详解" class="headerlink" title="linux tmux命令 详解"></a>linux tmux命令 详解</h2><p><code>tmux</code>（终端复用工具）是一个在终端窗口中创建和管理多个会话（sessions）、窗口（windows）和面板（panes）的工具。以下是一些常用的<code>tmux</code>命令的详解：</p>
<h3 id="1-启动和终止-tmux："><a href="#1-启动和终止-tmux：" class="headerlink" title="1. 启动和终止 tmux："></a>1. <strong>启动和终止 <code>tmux</code>：</strong></h3><ul>
<li><strong>启动 <code>tmux</code>：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux</span><br></pre></td></tr></table></figure></li>
<li><strong>退出 <code>tmux</code>：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>（默认的前缀键），然后按下 <code>d</code>，即 <code>Ctrl-b d</code>，来退出 <code>tmux</code> 会话。</li>
</ul>
<h3 id="2-会话管理："><a href="#2-会话管理：" class="headerlink" title="2. 会话管理："></a>2. <strong>会话管理：</strong></h3><ul>
<li><strong>创建新会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new-session -s session_name</span><br></pre></td></tr></table></figure></li>
<li><strong>切换会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux switch-client -t session_name</span><br></pre></td></tr></table></figure></li>
<li><strong>列出所有会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux list-sessions</span><br></pre></td></tr></table></figure></li>
<li><strong>关闭会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux kill-session -t session_name</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-窗口管理："><a href="#3-窗口管理：" class="headerlink" title="3. 窗口管理："></a>3. <strong>窗口管理：</strong></h3><ul>
<li><strong>创建新窗口：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>c</code>。</li>
<li><strong>切换窗口：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下窗口的编号（从0开始）。</li>
<li><strong>重命名窗口：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>,</code>，输入新窗口名字。</li>
<li><strong>关闭窗口：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>&amp;</code>。</li>
</ul>
<h3 id="4-面板管理："><a href="#4-面板管理：" class="headerlink" title="4. 面板管理："></a>4. <strong>面板管理：</strong></h3><ul>
<li><strong>垂直分割当前窗口：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>%</code>。</li>
<li><strong>水平分割当前窗口：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>&quot; </code>。</li>
<li><strong>切换面板：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下箭头键或使用 <code>o</code>。</li>
<li><strong>关闭面板：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>x</code>。</li>
</ul>
<h3 id="5-其他操作："><a href="#5-其他操作：" class="headerlink" title="5. 其他操作："></a>5. <strong>其他操作：</strong></h3><ul>
<li><strong>重新加载配置：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure></li>
<li><strong>显示帮助信息：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>?</code>。</li>
</ul>
<h3 id="6-复制和粘贴："><a href="#6-复制和粘贴：" class="headerlink" title="6. 复制和粘贴："></a>6. <strong>复制和粘贴：</strong></h3><ul>
<li><strong>进入复制模式：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>[</code>。</li>
<li><strong>在复制模式中移动光标：</strong><br>使用箭头键移动。</li>
<li><strong>开始选择文本：</strong><br>按下 <code>Space</code> 键开始选择，移动光标来选择文本。</li>
<li><strong>复制选中的文本：</strong><br>按下 <code>Enter</code> 键。</li>
<li><strong>粘贴复制的文本：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>]</code>。</li>
</ul>
<p>这些是一些常用的<code>tmux</code>命令，希望能够帮助你更有效地使用这个终端复用工具。<code>tmux</code>具有强大的功能，可以提高在终端中工作的效率。</p>
<h2 id="linux-tmux命令-常用技巧"><a href="#linux-tmux命令-常用技巧" class="headerlink" title="linux tmux命令 常用技巧"></a>linux tmux命令 常用技巧</h2><p>以下是一些在使用tmux时的常用技巧和命令：</p>
<h3 id="1-基本会话管理："><a href="#1-基本会话管理：" class="headerlink" title="1. 基本会话管理："></a>1. <strong>基本会话管理：</strong></h3><ul>
<li><strong>启动tmux：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux</span><br></pre></td></tr></table></figure></li>
<li><strong>分离会话：</strong><br>在tmux会话中按下 <code>Ctrl-b</code>，然后按下 <code>d</code>。</li>
<li><strong>重新连接到会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux attach-session -t session_name</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-窗口和面板："><a href="#2-窗口和面板：" class="headerlink" title="2. 窗口和面板："></a>2. <strong>窗口和面板：</strong></h3><ul>
<li><strong>创建新窗口：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b c</span><br></pre></td></tr></table></figure></li>
<li><strong>切换窗口：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b &lt;窗口编号&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>切换面板：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b 方向键</span><br></pre></td></tr></table></figure></li>
<li><strong>关闭当前窗口或面板：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-自定义键绑定："><a href="#3-自定义键绑定：" class="headerlink" title="3. 自定义键绑定："></a>3. <strong>自定义键绑定：</strong></h3><ul>
<li><strong>修改前缀键：</strong><br>在tmux配置文件（默认为 <code>~/.tmux.conf</code>）中添加：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-option -g prefix C-a</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-复制和粘贴："><a href="#4-复制和粘贴：" class="headerlink" title="4. 复制和粘贴："></a>4. <strong>复制和粘贴：</strong></h3><ul>
<li><strong>进入复制模式：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b [</span><br></pre></td></tr></table></figure></li>
<li><strong>开始选择文本：</strong><br>移动光标，按下 <code>Space</code> 开始选择，移动光标选择文本。</li>
<li><strong>复制选中的文本：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b ]</span><br></pre></td></tr></table></figure></li>
<li><strong>粘贴复制的文本：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b P</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-垂直和水平分割窗口："><a href="#5-垂直和水平分割窗口：" class="headerlink" title="5. 垂直和水平分割窗口："></a>5. <strong>垂直和水平分割窗口：</strong></h3><ul>
<li><strong>垂直分割：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b %</span><br></pre></td></tr></table></figure></li>
<li><strong>水平分割：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b <span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-显示和隐藏状态栏："><a href="#6-显示和隐藏状态栏：" class="headerlink" title="6. 显示和隐藏状态栏："></a>6. <strong>显示和隐藏状态栏：</strong></h3><ul>
<li><strong>切换状态栏显示：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b t</span><br></pre></td></tr></table></figure></li>
<li><strong>临时显示状态栏：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b :</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-会话管理："><a href="#7-会话管理：" class="headerlink" title="7. 会话管理："></a>7. <strong>会话管理：</strong></h3><ul>
<li><strong>列出所有会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux list-sessions</span><br></pre></td></tr></table></figure></li>
<li><strong>切换到下一个会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b (</span><br></pre></td></tr></table></figure></li>
<li><strong>切换到上一个会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b )</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-命令行中运行命令："><a href="#8-命令行中运行命令：" class="headerlink" title="8. 命令行中运行命令："></a>8. <strong>命令行中运行命令：</strong></h3><ul>
<li><strong>在新窗口中运行命令：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b :</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-重新加载tmux配置："><a href="#9-重新加载tmux配置：" class="headerlink" title="9. 重新加载tmux配置："></a>9. <strong>重新加载tmux配置：</strong></h3>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b :</span><br><span class="line">source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure>

<p>这些是一些常用的tmux技巧和命令，可以提高你在终端中使用tmux的效率。根据个人需求，你还可以根据tmux的配置文件进行更多的定制。</p>
<h2 id="linux-tmux命令-高级技巧"><a href="#linux-tmux命令-高级技巧" class="headerlink" title="linux tmux命令 高级技巧"></a>linux tmux命令 高级技巧</h2><p>以下是一些高级的 tmux 技巧，可以帮助你更好地使用 tmux 进行终端管理：</p>
<h3 id="1-复制到系统剪贴板："><a href="#1-复制到系统剪贴板：" class="headerlink" title="1. 复制到系统剪贴板："></a>1. <strong>复制到系统剪贴板：</strong></h3><ul>
<li>如果你的 tmux 版本支持，你可以使用 <code>reattach-to-user-namespace</code> 命令将 tmux 复制到系统剪贴板：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install reattach-to-user-namespace  <span class="comment"># 仅在 macOS 上需要</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>   在 tmux 中按下 <code>Ctrl-b</code> 进入复制模式，选择文本，然后按下 <code>Ctrl-b</code> + <code>]</code> 复制到系统剪贴板。</p>
<h3 id="2-会话共享："><a href="#2-会话共享：" class="headerlink" title="2. 会话共享："></a>2. <strong>会话共享：</strong></h3><ul>
<li><p>多用户共享同一 tmux 会话，允许多人同时查看和编辑相同的终端会话。</p>
<p>在一个终端中执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux -S /tmp/shared-session</span><br></pre></td></tr></table></figure>

<p>在另一个终端中执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux -S /tmp/shared-session attach</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-自动重新加载配置："><a href="#3-自动重新加载配置：" class="headerlink" title="3. 自动重新加载配置："></a>3. <strong>自动重新加载配置：</strong></h3><ul>
<li><p>让 tmux 在配置文件修改后自动重新加载：</p>
<p>在 <code>~/.tmux.conf</code> 中添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tmux-reload&#x27;</span></span><br><span class="line">run <span class="string">&#x27;~/.tmux.conf&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>   然后在 tmux 中执行 <code>Ctrl-b</code> + <code>I</code> 安装插件。</p>
<h3 id="4-远程复制和粘贴："><a href="#4-远程复制和粘贴：" class="headerlink" title="4. 远程复制和粘贴："></a>4. <strong>远程复制和粘贴：</strong></h3><ul>
<li><p>在远程服务器上使用 tmux，可以通过 SSH 远程复制和粘贴。</p>
<p>在本地终端执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -t user@remote tmux -CC</span><br></pre></td></tr></table></figure>

<p>然后你就可以使用本地终端的复制和粘贴功能了。</p>
</li>
</ul>
<h3 id="5-自动开启和关闭窗口-面板："><a href="#5-自动开启和关闭窗口-面板：" class="headerlink" title="5. 自动开启和关闭窗口&#x2F;面板："></a>5. <strong>自动开启和关闭窗口&#x2F;面板：</strong></h3><ul>
<li><p>使用 <code>tmux-resurrect</code> 插件可以在 tmux 会话间保存和恢复工作状态，包括窗口、面板、程序等。</p>
<p>安装插件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tmux-resurrect&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 tmux 中执行 <code>Ctrl-b</code> + <code>I</code> 安装插件。</p>
</li>
</ul>
<h3 id="6-自定义状态栏："><a href="#6-自定义状态栏：" class="headerlink" title="6. 自定义状态栏："></a>6. <strong>自定义状态栏：</strong></h3><ul>
<li><p>使用 <code>tmux</code> 的 <code>status-right</code> 和 <code>status-left</code> 选项来自定义状态栏，显示自己感兴趣的信息。</p>
<p>在 <code>~/.tmux.conf</code> 中添加类似以下的配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -g status-left <span class="string">&quot;My Custom Status: #H&quot;</span></span><br><span class="line"><span class="built_in">set</span> -g status-right <span class="string">&quot;Session #S - #I - #P&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-使用-Tmuxp-进行会话管理："><a href="#7-使用-Tmuxp-进行会话管理：" class="headerlink" title="7. 使用 Tmuxp 进行会话管理："></a>7. <strong>使用 Tmuxp 进行会话管理：</strong></h3><ul>
<li><p><code>tmuxp</code> 是一个用于管理 tmux 会话的工具，可以通过 YAML 文件来定义和配置 tmux 会话。</p>
<p>安装 <code>tmuxp</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tmuxp</span><br></pre></td></tr></table></figure>

<p>创建和加载会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmuxp load /path/to/config.yaml</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-使用多个配置文件："><a href="#8-使用多个配置文件：" class="headerlink" title="8. 使用多个配置文件："></a>8. <strong>使用多个配置文件：</strong></h3><ul>
<li><p>可以根据不同需求，创建多个 tmux 配置文件，然后通过别名加载：</p>
<p>在 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 中添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> tmux=<span class="string">&#x27;tmux -f ~/.tmux.conf.custom&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-使用-Tmux-插件管理器："><a href="#9-使用-Tmux-插件管理器：" class="headerlink" title="9. 使用 Tmux 插件管理器："></a>9. <strong>使用 Tmux 插件管理器：</strong></h3><ul>
<li><p>使用插件管理器，如 <code>tpm</code> (Tmux Plugin Manager) 来轻松管理和安装 tmux 插件。</p>
<p>安装 <code>tpm</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm</span><br></pre></td></tr></table></figure>

<p>在 <code>~/.tmux.conf</code> 中添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tpm&#x27;</span></span><br><span class="line">run <span class="string">&#x27;~/.tmux/plugins/tpm/tpm&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 tmux 中执行 <code>Ctrl-b</code> + <code>I</code> 安装插件。</p>
</li>
</ul>
<p>这些高级技巧可以帮助你更充分地利用 tmux 进行终端管理，并根据自己的工作流程进行定制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_06_open_ssh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_06_open_ssh/" class="post-title-link" itemprop="url">linux_2_06_open_ssh</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>openssh 相关工具的笔记</li>
</ul>
<h2 id="OpenSSH-详解"><a href="#OpenSSH-详解" class="headerlink" title="OpenSSH 详解"></a>OpenSSH 详解</h2><p>OpenSSH（Open Secure Shell）是一个用于安全远程登录和文件传输的开源工具套件，提供了加密的网络通信协议和相关的命令行工具。它是SSH协议的实现之一，广泛用于Linux、Unix和其他类Unix系统上。</p>
<p>以下是OpenSSH的一些主要特点和功能：</p>
<ol>
<li><p>安全远程登录：OpenSSH提供了ssh命令，可以通过安全的加密通道远程登录到其他计算机，并在远程终端上执行命令。这使得用户可以远程管理和访问远程服务器，而不必直接物理接触远程计算机。</p>
</li>
<li><p>文件传输：OpenSSH提供了scp和sftp命令，用于在本地计算机和远程服务器之间安全地传输文件和目录。这使得用户可以轻松地复制文件、上传和下载文件，以及进行远程文件管理。</p>
</li>
<li><p>SSH密钥认证：OpenSSH支持使用SSH密钥对进行身份认证，而不是传统的基于密码的认证方式。用户可以生成公钥和私钥，将公钥部署到服务器上，从而实现免密码登录。这提供了更高的安全性和方便性。</p>
</li>
<li><p>端口转发和隧道：OpenSSH支持本地和远程端口转发，以及创建安全的隧道连接。这使得用户可以安全地访问远程计算机上的服务，甚至通过防火墙和网络限制。</p>
</li>
<li><p>X11转发：OpenSSH支持X11转发，允许用户在远程计算机上运行图形化应用程序，并将其显示到本地计算机上。这使得用户可以远程访问图形界面应用程序，而不必直接在远程计算机上操作。</p>
</li>
<li><p>其他功能：OpenSSH还提供了许多其他功能，如代理转发、多因子认证、登录日志记录等，以增强安全性和用户管理能力。</p>
</li>
</ol>
<p>总的来说，OpenSSH是一个功能强大、安全可靠的工具套件，为用户提供了远程访问和文件传输等功能，并通过加密通信和身份认证提供了强大的安全性保障。它在服务器管理、系统维护和远程协作等场景中得到广泛应用。</p>
<h2 id="Linux和Windows互相拷贝"><a href="#Linux和Windows互相拷贝" class="headerlink" title="Linux和Windows互相拷贝"></a>Linux和Windows互相拷贝</h2><ul>
<li>从Linux复制到Windows：<ul>
<li><code>scp /home/user/data/tmp.txt user@192.169.4.16:/C:Users/user/Desktop</code></li>
</ul>
</li>
</ul>
<h2 id="修改SSH配置文件"><a href="#修改SSH配置文件" class="headerlink" title="修改SSH配置文件"></a>修改SSH配置文件</h2><ul>
<li><code>sudo vim /etc/ssh/sshd_config</code></li>
<li>搜索<code>PermitRootLogin</code>，将一下配置：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">33 #LoginGraceTime 2m</span><br><span class="line">34 #PermitRootLogin prohibit-password</span><br><span class="line">35 #StrictModes yes</span><br><span class="line">36 #MaxAuthTries 6</span><br><span class="line">37 #MaxSessions 10</span><br></pre></td></tr></table></figure></li>
<li>修改为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LoginGraceTime 2m</span><br><span class="line">PermitRootLogin yes</span><br><span class="line">StrictModes yes</span><br><span class="line">#MaxAuthTries 6</span><br><span class="line">#MaxSessions 10</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="重启ssh，使配置生效"><a href="#重启ssh，使配置生效" class="headerlink" title="重启ssh，使配置生效"></a>重启ssh，使配置生效</h2><ul>
<li><code>sudo service ssh restart</code></li>
</ul>
<h2 id="linux-openssh是什么"><a href="#linux-openssh是什么" class="headerlink" title="linux openssh是什么"></a>linux openssh是什么</h2><p>OpenSSH（Open Secure Shell）是一个用于提供加密的通信会话的免费开源实现，它包括SSH协议的实现和相关的工具。SSH（Secure Shell）是一种用于在网络上安全传输数据的协议，通常用于远程登录和执行命令，以及安全地传输文件。</p>
<p>以下是 OpenSSH 的主要组件和功能：</p>
<ol>
<li><p><strong>SSH服务器 (<code>sshd</code>)：</strong> OpenSSH 包括一个 SSH 服务器，用于接受远程用户的连接，并提供安全的远程访问。通过 SSH 协议，用户可以在远程系统上执行命令或进行其他操作，而通信过程是经过加密的，确保数据的机密性和完整性。</p>
</li>
<li><p><strong>SSH客户端 (<code>ssh</code>)：</strong> OpenSSH 提供了一个 SSH 客户端，用于建立到远程服务器的加密连接。通过 SSH 客户端，用户可以远程登录到其他系统，执行命令，传输文件等。用户可以在命令行中使用 <code>ssh</code> 命令，也可以使用图形界面工具。</p>
</li>
<li><p><strong>SCP 和 SFTP：</strong> OpenSSH 提供了用于安全文件传输的工具，包括 SCP（Secure Copy Protocol）和 SFTP（Secure File Transfer Protocol）。SCP 允许在网络上安全地传输文件，而 SFTP 则提供了一个交互式的文件传输协议，类似于 FTP，但使用 SSH 进行加密。</p>
</li>
<li><p><strong>SSH密钥对：</strong> OpenSSH 支持使用密钥对进行身份验证，以替代传统的基于密码的身份验证方式。用户可以生成公钥和私钥，将公钥部署到远程服务器上，从而实现更安全的身份验证方式。</p>
</li>
<li><p><strong>端口转发：</strong> OpenSSH 支持端口转发，允许用户在加密的通道上传输其他网络流量，如通过 SSH 安全地访问远程数据库或内部网络服务。</p>
</li>
</ol>
<p>OpenSSH 是许多操作系统中默认安装的标准 SSH 实现，包括许多 Linux 发行版和 BSD 系统。其开源性质使得用户可以审查和修改代码以满足特定需求，并且它广泛用于安全的远程系统管理和文件传输。</p>
<h2 id="linux-openssh详解"><a href="#linux-openssh详解" class="headerlink" title="linux openssh详解"></a>linux openssh详解</h2><p>OpenSSH 是一个用于提供安全网络通信的开源实现，它主要实现了 SSH（Secure Shell）协议。SSH 是一种加密的协议，用于在不安全的网络中提供安全的远程访问、文件传输以及命令执行。以下是 OpenSSH 的一些详细信息：</p>
<h3 id="组件和功能："><a href="#组件和功能：" class="headerlink" title="组件和功能："></a>组件和功能：</h3><ol>
<li><p><strong>sshd（SSH 服务器）：</strong></p>
<ul>
<li><code>sshd</code> 是 OpenSSH 中的服务器端程序，用于接受来自客户端的连接请求。</li>
<li>它负责验证用户身份、建立安全通道，并处理用户的远程命令或文件传输请求。</li>
</ul>
</li>
<li><p><strong>ssh（SSH 客户端）：</strong></p>
<ul>
<li><code>ssh</code> 是 OpenSSH 中的客户端程序，用于建立到远程 SSH 服务器的加密连接。</li>
<li>通过 <code>ssh</code> 命令，用户可以登录远程系统、执行命令、传输文件等。</li>
</ul>
</li>
<li><p><strong>SCP 和 SFTP：</strong></p>
<ul>
<li>SCP（Secure Copy Protocol）和 SFTP（Secure File Transfer Protocol）是用于在网络上安全传输文件的工具。</li>
<li>SCP 提供命令行方式的文件传输，而 SFTP 提供了一个类似于 FTP 的交互式文件传输协议。</li>
</ul>
</li>
<li><p><strong>SSH 密钥对：</strong></p>
<ul>
<li>OpenSSH 支持基于密钥对的身份验证，其中用户生成公钥和私钥。</li>
<li>用户将公钥部署到远程服务器，而私钥保留在本地。这样可以实现更安全的身份验证，避免传统密码登录的风险。</li>
</ul>
</li>
<li><p><strong>端口转发：</strong></p>
<ul>
<li>OpenSSH 支持端口转发，使用户能够通过 SSH 通道安全地传输其他网络流量。</li>
<li>通过端口转发，用户可以访问远程服务器上的本地服务，或者将远程服务映射到本地端口。</li>
</ul>
</li>
</ol>
<h3 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h3><p>OpenSSH 的配置文件通常是 <code>/etc/ssh/sshd_config</code>（服务器端）和 <code>~/.ssh/config</code>（客户端）。这些文件包含了各种配置选项，允许用户自定义 SSH 行为。</p>
<h3 id="安全性："><a href="#安全性：" class="headerlink" title="安全性："></a>安全性：</h3><p>OpenSSH 通过使用加密技术，包括对称加密、非对称加密和哈希算法，提供了通信的机密性和完整性。这使得它成为安全远程管理和文件传输的首选工具之一。</p>
<h3 id="使用案例："><a href="#使用案例：" class="headerlink" title="使用案例："></a>使用案例：</h3><ol>
<li><p><strong>远程登录：</strong> 使用 <code>ssh</code> 客户端通过命令行或图形界面安全地登录到远程系统。</p>
</li>
<li><p><strong>文件传输：</strong> 使用 SCP 或 SFTP 完成文件传输，确保文件在传输过程中得到加密保护。</p>
</li>
<li><p><strong>远程命令执行：</strong> 使用 <code>ssh</code> 客户端执行远程系统上的命令，而不必直接登录到系统。</p>
</li>
<li><p><strong>安全传输其他服务：</strong> 使用端口转发，通过 SSH 通道安全地访问和传输其他网络服务，如数据库服务。</p>
</li>
</ol>
<p>总体而言，OpenSSH 是一个功能强大、安全可靠的工具，被广泛用于各种 Linux 和 UNIX 系统上，以及其他操作系统中。</p>
<h2 id="linux-ssh服务器详解"><a href="#linux-ssh服务器详解" class="headerlink" title="linux ssh服务器详解"></a>linux ssh服务器详解</h2><p>在 Linux 系统上，SSH（Secure Shell）服务器主要由 OpenSSH 软件包提供，它是一个用于提供加密的远程登录和文件传输服务的开源实现。下面详细介绍 Linux 上的 SSH 服务器的相关概念和配置：</p>
<h3 id="OpenSSH-服务器-sshd-："><a href="#OpenSSH-服务器-sshd-：" class="headerlink" title="OpenSSH 服务器 (sshd)："></a>OpenSSH 服务器 (<code>sshd</code>)：</h3><ol>
<li><p><strong>服务启动：</strong></p>
<ul>
<li><code>sshd</code> 是 OpenSSH 中的服务器端程序，负责监听 SSH 连接请求并处理用户的远程登录和文件传输。</li>
<li>在大多数 Linux 发行版中，你可以通过以下命令启动或停止 SSH 服务：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service ssh start  <span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> service ssh stop   <span class="comment"># 停止服务</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>配置文件：</strong></p>
<ul>
<li>SSH 服务器的主要配置文件通常位于 <code>/etc/ssh/sshd_config</code>。这个文件包含了各种配置选项，用于定义服务器的行为、安全性设置和认证方式等。</li>
<li>修改配置文件可能需要超级用户权限，你可以使用编辑器（如 <code>nano</code> 或 <code>vi</code>）来进行编辑：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>重要配置选项：</strong></p>
<ul>
<li>一些常见的配置选项包括：<ul>
<li><code>Port</code>: 指定 SSH 服务器监听的端口，默认为 22。</li>
<li><code>PermitRootLogin</code>: 允许或禁止 root 用户通过 SSH 登录。</li>
<li><code>PasswordAuthentication</code>: 启用或禁用密码身份验证。</li>
<li><code>PubkeyAuthentication</code>: 启用或禁用公钥身份验证。</li>
<li><code>AllowUsers</code> 或 <code>AllowGroups</code>: 限制哪些用户或组可以登录。</li>
<li><code>Protocol</code>: 指定使用的 SSH 协议版本。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>身份验证方式：</strong></p>
<ul>
<li>SSH 服务器支持多种身份验证方式，包括密码、公钥和基于主机的身份验证。管理员可以根据安全需求配置适当的身份验证方式。</li>
</ul>
</li>
<li><p><strong>重启服务：</strong></p>
<ul>
<li>在修改了 <code>sshd_config</code> 文件后，需要重启 SSH 服务以使更改生效：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service ssh restart</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>日志文件：</strong></p>
<ul>
<li>SSH 服务器的活动和错误信息通常记录在 <code>/var/log/auth.log</code> 或 <code>/var/log/secure</code> 文件中，可以通过这些日志文件来监视服务器的活动。</li>
</ul>
</li>
<li><p><strong>安全性建议：</strong></p>
<ul>
<li>定期更新 SSH 服务器和操作系统，以确保安全性。</li>
<li>禁用不安全的身份验证方式，如密码身份验证，而使用公钥身份验证。</li>
<li>配置防火墙规则以限制对 SSH 服务器的访问。</li>
</ul>
</li>
</ol>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>一个简单的 <code>sshd_config</code> 配置示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Port 22</span><br><span class="line">PermitRootLogin no</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AllowUsers username</span><br></pre></td></tr></table></figure>

<p>在这个例子中，SSH 服务器监听默认端口 22，禁止 root 用户直接登录，启用密码和公钥身份验证，只允许特定的用户（<code>username</code>）登录。</p>
<p>请注意，实际配置应根据具体的安全需求和网络环境进行调整。</p>
<h2 id="linux-ssh客户端详解"><a href="#linux-ssh客户端详解" class="headerlink" title="linux ssh客户端详解"></a>linux ssh客户端详解</h2><p>在 Linux 系统上，SSH（Secure Shell）客户端通常由 OpenSSH 软件包提供。SSH 客户端允许用户建立加密连接到远程服务器，执行命令、传输文件以及进行其他远程操作。以下是关于 Linux 上 SSH 客户端的一些详细信息：</p>
<h3 id="OpenSSH-客户端-ssh-："><a href="#OpenSSH-客户端-ssh-：" class="headerlink" title="OpenSSH 客户端 (ssh)："></a>OpenSSH 客户端 (<code>ssh</code>)：</h3><ol>
<li><p><strong>连接远程服务器：</strong></p>
<ul>
<li>使用 <code>ssh</code> 命令可以轻松地建立到远程服务器的 SSH 连接。语法为：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@hostname</span><br></pre></td></tr></table></figure>
其中，<code>username</code> 是目标服务器上的用户名，而 <code>hostname</code> 是目标服务器的主机名或 IP 地址。</li>
</ul>
</li>
<li><p><strong>身份验证方式：</strong></p>
<ul>
<li>SSH 客户端支持多种身份验证方式，包括密码和公钥身份验证。当使用密码登录时，系统会要求用户输入密码。而在使用公钥身份验证时，客户端会使用预先生成的密钥对进行身份验证。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用密码身份验证</span></span><br><span class="line">ssh username@hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用公钥身份验证</span></span><br><span class="line">ssh -i /path/to/private_key username@hostname</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>文件传输：</strong></p>
<ul>
<li>使用 <code>scp</code> 命令可以在本地系统和远程服务器之间传输文件。语法为：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从本地到远程</span></span><br><span class="line">scp local_file username@hostname:/remote/path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从远程到本地</span></span><br><span class="line">scp username@hostname:/remote/file /local/path</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>SSH 配置文件 (<code>~/.ssh/config</code>)：</strong></p>
<ul>
<li>用户可以在 <code>~/.ssh/config</code> 文件中配置 SSH 客户端的行为。这个文件允许你定义主机别名、身份验证方式、端口等设置，以简化 SSH 连接的管理。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例 ~/.ssh/config 文件</span></span><br><span class="line">Host myserver</span><br><span class="line">  HostName example.com</span><br><span class="line">  User username</span><br><span class="line">  Port 2222</span><br><span class="line">  IdentityFile ~/.ssh/private_key</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>端口转发：</strong></p>
<ul>
<li>SSH 客户端支持端口转发，允许用户安全地传输其他网络流量。这通常用于访问远程服务器上的本地服务。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L local_port:remote_host:remote_port username@hostname</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>代理跳板：</strong></p>
<ul>
<li>通过 SSH 客户端，用户可以设置代理跳板，从而通过一个中间服务器访问目标服务器。这对于连接到内部网络的服务器很有用。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -J jumpbox_username@jumpbox_hostname username@target_hostname</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>执行远程命令：</strong></p>
<ul>
<li>通过在 <code>ssh</code> 命令后添加要执行的命令，可以在远程服务器上执行命令而不必手动登录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@hostname <span class="string">&#x27;command_to_run&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>SSH Agent：</strong></p>
<ul>
<li>SSH 客户端可以与 SSH Agent 配合使用，以避免在每次连接时重新输入密码或解锁私钥。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加私钥到 SSH Agent</span></span><br><span class="line">ssh-add /path/to/private_key</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>以上是一些基本的 SSH 客户端使用方式和功能。SSH 客户端非常灵活，可以通过不同的选项和配置满足各种需求，提供安全的远程访问和文件传输。</p>
<h2 id="linux-scp命令详解"><a href="#linux-scp命令详解" class="headerlink" title="linux scp命令详解"></a>linux scp命令详解</h2><p><code>scp</code>（Secure Copy Protocol）是一个用于在本地系统和远程系统之间进行安全文件传输的命令行工具。它使用 SSH 协议来提供加密的数据传输，确保传输的安全性。以下是关于 Linux 上 <code>scp</code> 命令的详解：</p>
<h3 id="scp-语法："><a href="#scp-语法：" class="headerlink" title="scp 语法："></a><code>scp</code> 语法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [选项] <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>source：</strong> 要传输的文件或目录的路径。可以是本地文件或远程服务器上的文件。</li>
<li><strong>destination：</strong> 文件或目录的目标位置。可以是本地路径或远程服务器的路径。</li>
</ul>
<h3 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h3><ol>
<li><p><strong>-r：</strong></p>
<ul>
<li>递归复制，用于传输目录及其内容。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_directory username@remote_host:/remote/path</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>-P：</strong></p>
<ul>
<li>指定远程服务器的端口号，默认为 22。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 local_file username@remote_host:/remote/path</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>-i：</strong></p>
<ul>
<li>指定用于身份验证的私钥文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -i /path/to/private_key local_file username@remote_host:/remote/path</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>-v：</strong></p>
<ul>
<li>启用详细模式，显示调试信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -v local_file username@remote_host:/remote/path</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><ol>
<li><p><strong>从本地传输到远程：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp local_file username@remote_host:/remote/path</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从远程传输到本地：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp username@remote_host:/remote/file /local/path</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>本地到远程目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_directory username@remote_host:/remote/path</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从远程到本地目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r username@remote_host:/remote/directory /local/path</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>scp</code> 使用 SSH 协议，因此你需要在远程服务器上启用 SSH 服务。</li>
<li>对于远程服务器路径，如果省略了用户名，则默认使用当前登录用户。</li>
<li><code>scp</code> 的工作方式类似于 <code>cp</code> 命令，但它使用 SSH 进行加密传输，因此数据在传输过程中是安全的。</li>
<li>在使用 <code>scp</code> 时，确保你有正确的权限来读取本地文件和写入远程目标路径。</li>
</ul>
<p><code>scp</code> 是一个非常实用的工具，能够在本地系统和远程服务器之间轻松传输文件，而且通过使用 SSH 进行加密，确保了数据的安全传输。</p>
<h2 id="linux-sftp命令详解"><a href="#linux-sftp命令详解" class="headerlink" title="linux sftp命令详解"></a>linux sftp命令详解</h2><p><code>sftp</code>（Secure File Transfer Protocol）是一个基于 SSH 协议的安全文件传输工具，它允许用户通过命令行交互式地在本地系统和远程服务器之间传输文件。与传统的 FTP 不同，<code>sftp</code> 使用 SSH 进行加密，提供更安全的文件传输方式。以下是关于 Linux 上 <code>sftp</code> 命令的详细解释：</p>
<h3 id="sftp-语法："><a href="#sftp-语法：" class="headerlink" title="sftp 语法："></a><code>sftp</code> 语法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp [选项] [username@]host[:path]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>username：</strong> 远程服务器上的用户名，如果省略，则使用当前登录用户。</li>
<li><strong>host：</strong> 远程服务器的主机名或 IP 地址。</li>
<li><strong>path：</strong> 远程服务器上的路径，如果省略，则默认为用户的主目录。</li>
</ul>
<h3 id="sftp-命令："><a href="#sftp-命令：" class="headerlink" title="sftp 命令："></a><code>sftp</code> 命令：</h3><ol>
<li><p><strong>连接到远程服务器：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp username@remote_host</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>退出 <code>sftp</code>：</strong></p>
<ul>
<li>在 <code>sftp</code> 交互式模式下，可以使用 <code>exit</code> 或 <code>quit</code> 命令退出。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>上传文件到远程服务器：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put local_file</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>下载文件到本地系统：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get remote_file</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列出远程目录内容：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>改变远程目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> remote_directory</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除远程文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> remote_file</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建远程目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> remote_directory</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重命名远程文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename old_name new_name</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><ul>
<li><p><strong>-i：</strong> 指定用于身份验证的私钥文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp -i /path/to/private_key username@remote_host</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>-P：</strong> 指定远程服务器的端口号，默认为 22。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp -P 2222 username@remote_host</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>sftp</code> 是一个交互式的命令行工具，用户可以在交互模式下输入命令。</li>
<li>文件上传和下载时，文件的路径和名称可以在本地和远程之间指定。</li>
<li><code>sftp</code> 提供了类似于 FTP 的命令，但是由于使用了 SSH 进行加密，传输过程更加安全。</li>
<li>可以使用 <code>help</code> 命令在 <code>sftp</code> 中查看可用的命令。</li>
</ul>
<p><code>sftp</code> 是一个灵活且安全的文件传输工具，适用于需要通过 SSH 加密传输文件的场景。在使用 <code>sftp</code> 时，请确保你有正确的权限来读取本地文件和写入远程服务器上的目标路径。</p>
<h2 id="linux-ssh密钥对详解"><a href="#linux-ssh密钥对详解" class="headerlink" title="linux ssh密钥对详解"></a>linux ssh密钥对详解</h2><p>在 Linux 系统中，SSH 密钥对是一种用于身份验证和安全传输的机制。密钥对包括公钥和私钥，这两者一起工作以确保安全的通信。以下是关于 Linux 中 SSH 密钥对的详细解释：</p>
<h3 id="SSH-密钥对的组成："><a href="#SSH-密钥对的组成：" class="headerlink" title="SSH 密钥对的组成："></a>SSH 密钥对的组成：</h3><ol>
<li><p><strong>公钥 (<code>id_rsa.pub</code>)：</strong></p>
<ul>
<li>公钥是可以公开分享的部分，用于验证与私钥配对的身份。它通常保存在用户的 <code>~/.ssh/</code> 目录下，文件名为 <code>id_rsa.pub</code>。</li>
<li>公钥是一串文本，类似于以下示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC+6czkGk...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>私钥 (<code>id_rsa</code>)：</strong></p>
<ul>
<li>私钥是必须保持安全的部分，只有拥有私钥的用户可以使用它来进行身份验证。私钥通常保存在用户的 <code>~/.ssh/</code> 目录下，文件名为 <code>id_rsa</code>。</li>
<li>私钥是二进制数据，通常不会直接以文本形式显示。</li>
</ul>
</li>
</ol>
<h3 id="生成-SSH-密钥对："><a href="#生成-SSH-密钥对：" class="headerlink" title="生成 SSH 密钥对："></a>生成 SSH 密钥对：</h3><p>可以使用 <code>ssh-keygen</code> 命令生成 SSH 密钥对。默认情况下，生成的密钥对将保存在用户的 <code>~/.ssh/</code> 目录下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 2048</span><br></pre></td></tr></table></figure>

<p>上述命令将生成一个 RSA 类型的密钥对，位数为 2048。根据需要，可以选择其他密钥类型和位数。</p>
<h3 id="将公钥部署到远程服务器："><a href="#将公钥部署到远程服务器：" class="headerlink" title="将公钥部署到远程服务器："></a>将公钥部署到远程服务器：</h3><ol>
<li><p><strong>手动复制：</strong></p>
<ul>
<li>使用 <code>ssh-copy-id</code> 或手动将公钥内容复制到远程服务器的 <code>~/.ssh/authorized_keys</code> 文件中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id username@remote_host</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>复制到剪贴板：</strong></p>
<ul>
<li>使用 <code>xclip</code> 或 <code>pbcopy</code> 将公钥复制到剪贴板，然后粘贴到远程服务器上的 <code>~/.ssh/authorized_keys</code> 文件中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub | xclip -sel clip</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="使用-SSH-密钥对进行身份验证："><a href="#使用-SSH-密钥对进行身份验证：" class="headerlink" title="使用 SSH 密钥对进行身份验证："></a>使用 SSH 密钥对进行身份验证：</h3><ol>
<li><p><strong>在登录时指定私钥：</strong></p>
<ul>
<li>在 <code>ssh</code> 命令中使用 <code>-i</code> 选项指定私钥文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i /path/to/private_key username@remote_host</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用 SSH Agent：</strong></p>
<ul>
<li>将私钥添加到 SSH Agent 中，以免在每次连接时输入密码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add /path/to/private_key</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><p><strong>私钥安全性：</strong></p>
<ul>
<li>私钥应该始终保持安全，不要与他人共享，以免被滥用。</li>
<li>私钥文件的权限应设置为只有拥有者可读写 (<code>chmod 600 ~/.ssh/id_rsa</code>)。</li>
</ul>
</li>
<li><p><strong>公钥部署：</strong></p>
<ul>
<li>将公钥部署到所有需要访问的远程服务器上，以实现无密码或密钥登录。</li>
<li>在远程服务器上的 <code>~/.ssh/authorized_keys</code> 文件中可以包含多个公钥，每行一个。</li>
</ul>
</li>
</ul>
<p>SSH 密钥对提供了一种强大且安全的身份验证机制，适用于远程登录、文件传输等场景。密钥对的生成和使用都涉及到一些注意事项，确保密钥的安全和正确配置是使用 SSH 密钥对的关键。</p>
<h2 id="Could-not-open-a-connection-to-your-authentication-agent-错误"><a href="#Could-not-open-a-connection-to-your-authentication-agent-错误" class="headerlink" title="Could not open a connection to your authentication agent 错误"></a>Could not open a connection to your authentication agent 错误</h2><p>如果您在执行 <code>ssh-add</code> 命令时收到 “Could not open a connection to your authentication agent” 错误，这通常意味着SSH Agent并未在当前的Shell会话中运行。以下是一些可能的原因和解决方法：</p>
<ol>
<li><p><strong>SSH Agent未启动：</strong> 请确保SSH Agent已经启动。您可以通过运行以下命令来启动SSH Agent：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Shell环境问题：</strong> 如果您在新的Shell窗口中运行 <code>ssh-add</code>，请确保您的SSH Agent环境变量已经被正确设置。您可以通过运行以下命令来检查：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$SSH_AGENT_PID</span></span><br></pre></td></tr></table></figure>

<p> 如果没有输出，或者输出为空，可能需要重新启动SSH Agent。</p>
</li>
<li><p><strong>SSH Agent自动启动问题：</strong> 如果您在每次登录时都遇到此问题，可能是因为SSH Agent没有在登录时自动启动。您可以将SSH Agent启动命令添加到您的shell配置文件中（例如，<code>.bashrc</code> 或 <code>.zshrc</code>）。</p>
<p>在文件末尾添加以下行：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$SSH_AUTH_SOCK</span>&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">    ssh-add</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>这将在每次登录时检查SSH Agent是否运行，如果没有，则启动并添加私钥。</p>
</li>
<li><p><strong>重新启动SSH Agent：</strong> 如果以上步骤都没有解决问题，可以尝试重新启动SSH Agent。首先，停止当前运行的SSH Agent：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent -k</span><br></pre></td></tr></table></figure>

<p> 然后重新启动SSH Agent：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>尝试这些步骤后，您应该能够成功将私钥添加到SSH Agent中。如果问题仍然存在，请提供更多详细信息，以便我能够提供更具体的帮助。</p>
<h2 id="Linux-openssh端口转发详解"><a href="#Linux-openssh端口转发详解" class="headerlink" title="Linux openssh端口转发详解"></a>Linux openssh端口转发详解</h2><p>在 Linux 下，OpenSSH 提供了强大的端口转发功能，可以通过 SSH 通道安全地传输其他网络流量。端口转发（Port Forwarding）允许你在本地计算机和远程服务器之间建立加密的通信通道，从而访问远程网络服务或将本地服务映射到远程服务器上。有两种主要类型的端口转发：本地端口转发（Local Port Forwarding）和远程端口转发（Remote Port Forwarding）。</p>
<h3 id="1-本地端口转发（Local-Port-Forwarding）："><a href="#1-本地端口转发（Local-Port-Forwarding）：" class="headerlink" title="1. 本地端口转发（Local Port Forwarding）："></a>1. 本地端口转发（Local Port Forwarding）：</h3><p>本地端口转发允许你将本地计算机上的端口转发到远程服务器上。通常用于访问远程服务器上的服务，如数据库或内部网站。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L local_port:remote_host:remote_port username@remote_server</span><br></pre></td></tr></table></figure>

<ul>
<li><code>local_port</code>：本地计算机上监听的端口。</li>
<li><code>remote_host</code>：远程服务器上服务的主机名或 IP 地址。</li>
<li><code>remote_port</code>：远程服务器上服务的端口。</li>
</ul>
<p>示例：将本地计算机的本地端口 8080 转发到远程服务器的 80 端口（Web 服务器）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 8080:localhost:80 username@remote_server</span><br></pre></td></tr></table></figure>

<p>现在，可以在本地浏览器中访问 <code>http://localhost:8080</code> 来访问远程服务器上的 Web 服务。</p>
<h3 id="2-远程端口转发（Remote-Port-Forwarding）："><a href="#2-远程端口转发（Remote-Port-Forwarding）：" class="headerlink" title="2. 远程端口转发（Remote Port Forwarding）："></a>2. 远程端口转发（Remote Port Forwarding）：</h3><p>远程端口转发允许你将远程服务器上的端口转发到本地计算机上。通常用于暴露本地服务，使其可以通过远程服务器访问。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R remote_port:local_host:local_port username@remote_server</span><br></pre></td></tr></table></figure>

<ul>
<li><code>remote_port</code>：远程服务器上监听的端口。</li>
<li><code>local_host</code>：本地计算机上服务的主机名或 IP 地址。</li>
<li><code>local_port</code>：本地计算机上服务的端口。</li>
</ul>
<p>示例：将远程服务器的远程端口 8888 转发到本地计算机的 22 端口（SSH 服务）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R 8888:localhost:22 username@remote_server</span><br></pre></td></tr></table></figure>

<p>现在，可以在远程服务器上通过 <code>ssh -p 8888 localhost</code> 来访问本地计算机上的 SSH 服务。</p>
<h3 id="注意事项：-3"><a href="#注意事项：-3" class="headerlink" title="注意事项："></a>注意事项：</h3><ol>
<li><p><strong>防火墙设置：</strong></p>
<ul>
<li>确保本地计算机和远程服务器的防火墙允许相应的端口访问。</li>
</ul>
</li>
<li><p><strong>SSH 服务器配置：</strong></p>
<ul>
<li>在远程服务器上，确保 SSH 服务器的配置文件允许相应的端口转发。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/ssh/sshd_config</span></span><br><span class="line">AllowTcpForwarding <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安全性：</strong></p>
<ul>
<li>使用端口转发时，务必注意安全性。不要将本地服务直接暴露到公共网络上，应仅限制访问到必要的主机。</li>
</ul>
</li>
<li><p><strong>通道保持活跃：</strong></p>
<ul>
<li>添加 <code>-N</code> 选项可以防止 <code>ssh</code> 命令打开 shell，从而只建立端口转发通道而不登录到远程服务器。</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -N -L local_port:remote_host:remote_port username@remote_server</span><br></pre></td></tr></table></figure>

<p>端口转发是 SSH 功能中非常有用的一部分，它可以使你在不直接暴露服务的情况下安全地访问远程服务器上的服务。</p>
<h2 id="OpenSSH-相关命令"><a href="#OpenSSH-相关命令" class="headerlink" title="OpenSSH 相关命令"></a>OpenSSH 相关命令</h2><p>OpenSSH是一个用于安全远程登录的开源工具套件，提供了一系列命令和协议用于远程访问和管理Linux系统。以下是一些常用的OpenSSH相关命令：</p>
<ol>
<li><p>ssh：远程登录到服务器或执行远程命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@hostname</span><br></pre></td></tr></table></figure>
<p>其中，<code>user</code>是远程服务器的用户名，<code>hostname</code>是远程服务器的主机名或IP地址。</p>
</li>
<li><p>scp：安全地复制文件和目录到远程服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp source_file user@hostname:destination_path</span><br></pre></td></tr></table></figure>
<p>其中，<code>source_file</code>是本地文件路径，<code>user</code>是远程服务器的用户名，<code>hostname</code>是远程服务器的主机名或IP地址，<code>destination_path</code>是远程服务器上的目标路径。</p>
</li>
<li><p>sftp：使用类似FTP的方式在本地系统和远程服务器之间传输文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp user@hostname</span><br></pre></td></tr></table></figure>
<p>通过此命令进入sftp会话后，可以执行一系列文件传输操作。</p>
</li>
<li><p>ssh-keygen：生成和管理SSH密钥对。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>该命令用于生成RSA密钥对，可以使用其他选项指定密钥类型和文件名等。</p>
</li>
<li><p>ssh-agent：管理SSH代理，用于管理私钥并免密码登录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval $(ssh-agent)</span><br></pre></td></tr></table></figure>
<p>该命令启动ssh-agent代理，并将其相关环境变量设置为当前shell的环境变量。</p>
</li>
<li><p>ssh-add：将私钥添加到ssh-agent代理中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>该命令将指定的私钥添加到ssh-agent代理中，以便在进行SSH身份验证时使用。</p>
</li>
</ol>
<p>这些命令是OpenSSH套件中的一部分，用于实现安全远程登录和文件传输等功能。请根据具体需求和情况选择适当的命令使用。</p>
<hr>
<h2 id="ssh-exchange-identification-read-Connection-reset-by-peer-错误"><a href="#ssh-exchange-identification-read-Connection-reset-by-peer-错误" class="headerlink" title="ssh_exchange_identification: read: Connection reset by peer 错误"></a>ssh_exchange_identification: read: Connection reset by peer 错误</h2><p>当你在使用SSH连接时，出现”ssh_exchange_identification: read: Connection reset by peer”错误，通常表示SSH连接被对方终止了。这可能是由于以下几个原因导致的：</p>
<ol>
<li><p>网络连接问题：这可能是由于网络中断、丢包或不稳定的连接导致的。请确保你的网络连接正常，并尝试重新连接。</p>
</li>
<li><p>SSH服务器配置问题：可能是SSH服务器配置有问题，导致连接被终止。你可以尝试重新启动SSH服务器或检查其配置文件以查找潜在的问题。</p>
</li>
<li><p>防火墙或安全设置：防火墙或其他安全设置可能会阻止SSH连接。确保你的防火墙设置允许SSH流量通过，并且服务器端没有任何限制。</p>
</li>
<li><p>SSH版本不匹配：如果你使用的SSH客户端和服务器端之间的SSH协议版本不匹配，可能会导致连接被重置。尝试使用兼容的SSH版本，或者更新SSH客户端和服务器端以确保版本一致。</p>
</li>
<li><p>SSH服务器负载过高：如果SSH服务器负载过高，可能无法处理新的连接请求，从而导致连接被重置。尝试在负载较低的时间重新连接。</p>
</li>
</ol>
<p>如果以上方法都无效，你可以尝试使用其他SSH客户端或与SSH服务器管理员联系以获取更多支持和故障排除。</p>
<hr>
<h2 id="ssh-允许root登录"><a href="#ssh-允许root登录" class="headerlink" title="ssh 允许root登录"></a>ssh 允许root登录</h2><ul>
<li>文件：&#x2F;etc&#x2F;ssh&#x2F;sshd_config<ul>
<li><code>PermitRootLogin yes</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="ssh-安装与配置"><a href="#ssh-安装与配置" class="headerlink" title="ssh 安装与配置"></a>ssh 安装与配置</h2><ul>
<li>一般ubuntu都会默认安装openssh-client,但是没有安装openssh-server</li>
<li>安装ssh服务器:<ul>
<li><code>sudo apt-get install openssh-server</code></li>
</ul>
</li>
<li>安装ssh客户端:<ul>
<li><code>sudo apt-get install openssh-client</code></li>
</ul>
</li>
<li>查看端口:<ul>
<li><code>netstat -tunpl | grep 22</code></li>
</ul>
</li>
<li>查看ssh状态:<ul>
<li><code>service sshd status</code></li>
</ul>
</li>
<li>重启ssh服务:<ul>
<li><code>service sshd restart</code> | <code>sudo /etc/init.d/ssh restart</code></li>
</ul>
</li>
<li>ssh配置文件:<ul>
<li><code>/etc/ssh/ssh_config</code> | <code>/etc/ssh/sshd_config</code></li>
<li><code>PasswordAuthentication yes</code></li>
<li><code>PermitRootLogin yes</code></li>
<li><code># PermitRootLogin prohibit-password</code></li>
</ul>
</li>
</ul>
<h2 id="SSH-基础知识"><a href="#SSH-基础知识" class="headerlink" title="SSH 基础知识"></a>SSH 基础知识</h2><ul>
<li><p>SSH的全称为<code>Secure Shell</code>，即安全外壳协议，是一种加密的网络传输协议。它能够在公开的网络环境中提供安全的数据传输环境，通常用于登陆远程主机和推拉代码。</p>
</li>
<li><p>同样一个SSH公钥文件，如果添加至某一个代码仓库，则称为部署公钥，配置后默认拥有读项目的只读权限，支持新增读写权限；</p>
</li>
<li><p>如果添加至团队设置中心，则称为团队部署公钥，仅拥有只读权限；</p>
</li>
<li><p>如果添加至个人账户，称为账户SSH公钥，配置后拥有账户内所有代码仓库的读写权限。</p>
</li>
<li><p>同一个SSH公钥无法即作为部署公钥，又作为个人账户SSH公钥</p>
</li>
<li><p>生成公钥 – 使用<code>ssh-keygen</code>工具生成SSH公钥</p>
<ul>
<li>&#96;ssh-keygen -m PEM -t ed25519 -C “<a href="mailto:&#x79;&#111;&#x75;&#x72;&#x2e;&#x65;&#x6d;&#97;&#105;&#108;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;">&#x79;&#111;&#x75;&#x72;&#x2e;&#x65;&#x6d;&#97;&#105;&#108;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;</a>“  &#x2F;&#x2F; 创建新的SSH私钥和公钥对</li>
</ul>
</li>
<li><p>添加至部署公钥</p>
<ul>
<li>打开生成的密钥对的地址，通常为<code>~/.ssh 文件夹</code> , 找到后缀为<code>pub</code>的文件</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h2><p><code>ssh-keygen</code>命令是Linux系统中用于生成SSH密钥对的工具。SSH密钥对由一对公钥和私钥组成，用于身份验证和安全通信。</p>
<p>下面是<code>ssh-keygen</code>命令的一些常见选项和用法：</p>
<ol>
<li><p>生成RSA密钥对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>这将生成一个RSA密钥对，默认情况下，公钥文件为<code>id_rsa.pub</code>，私钥文件为<code>id_rsa</code>。</p>
</li>
<li><p>生成DSA密钥对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t dsa</span><br></pre></td></tr></table></figure>
<p>这将生成一个DSA密钥对，默认情况下，公钥文件为<code>id_dsa.pub</code>，私钥文件为<code>id_dsa</code>。</p>
</li>
<li><p>生成ECDSA密钥对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ecdsa</span><br></pre></td></tr></table></figure>
<p>这将生成一个ECDSA密钥对，默认情况下，公钥文件为<code>id_ecdsa.pub</code>，私钥文件为<code>id_ecdsa</code>。</p>
</li>
<li><p>生成ED25519密钥对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519</span><br></pre></td></tr></table></figure>
<p>这将生成一个ED25519密钥对，默认情况下，公钥文件为<code>id_ed25519.pub</code>，私钥文件为<code>id_ed25519</code>。</p>
</li>
<li><p>指定密钥文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>-f</code>选项可以指定生成的密钥文件的文件名。例如，<code>ssh-keygen -f mykey</code>将生成<code>mykey</code>作为文件名的密钥对。</p>
</li>
<li><p>设置密钥密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p</span><br></pre></td></tr></table></figure>
<p>使用<code>-p</code>选项可以更改已有密钥文件的密码。</p>
</li>
<li><p>查看密钥指纹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -lf &lt;public_key_file&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>-lf</code>选项可以查看公钥文件的指纹。</p>
</li>
</ol>
<p>以上是一些常见的<code>ssh-keygen</code>命令选项和用法。生成密钥对后，可以将公钥文件部署到服务器上，以便进行SSH身份验证。私钥文件应该妥善保管，不应与他人共享。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_13_free/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_13_free/" class="post-title-link" itemprop="url">linux_2_13_free</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>free命令</li>
</ul>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><ul>
<li><p>Linux free命令用于显示内存状态。</p>
</li>
<li><p>free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>free [-bkmotV][-s &lt;间隔秒数&gt;]</code></li>
</ul>
</li>
<li><p>参数说明：</p>
<ul>
<li>-b 　以Byte为单位显示内存使用情况。</li>
<li>-k 　以KB为单位显示内存使用情况。</li>
<li>-m 　以MB为单位显示内存使用情况。</li>
<li>-h 　以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有：<ul>
<li>B &#x3D; bytes</li>
<li>K &#x3D; kilos</li>
<li>M &#x3D; megas</li>
<li>G &#x3D; gigas</li>
<li>T &#x3D; teras</li>
</ul>
</li>
<li>-o 　不显示缓冲区调节列。</li>
<li>-s&lt;间隔秒数&gt; 　持续观察内存使用状况。</li>
<li>-t 　显示内存总和列。</li>
<li>-V 　显示版本信息。</li>
</ul>
</li>
<li><p>实例：</p>
<ul>
<li>以总和的形式显示内存的使用信息 : <code>free -t //以总和的形式查询内存的使用信息</code></li>
<li>周期性的查询内存使用信息 : <code>free -s 10 //每10s 执行一次命令</code></li>
</ul>
</li>
</ul>
<h2 id="linux-free命令-详解"><a href="#linux-free命令-详解" class="headerlink" title="linux free命令 详解"></a>linux free命令 详解</h2><p><code>free</code> 命令用于显示系统中的内存使用情况，包括物理内存和交换空间。以下是 <code>free</code> 命令的详解：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [选项]</span><br></pre></td></tr></table></figure>

<p><strong>常用选项：</strong></p>
<ul>
<li><code>-b</code>：以字节为单位显示内存使用情况。</li>
<li><code>-k</code>：以千字节为单位显示内存使用情况（默认选项）。</li>
<li><code>-m</code>：以兆字节为单位显示内存使用情况。</li>
<li><code>-g</code>：以吉字节为单位显示内存使用情况。</li>
<li><code>-t</code>：显示总计行，将所有内存列的总和显示出来。</li>
<li><code>-h</code>：以人类可读的格式显示内存大小。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>

<p><strong>输出示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7827        3245         872        1065        3710        2708</span><br><span class="line">Swap:          8191           0        8191</span><br></pre></td></tr></table></figure>

<p><strong>字段解释：</strong></p>
<ul>
<li><code>total</code>: 总内存</li>
<li><code>used</code>: 已使用的内存</li>
<li><code>free</code>: 空闲内存</li>
<li><code>shared</code>: 多个进程共享的内存</li>
<li><code>buff/cache</code>: 用于缓存的内存，包括文件系统缓存和用于磁盘 I&#x2F;O 的缓冲区</li>
<li><code>available</code>: 可用内存，即系统可以提供给新进程使用的内存</li>
<li><code>Swap</code>: 交换空间，包括 <code>total</code>（总交换空间）、<code>used</code>（已使用的交换空间）和 <code>free</code>（空闲的交换空间）</li>
</ul>
<p><code>free</code> 命令的输出可以帮助你了解系统的内存使用情况，特别是在监控系统性能或诊断性能问题时。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_02_other/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_02_other/" class="post-title-link" itemprop="url">linux_2_02_other</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>不同的终端类型、Shell版本其中断的按键是不同的，甚至还可以自定义，这可通过stty命令查询：<code>sitty -a</code></li>
<li>注意：<code>^</code>是Ctrl的缩写</li>
</ul>
<h2 id="终端初始化脚本"><a href="#终端初始化脚本" class="headerlink" title="终端初始化脚本"></a>终端初始化脚本</h2><ul>
<li>参考：<ul>
<li><code>https://www.cnblogs.com/yoyo-sincerely/p/5931245.html</code></li>
</ul>
</li>
</ul>
<h2 id="显示路径问题"><a href="#显示路径问题" class="headerlink" title="显示路径问题"></a>显示路径问题</h2><ul>
<li><p><code>\w</code>  –  当前工作目录，例如<code>/home/user</code></p>
</li>
<li><p><code>\W</code>  –  当前工作目录的基名(basename)，例如<code>user</code></p>
</li>
<li><p>解决问题：终端显示路径太长，不易于阅读</p>
</li>
<li><p>解决方法：将<code>.bashrc</code>中的<code>\w</code>更换为<code>\W</code></p>
</li>
</ul>
<h2 id="MD5校验"><a href="#MD5校验" class="headerlink" title="MD5校验"></a>MD5校验</h2><ul>
<li>Windows下生成md5校验码: <code>certutil -hashfile filename MD5</code></li>
<li>Linux下生成md5校验码:   <code>md5sum filename</code></li>
</ul>
<h2 id="文件名通配符"><a href="#文件名通配符" class="headerlink" title="文件名通配符"></a>文件名通配符</h2><ul>
<li><code>×</code>：与0个或多个任意的字符相匹配</li>
<li><code>？</code>：只与单个任意的字符匹配，可以使用多个问号</li>
<li><code>[]</code>：与<code>？</code>相似，只与一个字符匹配。区别在于：问号与任意一个字符匹配，而方括号只与方括号中列出的字符之一匹配。短横线（<code>-</code>）代表一个范围内的字符。注：只能是升序</li>
</ul>
<h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><ul>
<li>sudo, superuser do</li>
</ul>
<p>在Linux中，<code>sudo</code>是一种命令行工具，用于以超级用户（也称为root用户）的权限执行其他命令。它允许普通用户在需要执行特权操作时临时获得root权限，从而执行需要管理员权限的任务，而无需切换到root用户。</p>
<p>以下是<code>sudo</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo [options] command [arguments]</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code>是可选的一些选项，<code>command</code>是要以root权限执行的命令，<code>arguments</code>是传递给命令的参数。</p>
<p>以下是一些常见的<code>sudo</code>命令选项和用法：</p>
<ol>
<li><p>以root权限执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo command</span><br></pre></td></tr></table></figure>

<p>此命令将以root权限执行<code>command</code>命令。</p>
</li>
<li><p>切换到root用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -i</span><br></pre></td></tr></table></figure>

<p>此命令将打开一个新的shell会话，并切换到root用户身份。</p>
</li>
<li><p>以其他用户身份执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u username command</span><br></pre></td></tr></table></figure>

<p>此命令将以指定用户（<code>username</code>）的权限执行<code>command</code>命令。</p>
</li>
<li><p>查看sudo命令的使用情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -h</span><br></pre></td></tr></table></figure>

<p>此命令将显示<code>sudo</code>命令的帮助信息，包括选项和用法。</p>
</li>
<li><p>列出当前用户的sudo权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure>

<p>此命令将列出当前用户可以使用<code>sudo</code>执行的命令列表。</p>
</li>
</ol>
<p>通过使用<code>sudo</code>命令，系统管理员可以授予特定的权限给普通用户，使其能够执行有限的特权操作，同时避免了在整个会话中使用root权限的风险。这提供了更好的系统安全性和管理员对系统的更细粒度控制。</p>
<p>需要注意的是，只有在<code>/etc/sudoers</code>文件中明确配置了用户的sudo权限，用户才能使用<code>sudo</code>命令。只有具备sudo权限的用户才能成功执行以root权限执行的命令。</p>
<h2 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h2><ul>
<li>supervisor, 是一个客户端&#x2F;服务器系统,它允许用户监视和控制类UNIX操作系统上的许多进程,是linux下一个便利的启动和监控服务的命令</li>
<li>Supervisor, 是用Python开发的一个client&#x2F;server服务,是Linux&#x2F;Unix系统下的一个进程管理工具,不支持Windows系统.它可以很方便的监听,启动,停止,重启一个或多个进程</li>
<li>用Supervisor管理的进程,当一个进程意外被杀死,supervisor监听到进程死后,会自动将它重新拉起,很方便的做到进程自动恢复的功能,不再需要自己写shell脚本来控制.</li>
<li>因为Supervisor是Python开发的,安装前先检查一下系统是否安装了Python2.4以上的版本</li>
<li>supervisor包括两个命令:supervisord, supervisorctl,分别是后台的守护进程以及命令行管理命令.</li>
<li>supervisor安装完成后会生成是三个执行程序:<code>supervisortd</code>, <code>supervisorctl</code>, <code>echo_supervisord_conf</code><ul>
<li><code>supervisortd</code>, 用于管理supervisor本身服务</li>
<li><code>supervisorctl</code>, 用于管理需要委托给supervisor工具的服务</li>
<li><code>echo_supervisord_conf</code>, 用于生成supervisor的配置文件</li>
<li>supervisor的守护进程服务(用于接受进程管理命令),客户端(用于和守护进程通信,发送管理进程的指令)</li>
</ul>
</li>
<li>两个命令共用一个配置文件,默认是:<code>/etc/supervisor/supervisor.conf</code>,而<code>supervisor.conf</code>通过include来引入其他配置文件,一般放在<code>/etc/supervisor/conf.d</code>目录下</li>
</ul>
<h2 id="redshift"><a href="#redshift" class="headerlink" title="redshift"></a>redshift</h2><p>在Linux中，<code>redshift</code>是一种用于调整屏幕颜色温度的命令行工具。它可以通过减少屏幕的蓝光成分来减轻视觉疲劳，并在晚上或低光环境下提供更舒适的视觉体验。</p>
<p>下面是<code>redshift</code>命令的一些常见选项和用法：</p>
<ol>
<li><p>基本用法：</p>
<ul>
<li>启动<code>redshift</code>：<code>redshift</code></li>
<li>停止<code>redshift</code>：<code>redshift -x</code></li>
</ul>
</li>
<li><p>调整颜色温度：</p>
<ul>
<li>使用<code>-t</code>选项指定颜色温度（单位为开尔文）：<code>redshift -t 4000</code></li>
<li>使用<code>-b</code>选项指定颜色温度并降低亮度：<code>redshift -b 0.8 -t 4000</code></li>
</ul>
</li>
<li><p>调整定位信息：</p>
<ul>
<li>使用<code>-l</code>选项指定纬度和经度以计算日出和日落时间：<code>redshift -l LAT:LON</code></li>
<li>例如：<code>redshift -l 37.8:-122.4</code>（设定位置为旧金山）</li>
</ul>
</li>
<li><p>调整亮度：</p>
<ul>
<li>使用<code>-m</code>选项启用亮度调整模式：<code>redshift -m METHOD</code></li>
<li>方法包括<code>randr</code>（默认值）和<code>vidmode</code></li>
</ul>
</li>
<li><p>调整亮度变化速度：</p>
<ul>
<li>使用<code>-r</code>选项指定亮度变化速度（单位为小时）：<code>redshift -r SPEED</code></li>
</ul>
</li>
<li><p>自定义配置文件：</p>
<ul>
<li>使用<code>-c</code>选项指定自定义配置文件的路径：<code>redshift -c /path/to/config</code></li>
</ul>
</li>
<li><p>显示调试信息：</p>
<ul>
<li>使用<code>-v</code>选项显示详细的调试信息：<code>redshift -v</code></li>
</ul>
</li>
</ol>
<p>以上是一些常见的<code>redshift</code>命令选项和用法示例。请注意，<code>redshift</code>命令需要正确配置和运行，以便根据位置和时间自动调整屏幕颜色温度。您可以根据自己的需求和喜好来调整命令的参数，以达到最佳的视觉效果。</p>
<h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><ul>
<li>在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具。支持文件的上传和下载，是综合传输工具，但是按照传统，习惯称curl为下载工具</li>
<li>参数<ul>
<li><code>-f / --fail</code> : 连接失败时不显示http错误</li>
<li><code>-s / --silent</code> : 静音模式，不输出任何东西</li>
<li><code>-S / --show-error</code> : 当与<code>-s</code>一起使用时，如果<code>curl</code>失败，<code>curl</code>将显示一条错误消息</li>
<li><code>-L / --location</code> : （HTTP&#x2F;HTTPS）跟踪重定向。如果服务器报告请求页面已移动到另一个位置，此选项将使curl在新位置上重做请求</li>
</ul>
</li>
</ul>
<p>在Linux中，<code>curl</code>命令是一个功能强大的网络工具，用于与服务器进行数据交互。它支持多种协议，包括HTTP、HTTPS、FTP、SMTP等，并可以执行各种操作，如下载文件、发送请求、上传文件等。</p>
<p>以下是<code>curl</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [options] [URL]</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code>是可选的一些选项，用于配置<code>curl</code>的行为，<code>URL</code>是要访问的目标地址。</p>
<p>以下是一些常见的<code>curl</code>命令选项和用法：</p>
<ol>
<li><p>发送HTTP GET请求并输出响应内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://example.com</span><br></pre></td></tr></table></figure>

<p>此命令将向<code>http://example.com</code>发送HTTP GET请求，并将响应内容输出到终端。</p>
</li>
<li><p>下载文件到本地：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://example.com/file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将从<code>http://example.com/file.txt</code>下载文件，并保存到当前目录下的<code>file.txt</code>文件。</p>
</li>
<li><p>发送POST请求并传递参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &quot;param1=value1&amp;param2=value2&quot; -X POST http://example.com/api</span><br></pre></td></tr></table></figure>

<p>此命令将向<code>http://example.com/api</code>发送HTTP POST请求，并将参数<code>param1=value1&amp;param2=value2</code>作为请求体发送。</p>
</li>
</ol>
<p><code>curl</code>命令还支持其他许多选项，如设置请求头、设置超时时间、处理重定向等。</p>
<p>使用<code>curl</code>命令可以方便地进行各种网络操作，如获取API数据、下载文件、测试网络连接等。它是一种非常强大和灵活的工具，广泛应用于开发、调试和自动化脚本等场景。</p>
<hr>
<h2 id="curl-–data-binary"><a href="#curl-–data-binary" class="headerlink" title="curl –data-binary"></a>curl –data-binary</h2><p><code>curl</code> 是一个命令行工具，用于进行 HTTP 请求。<code>--data-binary</code> 选项用于在 HTTP POST 请求中发送二进制数据作为请求体。以下是对该选项的详细解释：</p>
<p>当你在 <code>curl</code> 中使用 <code>--data-binary</code> 选项时，你需要提供要发送的数据作为请求体。这些数据可以是二进制数据，即可以包含非文本字符或不适合解释为纯文本的格式。例如，它可以是图像文件、视频文件或任何其他类型的二进制数据。</p>
<p><code>--data-binary</code> 选项期望你在命令行上直接指定数据，通常需要使用引号将其括起来，以保留任何特殊字符或格式。以下是一个示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --data-binary &quot;@文件名&quot; URL</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>@文件名</code> 表示包含要发送的二进制数据的文件路径。<code>@</code> 符号告诉 <code>curl</code> 读取文件的内容并将其用作请求体。</p>
<p>另外，你也可以直接在命令行上内联指定二进制数据，而无需使用文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --data-binary &quot;二进制数据&quot; URL</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>&quot;二进制数据&quot;</code> 表示你要发送的实际二进制数据。如果需要，确保正确编码数据，特别是如果数据包含可能被命令行解释器解释为特殊字符的字符。</p>
<p>当 <code>curl</code> 使用 <code>--data-binary</code> 选项发送 HTTP 请求时，默认情况下会将 <code>Content-Type</code> 头设置为 <code>application/octet-stream</code>。这向服务器表明请求体包含未知或未指定类型的二进制数据。如果需要指定其他内容类型，可以使用 <code>--header</code> 选项设置适当的头部。</p>
<p>值得注意的是，<code>--data-binary</code> 与 <code>curl</code> 中的 <code>--data</code> 选项是不同的。<code>--data</code> 选项用于将数据作为请求体发送，但它将数据视为纯文本，进行字符编码和特殊字符解释。相比之下，<code>--data-binary</code> 保留了数据的二进制特性，没有进行任何修改。</p>
<p>请记得将 “文件名” 替换为实际的文件路径，或将 “二进制数据” 替换为要发送的二进制数据，并将 “URL” 替换为要发送请求的服务器的 URL。</p>
<h2 id="xdg-user-dirs-upate"><a href="#xdg-user-dirs-upate" class="headerlink" title="xdg-user-dirs-upate"></a>xdg-user-dirs-upate</h2><ul>
<li>该命令会读取配置文件<code>/etc/xdg/user-dirs.defaults</code>,并在<code>$HOME</code>下创建一整套默认的经本地化的用户目录</li>
</ul>
<p><code>xdg-user-dirs-update</code>命令是一个用于更新用户目录的工具，它在Linux系统中用于管理用户的标准目录，例如桌面、下载、文档、音乐、图片等目录。</p>
<p>在Linux系统中，用户目录的路径通常存储在<code>~/.config/user-dirs.dirs</code>文件中。<code>xdg-user-dirs-update</code>命令用于根据配置文件中定义的规则，更新用户目录的路径和名称。</p>
<p>以下是<code>xdg-user-dirs-update</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xdg-user-dirs-update</span><br></pre></td></tr></table></figure>

<p>运行<code>xdg-user-dirs-update</code>命令将读取<code>~/.config/user-dirs.dirs</code>文件中的配置信息，并根据配置更新用户目录的路径和名称。</p>
<p><code>~/.config/user-dirs.dirs</code>文件的示例内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XDG_DESKTOP_DIR=&quot;$HOME/Desktop&quot;</span><br><span class="line">XDG_DOWNLOAD_DIR=&quot;$HOME/Downloads&quot;</span><br><span class="line">XDG_DOCUMENTS_DIR=&quot;$HOME/Documents&quot;</span><br><span class="line">XDG_MUSIC_DIR=&quot;$HOME/Music&quot;</span><br><span class="line">XDG_PICTURES_DIR=&quot;$HOME/Pictures&quot;</span><br><span class="line">XDG_VIDEOS_DIR=&quot;$HOME/Videos&quot;</span><br></pre></td></tr></table></figure>

<p>上述配置定义了标准的用户目录路径，如桌面、下载、文档、音乐、图片和视频目录。</p>
<p>运行<code>xdg-user-dirs-update</code>命令后，它将根据配置文件的内容，自动创建相应的目录，并将用户的默认目录路径设置为配置文件中定义的路径。</p>
<p><code>xdg-user-dirs-update</code>命令通常在用户登录时自动执行，确保用户的标准目录存在且正确设置。</p>
<h2 id="gnome-screensaver-command"><a href="#gnome-screensaver-command" class="headerlink" title="gnome-screensaver-command"></a>gnome-screensaver-command</h2><p><code>gnome-screensaver-command</code> 是用于与 GNOME 屏幕保护程序交互的命令行工具。它允许你控制屏幕保护程序的状态、设置和操作。</p>
<p>以下是一些常用的 <code>gnome-screensaver-command</code> 命令及其功能：</p>
<ul>
<li><code>gnome-screensaver-command -a</code>：激活屏幕保护程序。这会立即启动屏幕保护程序并锁定屏幕，要解锁屏幕，你需要提供用户密码。</li>
<li><code>gnome-screensaver-command -d</code>：禁用屏幕保护程序。这会关闭屏幕保护程序的自动启动和锁定屏幕的功能。</li>
<li><code>gnome-screensaver-command -q</code>：查询屏幕保护程序的状态。它会返回屏幕保护程序是否激活和屏幕是否锁定的信息。</li>
<li><code>gnome-screensaver-command -l</code>：锁定屏幕。这会立即锁定屏幕，要解锁屏幕，你需要提供用户密码。</li>
</ul>
<p>这些是 <code>gnome-screensaver-command</code> 命令的一些示例。通过使用不同的选项，你可以进行更多的配置和操作，如设置屏幕保护程序的超时时间、配置锁定屏幕的效果等。</p>
<p>需要注意的是，<code>gnome-screensaver-command</code> 命令仅在使用 GNOME 桌面环境的 Linux 系统中可用。对于其他桌面环境或窗口管理器，可能有不同的命令或工具来控制屏幕保护程序。</p>
<p>希望这个解释对你有帮助！如有需要，请随时提问。</p>
<hr>
<h2 id="pulseaudio"><a href="#pulseaudio" class="headerlink" title="pulseaudio"></a>pulseaudio</h2><p>PulseAudio 是 Linux 上广泛使用的音频服务器和音频子系统。它提供了许多命令行工具来管理和控制音频设备、音频流和音量等。下面是一些常用的 PulseAudio 命令及其详解：</p>
<ol>
<li><p><code>pacmd</code>：<code>pacmd</code> 是 PulseAudio 的命令行控制界面，可以用于交互式地管理和监视 PulseAudio。通过输入 <code>pacmd</code> 进入交互模式，然后可以使用以下命令：</p>
<ul>
<li><p><code>list-sinks</code>：列出所有可用的音频输出设备（音频输出设备称为 “sink”）。</p>
</li>
<li><p><code>list-sources</code>：列出所有可用的音频输入设备（音频输入设备称为 “source”）。</p>
</li>
<li><p><code>list-clients</code>：列出所有当前连接到 PulseAudio 的客户端应用程序。</p>
</li>
<li><p><code>set-default-sink</code>：设置默认的音频输出设备。</p>
</li>
<li><p><code>set-default-source</code>：设置默认的音频输入设备。</p>
</li>
<li><p><code>set-sink-volume</code>：设置音频输出设备的音量。</p>
</li>
<li><p><code>set-source-volume</code>：设置音频输入设备的音量。</p>
</li>
<li><p><code>exit</code>：退出 <code>pacmd</code> 交互模式。</p>
</li>
</ul>
</li>
<li><p><code>pactl</code>：<code>pactl</code> 是 PulseAudio 的控制命令行工具，用于控制 PulseAudio 的运行状态和配置。下面是一些常用的 <code>pactl</code> 命令：</p>
<ul>
<li><p><code>pactl list</code>：列出当前 PulseAudio 状态的概览，包括音频设备、音频流和音量等信息。</p>
</li>
<li><p><code>pactl set-sink-volume</code>：设置音频输出设备的音量。</p>
</li>
<li><p><code>pactl set-source-volume</code>：设置音频输入设备的音量。</p>
</li>
<li><p><code>pactl set-default-sink</code>：设置默认的音频输出设备。</p>
</li>
<li><p><code>pactl set-default-source</code>：设置默认的音频输入设备。</p>
</li>
<li><p><code>pactl suspend</code>：暂停或恢复 PulseAudio 服务器。</p>
</li>
<li><p><code>pactl exit</code>：停止 PulseAudio 服务器。</p>
</li>
</ul>
</li>
<li><p><code>pavucontrol</code>：<code>pavucontrol</code> 是 PulseAudio 的图形用户界面控制面板，用于图形化地管理和控制 PulseAudio。可以通过命令行运行 <code>pavucontrol</code> 启动它。</p>
<p><code>pavucontrol</code> 提供了一个用户友好的界面，可以查看和调整每个应用程序的音频流、音量和音频设备等设置。</p>
</li>
</ol>
<p>这些命令只是 PulseAudio 提供的一部分工具和功能。你可以根据需要查阅相关文档和手册，或者使用命令的 <code>--help</code> 选项获取更详细的命令说明和选项信息。</p>
<hr>
<h2 id="alsamixer"><a href="#alsamixer" class="headerlink" title="alsamixer"></a>alsamixer</h2><p><code>alsamixer</code> 是 Linux 上用于调整 ALSA（Advanced Linux Sound Architecture）音频驱动的命令行工具。它提供了一个终端界面，允许你调整音频设备的音量、通道设置和其他音频参数。下面是一些常用的 <code>alsamixer</code> 命令及其详解：</p>
<ol>
<li><p><code>alsamixer</code>：直接运行 <code>alsamixer</code> 命令将打开一个终端窗口，显示当前音频设备的音量控制界面。</p>
<ul>
<li>使用左右箭头键切换不同的音频通道（如果有多个通道可用）。</li>
<li>使用上下箭头键调整当前通道的音量。</li>
<li>使用空格键切换静音状态。</li>
<li>使用 Esc 键退出 <code>alsamixer</code>。</li>
</ul>
</li>
<li><p><code>alsamixer -c &lt;card&gt;</code>：使用 <code>-c</code> 选项指定要控制的音频设备（声卡）。可以通过 <code>&lt;card&gt;</code> 参数指定声卡的编号或标识符。例如，<code>alsamixer -c 0</code> 或 <code>alsamixer -c hw:0</code>。</p>
</li>
<li><p><code>alsamixer -V &lt;view&gt;</code>：使用 <code>-V</code> 选项指定要显示的视图。视图可以是 <code>Playback</code>（播放），<code>Capture</code>（捕获）或 <code>All</code>（全部）。例如，<code>alsamixer -V Capture</code> 将只显示捕获设备的音量控制界面。</p>
</li>
<li><p><code>alsamixer -D &lt;device&gt;</code>：使用 <code>-D</code> 选项指定要控制的特定音频设备。可以通过 <code>&lt;device&gt;</code> 参数指定设备的名称或标识符。例如，<code>alsamixer -D hw:0,0</code>。</p>
</li>
<li><p><code>alsamixer -h</code> 或 <code>alsamixer --help</code>：显示 <code>alsamixer</code> 命令的帮助信息，包括可用选项和用法示例。</p>
</li>
</ol>
<p>通过 <code>alsamixer</code>，你可以调整音频设备的音量、平衡、增益和其他音频控制参数。请注意，使用 <code>alsamixer</code> 进行的更改是实时的，不会永久保存。如果你希望在系统启动时应用特定的音频设置，可能需要考虑其他方法，例如 ALSA 的配置文件或其他工具。</p>
<p>在使用 <code>alsamixer</code> 时，如果遇到问题或需要进一步了解每个选项的详细说明，可以参考 ALSA 的官方文档或手册。</p>
<hr>
<hr>
<h2 id="aplay"><a href="#aplay" class="headerlink" title="aplay"></a>aplay</h2><p><code>aplay</code> 是 Linux 系统上的命令行音频播放工具，它使用 ALSA（Advanced Linux Sound Architecture）来播放音频文件。下面是对 <code>aplay</code> 命令的详细解释：</p>
<ol>
<li><p><code>aplay &lt;file&gt;</code>：直接运行 <code>aplay</code> 命令并指定音频文件作为参数，将会播放该音频文件。例如，<code>aplay audio.wav</code> 将会播放名为 “audio.wav” 的音频文件。</p>
</li>
<li><p><code>aplay -l</code>：使用 <code>-l</code> 选项可以列出系统上可用的音频设备（声卡）列表。它会显示设备的编号、名称和硬件信息等。</p>
</li>
<li><p><code>aplay -D &lt;device&gt;</code>：使用 <code>-D</code> 选项可以指定要使用的音频设备。可以通过 <code>&lt;device&gt;</code> 参数指定设备的名称或标识符。例如，<code>aplay -D hw:0,0 audio.wav</code> 将会使用 <code>hw:0,0</code> 设备播放 “audio.wav” 文件。</p>
</li>
<li><p><code>aplay -f &lt;format&gt;</code>：使用 <code>-f</code> 选项可以指定音频文件的格式。可以通过 <code>&lt;format&gt;</code> 参数指定格式，如 <code>S16_LE</code>、<code>S24_LE</code>、<code>float_le</code> 等。</p>
</li>
<li><p><code>aplay -r &lt;rate&gt;</code>：使用 <code>-r</code> 选项可以指定音频文件的采样率。可以通过 <code>&lt;rate&gt;</code> 参数指定采样率的数值。</p>
</li>
<li><p><code>aplay -c &lt;channels&gt;</code>：使用 <code>-c</code> 选项可以指定音频文件的通道数。可以通过 <code>&lt;channels&gt;</code> 参数指定通道数的数值。</p>
</li>
<li><p><code>aplay -t &lt;duration&gt;</code>：使用 <code>-t</code> 选项可以指定音频文件的播放时长。可以通过 <code>&lt;duration&gt;</code> 参数指定播放时长的数值和单位，如 <code>10s</code>、<code>2m</code> 等。</p>
</li>
<li><p><code>aplay -q</code>：使用 <code>-q</code> 选项可以启用静默模式，即不显示播放进度和其他信息。</p>
</li>
<li><p><code>aplay --help</code>：使用 <code>--help</code> 选项可以显示 <code>aplay</code> 命令的帮助信息，包括可用选项和用法示例。</p>
</li>
</ol>
<p>这些选项只是 <code>aplay</code> 命令的一部分，你可以根据需要查阅 <code>aplay</code> 的手册页或使用命令的 <code>--help</code> 选项获取更详细的命令说明和选项信息。</p>
<p>通过 <code>aplay</code>，你可以在 Linux 系统上播放音频文件。它对于测试音频设备、验证音频配置和简单的音频播放任务非常有用。</p>
<hr>
<h2 id="modprobe"><a href="#modprobe" class="headerlink" title="modprobe"></a>modprobe</h2><p><code>modprobe</code> 是 Linux 系统上的一个命令行工具，用于动态加载和卸载内核模块（驱动程序）。它可以根据模块的名称自动加载相应的内核模块，并处理模块之间的依赖关系。下面是对 <code>modprobe</code> 命令的详细解释：</p>
<ol>
<li><p><code>modprobe &lt;module&gt;</code>：直接运行 <code>modprobe</code> 命令并指定模块名称作为参数，将会尝试加载该模块。例如，<code>modprobe snd_usb_audio</code> 将会加载名为 “snd_usb_audio” 的内核模块。</p>
</li>
<li><p><code>modprobe -r &lt;module&gt;</code>：使用 <code>-r</code> 选项可以卸载指定的内核模块。例如，<code>modprobe -r snd_usb_audio</code> 将会卸载名为 “snd_usb_audio” 的内核模块。</p>
</li>
<li><p><code>modprobe -l</code>：使用 <code>-l</code> 选项可以列出所有可用的内核模块。它会显示模块的路径和名称。</p>
</li>
<li><p><code>modprobe -a &lt;module&gt;</code>：使用 <code>-a</code> 选项可以加载指定模块及其所有依赖的模块。它会自动处理模块之间的依赖关系。</p>
</li>
<li><p><code>modprobe -c</code>：使用 <code>-c</code> 选项可以显示当前加载的内核模块的配置信息。它会列出每个模块的配置参数。</p>
</li>
<li><p><code>modprobe -n &lt;module&gt;</code>：使用 <code>-n</code> 选项可以检查指定模块是否可加载，但不实际加载它。它会输出一个表示模块是否可加载的消息。</p>
</li>
<li><p><code>modprobe -v &lt;module&gt;</code>：使用 <code>-v</code> 选项可以显示详细的加载信息，包括加载的模块及其依赖关系。</p>
</li>
<li><p><code>modprobe -d &lt;directory&gt;</code>：使用 <code>-d</code> 选项可以指定要搜索模块的目录。默认情况下，<code>modprobe</code> 将搜索默认的模块目录。</p>
</li>
<li><p><code>modprobe -h</code> 或 <code>modprobe --help</code>：显示 <code>modprobe</code> 命令的帮助信息，包括可用选项和用法示例。</p>
</li>
</ol>
<p>通过 <code>modprobe</code> 命令，你可以在 Linux 系统上动态加载和卸载内核模块。这对于根据需要加载所需的驱动程序或模块、解决硬件兼容性问题以及进行模块调试和配置非常有用。请注意，你可能需要以超级用户权限（root 或使用 <code>sudo</code> 命令）运行 <code>modprobe</code> 命令，以便加载或卸载内核模块。</p>
<p>希望这些信息能帮助你理解和使用 <code>modprobe</code> 命令。如有需要，你可以参考相关文档或手册以获取更多详细信息。</p>
<hr>
<h2 id="insmod"><a href="#insmod" class="headerlink" title="insmod"></a>insmod</h2><p><code>insmod</code> 是 Linux 系统上的一个命令行工具，用于手动加载内核模块（驱动程序）到内核中。它可以加载指定的内核模块并将其插入当前运行的内核中。下面是对 <code>insmod</code> 命令的详细解释：</p>
<ol>
<li><p><code>insmod &lt;module&gt;</code>：直接运行 <code>insmod</code> 命令并指定模块名称作为参数，将会尝试加载该模块。例如，<code>insmod mymodule.ko</code> 将会加载名为 “mymodule.ko” 的内核模块。</p>
</li>
<li><p><code>insmod -f &lt;module&gt;</code>：使用 <code>-f</code> 选项可以强制加载指定的内核模块，即使模块已经加载过。注意，这可能导致冲突或意外行为，因此谨慎使用该选项。</p>
</li>
<li><p><code>insmod -r &lt;module&gt;</code>：使用 <code>-r</code> 选项可以卸载指定的内核模块。注意，使用 <code>insmod -r</code> 只会从内核中卸载模块，而不会处理模块的依赖关系。因此，如果有其他模块依赖于该模块，则可能导致系统不稳定。</p>
</li>
<li><p><code>insmod -l &lt;module&gt;</code>：使用 <code>-l</code> 选项可以指定模块文件的路径，而不是使用当前目录。例如，<code>insmod -l /path/to/modules/mymodule.ko</code> 将加载指定路径下的内核模块。</p>
</li>
<li><p><code>insmod -s &lt;symbol&gt;</code>：使用 <code>-s</code> 选项可以指定要加载的模块中的符号（函数或变量）。这在需要仅加载模块中的特定符号时很有用。</p>
</li>
<li><p><code>insmod -h</code> 或 <code>insmod --help</code>：显示 <code>insmod</code> 命令的帮助信息，包括可用选项和用法示例。</p>
</li>
</ol>
<p>需要注意的是，使用 <code>insmod</code> 命令手动加载内核模块需要具有超级用户权限（root 或使用 <code>sudo</code> 命令）。加载模块前，你需要确保该模块的二进制文件（<code>.ko</code> 文件）存在，并且与当前运行的内核版本兼容。</p>
<p>希望这些信息能帮助你理解和使用 <code>insmod</code> 命令。如有需要，你可以参考相关文档或手册以获取更多详细信息。</p>
<hr>
<h2 id="ubuntu-drivers-devices"><a href="#ubuntu-drivers-devices" class="headerlink" title="ubuntu-drivers devices"></a>ubuntu-drivers devices</h2><p><code>ubuntu-drivers devices</code> 是一个 Ubuntu 系统上的命令，用于列出可用的硬件驱动程序。它会扫描系统上的硬件设备，并显示适用于这些设备的推荐和可选驱动程序。下面是对 <code>ubuntu-drivers devices</code> 命令的详细解释：</p>
<ol>
<li><p><code>ubuntu-drivers devices</code>：直接运行 <code>ubuntu-drivers devices</code> 命令将列出系统中的硬件设备以及可用的驱动程序信息。</p>
</li>
<li><p>输出格式：命令的输出结果包含了设备的厂商、型号和设备标识符等信息，以及推荐和可选驱动程序的名称。</p>
</li>
<li><p>推荐驱动程序：在输出结果中，推荐的驱动程序被标记为 “recommended”，表示它们是最适合该设备的驱动程序。这些驱动程序通常由 Ubuntu 官方维护，并且在兼容性和稳定性方面经过测试。</p>
</li>
<li><p>可选驱动程序：在输出结果中，可选的驱动程序被标记为 “proprietary”，表示它们是由硬件厂商提供的专有驱动程序。这些驱动程序可能提供更好的性能或功能，但可能不像推荐驱动程序那样经过广泛测试。</p>
</li>
</ol>
<p>通过运行 <code>ubuntu-drivers devices</code> 命令，你可以获取有关系统硬件设备和适用驱动程序的信息。这对于了解系统硬件配置、选择适当的驱动程序以及解决硬件兼容性问题非常有用。</p>
<p>希望这些信息能帮助你理解和使用 <code>ubuntu-drivers devices</code> 命令。如有需要，你可以参考相关文档或手册以获取更多详细信息。</p>
<hr>
<h2 id="gsettings"><a href="#gsettings" class="headerlink" title="gsettings"></a>gsettings</h2><p><code>gsettings</code> 是一个命令行工具，用于在 Ubuntu 中访问和修改 GNOME 桌面环境的设置。它允许你通过命令行方式读取和更改各种系统设置、应用程序设置以及桌面外观和行为等。</p>
<p>下面是一些 <code>gsettings</code> 命令的常见用法和解释：</p>
<ol>
<li><p><code>gsettings list-schemas</code>：列出可用的模式（schemas）。这将显示所有可用的模式名称，你可以使用这些模式名称来查询和修改相关设置。</p>
</li>
<li><p><code>gsettings list-keys SCHEMA</code>：列出给定模式（SCHEMA）下的所有键（keys）。使用具体的模式名称替换 <code>SCHEMA</code> 部分来查看该模式下的所有可用键。</p>
</li>
<li><p><code>gsettings get SCHEMA KEY</code>：获取给定模式（SCHEMA）下给定键（KEY）的值。这可用于查看当前设置的值。</p>
</li>
<li><p><code>gsettings set SCHEMA KEY VALUE</code>：将给定模式（SCHEMA）下给定键（KEY）的值设置为指定的值（VALUE）。使用这个命令可以修改设置的值。</p>
</li>
<li><p><code>gsettings reset SCHEMA KEY</code>：重置给定模式（SCHEMA）下给定键（KEY）的值为默认值。</p>
</li>
<li><p><code>gsettings range SCHEMA KEY</code>：显示给定模式（SCHEMA）下给定键（KEY）的值的允许范围。</p>
</li>
</ol>
<p>需要注意的是，<code>SCHEMA</code> 是模式的名称，而 <code>KEY</code> 是模式中的键的名称。你可以使用 <code>list-schemas</code> 和 <code>list-keys</code> 命令来获取可用的模式和键的列表。</p>
<p>举例来说，<code>org.gnome.desktop.background</code> 是一个常用的模式，用于控制桌面背景相关的设置。你可以使用类似以下的命令来修改桌面背景图片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.desktop.background picture-uri &#x27;file:///path/to/image.jpg&#x27;</span><br></pre></td></tr></table></figure>
<p>这会将桌面背景设置为指定路径下的图像文件。</p>
<p><code>gsettings</code> 提供了一种方便的方式来从命令行管理和调整 GNOME 桌面环境的各种设置。你可以查阅相关的文档和手册来获取更多关于 <code>gsettings</code> 命令的详细信息和示例用法。</p>
<h2 id="nautilus"><a href="#nautilus" class="headerlink" title="nautilus"></a>nautilus</h2><p><code>nautilus</code> 是 Linux 系统中一个常用的文件管理器，它提供了图形化界面来浏览和管理文件和文件夹。下面是对 <code>nautilus</code> 命令的详细解释：</p>
<ol>
<li><p><strong>启动 Nautilus：</strong> 可以在终端中输入 <code>nautilus</code> 命令来启动 Nautilus 文件管理器。它会打开一个新的窗口显示当前用户的主目录。</p>
</li>
<li><p><strong>打开指定目录：</strong> 可以使用 <code>nautilus</code> 命令并指定目录路径来打开特定的目录。例如，<code>nautilus /path/to/directory</code> 会打开指定路径的目录。</p>
</li>
<li><p><strong>图形化界面操作：</strong> Nautilus 提供了一系列图形化界面操作，包括文件和文件夹的复制、剪切、粘贴、重命名、删除等。可以使用鼠标右键单击文件或文件夹，或使用菜单栏的选项来执行这些操作。</p>
</li>
<li><p><strong>查看和排序文件列表：</strong> Nautilus 允许你以不同的方式查看和排序文件列表。你可以切换到图标视图、列表视图或压缩视图，并可以根据名称、大小、类型等进行排序。</p>
</li>
<li><p><strong>搜索文件：</strong> Nautilus 提供了搜索功能，可以通过菜单栏中的搜索栏输入关键字来搜索文件和文件夹。</p>
</li>
<li><p><strong>自定义文件管理器：</strong> Nautilus 允许你自定义文件管理器的外观和行为。你可以通过菜单栏中的“偏好设置”选项访问各种设置选项，如外观、行为、文件预览等。</p>
</li>
</ol>
<p>请注意，<code>nautilus</code> 命令通常用于在桌面环境中打开 Nautilus 文件管理器。如果你使用的是不带桌面环境的服务器版本的 Linux，可能无法直接运行 <code>nautilus</code> 命令。在服务器上，你可能需要使用其他基于终端的文件管理工具。</p>
<hr>
<h2 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h2><ul>
<li><p>简介：</p>
<ul>
<li>xxd 是一个在 Linux 系统中用于十六进制和ASCII码转换的命令行工具。它可以将文件或输入的数据转换为十六进制和ASCII码的表示形式，或者将十六进制和ASCII码的数据还原为二进制格式</li>
</ul>
</li>
<li><p>语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd [选项] [文件名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项：</p>
<ul>
<li>-b：以二进制格式显示数据。</li>
<li>-c &lt;列数&gt;：指定每行显示的列数。</li>
<li>-e：以大端字节序（big-endian）格式显示数据。</li>
<li>-g &lt;字节数&gt;：指定每个显示的数据块的字节数。</li>
<li>-l &lt;长度&gt;：指定要显示的字节数。</li>
<li>-s &lt;偏移量&gt;：指定要从输入中开始显示的偏移量。</li>
<li>-u：以大写字母表示十六进制数值。</li>
<li>-v：以完整的输出格式显示，不省略重复的行。</li>
</ul>
</li>
</ul>
<h2 id="hexdump"><a href="#hexdump" class="headerlink" title="hexdump"></a>hexdump</h2><ul>
<li><p>简介：</p>
<ul>
<li>hexdump 命令在 Linux 中用于以十六进制和ASCII码形式显示文件或输入的内容。它可以将二进制文件或数据转换为人可读的格式</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump [选项] [文件名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项：</p>
<ul>
<li>-C：以十六进制和ASCII码形式显示内容，并在每行末尾显示对应的ASCII字符。</li>
<li>-b：以八进制格式显示内容。</li>
<li>-c：以字符形式显示内容。</li>
<li>-d：以十进制格式显示内容。</li>
<li>-e：指定自定义的格式字符串来显示内容。</li>
<li>-n &lt;长度&gt;：指定要显示的字节数。</li>
<li>-s &lt;偏移量&gt;：指定要从输入中开始显示的偏移量。</li>
<li>-v：以完整的输出格式显示，不省略重复的行。</li>
<li>-x：以十六进制格式显示内容。</li>
</ul>
</li>
</ul>
<h2 id="exiftool"><a href="#exiftool" class="headerlink" title="exiftool"></a>exiftool</h2><ul>
<li><p>简介：</p>
<ul>
<li>在 Linux 上可以使用 exiftool 命令来查看图片的元数据。你可以在终端中运行以下命令来获取图片的详细元数据：</li>
<li><code>exiftool image.jpg</code></li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>安装依赖包libimage-exiftool-perl: <code>sudo apt install libimage-exiftool-perl</code></li>
</ul>
</li>
</ul>
<h2 id="linux下，常用的查看动态库的符号链接工具"><a href="#linux下，常用的查看动态库的符号链接工具" class="headerlink" title="linux下，常用的查看动态库的符号链接工具"></a>linux下，常用的查看动态库的符号链接工具</h2><ol>
<li><p>nm：nm 命令用于列出目标文件或共享库中的符号信息。可以使用 nm 命令来查看动态库中的符号链接。例如，要查看一个动态库文件（如libexample.so）中的符号链接，可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -D libexample.so</span><br></pre></td></tr></table></figure>
<p>这将显示动态库中的所有符号及其链接信息。</p>
</li>
<li><p>objdump：objdump 命令用于显示目标文件或可执行文件的信息，包括符号表。可以使用 objdump 命令来查看动态库中的符号链接。例如，要查看一个动态库文件中的符号链接，可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -T libexample.so</span><br></pre></td></tr></table></figure>
<p>这将显示动态库中的符号链接表。</p>
</li>
<li><p>readelf：readelf 命令用于显示 ELF（Executable and Linkable Format）格式文件的信息，包括符号表。可以使用 readelf 命令来查看动态库中的符号链接。例如，要查看一个动态库文件中的符号链接，可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s libexample.so</span><br></pre></td></tr></table></figure>
<p>这将显示动态库中的符号表，其中包含符号链接信息。</p>
</li>
</ol>
<h2 id="Linux-常用命令全拼"><a href="#Linux-常用命令全拼" class="headerlink" title="Linux 常用命令全拼"></a>Linux 常用命令全拼</h2><ul>
<li>参考网站：<code>https://www.runoob.com/w3cnote/linux-command-full-fight.html</code></li>
</ul>
<h2 id="eog"><a href="#eog" class="headerlink" title="eog"></a>eog</h2><!-- + 简介：
  + 使用命令行查看图片

+ 示例：
  + `eog picturepath` -->

<ul>
<li><p>简介：</p>
<ul>
<li>eog 是 Linux 系统中的一个命令行工具，用于打开和显示图像文件。它是 Eye of GNOME (EOG) 图像查看器的命令行接口</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eog [选项] [图像文件]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项：</p>
<ul>
<li>-f 或 –fullscreen：以全屏模式打开图像。</li>
<li>-g 或 –geometry&#x3D;宽度x高度：指定窗口的初始大小。</li>
<li>-n 或 –new-instance：在新的 EOG 实例中打开图像。</li>
<li>-w 或 –disable-gallery：禁用图库模式</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eog image.jpg</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>当你在终端中运行 eog 命令并指定一个图像文件作为参数时，它会打开 Eye of GNOME (EOG) 图像查看器，并在窗口中显示指定的图像。你可以使用鼠标滚轮来缩放图像，使用工具栏进行放大、缩小、旋转等操作。还可以通过菜单栏中的选项进行图像的保存、打印和设置</li>
<li>eog 命令提供了一个快速和方便的方式来查看图像文件，尤其适用于图像的预览和简单的编辑操作。它支持多种常见的图像格式，如 JPEG、PNG、GIF 等</li>
<li>需要注意的是，eog 命令通常用于在图形化环境下打开图像文件。如果你在没有图形界面的终端环境中运行 eog 命令，可能会出现错误或无法正常工作</li>
</ul>
</li>
</ul>
<h2 id="查看linux服务器开机自启动服务"><a href="#查看linux服务器开机自启动服务" class="headerlink" title="查看linux服务器开机自启动服务"></a>查看linux服务器开机自启动服务</h2><ul>
<li><p>命令：</p>
<ul>
<li><code>systemctl list-unit-files</code></li>
</ul>
</li>
<li><p>参数：</p>
<ul>
<li>其中STATE显示为enable字样的服务，即可开机自启动的服务</li>
</ul>
</li>
<li><p>查处的内容过多，可通过grep 命令进行筛选</p>
<ul>
<li><code>systemctl list-unit-files | grep firewalld</code></li>
</ul>
</li>
</ul>
<h2 id="开启或关闭开机自启动"><a href="#开启或关闭开机自启动" class="headerlink" title="开启或关闭开机自启动"></a>开启或关闭开机自启动</h2><ul>
<li><p>关闭开机自启动：</p>
<ul>
<li><code>systemctl disable  服务name</code></li>
</ul>
</li>
<li><p>开启开机自启动：</p>
<ul>
<li><code>systemctl enable  服务name</code></li>
</ul>
</li>
</ul>
<h2 id="getconf"><a href="#getconf" class="headerlink" title="getconf"></a>getconf</h2><ul>
<li>简介：<ul>
<li>查询保存系统配置的变量</li>
</ul>
</li>
<li>参数<ul>
<li><code>-a</code> : 显示所有当前系统的配置变量和变量的值</li>
<li><code>-v</code> : </li>
<li><code>system_var</code> : 查询指定配置变量的值</li>
<li><code>path_var</code> : 参数是一个通过pathconf命令定义的系统配置变量</li>
</ul>
</li>
</ul>
<h2 id="清空文件内容"><a href="#清空文件内容" class="headerlink" title="清空文件内容"></a>清空文件内容</h2><ul>
<li><p>通过重定向到 Null 来清空文件内容</p>
<ul>
<li><code>&gt; access.log</code></li>
</ul>
</li>
<li><p>使用 ‘true’ 命令重定向来清空文件</p>
<ul>
<li>下面我们将使用 : 符号，它是 shell 的一个内置命令，等同于 true 命令，它可被用来作为一个 no-op（即不进行任何操作）</li>
<li><code>: &gt; access.log</code></li>
<li><code>true &gt; access.log</code></li>
</ul>
</li>
<li><p>使用 cat&#x2F;cp&#x2F;dd 实用工具及 &#x2F;dev&#x2F;null 设备来清空文件</p>
<ul>
<li>在 Linux 中， null 设备基本上被用来丢弃某个进程不再需要的输出流，或者作为某个输入流的空白文件，这些通常可以利用重定向机制来达到。</li>
<li>所以 &#x2F;dev&#x2F;null 设备文件是一个特殊的文件，它将清空送到它这里来的所有输入，而它的输出则可被视为一个空文件。</li>
<li>另外，你可以通过使用 cat 命令 显示 &#x2F;dev&#x2F;null 的内容然后重定向输出到某个文件，以此来达到清空该文件的目的。</li>
<li><code>cat /dev/null &gt; access.log</code></li>
</ul>
</li>
<li><p>下面，我们将使用 cp 命令 复制 &#x2F;dev&#x2F;null 的内容到某个文件来达到清空该文件的目的，具体如下所示：</p>
<ul>
<li><code>cp /dev/null access.log</code></li>
</ul>
</li>
<li><p>而下面的命令中， if 代表输入文件，of 代表输出文件。</p>
<ul>
<li><code>dd if=/dev/null of=access.log</code></li>
</ul>
</li>
<li><p>使用 echo 命令清空文件</p>
<ul>
<li><code>echo &quot;&quot; &gt; access.log</code></li>
<li><code>echo &gt; access.log</code></li>
</ul>
</li>
<li><p>注意：你应该记住空字符串并不等同于 null 。字符串表明它是一个具体的事物，只不过它的内容可能是空的，但 null 则意味着某个事物并不存在</p>
</li>
<li><p>基于这个原因，当你将 echo 命令 的输出作为输入重定向到文件后，使用 cat 命令 来查看该文件的内容时，你将看到一个空白行（即一个空字符串）</p>
</li>
<li><p>要将 null 做为输出输入到文件中，你应该使用 -n 选项，这个选项将告诉 echo 不再像上面的那个命令那样输出结尾的那个新行。</p>
</li>
<li><p>使用 truncate 命令来清空文件内容</p>
<ul>
<li>truncate 可被用来将一个文件缩小或者扩展到某个给定的大小</li>
<li>你可以利用它和 -s 参数来特别指定文件的大小。要清空文件的内容，则在下面的命令中将文件的大小设定为 0:<ul>
<li><code>truncate -s 0 access.log</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="fstab"><a href="#fstab" class="headerlink" title="fstab"></a>fstab</h2><p><code>fstab</code>（文件系统表）是一个Linux系统配置文件，用于定义系统在启动时挂载文件系统的方式和规则。它通常位于<code>/etc/fstab</code>路径下，由系统管理员进行编辑和管理。</p>
<p><code>fstab</code>文件中的每一行表示一个要挂载的文件系统，每个字段之间用空格或制表符分隔。以下是<code>fstab</code>文件的常用字段和说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;文件系统&gt;  &lt;挂载点&gt;  &lt;文件系统类型&gt;  &lt;挂载选项&gt;  &lt;dump&gt;  &lt;pass&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;文件系统&gt;</code>：要挂载的设备或网络位置。可以是设备名称（如<code>/dev/sda1</code>）、UUID（Universally Unique Identifier）、标签（Label）或网络位置（如<code>//server/share</code>）。</li>
<li><code>&lt;挂载点&gt;</code>：设备将被挂载到的目录路径。</li>
<li><code>&lt;文件系统类型&gt;</code>：设备的文件系统类型，如<code>ext4</code>、<code>ntfs</code>、<code>nfs</code>等。</li>
<li><code>&lt;挂载选项&gt;</code>：指定挂载设备时的选项，如<code>ro</code>（只读）、<code>rw</code>（读写）、<code>noauto</code>（不自动挂载）、<code>user</code>（允许普通用户挂载）等。</li>
<li><code>&lt;dump&gt;</code>：备份标志。如果设置为<code>0</code>，表示不会被备份；如果设置为<code>1</code>，表示会被备份。</li>
<li><code>&lt;pass&gt;</code>：检查顺序。用于<code>fsck</code>命令检查文件系统的顺序。如果设置为<code>0</code>，表示不会被检查。</li>
</ul>
<p>示例<code>fstab</code>文件条目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda1   /mnt/data   ext4   defaults   0   2</span><br><span class="line">//server/share   /mnt/nfs   nfs   defaults   0   0</span><br></pre></td></tr></table></figure>

<p>上述示例中，第一行表示将<code>/dev/sda1</code>设备挂载到<code>/mnt/data</code>目录，使用<code>ext4</code>文件系统和默认挂载选项。<code>dump</code>设置为<code>0</code>，<code>pass</code>设置为<code>2</code>。第二行表示将网络位置<code>//server/share</code>挂载到<code>/mnt/nfs</code>目录，使用NFS文件系统和默认挂载选项，不进行备份和检查。</p>
<p>要编辑<code>fstab</code>文件，请使用具有管理员权限的文本编辑器，例如<code>vi</code>或<code>nano</code>。请谨慎编辑<code>fstab</code>文件，确保提供正确的设备和挂载选项，以免影响系统的正常启动和文件系统的挂载。</p>
<hr>
<h2 id="mffs-ext4"><a href="#mffs-ext4" class="headerlink" title="mffs.ext4"></a>mffs.ext4</h2><p><code>mkfs.ext4</code>是一个Linux命令，用于创建ext4文件系统（第四个扩展文件系统）在指定的设备上。</p>
<p>以下是<code>mkfs.ext4</code>命令的常用选项和用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 [options] &lt;device&gt;</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<ul>
<li><code>-b block-size</code>：指定文件系统的块大小，默认为4096字节。</li>
<li><code>-L volume-label</code>：为文件系统设置卷标。</li>
<li><code>-m reserved-blocks-percentage</code>：指定保留块的百分比，用于系统管理员。</li>
<li><code>-T usage-type</code>：设置文件系统的用途类型，如<code>news</code>, <code>backup</code>, <code>web</code>, 等。</li>
<li><code>-O feature</code>：启用指定的文件系统特性，如<code>^has_journal</code>表示不使用日志功能。</li>
<li><code>-E extended-option</code>：设置扩展选项，如<code>stride</code>, <code>stripe-width</code>, <code>nodiscard</code>, 等。</li>
</ul>
<p>示例用法：</p>
<ol>
<li>创建ext4文件系统：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>上述命令将在设备<code>/dev/sdb1</code>上创建一个ext4文件系统，默认使用4096字节的块大小。</p>
<ol start="2">
<li>创建具有指定块大小的ext4文件系统：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 -b 8192 /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>上述命令将在设备<code>/dev/sdb1</code>上创建一个ext4文件系统，并指定块大小为8192字节。</p>
<ol start="3">
<li>为ext4文件系统设置卷标：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 -L MyVolume /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>上述命令将在设备<code>/dev/sdb1</code>上创建一个ext4文件系统，并设置卷标为”MyVolume”。</p>
<ol start="4">
<li>启用特定的文件系统特性：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 -O ^has_journal /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>上述命令将在设备<code>/dev/sdb1</code>上创建一个ext4文件系统，并禁用日志功能。</p>
<p><code>mkfs.ext4</code>命令用于创建ext4文件系统之前，请确保已经正确地指定了要创建文件系统的设备。创建文件系统将格式化该设备并擦除其上的所有数据，请谨慎操作。</p>
<hr>
<h2 id="Linux下视频剪辑，录制工具"><a href="#Linux下视频剪辑，录制工具" class="headerlink" title="Linux下视频剪辑，录制工具"></a>Linux下视频剪辑，录制工具</h2><ul>
<li><p>kazam </p>
<ul>
<li>录制屏幕：<code>apt-get install -y kazam</code></li>
<li>缺点：保存的视频，在vlc打开看不到视频，传到手机剪影也不能剪辑</li>
</ul>
</li>
<li><p>openshot</p>
<ul>
<li><code>apt-get install -y openshot-qt</code></li>
<li>和pr相似</li>
</ul>
</li>
<li><p><strong>simplescreenrecorder</strong></p>
<ul>
<li>录制屏幕：<code>apt-get install -y simplescreenrecorder</code></li>
<li>优点：相比于kazam，其录制的视频，容量小，vlc支持播放</li>
</ul>
</li>
</ul>
<hr>
<h2 id="屏保命令和锁屏命令"><a href="#屏保命令和锁屏命令" class="headerlink" title="屏保命令和锁屏命令"></a>屏保命令和锁屏命令</h2><ul>
<li><p><code>gnome-screensaver-command -a</code>  –  显示屏保但是不锁定，移动鼠标或敲击键盘后自动消失</p>
</li>
<li><p><code>gnome-screensaver-command -l</code>  –  显示屏保并锁定，移动鼠标或敲击键盘弹出密码框</p>
</li>
<li><p><code>sudo loginctl list-sessions</code>   – 列出当前所有的会话（默认命令）</p>
</li>
<li><p><code>sudo loginctl lock-session [ID]</code>   – 锁定指定会话（如果会话支持屏幕锁）或者当前调用者的会话</p>
</li>
<li><p><code>sudo loginctl unlock-session [ID]</code> – 解锁指定会话（如果会话支持屏幕锁）或者当前调用者的会话</p>
</li>
<li><p><code>sudo loginctl lock-sessions</code>  –  锁定全部会话</p>
</li>
<li><p><code>sudo loginctl unlock-sessions</code> – 解锁全部会话</p>
</li>
<li><p>ubuntu18 锁屏快捷键  –  <code>Super + L</code></p>
</li>
</ul>
<hr>
<h2 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h2><p><code>fdisk</code>是一个Linux命令行工具，用于对磁盘分区进行管理和操作。它可以创建、删除、调整磁盘分区以及显示磁盘分区信息。</p>
<p>以下是<code>fdisk</code>命令的常用选项和用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk [options] &lt;device&gt;</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<ul>
<li><code>-l</code>：列出指定设备或所有设备的分区表信息。</li>
<li><code>-s</code>：显示指定设备或所有设备的分区大小。</li>
<li><code>-u</code>：以扇区而不是柱面为单位显示分区信息。</li>
<li><code>-c</code>：与<code>-l</code>选项一起使用时，使用紧凑的格式显示分区表信息。</li>
<li><code>-p</code>：与<code>-l</code>选项一起使用时，使用可打印的格式显示分区表信息。</li>
<li><code>-n</code>：创建一个新的分区。</li>
<li><code>-d</code>：删除一个分区。</li>
<li><code>-t</code>：更改分区的类型。</li>
</ul>
<p>示例用法：</p>
<ol>
<li>列出所有设备的分区表信息：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>

<p>上述命令将列出所有设备的分区表信息，包括设备名称、分区大小、分区类型等。</p>
<ol start="2">
<li>列出指定设备的分区表信息：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l /dev/sda</span><br></pre></td></tr></table></figure>

<p>上述命令将列出设备<code>/dev/sda</code>的分区表信息。</p>
<ol start="3">
<li>创建新的分区：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure>

<p>上述命令将打开设备<code>/dev/sdb</code>的分区表，并引导您通过一系列的交互式步骤来创建新的分区。</p>
<ol start="4">
<li>删除分区：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdc</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): d</span><br><span class="line">Partition number (1-4): 1</span><br></pre></td></tr></table></figure>

<p>上述命令将打开设备<code>/dev/sdc</code>的分区表，并提示您输入要删除的分区号。</p>
<ol start="5">
<li>更改分区类型：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdd</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1-4): 1</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list codes): 83</span><br></pre></td></tr></table></figure>

<p>上述命令将打开设备<code>/dev/sdd</code>的分区表，并提示您输入要更改的分区号和新的分区类型。</p>
<p><code>fdisk</code>命令涉及对磁盘分区进行操作，因此需要以root权限运行。请谨慎操作，以免对系统造成损害。</p>
<hr>
<h2 id="sysstat"><a href="#sysstat" class="headerlink" title="sysstat"></a>sysstat</h2><p><code>sysstat</code>是一个性能监控工具集，它提供了一系列的命令行工具，用于收集和分析系统的性能数据。这些工具可以帮助您监视系统的资源利用率、性能瓶颈和运行状况。</p>
<p><code>sysstat</code>包括以下常用命令：</p>
<ol>
<li><p><code>sar</code>：用于收集、报告和存档系统活动信息，包括CPU利用率、内存使用、磁盘IO、网络流量等。示例用法：<code>sar -u</code>显示CPU利用率，<code>sar -r</code>显示内存使用情况，<code>sar -d</code>显示磁盘IO统计。</p>
</li>
<li><p><code>iostat</code>：用于报告和存档系统磁盘IO活动的统计信息，包括每个磁盘的读写速度、IO等待时间、IO请求队列长度等。示例用法：<code>iostat -x</code>显示详细的磁盘IO统计。</p>
</li>
<li><p><code>mpstat</code>：用于报告和存档每个CPU的利用率和其他统计信息，包括用户时间、系统时间、空闲时间等。示例用法：<code>mpstat -P ALL</code>显示每个CPU的利用率。</p>
</li>
<li><p><code>pidstat</code>：用于报告和存档进程的CPU利用率、内存使用和IO统计。示例用法：<code>pidstat -p &lt;pid&gt;</code>显示特定进程的统计信息。</p>
</li>
<li><p><code>ifstat</code>：用于报告和存档网络接口的流量统计，包括接收和发送的数据量。示例用法：<code>ifstat -a</code>显示所有网络接口的流量统计。</p>
</li>
</ol>
<p>这些命令都是通过收集系统性能数据并以可读的格式进行报告。您可以根据具体需求选择适合的命令，并结合不同的选项来获取所需的性能信息。</p>
<p><code>sysstat</code>工具集在大多数Linux发行版中都可用，但需要先安装。您可以使用包管理器（如apt、yum等）来安装<code>sysstat</code>软件包。</p>
<hr>
<h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><ul>
<li>pstree,以树状图的方式展现进程之间的派生关系,显示效果比较直观</li>
<li>参数<ul>
<li><code>a</code> : 显示每个程序的完整指令,包含路径,参数或者是常驻服务的标示</li>
<li><code>c</code> : 不使用精简表示法</li>
<li><code>G</code> : 使用VT100终端机的列绘图字符</li>
<li><code>n</code> : 用程序识别码排序,预设是以程序名称来排序</li>
<li><code>p</code> : 显示程序识别码</li>
<li><code>u</code> : 显示用户名称</li>
</ul>
</li>
</ul>
<h2 id="杀死指定进程"><a href="#杀死指定进程" class="headerlink" title="杀死指定进程"></a>杀死指定进程</h2><ul>
<li><code>kill -9 process_pid</code></li>
</ul>
<h2 id="wscat-详解"><a href="#wscat-详解" class="headerlink" title="wscat 详解"></a>wscat 详解</h2><p>wscat 是一个命令行工具，用于测试和调试 WebSocket 连接。它提供了一种简单的方式来建立 WebSocket 连接并进行数据交换。以下是 wscat 命令的常用选项和用法的详解：</p>
<p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat [options] [url]</span><br></pre></td></tr></table></figure>

<p><strong>选项</strong>：</p>
<ul>
<li><code>-l, --listen</code>: 以服务器模式监听指定的地址和端口。</li>
<li><code>-c, --connect</code>: 建立 WebSocket 连接到指定的 URL。</li>
<li><code>-s, --ssl</code>: 使用 SSL 加密连接。</li>
<li><code>-k, --insecure</code>: 忽略 SSL 证书验证。</li>
<li><code>-H, --header</code>: 添加自定义的请求头。</li>
<li><code>-n, --no-check</code>: 禁用 WebSocket 协议验证。</li>
<li><code>-P, --pipe</code>: 将标准输入的数据发送到 WebSocket 连接。</li>
<li><code>-t, --timestamp</code>: 在控制台输出消息的时间戳。</li>
<li><code>--host</code>: 指定自定义的 Host 头部。</li>
</ul>
<p><strong>用法示例</strong>：</p>
<ol>
<li><p>连接到 WebSocket 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -c ws://example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接到使用 SSL 的 WebSocket 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -c wss://example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听并建立 WebSocket 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -l 8080</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听并使用 SSL 加密的 WebSocket 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -l --ssl --ssl-key key.pem --ssl-cert cert.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送消息到 WebSocket 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -c ws://example.com -P</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加自定义的请求头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -c ws://example.com -H &quot;Authorization: Bearer token&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些是 wscat 命令的一些常用选项和用法示例。使用这个工具，您可以方便地测试和调试 WebSocket 服务器，发送和接收消息。</p>
<p>请注意，为了使用 wscat 工具，您需要先安装 Node.js 和 npm，然后使用以下命令安装 wscat：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g wscat</span><br><span class="line">apt install node-ws</span><br></pre></td></tr></table></figure>

<p>希望这些详解对您有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="curl-常用选项"><a href="#curl-常用选项" class="headerlink" title="curl 常用选项"></a>curl 常用选项</h2><p>curl 命令具有许多选项，可用于定制和控制请求的各个方面。以下是一些常用的 curl 命令选项：</p>
<ol>
<li><p><strong>-X, –request</strong>: 指定 HTTP 请求方法，如 GET、POST、PUT、DELETE 等。例如：<code>curl -X POST</code>.</p>
</li>
<li><p><strong>-H, –header</strong>: 添加请求头。可以使用多个 <code>-H</code> 选项添加多个请求头。例如：<code>curl -H &quot;Content-Type: application/json&quot; -H &quot;Authorization: Bearer token&quot;</code></p>
</li>
<li><p><strong>-d, –data</strong>: 指定请求的数据体（请求体）。用于发送 POST 或 PUT 请求的数据。例如：<code>curl -X POST -d &quot;username=admin&amp;password=123&quot;</code></p>
</li>
<li><p><strong>-F, –form</strong>: 以 multipart&#x2F;form-data 格式发送表单数据。用于文件上传等场景。例如：<code>curl -F &quot;file=@path/to/file&quot;</code></p>
</li>
<li><p><strong>-o, –output</strong>: 将响应保存到文件。可以指定文件名或路径。例如：<code>curl -o output.txt</code></p>
</li>
<li><p><strong>-i, –include</strong>: 在输出中包含响应头信息。例如：<code>curl -i</code></p>
</li>
<li><p><strong>-s, –silent</strong>: 静默模式，禁止显示进度信息或错误消息。例如：<code>curl -s</code></p>
</li>
<li><p><strong>-u, –user</strong>: 指定用户名和密码进行基本认证。例如：<code>curl -u username:password</code></p>
</li>
<li><p><strong>-k, –insecure</strong>: 忽略 SSL 证书验证，用于处理自签名证书等不受信任的情况。例如：<code>curl -k</code></p>
</li>
<li><p><strong>-x, –proxy</strong>: 指定代理服务器。例如：<code>curl -x http://proxy.example.com:8080</code></p>
</li>
<li><p><strong>-L, –location</strong>: 自动跟随重定向。当服务器返回重定向响应时，自动跳转到新的 URL。例如：<code>curl -L</code></p>
</li>
<li><p><strong>-c, –cookie</strong>: 指定 Cookie。发送请求时携带指定的 Cookie。例如：<code>curl -c cookies.txt</code></p>
</li>
</ol>
<p>这只是一小部分常用选项，curl 还提供了许多其他选项，如超时设置、身份验证方式、自定义请求头、代理配置等。可以通过 <code>curl --help</code> 命令或查阅 curl 的文档来获取更详细的选项说明和示例。</p>
<p>希望这些常用选项对您有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="curl-详解"><a href="#curl-详解" class="headerlink" title="curl 详解"></a>curl 详解</h2><p>curl 是一个命令行工具和库，用于在各种操作系统上进行网络数据传输。它支持多种协议，包括 HTTP、HTTPS、FTP、SMTP、POP3 等，可以执行各种网络操作，如发送请求、下载文件、上传文件等。以下是有关 curl 的详解：</p>
<ol>
<li><p><strong>发送请求</strong>：curl 可以用于发送 HTTP 请求到指定的 URL，并接收服务器的响应。它支持 GET、POST、PUT、DELETE 等常用的 HTTP 方法。</p>
</li>
<li><p><strong>参数定制</strong>：curl 提供了丰富的命令行参数，可以定制请求的各种参数，如请求头、请求体、超时时间、代理等。</p>
</li>
<li><p><strong>输出控制</strong>：curl 可以控制响应输出的格式和内容。默认情况下，它将响应输出到标准输出，但也可以将响应保存到文件或进行其他处理。</p>
</li>
<li><p><strong>文件传输</strong>：curl 可以用于上传和下载文件。通过指定适当的选项，它可以实现文件的上传和下载，支持断点续传等功能。</p>
</li>
<li><p><strong>HTTPS 支持</strong>：curl 支持通过 SSL&#x2F;TLS 加密协议进行安全的 HTTPS 请求。它能够验证服务器的证书，并支持使用客户端证书进行身份验证。</p>
</li>
<li><p><strong>认证</strong>：curl 提供了多种认证方式，如基本认证、摘要认证、Bearer Token 认证等，可以与需要身份验证的服务器进行交互。</p>
</li>
<li><p><strong>代理支持</strong>：curl 可以通过指定代理服务器来转发请求和接收响应。它支持 HTTP、HTTPS、SOCKS4 和 SOCKS5 代理。</p>
</li>
<li><p><strong>扩展性</strong>：curl 是一个功能强大且灵活的工具，还提供了丰富的 API，可以在各种编程语言中使用 curl 库进行网络操作。</p>
</li>
</ol>
<p>curl 是一个跨平台的工具，可在各种操作系统上使用，包括 Linux、macOS、Windows 等。它在命令行环境下使用简单，是开发人员进行网络调试、测试和自动化脚本编写的常用工具之一。</p>
<p>需要注意的是，curl 是一个命令行工具，它的使用方式和具体参数取决于具体的需求和场景。可以通过查阅 curl 的文档和使用示例来深入了解其更多功能和用法。</p>
<p>希望这些详解对 curl 有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="nmcli-常用选项"><a href="#nmcli-常用选项" class="headerlink" title="nmcli 常用选项"></a>nmcli 常用选项</h2><p>在 Linux 系统中，<code>nmcli</code> 是 NetworkManager 的命令行工具，用于配置和管理网络连接。下面是一些常用的 <code>nmcli</code> 命令选项：</p>
<ol>
<li><p><code>nmcli general status</code>：显示 NetworkManager 的状态信息，包括运行状态、活动连接等。</p>
</li>
<li><p><code>nmcli connection show</code>：显示当前系统上的所有网络连接的状态和详细信息。</p>
</li>
<li><p><code>nmcli connection up &lt;connection-name&gt;</code>：连接到指定名称的网络连接。</p>
</li>
<li><p><code>nmcli connection down &lt;connection-name&gt;</code>：断开指定名称的网络连接。</p>
</li>
<li><p><code>nmcli connection add type &lt;connection-type&gt; con-name &lt;connection-name&gt;</code>：添加一个新的网络连接。</p>
</li>
<li><p><code>nmcli connection modify &lt;connection-name&gt;</code>：修改现有的网络连接的配置。</p>
</li>
<li><p><code>nmcli connection delete &lt;connection-name&gt;</code>：删除指定名称的网络连接。</p>
</li>
<li><p><code>nmcli device status</code>：显示所有网络设备的状态信息，包括设备名称、连接状态等。</p>
</li>
<li><p><code>nmcli device wifi list</code>：显示可用的 Wi-Fi 网络列表。</p>
</li>
<li><p><code>nmcli device wifi connect &lt;SSID&gt; password &lt;password&gt;</code>：连接到指定的 Wi-Fi 网络，需要提供 SSID 和密码。</p>
</li>
<li><p><code>nmcli device show &lt;device-name&gt;</code>：显示指定网络设备的详细信息。</p>
</li>
<li><p><code>nmcli device disconnect &lt;device-name&gt;</code>：断开指定网络设备的连接。</p>
</li>
<li><p><code>nmcli radio wifi on</code>：打开 Wi-Fi 无线功能。</p>
</li>
<li><p><code>nmcli radio wifi off</code>：关闭 Wi-Fi 无线功能。</p>
</li>
<li><p><code>nmcli monitor</code>：启动 NetworkManager 的监视模式，实时显示网络连接状态的变化。</p>
</li>
</ol>
<p>这些是常用的 <code>nmcli</code> 命令选项，用于在 Linux 系统中配置和管理网络连接。<code>nmcli</code> 还有其他选项和命令，可以通过运行 <code>man nmcli</code> 命令在终端中查看完整的 <code>nmcli</code> 手册以获取更详细的命令说明和选项信息。</p>
<p>请注意，使用 <code>nmcli</code> 需要管理员权限（使用 <code>sudo</code>），以便对网络连接进行配置和管理。</p>
<p>希望这些信息对你有帮助！如果你有更多问题，请随时提问。</p>
<h2 id="nmcli-详解"><a href="#nmcli-详解" class="headerlink" title="nmcli 详解"></a>nmcli 详解</h2><p>在 Debian 系统中，<code>nmcli</code> 是 NetworkManager 的命令行工具，用于配置和管理网络连接。下面是一些常用的 <code>nmcli</code> 命令及其详细说明：</p>
<ol>
<li><p>显示网络连接状态和信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show</span><br></pre></td></tr></table></figure>

<p>这个命令将显示当前系统上的所有网络连接的状态和详细信息，包括连接名称、类型、设备、IP 地址等。</p>
</li>
<li><p>添加一个新的网络连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add <span class="built_in">type</span> &lt;connection-type&gt; con-name &lt;connection-name&gt; ifname &lt;interface-name&gt;</span><br></pre></td></tr></table></figure>

<p>在上述命令中，将 <code>&lt;connection-type&gt;</code> 替换为要添加的连接类型（如 ethernet、wifi、vpn 等），<code>&lt;connection-name&gt;</code> 替换为连接的名称，<code>&lt;interface-name&gt;</code> 替换为连接使用的网络接口名称。</p>
</li>
<li><p>编辑现有的网络连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection edit &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>该命令将进入一个交互式编辑模式，允许你编辑指定名称的网络连接的详细配置。你可以更改连接的属性，如 IP 设置、DNS 设置、认证方法等。</p>
</li>
<li><p>删除一个网络连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection delete &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令将删除指定名称的网络连接。</p>
</li>
<li><p>连接到一个网络：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令将连接到指定名称的网络连接。</p>
</li>
<li><p>断开一个网络连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection down &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令将断开指定名称的网络连接。</p>
</li>
</ol>
<p>以上是一些常用的 <code>nmcli</code> 命令，用于在 Debian 系统中配置和管理网络连接。<code>nmcli</code> 还有许多其他选项和命令，可以进一步探索和适应特定的网络管理需求。</p>
<p>你可以通过运行 <code>man nmcli</code> 命令在终端中查看 <code>nmcli</code> 的完整文档，以获取更详细的命令说明和选项信息。</p>
<p>请注意，使用 <code>nmcli</code> 需要管理员权限（使用 <code>sudo</code>），以便对网络连接进行配置和管理。</p>
<p>希望这些信息对你有帮助！如果你有更多问题，请随时提问。</p>
<h2 id="livemedia-utils"><a href="#livemedia-utils" class="headerlink" title="livemedia-utils"></a>livemedia-utils</h2><p>livemedia-utils 是一个Linux上的开源工具集，用于处理实时流媒体数据。它是由 LIVE555 Streaming Media 开发的，LIVE555 是一个用于流媒体的开源 C++ 库。</p>
<p>以下是关于 livemedia-utils 的一些详解：</p>
<ol>
<li><p><strong>功能</strong>：livemedia-utils 提供了一系列命令行工具，用于处理实时流媒体数据。这些工具包括流媒体服务器、流媒体客户端和其他相关实用程序。它们可用于流媒体的播放、录制、转码、传输和调试等。</p>
</li>
<li><p><strong>命令行工具</strong>：livemedia-utils 提供了多个命令行工具，其中一些重要的工具包括：</p>
<ul>
<li><strong>live555MediaServer</strong>：一个简单的流媒体服务器，可以提供实时流媒体的播放和转发功能。</li>
<li><strong>openRTSP</strong>：与上一个问题中提到的 OpenRTSP 工具类似，用于从 RTSP 服务器获取实时流媒体数据。</li>
<li><strong>testOnDemandRTSPServer</strong>：一个测试用的 RTSP 服务器，可以模拟实时流媒体的播放和控制。</li>
<li><strong>MPEG2TransportStreamIndexer</strong>：用于索引和检查 MPEG2 Transport Stream（M2TS）文件的工具。</li>
</ul>
</li>
<li><p><strong>跨平台支持</strong>：livemedia-utils 可以在多个操作系统上运行，包括 Linux、Windows、macOS 等。这使得它成为一个方便且广泛可用的工具，用于处理实时流媒体数据。</p>
</li>
<li><p><strong>开源和可定制性</strong>：livemedia-utils 是开源的，你可以查看其源代码、理解其实现细节，并对其进行定制和扩展，以满足特定需求。</p>
</li>
</ol>
<p>需要注意的是，livemedia-utils 是一个命令行工具集，适用于开发和调试实时流媒体应用程序，以及自动化脚本和批处理任务。如果你需要一个更完整的流媒体服务器或客户端，可能需要考虑其他更专业的流媒体解决方案或框架。</p>
<hr>
<h2 id="e2fsck"><a href="#e2fsck" class="headerlink" title="e2fsck"></a>e2fsck</h2><p><code>e2fsck</code>是用于检查和修复ext2、ext3和ext4文件系统中的错误的命令。下面是对<code>e2fsck</code>命令的详细解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e2fsck [选项] 设备</span><br></pre></td></tr></table></figure>

<p>其中，<code>选项</code>是一些可用的标志和参数，<code>设备</code>是要检查和修复的文件系统所在的设备或分区。</p>
<p>常用的选项包括：</p>
<ul>
<li><code>-p</code>：自动修复不需要人工干预的错误。</li>
<li><code>-y</code>：自动回答”yes”以所有问题，用于无人值守操作。</li>
<li><code>-f</code>：强制运行<code>e2fsck</code>，即使文件系统被标记为已经干净。</li>
<li><code>-c</code>：检查设备上的坏扇区，并将其添加到坏块列表中。</li>
<li><code>-n</code>：仅显示要执行的操作，而不实际执行它们。</li>
<li><code>-v</code>：显示更详细的输出，包括修复过程中的详细信息。</li>
<li><code>-b  备份文件</code>：将修复前的元数据备份到指定的文件中。</li>
</ul>
<p>除了选项之外，您还需要指定要检查和修复的文件系统所在的设备。例如，如果您要检查&#x2F;dev&#x2F;sda1上的文件系统，可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e2fsck /dev/sda1</span><br></pre></td></tr></table></figure>

<p><code>e2fsck</code>命令将会扫描文件系统并显示任何检测到的错误。如果它发现任何错误，它会提示您是否修复它们。您可以根据提示进行选择，或者使用前面提到的选项自动修复错误。</p>
<p>请注意，在运行<code>e2fsck</code>之前，建议您确保文件系统是以只读模式挂载的，以避免进一步损坏。如果您不能以只读模式挂载文件系统，最好使用其他工具或在紧急情况下考虑使用专业的数据恢复服务。</p>
<h2 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h2><p>Nano 是一个文本编辑器，常用于 Linux 和其他 Unix-like 系统。它是一个简单、易于使用的命令行编辑器，适合初学者和那些寻找基本编辑功能的用户。下面是 Nano 的一些详解：</p>
<ol>
<li><p>启动 Nano：<br>要启动 Nano 编辑器，请在终端中输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano</span><br></pre></td></tr></table></figure>
<p>如果要打开特定文件进行编辑，请在命令后加上文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>Nano 的界面：<br>Nano 编辑器的界面相对简洁。在编辑器的底部显示了一些常用的命令说明，如保存文件、退出编辑器等。使用箭头键导航光标在文本中移动。</p>
</li>
<li><p>基本操作：</p>
<ul>
<li>输入文本：在编辑器中直接键入文本即可。</li>
<li>保存文件：按下 <code>Ctrl + O</code>，然后按下 <code>Enter</code>，将文件保存到当前文件名。</li>
<li>退出编辑器：按下 <code>Ctrl + X</code>，如果文件有未保存的更改，Nano 会提示您保存或放弃更改。</li>
</ul>
</li>
<li><p>快捷键：<br>Nano 提供了一些常用的快捷键来进行各种操作：</p>
<ul>
<li><code>Ctrl + G</code>：显示帮助菜单，其中包含可用的命令列表。</li>
<li><code>Ctrl + K</code>：剪切当前行或选定的文本。</li>
<li><code>Ctrl + U</code>：粘贴剪切的文本。</li>
<li><code>Ctrl + W</code>：搜索文本。</li>
<li><code>Ctrl + \</code>：替换文本。</li>
<li><code>Ctrl + C</code>：显示当前光标位置的行号。</li>
</ul>
</li>
<li><p>配置文件：<br>Nano 的行为可以通过编辑配置文件 <code>~/.nanorc</code> 进行自定义。您可以在配置文件中定义颜色方案、键绑定和其他首选项。</p>
</li>
<li><p>其他功能：<br>Nano 提供了其他一些功能，如自动缩进、语法高亮、多文档编辑等。您可以通过命令行参数或配置文件来启用或禁用这些功能。</p>
</li>
</ol>
<p>Nano 是一个简单而实用的文本编辑器，尤其适合新手和需要基本编辑功能的用户。它的命令行界面和快捷键使得编辑文本文件变得方便快捷。</p>
<hr>
<h2 id="asan-工具-详解"><a href="#asan-工具-详解" class="headerlink" title="asan 工具 详解"></a>asan 工具 详解</h2><p>AddressSanitizer（ASan）是一种用于检测内存错误的工具，它是 LLVM 编译器工具链的一部分。ASan 主要用于检测内存越界访问、使用未初始化的内存、内存泄漏等常见的内存错误。</p>
<p>下面是 ASan 的一些主要特点和工作原理的详细解释：</p>
<ol>
<li><p>内存错误检测：ASan 在程序执行期间动态地分配和管理内存，并在每个内存块的边界添加额外的元数据。当程序访问超出分配的内存范围或使用未初始化的内存时，ASan 会检测到这些错误并生成相应的报告。</p>
</li>
<li><p>内存泄漏检测：ASan 跟踪程序中动态分配的内存，并在程序结束时检查是否有未释放的内存。如果存在内存泄漏，ASan 会生成相应的报告指示泄漏的内存块的位置。</p>
</li>
<li><p>元数据重映射：ASan 使用位图技术来存储内存元数据，以减少对内存的额外开销。这种位图会与程序的内存布局进行映射，以便快速定位错误和泄漏。</p>
</li>
<li><p>堆栈跟踪：当发生内存错误时，ASan 会捕获当前的函数调用堆栈信息，以便定位错误发生的位置。这对于调试和定位问题非常有帮助。</p>
</li>
<li><p>崩溃报告：当程序发生内存错误导致崩溃时，ASan 会生成详细的崩溃报告，其中包含了堆栈跟踪、错误类型和发生位置等信息。</p>
</li>
</ol>
<p>使用 ASan 进行内存错误检测时，需要使用支持 ASan 的编译器进行编译，并在链接时启用 ASan 的运行时库。编译和链接选项可以根据具体的编译器和工具链有所差异。</p>
<p>ASan 是一个强大的工具，可以帮助开发者在早期阶段捕获和调试内存错误，提高代码的质量和可靠性。然而，由于 ASan 需要额外的运行时开销和内存使用，对于大型项目或性能敏感的代码，可能需要在测试和生产环境中进行谨慎使用和评估。</p>
<hr>
<h2 id="asan-工具-使用-示例"><a href="#asan-工具-使用-示例" class="headerlink" title="asan 工具 使用 示例"></a>asan 工具 使用 示例</h2><p>以下是一个简单的示例，演示如何使用 AddressSanitizer（ASan）来检测和调试内存错误：</p>
<ol>
<li>编写代码文件（示例文件名为 <code>example.c</code>）：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* buffer = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line">    buffer[<span class="number">10</span>] = <span class="number">42</span>; <span class="comment">// 内存越界访问</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用编译器进行编译和链接，启用 ASan：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang -fsanitize=address -g example.c -o example</span></span><br></pre></td></tr></table></figure>

<p>或者使用 gcc 编译器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -fsanitize=address -g example.c -o example</span></span><br></pre></td></tr></table></figure>

<p>在编译过程中，我们通过添加 <code>-fsanitize=address</code> 选项来启用 ASan。</p>
<ol start="3">
<li>运行程序：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./example</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>ASan 检测到内存错误后，会生成相应的报告并打印在终端上，类似于以下内容：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==12345==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000eff0 at pc 0x0000004009b9</span><br><span class="line">READ of size 4 at 0x60200000eff0 thread T0</span><br><span class="line">    #0 0x4009b8 in main example.c:6</span><br><span class="line">    #1 0x7ffff6b4ab96 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)</span><br><span class="line">    #2 0x4008c9 in _start (/path/to/example+0x4008c9)</span><br><span class="line"></span><br><span class="line">Address 0x60200000eff0 is a wild pointer.</span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow example.c:6 in main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c047fffbe70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbe80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbe90: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbea0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbeb0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">=&gt;0x0c047fffbec0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa[04]fa</span><br><span class="line">  0x0c047fffbed0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbee0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbef0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbf00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbf10: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8</span><br><span class="line"></span><br><span class="line"> application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after return:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==12345==ABORTING</span><br></pre></td></tr></table></figure>

<p>报告中会提供详细的错误信息，包括错误类型、错误地址、堆栈跟踪等。在这个示例中，ASan 检测到了堆缓冲区溢出错误。</p>
<p>通过这种方式，ASan 可以帮助开发者捕获和调试内存错误，提供有用的诊断信息，以帮助修复问题和提高代码质量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_11_apt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_11_apt/" class="post-title-link" itemprop="url">linux_2_11_apt</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>apt相关命令笔记</li>
</ul>
<h2 id="linux-apt-file命令-详解"><a href="#linux-apt-file命令-详解" class="headerlink" title="linux apt-file命令 详解"></a>linux apt-file命令 详解</h2><p><code>apt-file</code> 是一个用于查询 APT 软件包中包含的文件的命令行工具。它不仅可以帮助你查找已安装软件包中的文件，还可以查找尚未安装但包含在软件包中的文件。使用 <code>apt-file</code> 可以帮助你找到特定文件属于哪个软件包。</p>
<p>以下是一些常见的 <code>apt-file</code> 命令及其说明：</p>
<ol>
<li><p><strong>安装 apt-file：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install apt-file</span><br></pre></td></tr></table></figure>
<p>在使用 <code>apt-file</code> 之前，你需要安装它。</p>
</li>
<li><p><strong>更新文件数据库：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-file update</span><br></pre></td></tr></table></figure>
<p>在查询之前，你需要先更新文件数据库，以确保它包含最新的信息。</p>
</li>
<li><p><strong>搜索已安装软件包中的文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-file list 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令列出指定已安装软件包中包含的文件。</p>
</li>
<li><p><strong>搜索未安装软件包中的文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-file search 文件名</span><br></pre></td></tr></table></figure>
<p>该命令搜索未安装软件包中包含指定文件名的软件包。</p>
</li>
<li><p><strong>显示与正则表达式匹配的所有软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-file search --regexp <span class="string">&#x27;正则表达式&#x27;</span></span><br></pre></td></tr></table></figure>
<p>该命令显示与指定正则表达式匹配的所有软件包。</p>
</li>
<li><p><strong>查找包含某个目录的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-file search /path/to/directory</span><br></pre></td></tr></table></figure>
<p>该命令搜索包含指定目录的软件包。</p>
</li>
<li><p><strong>显示文件属于哪个软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-file search --package-only 文件名</span><br></pre></td></tr></table></figure>
<p>该命令仅显示包含指定文件名的软件包。</p>
</li>
<li><p><strong>在所有已知软件包中搜索文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-file search --all 文件名</span><br></pre></td></tr></table></figure>
<p>该命令在所有已知的软件包中搜索指定文件名，包括未安装的软件包。</p>
</li>
</ol>
<p>使用 <code>apt-file</code> 可以方便地查找软件包中的文件，这对于理解系统中的文件属于哪个软件包、找出软件包提供的特定文件等非常有用。</p>
<h2 id="linux-apt-cache命令-详解"><a href="#linux-apt-cache命令-详解" class="headerlink" title="linux apt-cache命令 详解"></a>linux apt-cache命令 详解</h2><p><code>apt-cache</code> 是 Linux 中用于查询 APT (Advanced Package Tool) 缓存的命令行工具。它允许用户从本地软件包数据库中检索有关软件包的信息，包括依赖关系、版本、描述等。</p>
<p>以下是一些常见的 <code>apt-cache</code> 命令及其说明：</p>
<ol>
<li><p><strong>查看软件包信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache show 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令显示有关指定软件包的详细信息，包括版本、大小、依赖关系、描述等。</p>
</li>
<li><p><strong>搜索软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search 关键词</span><br></pre></td></tr></table></figure>
<p>通过该命令可以搜索软件包。它会列出所有与指定关键词相关的软件包。</p>
</li>
<li><p><strong>显示软件包提供的文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache showpkg 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示软件包提供的文件列表，以及该软件包所依赖的其他软件包。</p>
</li>
<li><p><strong>显示软件包的依赖关系：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache depends 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示指定软件包的依赖关系。</p>
</li>
<li><p><strong>显示软件包的反向依赖关系（被哪些软件包依赖）：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache rdepends 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示指定软件包的反向依赖关系，即依赖于该软件包的其他软件包。</p>
</li>
<li><p><strong>显示 APT 缓存统计信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache stats</span><br></pre></td></tr></table></figure>
<p>该命令用于显示有关 APT 缓存的统计信息，包括软件包的数量、大小等。</p>
</li>
<li><p><strong>显示软件包的提供者信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache showpkg -a 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令显示软件包在不同体系结构上的提供者信息。</p>
</li>
<li><p><strong>显示软件包的正则表达式匹配信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache showpkg --names-only <span class="string">&#x27;正则表达式&#x27;</span></span><br></pre></td></tr></table></figure>
<p>该命令显示与指定正则表达式匹配的软件包名称。</p>
</li>
</ol>
<p>以上是一些常见的 <code>apt-cache</code> 命令。这些命令可以帮助你更好地了解软件包的信息和相互关系。</p>
<h2 id="linux-apt-apt-get"><a href="#linux-apt-apt-get" class="headerlink" title="linux apt apt-get"></a>linux apt apt-get</h2><p><code>apt</code> 和 <code>apt-get</code> 是 Linux 系统中用于管理软件包的两个命令，它们都属于 Advanced Package Tool（APT）工具集。</p>
<ol>
<li><p><strong>apt-get:</strong></p>
<ul>
<li><code>apt-get</code> 是较早的软件包管理命令，用于安装、卸载、更新和管理软件包。它使用比较直接的命令语法，如 <code>apt-get install</code>、<code>apt-get remove</code> 等。</li>
<li>示例：安装一个软件包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install 软件包名称</span><br></pre></td></tr></table></figure></li>
<li><code>apt-get</code> 在操作时需要使用 <code>sudo</code> 以管理员权限执行。</li>
</ul>
</li>
<li><p><strong>apt:</strong></p>
<ul>
<li><code>apt</code> 是 <code>apt-get</code> 的新一代包装，提供了更简洁、友好的命令行接口，并且支持逐步更新。它整合了一些常用的 <code>apt-get</code> 子命令，使得用户在使用时更为方便。</li>
<li>示例：安装一个软件包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install 软件包名称</span><br></pre></td></tr></table></figure></li>
<li><code>apt</code> 使用时同样需要 <code>sudo</code> 权限。</li>
</ul>
</li>
</ol>
<p>一些使用 <code>apt</code> 相对于 <code>apt-get</code> 的优点包括：</p>
<ul>
<li>更友好的输出和进度条。</li>
<li>能够显示可用的自动修复指令。</li>
<li>与 <code>apt</code> 命令一起使用的时候，不需要再运行 <code>apt-get update</code> 命令。</li>
</ul>
<p>两者的基本功能是相似的，但 <code>apt</code> 提供了更为现代和用户友好的界面。在新的 Ubuntu 版本中，推荐使用 <code>apt</code> 命令。在老的系统或某些特殊情况下，你可能会看到人们仍然使用 <code>apt-get</code>。</p>
<h2 id="linux-apt命令-详解"><a href="#linux-apt命令-详解" class="headerlink" title="linux apt命令 详解"></a>linux apt命令 详解</h2><p><code>apt</code>（Advanced Package Tool）是用于在Debian及其衍生发行版（如Ubuntu）中进行软件包管理的工具。它提供了一组命令，用于搜索、安装、卸载、更新和管理软件包。以下是一些常用的<code>apt</code>命令及其说明：</p>
<ol>
<li><p><strong>更新软件包列表：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure>
<p>该命令用于从软件源服务器更新本地软件包列表，以获取最新的软件包信息。在执行其他<code>apt</code>命令之前，通常应该首先运行此命令。</p>
</li>
<li><p><strong>升级已安装的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br></pre></td></tr></table></figure>
<p>该命令用于升级已安装的所有软件包到最新可用的版本。在执行升级操作之前，建议先运行<code>apt update</code>以确保软件包列表是最新的。</p>
</li>
<li><p><strong>升级系统：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt dist-upgrade</span><br></pre></td></tr></table></figure>
<p>该命令用于执行更大规模的系统升级，包括新内核的安装等。它会比<code>apt upgrade</code>更积极地解决依赖关系。</p>
</li>
<li><p><strong>安装软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于安装指定软件包。你可以同时安装多个软件包，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install 软件包1 软件包2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>卸载软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt remove 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于卸载指定软件包，但保留其配置文件。如果你希望同时删除配置文件，可以使用<code>purge</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt purge 软件包名称</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>搜索软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search 关键词</span><br></pre></td></tr></table></figure>
<p>该命令用于搜索与指定关键词相关的软件包。</p>
</li>
<li><p><strong>显示软件包信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt show 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示有关指定软件包的详细信息，包括版本、大小、依赖关系等。</p>
</li>
<li><p><strong>清理无用的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt autoremove</span><br></pre></td></tr></table></figure>
<p>该命令用于删除已安装但不再需要的软件包。</p>
</li>
</ol>
<p>这些是一些<code>apt</code>命令的常见用法。你可以使用<code>man apt</code>查看<code>apt</code>的手册以获取更详细的信息。</p>
<h2 id="linux-apt命令-常用技巧"><a href="#linux-apt命令-常用技巧" class="headerlink" title="linux apt命令 常用技巧"></a>linux apt命令 常用技巧</h2><p>在使用<code>apt</code>命令时，有一些常用的技巧和实用的选项，可以提高软件包管理的效率。以下是一些常见的技巧：</p>
<ol>
<li><p><strong>查看软件包信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt show 软件包名称</span><br></pre></td></tr></table></figure>
<p>可以使用该命令查看软件包的详细信息，包括版本、大小、依赖关系等。</p>
</li>
<li><p><strong>查找软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search 关键词</span><br></pre></td></tr></table></figure>
<p>通过该命令可以搜索软件包。可以根据关键词查找与之相关的软件包。</p>
</li>
<li><p><strong>模糊搜索：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt list | grep 关键词</span><br></pre></td></tr></table></figure>
<p>使用<code>apt list</code>列出所有可用软件包，然后通过<code>grep</code>进行模糊搜索。</p>
</li>
<li><p><strong>列出已安装的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt list --installed</span><br></pre></td></tr></table></figure>
<p>该命令列出所有已经安装的软件包。</p>
</li>
<li><p><strong>列出可升级的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt list --upgradeable</span><br></pre></td></tr></table></figure>
<p>该命令列出可以升级的所有软件包。</p>
</li>
<li><p><strong>查看软件包依赖关系：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt depends 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于查看指定软件包的依赖关系。</p>
</li>
<li><p><strong>查看软件包提供的文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L 软件包名称</span><br></pre></td></tr></table></figure>
<p>使用<code>dpkg</code>命令查看指定软件包提供的文件列表。</p>
</li>
<li><p><strong>使用代理服务器：</strong><br>如果你在使用代理服务器，可以在<code>/etc/apt/apt.conf</code>中设置代理配置，或者在命令行中使用<code>-o</code>选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt -o Acquire::http::Proxy=<span class="string">&quot;http://代理地址&quot;</span> update</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用多线程下载：</strong><br>在更新软件包时，可以使用多线程进行下载以提高速度。在<code>/etc/apt/apt.conf</code>中添加以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Acquire::http::Pipeline-Depth &quot;0&quot;;</span><br><span class="line">Acquire::http::No-Cache &quot;true&quot;;</span><br><span class="line">Acquire::http::Dl-Limit &quot;256&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用国内镜像：</strong><br>将系统的软件源替换为国内镜像源可以加快下载速度。在<code>/etc/apt/sources.list</code>中修改软件源，将其替换为适合你的国内源。</p>
</li>
</ol>
<p>这些技巧可以让你更方便、更高效地使用<code>apt</code>命令进行软件包管理。根据个人需要，你可以结合这些技巧执行不同的操作。</p>
<h2 id="apt-家族"><a href="#apt-家族" class="headerlink" title="apt 家族"></a>apt 家族</h2><h3 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h3><ul>
<li><p>update</p>
<ul>
<li>从所有配置的源中下载包信息。其他的命令对这些数据进行操作</li>
</ul>
</li>
<li><p>upgrade</p>
<ul>
<li>upgrade 用于安装当前安装在系统上的所有软件包的可用升级，这些软件包来自于 sources.list(5) 配置的源的升级</li>
<li>如果有需要满足的依赖关系，新的安装包将会被安装。但是现有的安装包永远都不会被删除。如果一个软件包的升级需要删除一个已安装的软件包，那么这个软件包的升级将不会被执行</li>
</ul>
</li>
<li><p>full-upgrade</p>
<ul>
<li>full-upgrade执行升级的功能，但如果需要升级系统，它将删除当前安装的软件包，如果需要这样做来升级整个系统的话。</li>
</ul>
</li>
<li><p>install, remove, purge</p>
<ul>
<li>install, 安装软件包</li>
<li>remove, 仅删除软件包数据，会留下用户配置信息</li>
<li>purge, 会既删除软件包数据，也会删除用户配置信息</li>
</ul>
</li>
<li><p>autoremove</p>
<ul>
<li>autoremove是用来删除那些自动安装的软件包，以满足依赖的软件包，但现在不再需要了，因为依赖关系改变了或需要它们的软件包在这期间被删除，因此不再需要。</li>
</ul>
</li>
<li><p>search</p>
<ul>
<li>搜索可以用来在可用的软件包列表中搜索给定包的列表中搜索，并显示匹配结果。</li>
</ul>
</li>
<li><p>show</p>
<ul>
<li>显示有关给定软件包的信息，包括它的依赖性、安装和下载大小、软件包的可用来源以及对它的描述和下载大小，软件包的可用来源，软件包内容的描述等等。包的内容描述等等。</li>
</ul>
</li>
<li><p>list</p>
<ul>
<li>list与dpkg-query –list有点类似，它可以显示满足特定条件的满足特定条件的软件包列表。</li>
</ul>
</li>
<li><p>edit-sources</p>
<ul>
<li>edit-sources 可以让你在你喜欢的文本编辑器中编辑 sources.list(5) 文件。同时也提供基本的智能检查。</li>
</ul>
</li>
</ul>
<h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h3><ul>
<li><p>update</p>
</li>
<li><p>upgrade</p>
</li>
<li><p>dist-upgrade</p>
<ul>
<li>dist-upgrade除了执行升级的功能外，还能智能地处理新版本软件包的依赖关系变化；apt-get有一个 “智能 “的冲突解决系统，它将尝试升级最重要的软件包如果有必要的话，它会尝试升级最重要的软件包，而牺牲掉不那么重要的软件包。</li>
</ul>
</li>
<li><p>dselect-upgrade</p>
<ul>
<li>dselect-upgrade与传统的Debian packaging前端，即 dselect(1)。</li>
</ul>
</li>
<li><p>install</p>
</li>
<li><p>remove</p>
</li>
<li><p>purge</p>
</li>
<li><p>source </p>
<ul>
<li>获取源码包</li>
</ul>
</li>
<li><p>build-dep</p>
<ul>
<li>build-dep 导致 apt-get 安装&#x2F;移除软件包，以满足一个源代码软件包的构建的依赖性。</li>
</ul>
</li>
<li><p>check</p>
<ul>
<li>检查是一个诊断工具；它更新软件包缓存并检查损坏的依赖关系。</li>
</ul>
</li>
<li><p>download</p>
<ul>
<li>download将下载给定的二进制包到当前目录。</li>
</ul>
</li>
<li><p>clean</p>
<ul>
<li>清理本地存储库中检索到的软件包文件。它删除了除锁文件外的所有文件都从 &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F; 和&#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;partial&#x2F;。</li>
</ul>
</li>
<li><p>autoclean</p>
<ul>
<li>和clean一样，autoclean也会清除本地仓库中检索到的软件包文件。不同的是不同的是，它只删除那些不能再被下载的软件包文件，并且基本上是无用的。</li>
</ul>
</li>
<li><p>changelog</p>
<ul>
<li>changelog试图下载一个软件包的更新日志并通过sensible-pager。</li>
</ul>
</li>
<li><p>indextargets</p>
<ul>
<li>默认情况下，显示一个deb822格式的所有数据文件的信息列表(又称索引目标) apt-get update 会下载。</li>
</ul>
</li>
</ul>
<h3 id="apt-cache"><a href="#apt-cache" class="headerlink" title="apt-cache"></a>apt-cache</h3><p>在Linux中，<code>apt-cache</code>是一个用于查询APT（Advanced Package Tool）软件包管理器缓存的命令行工具。它允许您查看已安装软件包和可用软件包的详细信息，以及搜索软件包的相关信息。</p>
<p>下面是一些常见的<code>apt-cache</code>命令选项和用法：</p>
<ol>
<li><p>查询软件包信息：</p>
<ul>
<li><code>apt-cache show &lt;package&gt;</code>：显示指定软件包的详细信息，包括版本、描述、作者、依赖关系等。</li>
<li><code>apt-cache showpkg &lt;package&gt;</code>：显示软件包的包信息以及其相关的依赖关系和依赖它的软件包信息。</li>
</ul>
</li>
<li><p>搜索软件包：</p>
<ul>
<li><code>apt-cache search &lt;pattern&gt;</code>：根据模式搜索可用的软件包。模式可以是软件包名称、关键字或描述的一部分。</li>
<li><code>apt-cache search &lt;keyword1&gt; &lt;keyword2&gt;</code>：根据多个关键字搜索软件包。这将返回同时包含这些关键字的软件包。</li>
<li><code>apt-cache search --names-only &lt;pattern&gt;</code>：只搜索软件包的名称而不搜索描述或关键字。</li>
</ul>
</li>
<li><p>显示依赖关系：</p>
<ul>
<li><code>apt-cache depends &lt;package&gt;</code>：显示指定软件包的依赖关系，包括它所依赖的软件包和被它所依赖的软件包。</li>
<li><code>apt-cache rdepends &lt;package&gt;</code>：显示依赖于指定软件包的其他软件包。</li>
</ul>
</li>
<li><p>清除软件包缓存：</p>
<ul>
<li><code>apt-cache clean</code>：清除APT软件包管理器的本地软件包缓存。这将删除已下载的软件包文件，但不会删除已安装的软件包。</li>
</ul>
</li>
</ol>
<p>这些是<code>apt-cache</code>命令的一些常见选项和用法。您可以使用<code>apt-cache</code>命令来获取关于软件包的信息、搜索软件包以及查看软件包的依赖关系。在使用这些命令时，请确保以管理员权限运行，例如使用<code>sudo</code>命令。</p>
<h3 id="apt-file"><a href="#apt-file" class="headerlink" title="apt-file"></a>apt-file</h3><ul>
<li>查找包文件<ul>
<li><code>apt-file find libopenssh.so</code></li>
</ul>
</li>
</ul>
<p>在Linux中，<code>apt-file</code>是一个用于查询软件包文件的命令行工具。它可以帮助您查找特定文件属于哪个软件包，并可以搜索软件包中的文件。</p>
<p>以下是一些常见的<code>apt-file</code>命令选项和用法：</p>
<ol>
<li><p>初始化数据库：<br>在第一次使用<code>apt-file</code>之前，需要初始化文件数据库。使用以下命令进行初始化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-file update</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询文件所属的软件包：</p>
<ul>
<li><code>apt-file search &lt;filename&gt;</code>：查询指定文件所属的软件包。文件名可以是绝对路径或相对路径。</li>
<li>例如：<code>apt-file search /bin/ls</code>将返回包含<code>/bin/ls</code>的软件包。</li>
</ul>
</li>
<li><p>列出软件包中的文件：</p>
<ul>
<li><code>apt-file list &lt;package&gt;</code>：列出指定软件包中的所有文件。</li>
<li>例如：<code>apt-file list coreutils</code>将列出<code>coreutils</code>软件包中的所有文件。</li>
</ul>
</li>
<li><p>搜索文件名：</p>
<ul>
<li><code>apt-file search &lt;pattern&gt;</code>：根据模式搜索文件名。模式可以是文件名的一部分或关键字。</li>
<li>例如：<code>apt-file search libstdc++.so</code>将返回包含<code>libstdc++.so</code>的软件包。</li>
</ul>
</li>
</ol>
<p>请注意，<code>apt-file</code>命令需要根据您的系统安装软件包文件的索引数据库。因此，在使用<code>apt-file</code>之前，需要确保数据库已经初始化并更新。您可以使用<code>sudo apt-file update</code>命令来更新数据库。</p>
<p>使用<code>apt-file</code>命令可以帮助您轻松地查找软件包文件和软件包中的文件。这对于解决缺少文件或查找特定文件所属的软件包非常有用。</p>
<h3 id="apt-mark"><a href="#apt-mark" class="headerlink" title="apt-mark"></a>apt-mark</h3><p>在Linux中，<code>apt-mark</code>是一个用于标记和操作APT软件包状态的命令行工具。它可以用于设置、清除和查询软件包的各种标记，以及管理软件包的状态。</p>
<p>以下是一些常见的<code>apt-mark</code>命令选项和用法：</p>
<ol>
<li><p>标记软件包状态：</p>
<ul>
<li><code>apt-mark hold &lt;package&gt;</code>：将指定软件包标记为”hold”状态，阻止其被升级或删除。</li>
<li><code>apt-mark unhold &lt;package&gt;</code>：取消指定软件包的”hold”标记。</li>
</ul>
</li>
<li><p>设置软件包自动安装状态：</p>
<ul>
<li><code>apt-mark auto &lt;package&gt;</code>：将指定软件包标记为”auto”状态，允许APT自动安装和升级。</li>
<li><code>apt-mark manual &lt;package&gt;</code>：将指定软件包标记为”manual”状态，阻止APT自动安装和升级。</li>
</ul>
</li>
<li><p>查询软件包状态：</p>
<ul>
<li><code>apt-mark showhold</code>：显示所有被标记为”hold”状态的软件包。</li>
<li><code>apt-mark showauto</code>：显示所有被标记为”auto”状态的软件包。</li>
</ul>
</li>
<li><p>清除软件包状态：</p>
<ul>
<li><code>apt-mark unmarkauto &lt;package&gt;</code>：取消指定软件包的”auto”标记。</li>
<li><code>apt-mark unmarkhold &lt;package&gt;</code>：取消指定软件包的”hold”标记。</li>
<li><code>apt-mark unmarkall</code>：清除所有软件包的标记。</li>
</ul>
</li>
</ol>
<p>这些是<code>apt-mark</code>命令的一些常见选项和用法。您可以使用<code>apt-mark</code>命令来设置软件包的状态标记，以控制APT软件包管理器的行为。这对于防止软件包被升级或删除、手动管理软件包状态以及自定义软件包安装行为非常有用。请注意，在使用这些命令时，需要以管理员权限运行，例如使用<code>sudo</code>命令。</p>
<h2 id="aptitude"><a href="#aptitude" class="headerlink" title="aptitude"></a>aptitude</h2><p><code>aptitude</code>是Linux系统中的一个交互式软件包管理器，用于安装、升级、删除和管理软件包。它提供了一个用户友好的命令行界面，可以方便地浏览、搜索和操作软件包。</p>
<p>下面是一些常见的<code>aptitude</code>命令选项和用法：</p>
<ol>
<li><p>浏览软件包列表：</p>
<ul>
<li><code>aptitude</code>：启动<code>aptitude</code>界面，显示可用软件包列表。</li>
<li>使用箭头键或快捷键浏览软件包列表。</li>
<li>输入软件包名或关键字进行搜索。</li>
</ul>
</li>
<li><p>安装和卸载软件包：</p>
<ul>
<li>使用<code>+</code>号标记软件包以进行安装。</li>
<li>使用<code>-</code>号标记软件包以进行卸载。</li>
<li>按下<code>g</code>键执行所有标记的操作。</li>
</ul>
</li>
<li><p>查看软件包详细信息：</p>
<ul>
<li>在软件包列表中选中一个软件包，按下<code>Enter</code>键以查看详细信息。</li>
<li>显示软件包的描述、版本、依赖关系和其他相关信息。</li>
</ul>
</li>
<li><p>搜索软件包：</p>
<ul>
<li>按下<code>/</code>键进行搜索，然后输入要搜索的软件包名称或关键字。</li>
<li>使用箭头键浏览搜索结果。</li>
</ul>
</li>
<li><p>进阶命令：</p>
<ul>
<li><code>aptitude update</code>：更新软件包列表。</li>
<li><code>aptitude upgrade</code>：升级可用的软件包。</li>
<li><code>aptitude dist-upgrade</code>：执行发行版升级，包括软件包和系统组件的升级。</li>
<li><code>aptitude clean</code>：清理软件包缓存。</li>
<li><code>aptitude autoclean</code>：清理旧版本的软件包。</li>
</ul>
</li>
</ol>
<p>请注意，<code>aptitude</code>命令提供了更多功能和选项，可以根据您的需求进行更高级的软件包管理操作。在使用<code>aptitude</code>时，请仔细阅读相关文档和手册，以了解更多命令和选项的详细信息。</p>
<p>总体而言，<code>aptitude</code>是一个功能强大且易于使用的软件包管理器，提供了交互式的方式来管理和控制Linux系统上的软件包。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_12_dpkg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_12_dpkg/" class="post-title-link" itemprop="url">linux_2_12_dpkg</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>dpkg命令</li>
</ul>
<h2 id="linux-dpkg命令-详解"><a href="#linux-dpkg命令-详解" class="headerlink" title="linux dpkg命令 详解"></a>linux dpkg命令 详解</h2><p><code>dpkg</code> 是 Debian 系统中用于管理软件包的基础工具。它直接处理软件包的安装、配置和卸载，不像更高级的工具（例如 <code>apt</code>）会处理软件包的依赖关系。以下是一些常见的 <code>dpkg</code> 命令及其说明：</p>
<ol>
<li><p><strong>安装软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -i 软件包文件.deb</span><br></pre></td></tr></table></figure>
<p>该命令用于安装指定的 <code>.deb</code> 格式的软件包。</p>
</li>
<li><p><strong>卸载软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -r 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于卸载已安装的软件包，但保留其配置文件。</p>
</li>
<li><p><strong>卸载软件包并删除配置文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -P 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于卸载已安装的软件包，并删除其配置文件。</p>
</li>
<li><p><strong>查询软件包信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于列出已安装软件包的信息，包括软件包的状态、版本等。</p>
</li>
<li><p><strong>查询已安装的文件所属的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S /path/to/file</span><br></pre></td></tr></table></figure>
<p>该命令用于查找指定文件所属的已安装软件包。</p>
</li>
<li><p><strong>显示软件包的详细信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -p 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示指定软件包的详细信息，包括版本、描述、依赖关系等。</p>
</li>
<li><p><strong>重新配置软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg-reconfigure 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于重新配置已安装软件包，可以修改软件包的配置参数。</p>
</li>
<li><p><strong>检查软件包的完整性：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --verify</span><br></pre></td></tr></table></figure>
<p>该命令用于检查系统上已安装软件包的完整性，以确保文件未被修改。</p>
</li>
<li><p><strong>查看软件包的配置文件状态：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-query -W -f=<span class="string">&#x27;$&#123;Conffiles&#125;\n&#x27;</span> 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示软件包的配置文件状态。</p>
</li>
</ol>
<p>这些是一些常见的 <code>dpkg</code> 命令。请注意，<code>dpkg</code> 直接操作软件包而不考虑依赖关系，因此在处理软件包时要小心，以免引起依赖问题。在实际使用中，更推荐使用高级包管理工具如 <code>apt</code> 或 <code>apt-get</code>，它们能够更好地处理依赖关系。</p>
<h2 id="linux-dpkg命令-常用技巧"><a href="#linux-dpkg命令-常用技巧" class="headerlink" title="linux dpkg命令 常用技巧"></a>linux dpkg命令 常用技巧</h2><p>以下是一些在使用 <code>dpkg</code> 命令时常用的技巧：</p>
<ol>
<li><p><strong>查看系统上已安装的软件包列表：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l</span><br></pre></td></tr></table></figure>
<p>这会列出系统上所有已安装的软件包，包括软件包的状态、版本和简短描述。</p>
</li>
<li><p><strong>过滤和搜索已安装的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep 关键词</span><br></pre></td></tr></table></figure>
<p>使用 <code>grep</code> 过滤已安装软件包列表，以查找包含特定关键词的软件包。</p>
</li>
<li><p><strong>查找文件所属的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S /path/to/file</span><br></pre></td></tr></table></figure>
<p>该命令用于查找指定文件所属的已安装软件包。</p>
</li>
<li><p><strong>查看软件包的详细信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -p 软件包名称</span><br></pre></td></tr></table></figure>
<p>通过这个命令，你可以查看指定软件包的详细信息，包括版本、描述、依赖关系等。</p>
</li>
<li><p><strong>查看软件包的配置文件状态：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-query -W -f=<span class="string">&#x27;$&#123;Conffiles&#125;\n&#x27;</span> 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示软件包的配置文件状态。</p>
</li>
<li><p><strong>重新配置已安装的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg-reconfigure 软件包名称</span><br></pre></td></tr></table></figure>
<p>使用这个命令可以重新配置已安装的软件包，通常用于修改软件包的配置参数。</p>
</li>
<li><p><strong>检查软件包的完整性：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg --verify</span><br></pre></td></tr></table></figure>
<p>该命令用于检查系统上已安装软件包的完整性，以确保文件未被修改。</p>
</li>
<li><p><strong>清理未完全安装或删除的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -l | grep ^rc | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">sudo</span> dpkg --purge</span><br></pre></td></tr></table></figure>
<p>这个命令可以清理掉系统中未完全安装或删除的软件包。</p>
</li>
</ol>
<p>请注意，使用 <code>dpkg</code> 命令需要小心，因为它不会自动处理软件包的依赖关系。在处理软件包时，建议使用更高级的包管理工具如 <code>apt</code> 或 <code>apt-get</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/25/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/27/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
