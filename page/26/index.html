<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/26/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/26/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_10_tmux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_10_tmux/" class="post-title-link" itemprop="url">linux_2_10_tmux</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>tmux命令笔记</li>
</ul>
<h2 id="linux-tmux命令-详解"><a href="#linux-tmux命令-详解" class="headerlink" title="linux tmux命令 详解"></a>linux tmux命令 详解</h2><p><code>tmux</code>（终端复用工具）是一个在终端窗口中创建和管理多个会话（sessions）、窗口（windows）和面板（panes）的工具。以下是一些常用的<code>tmux</code>命令的详解：</p>
<h3 id="1-启动和终止-tmux："><a href="#1-启动和终止-tmux：" class="headerlink" title="1. 启动和终止 tmux："></a>1. <strong>启动和终止 <code>tmux</code>：</strong></h3><ul>
<li><strong>启动 <code>tmux</code>：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux</span><br></pre></td></tr></table></figure></li>
<li><strong>退出 <code>tmux</code>：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>（默认的前缀键），然后按下 <code>d</code>，即 <code>Ctrl-b d</code>，来退出 <code>tmux</code> 会话。</li>
</ul>
<h3 id="2-会话管理："><a href="#2-会话管理：" class="headerlink" title="2. 会话管理："></a>2. <strong>会话管理：</strong></h3><ul>
<li><strong>创建新会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new-session -s session_name</span><br></pre></td></tr></table></figure></li>
<li><strong>切换会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux switch-client -t session_name</span><br></pre></td></tr></table></figure></li>
<li><strong>列出所有会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux list-sessions</span><br></pre></td></tr></table></figure></li>
<li><strong>关闭会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux kill-session -t session_name</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-窗口管理："><a href="#3-窗口管理：" class="headerlink" title="3. 窗口管理："></a>3. <strong>窗口管理：</strong></h3><ul>
<li><strong>创建新窗口：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>c</code>。</li>
<li><strong>切换窗口：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下窗口的编号（从0开始）。</li>
<li><strong>重命名窗口：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>,</code>，输入新窗口名字。</li>
<li><strong>关闭窗口：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>&amp;</code>。</li>
</ul>
<h3 id="4-面板管理："><a href="#4-面板管理：" class="headerlink" title="4. 面板管理："></a>4. <strong>面板管理：</strong></h3><ul>
<li><strong>垂直分割当前窗口：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>%</code>。</li>
<li><strong>水平分割当前窗口：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>&quot; </code>。</li>
<li><strong>切换面板：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下箭头键或使用 <code>o</code>。</li>
<li><strong>关闭面板：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>x</code>。</li>
</ul>
<h3 id="5-其他操作："><a href="#5-其他操作：" class="headerlink" title="5. 其他操作："></a>5. <strong>其他操作：</strong></h3><ul>
<li><strong>重新加载配置：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure></li>
<li><strong>显示帮助信息：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>?</code>。</li>
</ul>
<h3 id="6-复制和粘贴："><a href="#6-复制和粘贴：" class="headerlink" title="6. 复制和粘贴："></a>6. <strong>复制和粘贴：</strong></h3><ul>
<li><strong>进入复制模式：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>[</code>。</li>
<li><strong>在复制模式中移动光标：</strong><br>使用箭头键移动。</li>
<li><strong>开始选择文本：</strong><br>按下 <code>Space</code> 键开始选择，移动光标来选择文本。</li>
<li><strong>复制选中的文本：</strong><br>按下 <code>Enter</code> 键。</li>
<li><strong>粘贴复制的文本：</strong><br>在 <code>tmux</code> 中按下 <code>Ctrl-b</code>，然后按下 <code>]</code>。</li>
</ul>
<p>这些是一些常用的<code>tmux</code>命令，希望能够帮助你更有效地使用这个终端复用工具。<code>tmux</code>具有强大的功能，可以提高在终端中工作的效率。</p>
<h2 id="linux-tmux命令-常用技巧"><a href="#linux-tmux命令-常用技巧" class="headerlink" title="linux tmux命令 常用技巧"></a>linux tmux命令 常用技巧</h2><p>以下是一些在使用tmux时的常用技巧和命令：</p>
<h3 id="1-基本会话管理："><a href="#1-基本会话管理：" class="headerlink" title="1. 基本会话管理："></a>1. <strong>基本会话管理：</strong></h3><ul>
<li><strong>启动tmux：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux</span><br></pre></td></tr></table></figure></li>
<li><strong>分离会话：</strong><br>在tmux会话中按下 <code>Ctrl-b</code>，然后按下 <code>d</code>。</li>
<li><strong>重新连接到会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux attach-session -t session_name</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-窗口和面板："><a href="#2-窗口和面板：" class="headerlink" title="2. 窗口和面板："></a>2. <strong>窗口和面板：</strong></h3><ul>
<li><strong>创建新窗口：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b c</span><br></pre></td></tr></table></figure></li>
<li><strong>切换窗口：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b &lt;窗口编号&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>切换面板：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b 方向键</span><br></pre></td></tr></table></figure></li>
<li><strong>关闭当前窗口或面板：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-自定义键绑定："><a href="#3-自定义键绑定：" class="headerlink" title="3. 自定义键绑定："></a>3. <strong>自定义键绑定：</strong></h3><ul>
<li><strong>修改前缀键：</strong><br>在tmux配置文件（默认为 <code>~/.tmux.conf</code>）中添加：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-option -g prefix C-a</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-复制和粘贴："><a href="#4-复制和粘贴：" class="headerlink" title="4. 复制和粘贴："></a>4. <strong>复制和粘贴：</strong></h3><ul>
<li><strong>进入复制模式：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b [</span><br></pre></td></tr></table></figure></li>
<li><strong>开始选择文本：</strong><br>移动光标，按下 <code>Space</code> 开始选择，移动光标选择文本。</li>
<li><strong>复制选中的文本：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b ]</span><br></pre></td></tr></table></figure></li>
<li><strong>粘贴复制的文本：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b P</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-垂直和水平分割窗口："><a href="#5-垂直和水平分割窗口：" class="headerlink" title="5. 垂直和水平分割窗口："></a>5. <strong>垂直和水平分割窗口：</strong></h3><ul>
<li><strong>垂直分割：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b %</span><br></pre></td></tr></table></figure></li>
<li><strong>水平分割：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b <span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-显示和隐藏状态栏："><a href="#6-显示和隐藏状态栏：" class="headerlink" title="6. 显示和隐藏状态栏："></a>6. <strong>显示和隐藏状态栏：</strong></h3><ul>
<li><strong>切换状态栏显示：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b t</span><br></pre></td></tr></table></figure></li>
<li><strong>临时显示状态栏：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b :</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-会话管理："><a href="#7-会话管理：" class="headerlink" title="7. 会话管理："></a>7. <strong>会话管理：</strong></h3><ul>
<li><strong>列出所有会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux list-sessions</span><br></pre></td></tr></table></figure></li>
<li><strong>切换到下一个会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b (</span><br></pre></td></tr></table></figure></li>
<li><strong>切换到上一个会话：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b )</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-命令行中运行命令："><a href="#8-命令行中运行命令：" class="headerlink" title="8. 命令行中运行命令："></a>8. <strong>命令行中运行命令：</strong></h3><ul>
<li><strong>在新窗口中运行命令：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b :</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-重新加载tmux配置："><a href="#9-重新加载tmux配置：" class="headerlink" title="9. 重新加载tmux配置："></a>9. <strong>重新加载tmux配置：</strong></h3>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-b :</span><br><span class="line">source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure>

<p>这些是一些常用的tmux技巧和命令，可以提高你在终端中使用tmux的效率。根据个人需求，你还可以根据tmux的配置文件进行更多的定制。</p>
<h2 id="linux-tmux命令-高级技巧"><a href="#linux-tmux命令-高级技巧" class="headerlink" title="linux tmux命令 高级技巧"></a>linux tmux命令 高级技巧</h2><p>以下是一些高级的 tmux 技巧，可以帮助你更好地使用 tmux 进行终端管理：</p>
<h3 id="1-复制到系统剪贴板："><a href="#1-复制到系统剪贴板：" class="headerlink" title="1. 复制到系统剪贴板："></a>1. <strong>复制到系统剪贴板：</strong></h3><ul>
<li>如果你的 tmux 版本支持，你可以使用 <code>reattach-to-user-namespace</code> 命令将 tmux 复制到系统剪贴板：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install reattach-to-user-namespace  <span class="comment"># 仅在 macOS 上需要</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>   在 tmux 中按下 <code>Ctrl-b</code> 进入复制模式，选择文本，然后按下 <code>Ctrl-b</code> + <code>]</code> 复制到系统剪贴板。</p>
<h3 id="2-会话共享："><a href="#2-会话共享：" class="headerlink" title="2. 会话共享："></a>2. <strong>会话共享：</strong></h3><ul>
<li><p>多用户共享同一 tmux 会话，允许多人同时查看和编辑相同的终端会话。</p>
<p>在一个终端中执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux -S /tmp/shared-session</span><br></pre></td></tr></table></figure>

<p>在另一个终端中执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux -S /tmp/shared-session attach</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-自动重新加载配置："><a href="#3-自动重新加载配置：" class="headerlink" title="3. 自动重新加载配置："></a>3. <strong>自动重新加载配置：</strong></h3><ul>
<li><p>让 tmux 在配置文件修改后自动重新加载：</p>
<p>在 <code>~/.tmux.conf</code> 中添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tmux-reload&#x27;</span></span><br><span class="line">run <span class="string">&#x27;~/.tmux.conf&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>   然后在 tmux 中执行 <code>Ctrl-b</code> + <code>I</code> 安装插件。</p>
<h3 id="4-远程复制和粘贴："><a href="#4-远程复制和粘贴：" class="headerlink" title="4. 远程复制和粘贴："></a>4. <strong>远程复制和粘贴：</strong></h3><ul>
<li><p>在远程服务器上使用 tmux，可以通过 SSH 远程复制和粘贴。</p>
<p>在本地终端执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -t user@remote tmux -CC</span><br></pre></td></tr></table></figure>

<p>然后你就可以使用本地终端的复制和粘贴功能了。</p>
</li>
</ul>
<h3 id="5-自动开启和关闭窗口-面板："><a href="#5-自动开启和关闭窗口-面板：" class="headerlink" title="5. 自动开启和关闭窗口&#x2F;面板："></a>5. <strong>自动开启和关闭窗口&#x2F;面板：</strong></h3><ul>
<li><p>使用 <code>tmux-resurrect</code> 插件可以在 tmux 会话间保存和恢复工作状态，包括窗口、面板、程序等。</p>
<p>安装插件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tmux-resurrect&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 tmux 中执行 <code>Ctrl-b</code> + <code>I</code> 安装插件。</p>
</li>
</ul>
<h3 id="6-自定义状态栏："><a href="#6-自定义状态栏：" class="headerlink" title="6. 自定义状态栏："></a>6. <strong>自定义状态栏：</strong></h3><ul>
<li><p>使用 <code>tmux</code> 的 <code>status-right</code> 和 <code>status-left</code> 选项来自定义状态栏，显示自己感兴趣的信息。</p>
<p>在 <code>~/.tmux.conf</code> 中添加类似以下的配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -g status-left <span class="string">&quot;My Custom Status: #H&quot;</span></span><br><span class="line"><span class="built_in">set</span> -g status-right <span class="string">&quot;Session #S - #I - #P&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-使用-Tmuxp-进行会话管理："><a href="#7-使用-Tmuxp-进行会话管理：" class="headerlink" title="7. 使用 Tmuxp 进行会话管理："></a>7. <strong>使用 Tmuxp 进行会话管理：</strong></h3><ul>
<li><p><code>tmuxp</code> 是一个用于管理 tmux 会话的工具，可以通过 YAML 文件来定义和配置 tmux 会话。</p>
<p>安装 <code>tmuxp</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tmuxp</span><br></pre></td></tr></table></figure>

<p>创建和加载会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmuxp load /path/to/config.yaml</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-使用多个配置文件："><a href="#8-使用多个配置文件：" class="headerlink" title="8. 使用多个配置文件："></a>8. <strong>使用多个配置文件：</strong></h3><ul>
<li><p>可以根据不同需求，创建多个 tmux 配置文件，然后通过别名加载：</p>
<p>在 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 中添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> tmux=<span class="string">&#x27;tmux -f ~/.tmux.conf.custom&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-使用-Tmux-插件管理器："><a href="#9-使用-Tmux-插件管理器：" class="headerlink" title="9. 使用 Tmux 插件管理器："></a>9. <strong>使用 Tmux 插件管理器：</strong></h3><ul>
<li><p>使用插件管理器，如 <code>tpm</code> (Tmux Plugin Manager) 来轻松管理和安装 tmux 插件。</p>
<p>安装 <code>tpm</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm</span><br></pre></td></tr></table></figure>

<p>在 <code>~/.tmux.conf</code> 中添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tpm&#x27;</span></span><br><span class="line">run <span class="string">&#x27;~/.tmux/plugins/tpm/tpm&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 tmux 中执行 <code>Ctrl-b</code> + <code>I</code> 安装插件。</p>
</li>
</ul>
<p>这些高级技巧可以帮助你更充分地利用 tmux 进行终端管理，并根据自己的工作流程进行定制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_06_open_ssh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_06_open_ssh/" class="post-title-link" itemprop="url">linux_2_06_open_ssh</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>openssh 相关工具的笔记</li>
</ul>
<h2 id="OpenSSH-详解"><a href="#OpenSSH-详解" class="headerlink" title="OpenSSH 详解"></a>OpenSSH 详解</h2><p>OpenSSH（Open Secure Shell）是一个用于安全远程登录和文件传输的开源工具套件，提供了加密的网络通信协议和相关的命令行工具。它是SSH协议的实现之一，广泛用于Linux、Unix和其他类Unix系统上。</p>
<p>以下是OpenSSH的一些主要特点和功能：</p>
<ol>
<li><p>安全远程登录：OpenSSH提供了ssh命令，可以通过安全的加密通道远程登录到其他计算机，并在远程终端上执行命令。这使得用户可以远程管理和访问远程服务器，而不必直接物理接触远程计算机。</p>
</li>
<li><p>文件传输：OpenSSH提供了scp和sftp命令，用于在本地计算机和远程服务器之间安全地传输文件和目录。这使得用户可以轻松地复制文件、上传和下载文件，以及进行远程文件管理。</p>
</li>
<li><p>SSH密钥认证：OpenSSH支持使用SSH密钥对进行身份认证，而不是传统的基于密码的认证方式。用户可以生成公钥和私钥，将公钥部署到服务器上，从而实现免密码登录。这提供了更高的安全性和方便性。</p>
</li>
<li><p>端口转发和隧道：OpenSSH支持本地和远程端口转发，以及创建安全的隧道连接。这使得用户可以安全地访问远程计算机上的服务，甚至通过防火墙和网络限制。</p>
</li>
<li><p>X11转发：OpenSSH支持X11转发，允许用户在远程计算机上运行图形化应用程序，并将其显示到本地计算机上。这使得用户可以远程访问图形界面应用程序，而不必直接在远程计算机上操作。</p>
</li>
<li><p>其他功能：OpenSSH还提供了许多其他功能，如代理转发、多因子认证、登录日志记录等，以增强安全性和用户管理能力。</p>
</li>
</ol>
<p>总的来说，OpenSSH是一个功能强大、安全可靠的工具套件，为用户提供了远程访问和文件传输等功能，并通过加密通信和身份认证提供了强大的安全性保障。它在服务器管理、系统维护和远程协作等场景中得到广泛应用。</p>
<h2 id="Linux和Windows互相拷贝"><a href="#Linux和Windows互相拷贝" class="headerlink" title="Linux和Windows互相拷贝"></a>Linux和Windows互相拷贝</h2><ul>
<li>从Linux复制到Windows：<ul>
<li><code>scp /home/user/data/tmp.txt user@192.169.4.16:/C:Users/user/Desktop</code></li>
</ul>
</li>
</ul>
<h2 id="修改SSH配置文件"><a href="#修改SSH配置文件" class="headerlink" title="修改SSH配置文件"></a>修改SSH配置文件</h2><ul>
<li><code>sudo vim /etc/ssh/sshd_config</code></li>
<li>搜索<code>PermitRootLogin</code>，将一下配置：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">33 #LoginGraceTime 2m</span><br><span class="line">34 #PermitRootLogin prohibit-password</span><br><span class="line">35 #StrictModes yes</span><br><span class="line">36 #MaxAuthTries 6</span><br><span class="line">37 #MaxSessions 10</span><br></pre></td></tr></table></figure></li>
<li>修改为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LoginGraceTime 2m</span><br><span class="line">PermitRootLogin yes</span><br><span class="line">StrictModes yes</span><br><span class="line">#MaxAuthTries 6</span><br><span class="line">#MaxSessions 10</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="重启ssh，使配置生效"><a href="#重启ssh，使配置生效" class="headerlink" title="重启ssh，使配置生效"></a>重启ssh，使配置生效</h2><ul>
<li><code>sudo service ssh restart</code></li>
</ul>
<h2 id="linux-openssh是什么"><a href="#linux-openssh是什么" class="headerlink" title="linux openssh是什么"></a>linux openssh是什么</h2><p>OpenSSH（Open Secure Shell）是一个用于提供加密的通信会话的免费开源实现，它包括SSH协议的实现和相关的工具。SSH（Secure Shell）是一种用于在网络上安全传输数据的协议，通常用于远程登录和执行命令，以及安全地传输文件。</p>
<p>以下是 OpenSSH 的主要组件和功能：</p>
<ol>
<li><p><strong>SSH服务器 (<code>sshd</code>)：</strong> OpenSSH 包括一个 SSH 服务器，用于接受远程用户的连接，并提供安全的远程访问。通过 SSH 协议，用户可以在远程系统上执行命令或进行其他操作，而通信过程是经过加密的，确保数据的机密性和完整性。</p>
</li>
<li><p><strong>SSH客户端 (<code>ssh</code>)：</strong> OpenSSH 提供了一个 SSH 客户端，用于建立到远程服务器的加密连接。通过 SSH 客户端，用户可以远程登录到其他系统，执行命令，传输文件等。用户可以在命令行中使用 <code>ssh</code> 命令，也可以使用图形界面工具。</p>
</li>
<li><p><strong>SCP 和 SFTP：</strong> OpenSSH 提供了用于安全文件传输的工具，包括 SCP（Secure Copy Protocol）和 SFTP（Secure File Transfer Protocol）。SCP 允许在网络上安全地传输文件，而 SFTP 则提供了一个交互式的文件传输协议，类似于 FTP，但使用 SSH 进行加密。</p>
</li>
<li><p><strong>SSH密钥对：</strong> OpenSSH 支持使用密钥对进行身份验证，以替代传统的基于密码的身份验证方式。用户可以生成公钥和私钥，将公钥部署到远程服务器上，从而实现更安全的身份验证方式。</p>
</li>
<li><p><strong>端口转发：</strong> OpenSSH 支持端口转发，允许用户在加密的通道上传输其他网络流量，如通过 SSH 安全地访问远程数据库或内部网络服务。</p>
</li>
</ol>
<p>OpenSSH 是许多操作系统中默认安装的标准 SSH 实现，包括许多 Linux 发行版和 BSD 系统。其开源性质使得用户可以审查和修改代码以满足特定需求，并且它广泛用于安全的远程系统管理和文件传输。</p>
<h2 id="linux-openssh详解"><a href="#linux-openssh详解" class="headerlink" title="linux openssh详解"></a>linux openssh详解</h2><p>OpenSSH 是一个用于提供安全网络通信的开源实现，它主要实现了 SSH（Secure Shell）协议。SSH 是一种加密的协议，用于在不安全的网络中提供安全的远程访问、文件传输以及命令执行。以下是 OpenSSH 的一些详细信息：</p>
<h3 id="组件和功能："><a href="#组件和功能：" class="headerlink" title="组件和功能："></a>组件和功能：</h3><ol>
<li><p><strong>sshd（SSH 服务器）：</strong></p>
<ul>
<li><code>sshd</code> 是 OpenSSH 中的服务器端程序，用于接受来自客户端的连接请求。</li>
<li>它负责验证用户身份、建立安全通道，并处理用户的远程命令或文件传输请求。</li>
</ul>
</li>
<li><p><strong>ssh（SSH 客户端）：</strong></p>
<ul>
<li><code>ssh</code> 是 OpenSSH 中的客户端程序，用于建立到远程 SSH 服务器的加密连接。</li>
<li>通过 <code>ssh</code> 命令，用户可以登录远程系统、执行命令、传输文件等。</li>
</ul>
</li>
<li><p><strong>SCP 和 SFTP：</strong></p>
<ul>
<li>SCP（Secure Copy Protocol）和 SFTP（Secure File Transfer Protocol）是用于在网络上安全传输文件的工具。</li>
<li>SCP 提供命令行方式的文件传输，而 SFTP 提供了一个类似于 FTP 的交互式文件传输协议。</li>
</ul>
</li>
<li><p><strong>SSH 密钥对：</strong></p>
<ul>
<li>OpenSSH 支持基于密钥对的身份验证，其中用户生成公钥和私钥。</li>
<li>用户将公钥部署到远程服务器，而私钥保留在本地。这样可以实现更安全的身份验证，避免传统密码登录的风险。</li>
</ul>
</li>
<li><p><strong>端口转发：</strong></p>
<ul>
<li>OpenSSH 支持端口转发，使用户能够通过 SSH 通道安全地传输其他网络流量。</li>
<li>通过端口转发，用户可以访问远程服务器上的本地服务，或者将远程服务映射到本地端口。</li>
</ul>
</li>
</ol>
<h3 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h3><p>OpenSSH 的配置文件通常是 <code>/etc/ssh/sshd_config</code>（服务器端）和 <code>~/.ssh/config</code>（客户端）。这些文件包含了各种配置选项，允许用户自定义 SSH 行为。</p>
<h3 id="安全性："><a href="#安全性：" class="headerlink" title="安全性："></a>安全性：</h3><p>OpenSSH 通过使用加密技术，包括对称加密、非对称加密和哈希算法，提供了通信的机密性和完整性。这使得它成为安全远程管理和文件传输的首选工具之一。</p>
<h3 id="使用案例："><a href="#使用案例：" class="headerlink" title="使用案例："></a>使用案例：</h3><ol>
<li><p><strong>远程登录：</strong> 使用 <code>ssh</code> 客户端通过命令行或图形界面安全地登录到远程系统。</p>
</li>
<li><p><strong>文件传输：</strong> 使用 SCP 或 SFTP 完成文件传输，确保文件在传输过程中得到加密保护。</p>
</li>
<li><p><strong>远程命令执行：</strong> 使用 <code>ssh</code> 客户端执行远程系统上的命令，而不必直接登录到系统。</p>
</li>
<li><p><strong>安全传输其他服务：</strong> 使用端口转发，通过 SSH 通道安全地访问和传输其他网络服务，如数据库服务。</p>
</li>
</ol>
<p>总体而言，OpenSSH 是一个功能强大、安全可靠的工具，被广泛用于各种 Linux 和 UNIX 系统上，以及其他操作系统中。</p>
<h2 id="linux-ssh服务器详解"><a href="#linux-ssh服务器详解" class="headerlink" title="linux ssh服务器详解"></a>linux ssh服务器详解</h2><p>在 Linux 系统上，SSH（Secure Shell）服务器主要由 OpenSSH 软件包提供，它是一个用于提供加密的远程登录和文件传输服务的开源实现。下面详细介绍 Linux 上的 SSH 服务器的相关概念和配置：</p>
<h3 id="OpenSSH-服务器-sshd-："><a href="#OpenSSH-服务器-sshd-：" class="headerlink" title="OpenSSH 服务器 (sshd)："></a>OpenSSH 服务器 (<code>sshd</code>)：</h3><ol>
<li><p><strong>服务启动：</strong></p>
<ul>
<li><code>sshd</code> 是 OpenSSH 中的服务器端程序，负责监听 SSH 连接请求并处理用户的远程登录和文件传输。</li>
<li>在大多数 Linux 发行版中，你可以通过以下命令启动或停止 SSH 服务：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service ssh start  <span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> service ssh stop   <span class="comment"># 停止服务</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>配置文件：</strong></p>
<ul>
<li>SSH 服务器的主要配置文件通常位于 <code>/etc/ssh/sshd_config</code>。这个文件包含了各种配置选项，用于定义服务器的行为、安全性设置和认证方式等。</li>
<li>修改配置文件可能需要超级用户权限，你可以使用编辑器（如 <code>nano</code> 或 <code>vi</code>）来进行编辑：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>重要配置选项：</strong></p>
<ul>
<li>一些常见的配置选项包括：<ul>
<li><code>Port</code>: 指定 SSH 服务器监听的端口，默认为 22。</li>
<li><code>PermitRootLogin</code>: 允许或禁止 root 用户通过 SSH 登录。</li>
<li><code>PasswordAuthentication</code>: 启用或禁用密码身份验证。</li>
<li><code>PubkeyAuthentication</code>: 启用或禁用公钥身份验证。</li>
<li><code>AllowUsers</code> 或 <code>AllowGroups</code>: 限制哪些用户或组可以登录。</li>
<li><code>Protocol</code>: 指定使用的 SSH 协议版本。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>身份验证方式：</strong></p>
<ul>
<li>SSH 服务器支持多种身份验证方式，包括密码、公钥和基于主机的身份验证。管理员可以根据安全需求配置适当的身份验证方式。</li>
</ul>
</li>
<li><p><strong>重启服务：</strong></p>
<ul>
<li>在修改了 <code>sshd_config</code> 文件后，需要重启 SSH 服务以使更改生效：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service ssh restart</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>日志文件：</strong></p>
<ul>
<li>SSH 服务器的活动和错误信息通常记录在 <code>/var/log/auth.log</code> 或 <code>/var/log/secure</code> 文件中，可以通过这些日志文件来监视服务器的活动。</li>
</ul>
</li>
<li><p><strong>安全性建议：</strong></p>
<ul>
<li>定期更新 SSH 服务器和操作系统，以确保安全性。</li>
<li>禁用不安全的身份验证方式，如密码身份验证，而使用公钥身份验证。</li>
<li>配置防火墙规则以限制对 SSH 服务器的访问。</li>
</ul>
</li>
</ol>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>一个简单的 <code>sshd_config</code> 配置示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Port 22</span><br><span class="line">PermitRootLogin no</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AllowUsers username</span><br></pre></td></tr></table></figure>

<p>在这个例子中，SSH 服务器监听默认端口 22，禁止 root 用户直接登录，启用密码和公钥身份验证，只允许特定的用户（<code>username</code>）登录。</p>
<p>请注意，实际配置应根据具体的安全需求和网络环境进行调整。</p>
<h2 id="linux-ssh客户端详解"><a href="#linux-ssh客户端详解" class="headerlink" title="linux ssh客户端详解"></a>linux ssh客户端详解</h2><p>在 Linux 系统上，SSH（Secure Shell）客户端通常由 OpenSSH 软件包提供。SSH 客户端允许用户建立加密连接到远程服务器，执行命令、传输文件以及进行其他远程操作。以下是关于 Linux 上 SSH 客户端的一些详细信息：</p>
<h3 id="OpenSSH-客户端-ssh-："><a href="#OpenSSH-客户端-ssh-：" class="headerlink" title="OpenSSH 客户端 (ssh)："></a>OpenSSH 客户端 (<code>ssh</code>)：</h3><ol>
<li><p><strong>连接远程服务器：</strong></p>
<ul>
<li>使用 <code>ssh</code> 命令可以轻松地建立到远程服务器的 SSH 连接。语法为：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@hostname</span><br></pre></td></tr></table></figure>
其中，<code>username</code> 是目标服务器上的用户名，而 <code>hostname</code> 是目标服务器的主机名或 IP 地址。</li>
</ul>
</li>
<li><p><strong>身份验证方式：</strong></p>
<ul>
<li>SSH 客户端支持多种身份验证方式，包括密码和公钥身份验证。当使用密码登录时，系统会要求用户输入密码。而在使用公钥身份验证时，客户端会使用预先生成的密钥对进行身份验证。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用密码身份验证</span></span><br><span class="line">ssh username@hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用公钥身份验证</span></span><br><span class="line">ssh -i /path/to/private_key username@hostname</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>文件传输：</strong></p>
<ul>
<li>使用 <code>scp</code> 命令可以在本地系统和远程服务器之间传输文件。语法为：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从本地到远程</span></span><br><span class="line">scp local_file username@hostname:/remote/path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从远程到本地</span></span><br><span class="line">scp username@hostname:/remote/file /local/path</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>SSH 配置文件 (<code>~/.ssh/config</code>)：</strong></p>
<ul>
<li>用户可以在 <code>~/.ssh/config</code> 文件中配置 SSH 客户端的行为。这个文件允许你定义主机别名、身份验证方式、端口等设置，以简化 SSH 连接的管理。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例 ~/.ssh/config 文件</span></span><br><span class="line">Host myserver</span><br><span class="line">  HostName example.com</span><br><span class="line">  User username</span><br><span class="line">  Port 2222</span><br><span class="line">  IdentityFile ~/.ssh/private_key</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>端口转发：</strong></p>
<ul>
<li>SSH 客户端支持端口转发，允许用户安全地传输其他网络流量。这通常用于访问远程服务器上的本地服务。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L local_port:remote_host:remote_port username@hostname</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>代理跳板：</strong></p>
<ul>
<li>通过 SSH 客户端，用户可以设置代理跳板，从而通过一个中间服务器访问目标服务器。这对于连接到内部网络的服务器很有用。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -J jumpbox_username@jumpbox_hostname username@target_hostname</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>执行远程命令：</strong></p>
<ul>
<li>通过在 <code>ssh</code> 命令后添加要执行的命令，可以在远程服务器上执行命令而不必手动登录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@hostname <span class="string">&#x27;command_to_run&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>SSH Agent：</strong></p>
<ul>
<li>SSH 客户端可以与 SSH Agent 配合使用，以避免在每次连接时重新输入密码或解锁私钥。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加私钥到 SSH Agent</span></span><br><span class="line">ssh-add /path/to/private_key</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>以上是一些基本的 SSH 客户端使用方式和功能。SSH 客户端非常灵活，可以通过不同的选项和配置满足各种需求，提供安全的远程访问和文件传输。</p>
<h2 id="linux-scp命令详解"><a href="#linux-scp命令详解" class="headerlink" title="linux scp命令详解"></a>linux scp命令详解</h2><p><code>scp</code>（Secure Copy Protocol）是一个用于在本地系统和远程系统之间进行安全文件传输的命令行工具。它使用 SSH 协议来提供加密的数据传输，确保传输的安全性。以下是关于 Linux 上 <code>scp</code> 命令的详解：</p>
<h3 id="scp-语法："><a href="#scp-语法：" class="headerlink" title="scp 语法："></a><code>scp</code> 语法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [选项] <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>source：</strong> 要传输的文件或目录的路径。可以是本地文件或远程服务器上的文件。</li>
<li><strong>destination：</strong> 文件或目录的目标位置。可以是本地路径或远程服务器的路径。</li>
</ul>
<h3 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h3><ol>
<li><p><strong>-r：</strong></p>
<ul>
<li>递归复制，用于传输目录及其内容。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_directory username@remote_host:/remote/path</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>-P：</strong></p>
<ul>
<li>指定远程服务器的端口号，默认为 22。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 local_file username@remote_host:/remote/path</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>-i：</strong></p>
<ul>
<li>指定用于身份验证的私钥文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -i /path/to/private_key local_file username@remote_host:/remote/path</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>-v：</strong></p>
<ul>
<li>启用详细模式，显示调试信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -v local_file username@remote_host:/remote/path</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><ol>
<li><p><strong>从本地传输到远程：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp local_file username@remote_host:/remote/path</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从远程传输到本地：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp username@remote_host:/remote/file /local/path</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>本地到远程目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_directory username@remote_host:/remote/path</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从远程到本地目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r username@remote_host:/remote/directory /local/path</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>scp</code> 使用 SSH 协议，因此你需要在远程服务器上启用 SSH 服务。</li>
<li>对于远程服务器路径，如果省略了用户名，则默认使用当前登录用户。</li>
<li><code>scp</code> 的工作方式类似于 <code>cp</code> 命令，但它使用 SSH 进行加密传输，因此数据在传输过程中是安全的。</li>
<li>在使用 <code>scp</code> 时，确保你有正确的权限来读取本地文件和写入远程目标路径。</li>
</ul>
<p><code>scp</code> 是一个非常实用的工具，能够在本地系统和远程服务器之间轻松传输文件，而且通过使用 SSH 进行加密，确保了数据的安全传输。</p>
<h2 id="linux-sftp命令详解"><a href="#linux-sftp命令详解" class="headerlink" title="linux sftp命令详解"></a>linux sftp命令详解</h2><p><code>sftp</code>（Secure File Transfer Protocol）是一个基于 SSH 协议的安全文件传输工具，它允许用户通过命令行交互式地在本地系统和远程服务器之间传输文件。与传统的 FTP 不同，<code>sftp</code> 使用 SSH 进行加密，提供更安全的文件传输方式。以下是关于 Linux 上 <code>sftp</code> 命令的详细解释：</p>
<h3 id="sftp-语法："><a href="#sftp-语法：" class="headerlink" title="sftp 语法："></a><code>sftp</code> 语法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp [选项] [username@]host[:path]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>username：</strong> 远程服务器上的用户名，如果省略，则使用当前登录用户。</li>
<li><strong>host：</strong> 远程服务器的主机名或 IP 地址。</li>
<li><strong>path：</strong> 远程服务器上的路径，如果省略，则默认为用户的主目录。</li>
</ul>
<h3 id="sftp-命令："><a href="#sftp-命令：" class="headerlink" title="sftp 命令："></a><code>sftp</code> 命令：</h3><ol>
<li><p><strong>连接到远程服务器：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp username@remote_host</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>退出 <code>sftp</code>：</strong></p>
<ul>
<li>在 <code>sftp</code> 交互式模式下，可以使用 <code>exit</code> 或 <code>quit</code> 命令退出。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>上传文件到远程服务器：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put local_file</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>下载文件到本地系统：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get remote_file</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列出远程目录内容：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>改变远程目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> remote_directory</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除远程文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> remote_file</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建远程目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> remote_directory</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重命名远程文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename old_name new_name</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><ul>
<li><p><strong>-i：</strong> 指定用于身份验证的私钥文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp -i /path/to/private_key username@remote_host</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>-P：</strong> 指定远程服务器的端口号，默认为 22。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp -P 2222 username@remote_host</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>sftp</code> 是一个交互式的命令行工具，用户可以在交互模式下输入命令。</li>
<li>文件上传和下载时，文件的路径和名称可以在本地和远程之间指定。</li>
<li><code>sftp</code> 提供了类似于 FTP 的命令，但是由于使用了 SSH 进行加密，传输过程更加安全。</li>
<li>可以使用 <code>help</code> 命令在 <code>sftp</code> 中查看可用的命令。</li>
</ul>
<p><code>sftp</code> 是一个灵活且安全的文件传输工具，适用于需要通过 SSH 加密传输文件的场景。在使用 <code>sftp</code> 时，请确保你有正确的权限来读取本地文件和写入远程服务器上的目标路径。</p>
<h2 id="linux-ssh密钥对详解"><a href="#linux-ssh密钥对详解" class="headerlink" title="linux ssh密钥对详解"></a>linux ssh密钥对详解</h2><p>在 Linux 系统中，SSH 密钥对是一种用于身份验证和安全传输的机制。密钥对包括公钥和私钥，这两者一起工作以确保安全的通信。以下是关于 Linux 中 SSH 密钥对的详细解释：</p>
<h3 id="SSH-密钥对的组成："><a href="#SSH-密钥对的组成：" class="headerlink" title="SSH 密钥对的组成："></a>SSH 密钥对的组成：</h3><ol>
<li><p><strong>公钥 (<code>id_rsa.pub</code>)：</strong></p>
<ul>
<li>公钥是可以公开分享的部分，用于验证与私钥配对的身份。它通常保存在用户的 <code>~/.ssh/</code> 目录下，文件名为 <code>id_rsa.pub</code>。</li>
<li>公钥是一串文本，类似于以下示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC+6czkGk...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>私钥 (<code>id_rsa</code>)：</strong></p>
<ul>
<li>私钥是必须保持安全的部分，只有拥有私钥的用户可以使用它来进行身份验证。私钥通常保存在用户的 <code>~/.ssh/</code> 目录下，文件名为 <code>id_rsa</code>。</li>
<li>私钥是二进制数据，通常不会直接以文本形式显示。</li>
</ul>
</li>
</ol>
<h3 id="生成-SSH-密钥对："><a href="#生成-SSH-密钥对：" class="headerlink" title="生成 SSH 密钥对："></a>生成 SSH 密钥对：</h3><p>可以使用 <code>ssh-keygen</code> 命令生成 SSH 密钥对。默认情况下，生成的密钥对将保存在用户的 <code>~/.ssh/</code> 目录下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 2048</span><br></pre></td></tr></table></figure>

<p>上述命令将生成一个 RSA 类型的密钥对，位数为 2048。根据需要，可以选择其他密钥类型和位数。</p>
<h3 id="将公钥部署到远程服务器："><a href="#将公钥部署到远程服务器：" class="headerlink" title="将公钥部署到远程服务器："></a>将公钥部署到远程服务器：</h3><ol>
<li><p><strong>手动复制：</strong></p>
<ul>
<li>使用 <code>ssh-copy-id</code> 或手动将公钥内容复制到远程服务器的 <code>~/.ssh/authorized_keys</code> 文件中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id username@remote_host</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>复制到剪贴板：</strong></p>
<ul>
<li>使用 <code>xclip</code> 或 <code>pbcopy</code> 将公钥复制到剪贴板，然后粘贴到远程服务器上的 <code>~/.ssh/authorized_keys</code> 文件中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub | xclip -sel clip</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="使用-SSH-密钥对进行身份验证："><a href="#使用-SSH-密钥对进行身份验证：" class="headerlink" title="使用 SSH 密钥对进行身份验证："></a>使用 SSH 密钥对进行身份验证：</h3><ol>
<li><p><strong>在登录时指定私钥：</strong></p>
<ul>
<li>在 <code>ssh</code> 命令中使用 <code>-i</code> 选项指定私钥文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i /path/to/private_key username@remote_host</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用 SSH Agent：</strong></p>
<ul>
<li>将私钥添加到 SSH Agent 中，以免在每次连接时输入密码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add /path/to/private_key</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><p><strong>私钥安全性：</strong></p>
<ul>
<li>私钥应该始终保持安全，不要与他人共享，以免被滥用。</li>
<li>私钥文件的权限应设置为只有拥有者可读写 (<code>chmod 600 ~/.ssh/id_rsa</code>)。</li>
</ul>
</li>
<li><p><strong>公钥部署：</strong></p>
<ul>
<li>将公钥部署到所有需要访问的远程服务器上，以实现无密码或密钥登录。</li>
<li>在远程服务器上的 <code>~/.ssh/authorized_keys</code> 文件中可以包含多个公钥，每行一个。</li>
</ul>
</li>
</ul>
<p>SSH 密钥对提供了一种强大且安全的身份验证机制，适用于远程登录、文件传输等场景。密钥对的生成和使用都涉及到一些注意事项，确保密钥的安全和正确配置是使用 SSH 密钥对的关键。</p>
<h2 id="Could-not-open-a-connection-to-your-authentication-agent-错误"><a href="#Could-not-open-a-connection-to-your-authentication-agent-错误" class="headerlink" title="Could not open a connection to your authentication agent 错误"></a>Could not open a connection to your authentication agent 错误</h2><p>如果您在执行 <code>ssh-add</code> 命令时收到 “Could not open a connection to your authentication agent” 错误，这通常意味着SSH Agent并未在当前的Shell会话中运行。以下是一些可能的原因和解决方法：</p>
<ol>
<li><p><strong>SSH Agent未启动：</strong> 请确保SSH Agent已经启动。您可以通过运行以下命令来启动SSH Agent：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Shell环境问题：</strong> 如果您在新的Shell窗口中运行 <code>ssh-add</code>，请确保您的SSH Agent环境变量已经被正确设置。您可以通过运行以下命令来检查：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$SSH_AGENT_PID</span></span><br></pre></td></tr></table></figure>

<p> 如果没有输出，或者输出为空，可能需要重新启动SSH Agent。</p>
</li>
<li><p><strong>SSH Agent自动启动问题：</strong> 如果您在每次登录时都遇到此问题，可能是因为SSH Agent没有在登录时自动启动。您可以将SSH Agent启动命令添加到您的shell配置文件中（例如，<code>.bashrc</code> 或 <code>.zshrc</code>）。</p>
<p>在文件末尾添加以下行：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$SSH_AUTH_SOCK</span>&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">    ssh-add</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>这将在每次登录时检查SSH Agent是否运行，如果没有，则启动并添加私钥。</p>
</li>
<li><p><strong>重新启动SSH Agent：</strong> 如果以上步骤都没有解决问题，可以尝试重新启动SSH Agent。首先，停止当前运行的SSH Agent：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent -k</span><br></pre></td></tr></table></figure>

<p> 然后重新启动SSH Agent：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>尝试这些步骤后，您应该能够成功将私钥添加到SSH Agent中。如果问题仍然存在，请提供更多详细信息，以便我能够提供更具体的帮助。</p>
<h2 id="Linux-openssh端口转发详解"><a href="#Linux-openssh端口转发详解" class="headerlink" title="Linux openssh端口转发详解"></a>Linux openssh端口转发详解</h2><p>在 Linux 下，OpenSSH 提供了强大的端口转发功能，可以通过 SSH 通道安全地传输其他网络流量。端口转发（Port Forwarding）允许你在本地计算机和远程服务器之间建立加密的通信通道，从而访问远程网络服务或将本地服务映射到远程服务器上。有两种主要类型的端口转发：本地端口转发（Local Port Forwarding）和远程端口转发（Remote Port Forwarding）。</p>
<h3 id="1-本地端口转发（Local-Port-Forwarding）："><a href="#1-本地端口转发（Local-Port-Forwarding）：" class="headerlink" title="1. 本地端口转发（Local Port Forwarding）："></a>1. 本地端口转发（Local Port Forwarding）：</h3><p>本地端口转发允许你将本地计算机上的端口转发到远程服务器上。通常用于访问远程服务器上的服务，如数据库或内部网站。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L local_port:remote_host:remote_port username@remote_server</span><br></pre></td></tr></table></figure>

<ul>
<li><code>local_port</code>：本地计算机上监听的端口。</li>
<li><code>remote_host</code>：远程服务器上服务的主机名或 IP 地址。</li>
<li><code>remote_port</code>：远程服务器上服务的端口。</li>
</ul>
<p>示例：将本地计算机的本地端口 8080 转发到远程服务器的 80 端口（Web 服务器）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 8080:localhost:80 username@remote_server</span><br></pre></td></tr></table></figure>

<p>现在，可以在本地浏览器中访问 <code>http://localhost:8080</code> 来访问远程服务器上的 Web 服务。</p>
<h3 id="2-远程端口转发（Remote-Port-Forwarding）："><a href="#2-远程端口转发（Remote-Port-Forwarding）：" class="headerlink" title="2. 远程端口转发（Remote Port Forwarding）："></a>2. 远程端口转发（Remote Port Forwarding）：</h3><p>远程端口转发允许你将远程服务器上的端口转发到本地计算机上。通常用于暴露本地服务，使其可以通过远程服务器访问。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R remote_port:local_host:local_port username@remote_server</span><br></pre></td></tr></table></figure>

<ul>
<li><code>remote_port</code>：远程服务器上监听的端口。</li>
<li><code>local_host</code>：本地计算机上服务的主机名或 IP 地址。</li>
<li><code>local_port</code>：本地计算机上服务的端口。</li>
</ul>
<p>示例：将远程服务器的远程端口 8888 转发到本地计算机的 22 端口（SSH 服务）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R 8888:localhost:22 username@remote_server</span><br></pre></td></tr></table></figure>

<p>现在，可以在远程服务器上通过 <code>ssh -p 8888 localhost</code> 来访问本地计算机上的 SSH 服务。</p>
<h3 id="注意事项：-3"><a href="#注意事项：-3" class="headerlink" title="注意事项："></a>注意事项：</h3><ol>
<li><p><strong>防火墙设置：</strong></p>
<ul>
<li>确保本地计算机和远程服务器的防火墙允许相应的端口访问。</li>
</ul>
</li>
<li><p><strong>SSH 服务器配置：</strong></p>
<ul>
<li>在远程服务器上，确保 SSH 服务器的配置文件允许相应的端口转发。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/ssh/sshd_config</span></span><br><span class="line">AllowTcpForwarding <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安全性：</strong></p>
<ul>
<li>使用端口转发时，务必注意安全性。不要将本地服务直接暴露到公共网络上，应仅限制访问到必要的主机。</li>
</ul>
</li>
<li><p><strong>通道保持活跃：</strong></p>
<ul>
<li>添加 <code>-N</code> 选项可以防止 <code>ssh</code> 命令打开 shell，从而只建立端口转发通道而不登录到远程服务器。</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -N -L local_port:remote_host:remote_port username@remote_server</span><br></pre></td></tr></table></figure>

<p>端口转发是 SSH 功能中非常有用的一部分，它可以使你在不直接暴露服务的情况下安全地访问远程服务器上的服务。</p>
<h2 id="OpenSSH-相关命令"><a href="#OpenSSH-相关命令" class="headerlink" title="OpenSSH 相关命令"></a>OpenSSH 相关命令</h2><p>OpenSSH是一个用于安全远程登录的开源工具套件，提供了一系列命令和协议用于远程访问和管理Linux系统。以下是一些常用的OpenSSH相关命令：</p>
<ol>
<li><p>ssh：远程登录到服务器或执行远程命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@hostname</span><br></pre></td></tr></table></figure>
<p>其中，<code>user</code>是远程服务器的用户名，<code>hostname</code>是远程服务器的主机名或IP地址。</p>
</li>
<li><p>scp：安全地复制文件和目录到远程服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp source_file user@hostname:destination_path</span><br></pre></td></tr></table></figure>
<p>其中，<code>source_file</code>是本地文件路径，<code>user</code>是远程服务器的用户名，<code>hostname</code>是远程服务器的主机名或IP地址，<code>destination_path</code>是远程服务器上的目标路径。</p>
</li>
<li><p>sftp：使用类似FTP的方式在本地系统和远程服务器之间传输文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp user@hostname</span><br></pre></td></tr></table></figure>
<p>通过此命令进入sftp会话后，可以执行一系列文件传输操作。</p>
</li>
<li><p>ssh-keygen：生成和管理SSH密钥对。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>该命令用于生成RSA密钥对，可以使用其他选项指定密钥类型和文件名等。</p>
</li>
<li><p>ssh-agent：管理SSH代理，用于管理私钥并免密码登录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval $(ssh-agent)</span><br></pre></td></tr></table></figure>
<p>该命令启动ssh-agent代理，并将其相关环境变量设置为当前shell的环境变量。</p>
</li>
<li><p>ssh-add：将私钥添加到ssh-agent代理中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>该命令将指定的私钥添加到ssh-agent代理中，以便在进行SSH身份验证时使用。</p>
</li>
</ol>
<p>这些命令是OpenSSH套件中的一部分，用于实现安全远程登录和文件传输等功能。请根据具体需求和情况选择适当的命令使用。</p>
<hr>
<h2 id="ssh-exchange-identification-read-Connection-reset-by-peer-错误"><a href="#ssh-exchange-identification-read-Connection-reset-by-peer-错误" class="headerlink" title="ssh_exchange_identification: read: Connection reset by peer 错误"></a>ssh_exchange_identification: read: Connection reset by peer 错误</h2><p>当你在使用SSH连接时，出现”ssh_exchange_identification: read: Connection reset by peer”错误，通常表示SSH连接被对方终止了。这可能是由于以下几个原因导致的：</p>
<ol>
<li><p>网络连接问题：这可能是由于网络中断、丢包或不稳定的连接导致的。请确保你的网络连接正常，并尝试重新连接。</p>
</li>
<li><p>SSH服务器配置问题：可能是SSH服务器配置有问题，导致连接被终止。你可以尝试重新启动SSH服务器或检查其配置文件以查找潜在的问题。</p>
</li>
<li><p>防火墙或安全设置：防火墙或其他安全设置可能会阻止SSH连接。确保你的防火墙设置允许SSH流量通过，并且服务器端没有任何限制。</p>
</li>
<li><p>SSH版本不匹配：如果你使用的SSH客户端和服务器端之间的SSH协议版本不匹配，可能会导致连接被重置。尝试使用兼容的SSH版本，或者更新SSH客户端和服务器端以确保版本一致。</p>
</li>
<li><p>SSH服务器负载过高：如果SSH服务器负载过高，可能无法处理新的连接请求，从而导致连接被重置。尝试在负载较低的时间重新连接。</p>
</li>
</ol>
<p>如果以上方法都无效，你可以尝试使用其他SSH客户端或与SSH服务器管理员联系以获取更多支持和故障排除。</p>
<hr>
<h2 id="ssh-允许root登录"><a href="#ssh-允许root登录" class="headerlink" title="ssh 允许root登录"></a>ssh 允许root登录</h2><ul>
<li>文件：&#x2F;etc&#x2F;ssh&#x2F;sshd_config<ul>
<li><code>PermitRootLogin yes</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="ssh-安装与配置"><a href="#ssh-安装与配置" class="headerlink" title="ssh 安装与配置"></a>ssh 安装与配置</h2><ul>
<li>一般ubuntu都会默认安装openssh-client,但是没有安装openssh-server</li>
<li>安装ssh服务器:<ul>
<li><code>sudo apt-get install openssh-server</code></li>
</ul>
</li>
<li>安装ssh客户端:<ul>
<li><code>sudo apt-get install openssh-client</code></li>
</ul>
</li>
<li>查看端口:<ul>
<li><code>netstat -tunpl | grep 22</code></li>
</ul>
</li>
<li>查看ssh状态:<ul>
<li><code>service sshd status</code></li>
</ul>
</li>
<li>重启ssh服务:<ul>
<li><code>service sshd restart</code> | <code>sudo /etc/init.d/ssh restart</code></li>
</ul>
</li>
<li>ssh配置文件:<ul>
<li><code>/etc/ssh/ssh_config</code> | <code>/etc/ssh/sshd_config</code></li>
<li><code>PasswordAuthentication yes</code></li>
<li><code>PermitRootLogin yes</code></li>
<li><code># PermitRootLogin prohibit-password</code></li>
</ul>
</li>
</ul>
<h2 id="SSH-基础知识"><a href="#SSH-基础知识" class="headerlink" title="SSH 基础知识"></a>SSH 基础知识</h2><ul>
<li><p>SSH的全称为<code>Secure Shell</code>，即安全外壳协议，是一种加密的网络传输协议。它能够在公开的网络环境中提供安全的数据传输环境，通常用于登陆远程主机和推拉代码。</p>
</li>
<li><p>同样一个SSH公钥文件，如果添加至某一个代码仓库，则称为部署公钥，配置后默认拥有读项目的只读权限，支持新增读写权限；</p>
</li>
<li><p>如果添加至团队设置中心，则称为团队部署公钥，仅拥有只读权限；</p>
</li>
<li><p>如果添加至个人账户，称为账户SSH公钥，配置后拥有账户内所有代码仓库的读写权限。</p>
</li>
<li><p>同一个SSH公钥无法即作为部署公钥，又作为个人账户SSH公钥</p>
</li>
<li><p>生成公钥 – 使用<code>ssh-keygen</code>工具生成SSH公钥</p>
<ul>
<li>&#96;ssh-keygen -m PEM -t ed25519 -C “<a href="mailto:&#x79;&#111;&#x75;&#x72;&#x2e;&#x65;&#x6d;&#97;&#105;&#108;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;">&#x79;&#111;&#x75;&#x72;&#x2e;&#x65;&#x6d;&#97;&#105;&#108;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;</a>“  &#x2F;&#x2F; 创建新的SSH私钥和公钥对</li>
</ul>
</li>
<li><p>添加至部署公钥</p>
<ul>
<li>打开生成的密钥对的地址，通常为<code>~/.ssh 文件夹</code> , 找到后缀为<code>pub</code>的文件</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h2><p><code>ssh-keygen</code>命令是Linux系统中用于生成SSH密钥对的工具。SSH密钥对由一对公钥和私钥组成，用于身份验证和安全通信。</p>
<p>下面是<code>ssh-keygen</code>命令的一些常见选项和用法：</p>
<ol>
<li><p>生成RSA密钥对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>这将生成一个RSA密钥对，默认情况下，公钥文件为<code>id_rsa.pub</code>，私钥文件为<code>id_rsa</code>。</p>
</li>
<li><p>生成DSA密钥对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t dsa</span><br></pre></td></tr></table></figure>
<p>这将生成一个DSA密钥对，默认情况下，公钥文件为<code>id_dsa.pub</code>，私钥文件为<code>id_dsa</code>。</p>
</li>
<li><p>生成ECDSA密钥对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ecdsa</span><br></pre></td></tr></table></figure>
<p>这将生成一个ECDSA密钥对，默认情况下，公钥文件为<code>id_ecdsa.pub</code>，私钥文件为<code>id_ecdsa</code>。</p>
</li>
<li><p>生成ED25519密钥对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519</span><br></pre></td></tr></table></figure>
<p>这将生成一个ED25519密钥对，默认情况下，公钥文件为<code>id_ed25519.pub</code>，私钥文件为<code>id_ed25519</code>。</p>
</li>
<li><p>指定密钥文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>-f</code>选项可以指定生成的密钥文件的文件名。例如，<code>ssh-keygen -f mykey</code>将生成<code>mykey</code>作为文件名的密钥对。</p>
</li>
<li><p>设置密钥密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p</span><br></pre></td></tr></table></figure>
<p>使用<code>-p</code>选项可以更改已有密钥文件的密码。</p>
</li>
<li><p>查看密钥指纹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -lf &lt;public_key_file&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>-lf</code>选项可以查看公钥文件的指纹。</p>
</li>
</ol>
<p>以上是一些常见的<code>ssh-keygen</code>命令选项和用法。生成密钥对后，可以将公钥文件部署到服务器上，以便进行SSH身份验证。私钥文件应该妥善保管，不应与他人共享。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_13_free/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_13_free/" class="post-title-link" itemprop="url">linux_2_13_free</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>free命令</li>
</ul>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><ul>
<li><p>Linux free命令用于显示内存状态。</p>
</li>
<li><p>free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>free [-bkmotV][-s &lt;间隔秒数&gt;]</code></li>
</ul>
</li>
<li><p>参数说明：</p>
<ul>
<li>-b 　以Byte为单位显示内存使用情况。</li>
<li>-k 　以KB为单位显示内存使用情况。</li>
<li>-m 　以MB为单位显示内存使用情况。</li>
<li>-h 　以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有：<ul>
<li>B &#x3D; bytes</li>
<li>K &#x3D; kilos</li>
<li>M &#x3D; megas</li>
<li>G &#x3D; gigas</li>
<li>T &#x3D; teras</li>
</ul>
</li>
<li>-o 　不显示缓冲区调节列。</li>
<li>-s&lt;间隔秒数&gt; 　持续观察内存使用状况。</li>
<li>-t 　显示内存总和列。</li>
<li>-V 　显示版本信息。</li>
</ul>
</li>
<li><p>实例：</p>
<ul>
<li>以总和的形式显示内存的使用信息 : <code>free -t //以总和的形式查询内存的使用信息</code></li>
<li>周期性的查询内存使用信息 : <code>free -s 10 //每10s 执行一次命令</code></li>
</ul>
</li>
</ul>
<h2 id="linux-free命令-详解"><a href="#linux-free命令-详解" class="headerlink" title="linux free命令 详解"></a>linux free命令 详解</h2><p><code>free</code> 命令用于显示系统中的内存使用情况，包括物理内存和交换空间。以下是 <code>free</code> 命令的详解：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [选项]</span><br></pre></td></tr></table></figure>

<p><strong>常用选项：</strong></p>
<ul>
<li><code>-b</code>：以字节为单位显示内存使用情况。</li>
<li><code>-k</code>：以千字节为单位显示内存使用情况（默认选项）。</li>
<li><code>-m</code>：以兆字节为单位显示内存使用情况。</li>
<li><code>-g</code>：以吉字节为单位显示内存使用情况。</li>
<li><code>-t</code>：显示总计行，将所有内存列的总和显示出来。</li>
<li><code>-h</code>：以人类可读的格式显示内存大小。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>

<p><strong>输出示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7827        3245         872        1065        3710        2708</span><br><span class="line">Swap:          8191           0        8191</span><br></pre></td></tr></table></figure>

<p><strong>字段解释：</strong></p>
<ul>
<li><code>total</code>: 总内存</li>
<li><code>used</code>: 已使用的内存</li>
<li><code>free</code>: 空闲内存</li>
<li><code>shared</code>: 多个进程共享的内存</li>
<li><code>buff/cache</code>: 用于缓存的内存，包括文件系统缓存和用于磁盘 I&#x2F;O 的缓冲区</li>
<li><code>available</code>: 可用内存，即系统可以提供给新进程使用的内存</li>
<li><code>Swap</code>: 交换空间，包括 <code>total</code>（总交换空间）、<code>used</code>（已使用的交换空间）和 <code>free</code>（空闲的交换空间）</li>
</ul>
<p><code>free</code> 命令的输出可以帮助你了解系统的内存使用情况，特别是在监控系统性能或诊断性能问题时。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_02_other/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_02_other/" class="post-title-link" itemprop="url">linux_2_02_other</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>不同的终端类型、Shell版本其中断的按键是不同的，甚至还可以自定义，这可通过stty命令查询：<code>sitty -a</code></li>
<li>注意：<code>^</code>是Ctrl的缩写</li>
</ul>
<h2 id="终端初始化脚本"><a href="#终端初始化脚本" class="headerlink" title="终端初始化脚本"></a>终端初始化脚本</h2><ul>
<li>参考：<ul>
<li><code>https://www.cnblogs.com/yoyo-sincerely/p/5931245.html</code></li>
</ul>
</li>
</ul>
<h2 id="显示路径问题"><a href="#显示路径问题" class="headerlink" title="显示路径问题"></a>显示路径问题</h2><ul>
<li><p><code>\w</code>  –  当前工作目录，例如<code>/home/user</code></p>
</li>
<li><p><code>\W</code>  –  当前工作目录的基名(basename)，例如<code>user</code></p>
</li>
<li><p>解决问题：终端显示路径太长，不易于阅读</p>
</li>
<li><p>解决方法：将<code>.bashrc</code>中的<code>\w</code>更换为<code>\W</code></p>
</li>
</ul>
<h2 id="MD5校验"><a href="#MD5校验" class="headerlink" title="MD5校验"></a>MD5校验</h2><ul>
<li>Windows下生成md5校验码: <code>certutil -hashfile filename MD5</code></li>
<li>Linux下生成md5校验码:   <code>md5sum filename</code></li>
</ul>
<h2 id="文件名通配符"><a href="#文件名通配符" class="headerlink" title="文件名通配符"></a>文件名通配符</h2><ul>
<li><code>×</code>：与0个或多个任意的字符相匹配</li>
<li><code>？</code>：只与单个任意的字符匹配，可以使用多个问号</li>
<li><code>[]</code>：与<code>？</code>相似，只与一个字符匹配。区别在于：问号与任意一个字符匹配，而方括号只与方括号中列出的字符之一匹配。短横线（<code>-</code>）代表一个范围内的字符。注：只能是升序</li>
</ul>
<h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><ul>
<li>sudo, superuser do</li>
</ul>
<p>在Linux中，<code>sudo</code>是一种命令行工具，用于以超级用户（也称为root用户）的权限执行其他命令。它允许普通用户在需要执行特权操作时临时获得root权限，从而执行需要管理员权限的任务，而无需切换到root用户。</p>
<p>以下是<code>sudo</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo [options] command [arguments]</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code>是可选的一些选项，<code>command</code>是要以root权限执行的命令，<code>arguments</code>是传递给命令的参数。</p>
<p>以下是一些常见的<code>sudo</code>命令选项和用法：</p>
<ol>
<li><p>以root权限执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo command</span><br></pre></td></tr></table></figure>

<p>此命令将以root权限执行<code>command</code>命令。</p>
</li>
<li><p>切换到root用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -i</span><br></pre></td></tr></table></figure>

<p>此命令将打开一个新的shell会话，并切换到root用户身份。</p>
</li>
<li><p>以其他用户身份执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u username command</span><br></pre></td></tr></table></figure>

<p>此命令将以指定用户（<code>username</code>）的权限执行<code>command</code>命令。</p>
</li>
<li><p>查看sudo命令的使用情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -h</span><br></pre></td></tr></table></figure>

<p>此命令将显示<code>sudo</code>命令的帮助信息，包括选项和用法。</p>
</li>
<li><p>列出当前用户的sudo权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure>

<p>此命令将列出当前用户可以使用<code>sudo</code>执行的命令列表。</p>
</li>
</ol>
<p>通过使用<code>sudo</code>命令，系统管理员可以授予特定的权限给普通用户，使其能够执行有限的特权操作，同时避免了在整个会话中使用root权限的风险。这提供了更好的系统安全性和管理员对系统的更细粒度控制。</p>
<p>需要注意的是，只有在<code>/etc/sudoers</code>文件中明确配置了用户的sudo权限，用户才能使用<code>sudo</code>命令。只有具备sudo权限的用户才能成功执行以root权限执行的命令。</p>
<h2 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h2><ul>
<li>supervisor, 是一个客户端&#x2F;服务器系统,它允许用户监视和控制类UNIX操作系统上的许多进程,是linux下一个便利的启动和监控服务的命令</li>
<li>Supervisor, 是用Python开发的一个client&#x2F;server服务,是Linux&#x2F;Unix系统下的一个进程管理工具,不支持Windows系统.它可以很方便的监听,启动,停止,重启一个或多个进程</li>
<li>用Supervisor管理的进程,当一个进程意外被杀死,supervisor监听到进程死后,会自动将它重新拉起,很方便的做到进程自动恢复的功能,不再需要自己写shell脚本来控制.</li>
<li>因为Supervisor是Python开发的,安装前先检查一下系统是否安装了Python2.4以上的版本</li>
<li>supervisor包括两个命令:supervisord, supervisorctl,分别是后台的守护进程以及命令行管理命令.</li>
<li>supervisor安装完成后会生成是三个执行程序:<code>supervisortd</code>, <code>supervisorctl</code>, <code>echo_supervisord_conf</code><ul>
<li><code>supervisortd</code>, 用于管理supervisor本身服务</li>
<li><code>supervisorctl</code>, 用于管理需要委托给supervisor工具的服务</li>
<li><code>echo_supervisord_conf</code>, 用于生成supervisor的配置文件</li>
<li>supervisor的守护进程服务(用于接受进程管理命令),客户端(用于和守护进程通信,发送管理进程的指令)</li>
</ul>
</li>
<li>两个命令共用一个配置文件,默认是:<code>/etc/supervisor/supervisor.conf</code>,而<code>supervisor.conf</code>通过include来引入其他配置文件,一般放在<code>/etc/supervisor/conf.d</code>目录下</li>
</ul>
<h2 id="redshift"><a href="#redshift" class="headerlink" title="redshift"></a>redshift</h2><p>在Linux中，<code>redshift</code>是一种用于调整屏幕颜色温度的命令行工具。它可以通过减少屏幕的蓝光成分来减轻视觉疲劳，并在晚上或低光环境下提供更舒适的视觉体验。</p>
<p>下面是<code>redshift</code>命令的一些常见选项和用法：</p>
<ol>
<li><p>基本用法：</p>
<ul>
<li>启动<code>redshift</code>：<code>redshift</code></li>
<li>停止<code>redshift</code>：<code>redshift -x</code></li>
</ul>
</li>
<li><p>调整颜色温度：</p>
<ul>
<li>使用<code>-t</code>选项指定颜色温度（单位为开尔文）：<code>redshift -t 4000</code></li>
<li>使用<code>-b</code>选项指定颜色温度并降低亮度：<code>redshift -b 0.8 -t 4000</code></li>
</ul>
</li>
<li><p>调整定位信息：</p>
<ul>
<li>使用<code>-l</code>选项指定纬度和经度以计算日出和日落时间：<code>redshift -l LAT:LON</code></li>
<li>例如：<code>redshift -l 37.8:-122.4</code>（设定位置为旧金山）</li>
</ul>
</li>
<li><p>调整亮度：</p>
<ul>
<li>使用<code>-m</code>选项启用亮度调整模式：<code>redshift -m METHOD</code></li>
<li>方法包括<code>randr</code>（默认值）和<code>vidmode</code></li>
</ul>
</li>
<li><p>调整亮度变化速度：</p>
<ul>
<li>使用<code>-r</code>选项指定亮度变化速度（单位为小时）：<code>redshift -r SPEED</code></li>
</ul>
</li>
<li><p>自定义配置文件：</p>
<ul>
<li>使用<code>-c</code>选项指定自定义配置文件的路径：<code>redshift -c /path/to/config</code></li>
</ul>
</li>
<li><p>显示调试信息：</p>
<ul>
<li>使用<code>-v</code>选项显示详细的调试信息：<code>redshift -v</code></li>
</ul>
</li>
</ol>
<p>以上是一些常见的<code>redshift</code>命令选项和用法示例。请注意，<code>redshift</code>命令需要正确配置和运行，以便根据位置和时间自动调整屏幕颜色温度。您可以根据自己的需求和喜好来调整命令的参数，以达到最佳的视觉效果。</p>
<h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><ul>
<li>在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具。支持文件的上传和下载，是综合传输工具，但是按照传统，习惯称curl为下载工具</li>
<li>参数<ul>
<li><code>-f / --fail</code> : 连接失败时不显示http错误</li>
<li><code>-s / --silent</code> : 静音模式，不输出任何东西</li>
<li><code>-S / --show-error</code> : 当与<code>-s</code>一起使用时，如果<code>curl</code>失败，<code>curl</code>将显示一条错误消息</li>
<li><code>-L / --location</code> : （HTTP&#x2F;HTTPS）跟踪重定向。如果服务器报告请求页面已移动到另一个位置，此选项将使curl在新位置上重做请求</li>
</ul>
</li>
</ul>
<p>在Linux中，<code>curl</code>命令是一个功能强大的网络工具，用于与服务器进行数据交互。它支持多种协议，包括HTTP、HTTPS、FTP、SMTP等，并可以执行各种操作，如下载文件、发送请求、上传文件等。</p>
<p>以下是<code>curl</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [options] [URL]</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code>是可选的一些选项，用于配置<code>curl</code>的行为，<code>URL</code>是要访问的目标地址。</p>
<p>以下是一些常见的<code>curl</code>命令选项和用法：</p>
<ol>
<li><p>发送HTTP GET请求并输出响应内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://example.com</span><br></pre></td></tr></table></figure>

<p>此命令将向<code>http://example.com</code>发送HTTP GET请求，并将响应内容输出到终端。</p>
</li>
<li><p>下载文件到本地：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://example.com/file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将从<code>http://example.com/file.txt</code>下载文件，并保存到当前目录下的<code>file.txt</code>文件。</p>
</li>
<li><p>发送POST请求并传递参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &quot;param1=value1&amp;param2=value2&quot; -X POST http://example.com/api</span><br></pre></td></tr></table></figure>

<p>此命令将向<code>http://example.com/api</code>发送HTTP POST请求，并将参数<code>param1=value1&amp;param2=value2</code>作为请求体发送。</p>
</li>
</ol>
<p><code>curl</code>命令还支持其他许多选项，如设置请求头、设置超时时间、处理重定向等。</p>
<p>使用<code>curl</code>命令可以方便地进行各种网络操作，如获取API数据、下载文件、测试网络连接等。它是一种非常强大和灵活的工具，广泛应用于开发、调试和自动化脚本等场景。</p>
<hr>
<h2 id="curl-–data-binary"><a href="#curl-–data-binary" class="headerlink" title="curl –data-binary"></a>curl –data-binary</h2><p><code>curl</code> 是一个命令行工具，用于进行 HTTP 请求。<code>--data-binary</code> 选项用于在 HTTP POST 请求中发送二进制数据作为请求体。以下是对该选项的详细解释：</p>
<p>当你在 <code>curl</code> 中使用 <code>--data-binary</code> 选项时，你需要提供要发送的数据作为请求体。这些数据可以是二进制数据，即可以包含非文本字符或不适合解释为纯文本的格式。例如，它可以是图像文件、视频文件或任何其他类型的二进制数据。</p>
<p><code>--data-binary</code> 选项期望你在命令行上直接指定数据，通常需要使用引号将其括起来，以保留任何特殊字符或格式。以下是一个示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --data-binary &quot;@文件名&quot; URL</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>@文件名</code> 表示包含要发送的二进制数据的文件路径。<code>@</code> 符号告诉 <code>curl</code> 读取文件的内容并将其用作请求体。</p>
<p>另外，你也可以直接在命令行上内联指定二进制数据，而无需使用文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --data-binary &quot;二进制数据&quot; URL</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>&quot;二进制数据&quot;</code> 表示你要发送的实际二进制数据。如果需要，确保正确编码数据，特别是如果数据包含可能被命令行解释器解释为特殊字符的字符。</p>
<p>当 <code>curl</code> 使用 <code>--data-binary</code> 选项发送 HTTP 请求时，默认情况下会将 <code>Content-Type</code> 头设置为 <code>application/octet-stream</code>。这向服务器表明请求体包含未知或未指定类型的二进制数据。如果需要指定其他内容类型，可以使用 <code>--header</code> 选项设置适当的头部。</p>
<p>值得注意的是，<code>--data-binary</code> 与 <code>curl</code> 中的 <code>--data</code> 选项是不同的。<code>--data</code> 选项用于将数据作为请求体发送，但它将数据视为纯文本，进行字符编码和特殊字符解释。相比之下，<code>--data-binary</code> 保留了数据的二进制特性，没有进行任何修改。</p>
<p>请记得将 “文件名” 替换为实际的文件路径，或将 “二进制数据” 替换为要发送的二进制数据，并将 “URL” 替换为要发送请求的服务器的 URL。</p>
<h2 id="xdg-user-dirs-upate"><a href="#xdg-user-dirs-upate" class="headerlink" title="xdg-user-dirs-upate"></a>xdg-user-dirs-upate</h2><ul>
<li>该命令会读取配置文件<code>/etc/xdg/user-dirs.defaults</code>,并在<code>$HOME</code>下创建一整套默认的经本地化的用户目录</li>
</ul>
<p><code>xdg-user-dirs-update</code>命令是一个用于更新用户目录的工具，它在Linux系统中用于管理用户的标准目录，例如桌面、下载、文档、音乐、图片等目录。</p>
<p>在Linux系统中，用户目录的路径通常存储在<code>~/.config/user-dirs.dirs</code>文件中。<code>xdg-user-dirs-update</code>命令用于根据配置文件中定义的规则，更新用户目录的路径和名称。</p>
<p>以下是<code>xdg-user-dirs-update</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xdg-user-dirs-update</span><br></pre></td></tr></table></figure>

<p>运行<code>xdg-user-dirs-update</code>命令将读取<code>~/.config/user-dirs.dirs</code>文件中的配置信息，并根据配置更新用户目录的路径和名称。</p>
<p><code>~/.config/user-dirs.dirs</code>文件的示例内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XDG_DESKTOP_DIR=&quot;$HOME/Desktop&quot;</span><br><span class="line">XDG_DOWNLOAD_DIR=&quot;$HOME/Downloads&quot;</span><br><span class="line">XDG_DOCUMENTS_DIR=&quot;$HOME/Documents&quot;</span><br><span class="line">XDG_MUSIC_DIR=&quot;$HOME/Music&quot;</span><br><span class="line">XDG_PICTURES_DIR=&quot;$HOME/Pictures&quot;</span><br><span class="line">XDG_VIDEOS_DIR=&quot;$HOME/Videos&quot;</span><br></pre></td></tr></table></figure>

<p>上述配置定义了标准的用户目录路径，如桌面、下载、文档、音乐、图片和视频目录。</p>
<p>运行<code>xdg-user-dirs-update</code>命令后，它将根据配置文件的内容，自动创建相应的目录，并将用户的默认目录路径设置为配置文件中定义的路径。</p>
<p><code>xdg-user-dirs-update</code>命令通常在用户登录时自动执行，确保用户的标准目录存在且正确设置。</p>
<h2 id="gnome-screensaver-command"><a href="#gnome-screensaver-command" class="headerlink" title="gnome-screensaver-command"></a>gnome-screensaver-command</h2><p><code>gnome-screensaver-command</code> 是用于与 GNOME 屏幕保护程序交互的命令行工具。它允许你控制屏幕保护程序的状态、设置和操作。</p>
<p>以下是一些常用的 <code>gnome-screensaver-command</code> 命令及其功能：</p>
<ul>
<li><code>gnome-screensaver-command -a</code>：激活屏幕保护程序。这会立即启动屏幕保护程序并锁定屏幕，要解锁屏幕，你需要提供用户密码。</li>
<li><code>gnome-screensaver-command -d</code>：禁用屏幕保护程序。这会关闭屏幕保护程序的自动启动和锁定屏幕的功能。</li>
<li><code>gnome-screensaver-command -q</code>：查询屏幕保护程序的状态。它会返回屏幕保护程序是否激活和屏幕是否锁定的信息。</li>
<li><code>gnome-screensaver-command -l</code>：锁定屏幕。这会立即锁定屏幕，要解锁屏幕，你需要提供用户密码。</li>
</ul>
<p>这些是 <code>gnome-screensaver-command</code> 命令的一些示例。通过使用不同的选项，你可以进行更多的配置和操作，如设置屏幕保护程序的超时时间、配置锁定屏幕的效果等。</p>
<p>需要注意的是，<code>gnome-screensaver-command</code> 命令仅在使用 GNOME 桌面环境的 Linux 系统中可用。对于其他桌面环境或窗口管理器，可能有不同的命令或工具来控制屏幕保护程序。</p>
<p>希望这个解释对你有帮助！如有需要，请随时提问。</p>
<hr>
<h2 id="pulseaudio"><a href="#pulseaudio" class="headerlink" title="pulseaudio"></a>pulseaudio</h2><p>PulseAudio 是 Linux 上广泛使用的音频服务器和音频子系统。它提供了许多命令行工具来管理和控制音频设备、音频流和音量等。下面是一些常用的 PulseAudio 命令及其详解：</p>
<ol>
<li><p><code>pacmd</code>：<code>pacmd</code> 是 PulseAudio 的命令行控制界面，可以用于交互式地管理和监视 PulseAudio。通过输入 <code>pacmd</code> 进入交互模式，然后可以使用以下命令：</p>
<ul>
<li><p><code>list-sinks</code>：列出所有可用的音频输出设备（音频输出设备称为 “sink”）。</p>
</li>
<li><p><code>list-sources</code>：列出所有可用的音频输入设备（音频输入设备称为 “source”）。</p>
</li>
<li><p><code>list-clients</code>：列出所有当前连接到 PulseAudio 的客户端应用程序。</p>
</li>
<li><p><code>set-default-sink</code>：设置默认的音频输出设备。</p>
</li>
<li><p><code>set-default-source</code>：设置默认的音频输入设备。</p>
</li>
<li><p><code>set-sink-volume</code>：设置音频输出设备的音量。</p>
</li>
<li><p><code>set-source-volume</code>：设置音频输入设备的音量。</p>
</li>
<li><p><code>exit</code>：退出 <code>pacmd</code> 交互模式。</p>
</li>
</ul>
</li>
<li><p><code>pactl</code>：<code>pactl</code> 是 PulseAudio 的控制命令行工具，用于控制 PulseAudio 的运行状态和配置。下面是一些常用的 <code>pactl</code> 命令：</p>
<ul>
<li><p><code>pactl list</code>：列出当前 PulseAudio 状态的概览，包括音频设备、音频流和音量等信息。</p>
</li>
<li><p><code>pactl set-sink-volume</code>：设置音频输出设备的音量。</p>
</li>
<li><p><code>pactl set-source-volume</code>：设置音频输入设备的音量。</p>
</li>
<li><p><code>pactl set-default-sink</code>：设置默认的音频输出设备。</p>
</li>
<li><p><code>pactl set-default-source</code>：设置默认的音频输入设备。</p>
</li>
<li><p><code>pactl suspend</code>：暂停或恢复 PulseAudio 服务器。</p>
</li>
<li><p><code>pactl exit</code>：停止 PulseAudio 服务器。</p>
</li>
</ul>
</li>
<li><p><code>pavucontrol</code>：<code>pavucontrol</code> 是 PulseAudio 的图形用户界面控制面板，用于图形化地管理和控制 PulseAudio。可以通过命令行运行 <code>pavucontrol</code> 启动它。</p>
<p><code>pavucontrol</code> 提供了一个用户友好的界面，可以查看和调整每个应用程序的音频流、音量和音频设备等设置。</p>
</li>
</ol>
<p>这些命令只是 PulseAudio 提供的一部分工具和功能。你可以根据需要查阅相关文档和手册，或者使用命令的 <code>--help</code> 选项获取更详细的命令说明和选项信息。</p>
<hr>
<h2 id="alsamixer"><a href="#alsamixer" class="headerlink" title="alsamixer"></a>alsamixer</h2><p><code>alsamixer</code> 是 Linux 上用于调整 ALSA（Advanced Linux Sound Architecture）音频驱动的命令行工具。它提供了一个终端界面，允许你调整音频设备的音量、通道设置和其他音频参数。下面是一些常用的 <code>alsamixer</code> 命令及其详解：</p>
<ol>
<li><p><code>alsamixer</code>：直接运行 <code>alsamixer</code> 命令将打开一个终端窗口，显示当前音频设备的音量控制界面。</p>
<ul>
<li>使用左右箭头键切换不同的音频通道（如果有多个通道可用）。</li>
<li>使用上下箭头键调整当前通道的音量。</li>
<li>使用空格键切换静音状态。</li>
<li>使用 Esc 键退出 <code>alsamixer</code>。</li>
</ul>
</li>
<li><p><code>alsamixer -c &lt;card&gt;</code>：使用 <code>-c</code> 选项指定要控制的音频设备（声卡）。可以通过 <code>&lt;card&gt;</code> 参数指定声卡的编号或标识符。例如，<code>alsamixer -c 0</code> 或 <code>alsamixer -c hw:0</code>。</p>
</li>
<li><p><code>alsamixer -V &lt;view&gt;</code>：使用 <code>-V</code> 选项指定要显示的视图。视图可以是 <code>Playback</code>（播放），<code>Capture</code>（捕获）或 <code>All</code>（全部）。例如，<code>alsamixer -V Capture</code> 将只显示捕获设备的音量控制界面。</p>
</li>
<li><p><code>alsamixer -D &lt;device&gt;</code>：使用 <code>-D</code> 选项指定要控制的特定音频设备。可以通过 <code>&lt;device&gt;</code> 参数指定设备的名称或标识符。例如，<code>alsamixer -D hw:0,0</code>。</p>
</li>
<li><p><code>alsamixer -h</code> 或 <code>alsamixer --help</code>：显示 <code>alsamixer</code> 命令的帮助信息，包括可用选项和用法示例。</p>
</li>
</ol>
<p>通过 <code>alsamixer</code>，你可以调整音频设备的音量、平衡、增益和其他音频控制参数。请注意，使用 <code>alsamixer</code> 进行的更改是实时的，不会永久保存。如果你希望在系统启动时应用特定的音频设置，可能需要考虑其他方法，例如 ALSA 的配置文件或其他工具。</p>
<p>在使用 <code>alsamixer</code> 时，如果遇到问题或需要进一步了解每个选项的详细说明，可以参考 ALSA 的官方文档或手册。</p>
<hr>
<hr>
<h2 id="aplay"><a href="#aplay" class="headerlink" title="aplay"></a>aplay</h2><p><code>aplay</code> 是 Linux 系统上的命令行音频播放工具，它使用 ALSA（Advanced Linux Sound Architecture）来播放音频文件。下面是对 <code>aplay</code> 命令的详细解释：</p>
<ol>
<li><p><code>aplay &lt;file&gt;</code>：直接运行 <code>aplay</code> 命令并指定音频文件作为参数，将会播放该音频文件。例如，<code>aplay audio.wav</code> 将会播放名为 “audio.wav” 的音频文件。</p>
</li>
<li><p><code>aplay -l</code>：使用 <code>-l</code> 选项可以列出系统上可用的音频设备（声卡）列表。它会显示设备的编号、名称和硬件信息等。</p>
</li>
<li><p><code>aplay -D &lt;device&gt;</code>：使用 <code>-D</code> 选项可以指定要使用的音频设备。可以通过 <code>&lt;device&gt;</code> 参数指定设备的名称或标识符。例如，<code>aplay -D hw:0,0 audio.wav</code> 将会使用 <code>hw:0,0</code> 设备播放 “audio.wav” 文件。</p>
</li>
<li><p><code>aplay -f &lt;format&gt;</code>：使用 <code>-f</code> 选项可以指定音频文件的格式。可以通过 <code>&lt;format&gt;</code> 参数指定格式，如 <code>S16_LE</code>、<code>S24_LE</code>、<code>float_le</code> 等。</p>
</li>
<li><p><code>aplay -r &lt;rate&gt;</code>：使用 <code>-r</code> 选项可以指定音频文件的采样率。可以通过 <code>&lt;rate&gt;</code> 参数指定采样率的数值。</p>
</li>
<li><p><code>aplay -c &lt;channels&gt;</code>：使用 <code>-c</code> 选项可以指定音频文件的通道数。可以通过 <code>&lt;channels&gt;</code> 参数指定通道数的数值。</p>
</li>
<li><p><code>aplay -t &lt;duration&gt;</code>：使用 <code>-t</code> 选项可以指定音频文件的播放时长。可以通过 <code>&lt;duration&gt;</code> 参数指定播放时长的数值和单位，如 <code>10s</code>、<code>2m</code> 等。</p>
</li>
<li><p><code>aplay -q</code>：使用 <code>-q</code> 选项可以启用静默模式，即不显示播放进度和其他信息。</p>
</li>
<li><p><code>aplay --help</code>：使用 <code>--help</code> 选项可以显示 <code>aplay</code> 命令的帮助信息，包括可用选项和用法示例。</p>
</li>
</ol>
<p>这些选项只是 <code>aplay</code> 命令的一部分，你可以根据需要查阅 <code>aplay</code> 的手册页或使用命令的 <code>--help</code> 选项获取更详细的命令说明和选项信息。</p>
<p>通过 <code>aplay</code>，你可以在 Linux 系统上播放音频文件。它对于测试音频设备、验证音频配置和简单的音频播放任务非常有用。</p>
<hr>
<h2 id="modprobe"><a href="#modprobe" class="headerlink" title="modprobe"></a>modprobe</h2><p><code>modprobe</code> 是 Linux 系统上的一个命令行工具，用于动态加载和卸载内核模块（驱动程序）。它可以根据模块的名称自动加载相应的内核模块，并处理模块之间的依赖关系。下面是对 <code>modprobe</code> 命令的详细解释：</p>
<ol>
<li><p><code>modprobe &lt;module&gt;</code>：直接运行 <code>modprobe</code> 命令并指定模块名称作为参数，将会尝试加载该模块。例如，<code>modprobe snd_usb_audio</code> 将会加载名为 “snd_usb_audio” 的内核模块。</p>
</li>
<li><p><code>modprobe -r &lt;module&gt;</code>：使用 <code>-r</code> 选项可以卸载指定的内核模块。例如，<code>modprobe -r snd_usb_audio</code> 将会卸载名为 “snd_usb_audio” 的内核模块。</p>
</li>
<li><p><code>modprobe -l</code>：使用 <code>-l</code> 选项可以列出所有可用的内核模块。它会显示模块的路径和名称。</p>
</li>
<li><p><code>modprobe -a &lt;module&gt;</code>：使用 <code>-a</code> 选项可以加载指定模块及其所有依赖的模块。它会自动处理模块之间的依赖关系。</p>
</li>
<li><p><code>modprobe -c</code>：使用 <code>-c</code> 选项可以显示当前加载的内核模块的配置信息。它会列出每个模块的配置参数。</p>
</li>
<li><p><code>modprobe -n &lt;module&gt;</code>：使用 <code>-n</code> 选项可以检查指定模块是否可加载，但不实际加载它。它会输出一个表示模块是否可加载的消息。</p>
</li>
<li><p><code>modprobe -v &lt;module&gt;</code>：使用 <code>-v</code> 选项可以显示详细的加载信息，包括加载的模块及其依赖关系。</p>
</li>
<li><p><code>modprobe -d &lt;directory&gt;</code>：使用 <code>-d</code> 选项可以指定要搜索模块的目录。默认情况下，<code>modprobe</code> 将搜索默认的模块目录。</p>
</li>
<li><p><code>modprobe -h</code> 或 <code>modprobe --help</code>：显示 <code>modprobe</code> 命令的帮助信息，包括可用选项和用法示例。</p>
</li>
</ol>
<p>通过 <code>modprobe</code> 命令，你可以在 Linux 系统上动态加载和卸载内核模块。这对于根据需要加载所需的驱动程序或模块、解决硬件兼容性问题以及进行模块调试和配置非常有用。请注意，你可能需要以超级用户权限（root 或使用 <code>sudo</code> 命令）运行 <code>modprobe</code> 命令，以便加载或卸载内核模块。</p>
<p>希望这些信息能帮助你理解和使用 <code>modprobe</code> 命令。如有需要，你可以参考相关文档或手册以获取更多详细信息。</p>
<hr>
<h2 id="insmod"><a href="#insmod" class="headerlink" title="insmod"></a>insmod</h2><p><code>insmod</code> 是 Linux 系统上的一个命令行工具，用于手动加载内核模块（驱动程序）到内核中。它可以加载指定的内核模块并将其插入当前运行的内核中。下面是对 <code>insmod</code> 命令的详细解释：</p>
<ol>
<li><p><code>insmod &lt;module&gt;</code>：直接运行 <code>insmod</code> 命令并指定模块名称作为参数，将会尝试加载该模块。例如，<code>insmod mymodule.ko</code> 将会加载名为 “mymodule.ko” 的内核模块。</p>
</li>
<li><p><code>insmod -f &lt;module&gt;</code>：使用 <code>-f</code> 选项可以强制加载指定的内核模块，即使模块已经加载过。注意，这可能导致冲突或意外行为，因此谨慎使用该选项。</p>
</li>
<li><p><code>insmod -r &lt;module&gt;</code>：使用 <code>-r</code> 选项可以卸载指定的内核模块。注意，使用 <code>insmod -r</code> 只会从内核中卸载模块，而不会处理模块的依赖关系。因此，如果有其他模块依赖于该模块，则可能导致系统不稳定。</p>
</li>
<li><p><code>insmod -l &lt;module&gt;</code>：使用 <code>-l</code> 选项可以指定模块文件的路径，而不是使用当前目录。例如，<code>insmod -l /path/to/modules/mymodule.ko</code> 将加载指定路径下的内核模块。</p>
</li>
<li><p><code>insmod -s &lt;symbol&gt;</code>：使用 <code>-s</code> 选项可以指定要加载的模块中的符号（函数或变量）。这在需要仅加载模块中的特定符号时很有用。</p>
</li>
<li><p><code>insmod -h</code> 或 <code>insmod --help</code>：显示 <code>insmod</code> 命令的帮助信息，包括可用选项和用法示例。</p>
</li>
</ol>
<p>需要注意的是，使用 <code>insmod</code> 命令手动加载内核模块需要具有超级用户权限（root 或使用 <code>sudo</code> 命令）。加载模块前，你需要确保该模块的二进制文件（<code>.ko</code> 文件）存在，并且与当前运行的内核版本兼容。</p>
<p>希望这些信息能帮助你理解和使用 <code>insmod</code> 命令。如有需要，你可以参考相关文档或手册以获取更多详细信息。</p>
<hr>
<h2 id="ubuntu-drivers-devices"><a href="#ubuntu-drivers-devices" class="headerlink" title="ubuntu-drivers devices"></a>ubuntu-drivers devices</h2><p><code>ubuntu-drivers devices</code> 是一个 Ubuntu 系统上的命令，用于列出可用的硬件驱动程序。它会扫描系统上的硬件设备，并显示适用于这些设备的推荐和可选驱动程序。下面是对 <code>ubuntu-drivers devices</code> 命令的详细解释：</p>
<ol>
<li><p><code>ubuntu-drivers devices</code>：直接运行 <code>ubuntu-drivers devices</code> 命令将列出系统中的硬件设备以及可用的驱动程序信息。</p>
</li>
<li><p>输出格式：命令的输出结果包含了设备的厂商、型号和设备标识符等信息，以及推荐和可选驱动程序的名称。</p>
</li>
<li><p>推荐驱动程序：在输出结果中，推荐的驱动程序被标记为 “recommended”，表示它们是最适合该设备的驱动程序。这些驱动程序通常由 Ubuntu 官方维护，并且在兼容性和稳定性方面经过测试。</p>
</li>
<li><p>可选驱动程序：在输出结果中，可选的驱动程序被标记为 “proprietary”，表示它们是由硬件厂商提供的专有驱动程序。这些驱动程序可能提供更好的性能或功能，但可能不像推荐驱动程序那样经过广泛测试。</p>
</li>
</ol>
<p>通过运行 <code>ubuntu-drivers devices</code> 命令，你可以获取有关系统硬件设备和适用驱动程序的信息。这对于了解系统硬件配置、选择适当的驱动程序以及解决硬件兼容性问题非常有用。</p>
<p>希望这些信息能帮助你理解和使用 <code>ubuntu-drivers devices</code> 命令。如有需要，你可以参考相关文档或手册以获取更多详细信息。</p>
<hr>
<h2 id="gsettings"><a href="#gsettings" class="headerlink" title="gsettings"></a>gsettings</h2><p><code>gsettings</code> 是一个命令行工具，用于在 Ubuntu 中访问和修改 GNOME 桌面环境的设置。它允许你通过命令行方式读取和更改各种系统设置、应用程序设置以及桌面外观和行为等。</p>
<p>下面是一些 <code>gsettings</code> 命令的常见用法和解释：</p>
<ol>
<li><p><code>gsettings list-schemas</code>：列出可用的模式（schemas）。这将显示所有可用的模式名称，你可以使用这些模式名称来查询和修改相关设置。</p>
</li>
<li><p><code>gsettings list-keys SCHEMA</code>：列出给定模式（SCHEMA）下的所有键（keys）。使用具体的模式名称替换 <code>SCHEMA</code> 部分来查看该模式下的所有可用键。</p>
</li>
<li><p><code>gsettings get SCHEMA KEY</code>：获取给定模式（SCHEMA）下给定键（KEY）的值。这可用于查看当前设置的值。</p>
</li>
<li><p><code>gsettings set SCHEMA KEY VALUE</code>：将给定模式（SCHEMA）下给定键（KEY）的值设置为指定的值（VALUE）。使用这个命令可以修改设置的值。</p>
</li>
<li><p><code>gsettings reset SCHEMA KEY</code>：重置给定模式（SCHEMA）下给定键（KEY）的值为默认值。</p>
</li>
<li><p><code>gsettings range SCHEMA KEY</code>：显示给定模式（SCHEMA）下给定键（KEY）的值的允许范围。</p>
</li>
</ol>
<p>需要注意的是，<code>SCHEMA</code> 是模式的名称，而 <code>KEY</code> 是模式中的键的名称。你可以使用 <code>list-schemas</code> 和 <code>list-keys</code> 命令来获取可用的模式和键的列表。</p>
<p>举例来说，<code>org.gnome.desktop.background</code> 是一个常用的模式，用于控制桌面背景相关的设置。你可以使用类似以下的命令来修改桌面背景图片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.desktop.background picture-uri &#x27;file:///path/to/image.jpg&#x27;</span><br></pre></td></tr></table></figure>
<p>这会将桌面背景设置为指定路径下的图像文件。</p>
<p><code>gsettings</code> 提供了一种方便的方式来从命令行管理和调整 GNOME 桌面环境的各种设置。你可以查阅相关的文档和手册来获取更多关于 <code>gsettings</code> 命令的详细信息和示例用法。</p>
<h2 id="nautilus"><a href="#nautilus" class="headerlink" title="nautilus"></a>nautilus</h2><p><code>nautilus</code> 是 Linux 系统中一个常用的文件管理器，它提供了图形化界面来浏览和管理文件和文件夹。下面是对 <code>nautilus</code> 命令的详细解释：</p>
<ol>
<li><p><strong>启动 Nautilus：</strong> 可以在终端中输入 <code>nautilus</code> 命令来启动 Nautilus 文件管理器。它会打开一个新的窗口显示当前用户的主目录。</p>
</li>
<li><p><strong>打开指定目录：</strong> 可以使用 <code>nautilus</code> 命令并指定目录路径来打开特定的目录。例如，<code>nautilus /path/to/directory</code> 会打开指定路径的目录。</p>
</li>
<li><p><strong>图形化界面操作：</strong> Nautilus 提供了一系列图形化界面操作，包括文件和文件夹的复制、剪切、粘贴、重命名、删除等。可以使用鼠标右键单击文件或文件夹，或使用菜单栏的选项来执行这些操作。</p>
</li>
<li><p><strong>查看和排序文件列表：</strong> Nautilus 允许你以不同的方式查看和排序文件列表。你可以切换到图标视图、列表视图或压缩视图，并可以根据名称、大小、类型等进行排序。</p>
</li>
<li><p><strong>搜索文件：</strong> Nautilus 提供了搜索功能，可以通过菜单栏中的搜索栏输入关键字来搜索文件和文件夹。</p>
</li>
<li><p><strong>自定义文件管理器：</strong> Nautilus 允许你自定义文件管理器的外观和行为。你可以通过菜单栏中的“偏好设置”选项访问各种设置选项，如外观、行为、文件预览等。</p>
</li>
</ol>
<p>请注意，<code>nautilus</code> 命令通常用于在桌面环境中打开 Nautilus 文件管理器。如果你使用的是不带桌面环境的服务器版本的 Linux，可能无法直接运行 <code>nautilus</code> 命令。在服务器上，你可能需要使用其他基于终端的文件管理工具。</p>
<hr>
<h2 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h2><ul>
<li><p>简介：</p>
<ul>
<li>xxd 是一个在 Linux 系统中用于十六进制和ASCII码转换的命令行工具。它可以将文件或输入的数据转换为十六进制和ASCII码的表示形式，或者将十六进制和ASCII码的数据还原为二进制格式</li>
</ul>
</li>
<li><p>语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd [选项] [文件名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项：</p>
<ul>
<li>-b：以二进制格式显示数据。</li>
<li>-c &lt;列数&gt;：指定每行显示的列数。</li>
<li>-e：以大端字节序（big-endian）格式显示数据。</li>
<li>-g &lt;字节数&gt;：指定每个显示的数据块的字节数。</li>
<li>-l &lt;长度&gt;：指定要显示的字节数。</li>
<li>-s &lt;偏移量&gt;：指定要从输入中开始显示的偏移量。</li>
<li>-u：以大写字母表示十六进制数值。</li>
<li>-v：以完整的输出格式显示，不省略重复的行。</li>
</ul>
</li>
</ul>
<h2 id="hexdump"><a href="#hexdump" class="headerlink" title="hexdump"></a>hexdump</h2><ul>
<li><p>简介：</p>
<ul>
<li>hexdump 命令在 Linux 中用于以十六进制和ASCII码形式显示文件或输入的内容。它可以将二进制文件或数据转换为人可读的格式</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump [选项] [文件名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项：</p>
<ul>
<li>-C：以十六进制和ASCII码形式显示内容，并在每行末尾显示对应的ASCII字符。</li>
<li>-b：以八进制格式显示内容。</li>
<li>-c：以字符形式显示内容。</li>
<li>-d：以十进制格式显示内容。</li>
<li>-e：指定自定义的格式字符串来显示内容。</li>
<li>-n &lt;长度&gt;：指定要显示的字节数。</li>
<li>-s &lt;偏移量&gt;：指定要从输入中开始显示的偏移量。</li>
<li>-v：以完整的输出格式显示，不省略重复的行。</li>
<li>-x：以十六进制格式显示内容。</li>
</ul>
</li>
</ul>
<h2 id="exiftool"><a href="#exiftool" class="headerlink" title="exiftool"></a>exiftool</h2><ul>
<li><p>简介：</p>
<ul>
<li>在 Linux 上可以使用 exiftool 命令来查看图片的元数据。你可以在终端中运行以下命令来获取图片的详细元数据：</li>
<li><code>exiftool image.jpg</code></li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>安装依赖包libimage-exiftool-perl: <code>sudo apt install libimage-exiftool-perl</code></li>
</ul>
</li>
</ul>
<h2 id="linux下，常用的查看动态库的符号链接工具"><a href="#linux下，常用的查看动态库的符号链接工具" class="headerlink" title="linux下，常用的查看动态库的符号链接工具"></a>linux下，常用的查看动态库的符号链接工具</h2><ol>
<li><p>nm：nm 命令用于列出目标文件或共享库中的符号信息。可以使用 nm 命令来查看动态库中的符号链接。例如，要查看一个动态库文件（如libexample.so）中的符号链接，可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -D libexample.so</span><br></pre></td></tr></table></figure>
<p>这将显示动态库中的所有符号及其链接信息。</p>
</li>
<li><p>objdump：objdump 命令用于显示目标文件或可执行文件的信息，包括符号表。可以使用 objdump 命令来查看动态库中的符号链接。例如，要查看一个动态库文件中的符号链接，可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -T libexample.so</span><br></pre></td></tr></table></figure>
<p>这将显示动态库中的符号链接表。</p>
</li>
<li><p>readelf：readelf 命令用于显示 ELF（Executable and Linkable Format）格式文件的信息，包括符号表。可以使用 readelf 命令来查看动态库中的符号链接。例如，要查看一个动态库文件中的符号链接，可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s libexample.so</span><br></pre></td></tr></table></figure>
<p>这将显示动态库中的符号表，其中包含符号链接信息。</p>
</li>
</ol>
<h2 id="Linux-常用命令全拼"><a href="#Linux-常用命令全拼" class="headerlink" title="Linux 常用命令全拼"></a>Linux 常用命令全拼</h2><ul>
<li>参考网站：<code>https://www.runoob.com/w3cnote/linux-command-full-fight.html</code></li>
</ul>
<h2 id="eog"><a href="#eog" class="headerlink" title="eog"></a>eog</h2><!-- + 简介：
  + 使用命令行查看图片

+ 示例：
  + `eog picturepath` -->

<ul>
<li><p>简介：</p>
<ul>
<li>eog 是 Linux 系统中的一个命令行工具，用于打开和显示图像文件。它是 Eye of GNOME (EOG) 图像查看器的命令行接口</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eog [选项] [图像文件]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项：</p>
<ul>
<li>-f 或 –fullscreen：以全屏模式打开图像。</li>
<li>-g 或 –geometry&#x3D;宽度x高度：指定窗口的初始大小。</li>
<li>-n 或 –new-instance：在新的 EOG 实例中打开图像。</li>
<li>-w 或 –disable-gallery：禁用图库模式</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eog image.jpg</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>当你在终端中运行 eog 命令并指定一个图像文件作为参数时，它会打开 Eye of GNOME (EOG) 图像查看器，并在窗口中显示指定的图像。你可以使用鼠标滚轮来缩放图像，使用工具栏进行放大、缩小、旋转等操作。还可以通过菜单栏中的选项进行图像的保存、打印和设置</li>
<li>eog 命令提供了一个快速和方便的方式来查看图像文件，尤其适用于图像的预览和简单的编辑操作。它支持多种常见的图像格式，如 JPEG、PNG、GIF 等</li>
<li>需要注意的是，eog 命令通常用于在图形化环境下打开图像文件。如果你在没有图形界面的终端环境中运行 eog 命令，可能会出现错误或无法正常工作</li>
</ul>
</li>
</ul>
<h2 id="查看linux服务器开机自启动服务"><a href="#查看linux服务器开机自启动服务" class="headerlink" title="查看linux服务器开机自启动服务"></a>查看linux服务器开机自启动服务</h2><ul>
<li><p>命令：</p>
<ul>
<li><code>systemctl list-unit-files</code></li>
</ul>
</li>
<li><p>参数：</p>
<ul>
<li>其中STATE显示为enable字样的服务，即可开机自启动的服务</li>
</ul>
</li>
<li><p>查处的内容过多，可通过grep 命令进行筛选</p>
<ul>
<li><code>systemctl list-unit-files | grep firewalld</code></li>
</ul>
</li>
</ul>
<h2 id="开启或关闭开机自启动"><a href="#开启或关闭开机自启动" class="headerlink" title="开启或关闭开机自启动"></a>开启或关闭开机自启动</h2><ul>
<li><p>关闭开机自启动：</p>
<ul>
<li><code>systemctl disable  服务name</code></li>
</ul>
</li>
<li><p>开启开机自启动：</p>
<ul>
<li><code>systemctl enable  服务name</code></li>
</ul>
</li>
</ul>
<h2 id="getconf"><a href="#getconf" class="headerlink" title="getconf"></a>getconf</h2><ul>
<li>简介：<ul>
<li>查询保存系统配置的变量</li>
</ul>
</li>
<li>参数<ul>
<li><code>-a</code> : 显示所有当前系统的配置变量和变量的值</li>
<li><code>-v</code> : </li>
<li><code>system_var</code> : 查询指定配置变量的值</li>
<li><code>path_var</code> : 参数是一个通过pathconf命令定义的系统配置变量</li>
</ul>
</li>
</ul>
<h2 id="清空文件内容"><a href="#清空文件内容" class="headerlink" title="清空文件内容"></a>清空文件内容</h2><ul>
<li><p>通过重定向到 Null 来清空文件内容</p>
<ul>
<li><code>&gt; access.log</code></li>
</ul>
</li>
<li><p>使用 ‘true’ 命令重定向来清空文件</p>
<ul>
<li>下面我们将使用 : 符号，它是 shell 的一个内置命令，等同于 true 命令，它可被用来作为一个 no-op（即不进行任何操作）</li>
<li><code>: &gt; access.log</code></li>
<li><code>true &gt; access.log</code></li>
</ul>
</li>
<li><p>使用 cat&#x2F;cp&#x2F;dd 实用工具及 &#x2F;dev&#x2F;null 设备来清空文件</p>
<ul>
<li>在 Linux 中， null 设备基本上被用来丢弃某个进程不再需要的输出流，或者作为某个输入流的空白文件，这些通常可以利用重定向机制来达到。</li>
<li>所以 &#x2F;dev&#x2F;null 设备文件是一个特殊的文件，它将清空送到它这里来的所有输入，而它的输出则可被视为一个空文件。</li>
<li>另外，你可以通过使用 cat 命令 显示 &#x2F;dev&#x2F;null 的内容然后重定向输出到某个文件，以此来达到清空该文件的目的。</li>
<li><code>cat /dev/null &gt; access.log</code></li>
</ul>
</li>
<li><p>下面，我们将使用 cp 命令 复制 &#x2F;dev&#x2F;null 的内容到某个文件来达到清空该文件的目的，具体如下所示：</p>
<ul>
<li><code>cp /dev/null access.log</code></li>
</ul>
</li>
<li><p>而下面的命令中， if 代表输入文件，of 代表输出文件。</p>
<ul>
<li><code>dd if=/dev/null of=access.log</code></li>
</ul>
</li>
<li><p>使用 echo 命令清空文件</p>
<ul>
<li><code>echo &quot;&quot; &gt; access.log</code></li>
<li><code>echo &gt; access.log</code></li>
</ul>
</li>
<li><p>注意：你应该记住空字符串并不等同于 null 。字符串表明它是一个具体的事物，只不过它的内容可能是空的，但 null 则意味着某个事物并不存在</p>
</li>
<li><p>基于这个原因，当你将 echo 命令 的输出作为输入重定向到文件后，使用 cat 命令 来查看该文件的内容时，你将看到一个空白行（即一个空字符串）</p>
</li>
<li><p>要将 null 做为输出输入到文件中，你应该使用 -n 选项，这个选项将告诉 echo 不再像上面的那个命令那样输出结尾的那个新行。</p>
</li>
<li><p>使用 truncate 命令来清空文件内容</p>
<ul>
<li>truncate 可被用来将一个文件缩小或者扩展到某个给定的大小</li>
<li>你可以利用它和 -s 参数来特别指定文件的大小。要清空文件的内容，则在下面的命令中将文件的大小设定为 0:<ul>
<li><code>truncate -s 0 access.log</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="fstab"><a href="#fstab" class="headerlink" title="fstab"></a>fstab</h2><p><code>fstab</code>（文件系统表）是一个Linux系统配置文件，用于定义系统在启动时挂载文件系统的方式和规则。它通常位于<code>/etc/fstab</code>路径下，由系统管理员进行编辑和管理。</p>
<p><code>fstab</code>文件中的每一行表示一个要挂载的文件系统，每个字段之间用空格或制表符分隔。以下是<code>fstab</code>文件的常用字段和说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;文件系统&gt;  &lt;挂载点&gt;  &lt;文件系统类型&gt;  &lt;挂载选项&gt;  &lt;dump&gt;  &lt;pass&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;文件系统&gt;</code>：要挂载的设备或网络位置。可以是设备名称（如<code>/dev/sda1</code>）、UUID（Universally Unique Identifier）、标签（Label）或网络位置（如<code>//server/share</code>）。</li>
<li><code>&lt;挂载点&gt;</code>：设备将被挂载到的目录路径。</li>
<li><code>&lt;文件系统类型&gt;</code>：设备的文件系统类型，如<code>ext4</code>、<code>ntfs</code>、<code>nfs</code>等。</li>
<li><code>&lt;挂载选项&gt;</code>：指定挂载设备时的选项，如<code>ro</code>（只读）、<code>rw</code>（读写）、<code>noauto</code>（不自动挂载）、<code>user</code>（允许普通用户挂载）等。</li>
<li><code>&lt;dump&gt;</code>：备份标志。如果设置为<code>0</code>，表示不会被备份；如果设置为<code>1</code>，表示会被备份。</li>
<li><code>&lt;pass&gt;</code>：检查顺序。用于<code>fsck</code>命令检查文件系统的顺序。如果设置为<code>0</code>，表示不会被检查。</li>
</ul>
<p>示例<code>fstab</code>文件条目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda1   /mnt/data   ext4   defaults   0   2</span><br><span class="line">//server/share   /mnt/nfs   nfs   defaults   0   0</span><br></pre></td></tr></table></figure>

<p>上述示例中，第一行表示将<code>/dev/sda1</code>设备挂载到<code>/mnt/data</code>目录，使用<code>ext4</code>文件系统和默认挂载选项。<code>dump</code>设置为<code>0</code>，<code>pass</code>设置为<code>2</code>。第二行表示将网络位置<code>//server/share</code>挂载到<code>/mnt/nfs</code>目录，使用NFS文件系统和默认挂载选项，不进行备份和检查。</p>
<p>要编辑<code>fstab</code>文件，请使用具有管理员权限的文本编辑器，例如<code>vi</code>或<code>nano</code>。请谨慎编辑<code>fstab</code>文件，确保提供正确的设备和挂载选项，以免影响系统的正常启动和文件系统的挂载。</p>
<hr>
<h2 id="mffs-ext4"><a href="#mffs-ext4" class="headerlink" title="mffs.ext4"></a>mffs.ext4</h2><p><code>mkfs.ext4</code>是一个Linux命令，用于创建ext4文件系统（第四个扩展文件系统）在指定的设备上。</p>
<p>以下是<code>mkfs.ext4</code>命令的常用选项和用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 [options] &lt;device&gt;</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<ul>
<li><code>-b block-size</code>：指定文件系统的块大小，默认为4096字节。</li>
<li><code>-L volume-label</code>：为文件系统设置卷标。</li>
<li><code>-m reserved-blocks-percentage</code>：指定保留块的百分比，用于系统管理员。</li>
<li><code>-T usage-type</code>：设置文件系统的用途类型，如<code>news</code>, <code>backup</code>, <code>web</code>, 等。</li>
<li><code>-O feature</code>：启用指定的文件系统特性，如<code>^has_journal</code>表示不使用日志功能。</li>
<li><code>-E extended-option</code>：设置扩展选项，如<code>stride</code>, <code>stripe-width</code>, <code>nodiscard</code>, 等。</li>
</ul>
<p>示例用法：</p>
<ol>
<li>创建ext4文件系统：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>上述命令将在设备<code>/dev/sdb1</code>上创建一个ext4文件系统，默认使用4096字节的块大小。</p>
<ol start="2">
<li>创建具有指定块大小的ext4文件系统：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 -b 8192 /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>上述命令将在设备<code>/dev/sdb1</code>上创建一个ext4文件系统，并指定块大小为8192字节。</p>
<ol start="3">
<li>为ext4文件系统设置卷标：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 -L MyVolume /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>上述命令将在设备<code>/dev/sdb1</code>上创建一个ext4文件系统，并设置卷标为”MyVolume”。</p>
<ol start="4">
<li>启用特定的文件系统特性：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 -O ^has_journal /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>上述命令将在设备<code>/dev/sdb1</code>上创建一个ext4文件系统，并禁用日志功能。</p>
<p><code>mkfs.ext4</code>命令用于创建ext4文件系统之前，请确保已经正确地指定了要创建文件系统的设备。创建文件系统将格式化该设备并擦除其上的所有数据，请谨慎操作。</p>
<hr>
<h2 id="Linux下视频剪辑，录制工具"><a href="#Linux下视频剪辑，录制工具" class="headerlink" title="Linux下视频剪辑，录制工具"></a>Linux下视频剪辑，录制工具</h2><ul>
<li><p>kazam </p>
<ul>
<li>录制屏幕：<code>apt-get install -y kazam</code></li>
<li>缺点：保存的视频，在vlc打开看不到视频，传到手机剪影也不能剪辑</li>
</ul>
</li>
<li><p>openshot</p>
<ul>
<li><code>apt-get install -y openshot-qt</code></li>
<li>和pr相似</li>
</ul>
</li>
<li><p><strong>simplescreenrecorder</strong></p>
<ul>
<li>录制屏幕：<code>apt-get install -y simplescreenrecorder</code></li>
<li>优点：相比于kazam，其录制的视频，容量小，vlc支持播放</li>
</ul>
</li>
</ul>
<hr>
<h2 id="屏保命令和锁屏命令"><a href="#屏保命令和锁屏命令" class="headerlink" title="屏保命令和锁屏命令"></a>屏保命令和锁屏命令</h2><ul>
<li><p><code>gnome-screensaver-command -a</code>  –  显示屏保但是不锁定，移动鼠标或敲击键盘后自动消失</p>
</li>
<li><p><code>gnome-screensaver-command -l</code>  –  显示屏保并锁定，移动鼠标或敲击键盘弹出密码框</p>
</li>
<li><p><code>sudo loginctl list-sessions</code>   – 列出当前所有的会话（默认命令）</p>
</li>
<li><p><code>sudo loginctl lock-session [ID]</code>   – 锁定指定会话（如果会话支持屏幕锁）或者当前调用者的会话</p>
</li>
<li><p><code>sudo loginctl unlock-session [ID]</code> – 解锁指定会话（如果会话支持屏幕锁）或者当前调用者的会话</p>
</li>
<li><p><code>sudo loginctl lock-sessions</code>  –  锁定全部会话</p>
</li>
<li><p><code>sudo loginctl unlock-sessions</code> – 解锁全部会话</p>
</li>
<li><p>ubuntu18 锁屏快捷键  –  <code>Super + L</code></p>
</li>
</ul>
<hr>
<h2 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h2><p><code>fdisk</code>是一个Linux命令行工具，用于对磁盘分区进行管理和操作。它可以创建、删除、调整磁盘分区以及显示磁盘分区信息。</p>
<p>以下是<code>fdisk</code>命令的常用选项和用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk [options] &lt;device&gt;</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<ul>
<li><code>-l</code>：列出指定设备或所有设备的分区表信息。</li>
<li><code>-s</code>：显示指定设备或所有设备的分区大小。</li>
<li><code>-u</code>：以扇区而不是柱面为单位显示分区信息。</li>
<li><code>-c</code>：与<code>-l</code>选项一起使用时，使用紧凑的格式显示分区表信息。</li>
<li><code>-p</code>：与<code>-l</code>选项一起使用时，使用可打印的格式显示分区表信息。</li>
<li><code>-n</code>：创建一个新的分区。</li>
<li><code>-d</code>：删除一个分区。</li>
<li><code>-t</code>：更改分区的类型。</li>
</ul>
<p>示例用法：</p>
<ol>
<li>列出所有设备的分区表信息：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>

<p>上述命令将列出所有设备的分区表信息，包括设备名称、分区大小、分区类型等。</p>
<ol start="2">
<li>列出指定设备的分区表信息：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l /dev/sda</span><br></pre></td></tr></table></figure>

<p>上述命令将列出设备<code>/dev/sda</code>的分区表信息。</p>
<ol start="3">
<li>创建新的分区：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure>

<p>上述命令将打开设备<code>/dev/sdb</code>的分区表，并引导您通过一系列的交互式步骤来创建新的分区。</p>
<ol start="4">
<li>删除分区：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdc</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): d</span><br><span class="line">Partition number (1-4): 1</span><br></pre></td></tr></table></figure>

<p>上述命令将打开设备<code>/dev/sdc</code>的分区表，并提示您输入要删除的分区号。</p>
<ol start="5">
<li>更改分区类型：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdd</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1-4): 1</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list codes): 83</span><br></pre></td></tr></table></figure>

<p>上述命令将打开设备<code>/dev/sdd</code>的分区表，并提示您输入要更改的分区号和新的分区类型。</p>
<p><code>fdisk</code>命令涉及对磁盘分区进行操作，因此需要以root权限运行。请谨慎操作，以免对系统造成损害。</p>
<hr>
<h2 id="sysstat"><a href="#sysstat" class="headerlink" title="sysstat"></a>sysstat</h2><p><code>sysstat</code>是一个性能监控工具集，它提供了一系列的命令行工具，用于收集和分析系统的性能数据。这些工具可以帮助您监视系统的资源利用率、性能瓶颈和运行状况。</p>
<p><code>sysstat</code>包括以下常用命令：</p>
<ol>
<li><p><code>sar</code>：用于收集、报告和存档系统活动信息，包括CPU利用率、内存使用、磁盘IO、网络流量等。示例用法：<code>sar -u</code>显示CPU利用率，<code>sar -r</code>显示内存使用情况，<code>sar -d</code>显示磁盘IO统计。</p>
</li>
<li><p><code>iostat</code>：用于报告和存档系统磁盘IO活动的统计信息，包括每个磁盘的读写速度、IO等待时间、IO请求队列长度等。示例用法：<code>iostat -x</code>显示详细的磁盘IO统计。</p>
</li>
<li><p><code>mpstat</code>：用于报告和存档每个CPU的利用率和其他统计信息，包括用户时间、系统时间、空闲时间等。示例用法：<code>mpstat -P ALL</code>显示每个CPU的利用率。</p>
</li>
<li><p><code>pidstat</code>：用于报告和存档进程的CPU利用率、内存使用和IO统计。示例用法：<code>pidstat -p &lt;pid&gt;</code>显示特定进程的统计信息。</p>
</li>
<li><p><code>ifstat</code>：用于报告和存档网络接口的流量统计，包括接收和发送的数据量。示例用法：<code>ifstat -a</code>显示所有网络接口的流量统计。</p>
</li>
</ol>
<p>这些命令都是通过收集系统性能数据并以可读的格式进行报告。您可以根据具体需求选择适合的命令，并结合不同的选项来获取所需的性能信息。</p>
<p><code>sysstat</code>工具集在大多数Linux发行版中都可用，但需要先安装。您可以使用包管理器（如apt、yum等）来安装<code>sysstat</code>软件包。</p>
<hr>
<h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><ul>
<li>pstree,以树状图的方式展现进程之间的派生关系,显示效果比较直观</li>
<li>参数<ul>
<li><code>a</code> : 显示每个程序的完整指令,包含路径,参数或者是常驻服务的标示</li>
<li><code>c</code> : 不使用精简表示法</li>
<li><code>G</code> : 使用VT100终端机的列绘图字符</li>
<li><code>n</code> : 用程序识别码排序,预设是以程序名称来排序</li>
<li><code>p</code> : 显示程序识别码</li>
<li><code>u</code> : 显示用户名称</li>
</ul>
</li>
</ul>
<h2 id="杀死指定进程"><a href="#杀死指定进程" class="headerlink" title="杀死指定进程"></a>杀死指定进程</h2><ul>
<li><code>kill -9 process_pid</code></li>
</ul>
<h2 id="wscat-详解"><a href="#wscat-详解" class="headerlink" title="wscat 详解"></a>wscat 详解</h2><p>wscat 是一个命令行工具，用于测试和调试 WebSocket 连接。它提供了一种简单的方式来建立 WebSocket 连接并进行数据交换。以下是 wscat 命令的常用选项和用法的详解：</p>
<p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat [options] [url]</span><br></pre></td></tr></table></figure>

<p><strong>选项</strong>：</p>
<ul>
<li><code>-l, --listen</code>: 以服务器模式监听指定的地址和端口。</li>
<li><code>-c, --connect</code>: 建立 WebSocket 连接到指定的 URL。</li>
<li><code>-s, --ssl</code>: 使用 SSL 加密连接。</li>
<li><code>-k, --insecure</code>: 忽略 SSL 证书验证。</li>
<li><code>-H, --header</code>: 添加自定义的请求头。</li>
<li><code>-n, --no-check</code>: 禁用 WebSocket 协议验证。</li>
<li><code>-P, --pipe</code>: 将标准输入的数据发送到 WebSocket 连接。</li>
<li><code>-t, --timestamp</code>: 在控制台输出消息的时间戳。</li>
<li><code>--host</code>: 指定自定义的 Host 头部。</li>
</ul>
<p><strong>用法示例</strong>：</p>
<ol>
<li><p>连接到 WebSocket 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -c ws://example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接到使用 SSL 的 WebSocket 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -c wss://example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听并建立 WebSocket 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -l 8080</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听并使用 SSL 加密的 WebSocket 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -l --ssl --ssl-key key.pem --ssl-cert cert.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送消息到 WebSocket 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -c ws://example.com -P</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加自定义的请求头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wscat -c ws://example.com -H &quot;Authorization: Bearer token&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些是 wscat 命令的一些常用选项和用法示例。使用这个工具，您可以方便地测试和调试 WebSocket 服务器，发送和接收消息。</p>
<p>请注意，为了使用 wscat 工具，您需要先安装 Node.js 和 npm，然后使用以下命令安装 wscat：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g wscat</span><br><span class="line">apt install node-ws</span><br></pre></td></tr></table></figure>

<p>希望这些详解对您有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="curl-常用选项"><a href="#curl-常用选项" class="headerlink" title="curl 常用选项"></a>curl 常用选项</h2><p>curl 命令具有许多选项，可用于定制和控制请求的各个方面。以下是一些常用的 curl 命令选项：</p>
<ol>
<li><p><strong>-X, –request</strong>: 指定 HTTP 请求方法，如 GET、POST、PUT、DELETE 等。例如：<code>curl -X POST</code>.</p>
</li>
<li><p><strong>-H, –header</strong>: 添加请求头。可以使用多个 <code>-H</code> 选项添加多个请求头。例如：<code>curl -H &quot;Content-Type: application/json&quot; -H &quot;Authorization: Bearer token&quot;</code></p>
</li>
<li><p><strong>-d, –data</strong>: 指定请求的数据体（请求体）。用于发送 POST 或 PUT 请求的数据。例如：<code>curl -X POST -d &quot;username=admin&amp;password=123&quot;</code></p>
</li>
<li><p><strong>-F, –form</strong>: 以 multipart&#x2F;form-data 格式发送表单数据。用于文件上传等场景。例如：<code>curl -F &quot;file=@path/to/file&quot;</code></p>
</li>
<li><p><strong>-o, –output</strong>: 将响应保存到文件。可以指定文件名或路径。例如：<code>curl -o output.txt</code></p>
</li>
<li><p><strong>-i, –include</strong>: 在输出中包含响应头信息。例如：<code>curl -i</code></p>
</li>
<li><p><strong>-s, –silent</strong>: 静默模式，禁止显示进度信息或错误消息。例如：<code>curl -s</code></p>
</li>
<li><p><strong>-u, –user</strong>: 指定用户名和密码进行基本认证。例如：<code>curl -u username:password</code></p>
</li>
<li><p><strong>-k, –insecure</strong>: 忽略 SSL 证书验证，用于处理自签名证书等不受信任的情况。例如：<code>curl -k</code></p>
</li>
<li><p><strong>-x, –proxy</strong>: 指定代理服务器。例如：<code>curl -x http://proxy.example.com:8080</code></p>
</li>
<li><p><strong>-L, –location</strong>: 自动跟随重定向。当服务器返回重定向响应时，自动跳转到新的 URL。例如：<code>curl -L</code></p>
</li>
<li><p><strong>-c, –cookie</strong>: 指定 Cookie。发送请求时携带指定的 Cookie。例如：<code>curl -c cookies.txt</code></p>
</li>
</ol>
<p>这只是一小部分常用选项，curl 还提供了许多其他选项，如超时设置、身份验证方式、自定义请求头、代理配置等。可以通过 <code>curl --help</code> 命令或查阅 curl 的文档来获取更详细的选项说明和示例。</p>
<p>希望这些常用选项对您有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="curl-详解"><a href="#curl-详解" class="headerlink" title="curl 详解"></a>curl 详解</h2><p>curl 是一个命令行工具和库，用于在各种操作系统上进行网络数据传输。它支持多种协议，包括 HTTP、HTTPS、FTP、SMTP、POP3 等，可以执行各种网络操作，如发送请求、下载文件、上传文件等。以下是有关 curl 的详解：</p>
<ol>
<li><p><strong>发送请求</strong>：curl 可以用于发送 HTTP 请求到指定的 URL，并接收服务器的响应。它支持 GET、POST、PUT、DELETE 等常用的 HTTP 方法。</p>
</li>
<li><p><strong>参数定制</strong>：curl 提供了丰富的命令行参数，可以定制请求的各种参数，如请求头、请求体、超时时间、代理等。</p>
</li>
<li><p><strong>输出控制</strong>：curl 可以控制响应输出的格式和内容。默认情况下，它将响应输出到标准输出，但也可以将响应保存到文件或进行其他处理。</p>
</li>
<li><p><strong>文件传输</strong>：curl 可以用于上传和下载文件。通过指定适当的选项，它可以实现文件的上传和下载，支持断点续传等功能。</p>
</li>
<li><p><strong>HTTPS 支持</strong>：curl 支持通过 SSL&#x2F;TLS 加密协议进行安全的 HTTPS 请求。它能够验证服务器的证书，并支持使用客户端证书进行身份验证。</p>
</li>
<li><p><strong>认证</strong>：curl 提供了多种认证方式，如基本认证、摘要认证、Bearer Token 认证等，可以与需要身份验证的服务器进行交互。</p>
</li>
<li><p><strong>代理支持</strong>：curl 可以通过指定代理服务器来转发请求和接收响应。它支持 HTTP、HTTPS、SOCKS4 和 SOCKS5 代理。</p>
</li>
<li><p><strong>扩展性</strong>：curl 是一个功能强大且灵活的工具，还提供了丰富的 API，可以在各种编程语言中使用 curl 库进行网络操作。</p>
</li>
</ol>
<p>curl 是一个跨平台的工具，可在各种操作系统上使用，包括 Linux、macOS、Windows 等。它在命令行环境下使用简单，是开发人员进行网络调试、测试和自动化脚本编写的常用工具之一。</p>
<p>需要注意的是，curl 是一个命令行工具，它的使用方式和具体参数取决于具体的需求和场景。可以通过查阅 curl 的文档和使用示例来深入了解其更多功能和用法。</p>
<p>希望这些详解对 curl 有所帮助！如果您有更多问题，请随时提问。</p>
<h2 id="nmcli-常用选项"><a href="#nmcli-常用选项" class="headerlink" title="nmcli 常用选项"></a>nmcli 常用选项</h2><p>在 Linux 系统中，<code>nmcli</code> 是 NetworkManager 的命令行工具，用于配置和管理网络连接。下面是一些常用的 <code>nmcli</code> 命令选项：</p>
<ol>
<li><p><code>nmcli general status</code>：显示 NetworkManager 的状态信息，包括运行状态、活动连接等。</p>
</li>
<li><p><code>nmcli connection show</code>：显示当前系统上的所有网络连接的状态和详细信息。</p>
</li>
<li><p><code>nmcli connection up &lt;connection-name&gt;</code>：连接到指定名称的网络连接。</p>
</li>
<li><p><code>nmcli connection down &lt;connection-name&gt;</code>：断开指定名称的网络连接。</p>
</li>
<li><p><code>nmcli connection add type &lt;connection-type&gt; con-name &lt;connection-name&gt;</code>：添加一个新的网络连接。</p>
</li>
<li><p><code>nmcli connection modify &lt;connection-name&gt;</code>：修改现有的网络连接的配置。</p>
</li>
<li><p><code>nmcli connection delete &lt;connection-name&gt;</code>：删除指定名称的网络连接。</p>
</li>
<li><p><code>nmcli device status</code>：显示所有网络设备的状态信息，包括设备名称、连接状态等。</p>
</li>
<li><p><code>nmcli device wifi list</code>：显示可用的 Wi-Fi 网络列表。</p>
</li>
<li><p><code>nmcli device wifi connect &lt;SSID&gt; password &lt;password&gt;</code>：连接到指定的 Wi-Fi 网络，需要提供 SSID 和密码。</p>
</li>
<li><p><code>nmcli device show &lt;device-name&gt;</code>：显示指定网络设备的详细信息。</p>
</li>
<li><p><code>nmcli device disconnect &lt;device-name&gt;</code>：断开指定网络设备的连接。</p>
</li>
<li><p><code>nmcli radio wifi on</code>：打开 Wi-Fi 无线功能。</p>
</li>
<li><p><code>nmcli radio wifi off</code>：关闭 Wi-Fi 无线功能。</p>
</li>
<li><p><code>nmcli monitor</code>：启动 NetworkManager 的监视模式，实时显示网络连接状态的变化。</p>
</li>
</ol>
<p>这些是常用的 <code>nmcli</code> 命令选项，用于在 Linux 系统中配置和管理网络连接。<code>nmcli</code> 还有其他选项和命令，可以通过运行 <code>man nmcli</code> 命令在终端中查看完整的 <code>nmcli</code> 手册以获取更详细的命令说明和选项信息。</p>
<p>请注意，使用 <code>nmcli</code> 需要管理员权限（使用 <code>sudo</code>），以便对网络连接进行配置和管理。</p>
<p>希望这些信息对你有帮助！如果你有更多问题，请随时提问。</p>
<h2 id="nmcli-详解"><a href="#nmcli-详解" class="headerlink" title="nmcli 详解"></a>nmcli 详解</h2><p>在 Debian 系统中，<code>nmcli</code> 是 NetworkManager 的命令行工具，用于配置和管理网络连接。下面是一些常用的 <code>nmcli</code> 命令及其详细说明：</p>
<ol>
<li><p>显示网络连接状态和信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show</span><br></pre></td></tr></table></figure>

<p>这个命令将显示当前系统上的所有网络连接的状态和详细信息，包括连接名称、类型、设备、IP 地址等。</p>
</li>
<li><p>添加一个新的网络连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add <span class="built_in">type</span> &lt;connection-type&gt; con-name &lt;connection-name&gt; ifname &lt;interface-name&gt;</span><br></pre></td></tr></table></figure>

<p>在上述命令中，将 <code>&lt;connection-type&gt;</code> 替换为要添加的连接类型（如 ethernet、wifi、vpn 等），<code>&lt;connection-name&gt;</code> 替换为连接的名称，<code>&lt;interface-name&gt;</code> 替换为连接使用的网络接口名称。</p>
</li>
<li><p>编辑现有的网络连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection edit &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>该命令将进入一个交互式编辑模式，允许你编辑指定名称的网络连接的详细配置。你可以更改连接的属性，如 IP 设置、DNS 设置、认证方法等。</p>
</li>
<li><p>删除一个网络连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection delete &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令将删除指定名称的网络连接。</p>
</li>
<li><p>连接到一个网络：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection up &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令将连接到指定名称的网络连接。</p>
</li>
<li><p>断开一个网络连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection down &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令将断开指定名称的网络连接。</p>
</li>
</ol>
<p>以上是一些常用的 <code>nmcli</code> 命令，用于在 Debian 系统中配置和管理网络连接。<code>nmcli</code> 还有许多其他选项和命令，可以进一步探索和适应特定的网络管理需求。</p>
<p>你可以通过运行 <code>man nmcli</code> 命令在终端中查看 <code>nmcli</code> 的完整文档，以获取更详细的命令说明和选项信息。</p>
<p>请注意，使用 <code>nmcli</code> 需要管理员权限（使用 <code>sudo</code>），以便对网络连接进行配置和管理。</p>
<p>希望这些信息对你有帮助！如果你有更多问题，请随时提问。</p>
<h2 id="livemedia-utils"><a href="#livemedia-utils" class="headerlink" title="livemedia-utils"></a>livemedia-utils</h2><p>livemedia-utils 是一个Linux上的开源工具集，用于处理实时流媒体数据。它是由 LIVE555 Streaming Media 开发的，LIVE555 是一个用于流媒体的开源 C++ 库。</p>
<p>以下是关于 livemedia-utils 的一些详解：</p>
<ol>
<li><p><strong>功能</strong>：livemedia-utils 提供了一系列命令行工具，用于处理实时流媒体数据。这些工具包括流媒体服务器、流媒体客户端和其他相关实用程序。它们可用于流媒体的播放、录制、转码、传输和调试等。</p>
</li>
<li><p><strong>命令行工具</strong>：livemedia-utils 提供了多个命令行工具，其中一些重要的工具包括：</p>
<ul>
<li><strong>live555MediaServer</strong>：一个简单的流媒体服务器，可以提供实时流媒体的播放和转发功能。</li>
<li><strong>openRTSP</strong>：与上一个问题中提到的 OpenRTSP 工具类似，用于从 RTSP 服务器获取实时流媒体数据。</li>
<li><strong>testOnDemandRTSPServer</strong>：一个测试用的 RTSP 服务器，可以模拟实时流媒体的播放和控制。</li>
<li><strong>MPEG2TransportStreamIndexer</strong>：用于索引和检查 MPEG2 Transport Stream（M2TS）文件的工具。</li>
</ul>
</li>
<li><p><strong>跨平台支持</strong>：livemedia-utils 可以在多个操作系统上运行，包括 Linux、Windows、macOS 等。这使得它成为一个方便且广泛可用的工具，用于处理实时流媒体数据。</p>
</li>
<li><p><strong>开源和可定制性</strong>：livemedia-utils 是开源的，你可以查看其源代码、理解其实现细节，并对其进行定制和扩展，以满足特定需求。</p>
</li>
</ol>
<p>需要注意的是，livemedia-utils 是一个命令行工具集，适用于开发和调试实时流媒体应用程序，以及自动化脚本和批处理任务。如果你需要一个更完整的流媒体服务器或客户端，可能需要考虑其他更专业的流媒体解决方案或框架。</p>
<hr>
<h2 id="e2fsck"><a href="#e2fsck" class="headerlink" title="e2fsck"></a>e2fsck</h2><p><code>e2fsck</code>是用于检查和修复ext2、ext3和ext4文件系统中的错误的命令。下面是对<code>e2fsck</code>命令的详细解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e2fsck [选项] 设备</span><br></pre></td></tr></table></figure>

<p>其中，<code>选项</code>是一些可用的标志和参数，<code>设备</code>是要检查和修复的文件系统所在的设备或分区。</p>
<p>常用的选项包括：</p>
<ul>
<li><code>-p</code>：自动修复不需要人工干预的错误。</li>
<li><code>-y</code>：自动回答”yes”以所有问题，用于无人值守操作。</li>
<li><code>-f</code>：强制运行<code>e2fsck</code>，即使文件系统被标记为已经干净。</li>
<li><code>-c</code>：检查设备上的坏扇区，并将其添加到坏块列表中。</li>
<li><code>-n</code>：仅显示要执行的操作，而不实际执行它们。</li>
<li><code>-v</code>：显示更详细的输出，包括修复过程中的详细信息。</li>
<li><code>-b  备份文件</code>：将修复前的元数据备份到指定的文件中。</li>
</ul>
<p>除了选项之外，您还需要指定要检查和修复的文件系统所在的设备。例如，如果您要检查&#x2F;dev&#x2F;sda1上的文件系统，可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e2fsck /dev/sda1</span><br></pre></td></tr></table></figure>

<p><code>e2fsck</code>命令将会扫描文件系统并显示任何检测到的错误。如果它发现任何错误，它会提示您是否修复它们。您可以根据提示进行选择，或者使用前面提到的选项自动修复错误。</p>
<p>请注意，在运行<code>e2fsck</code>之前，建议您确保文件系统是以只读模式挂载的，以避免进一步损坏。如果您不能以只读模式挂载文件系统，最好使用其他工具或在紧急情况下考虑使用专业的数据恢复服务。</p>
<h2 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h2><p>Nano 是一个文本编辑器，常用于 Linux 和其他 Unix-like 系统。它是一个简单、易于使用的命令行编辑器，适合初学者和那些寻找基本编辑功能的用户。下面是 Nano 的一些详解：</p>
<ol>
<li><p>启动 Nano：<br>要启动 Nano 编辑器，请在终端中输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano</span><br></pre></td></tr></table></figure>
<p>如果要打开特定文件进行编辑，请在命令后加上文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>Nano 的界面：<br>Nano 编辑器的界面相对简洁。在编辑器的底部显示了一些常用的命令说明，如保存文件、退出编辑器等。使用箭头键导航光标在文本中移动。</p>
</li>
<li><p>基本操作：</p>
<ul>
<li>输入文本：在编辑器中直接键入文本即可。</li>
<li>保存文件：按下 <code>Ctrl + O</code>，然后按下 <code>Enter</code>，将文件保存到当前文件名。</li>
<li>退出编辑器：按下 <code>Ctrl + X</code>，如果文件有未保存的更改，Nano 会提示您保存或放弃更改。</li>
</ul>
</li>
<li><p>快捷键：<br>Nano 提供了一些常用的快捷键来进行各种操作：</p>
<ul>
<li><code>Ctrl + G</code>：显示帮助菜单，其中包含可用的命令列表。</li>
<li><code>Ctrl + K</code>：剪切当前行或选定的文本。</li>
<li><code>Ctrl + U</code>：粘贴剪切的文本。</li>
<li><code>Ctrl + W</code>：搜索文本。</li>
<li><code>Ctrl + \</code>：替换文本。</li>
<li><code>Ctrl + C</code>：显示当前光标位置的行号。</li>
</ul>
</li>
<li><p>配置文件：<br>Nano 的行为可以通过编辑配置文件 <code>~/.nanorc</code> 进行自定义。您可以在配置文件中定义颜色方案、键绑定和其他首选项。</p>
</li>
<li><p>其他功能：<br>Nano 提供了其他一些功能，如自动缩进、语法高亮、多文档编辑等。您可以通过命令行参数或配置文件来启用或禁用这些功能。</p>
</li>
</ol>
<p>Nano 是一个简单而实用的文本编辑器，尤其适合新手和需要基本编辑功能的用户。它的命令行界面和快捷键使得编辑文本文件变得方便快捷。</p>
<hr>
<h2 id="asan-工具-详解"><a href="#asan-工具-详解" class="headerlink" title="asan 工具 详解"></a>asan 工具 详解</h2><p>AddressSanitizer（ASan）是一种用于检测内存错误的工具，它是 LLVM 编译器工具链的一部分。ASan 主要用于检测内存越界访问、使用未初始化的内存、内存泄漏等常见的内存错误。</p>
<p>下面是 ASan 的一些主要特点和工作原理的详细解释：</p>
<ol>
<li><p>内存错误检测：ASan 在程序执行期间动态地分配和管理内存，并在每个内存块的边界添加额外的元数据。当程序访问超出分配的内存范围或使用未初始化的内存时，ASan 会检测到这些错误并生成相应的报告。</p>
</li>
<li><p>内存泄漏检测：ASan 跟踪程序中动态分配的内存，并在程序结束时检查是否有未释放的内存。如果存在内存泄漏，ASan 会生成相应的报告指示泄漏的内存块的位置。</p>
</li>
<li><p>元数据重映射：ASan 使用位图技术来存储内存元数据，以减少对内存的额外开销。这种位图会与程序的内存布局进行映射，以便快速定位错误和泄漏。</p>
</li>
<li><p>堆栈跟踪：当发生内存错误时，ASan 会捕获当前的函数调用堆栈信息，以便定位错误发生的位置。这对于调试和定位问题非常有帮助。</p>
</li>
<li><p>崩溃报告：当程序发生内存错误导致崩溃时，ASan 会生成详细的崩溃报告，其中包含了堆栈跟踪、错误类型和发生位置等信息。</p>
</li>
</ol>
<p>使用 ASan 进行内存错误检测时，需要使用支持 ASan 的编译器进行编译，并在链接时启用 ASan 的运行时库。编译和链接选项可以根据具体的编译器和工具链有所差异。</p>
<p>ASan 是一个强大的工具，可以帮助开发者在早期阶段捕获和调试内存错误，提高代码的质量和可靠性。然而，由于 ASan 需要额外的运行时开销和内存使用，对于大型项目或性能敏感的代码，可能需要在测试和生产环境中进行谨慎使用和评估。</p>
<hr>
<h2 id="asan-工具-使用-示例"><a href="#asan-工具-使用-示例" class="headerlink" title="asan 工具 使用 示例"></a>asan 工具 使用 示例</h2><p>以下是一个简单的示例，演示如何使用 AddressSanitizer（ASan）来检测和调试内存错误：</p>
<ol>
<li>编写代码文件（示例文件名为 <code>example.c</code>）：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* buffer = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line">    buffer[<span class="number">10</span>] = <span class="number">42</span>; <span class="comment">// 内存越界访问</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用编译器进行编译和链接，启用 ASan：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang -fsanitize=address -g example.c -o example</span></span><br></pre></td></tr></table></figure>

<p>或者使用 gcc 编译器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -fsanitize=address -g example.c -o example</span></span><br></pre></td></tr></table></figure>

<p>在编译过程中，我们通过添加 <code>-fsanitize=address</code> 选项来启用 ASan。</p>
<ol start="3">
<li>运行程序：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./example</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>ASan 检测到内存错误后，会生成相应的报告并打印在终端上，类似于以下内容：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==12345==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000eff0 at pc 0x0000004009b9</span><br><span class="line">READ of size 4 at 0x60200000eff0 thread T0</span><br><span class="line">    #0 0x4009b8 in main example.c:6</span><br><span class="line">    #1 0x7ffff6b4ab96 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)</span><br><span class="line">    #2 0x4008c9 in _start (/path/to/example+0x4008c9)</span><br><span class="line"></span><br><span class="line">Address 0x60200000eff0 is a wild pointer.</span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow example.c:6 in main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c047fffbe70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbe80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbe90: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbea0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbeb0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">=&gt;0x0c047fffbec0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa[04]fa</span><br><span class="line">  0x0c047fffbed0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbee0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbef0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbf00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fffbf10: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8</span><br><span class="line"></span><br><span class="line"> application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after return:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==12345==ABORTING</span><br></pre></td></tr></table></figure>

<p>报告中会提供详细的错误信息，包括错误类型、错误地址、堆栈跟踪等。在这个示例中，ASan 检测到了堆缓冲区溢出错误。</p>
<p>通过这种方式，ASan 可以帮助开发者捕获和调试内存错误，提供有用的诊断信息，以帮助修复问题和提高代码质量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_11_apt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_11_apt/" class="post-title-link" itemprop="url">linux_2_11_apt</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>apt相关命令笔记</li>
</ul>
<h2 id="linux-apt-file命令-详解"><a href="#linux-apt-file命令-详解" class="headerlink" title="linux apt-file命令 详解"></a>linux apt-file命令 详解</h2><p><code>apt-file</code> 是一个用于查询 APT 软件包中包含的文件的命令行工具。它不仅可以帮助你查找已安装软件包中的文件，还可以查找尚未安装但包含在软件包中的文件。使用 <code>apt-file</code> 可以帮助你找到特定文件属于哪个软件包。</p>
<p>以下是一些常见的 <code>apt-file</code> 命令及其说明：</p>
<ol>
<li><p><strong>安装 apt-file：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install apt-file</span><br></pre></td></tr></table></figure>
<p>在使用 <code>apt-file</code> 之前，你需要安装它。</p>
</li>
<li><p><strong>更新文件数据库：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-file update</span><br></pre></td></tr></table></figure>
<p>在查询之前，你需要先更新文件数据库，以确保它包含最新的信息。</p>
</li>
<li><p><strong>搜索已安装软件包中的文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-file list 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令列出指定已安装软件包中包含的文件。</p>
</li>
<li><p><strong>搜索未安装软件包中的文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-file search 文件名</span><br></pre></td></tr></table></figure>
<p>该命令搜索未安装软件包中包含指定文件名的软件包。</p>
</li>
<li><p><strong>显示与正则表达式匹配的所有软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-file search --regexp <span class="string">&#x27;正则表达式&#x27;</span></span><br></pre></td></tr></table></figure>
<p>该命令显示与指定正则表达式匹配的所有软件包。</p>
</li>
<li><p><strong>查找包含某个目录的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-file search /path/to/directory</span><br></pre></td></tr></table></figure>
<p>该命令搜索包含指定目录的软件包。</p>
</li>
<li><p><strong>显示文件属于哪个软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-file search --package-only 文件名</span><br></pre></td></tr></table></figure>
<p>该命令仅显示包含指定文件名的软件包。</p>
</li>
<li><p><strong>在所有已知软件包中搜索文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-file search --all 文件名</span><br></pre></td></tr></table></figure>
<p>该命令在所有已知的软件包中搜索指定文件名，包括未安装的软件包。</p>
</li>
</ol>
<p>使用 <code>apt-file</code> 可以方便地查找软件包中的文件，这对于理解系统中的文件属于哪个软件包、找出软件包提供的特定文件等非常有用。</p>
<h2 id="linux-apt-cache命令-详解"><a href="#linux-apt-cache命令-详解" class="headerlink" title="linux apt-cache命令 详解"></a>linux apt-cache命令 详解</h2><p><code>apt-cache</code> 是 Linux 中用于查询 APT (Advanced Package Tool) 缓存的命令行工具。它允许用户从本地软件包数据库中检索有关软件包的信息，包括依赖关系、版本、描述等。</p>
<p>以下是一些常见的 <code>apt-cache</code> 命令及其说明：</p>
<ol>
<li><p><strong>查看软件包信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache show 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令显示有关指定软件包的详细信息，包括版本、大小、依赖关系、描述等。</p>
</li>
<li><p><strong>搜索软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search 关键词</span><br></pre></td></tr></table></figure>
<p>通过该命令可以搜索软件包。它会列出所有与指定关键词相关的软件包。</p>
</li>
<li><p><strong>显示软件包提供的文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache showpkg 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示软件包提供的文件列表，以及该软件包所依赖的其他软件包。</p>
</li>
<li><p><strong>显示软件包的依赖关系：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache depends 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示指定软件包的依赖关系。</p>
</li>
<li><p><strong>显示软件包的反向依赖关系（被哪些软件包依赖）：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache rdepends 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示指定软件包的反向依赖关系，即依赖于该软件包的其他软件包。</p>
</li>
<li><p><strong>显示 APT 缓存统计信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache stats</span><br></pre></td></tr></table></figure>
<p>该命令用于显示有关 APT 缓存的统计信息，包括软件包的数量、大小等。</p>
</li>
<li><p><strong>显示软件包的提供者信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache showpkg -a 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令显示软件包在不同体系结构上的提供者信息。</p>
</li>
<li><p><strong>显示软件包的正则表达式匹配信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache showpkg --names-only <span class="string">&#x27;正则表达式&#x27;</span></span><br></pre></td></tr></table></figure>
<p>该命令显示与指定正则表达式匹配的软件包名称。</p>
</li>
</ol>
<p>以上是一些常见的 <code>apt-cache</code> 命令。这些命令可以帮助你更好地了解软件包的信息和相互关系。</p>
<h2 id="linux-apt-apt-get"><a href="#linux-apt-apt-get" class="headerlink" title="linux apt apt-get"></a>linux apt apt-get</h2><p><code>apt</code> 和 <code>apt-get</code> 是 Linux 系统中用于管理软件包的两个命令，它们都属于 Advanced Package Tool（APT）工具集。</p>
<ol>
<li><p><strong>apt-get:</strong></p>
<ul>
<li><code>apt-get</code> 是较早的软件包管理命令，用于安装、卸载、更新和管理软件包。它使用比较直接的命令语法，如 <code>apt-get install</code>、<code>apt-get remove</code> 等。</li>
<li>示例：安装一个软件包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install 软件包名称</span><br></pre></td></tr></table></figure></li>
<li><code>apt-get</code> 在操作时需要使用 <code>sudo</code> 以管理员权限执行。</li>
</ul>
</li>
<li><p><strong>apt:</strong></p>
<ul>
<li><code>apt</code> 是 <code>apt-get</code> 的新一代包装，提供了更简洁、友好的命令行接口，并且支持逐步更新。它整合了一些常用的 <code>apt-get</code> 子命令，使得用户在使用时更为方便。</li>
<li>示例：安装一个软件包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install 软件包名称</span><br></pre></td></tr></table></figure></li>
<li><code>apt</code> 使用时同样需要 <code>sudo</code> 权限。</li>
</ul>
</li>
</ol>
<p>一些使用 <code>apt</code> 相对于 <code>apt-get</code> 的优点包括：</p>
<ul>
<li>更友好的输出和进度条。</li>
<li>能够显示可用的自动修复指令。</li>
<li>与 <code>apt</code> 命令一起使用的时候，不需要再运行 <code>apt-get update</code> 命令。</li>
</ul>
<p>两者的基本功能是相似的，但 <code>apt</code> 提供了更为现代和用户友好的界面。在新的 Ubuntu 版本中，推荐使用 <code>apt</code> 命令。在老的系统或某些特殊情况下，你可能会看到人们仍然使用 <code>apt-get</code>。</p>
<h2 id="linux-apt命令-详解"><a href="#linux-apt命令-详解" class="headerlink" title="linux apt命令 详解"></a>linux apt命令 详解</h2><p><code>apt</code>（Advanced Package Tool）是用于在Debian及其衍生发行版（如Ubuntu）中进行软件包管理的工具。它提供了一组命令，用于搜索、安装、卸载、更新和管理软件包。以下是一些常用的<code>apt</code>命令及其说明：</p>
<ol>
<li><p><strong>更新软件包列表：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure>
<p>该命令用于从软件源服务器更新本地软件包列表，以获取最新的软件包信息。在执行其他<code>apt</code>命令之前，通常应该首先运行此命令。</p>
</li>
<li><p><strong>升级已安装的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br></pre></td></tr></table></figure>
<p>该命令用于升级已安装的所有软件包到最新可用的版本。在执行升级操作之前，建议先运行<code>apt update</code>以确保软件包列表是最新的。</p>
</li>
<li><p><strong>升级系统：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt dist-upgrade</span><br></pre></td></tr></table></figure>
<p>该命令用于执行更大规模的系统升级，包括新内核的安装等。它会比<code>apt upgrade</code>更积极地解决依赖关系。</p>
</li>
<li><p><strong>安装软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于安装指定软件包。你可以同时安装多个软件包，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install 软件包1 软件包2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>卸载软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt remove 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于卸载指定软件包，但保留其配置文件。如果你希望同时删除配置文件，可以使用<code>purge</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt purge 软件包名称</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>搜索软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search 关键词</span><br></pre></td></tr></table></figure>
<p>该命令用于搜索与指定关键词相关的软件包。</p>
</li>
<li><p><strong>显示软件包信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt show 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示有关指定软件包的详细信息，包括版本、大小、依赖关系等。</p>
</li>
<li><p><strong>清理无用的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt autoremove</span><br></pre></td></tr></table></figure>
<p>该命令用于删除已安装但不再需要的软件包。</p>
</li>
</ol>
<p>这些是一些<code>apt</code>命令的常见用法。你可以使用<code>man apt</code>查看<code>apt</code>的手册以获取更详细的信息。</p>
<h2 id="linux-apt命令-常用技巧"><a href="#linux-apt命令-常用技巧" class="headerlink" title="linux apt命令 常用技巧"></a>linux apt命令 常用技巧</h2><p>在使用<code>apt</code>命令时，有一些常用的技巧和实用的选项，可以提高软件包管理的效率。以下是一些常见的技巧：</p>
<ol>
<li><p><strong>查看软件包信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt show 软件包名称</span><br></pre></td></tr></table></figure>
<p>可以使用该命令查看软件包的详细信息，包括版本、大小、依赖关系等。</p>
</li>
<li><p><strong>查找软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search 关键词</span><br></pre></td></tr></table></figure>
<p>通过该命令可以搜索软件包。可以根据关键词查找与之相关的软件包。</p>
</li>
<li><p><strong>模糊搜索：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt list | grep 关键词</span><br></pre></td></tr></table></figure>
<p>使用<code>apt list</code>列出所有可用软件包，然后通过<code>grep</code>进行模糊搜索。</p>
</li>
<li><p><strong>列出已安装的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt list --installed</span><br></pre></td></tr></table></figure>
<p>该命令列出所有已经安装的软件包。</p>
</li>
<li><p><strong>列出可升级的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt list --upgradeable</span><br></pre></td></tr></table></figure>
<p>该命令列出可以升级的所有软件包。</p>
</li>
<li><p><strong>查看软件包依赖关系：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt depends 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于查看指定软件包的依赖关系。</p>
</li>
<li><p><strong>查看软件包提供的文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L 软件包名称</span><br></pre></td></tr></table></figure>
<p>使用<code>dpkg</code>命令查看指定软件包提供的文件列表。</p>
</li>
<li><p><strong>使用代理服务器：</strong><br>如果你在使用代理服务器，可以在<code>/etc/apt/apt.conf</code>中设置代理配置，或者在命令行中使用<code>-o</code>选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt -o Acquire::http::Proxy=<span class="string">&quot;http://代理地址&quot;</span> update</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用多线程下载：</strong><br>在更新软件包时，可以使用多线程进行下载以提高速度。在<code>/etc/apt/apt.conf</code>中添加以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Acquire::http::Pipeline-Depth &quot;0&quot;;</span><br><span class="line">Acquire::http::No-Cache &quot;true&quot;;</span><br><span class="line">Acquire::http::Dl-Limit &quot;256&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用国内镜像：</strong><br>将系统的软件源替换为国内镜像源可以加快下载速度。在<code>/etc/apt/sources.list</code>中修改软件源，将其替换为适合你的国内源。</p>
</li>
</ol>
<p>这些技巧可以让你更方便、更高效地使用<code>apt</code>命令进行软件包管理。根据个人需要，你可以结合这些技巧执行不同的操作。</p>
<h2 id="apt-家族"><a href="#apt-家族" class="headerlink" title="apt 家族"></a>apt 家族</h2><h3 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h3><ul>
<li><p>update</p>
<ul>
<li>从所有配置的源中下载包信息。其他的命令对这些数据进行操作</li>
</ul>
</li>
<li><p>upgrade</p>
<ul>
<li>upgrade 用于安装当前安装在系统上的所有软件包的可用升级，这些软件包来自于 sources.list(5) 配置的源的升级</li>
<li>如果有需要满足的依赖关系，新的安装包将会被安装。但是现有的安装包永远都不会被删除。如果一个软件包的升级需要删除一个已安装的软件包，那么这个软件包的升级将不会被执行</li>
</ul>
</li>
<li><p>full-upgrade</p>
<ul>
<li>full-upgrade执行升级的功能，但如果需要升级系统，它将删除当前安装的软件包，如果需要这样做来升级整个系统的话。</li>
</ul>
</li>
<li><p>install, remove, purge</p>
<ul>
<li>install, 安装软件包</li>
<li>remove, 仅删除软件包数据，会留下用户配置信息</li>
<li>purge, 会既删除软件包数据，也会删除用户配置信息</li>
</ul>
</li>
<li><p>autoremove</p>
<ul>
<li>autoremove是用来删除那些自动安装的软件包，以满足依赖的软件包，但现在不再需要了，因为依赖关系改变了或需要它们的软件包在这期间被删除，因此不再需要。</li>
</ul>
</li>
<li><p>search</p>
<ul>
<li>搜索可以用来在可用的软件包列表中搜索给定包的列表中搜索，并显示匹配结果。</li>
</ul>
</li>
<li><p>show</p>
<ul>
<li>显示有关给定软件包的信息，包括它的依赖性、安装和下载大小、软件包的可用来源以及对它的描述和下载大小，软件包的可用来源，软件包内容的描述等等。包的内容描述等等。</li>
</ul>
</li>
<li><p>list</p>
<ul>
<li>list与dpkg-query –list有点类似，它可以显示满足特定条件的满足特定条件的软件包列表。</li>
</ul>
</li>
<li><p>edit-sources</p>
<ul>
<li>edit-sources 可以让你在你喜欢的文本编辑器中编辑 sources.list(5) 文件。同时也提供基本的智能检查。</li>
</ul>
</li>
</ul>
<h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h3><ul>
<li><p>update</p>
</li>
<li><p>upgrade</p>
</li>
<li><p>dist-upgrade</p>
<ul>
<li>dist-upgrade除了执行升级的功能外，还能智能地处理新版本软件包的依赖关系变化；apt-get有一个 “智能 “的冲突解决系统，它将尝试升级最重要的软件包如果有必要的话，它会尝试升级最重要的软件包，而牺牲掉不那么重要的软件包。</li>
</ul>
</li>
<li><p>dselect-upgrade</p>
<ul>
<li>dselect-upgrade与传统的Debian packaging前端，即 dselect(1)。</li>
</ul>
</li>
<li><p>install</p>
</li>
<li><p>remove</p>
</li>
<li><p>purge</p>
</li>
<li><p>source </p>
<ul>
<li>获取源码包</li>
</ul>
</li>
<li><p>build-dep</p>
<ul>
<li>build-dep 导致 apt-get 安装&#x2F;移除软件包，以满足一个源代码软件包的构建的依赖性。</li>
</ul>
</li>
<li><p>check</p>
<ul>
<li>检查是一个诊断工具；它更新软件包缓存并检查损坏的依赖关系。</li>
</ul>
</li>
<li><p>download</p>
<ul>
<li>download将下载给定的二进制包到当前目录。</li>
</ul>
</li>
<li><p>clean</p>
<ul>
<li>清理本地存储库中检索到的软件包文件。它删除了除锁文件外的所有文件都从 &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F; 和&#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;partial&#x2F;。</li>
</ul>
</li>
<li><p>autoclean</p>
<ul>
<li>和clean一样，autoclean也会清除本地仓库中检索到的软件包文件。不同的是不同的是，它只删除那些不能再被下载的软件包文件，并且基本上是无用的。</li>
</ul>
</li>
<li><p>changelog</p>
<ul>
<li>changelog试图下载一个软件包的更新日志并通过sensible-pager。</li>
</ul>
</li>
<li><p>indextargets</p>
<ul>
<li>默认情况下，显示一个deb822格式的所有数据文件的信息列表(又称索引目标) apt-get update 会下载。</li>
</ul>
</li>
</ul>
<h3 id="apt-cache"><a href="#apt-cache" class="headerlink" title="apt-cache"></a>apt-cache</h3><p>在Linux中，<code>apt-cache</code>是一个用于查询APT（Advanced Package Tool）软件包管理器缓存的命令行工具。它允许您查看已安装软件包和可用软件包的详细信息，以及搜索软件包的相关信息。</p>
<p>下面是一些常见的<code>apt-cache</code>命令选项和用法：</p>
<ol>
<li><p>查询软件包信息：</p>
<ul>
<li><code>apt-cache show &lt;package&gt;</code>：显示指定软件包的详细信息，包括版本、描述、作者、依赖关系等。</li>
<li><code>apt-cache showpkg &lt;package&gt;</code>：显示软件包的包信息以及其相关的依赖关系和依赖它的软件包信息。</li>
</ul>
</li>
<li><p>搜索软件包：</p>
<ul>
<li><code>apt-cache search &lt;pattern&gt;</code>：根据模式搜索可用的软件包。模式可以是软件包名称、关键字或描述的一部分。</li>
<li><code>apt-cache search &lt;keyword1&gt; &lt;keyword2&gt;</code>：根据多个关键字搜索软件包。这将返回同时包含这些关键字的软件包。</li>
<li><code>apt-cache search --names-only &lt;pattern&gt;</code>：只搜索软件包的名称而不搜索描述或关键字。</li>
</ul>
</li>
<li><p>显示依赖关系：</p>
<ul>
<li><code>apt-cache depends &lt;package&gt;</code>：显示指定软件包的依赖关系，包括它所依赖的软件包和被它所依赖的软件包。</li>
<li><code>apt-cache rdepends &lt;package&gt;</code>：显示依赖于指定软件包的其他软件包。</li>
</ul>
</li>
<li><p>清除软件包缓存：</p>
<ul>
<li><code>apt-cache clean</code>：清除APT软件包管理器的本地软件包缓存。这将删除已下载的软件包文件，但不会删除已安装的软件包。</li>
</ul>
</li>
</ol>
<p>这些是<code>apt-cache</code>命令的一些常见选项和用法。您可以使用<code>apt-cache</code>命令来获取关于软件包的信息、搜索软件包以及查看软件包的依赖关系。在使用这些命令时，请确保以管理员权限运行，例如使用<code>sudo</code>命令。</p>
<h3 id="apt-file"><a href="#apt-file" class="headerlink" title="apt-file"></a>apt-file</h3><ul>
<li>查找包文件<ul>
<li><code>apt-file find libopenssh.so</code></li>
</ul>
</li>
</ul>
<p>在Linux中，<code>apt-file</code>是一个用于查询软件包文件的命令行工具。它可以帮助您查找特定文件属于哪个软件包，并可以搜索软件包中的文件。</p>
<p>以下是一些常见的<code>apt-file</code>命令选项和用法：</p>
<ol>
<li><p>初始化数据库：<br>在第一次使用<code>apt-file</code>之前，需要初始化文件数据库。使用以下命令进行初始化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-file update</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询文件所属的软件包：</p>
<ul>
<li><code>apt-file search &lt;filename&gt;</code>：查询指定文件所属的软件包。文件名可以是绝对路径或相对路径。</li>
<li>例如：<code>apt-file search /bin/ls</code>将返回包含<code>/bin/ls</code>的软件包。</li>
</ul>
</li>
<li><p>列出软件包中的文件：</p>
<ul>
<li><code>apt-file list &lt;package&gt;</code>：列出指定软件包中的所有文件。</li>
<li>例如：<code>apt-file list coreutils</code>将列出<code>coreutils</code>软件包中的所有文件。</li>
</ul>
</li>
<li><p>搜索文件名：</p>
<ul>
<li><code>apt-file search &lt;pattern&gt;</code>：根据模式搜索文件名。模式可以是文件名的一部分或关键字。</li>
<li>例如：<code>apt-file search libstdc++.so</code>将返回包含<code>libstdc++.so</code>的软件包。</li>
</ul>
</li>
</ol>
<p>请注意，<code>apt-file</code>命令需要根据您的系统安装软件包文件的索引数据库。因此，在使用<code>apt-file</code>之前，需要确保数据库已经初始化并更新。您可以使用<code>sudo apt-file update</code>命令来更新数据库。</p>
<p>使用<code>apt-file</code>命令可以帮助您轻松地查找软件包文件和软件包中的文件。这对于解决缺少文件或查找特定文件所属的软件包非常有用。</p>
<h3 id="apt-mark"><a href="#apt-mark" class="headerlink" title="apt-mark"></a>apt-mark</h3><p>在Linux中，<code>apt-mark</code>是一个用于标记和操作APT软件包状态的命令行工具。它可以用于设置、清除和查询软件包的各种标记，以及管理软件包的状态。</p>
<p>以下是一些常见的<code>apt-mark</code>命令选项和用法：</p>
<ol>
<li><p>标记软件包状态：</p>
<ul>
<li><code>apt-mark hold &lt;package&gt;</code>：将指定软件包标记为”hold”状态，阻止其被升级或删除。</li>
<li><code>apt-mark unhold &lt;package&gt;</code>：取消指定软件包的”hold”标记。</li>
</ul>
</li>
<li><p>设置软件包自动安装状态：</p>
<ul>
<li><code>apt-mark auto &lt;package&gt;</code>：将指定软件包标记为”auto”状态，允许APT自动安装和升级。</li>
<li><code>apt-mark manual &lt;package&gt;</code>：将指定软件包标记为”manual”状态，阻止APT自动安装和升级。</li>
</ul>
</li>
<li><p>查询软件包状态：</p>
<ul>
<li><code>apt-mark showhold</code>：显示所有被标记为”hold”状态的软件包。</li>
<li><code>apt-mark showauto</code>：显示所有被标记为”auto”状态的软件包。</li>
</ul>
</li>
<li><p>清除软件包状态：</p>
<ul>
<li><code>apt-mark unmarkauto &lt;package&gt;</code>：取消指定软件包的”auto”标记。</li>
<li><code>apt-mark unmarkhold &lt;package&gt;</code>：取消指定软件包的”hold”标记。</li>
<li><code>apt-mark unmarkall</code>：清除所有软件包的标记。</li>
</ul>
</li>
</ol>
<p>这些是<code>apt-mark</code>命令的一些常见选项和用法。您可以使用<code>apt-mark</code>命令来设置软件包的状态标记，以控制APT软件包管理器的行为。这对于防止软件包被升级或删除、手动管理软件包状态以及自定义软件包安装行为非常有用。请注意，在使用这些命令时，需要以管理员权限运行，例如使用<code>sudo</code>命令。</p>
<h2 id="aptitude"><a href="#aptitude" class="headerlink" title="aptitude"></a>aptitude</h2><p><code>aptitude</code>是Linux系统中的一个交互式软件包管理器，用于安装、升级、删除和管理软件包。它提供了一个用户友好的命令行界面，可以方便地浏览、搜索和操作软件包。</p>
<p>下面是一些常见的<code>aptitude</code>命令选项和用法：</p>
<ol>
<li><p>浏览软件包列表：</p>
<ul>
<li><code>aptitude</code>：启动<code>aptitude</code>界面，显示可用软件包列表。</li>
<li>使用箭头键或快捷键浏览软件包列表。</li>
<li>输入软件包名或关键字进行搜索。</li>
</ul>
</li>
<li><p>安装和卸载软件包：</p>
<ul>
<li>使用<code>+</code>号标记软件包以进行安装。</li>
<li>使用<code>-</code>号标记软件包以进行卸载。</li>
<li>按下<code>g</code>键执行所有标记的操作。</li>
</ul>
</li>
<li><p>查看软件包详细信息：</p>
<ul>
<li>在软件包列表中选中一个软件包，按下<code>Enter</code>键以查看详细信息。</li>
<li>显示软件包的描述、版本、依赖关系和其他相关信息。</li>
</ul>
</li>
<li><p>搜索软件包：</p>
<ul>
<li>按下<code>/</code>键进行搜索，然后输入要搜索的软件包名称或关键字。</li>
<li>使用箭头键浏览搜索结果。</li>
</ul>
</li>
<li><p>进阶命令：</p>
<ul>
<li><code>aptitude update</code>：更新软件包列表。</li>
<li><code>aptitude upgrade</code>：升级可用的软件包。</li>
<li><code>aptitude dist-upgrade</code>：执行发行版升级，包括软件包和系统组件的升级。</li>
<li><code>aptitude clean</code>：清理软件包缓存。</li>
<li><code>aptitude autoclean</code>：清理旧版本的软件包。</li>
</ul>
</li>
</ol>
<p>请注意，<code>aptitude</code>命令提供了更多功能和选项，可以根据您的需求进行更高级的软件包管理操作。在使用<code>aptitude</code>时，请仔细阅读相关文档和手册，以了解更多命令和选项的详细信息。</p>
<p>总体而言，<code>aptitude</code>是一个功能强大且易于使用的软件包管理器，提供了交互式的方式来管理和控制Linux系统上的软件包。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_12_dpkg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_12_dpkg/" class="post-title-link" itemprop="url">linux_2_12_dpkg</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>dpkg命令</li>
</ul>
<h2 id="linux-dpkg命令-详解"><a href="#linux-dpkg命令-详解" class="headerlink" title="linux dpkg命令 详解"></a>linux dpkg命令 详解</h2><p><code>dpkg</code> 是 Debian 系统中用于管理软件包的基础工具。它直接处理软件包的安装、配置和卸载，不像更高级的工具（例如 <code>apt</code>）会处理软件包的依赖关系。以下是一些常见的 <code>dpkg</code> 命令及其说明：</p>
<ol>
<li><p><strong>安装软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -i 软件包文件.deb</span><br></pre></td></tr></table></figure>
<p>该命令用于安装指定的 <code>.deb</code> 格式的软件包。</p>
</li>
<li><p><strong>卸载软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -r 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于卸载已安装的软件包，但保留其配置文件。</p>
</li>
<li><p><strong>卸载软件包并删除配置文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -P 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于卸载已安装的软件包，并删除其配置文件。</p>
</li>
<li><p><strong>查询软件包信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于列出已安装软件包的信息，包括软件包的状态、版本等。</p>
</li>
<li><p><strong>查询已安装的文件所属的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S /path/to/file</span><br></pre></td></tr></table></figure>
<p>该命令用于查找指定文件所属的已安装软件包。</p>
</li>
<li><p><strong>显示软件包的详细信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -p 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示指定软件包的详细信息，包括版本、描述、依赖关系等。</p>
</li>
<li><p><strong>重新配置软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg-reconfigure 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于重新配置已安装软件包，可以修改软件包的配置参数。</p>
</li>
<li><p><strong>检查软件包的完整性：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --verify</span><br></pre></td></tr></table></figure>
<p>该命令用于检查系统上已安装软件包的完整性，以确保文件未被修改。</p>
</li>
<li><p><strong>查看软件包的配置文件状态：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-query -W -f=<span class="string">&#x27;$&#123;Conffiles&#125;\n&#x27;</span> 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示软件包的配置文件状态。</p>
</li>
</ol>
<p>这些是一些常见的 <code>dpkg</code> 命令。请注意，<code>dpkg</code> 直接操作软件包而不考虑依赖关系，因此在处理软件包时要小心，以免引起依赖问题。在实际使用中，更推荐使用高级包管理工具如 <code>apt</code> 或 <code>apt-get</code>，它们能够更好地处理依赖关系。</p>
<h2 id="linux-dpkg命令-常用技巧"><a href="#linux-dpkg命令-常用技巧" class="headerlink" title="linux dpkg命令 常用技巧"></a>linux dpkg命令 常用技巧</h2><p>以下是一些在使用 <code>dpkg</code> 命令时常用的技巧：</p>
<ol>
<li><p><strong>查看系统上已安装的软件包列表：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l</span><br></pre></td></tr></table></figure>
<p>这会列出系统上所有已安装的软件包，包括软件包的状态、版本和简短描述。</p>
</li>
<li><p><strong>过滤和搜索已安装的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep 关键词</span><br></pre></td></tr></table></figure>
<p>使用 <code>grep</code> 过滤已安装软件包列表，以查找包含特定关键词的软件包。</p>
</li>
<li><p><strong>查找文件所属的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S /path/to/file</span><br></pre></td></tr></table></figure>
<p>该命令用于查找指定文件所属的已安装软件包。</p>
</li>
<li><p><strong>查看软件包的详细信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -p 软件包名称</span><br></pre></td></tr></table></figure>
<p>通过这个命令，你可以查看指定软件包的详细信息，包括版本、描述、依赖关系等。</p>
</li>
<li><p><strong>查看软件包的配置文件状态：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-query -W -f=<span class="string">&#x27;$&#123;Conffiles&#125;\n&#x27;</span> 软件包名称</span><br></pre></td></tr></table></figure>
<p>该命令用于显示软件包的配置文件状态。</p>
</li>
<li><p><strong>重新配置已安装的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg-reconfigure 软件包名称</span><br></pre></td></tr></table></figure>
<p>使用这个命令可以重新配置已安装的软件包，通常用于修改软件包的配置参数。</p>
</li>
<li><p><strong>检查软件包的完整性：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg --verify</span><br></pre></td></tr></table></figure>
<p>该命令用于检查系统上已安装软件包的完整性，以确保文件未被修改。</p>
</li>
<li><p><strong>清理未完全安装或删除的软件包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -l | grep ^rc | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">sudo</span> dpkg --purge</span><br></pre></td></tr></table></figure>
<p>这个命令可以清理掉系统中未完全安装或删除的软件包。</p>
</li>
</ol>
<p>请注意，使用 <code>dpkg</code> 命令需要小心，因为它不会自动处理软件包的依赖关系。在处理软件包时，建议使用更高级的包管理工具如 <code>apt</code> 或 <code>apt-get</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_16_more/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_16_more/" class="post-title-link" itemprop="url">linux_2_16_more</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>more命令</li>
</ul>
<h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><ul>
<li>more, 一次显示一页</li>
</ul>
<p>在Linux中，<code>more</code>命令用于逐页显示文本文件的内容。它允许您按页浏览文本文件，以便更好地查看和阅读长篇文本。</p>
<p>以下是<code>more</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [options] [file]</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code>是可选的一些选项，<code>file</code>是要显示的文本文件。</p>
<p>以下是一些常见的<code>more</code>命令选项和用法：</p>
<ol>
<li><p>逐页显示文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将按一页一页地显示<code>file.txt</code>文件的内容。您可以使用空格键向下翻页，按<code>q</code>键退出。</p>
</li>
<li><p>显示行号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more -n file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将在每一行前显示行号。</p>
</li>
<li><p>显示百分比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more -p file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将在屏幕底部显示当前显示内容相对于整个文件的百分比。</p>
</li>
<li><p>搜索文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more -s file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将禁止滚屏显示，只显示与搜索模式匹配的行。</p>
</li>
<li><p>跳转到指定行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more +10 file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将从第10行开始显示文件内容。</p>
</li>
</ol>
<p>请注意，<code>more</code>命令仅支持向前翻页，无法向后翻页。如果您需要更强大和灵活的文本查看工具，可以考虑使用<code>less</code>命令，它提供了更多功能，如向前翻页、向后翻页、搜索等。</p>
<p>这些是<code>more</code>命令的一些常见选项和用法。您可以根据需要选择适合的选项来浏览和查看文本文件的内容。</p>
<h2 id="linux-more命令-详解"><a href="#linux-more命令-详解" class="headerlink" title="linux more命令 详解"></a>linux more命令 详解</h2><p><code>more</code> 命令用于在终端逐页显示文本文件的内容。它允许用户逐页查看文件内容，提供一种按需加载的方式，使用户可以方便地浏览大型文本文件。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [选项] 文件名</span><br></pre></td></tr></table></figure>

<p><code>more</code> 命令的一些常见选项和用法：</p>
<ol>
<li><strong>空格键：</strong> 显示下一页。</li>
<li><strong>Enter 键：</strong> 显示下一行。</li>
<li><strong>q 键：</strong> 退出 <code>more</code>。</li>
<li><strong>&#x2F; 搜索字符串：</strong> 在文本中搜索指定字符串。</li>
<li><strong>n 键：</strong> 跳到下一次出现搜索字符串的位置。</li>
<li><strong>b 键：</strong> 返回到上一页。</li>
<li><strong>:f：</strong> 显示当前文件名和行号。</li>
<li><strong>:n：</strong> 切换行号显示。</li>
<li><strong>v 键：</strong> 使用系统默认编辑器（如 <code>vi</code>）打开文件进行编辑。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more example.txt</span><br></pre></td></tr></table></figure>

<p><code>more</code> 命令按页显示 <code>example.txt</code> 文件的内容，允许用户逐页查看文本文件。</p>
<p><strong>注意：</strong> <code>more</code> 命令是一个相对简单的分页查看工具。在实际使用中，可能会使用更强大的分页工具，如 <code>less</code>，它提供了更多的交互性和搜索功能。</p>
<p>如果你想要查看更多 <code>more</code> 命令的选项和功能，你可以查阅 <code>man more</code> 或 <code>more --help</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_14_trap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_14_trap/" class="post-title-link" itemprop="url">linux_2_14_trap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>trap命令</li>
</ul>
<h2 id="trap-信号"><a href="#trap-信号" class="headerlink" title="trap 信号"></a>trap 信号</h2><h3 id="1-1-简单使用"><a href="#1-1-简单使用" class="headerlink" title="1.1 简单使用"></a>1.1 简单使用</h3><ul>
<li><p>trap命令，用于指定在接收到信号后将要采取的动作。常见的用途是在脚本程序被中断时完成清理工作。</p>
</li>
<li><p>历史上，shell总是用数字来代表信号，而新的脚本程序应该使用信号的名字，它们保存在用<code>#include</code>命令包含进来的<code>signal.h</code>头文件中，在使用信号名时需要省略<code>SIG</code>前缀</p>
</li>
<li><p>kill和trap等都可以看到信号编号及其关联的名称。“信号”是指那些被异步发送到一个程序的事件。默认情况下，它们通常会终止一个程序的运行。</p>
</li>
<li><p>查看所有信号的：</p>
<ul>
<li><code>trap -l</code></li>
</ul>
</li>
</ul>
<h3 id="1-2-trap的使用"><a href="#1-2-trap的使用" class="headerlink" title="1.2 trap的使用"></a>1.2 trap的使用</h3><ul>
<li>trap命令的参数分为两部分，前一部分是接收到指定信号时将要采取的行动，后一部分是要处理的信号名。<ul>
<li><code>trap command signal</code></li>
</ul>
</li>
</ul>
<h2 id="linux-trap命令-详解"><a href="#linux-trap命令-详解" class="headerlink" title="linux trap命令 详解"></a>linux trap命令 详解</h2><p><code>trap</code> 命令在 Linux 和其他类 Unix 操作系统中用于捕获和处理信号。信号是一种在 Unix 系统中用于通知进程发生了某个事件的机制。<code>trap</code> 命令允许你为脚本或命令设置对信号的处理方式。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> [命令] [信号]</span><br></pre></td></tr></table></figure>

<p><strong>常见用法：</strong></p>
<ol>
<li><p><strong>设置捕获信号的动作：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;命令&quot;</span> 信号</span><br></pre></td></tr></table></figure>
<p>例如，以下命令设置在收到 <code>SIGINT</code> 信号时执行 <code>echo &quot;Caught interrupt signal&quot;</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27;Caught interrupt signal&#x27;&quot;</span> SIGINT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>禁用信号的默认行为：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;&quot;</span> 信号</span><br></pre></td></tr></table></figure>
<p>例如，以下命令禁用 <code>SIGINT</code> 信号的默认行为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;&quot;</span> SIGINT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>恢复信号的默认行为：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> - 信号</span><br></pre></td></tr></table></figure>
<p>例如，以下命令恢复 <code>SIGINT</code> 信号的默认行为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> - SIGINT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>捕获多个信号：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;命令&quot;</span> 信号1 信号2 ...</span><br></pre></td></tr></table></figure>
<p>例如，以下命令设置在收到 <code>SIGINT</code> 或 <code>SIGTERM</code> 信号时执行 <code>echo &quot;Caught interrupt or termination signal&quot;</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27;Caught interrupt or termination signal&#x27;&quot;</span> SIGINT SIGTERM</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置捕获 Ctrl+C 信号</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27;Caught interrupt signal&#x27;&quot;</span> SIGINT</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running script...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟一个长时间运行的任务</span></span><br><span class="line"><span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Script completed.&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上述脚本中，当用户按下 <code>Ctrl+C</code> 时，<code>trap</code> 命令将捕获 <code>SIGINT</code> 信号并执行指定的命令，这里是输出 “Caught interrupt signal”。</p>
<p><code>trap</code> 命令通常用于确保在脚本执行期间捕获特定信号时执行某些操作，例如清理资源或执行特定的处理程序。</p>
<h2 id="linux-trap命令-常用技巧"><a href="#linux-trap命令-常用技巧" class="headerlink" title="linux trap命令 常用技巧"></a>linux trap命令 常用技巧</h2><p><code>trap</code> 命令在脚本编写中可以用于处理信号，以下是一些 <code>trap</code> 命令的常用技巧：</p>
<ol>
<li><p><strong>捕获并忽略信号：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;&quot;</span> 信号</span><br></pre></td></tr></table></figure>
<p>通过将空字符串指定为命令，可以捕获并忽略特定信号的默认动作。例如，以下命令会忽略 <code>SIGTERM</code> 信号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;&quot;</span> SIGTERM</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>处理脚本终止信号：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;cleanup_function&quot;</span> EXIT</span><br></pre></td></tr></table></figure>
<p>在脚本退出时执行清理函数。<code>EXIT</code> 是一个特殊的信号，表示脚本即将退出。例如，以下命令会在脚本退出时调用名为 <code>cleanup</code> 的清理函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;cleanup&quot;</span> EXIT</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cleanup</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Performing cleanup...&quot;</span></span><br><span class="line">    <span class="comment"># 其他清理操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本的主要逻辑</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>防止脚本被中断：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27;Script is running. Please wait...&#x27;&quot;</span> SIGINT</span><br></pre></td></tr></table></figure>
<p>通过捕获 <code>SIGINT</code> 信号（Ctrl+C）并输出一条消息，可以防止用户中断正在执行的脚本。这样，用户按下 Ctrl+C 时，只会得到一条消息而不是立即中断脚本。</p>
</li>
<li><p><strong>设置错误处理：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;error_handler&quot;</span> ERR</span><br></pre></td></tr></table></figure>
<p>在脚本中设置一个错误处理函数，以便在命令发生错误时执行特定的操作。例如，以下命令会在发生错误时调用名为 <code>handle_error</code> 的错误处理函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;handle_error&quot;</span> ERR</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">handle_error</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;An error occurred. Exiting...&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本的主要逻辑</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>临时捕获信号：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;cleanup_function&quot;</span> SIGNAL</span><br></pre></td></tr></table></figure>
<p>可以在脚本的特定部分设置 <code>trap</code>，然后在执行完该部分后恢复原有的信号处理。例如，以下命令会在执行某个任务期间捕获 <code>SIGINT</code> 信号，执行清理操作，然后在任务完成后恢复默认的信号处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&quot;cleanup_function&quot;</span> SIGINT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行某个任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复默认的信号处理</span></span><br><span class="line"><span class="built_in">trap</span> - SIGINT</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些技巧可以帮助你更好地处理脚本中的信号，确保在发生特定事件时执行适当的操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_18_nohup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_18_nohup/" class="post-title-link" itemprop="url">linux_2_18_nohup</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>nohup命令</li>
</ul>
<h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><!-- + `nohup, no hang up`， 用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行
+ 在默认情况下（非重定向时），会输出一个名叫`nohup.out`的文件在当前目录下，如果当前目录下文件不可写，输出重定向到`$HOME/nohup.out`文件中

+ 语法格式 -- `nohup Command [Arg ...] [ & ]`

+ 参数说明
  + `Command` -- 要执行的命令
  + `Arg` -- 一些参数，可以指定输出文件
  + `&` -- 让命令在后台执行，终端退出后命令仍旧执行 -->

<p>在Linux中，<code>nohup</code>命令用于在后台运行程序，并忽略掉终端断开的信号（SIGHUP）。它允许您在终端退出后继续运行程序，同时将程序的输出重定向到指定的文件中。</p>
<p>以下是<code>nohup</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command [arguments] [redirection]</span><br></pre></td></tr></table></figure>

<p>其中，<code>command</code>是要运行的程序或命令，<code>arguments</code>是传递给程序的参数，<code>redirection</code>是输出重定向的选项。</p>
<p>以下是一些常见的<code>nohup</code>命令选项和用法：</p>
<ol>
<li><p>后台运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command &amp;</span><br></pre></td></tr></table></figure>

<p>此命令将<code>command</code>程序在后台运行，并忽略终端断开信号。</p>
</li>
<li><p>输出重定向到文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command &gt; output.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>此命令将<code>command</code>程序的输出重定向到<code>output.log</code>文件中。<code>2&gt;&amp;1</code>将标准错误输出也重定向到相同的文件。</p>
</li>
<li><p>指定日志文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command &gt; output.log 2&gt; error.log &amp;</span><br></pre></td></tr></table></figure>

<p>此命令将标准输出重定向到<code>output.log</code>文件，将标准错误输出重定向到<code>error.log</code>文件。</p>
</li>
<li><p>追加到日志文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command &gt;&gt; output.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>此命令将标准输出和标准错误输出追加到<code>output.log</code>文件中。</p>
</li>
<li><p>查看输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f output.log</span><br></pre></td></tr></table></figure>

<p>使用<code>tail -f</code>命令实时查看<code>output.log</code>文件的内容，以便监控程序的输出。</p>
</li>
</ol>
<p>请注意，<code>nohup</code>命令将程序放在后台运行，但它仍然会生成一个<code>nohup.out</code>文件，用于保存程序的输出。如果不想生成此文件，可以将输出重定向到其他文件。</p>
<p>使用<code>nohup</code>命令时，通常建议同时使用<code>&amp;</code>符号将程序放在后台运行，并将输出重定向到文件，以确保程序在终端退出后继续运行，并且输出可以保存。</p>
<h2 id="linux-nohup命令-详解"><a href="#linux-nohup命令-详解" class="headerlink" title="linux nohup命令 详解"></a>linux nohup命令 详解</h2><p><code>nohup</code> 命令用于在后台运行命令，即使当前终端会话关闭，也能保持命令的执行。这使得用户可以启动一个长时间运行的任务，而不必担心它是否会在终端关闭时终止。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> <span class="built_in">command</span> [options] [arguments] &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>command</code>: 要在后台运行的命令。</li>
<li><code>options</code> 和 <code>arguments</code>: 命令的选项和参数。</li>
<li><code>&amp;</code>: 将命令放入后台运行。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ./long_running_script.sh &gt; output.log &amp;</span><br></pre></td></tr></table></figure>

<p>这个例子将 <code>long_running_script.sh</code> 脚本以后台进程运行，并将输出重定向到 <code>output.log</code> 文件。即使你关闭终端，<code>long_running_script.sh</code> 仍会继续运行。</p>
<p><strong>注意：</strong></p>
<ul>
<li>默认情况下，<code>nohup</code> 的输出会追加到一个文件名为 <code>nohup.out</code> 的文件中。如果你希望自定义输出文件，可以使用重定向符号（如 <code>&gt; output.log</code>）。</li>
<li><code>nohup</code> 启动的进程会忽略 <code>SIGHUP</code> 信号，这是为了确保即使终端关闭，进程也能继续运行。</li>
</ul>
<h2 id="linux-nohup命令-常用技巧"><a href="#linux-nohup命令-常用技巧" class="headerlink" title="linux nohup命令 常用技巧"></a>linux nohup命令 常用技巧</h2><p>以下是一些在使用 <code>nohup</code> 命令时的一些常用技巧：</p>
<ol>
<li><p><strong>将输出重定向到文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> <span class="built_in">command</span> &gt; output.log &amp;</span><br></pre></td></tr></table></figure>
<p>这将 <code>command</code> 的输出重定向到 <code>output.log</code> 文件，避免默认的 <code>nohup.out</code>。</p>
</li>
<li><p><strong>将输出同时追加到文件和终端：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> <span class="built_in">command</span> &gt; output.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>使用 <code>2&gt;&amp;1</code> 将标准错误（stderr）也重定向到标准输出，这样输出既会追加到文件中，也会在终端显示。</p>
</li>
<li><p><strong>在后台运行脚本：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ./script.sh arg1 arg2 &gt; output.log &amp;</span><br></pre></td></tr></table></figure>
<p>启动一个脚本，并将输出写入 <code>output.log</code> 文件，即使终端关闭，脚本也会在后台继续运行。</p>
</li>
<li><p><strong>将进程挂起到后台：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> <span class="built_in">command</span> &gt; output.log &amp;</span><br></pre></td></tr></table></figure>
<p>使用 <code>&amp;</code> 将进程放入后台运行。如果你忘记在命令后添加 <code>&amp;</code>，你可以使用 <code>Ctrl+Z</code> 暂停进程，然后使用 <code>bg</code> 命令将其放入后台。</p>
</li>
<li><p><strong>查看正在运行的后台任务：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>jobs</code> 命令可以列出当前终端中正在运行的后台任务。每个任务都有一个唯一的编号。</p>
</li>
<li><p><strong>将后台任务切换到前台：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fg</span> %1</span><br></pre></td></tr></table></figure>
<p>使用 <code>fg</code> 命令将后台任务切换到前台。在这个例子中，<code>%1</code> 是任务的编号。</p>
</li>
<li><p><strong>将后台任务放到后台运行：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span> %1</span><br></pre></td></tr></table></figure>
<p>使用 <code>bg</code> 命令将后台任务放到后台运行。同样，<code>%1</code> 是任务的编号。</p>
</li>
<li><p><strong>将一个命令放到后台运行并立即脱离：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> <span class="built_in">command</span> &gt; output.log 2&gt;&amp;1 &amp; <span class="built_in">disown</span></span><br></pre></td></tr></table></figure>
<p><code>disown</code> 命令可以使任务脱离终端，这样它不会受到终端关闭的影响。</p>
</li>
</ol>
<p>这些技巧可以帮助你更灵活地使用 <code>nohup</code> 命令来管理在后台运行的任务。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_15_read/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_15_read/" class="post-title-link" itemprop="url">linux_2_15_read</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>read命令</li>
</ul>
<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><ul>
<li>从命令行读取标准输入</li>
<li>读取输入，保存到变量<ul>
<li><code>read -p &quot;please input &gt;&gt;&gt;&quot; var</code></li>
</ul>
</li>
</ul>
<p>在Linux中，<code>read</code>命令用于从标准输入读取用户输入并存储到一个或多个变量中。它通常用于脚本中，以便与用户进行交互并获取输入数据。</p>
<p>以下是<code>read</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read [-options] [variable...]</span><br></pre></td></tr></table></figure>

<p>其中，<code>-options</code>是可选的一些选项，<code>variable</code>是要存储输入的一个或多个变量。</p>
<p>以下是一些常见的<code>read</code>命令选项和用法：</p>
<ol>
<li><p>读取单个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read variable</span><br></pre></td></tr></table></figure>

<p>此命令将提示用户输入，并将输入的值存储到<code>variable</code>变量中。</p>
</li>
<li><p>读取多个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read variable1 variable2 ...</span><br></pre></td></tr></table></figure>

<p>此命令将按顺序提示用户输入，并将每个输入的值依次存储到相应的变量中。</p>
</li>
<li><p>自定义提示符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;Enter your name: &quot; name</span><br></pre></td></tr></table></figure>

<p>此命令将显示自定义的提示符（在双引号中指定），并将输入的值存储到<code>name</code>变量中。</p>
</li>
<li><p>设置超时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -t 5 variable</span><br></pre></td></tr></table></figure>

<p>此命令将在等待用户输入时设置一个超时时间（5秒）。如果在超时时间内未收到输入，命令将继续执行并变量的值为空。</p>
</li>
<li><p>读取行中的多个单词：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -a array</span><br></pre></td></tr></table></figure>

<p>此命令将读取一行输入，并将输入的单词存储到一个数组变量中。</p>
</li>
</ol>
<p><code>read</code>命令还有其他一些选项，如设置分隔符、禁止回显输入等，您可以通过<code>man read</code>命令查看完整的选项和用法说明。</p>
<p>请注意，<code>read</code>命令在交互式脚本中非常有用，可以用于获取用户输入并在脚本中进行处理。</p>
<h2 id="linux-read命令-详解"><a href="#linux-read命令-详解" class="headerlink" title="linux read命令 详解"></a>linux read命令 详解</h2><p><code>read</code> 命令在 Linux 中用于从标准输入或其他文件描述符中读取输入，并将其保存到一个或多个变量中。这个命令通常用于从用户获取输入或从管道中读取数据。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [选项] 变量</span><br></pre></td></tr></table></figure>

<p><strong>常见选项：</strong></p>
<ul>
<li><code>-p prompt</code>：指定提示符，用于向用户显示输入的请求。</li>
<li><code>-t timeout</code>：设置超时时间，如果在指定时间内没有输入，命令将退出。</li>
<li><code>-n count</code>：指定读取的字符数。</li>
<li><code>-s</code>：静默模式，不显示输入的字符。</li>
</ul>
<p><strong>示例：</strong></p>
<ol>
<li><p><strong>从用户获取输入：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Enter your name: &quot;</span></span><br><span class="line"><span class="built_in">read</span> username</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$username</span>!&quot;</span></span><br></pre></td></tr></table></figure>
<p>用户输入将被保存到变量 <code>username</code> 中。</p>
</li>
<li><p><strong>指定提示符：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your age: &quot;</span> age</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your age is <span class="variable">$age</span>.&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置超时：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">read</span> -t 5 -p <span class="string">&quot;Enter your choice within 5 seconds: &quot;</span> choice; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;You entered: <span class="variable">$choice</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Time is up!&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>读取固定数量的字符：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -n 3 -p <span class="string">&quot;Enter a three-character code: &quot;</span> code</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;You entered: <span class="variable">$code</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静默模式：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -s -p <span class="string">&quot;Enter your password: &quot;</span> password</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Password entered.&quot;</span></span><br></pre></td></tr></table></figure>
<p>用户的输入将不会显示在屏幕上。</p>
</li>
<li><p><strong>使用 <code>IFS</code> 定义字段分隔符：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IFS=<span class="string">&#x27;,&#x27;</span> <span class="built_in">read</span> -r -a array &lt;&lt;&lt; <span class="string">&quot;item1,item2,item3&quot;</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;array[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Item: <span class="variable">$item</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>IFS</code> 被设置为逗号，<code>read</code> 命令将逗号分隔的字符串读入数组中。</p>
</li>
</ol>
<p><code>read</code> 命令通常用于交互性较强的脚本或命令，以从用户获取输入。通过结合不同的选项，你可以实现更灵活和复杂的用户交互。</p>
<h2 id="linux-read命令-常用技巧"><a href="#linux-read命令-常用技巧" class="headerlink" title="linux read命令 常用技巧"></a>linux read命令 常用技巧</h2><p>以下是一些在使用 <code>read</code> 命令时的常用技巧：</p>
<ol>
<li><p><strong>使用 <code>-r</code> 选项防止反斜杠转义：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -r variable</span><br></pre></td></tr></table></figure>
<p><code>-r</code> 选项用于禁用反斜杠的转义，确保输入的内容保持原样，不对反斜杠进行转义。</p>
</li>
<li><p><strong>将输入直接赋值给数组：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -a array</span><br></pre></td></tr></table></figure>
<p>这将直接将用户输入的内容分配给数组，每个单词作为数组的一个元素。</p>
</li>
<li><p><strong>使用 <code>IFS</code> 定义字段分隔符：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFS=<span class="string">&#x27;,&#x27;</span> <span class="built_in">read</span> -r -a array</span><br></pre></td></tr></table></figure>
<p>通过设置 <code>IFS</code>（Internal Field Separator）来指定字段分隔符，以便读取逗号分隔的值并分配给数组。</p>
</li>
<li><p><strong>设置默认值：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your name [default: John]: &quot;</span> name</span><br><span class="line">name=<span class="variable">$&#123;name:-John&#125;</span></span><br></pre></td></tr></table></figure>
<p>这将在用户没有输入时将变量设置为默认值。</p>
</li>
<li><p><strong>限制输入的字符数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -n 3 variable</span><br></pre></td></tr></table></figure>
<p>使用 <code>-n</code> 选项可以限制读取的字符数。在上述例子中，用户只能输入三个字符。</p>
</li>
<li><p><strong>使用 <code>select</code> 与 <code>read</code> 实现菜单：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">options=(<span class="string">&quot;Option 1&quot;</span> <span class="string">&quot;Option 2&quot;</span> <span class="string">&quot;Option 3&quot;</span>)</span><br><span class="line">PS3=<span class="string">&quot;Select an option: &quot;</span></span><br><span class="line"><span class="keyword">select</span> choice <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;options[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">read</span> -r selected_option</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$REPLY</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3) <span class="built_in">echo</span> <span class="string">&quot;You selected: <span class="variable">$choice</span>&quot;</span>; <span class="built_in">break</span>;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">&quot;Invalid option. Try again.&quot;</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这个例子结合了 <code>select</code> 和 <code>read</code>，创建了一个简单的菜单。</p>
</li>
<li><p><strong>使用 <code>IFS</code> 将一行输入分割为多个变量：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFS=<span class="string">&quot;,&quot;</span> <span class="built_in">read</span> var1 var2 var3</span><br></pre></td></tr></table></figure>
<p>如果输入是逗号分隔的，这将把输入分割为三个变量。</p>
</li>
<li><p><strong>将输入转换为小写或大写：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your choice: &quot;</span> choice</span><br><span class="line">choice=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$choice</span>&quot;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[:upper:]&#x27;</span> <span class="string">&#x27;[:lower:]&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子将用户输入的内容转换为小写。你也可以使用 <code>tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code> 将其转换为大写。</p>
</li>
</ol>
<p>这些技巧可以帮助你更灵活地使用 <code>read</code> 命令，使交互式脚本更加强大和用户友好。</p>
<h2 id="linux-read命令-高级技巧"><a href="#linux-read命令-高级技巧" class="headerlink" title="linux read命令 高级技巧"></a>linux read命令 高级技巧</h2><p>以下是一些在使用 <code>read</code> 命令时的一些高级技巧，可以用于处理更复杂的输入场景：</p>
<ol>
<li><p><strong>使用 <code>read</code> 读取密码而不回显：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -s -p <span class="string">&quot;Enter your password: &quot;</span> password</span><br></pre></td></tr></table></figure>
<p><code>-s</code> 选项用于关闭输入回显，这样用户输入密码时不会在屏幕上显示明文。</p>
</li>
<li><p><strong>在单行中读取多个变量：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter name and age: &quot;</span> name age</span><br></pre></td></tr></table></figure>
<p>这将一次性读取用户输入的姓名和年龄，并分别赋值给变量 <code>name</code> 和 <code>age</code>。</p>
</li>
<li><p><strong>读取多行文本：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Enter your text (Ctrl+D to finish):&quot;</span></span><br><span class="line"><span class="built_in">read</span> -d <span class="string">&#x27;&#x27;</span> text</span><br></pre></td></tr></table></figure>
<p>使用 <code>-d &#39;&#39;</code> 选项可以读取多行文本，用户可以通过按下 <code>Ctrl+D</code> 来结束输入。</p>
</li>
<li><p><strong>在循环中使用 <code>read</code>：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Read line: <span class="variable">$line</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &lt; file.txt</span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>read</code> 在循环中用于逐行读取文件 <code>file.txt</code> 的内容。</p>
</li>
<li><p><strong>使用超时处理输入：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">read</span> -t 5 -p <span class="string">&quot;Enter your choice: &quot;</span> choice; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;You entered: <span class="variable">$choice</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Timed out. No input received.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果在 5 秒内没有用户输入，<code>read</code> 命令会超时，执行 <code>else</code> 语句块。</p>
</li>
<li><p><strong>使用 <code>IFS</code> 读取并分割输入行：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> IFS=, <span class="built_in">read</span> -r name age; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Name: <span class="variable">$name</span>, Age: <span class="variable">$age</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &lt; data.csv</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>IFS</code> 被设置为逗号，<code>read</code> 将逗号分隔的值分配给变量 <code>name</code> 和 <code>age</code>。</p>
</li>
<li><p><strong>处理特殊字符：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -n 1 -r -p <span class="string">&quot;Press any key to continue...&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>-n 1</code> 选项可以读取用户按下的任意键，而不需要按回车键。</p>
</li>
<li><p><strong>使用 <code>read</code> 读取密码并检测输入是否为空：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">read</span> -s -p <span class="string">&quot;Enter your password: &quot;</span> password</span><br><span class="line">    [ -n <span class="string">&quot;<span class="variable">$password</span>&quot;</span> ] &amp;&amp; <span class="built_in">break</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Password cannot be empty. Please try again.&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这个例子会循环要求用户输入密码，直到输入非空为止。</p>
</li>
</ol>
<p>这些高级技巧可以使 <code>read</code> 命令在处理不同类型的输入时更加灵活和强大。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_17_less/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_17_less/" class="post-title-link" itemprop="url">linux_2_17_less</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>less命令</li>
</ul>
<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>在Linux中，<code>less</code>命令用于逐页浏览文本文件的内容。它是对<code>more</code>命令的改进，提供了更多的功能和灵活性。</p>
<p>以下是<code>less</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [options] [file]</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code>是可选的一些选项，<code>file</code>是要显示的文本文件。</p>
<p>以下是一些常见的<code>less</code>命令选项和用法：</p>
<ol>
<li><p>逐页浏览文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将按一页一页地显示<code>file.txt</code>文件的内容。您可以使用空格键向下翻页，按<code>b</code>键向上翻页，按<code>q</code>键退出。</p>
</li>
<li><p>搜索文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less -p pattern file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将打开文件并搜索与<code>pattern</code>匹配的文本。按<code>n</code>键向下查找下一个匹配项，按<code>N</code>键向上查找上一个匹配项。</p>
</li>
<li><p>显示行号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less -N file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将在每一行前显示行号。</p>
</li>
<li><p>显示文件大小和位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less -m file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将在屏幕底部显示当前显示内容相对于整个文件的百分比、文件大小和当前显示内容的行数。</p>
</li>
<li><p>跳转到指定行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less +10 file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将从第10行开始显示文件内容。</p>
</li>
<li><p>从命令行读取输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command | less</span><br></pre></td></tr></table></figure>

<p>此命令将从命令行输出中读取内容并使用<code>less</code>进行浏览。</p>
</li>
</ol>
<p><code>less</code>命令还支持其他一些选项和操作，如按字母排序、复制文本、显示特定行范围等。您可以使用<code>man less</code>命令查看完整的选项和用法说明。</p>
<p>总体而言，<code>less</code>命令是一个功能强大且灵活的文本浏览器，它可以帮助您浏览和查看大型文本文件，并提供了许多方便的功能。</p>
<h2 id="linux-less命令-详解"><a href="#linux-less命令-详解" class="headerlink" title="linux less命令 详解"></a>linux less命令 详解</h2><p><code>less</code> 命令也是一个用于在终端中逐页显示文本文件内容的分页查看工具，它相对于 <code>more</code> 具有更多的交互性和功能。<code>less</code> 允许用户在查看文件时进行搜索、滚动、跳转等操作。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [选项] 文件名</span><br></pre></td></tr></table></figure>

<p>一些常见的 <code>less</code> 命令选项和用法：</p>
<ol>
<li><strong>空格键：</strong> 显示下一页。</li>
<li><strong>b 键：</strong> 显示上一页。</li>
<li><strong>Enter 键：</strong> 显示下一行。</li>
<li><strong>q 键：</strong> 退出 <code>less</code>。</li>
<li><strong>&#x2F; 搜索字符串：</strong> 在文本中搜索指定字符串。</li>
<li><strong>n 键：</strong> 跳到下一次出现搜索字符串的位置。</li>
<li><strong>N 键：</strong> 反向跳到上一次出现搜索字符串的位置。</li>
<li><strong>g 键：</strong> 跳到文件开头。</li>
<li><strong>G 键：</strong> 跳到文件末尾。</li>
<li><strong>:f：</strong> 显示当前文件名和行号。</li>
<li><strong>:n：</strong> 切换行号显示。</li>
<li><strong>! 命令：</strong> 执行外部命令。</li>
<li><strong>v 键：</strong> 使用系统默认编辑器（如 <code>vi</code>）打开文件进行编辑。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less example.txt</span><br></pre></td></tr></table></figure>

<p><code>less</code> 命令将以分页形式显示 <code>example.txt</code> 文件的内容，并提供了上述交互式功能。</p>
<p>与 <code>more</code> 不同，<code>less</code> 允许用户向前和向后滚动，支持搜索字符串，提供更多的浏览和搜索选项，使得在查看大型文本文件时更为方便。</p>
<p>如果你想要查看更多 <code>less</code> 命令的选项和功能，你可以查阅 <code>man less</code> 或 <code>less --help</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_22_ar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_22_ar/" class="post-title-link" itemprop="url">linux_2_22_ar</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ar命令</li>
</ul>
<h2 id="ar"><a href="#ar" class="headerlink" title="ar"></a>ar</h2><ul>
<li>ar命令，用于建立或修改备存文件，或者是从备存文件中抽取文件</li>
<li>ar可以集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限</li>
<li>语法<ul>
<li><code>ar [ -dmpqrtx ] [ cfosSuvV ] [ a&lt;成员文件&gt; ] [ b&lt;成员文件&gt; ] [ i&lt;成员文件&gt; ] [ 备存文件 ] [ 成员文件 ]</code></li>
</ul>
</li>
<li>参数<ul>
<li><code>-d</code> : 删除备存文件中的成员文件</li>
<li><code>-m</code> : 变更成员文件在备存文件中的次序</li>
<li><code>-p</code> : 显示备存文件中的成员文件内容</li>
<li><code>-q</code> : 将文件附加在备存文件末端</li>
<li><code>-r</code> : 将文件插入备存文件中</li>
<li><code>-t</code> : 显示备存文件中所包含的文件</li>
<li><code>-x</code> : 自备存文件中取出成员文件</li>
</ul>
</li>
<li>选项参数：<ul>
<li><code>a&lt;成员文件&gt;</code> : 将文件插入备存文件中指定的成员文件之后</li>
<li><code>b&lt;成员文件&gt;</code> : 将文件插入备存文件中指定的成员文件之前</li>
<li><code>c</code> : <strong>建立备存文件</strong></li>
<li><code>f</code> : 为避免过场的文件名不兼容于其他系统的ar指令，因此可使用此参数，截掉要放入备存文件中过长的成员文件名称</li>
<li><code>i&lt;成员文件&gt;</code> : 将文件插入备存文件中指定的成员文件之前</li>
<li><code>o</code> : 保留备存文件中文件的日期</li>
<li><code>s</code> : 若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表</li>
<li><code>S</code> : 不产生符号表</li>
<li><code>u</code> : 只将日期较新文件插入备存文件中</li>
<li><code>v</code> : 程序执行时显示详细的信息</li>
<li><code>V</code> : 显示版本信息</li>
</ul>
</li>
</ul>
<h2 id="linux-ar命令-详解"><a href="#linux-ar命令-详解" class="headerlink" title="linux ar命令 详解"></a>linux ar命令 详解</h2><p><code>ar</code> 命令是用于创建和维护静态库（archive）的工具。静态库是包含了多个目标文件的归档文件，通常用于在编译和链接时与程序一起使用。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar [选项] [archive] [files]</span><br></pre></td></tr></table></figure>

<p><strong>常见选项：</strong></p>
<ul>
<li><code>r</code>：将文件添加到归档中。</li>
<li><code>x</code>：从归档中提取文件。</li>
<li><code>t</code>：列出归档中的文件。</li>
<li><code>d</code>：从归档中删除文件。</li>
<li><code>c</code>：创建归档。</li>
</ul>
<p><strong>示例：</strong></p>
<ol>
<li><p><strong>创建静态库：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libexample.a file1.o file2.o file3.o</span><br></pre></td></tr></table></figure>
<p>这将创建名为 <code>libexample.a</code> 的静态库，并将 <code>file1.o</code>、<code>file2.o</code> 和 <code>file3.o</code> 添加到其中。</p>
</li>
<li><p><strong>从静态库中提取文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar x libexample.a file2.o</span><br></pre></td></tr></table></figure>
<p>这将从 <code>libexample.a</code> 中提取 <code>file2.o</code>。</p>
</li>
<li><p><strong>列出静态库中的文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar t libexample.a</span><br></pre></td></tr></table></figure>
<p>这将列出 <code>libexample.a</code> 中包含的文件。</p>
</li>
<li><p><strong>从静态库中删除文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar d libexample.a file1.o</span><br></pre></td></tr></table></figure>
<p>这将从 <code>libexample.a</code> 中删除 <code>file1.o</code>。</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>静态库通常使用 <code>.a</code> 扩展名，但这并不是强制的。</li>
<li>在许多情况下，开发人员更倾向于使用共享库（动态库）而不是静态库，因为共享库在运行时动态加载，更加灵活。</li>
</ul>
<p><code>ar</code> 命令通常与编译器（如 <code>gcc</code>）一起使用，用于创建和管理程序的静态库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_21_wc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_21_wc/" class="post-title-link" itemprop="url">linux_2_21_wc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>wc命令</li>
</ul>
<h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><ul>
<li>wc, 用于计算字数</li>
<li>利用wc指令可以计算文件的Byte数,字数或是列数,若不指定文件名称,或是所给予的文件名为<code>-</code>,则wc指令会从标准输入设备读取数据</li>
<li>语法:<code>wc [-clw] [--help] [--version] [文件...]</code></li>
<li>参数:<ul>
<li><code>-c</code>或<code>--bytes</code>或<code>--chars</code> 只显示Bytes数</li>
<li><code>-w</code>或<code>--words</code> 只显示字数</li>
<li><code>-l</code>或<code>--lines</code> 显示行数</li>
<li><code>--help</code> 在线帮助</li>
<li><code>--version</code> 显示版本信息</li>
</ul>
</li>
<li>使用wc统计:<ul>
<li><code>wc testfile  # testfile文件的统计信息</code></li>
<li><code>3 92 598 testfile # testfile文件的行数为3, 单词数为92, 字节数为598</code></li>
<li>其中三个数字分别表示testfile文件的行数,单词数,以及该文件的字节数</li>
</ul>
</li>
<li>如果想同时统计多个文件的信息,例如同时统计testfile,testfile_1,testfile_2,可使用:<code>wc testfile testfile_1 testfile_2  # 统计三个文件的信息</code></li>
</ul>
<h2 id="wc-1"><a href="#wc-1" class="headerlink" title="wc"></a>wc</h2><!-- + `wc`,命令用于计算字数
+ 利用`wc`指令我们可以计算文件的Byte数，字数，或者是列数，如果不指定文件名称，或者是所给的文件名为`"-"`，则wc指令会从标准如入设备读取数据
+ 语法：`wc [-clw][--help][--version][files...]`
+ 参数：
  + `-c, -bytes, --chars`：只显示Bytes数
  + `-l， --lines`：显示行数
  + `-w, --words`：只显示字数
+ 查看某个目录下的文件数：`ls -l | grep "-" | wc -l` -->

<p>在Linux中，<code>wc</code>命令用于计算给定文件或标准输入中的字节数、字数和行数。它是一个简单但功能强大的命令，经常用于统计文本文件的信息。</p>
<p>以下是<code>wc</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [options] [file...]</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code>是可选的一些选项，<code>file</code>是要统计的文件。</p>
<p>以下是一些常见的<code>wc</code>命令选项和用法：</p>
<ol>
<li><p>统计文件中的字节数、字数和行数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将输出文件<code>file.txt</code>中的字节数、字数和行数。</p>
</li>
<li><p>只统计字节数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -c file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将仅输出文件<code>file.txt</code>中的字节数。</p>
</li>
<li><p>只统计字数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -w file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将仅输出文件<code>file.txt</code>中的字数。</p>
</li>
<li><p>只统计行数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -l file.txt</span><br></pre></td></tr></table></figure>

<p>此命令将仅输出文件<code>file.txt</code>中的行数。</p>
</li>
<li><p>批量统计多个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc file1.txt file2.txt file3.txt</span><br></pre></td></tr></table></figure>

<p>此命令将分别统计并输出多个文件的字节数、字数和行数。</p>
</li>
<li><p>统计多个文件的总计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -l file1.txt file2.txt file3.txt</span><br></pre></td></tr></table></figure>

<p>此命令将统计多个文件的行数，并在最后输出总行数。</p>
</li>
</ol>
<p><code>wc</code>命令还支持其他一些选项，如统计最长行的长度、输出格式化结果等。您可以使用<code>man wc</code>命令查看完整的选项和用法说明。</p>
<p>总体而言，<code>wc</code>命令是一个方便的工具，用于统计文件中的字节数、字数和行数。它在处理文本文件时非常有用，可以提供对文件结构和内容的快速概览。</p>
<h2 id="linux-wc命令-详解"><a href="#linux-wc命令-详解" class="headerlink" title="linux wc命令 详解"></a>linux wc命令 详解</h2><p><code>wc</code> 命令用于统计文件的行数、字数和字节数。它是一个简单而有效的工具，经常用于文本文件的分析和统计。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> [选项] 文件名</span><br></pre></td></tr></table></figure>

<p><strong>常见选项：</strong></p>
<ul>
<li><code>-l</code>：统计行数。</li>
<li><code>-w</code>：统计字数。</li>
<li><code>-c</code>：统计字节数。</li>
<li><code>-m</code>：统计字符数。</li>
<li><code>-L</code>：找出文件中最长行的长度。</li>
</ul>
<p><strong>示例：</strong></p>
<ol>
<li><p><strong>统计文件的行数、字数和字节数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>只统计行数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>只统计字数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> -w filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>只统计字节数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> -c filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>找出文件中最长行的长度：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> -L filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>统计多个文件的总行数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l file1.txt file2.txt file3.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过管道统计命令输出：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>
<p>这个例子统计当前目录下的文件数。</p>
</li>
<li><p><strong>递归统计目录中所有文件的行数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">wc</span> -l &#123;&#125; +</span><br></pre></td></tr></table></figure>
<p>使用 <code>find</code> 命令递归查找指定目录下的所有文件，并统计它们的行数。</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>如果没有提供文件名，则 <code>wc</code> 将从标准输入读取数据。</li>
<li><code>wc</code> 默认情况下会输出行数、字数和字节数，按照顺序排列。</li>
</ul>
<p><code>wc</code> 命令是一个简单而强大的工具，用于快速获取文件或文本数据的统计信息。根据需要选择不同的选项，可以获取所需的统计结果。</p>
<h2 id="linux-wc命令-常用技巧"><a href="#linux-wc命令-常用技巧" class="headerlink" title="linux wc命令 常用技巧"></a>linux wc命令 常用技巧</h2><p>以下是一些在使用 <code>wc</code> 命令时的一些常用技巧：</p>
<ol>
<li><p><strong>使用通配符统计多个文件的总行数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l *.txt</span><br></pre></td></tr></table></figure>
<p>这将统计所有以 <code>.txt</code> 结尾的文件的总行数。</p>
</li>
<li><p><strong>使用 <code>echo</code> 命令传递字符串并统计信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, World!&quot;</span> | <span class="built_in">wc</span> -c</span><br></pre></td></tr></table></figure>
<p>这将统计字符串 “Hello, World!” 的字符数。</p>
</li>
<li><p><strong>使用 <code>find</code> 和 <code>xargs</code> 统计多个目录中所有文件的总行数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -<span class="built_in">type</span> f -print0 | xargs -0 <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>
<p><code>-print0</code> 和 <code>-0</code> 选项用于处理文件名中包含空格等特殊字符的情况。</p>
</li>
<li><p><strong>在 <code>for</code> 循环中使用 <code>wc</code> 统计多个文件的信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *.txt; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">wc</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这将逐个统计所有以 <code>.txt</code> 结尾的文件的行数、字数和字节数。</p>
</li>
<li><p><strong>使用 <code>tee</code> 同时输出到屏幕和文件并统计：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> | <span class="built_in">tee</span> output.log | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>
<p>这将执行某个命令，将其输出同时写入文件 <code>output.log</code> 和通过管道传递给 <code>wc</code> 统计行数。</p>
</li>
<li><p><strong>使用 <code>grep</code> 统计匹配行的数量：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c <span class="string">&quot;pattern&quot;</span> filename.txt</span><br></pre></td></tr></table></figure>
<p>这将统计文件中包含指定模式的行数。</p>
</li>
<li><p><strong>将 <code>wc</code> 输出格式化为单行：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l filename.txt | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这使用 <code>awk</code> 只输出 <code>wc</code> 的行数，去掉文件名。</p>
</li>
<li><p><strong>使用 <code>paste</code> 将多个文件的信息并排显示：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> &lt;(<span class="built_in">wc</span> -l file1.txt) &lt;(<span class="built_in">wc</span> -l file2.txt)</span><br></pre></td></tr></table></figure>
<p>这将以并排的方式显示两个文件的行数信息。</p>
</li>
</ol>
<p>这些技巧可以帮助你更灵活地使用 <code>wc</code> 命令，根据不同的需求获取所需的统计信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_19_split/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_19_split/" class="post-title-link" itemprop="url">linux_2_19_split</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>split命令</li>
</ul>
<h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><ul>
<li>功能：将单个tar文件切割成多个tar文件</li>
<li>命令：<code>split -b 4000M -a 1 -d nvidia.tar nvidia.tar</code></li>
<li>参数：<ul>
<li><code>-b</code>  –  指定生成的分割包大小</li>
<li><code>-a</code>  –  设定序列的长度，默认为2，这里设置为1，生成的文件就为nvidia.tar1，</li>
<li><code>-d</code>  –  指定生成的分割包后缀为数字的形式</li>
</ul>
</li>
</ul>
<p>在Linux中，<code>split</code>命令用于将一个大文件拆分成多个较小的文件。它可以按照文件大小、行数或指定的分割标准将文件分割成多个部分，方便处理和传输大型文件。</p>
<p>以下是<code>split</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split [options] input_file [output_file_prefix]</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code>是可选的一些选项，<code>input_file</code>是要拆分的输入文件，<code>output_file_prefix</code>是输出文件的前缀。输出文件的名称将以前缀开头，后跟一个字母或数字来表示各个部分。</p>
<p>以下是一些常见的<code>split</code>命令选项和用法：</p>
<ol>
<li><p>按照文件大小拆分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split -b size input_file output_file_prefix</span><br></pre></td></tr></table></figure>

<p>此命令将根据指定的文件大小（<code>size</code>）将输入文件拆分成多个部分。<code>size</code>可以使用以下后缀表示：K（千字节）、M（兆字节）、G（千兆字节）等。</p>
</li>
<li><p>按照行数拆分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split -l lines input_file output_file_prefix</span><br></pre></td></tr></table></figure>

<p>此命令将根据指定的行数（<code>lines</code>）将输入文件拆分成多个部分。</p>
</li>
<li><p>自定义输出文件名格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split --additional-suffix=suffix input_file output_file_prefix</span><br></pre></td></tr></table></figure>

<p>此命令将在输出文件的名称中添加指定的后缀（<code>suffix</code>），以自定义输出文件名的格式。</p>
</li>
<li><p>拆分二进制文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split -b size --binary input_file output_file_prefix</span><br></pre></td></tr></table></figure>

<p>如果要拆分二进制文件，可以使用<code>--binary</code>选项。</p>
</li>
</ol>
<p><code>split</code>命令还支持其他一些选项，如指定拆分文件的数量、保留原始文件等。您可以使用<code>man split</code>命令查看完整的选项和用法说明。</p>
<p><code>split</code>命令对于处理大型文件或需要分割成较小部分的文件非常有用。它可以帮助您在处理和传输文件时更加高效地操作数据。</p>
<h2 id="将split分割的压缩包合并"><a href="#将split分割的压缩包合并" class="headerlink" title="将split分割的压缩包合并"></a>将<code>split</code>分割的压缩包合并</h2><ul>
<li><code>cat nvidia.tar* &gt; nvidia.tar | cat nvidia.tar01 nvidia.tar02 &gt; nvidia.tar</code></li>
</ul>
<h2 id="7z-文件"><a href="#7z-文件" class="headerlink" title=".7z 文件"></a><code>.7z</code> 文件</h2><ul>
<li>使用<code>p7zip</code>软件解压</li>
<li>参数：<ul>
<li><code>-d , --decompress --uncompress</code> : decompress file</li>
<li><code>-c --stdout --to-stdout</code> : output data to stdout</li>
<li>&#96;&#96;</li>
</ul>
</li>
</ul>
<h2 id="linux-split命令-详解"><a href="#linux-split命令-详解" class="headerlink" title="linux split命令 详解"></a>linux split命令 详解</h2><p><code>split</code> 命令用于将一个大文件拆分成多个小文件，可以指定拆分的大小或拆分的行数。这个命令在处理大型日志文件或备份文件时非常有用。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> [选项] 输入文件 [输出文件前缀]</span><br></pre></td></tr></table></figure>

<p><strong>常见选项：</strong></p>
<ul>
<li><code>-b, --bytes=SIZE</code>：按字节大小拆分。</li>
<li><code>-l, --lines=NUMBER</code>：按行数拆分。</li>
<li><code>-a, --suffix-length=N</code>：设置输出文件后缀的长度。</li>
<li><code>--numeric-suffixes</code>：使用数字后缀替代字母后缀。</li>
<li><code>--additional-suffix=SUFFIX</code>：添加额外的后缀到输出文件。</li>
</ul>
<p><strong>示例：</strong></p>
<ol>
<li><p><strong>按字节大小拆分：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -b 1M largefile.txt smallfile</span><br></pre></td></tr></table></figure>
<p>这将把 <code>largefile.txt</code> 拆分成以 <code>smallfile</code> 为前缀的多个小文件，每个文件大小为 1MB。</p>
</li>
<li><p><strong>按行数拆分：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -l 1000 largefile.txt smallfile</span><br></pre></td></tr></table></figure>
<p>这将把 <code>largefile.txt</code> 拆分成以 <code>smallfile</code> 为前缀的多个小文件，每个文件包含 1000 行。</p>
</li>
<li><p><strong>设置输出文件后缀长度：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -b 1M -a 3 largefile.txt smallfile</span><br></pre></td></tr></table></figure>
<p>在这个例子中，输出文件的后缀长度为 3。</p>
</li>
<li><p><strong>使用数字后缀：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -l 500 --numeric-suffixes largefile.txt smallfile</span><br></pre></td></tr></table></figure>
<p>这将使用数字后缀而不是默认的字母后缀。</p>
</li>
<li><p><strong>添加额外的后缀：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -l 500 --numeric-suffixes --additional-suffix=.txt largefile.txt smallfile</span><br></pre></td></tr></table></figure>
<p>这将使用数字后缀，并且每个输出文件都会以 <code>.txt</code> 结尾。</p>
</li>
</ol>
<p><strong>注意：</strong> 如果没有指定输出文件前缀，<code>split</code> 默认使用 <code>x</code> 作为前缀。</p>
<p><code>split</code> 命令非常适用于需要将大文件拆分成小块以便于处理或传输的情况。</p>
<h2 id="linux-split命令-常用技巧"><a href="#linux-split命令-常用技巧" class="headerlink" title="linux split命令 常用技巧"></a>linux split命令 常用技巧</h2><p>以下是在使用 <code>split</code> 命令时的一些常用技巧：</p>
<ol>
<li><p><strong>按大小拆分文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -b 1G largefile.txt smallfile</span><br></pre></td></tr></table></figure>
<p>这将把 <code>largefile.txt</code> 拆分成以 <code>smallfile</code> 为前缀的多个小文件，每个文件大小为 1GB。</p>
</li>
<li><p><strong>按行数拆分文件并指定文件前缀：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -l 1000 -d -a 3 -t <span class="string">&quot; &quot;</span> largefile.txt data_</span><br></pre></td></tr></table></figure>
<p>这将把 <code>largefile.txt</code> 按照每行 1000 行进行拆分，使用三位数字后缀，并以 <code>data_</code> 为前缀。</p>
</li>
<li><p><strong>自定义文件名后缀：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -l 500 --numeric-suffixes --additional-suffix=.part largefile.txt smallfile</span><br></pre></td></tr></table></figure>
<p>这将使用数字后缀，并且每个输出文件都会以 <code>.part</code> 结尾。</p>
</li>
<li><p><strong>跳过前几行：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n +100 largefile.txt | <span class="built_in">split</span> -l 500 --numeric-suffixes - smallfile</span><br></pre></td></tr></table></figure>
<p>这将跳过文件的前 100 行，然后将其余的内容按行拆分。</p>
</li>
<li><p><strong>使用 <code>cat</code> 连接文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> smallfile* &gt; combinedfile.txt</span><br></pre></td></tr></table></figure>
<p>这将使用 <code>cat</code> 命令将以 <code>smallfile</code> 为前缀的所有小文件连接成一个大文件。</p>
</li>
<li><p><strong>使用 <code>find</code> 来拆分多个文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.log&quot;</span> -<span class="built_in">exec</span> <span class="built_in">split</span> -l 1000 --numeric-suffixes &#123;&#125; &#123;&#125;.part \;</span><br></pre></td></tr></table></figure>
<p>这将在当前目录及其子目录中找到所有以 <code>.log</code> 结尾的文件，并将每个文件按行数拆分成小文件。</p>
</li>
</ol>
<p>这些技巧可以根据具体需求帮助你更灵活地使用 <code>split</code> 命令来处理大文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_23_lsmod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_23_lsmod/" class="post-title-link" itemprop="url">linux_2_23_lsmod</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>lsmod命令</li>
</ul>
<h2 id="lsmod"><a href="#lsmod" class="headerlink" title="lsmod"></a>lsmod</h2><!-- + lsmod - Show the status of modules in the Linux Kernel -->

<p>在Linux中，<code>lsmod</code>命令用于列出当前加载的内核模块。内核模块是与内核相互独立的可加载程序，它们可以在运行时加载和卸载，以添加或删除特定的功能和驱动程序。</p>
<p>以下是<code>lsmod</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod</span><br></pre></td></tr></table></figure>

<p>使用<code>lsmod</code>命令时，它会直接输出已加载的内核模块的列表。每个模块的输出通常包括以下列：</p>
<ol>
<li>Module：内核模块的名称。</li>
<li>Size：模块在内存中的大小（以字节为单位）。</li>
<li>Used by：使用该模块的进程或其他模块的列表。</li>
</ol>
<p>例如，以下是<code>lsmod</code>命令的示例输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Module                 Size  Used by</span><br><span class="line">nls_utf8               16384  1</span><br><span class="line">isofs                  49152  1</span><br><span class="line">usb_storage            77824  1</span><br></pre></td></tr></table></figure>

<p>这个输出表示有三个内核模块被加载：<code>nls_utf8</code>、<code>isofs</code>和<code>usb_storage</code>。<code>nls_utf8</code>模块被一个进程或其他模块使用，<code>isofs</code>模块被一个进程或其他模块使用，而<code>usb_storage</code>模块仅被一个进程或其他模块使用。</p>
<p><code>lsmod</code>命令常用于查看当前系统中加载的内核模块，以及它们之间的依赖关系。它对于诊断和调试与内核模块相关的问题非常有用。</p>
<p>希望这个简要的解释对您有帮助。如有任何进一步的问题，请随时提问。</p>
<h2 id="linux-lsmod命令-详解"><a href="#linux-lsmod命令-详解" class="headerlink" title="linux lsmod命令 详解"></a>linux lsmod命令 详解</h2><p><code>lsmod</code> 是 Linux 系统中的一个命令，用于列出当前加载到内核的模块（kernel modules）的信息。以下是关于 <code>lsmod</code> 命令的详解：</p>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod</span><br></pre></td></tr></table></figure>

<h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h3><ul>
<li><code>lsmod</code> 命令用于显示当前加载的内核模块的信息，包括模块的名字、使用该模块的进程数量、模块的大小等信息。</li>
</ul>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p><code>lsmod</code> 输出的信息通常包含以下列：</p>
<ol>
<li><strong>Module：</strong> 内核模块的名称。</li>
<li><strong>Size：</strong> 模块占用的内存大小。</li>
<li><strong>Used by：</strong> 使用该模块的进程数量，以及进程的 PID。</li>
</ol>
<h3 id="示例输出："><a href="#示例输出：" class="headerlink" title="示例输出："></a>示例输出：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module                  Size  Used by</span><br><span class="line">nls_utf8               16384  1</span><br><span class="line">isofs                  45056  1</span><br><span class="line">vboxsf                 65536  2</span><br><span class="line">snd_intel8x0           40960  2</span><br><span class="line">snd_ac97_codec        139264  1 snd_intel8x0</span><br><span class="line">ac97_bus               16384  1 snd_ac97_codec</span><br><span class="line">snd_pcm               106496  2 snd_ac97_codec,snd_intel8x0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="解释输出信息："><a href="#解释输出信息：" class="headerlink" title="解释输出信息："></a>解释输出信息：</h3><ul>
<li><strong>Module：</strong> 模块的名称。</li>
<li><strong>Size：</strong> 模块占用的内存大小（以字节为单位）。</li>
<li><strong>Used by：</strong> 使用该模块的进程数量和进程的 PID。例如，”1” 表示有一个进程在使用该模块。</li>
</ul>
<h3 id="附加信息："><a href="#附加信息：" class="headerlink" title="附加信息："></a>附加信息：</h3><ul>
<li>如果 <code>lsmod</code> 命令未找到任何模块，输出将为空。</li>
<li>使用 <code>lsmod</code> 命令通常需要超级用户权限，因为它涉及到内核的信息。</li>
</ul>
<h3 id="相关命令："><a href="#相关命令：" class="headerlink" title="相关命令："></a>相关命令：</h3><ul>
<li><strong>modprobe：</strong> 用于加载、卸载、或查询模块的相关信息。</li>
<li><strong>lsmod：</strong> 显示已加载的模块。</li>
<li><strong>rmmod：</strong> 用于卸载已加载的模块。</li>
</ul>
<p>通过 <code>lsmod</code> 命令，你可以快速了解系统中哪些内核模块正在使用，以及它们的大小和被哪些进程所使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_20_mktemp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_20_mktemp/" class="post-title-link" itemprop="url">linux_2_20_mktemp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mktemp命令</li>
</ul>
<h2 id="mktemp"><a href="#mktemp" class="headerlink" title="mktemp"></a>mktemp</h2><ul>
<li>mktemp, 创建临时的文件或文件夹</li>
<li>参数：<ul>
<li><code>-d</code> , <code>--directory</code> : create a directory, not a file</li>
<li><code>-u</code> , <code>--dry-run</code>   : do not create anything; merely print a name(unsafe)</li>
<li><code>-q</code> , <code>--quiet</code>     : suppress diagnostics about file&#x2F;dir-creation failure</li>
</ul>
</li>
</ul>
<p>在Linux中，<code>mktemp</code>命令用于创建一个临时文件或临时目录，并返回其名称。临时文件和目录通常用于在脚本或程序中进行临时性的文件操作，并在使用完毕后自动删除。</p>
<p>以下是<code>mktemp</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mktemp [options] [template]</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code>是可选的一些选项，<code>template</code>是用于生成临时文件名的模板。</p>
<p>以下是一些常见的<code>mktemp</code>命令选项和用法：</p>
<ol>
<li><p>创建一个临时文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mktemp</span><br></pre></td></tr></table></figure>

<p>此命令将生成一个临时文件，并返回其完整的路径和文件名。</p>
</li>
<li><p>创建一个临时目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mktemp -d</span><br></pre></td></tr></table></figure>

<p>此命令将生成一个临时目录，并返回其完整的路径。</p>
</li>
<li><p>自定义临时文件名模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mktemp -t prefix.XXXXXX</span><br></pre></td></tr></table></figure>

<p>此命令将使用指定的前缀（<code>prefix</code>）和<code>XXXXXX</code>占位符作为模板生成临时文件名。<code>XXXXXX</code>将被自动生成的随机字符替换。</p>
</li>
<li><p>指定临时文件或目录所在的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mktemp -p directory</span><br></pre></td></tr></table></figure>

<p>此命令将在指定的目录（<code>directory</code>）中创建临时文件或目录。</p>
</li>
</ol>
<p><code>mktemp</code>命令还支持其他一些选项，如设置临时文件的权限、创建多个临时文件等。您可以使用<code>man mktemp</code>命令查看完整的选项和用法说明。</p>
<p>使用<code>mktemp</code>命令可以方便地创建临时文件或目录，避免手动管理和清理临时文件的麻烦。</p>
<h2 id="linux-mktemp命令-详解"><a href="#linux-mktemp命令-详解" class="headerlink" title="linux mktemp命令 详解"></a>linux mktemp命令 详解</h2><p><code>mktemp</code> 命令在 Linux 中用于创建临时文件或目录，其名称是唯一的，可以防止命名冲突。这在脚本编写或需要创建临时文件的情况下非常有用。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mktemp</span> [选项] [模板]</span><br></pre></td></tr></table></figure>

<p><strong>常见选项：</strong></p>
<ul>
<li><code>-d</code>：创建临时目录而不是文件。</li>
<li><code>-u</code>：生成临时文件或目录名称后，不创建它。</li>
</ul>
<p><strong>模板说明：</strong></p>
<ul>
<li>模板是一个包含 <code>X</code> 字符的字符串，<code>X</code> 字符会被替换为一个唯一的字符或数字。</li>
<li>模板的结尾可以是 <code>/</code>，以指定创建临时目录。</li>
</ul>
<p><strong>示例：</strong></p>
<ol>
<li><p><strong>创建临时文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tempfile=$(<span class="built_in">mktemp</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a temporary file.&quot;</span> &gt; <span class="string">&quot;<span class="variable">$tempfile</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建临时目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tempdir=$(<span class="built_in">mktemp</span> -d)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a temporary directory.&quot;</span> &gt; <span class="string">&quot;<span class="variable">$tempdir</span>/tempfile&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用模板创建临时文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tempfile=$(<span class="built_in">mktemp</span> temp_file_XXXXXX.txt)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a temporary file.&quot;</span> &gt; <span class="string">&quot;<span class="variable">$tempfile</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生成临时文件名但不创建：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tempname=$(<span class="built_in">mktemp</span> -u)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Generated unique temporary name: <span class="variable">$tempname</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建临时文件，但保留名称以供其他用途：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tempname=$(<span class="built_in">mktemp</span> -u /tmp/temp_file_XXXXXX.txt)</span><br><span class="line"><span class="built_in">touch</span> <span class="string">&quot;<span class="variable">$tempname</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This file will be retained with the name: <span class="variable">$tempname</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li><code>mktemp</code> 默认会在 <code>/tmp</code> 目录下创建临时文件或目录。可以通过设置 <code>TMPDIR</code> 环境变量来更改默认的临时目录。</li>
<li>在使用 <code>mktemp</code> 时，始终将结果保存到变量中，以避免竞态条件（race conditions）。</li>
</ul>
<p><code>mktemp</code> 是一个强大的工具，它可以确保在多个进程或脚本中创建的临时文件名不会发生冲突。</p>
<h2 id="linux-mktemp命令-常用技巧"><a href="#linux-mktemp命令-常用技巧" class="headerlink" title="linux mktemp命令 常用技巧"></a>linux mktemp命令 常用技巧</h2><p>以下是在使用 <code>mktemp</code> 命令时的一些常用技巧：</p>
<ol>
<li><p><strong>创建带有特定前缀或后缀的临时文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempfile=$(<span class="built_in">mktemp</span> myprefix_XXXXXX.txt)</span><br></pre></td></tr></table></figure>
<p>这将创建一个以 <code>myprefix_</code> 开头的临时文件，<code>XXXXXX</code> 部分由 <code>mktemp</code> 替换为唯一字符或数字。</p>
</li>
<li><p><strong>为创建的临时文件指定目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempfile=$(<span class="built_in">mktemp</span> -t -p /path/to/directory)</span><br></pre></td></tr></table></figure>
<p>使用 <code>-t</code> 选项并通过 <code>-p</code> 指定目录路径，可以在指定目录中创建临时文件。</p>
</li>
<li><p><strong>创建带有自定义模板的临时文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempfile=$(<span class="built_in">mktemp</span> -t mytemplate_XXXXXX.txt)</span><br></pre></td></tr></table></figure>
<p>在模板中使用 <code>X</code> 以外的字符，可以创建具有自定义名称的临时文件。</p>
</li>
<li><p><strong>创建临时目录并指定目录前缀：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempdir=$(<span class="built_in">mktemp</span> -d /tmp/mydir_XXXXXX)</span><br></pre></td></tr></table></figure>
<p>使用 <code>-d</code> 选项创建临时目录，并通过模板指定目录名。</p>
</li>
<li><p><strong>创建具有特定权限的临时文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempfile=$(<span class="built_in">mktemp</span> --tmpdir=/path/to/directory --mode=600)</span><br></pre></td></tr></table></figure>
<p>使用 <code>--mode</code> 选项可以指定临时文件的权限。在这个例子中，文件权限被设置为只有所有者可读可写。</p>
</li>
<li><p><strong>创建多个临时文件或目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span></span><br><span class="line">    tempfile=$(<span class="built_in">mktemp</span> -t temp_file_XXXXXX.txt)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;This is temporary file <span class="variable">$i</span>.&quot;</span> &gt; <span class="string">&quot;<span class="variable">$tempfile</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>使用循环可以方便地创建多个临时文件或目录。</p>
</li>
<li><p><strong>通过环境变量设置默认临时目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TMPDIR=/path/to/default/directory</span><br><span class="line">tempfile=$(<span class="built_in">mktemp</span>)</span><br></pre></td></tr></table></figure>
<p>通过设置 <code>TMPDIR</code> 环境变量，可以为 <code>mktemp</code> 命令设置默认的临时目录。</p>
</li>
<li><p><strong>创建带有随机元素的文件名：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempfile=$(<span class="built_in">mktemp</span> /tmp/myfile_$(<span class="built_in">date</span> +%s)_XXXXXX.txt)</span><br></pre></td></tr></table></figure>
<p>在文件名中加入随机元素，例如当前时间戳，以确保文件名的唯一性。</p>
</li>
</ol>
<p>这些技巧可以根据具体需求帮助你更灵活地使用 <code>mktemp</code> 命令创建临时文件或目录。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_26_tar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_26_tar/" class="post-title-link" itemprop="url">linux_2_26_tar</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>tar命令</li>
</ul>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><ul>
<li>解压文件:<code>tar -zxf filename -C destination-path</code></li>
<li>压缩文件:<code>tar -zcf filename</code></li>
</ul>
<h2 id="linux-tar命令-详解"><a href="#linux-tar命令-详解" class="headerlink" title="linux tar命令 详解"></a>linux tar命令 详解</h2><p><code>tar</code>是Linux系统中一个用于归档和压缩文件的命令行工具。它的名称来源于”tape archive”，最初设计是为了在磁带上创建备份。下面是<code>tar</code>命令的一些常见用法和参数：</p>
<h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] [文件或目录]</span><br></pre></td></tr></table></figure>

<h3 id="常见选项："><a href="#常见选项：" class="headerlink" title="常见选项："></a>常见选项：</h3><ol>
<li><p><strong>创建归档文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf archive.tar file1 file2 directory</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-c</code>: 创建归档文件。</li>
<li><code>-v</code>: 显示详细信息。</li>
<li><code>-f</code>: 指定归档文件的名称。</li>
</ul>
</li>
<li><p><strong>解压缩归档文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf archive.tar</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-x</code>: 解压缩归档文件。</li>
</ul>
</li>
<li><p><strong>查看归档文件内容：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf archive.tar</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-t</code>: 列出归档文件中的内容。</li>
</ul>
</li>
<li><p><strong>添加文件到已有归档文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -rvf archive.tar newfile</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-r</code>: 向已有归档文件中添加文件。</li>
</ul>
</li>
<li><p><strong>从归档中删除文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --delete -f archive.tar file1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--delete</code>: 从归档文件中删除文件。</li>
</ul>
</li>
<li><p><strong>指定工作目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -C /path/to/directory -xvf archive.tar</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-C</code>: 指定解压缩时的工作目录。</li>
</ul>
</li>
<li><p><strong>压缩归档文件（使用gzip）：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf archive.tar.gz directory</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-z</code>: 使用gzip进行压缩。</li>
</ul>
</li>
<li><p><strong>压缩归档文件（使用bzip2）：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cjvf archive.tar.bz2 directory</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-j</code>: 使用bzip2进行压缩。</li>
</ul>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><ul>
<li><p>创建归档文件并压缩：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf archive.tar.gz directory</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压缩压缩过的归档文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf archive.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看归档文件内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf archive.tar</span><br></pre></td></tr></table></figure></li>
</ul>
<p>请注意，<code>tar</code>命令的选项可能有所不同，具体取决于系统和<code>tar</code>版本。你可以使用<code>man tar</code>命令查看<code>tar</code>的手册页以获<br>取更详细的信息。</p>
<h2 id="linux-tar命令-常用技巧"><a href="#linux-tar命令-常用技巧" class="headerlink" title="linux tar命令 常用技巧"></a>linux tar命令 常用技巧</h2><p>在使用<code>tar</code>命令时，有一些常用的技巧和实用的选项，可以帮助你更有效地处理文件和目录。以下是一些常用的<code>tar</code>命令技巧：</p>
<ol>
<li><p><strong>压缩和解压缩：</strong></p>
<ul>
<li>压缩文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf archive.tar.gz file1 file2 directory</span><br></pre></td></tr></table></figure></li>
<li>解压缩文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf archive.tar.gz</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用不同的压缩算法：</strong></p>
<ul>
<li>使用bzip2进行压缩：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cjvf archive.tar.bz2 directory</span><br></pre></td></tr></table></figure></li>
<li>使用xz进行压缩：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cJvf archive.tar.xz directory</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>仅显示归档文件的内容而不解压缩：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf archive.tar</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>向归档文件添加新文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -rvf archive.tar newfile</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从归档文件中删除文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --delete -f archive.tar file1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建归档时排除特定文件或目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --exclude=pattern -cvf archive.tar directory</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>压缩归档文件时显示进度信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf - directory | pv &gt; archive.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pv</code>是一个用于显示数据流进度的命令。</li>
</ul>
</li>
<li><p><strong>在指定目录解压缩文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -C /path/to/destination -xvzf archive.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将归档文件从远程服务器传输到本地：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@remote <span class="string">&#x27;tar -czvf - directory&#x27;</span> | tar -xzvf -</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>仅解压缩归档文件的部分内容：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf archive.tar.gz --wildcards <span class="string">&#x27;*.txt&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>仅解压缩归档文件中扩展名为<code>.txt</code>的文件。</li>
</ul>
</li>
</ol>
<p>这些技巧可以帮助你更灵活地使用<code>tar</code>命令，提高在文件和目录处理方面的效率。记得查看<code>man tar</code>以获取更多详细信息。</p>
<h2 id="tar-1"><a href="#tar-1" class="headerlink" title="tar"></a>tar</h2><ul>
<li><p>tar(tape archive),命令用于备份文件</p>
</li>
<li><p>tar是用来建立,还原备份文件的工具程序,它可以加入,解开备份文件内的文件</p>
</li>
<li><p>tar命令 可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。</p>
</li>
<li><p>首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p>
</li>
<li><p>为什么要区分这两个概念呢？</p>
<ul>
<li>这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b &lt;区块数目&gt;][-C &lt;目的目录&gt;]</span><br><span class="line">    [-f &lt;备份文件&gt;][-F &lt;Script文件&gt;][-K &lt;文件&gt;][-L &lt;媒体容量&gt;][-N &lt;日期时间&gt;]</span><br><span class="line">    [-T &lt;范本文件&gt;][-V &lt;卷册名称&gt;][-X &lt;范本文件&gt;][-&lt;设备编号&gt;&lt;存储密度&gt;]</span><br><span class="line">    [--after-date=&lt;日期时间&gt;][--atime-preserve][--backuup=&lt;备份方式&gt;]</span><br><span class="line">    [--checkpoint][--concatenate][--confirmation][--delete]</span><br><span class="line">    [--exclude=&lt;范本样式&gt;][--force-local][--group=&lt;群组名称&gt;][--help]</span><br><span class="line">    [--ignore-failed-read][--new-volume-script=&lt;Script文件&gt;][--newer-mtime]</span><br><span class="line">    [--no-recursion][--null][--numeric-owner][--owner=&lt;用户名称&gt;][--posix]</span><br><span class="line">    [--erve][--preserve-order][--preserve-permissions]</span><br><span class="line">    [--record-size=&lt;区块数目&gt;][--recursive-unlink][--remove-files]</span><br><span class="line">    [--rsh-command=&lt;执行指令&gt;][--same-owner][--suffix=&lt;备份字尾字符串&gt;]</span><br><span class="line">    [--totals][--use-compress-program=&lt;执行指令&gt;][--version]</span><br><span class="line">    [--volno-file=&lt;编号文件&gt;][文件或目录...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项：</p>
<ul>
<li>-A或–catenate：新增文件到以存在的备份文件；</li>
<li>-b&lt;区块数目&gt;或–blocking-factor&#x3D;&lt;区块数目&gt;；</li>
<li>-B：设置区块大小；</li>
<li>-c或–create：建立新的备份文件；</li>
<li>-C &lt;目录&gt;：切换工作目录，先进入指定目录再执行压缩&#x2F;解压缩操作，可用于仅压缩特定目录里的内容或解压缩到特定目录</li>
<li>-d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。</li>
<li>-f&lt;备份文件&gt;或–file&#x3D;&lt;备份文件&gt; 指定备份文件。</li>
<li>-F&lt;Script文件&gt;或–info-script&#x3D;&lt;Script文件&gt; 每次更换磁带时，就执行指定的Script文件</li>
<li>-g或–listed-incremental 处理GNU格式的大量备份。</li>
<li>-G或–incremental 处理旧的GNU格式的大量备份。</li>
<li>-h或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。</li>
<li>-i或–ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。</li>
<li>-k或–keep-old-files 解开备份文件时，不覆盖已有的文件。</li>
<li>-K&lt;文件&gt;或–starting-file&#x3D;&lt;文件&gt; 从指定的文件开始还原。</li>
<li>-l或–one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制</li>
<li>-L&lt;媒体容量&gt;或-tape-length&#x3D;&lt;媒体容量&gt; 设置存放每体的容量，单位以1024 Bytes计算。</li>
<li>-m或–modification-time 还原文件时，不变更文件的更改时间。</li>
<li>-M或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li>
<li>-N&lt;日期格式&gt;或–newer&#x3D;&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。</li>
<li>-o或–old-archive或–portability 将资料写入备份文件时使用V7格式。</li>
<li>-O或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li>
<li>-p或–same-permissions 用原来的文件权限还原文件。</li>
<li>-P或–absolute-names 文件名使用绝对名称，不移除文件名称前的”&#x2F;”号。</li>
<li>-r或–append 新增文件到已存在的备份文件的结尾部分。</li>
<li>-R或–block-number 列出每个信息在备份文件中的区块编号。</li>
<li>-s或–same-order 还原文件的顺序和备份文件内的存放顺序相同。</li>
<li>-S或–sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li>
<li>-t或–list 列出备份文件的内容。</li>
<li>-T&lt;范本文件&gt;或–files-from&#x3D;&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li>
<li>-u或–update 仅置换较备份文件内的文件更新的文件。</li>
<li>-U或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。</li>
<li>-v或–verbose 显示指令执行过程。</li>
<li>-V&lt;卷册名称&gt;或–label&#x3D;&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。</li>
<li>-w或–interactive 遭遇问题时先询问用户。</li>
<li>-W或–verify 写入备份文件后，确认文件正确无误。</li>
<li>-x或–extract或–get：从备份文件中还原文件；</li>
<li>-t或–list：列出备份文件的内容；</li>
<li>-z或–gzip或–ungzip：通过gzip指令处理备份文件；</li>
<li>-Z或–compress或–uncompress：通过compress指令处理备份文件；</li>
<li>-&lt;设备编号&gt;&lt;存储密度&gt;  设置备份用的外围设备编号及存放数据的密度。</li>
<li>–after-date&#x3D;&lt;日期时间&gt; 此参数的效果和指定”-N”参数相同。</li>
<li>–atime-preserve 不变更文件的存取时间。</li>
<li>–backup&#x3D;&lt;备份方式&gt;或–backup 移除文件前先进行备份。</li>
<li>–checkpoint 读取备份文件时列出目录名称。</li>
<li>–concatenate 此参数的效果和指定”-A”参数相同。</li>
<li>–confirmation 此参数的效果和指定”-w”参数相同。</li>
<li>–delete 从备份文件中删除指定的文件。</li>
<li>–exclude&#x3D;&lt;范本样式&gt; 排除符合范本样式的问家。</li>
<li>–group&#x3D;&lt;群组名称&gt;  把加入设备文件中的文件的所属群组设成指定的群组。</li>
<li>–help 在线帮助。</li>
<li>–ignore-failed-read 忽略数据读取错误，不中断程序的执行。</li>
<li>–new-volume-script&#x3D;&lt;Script文件&gt;  此参数的效果和指定”-F”参数相同。</li>
<li>–newer-mtime 只保存更改过的文件。</li>
<li>–no-recursion  不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li>
<li>–null 从null设备读取文件名称。</li>
<li>–numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。</li>
<li>–owner&#x3D;&lt;用户名称&gt; 把加入备份文件中的文件的拥有者设成指定的用户。</li>
<li>–posix 将数据写入备份文件时使用POSIX格式。</li>
<li>–preserve 此参数的效果和指定”-ps”参数相同。</li>
<li>–preserve-order 此参数的效果和指定”-A”参数相同。</li>
<li>–preserve-permissions 此参数的效果和指定”-p”参数相同。</li>
<li>–record-size&#x3D;&lt;区块数目&gt; 此参数的效果和指定”-b”参数相同。</li>
<li>–recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li>
<li>–remove-files 文件加入备份文件后，就将其删除。</li>
<li>–rsh-command&#x3D;&lt;执行指令&gt; 设置要在远端主机上执行的指令，以取代rsh指令。</li>
<li>–same-owner 尝试以相同的文件拥有者还原问家你。</li>
<li>–suffix&#x3D;&lt;备份字尾字符串&gt; 移除文件前先行备份。</li>
<li>–totals 备份文件建立后，列出文件大小。</li>
<li>–use-compress-program&#x3D;&lt;执行指令&gt; 通过指定的指令处理备份文件。</li>
<li>–version 显示版本信息。</li>
<li>–volno-file&#x3D;&lt;编号文件&gt; 使用指定文件内的编号取代预设的卷册编号。</li>
</ul>
</li>
<li><p>参数：文件或目录：指定要打包的文件或目录列表。</p>
</li>
<li><p>实例：</p>
<ul>
<li><code>-z</code>：有gzip属性的</li>
<li><code>-j</code>：有bz2属性的</li>
<li><code>-Z</code>：有compress属性的</li>
<li><code>-v</code>：显示所有过程</li>
<li><code>-O</code>：将文件解开到标准输出</li>
</ul>
</li>
<li><p>下面的参数-f是必须的</p>
<ul>
<li>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tar -cf all.tar *.jpg</span><br><span class="line"># 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</span><br><span class="line"></span><br><span class="line">tar -rf all.tar *.gif</span><br><span class="line"># 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</span><br><span class="line"></span><br><span class="line">tar -uf all.tar logo.gif</span><br><span class="line"># 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</span><br><span class="line"></span><br><span class="line">tar -tf all.tar</span><br><span class="line"># 这条命令是列出all.tar包中所有文件，-t是列出文件的意思</span><br><span class="line"></span><br><span class="line">tar -cfv archive.tar foo bar  # 从文件foo和bar创建archive.tar。</span><br><span class="line">tar -tvf archive.tar         # 详细列出archive.tar中的所有文件。</span><br><span class="line">tar -xf archive.tar          # 从archive.tar提取所有文件。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>zip格式</p>
<ul>
<li>压缩： zip -r [目标文件名].zip [原文件&#x2F;目录名]</li>
<li>解压： unzip [原文件名].zip</li>
<li>注：-r参数代表递归</li>
</ul>
</li>
<li><p>tar格式（该格式仅仅打包，不压缩）</p>
<ul>
<li>打包：tar -cvf [目标文件名].tar [原文件名&#x2F;目录名]</li>
<li>解包：tar -xvf [原文件名].tar</li>
<li>注：c参数代表create（创建），x参数代表extract（解包），v参数代表verbose（详细信息），f参数代表filename（文件名），所以f后必须接文件名。</li>
</ul>
</li>
<li><p>tar.gz格式</p>
<ul>
<li>方式一：利用前面已经打包好的tar文件，直接用压缩命令。<ul>
<li>压缩：gzip [原文件名].tar</li>
<li>解压：gunzip [原文件名].tar.gz</li>
</ul>
</li>
<li>方式二：一次性打包并压缩、解压并解包<ul>
<li>打包并压缩： tar -zcvf [目标文件名].tar.gz [原文件名&#x2F;目录名]</li>
<li>解压并解包： tar -zxvf [原文件名].tar.gz</li>
<li>注：z代表用gzip算法来压缩&#x2F;解压。</li>
</ul>
</li>
</ul>
</li>
<li><p>tar.bz2格式</p>
<ul>
<li>方式一：利用已经打包好的tar文件，直接执行压缩命令：<ul>
<li>压缩：bzip2 [原文件名].tar</li>
<li>解压：bunzip2 [原文件名].tar.bz2</li>
</ul>
</li>
<li>方式二：一次性打包并压缩、解压并解包<ul>
<li>打包并压缩： tar -jcvf [目标文件名].tar.bz2 [原文件名&#x2F;目录名]</li>
<li>解压并解包： tar -jxvf [原文件名].tar.bz2</li>
<li>注：小写j代表用bzip2算法来压缩&#x2F;解压。</li>
</ul>
</li>
</ul>
</li>
<li><p>tar.xz格式</p>
<ul>
<li>方式一：利用已经打包好的tar文件，直接用压缩命令：<ul>
<li>压缩：xz [原文件名].tar</li>
<li>解压：unxz [原文件名].tar.xz</li>
</ul>
</li>
<li>方式二：一次性打包并压缩、解压并解包<ul>
<li>打包并压缩： tar -Jcvf [目标文件名].tar.xz [原文件名&#x2F;目录名]</li>
<li>解压并解包： tar -Jxvf [原文件名].tar.xz</li>
<li>注：大写J代表用xz算法来压缩&#x2F;解压。</li>
</ul>
</li>
</ul>
</li>
<li><p>jar格式</p>
<ul>
<li>压缩：jar -cvf [目标文件名].jar [原文件名&#x2F;目录名]</li>
<li>解压：jar -xvf [原文件名].jar</li>
</ul>
</li>
<li><p>7z格式</p>
<ul>
<li>压缩：7z a [目标文件名].7z [原文件名&#x2F;目录名]</li>
<li>解压：7z x [原文件名].7z</li>
<li>注：这个7z解压命令支持rar格式</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_24_screen/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_24_screen/" class="post-title-link" itemprop="url">linux_2_24_screen</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>screen命令</li>
</ul>
<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>在Linux中，<code>screen</code>命令用于创建和管理会话（session），它允许您在单个终端窗口中同时运行多个终端会话。<code>screen</code>命令提供了一种将会话分离和重新连接的机制，使您可以在需要时断开会话，并在稍后重新连接，而不会丢失会话的状态和进程。</p>
<p>以下是<code>screen</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen [options] [command [args]]</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code>是可选的一些选项，<code>command</code>是要运行的命令，<code>args</code>是传递给命令的参数。</p>
<p>以下是一些常见的<code>screen</code>命令选项和用法：</p>
<ol>
<li><p>创建新会话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure>

<p>此命令将创建一个新的<code>screen</code>会话。</p>
</li>
<li><p>列出所有会话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -ls</span><br></pre></td></tr></table></figure>

<p>此命令将列出所有已经存在的<code>screen</code>会话。</p>
</li>
<li><p>连接到会话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r session_id</span><br></pre></td></tr></table></figure>

<p>此命令将连接到指定的会话，<code>session_id</code>是会话的唯一标识符。</p>
</li>
<li><p>断开会话：<br>在<code>screen</code>会话中按下<code>Ctrl + A</code>，然后按下<code>d</code>键。</p>
<p>此命令将断开当前的<code>screen</code>会话，但会话仍在后台运行。</p>
</li>
<li><p>重新连接会话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r session_id</span><br></pre></td></tr></table></figure>

<p>此命令将重新连接之前断开的<code>screen</code>会话。</p>
</li>
<li><p>指定会话名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S session_name</span><br></pre></td></tr></table></figure>

<p>此命令将创建一个具有指定名称的<code>screen</code>会话。</p>
</li>
</ol>
<p><code>screen</code>命令还支持其他一些选项和操作，如分割窗口、滚动缓冲区、复制粘贴等。您可以使用<code>man screen</code>命令查看完整的选项和用法说明。</p>
<p><code>screen</code>命令对于在远程服务器上长时间运行的任务、会话的持久性以及同时管理多个终端会话非常有用。它提供了一种灵活和强大的方式来处理会话管理和终端复用。</p>
<h2 id="linux-screen命令-详解"><a href="#linux-screen命令-详解" class="headerlink" title="linux screen命令 详解"></a>linux screen命令 详解</h2><p><code>screen</code> 是一个在 Linux 系统中常用的终端复用工具，它允许用户在一个终端会话中创建多个窗口，并在这些窗口之间进行切换，同时还能够在后台运行进程。以下是关于 <code>screen</code> 命令的详解：</p>
<h3 id="1-安装-screen"><a href="#1-安装-screen" class="headerlink" title="1. 安装 screen"></a>1. 安装 <code>screen</code></h3><p>在大多数 Linux 发行版中，<code>screen</code> 已经预装。如果未安装，可以使用包管理工具进行安装：</p>
<ul>
<li>在 Debian&#x2F;Ubuntu 上：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install screen</span><br></pre></td></tr></table></figure>

<ul>
<li>在 Red Hat&#x2F;CentOS 上：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install screen</span><br></pre></td></tr></table></figure>

<h3 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a>2. 基本用法</h3><ul>
<li>启动 <code>screen</code> 会话：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建一个新窗口：按下 <code>Ctrl</code> + <code>A</code>，然后按下 <code>C</code>。</p>
</li>
<li><p>在窗口之间切换：按下 <code>Ctrl</code> + <code>A</code>，然后按下 <code>n</code>（下一个窗口）或 <code>p</code>（上一个窗口）。</p>
</li>
<li><p>分离会话：按下 <code>Ctrl</code> + <code>A</code>，然后按下 <code>d</code>。这会将 <code>screen</code> 会话放入后台，并保持运行。</p>
</li>
<li><p>重新连接会话：使用以下命令重新连接到 <code>screen</code> 会话：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r</span><br></pre></td></tr></table></figure>

<h3 id="3-高级用法"><a href="#3-高级用法" class="headerlink" title="3. 高级用法"></a>3. 高级用法</h3><ul>
<li>查看会话列表：可以使用以下命令查看所有 <code>screen</code> 会话：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -<span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重新连接到指定会话：如果有多个会话，可以使用以下命令重新连接到指定会话：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r &lt;session_id&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>给会话命名：在创建会话时，可以使用 <code>-S</code> 选项为会话指定一个名称：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S mysession</span><br></pre></td></tr></table></figure>

<p>然后可以使用以下命令重新连接到该会话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r mysession</span><br></pre></td></tr></table></figure>

<ul>
<li>查看帮助：按下 <code>Ctrl</code> + <code>A</code>，然后按下 <code>?</code>。</li>
</ul>
<h3 id="4-其他常用操作"><a href="#4-其他常用操作" class="headerlink" title="4. 其他常用操作"></a>4. 其他常用操作</h3><ul>
<li><p>关闭当前窗口：在窗口中执行 <code>exit</code> 或按下 <code>Ctrl</code> + <code>D</code>。</p>
</li>
<li><p>暂停和恢复滚动：按下 <code>Ctrl</code> + <code>A</code>，然后按下 <code>[</code> 进入滚动模式，按 <code>Space</code> 开始滚动，按 <code>Esc</code> 退出滚动模式。</p>
</li>
<li><p>在多用户模式下共享会话：可以在多个用户之间共享 <code>screen</code> 会话，具体用法可参考 <code>man screen</code> 中的说明。</p>
</li>
</ul>
<p>这些是 <code>screen</code> 命令的一些基本和高级用法，它是一个强大的工具，特别是在需要在远程服务器上长时间运行任务或会话的情况下。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_25_source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_25_source/" class="post-title-link" itemprop="url">linux_2_25_source</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>source命令</li>
</ul>
<h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><ul>
<li>source命令（从 C Shell而来）是<code>bash shell</code>的内置命令； <code>.</code> 点命令，就是一个点符号，是source的另一名称。这两个命令都以一个脚本为参数，该脚本将在当前shell的环境执行，即** 不会启动一个新的子shell** 。所有在脚本中设置的变量都将成为当前shell的一部分</li>
<li>source命令的妙用：<ul>
<li>在编译核心时，常常要反复输入一长串命令。这些命令即长又繁琐，而且有时候容易输错。</li>
<li>如果把命令做成一个文件，让它自动执行，对于需要多次反复编译核心的用户来说，会很方便</li>
<li>用source命令可以做到这一点。** 它的作用就是把一个文件的内容当成是shell来执行**</li>
</ul>
</li>
<li><code>source filename, sh filename, ./filename</code><ul>
<li>当shell脚本具有可执行权限时，用<code>sh filename</code>与<code>./filename</code>执行脚本没有区别。 <code>./filename</code>是因为当前目录没有在<code>PATH</code>, 所有<code>.</code> 都是用来表示当前目录的</li>
</ul>
</li>
</ul>
<p>在Linux中，<code>source</code>命令用于在当前Shell环境中执行指定的脚本文件，并将其内容加载到当前Shell会话中。它通常用于加载和执行Shell脚本，以便在当前Shell会话中设置环境变量、函数和其他Shell配置。</p>
<p>以下是<code>source</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source filename</span><br></pre></td></tr></table></figure>

<p>或者可以使用点号(<code>.</code>)来代替<code>source</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. filename</span><br></pre></td></tr></table></figure>

<p>其中，<code>filename</code>是要执行的脚本文件的名称，可以是相对路径或绝对路径。</p>
<p><code>source</code>命令的作用是将指定的脚本文件的内容作为当前Shell会话的一部分来执行，而不是在一个单独的子Shell中执行。这意味着在执行完脚本后，其中定义的变量、函数和别名将在当前Shell环境中保持可用。</p>
<p>使用<code>source</code>命令的一些常见用例包括：</p>
<ol>
<li><p>加载Shell配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>此命令将加载用户主目录下的<code>.bashrc</code>文件中定义的配置，使得配置的环境变量、别名等在当前Shell会话中生效。</p>
</li>
<li><p>执行Shell脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source script.sh</span><br></pre></td></tr></table></figure>

<p>此命令将执行<code>script.sh</code>脚本文件，并将脚本中的内容加载到当前Shell环境中。</p>
</li>
</ol>
<p>需要注意的是，<code>source</code>命令是在当前Shell环境中执行脚本，因此需要确保脚本文件具有可执行权限。</p>
<p>使用<code>source</code>命令可以方便地在当前Shell会话中加载和执行脚本文件，将脚本中定义的变量、函数和其他配置设置直接应用于当前环境。</p>
<h2 id="linux-source命令-详解"><a href="#linux-source命令-详解" class="headerlink" title="linux source命令 详解"></a>linux source命令 详解</h2><p><code>source</code> 命令是在 Bash（Bourne Again SHell）中使用的一个内置命令，它用于在当前 Shell 环境中执行指定脚本文件，通常是用来加载配置文件或者在当前 Shell 环境中应用一些设置。以下是关于 <code>source</code> 命令的详细解释：</p>
<h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><p><code>source</code> 命令的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> filename</span><br></pre></td></tr></table></figure>

<p>或者使用缩写形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. filename</span><br></pre></td></tr></table></figure>

<p>其中 <code>filename</code> 是要执行的脚本文件的路径。</p>
<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><p><code>source</code> 的主要作用是在当前 Shell 环境中运行指定的脚本，而不是创建一个新的子 Shell 来执行脚本。这与直接运行脚本的区别在于，直接运行脚本会在一个新的子 Shell 中执行，而 <code>source</code> 会在当前 Shell 环境中执行，因此它可以影响当前 Shell 的环境变量和状态。</p>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><ul>
<li><strong>加载配置文件：</strong> 常见的用法是在登录时加载用户的配置文件，比如 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 文件。这样，用户定义的环境变量、别名和函数将在登录后的每个 Shell 会话中生效。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>应用设置和变更：</strong> 当你修改了一个 Shell 脚本或配置文件，并希望立即应用这些变更而不用关闭当前的 Shell 会话时，可以使用 <code>source</code> 命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> myscript.sh</span><br></pre></td></tr></table></figure>

<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul>
<li><p><strong>点号 <code>.</code> 与 <code>source</code> 的等价性：</strong> 在 Bash 中，<code>.</code>（点号）和 <code>source</code> 是等价的，它们都用于执行脚本文件。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. myscript.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件路径：</strong> 如果文件路径中包含空格，最好将路径用引号括起来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">&quot;path with spaces/myscript.sh&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>退出状态：</strong> 如果脚本执行成功，<code>source</code> 命令将返回 0；如果出现错误，返回非零值。</p>
</li>
</ul>
<h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h3><p>假设有一个脚本文件 <code>myscript.sh</code> 包含以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myscript.sh</span></span><br><span class="line"><span class="built_in">export</span> MY_VARIABLE=<span class="string">&quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>source</code> 命令应用该脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> myscript.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$MY_VARIABLE</span></span><br></pre></td></tr></table></figure>

<p>上述代码执行后，<code>$MY_VARIABLE</code> 将在当前 Shell 中生效，并输出 “Hello, World!”。</p>
<p>总的来说，<code>source</code> 命令是一个方便的工具，用于在当前 Shell 环境中执行脚本，使得对环境变量和设置的修改能够立即生效。</p>
<h2 id="linux-source命令-详解-1"><a href="#linux-source命令-详解-1" class="headerlink" title="linux source命令 详解"></a>linux source命令 详解</h2><p><code>source</code> 命令用于在当前 Shell 环境中执行指定的脚本文件，通常用于加载配置文件或在当前 Shell 中应用一些设置。在 Bash 中，<code>.</code>（点号）也可以用于执行脚本文件，它与 <code>source</code> 是等价的。以下是关于 <code>source</code> 命令的详细解释：</p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> filename [arguments]</span><br></pre></td></tr></table></figure>

<p>或者使用点号的缩写形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. filename [arguments]</span><br></pre></td></tr></table></figure>

<p>其中，<code>filename</code> 是脚本文件的路径，而 <code>arguments</code> 是传递给脚本的参数。</p>
<h3 id="2-作用-1"><a href="#2-作用-1" class="headerlink" title="2. 作用"></a>2. 作用</h3><p><code>source</code> 命令的主要作用是在当前 Shell 环境中运行指定的脚本，而不是创建一个新的子 Shell。这意味着脚本中的变量、函数和其他环境设置将直接影响当前 Shell。</p>
<h3 id="3-使用场景-1"><a href="#3-使用场景-1" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><ul>
<li><p><strong>加载配置文件：</strong> 常见的用法是在登录时加载用户的配置文件，例如 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 文件。通过 <code>source</code> 命令，用户定义的环境变量、别名和函数将在每个新的 Shell 会话中生效。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>应用设置和变更：</strong> 当修改了一个 Shell 脚本或配置文件，并希望立即应用这些变更而不用重新启动 Shell 时，可以使用 <code>source</code> 命令。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> myscript.sh</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-注意事项-1"><a href="#4-注意事项-1" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul>
<li><p><strong>点号 <code>.</code> 与 <code>source</code> 的等价性：</strong> 在 Bash 中，<code>.</code>（点号）和 <code>source</code> 是等价的，它们都用于执行脚本文件。例如：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. myscript.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件路径中的空格：</strong> 如果文件路径中包含空格，最好将路径用引号括起来。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">&quot;path with spaces/myscript.sh&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>退出状态：</strong> 如果脚本执行成功，<code>source</code> 命令将返回 0；如果出现错误，返回非零值。</p>
</li>
</ul>
<h3 id="5-示例-1"><a href="#5-示例-1" class="headerlink" title="5. 示例"></a>5. 示例</h3><p>假设有一个脚本文件 <code>myscript.sh</code> 包含以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myscript.sh</span></span><br><span class="line"><span class="built_in">export</span> MY_VARIABLE=<span class="string">&quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>source</code> 命令应用该脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> myscript.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$MY_VARIABLE</span></span><br></pre></td></tr></table></figure>

<p>上述代码执行后，<code>$MY_VARIABLE</code> 将在当前 Shell 中生效，并输出 “Hello, World!”。</p>
<p>总的来说，<code>source</code> 命令是一个有用的工具，特别是在需要在当前 Shell 中应用配置或设置时，可以确保变量和环境的改变在当前 Shell 中生效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_28_useradd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-05-22-linux_2_28_useradd/" class="post-title-link" itemprop="url">linux_2_28_useradd</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>userdata命令</li>
</ul>
<h2 id="linux-useradd命令-详解"><a href="#linux-useradd命令-详解" class="headerlink" title="linux useradd命令 详解"></a>linux useradd命令 详解</h2><p><code>useradd</code>命令用于在Linux系统中创建新用户。它可以通过命令行提供一系列选项和参数来配置新用户的属性。以下是<code>useradd</code>命令的基本语法和一些常见选项：</p>
<h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [选项] 用户名</span><br></pre></td></tr></table></figure>

<h3 id="常见选项："><a href="#常见选项：" class="headerlink" title="常见选项："></a>常见选项：</h3><ol>
<li><p><strong>指定用户家目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -d /home/newuser newuser</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-m</code>: 创建用户的家目录。</li>
<li><code>-d</code>: 指定用户的家目录路径。</li>
</ul>
</li>
<li><p><strong>指定用户ID（UID）：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -u 1001 newuser</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-u</code>: 指定用户ID。</li>
</ul>
</li>
<li><p><strong>指定初始登录Shell：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -s /bin/bash newuser</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-s</code>: 指定初始登录Shell。</li>
</ul>
</li>
<li><p><strong>指定用户组：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -g <span class="built_in">users</span> newuser</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-g</code>: 指定用户的主组。</li>
</ul>
</li>
<li><p><strong>指定附加组：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -G wheel,ftp newuser</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-G</code>: 指定用户的附加组。</li>
</ul>
</li>
<li><p><strong>设置用户密码：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd newuser</span><br></pre></td></tr></table></figure>
<p>使用<code>passwd</code>命令为新用户设置密码。</p>
</li>
<li><p><strong>强制用户在首次登录时修改密码：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -e 2023-01-31 newuser</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-e</code>: 指定过期日期。</li>
</ul>
</li>
<li><p><strong>创建系统用户：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -r sysuser</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-r</code>: 创建系统用户。</li>
</ul>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><ul>
<li><p>创建一个新用户并设置密码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd newuser</span><br><span class="line">passwd newuser</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户时指定用户ID、初始Shell和主组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -u 1001 -s /bin/bash -g <span class="built_in">users</span> newuser</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建系统用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -r sysuser</span><br></pre></td></tr></table></figure></li>
</ul>
<p>请注意，使用<code>useradd</code>仅会创建用户，如果你需要为新用户分配文件访问权限，可能还需要使用<code>chown</code>和<code>chmod</code>等命令。要了解更多选项和详细信息，可以查看<code>man useradd</code>。</p>
<h2 id="linux-useradd命令-常用技巧"><a href="#linux-useradd命令-常用技巧" class="headerlink" title="linux useradd命令 常用技巧"></a>linux useradd命令 常用技巧</h2><p>在使用<code>useradd</code>命令时，有一些常用的技巧和选项，可以帮助你更灵活地创建和管理用户。以下是一些常见的<code>useradd</code>命令技巧：</p>
<ol>
<li><p><strong>一次性设置多个用户：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd user1 user2 user3</span><br></pre></td></tr></table></figure>
<p>可以在一条命令中一次性创建多个用户。</p>
</li>
<li><p><strong>使用<code>-m</code>选项创建用户的家目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -m newuser</span><br></pre></td></tr></table></figure>
<p><code>-m</code>选项将会为新用户创建一个家目录。</p>
</li>
<li><p><strong>指定用户ID（UID）：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -u 1001 newuser</span><br></pre></td></tr></table></figure>
<p>使用<code>-u</code>选项可以为用户指定特定的用户ID。</p>
</li>
<li><p><strong>指定用户组：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -g <span class="built_in">users</span> newuser</span><br></pre></td></tr></table></figure>
<p>使用<code>-g</code>选项可以指定新用户的主组。</p>
</li>
<li><p><strong>添加用户到多个附加组：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -G wheel,ftp newuser</span><br></pre></td></tr></table></figure>
<p>使用<code>-G</code>选项可以为用户指定多个附加组。</p>
</li>
<li><p><strong>指定用户的登录Shell：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -s /bin/bash newuser</span><br></pre></td></tr></table></figure>
<p>使用<code>-s</code>选项可以为用户指定初始登录Shell。</p>
</li>
<li><p><strong>创建系统用户：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -r sysuser</span><br></pre></td></tr></table></figure>
<p>使用<code>-r</code>选项可以创建系统用户，这样系统用户将没有家目录，通常用于运行服务的用户。</p>
</li>
<li><p><strong>创建用户并设置过期日期：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -e 2023-01-31 newuser</span><br></pre></td></tr></table></figure>
<p>使用<code>-e</code>选项可以设置用户的过期日期，用户在首次登录时需要修改密码。</p>
</li>
<li><p><strong>创建用户时强制指定密码：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -p $(openssl passwd -crypt mypassword) newuser</span><br></pre></td></tr></table></figure>
<p>使用<code>-p</code>选项可以指定经过加密的密码。上例中使用<code>openssl passwd -crypt</code>生成加密的密码。</p>
</li>
<li><p><strong>禁用新用户的登录权限：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -M newuser</span><br></pre></td></tr></table></figure>
<p>使用<code>-M</code>选项可以创建用户，但不会为其创建家目录，也不会设置登录Shell，从而禁用其登录权限。</p>
</li>
</ol>
<p>这些技巧可以帮助你更好地使用<code>useradd</code>命令，根据具体需求创建和管理用户。确保仔细查看<code>man useradd</code>以了解更多详细信息。</p>
<h2 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h2><ul>
<li>useradd, 用于建立用户账号</li>
<li>useradd可用来建立用户账号,账号建好之后,再用passwd设定账号的密码,用userdel删除账号,</li>
<li>示例:<ul>
<li><code>useradd tt # 添加一般用户</code></li>
<li><code>useradd -g root tt  # 为添加的用户指定相应的用户组</code></li>
<li><code>useradd -r tt  # 创建一个系统用户</code></li>
<li><code>useradd -d /home/myd tt  # 为新添加的用户指定home目录</code></li>
<li><code>useradd caojh -u 544  # 建立用户并制定id</code></li>
</ul>
</li>
</ul>
<p>在Linux中，<code>useradd</code>命令用于创建新用户账号。它是用于管理用户的基本命令之一。</p>
<p>以下是<code>useradd</code>命令的一般语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [options] username</span><br></pre></td></tr></table></figure>

<p>其中，<code>options</code>是可选的一些选项，<code>username</code>是要创建的新用户的用户名。</p>
<p>以下是一些常见的<code>useradd</code>命令选项和用法：</p>
<ol>
<li><p>创建新用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd username</span><br></pre></td></tr></table></figure>

<p>此命令将创建一个新用户账号，并使用指定的用户名。</p>
</li>
<li><p>指定用户ID（UID）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -u uid username</span><br></pre></td></tr></table></figure>

<p>此命令将为新用户指定一个特定的用户ID（UID）。如果未指定，系统会自动分配一个唯一的UID。</p>
</li>
<li><p>指定用户所属的初始组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -g groupname username</span><br></pre></td></tr></table></figure>

<p>此命令将指定新用户所属的初始组。如果未指定，将使用与用户名相同的组。</p>
</li>
<li><p>指定用户的主目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -d homedir username</span><br></pre></td></tr></table></figure>

<p>此命令将为新用户指定一个特定的主目录。如果未指定，系统将创建一个与用户名相同的目录。</p>
</li>
<li><p>创建用户并指定登录Shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -s shell username</span><br></pre></td></tr></table></figure>

<p>此命令将为新用户指定一个特定的登录Shell。如果未指定，将使用系统默认的Shell。</p>
</li>
</ol>
<p><code>useradd</code>命令还支持其他一些选项，如设置用户的密码、指定用户的备注信息等。您可以使用<code>man useradd</code>命令查看完整的选项和用法说明。</p>
<p>请注意，使用<code>useradd</code>命令仅创建用户账号，不会自动创建密码或设置用户的权限和访问控制。您可能需要使用其他命令，如<code>passwd</code>和<code>usermod</code>，来设置密码和修改用户的属性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/25/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/27/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
