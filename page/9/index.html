<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/9/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/11/notebook/Compiler/LLVM/2024-12-11-clang-format/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/11/notebook/Compiler/LLVM/2024-12-11-clang-format/" class="post-title-link" itemprop="url">Clang-Format</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-11 09:00:00" itemprop="dateCreated datePublished" datetime="2024-12-11T09:00:00+08:00">2024-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="clang-format-是什么"><a href="#clang-format-是什么" class="headerlink" title="clang-format 是什么"></a>clang-format 是什么</h2><p><strong><code>clang-format</code></strong> 是一款由 LLVM 项目开发的代码格式化工具，用于自动格式化 C、C++、JavaScript、Objective-C、C# 等多种语言的源代码。它是开发者用于统一代码风格的高效工具，尤其适用于大型团队和项目。</p>
<hr>
<h3 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a><strong>功能特点</strong></h3><ol>
<li><p><strong>自动化代码格式化</strong><br><code>clang-format</code> 根据指定的格式规则（如缩进、空格、括号对齐）对代码进行调整，无需手动修改。</p>
</li>
<li><p><strong>支持多种配置</strong><br>使用 <code>.clang-format</code> 配置文件或命令行选项自定义规则。支持的规则包括：</p>
<ul>
<li>缩进宽度</li>
<li>括号的换行位置</li>
<li>操作符的对齐方式</li>
</ul>
</li>
<li><p><strong>支持集成开发环境 (IDE)</strong>  </p>
<ul>
<li>可以与主流 IDE（如 Visual Studio、VS Code、CLion 等）集成，提供即时格式化功能。</li>
<li>常用于 Git hook 自动格式化提交代码。</li>
</ul>
</li>
<li><p><strong>格式化范围灵活</strong>  </p>
<ul>
<li>可以格式化整个文件、指定的行范围，或者通过标准输入指定内容。</li>
</ul>
</li>
<li><p><strong>与版本控制配合</strong><br>可以使用 <code>git clang-format</code> 格式化特定的代码变更。</p>
</li>
</ol>
<hr>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><ul>
<li><p><strong>格式化文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format -i &lt;文件名&gt;</span><br></pre></td></tr></table></figure>
<p><code>-i</code> 参数表示直接修改文件。</p>
</li>
<li><p><strong>格式化部分代码：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format &lt; 文件名 &gt; 输出文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指定规则文件：</strong><br>使用 <code>.clang-format</code> 文件指定项目的格式化规则：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">Google</span></span><br><span class="line"><span class="attr">IndentWidth:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">ColumnLimit:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ol>
<li><strong>代码风格统一</strong>：在团队开发中避免因代码风格不一致导致的冲突。</li>
<li><strong>代码质量改进</strong>：提升代码可读性，减少代码审查的时间。</li>
<li><strong>快速代码格式调整</strong>：尤其适用于已有遗留代码的大规模格式化。</li>
</ol>
<hr>
<p>更多信息可参考：  </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ClangFormat.html">LLVM 官方文档</a>  </li>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/tree/main/clang/tools/clang-format">GitHub 项目页面</a></li>
</ul>
<h2 id="clang-format-常用参数-详解"><a href="#clang-format-常用参数-详解" class="headerlink" title="clang-format 常用参数 详解"></a>clang-format 常用参数 详解</h2><p><code>clang-format</code> 是一个强大的代码格式化工具，支持丰富的配置选项，以满足不同团队或项目的代码风格要求。以下是其常用参数及配置选项的详解：</p>
<hr>
<h3 id="命令行常用参数"><a href="#命令行常用参数" class="headerlink" title="命令行常用参数"></a><strong>命令行常用参数</strong></h3><ol>
<li><p><strong>基本操作</strong></p>
<ul>
<li><code>-i</code>: 直接修改原文件（in-place）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format -i example.cpp</span><br></pre></td></tr></table></figure></li>
<li><code>-style=&lt;style&gt;</code>: 指定格式风格，可以使用内置样式（如 <code>LLVM</code>, <code>Google</code>, <code>Chromium</code>）或自定义样式文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format -style=Google example.cpp</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>格式化范围</strong></p>
<ul>
<li><code>-lines=&lt;start&gt;:&lt;end&gt;</code>: 格式化指定行的代码。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format -lines=5:10 example.cpp</span><br></pre></td></tr></table></figure></li>
<li><code>-offset=&lt;offset&gt; -length=&lt;length&gt;</code>: 格式化指定偏移和长度的代码。</li>
</ul>
</li>
<li><p><strong>标准输入&#x2F;输出</strong></p>
<ul>
<li><code>-</code>: 从标准输入读取代码，格式化后输出到标准输出。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format - &lt; example.cpp &gt; formatted.cpp</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>其他参数</strong></p>
<ul>
<li><code>-dump-config</code>: 导出当前的 <code>.clang-format</code> 配置。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format -dump-config &gt; .clang-format</span><br></pre></td></tr></table></figure></li>
<li><code>-assume-filename=&lt;filename&gt;</code>: 假定文件名以便确定语言类型（如 <code>.cpp</code>, <code>.js</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="clang-format-配置文件常用选项"><a href="#clang-format-配置文件常用选项" class="headerlink" title=".clang-format 配置文件常用选项"></a><strong><code>.clang-format</code> 配置文件常用选项</strong></h3><p><code>.clang-format</code> 是一个 YAML 格式的文件，用于定义代码格式化规则。以下是常用选项：</p>
<h4 id="1-基础选项"><a href="#1-基础选项" class="headerlink" title="1. 基础选项"></a><strong>1. 基础选项</strong></h4><ul>
<li><p><code>BasedOnStyle</code>: 指定基础风格（<code>LLVM</code>, <code>Google</code>, <code>Chromium</code>, <code>Mozilla</code> 等）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">Google</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Language</code>: 指定语言（<code>Cpp</code>, <code>Java</code>, <code>JavaScript</code> 等）。</p>
</li>
</ul>
<h4 id="2-缩进与对齐"><a href="#2-缩进与对齐" class="headerlink" title="2. 缩进与对齐"></a><strong>2. 缩进与对齐</strong></h4><ul>
<li><p><code>IndentWidth</code>: 缩进的空格数。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">IndentWidth:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UseTab</code>: 是否使用 Tab 替代空格（<code>Never</code>, <code>ForIndentation</code>, <code>Always</code>）。</p>
</li>
<li><p><code>AlignConsecutiveAssignments</code>: 对齐连续的赋值语句。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">AlignConsecutiveAssignments:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-换行规则"><a href="#3-换行规则" class="headerlink" title="3. 换行规则"></a><strong>3. 换行规则</strong></h4><ul>
<li><p><code>ColumnLimit</code>: 每行代码的最大字符数。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ColumnLimit:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>BreakBeforeBraces</code>: 括号换行规则（<code>Attach</code>, <code>Linux</code>, <code>Allman</code>, <code>Stroustrup</code> 等）。</p>
</li>
</ul>
<h4 id="4-空格规则"><a href="#4-空格规则" class="headerlink" title="4. 空格规则"></a><strong>4. 空格规则</strong></h4><ul>
<li><p><code>SpaceBeforeParens</code>: 函数声明和调用括号前是否加空格。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SpaceBeforeParens:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SpacesInParentheses</code>: 括号内是否添加空格。</p>
</li>
</ul>
<h4 id="5-注释规则"><a href="#5-注释规则" class="headerlink" title="5. 注释规则"></a><strong>5. 注释规则</strong></h4><ul>
<li><code>SortIncludes</code>: 是否排序 include 语句。</li>
<li><code>ReflowComments</code>: 自动调整注释的行宽。</li>
</ul>
<hr>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a><strong>使用示例</strong></h3><ol>
<li><p>格式化整个项目代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.cpp&quot;</span> -o -name <span class="string">&quot;*.h&quot;</span> | xargs clang-format -i</span><br></pre></td></tr></table></figure>
</li>
<li><p>配合 Git，仅格式化改动的代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clang-format</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出当前项目的默认风格配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format -dump-config &gt; .clang-format</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="更多参考资料"><a href="#更多参考资料" class="headerlink" title="更多参考资料"></a><strong>更多参考资料</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ClangFormat.html">Clang-Format 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://zed0.co.uk/clang-format-configurator/">Clang-Format 配置样例</a></li>
</ul>
<p>如果需要帮助配置 <code>.clang-format</code>，请提供具体需求！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/10/notebook/Compiler/2024-12-10-msvc%E7%BC%96%E8%AF%91%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/10/notebook/Compiler/2024-12-10-msvc%E7%BC%96%E8%AF%91%E5%99%A8/" class="post-title-link" itemprop="url">MSVC编译器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-10 09:00:00" itemprop="dateCreated datePublished" datetime="2024-12-10T09:00:00+08:00">2024-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>windows下C++编程 相关学习笔记</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/12/10/notebook/Compiler/2024-12-10-msvc%E7%BC%96%E8%AF%91%E5%99%A8/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/03/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-12-03-python_3_pathlib%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/03/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-12-03-python_3_pathlib%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">python_3_pathlib模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-03 09:00:00" itemprop="dateCreated datePublished" datetime="2024-12-03T09:00:00+08:00">2024-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="python3-pathlib模块-详解"><a href="#python3-pathlib模块-详解" class="headerlink" title="python3 pathlib模块 详解"></a>python3 pathlib模块 详解</h2><p><code>pathlib</code> 是 Python 3.4 引入的标准库模块，用于处理文件和路径。它提供了面向对象的接口，简洁优雅，功能强大，是现代 Python 开发操作路径的推荐选择。</p>
<p>以下是对 <code>pathlib</code> 模块的详细介绍及用法：</p>
<hr>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h2><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br></pre></td></tr></table></figure>

<p><code>Path</code> 类是 <code>pathlib</code> 模块的核心。它抽象了不同操作系统文件路径的细节，支持跨平台操作。</p>
<hr>
<h2 id="2-创建-Path-对象"><a href="#2-创建-Path-对象" class="headerlink" title="2. 创建 Path 对象"></a><strong>2. 创建 <code>Path</code> 对象</strong></h2><h3 id="创建路径对象"><a href="#创建路径对象" class="headerlink" title="创建路径对象"></a>创建路径对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用字符串路径</span></span><br><span class="line">path = Path(<span class="string">&quot;/home/user/documents&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用相对路径</span></span><br><span class="line">relative_path = Path(<span class="string">&quot;documents/example.txt&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_dir = Path.cwd()</span><br><span class="line"><span class="built_in">print</span>(current_dir)</span><br></pre></td></tr></table></figure>

<h3 id="当前脚本所在目录"><a href="#当前脚本所在目录" class="headerlink" title="当前脚本所在目录"></a>当前脚本所在目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">script_dir = Path(__file__).resolve().parent</span><br><span class="line"><span class="built_in">print</span>(script_dir)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-路径的基本操作"><a href="#3-路径的基本操作" class="headerlink" title="3. 路径的基本操作"></a><strong>3. 路径的基本操作</strong></h2><h3 id="拼接路径"><a href="#拼接路径" class="headerlink" title="拼接路径"></a>拼接路径</h3><p>使用 <code>/</code> 运算符拼接路径，比字符串操作更简洁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user&quot;</span>) / <span class="string">&quot;documents&quot;</span> / <span class="string">&quot;example.txt&quot;</span></span><br><span class="line"><span class="built_in">print</span>(path)  <span class="comment"># 输出: /home/user/documents/example.txt</span></span><br></pre></td></tr></table></figure>

<h3 id="获取路径的父目录"><a href="#获取路径的父目录" class="headerlink" title="获取路径的父目录"></a>获取路径的父目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents/example.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(path.parent)  <span class="comment"># 输出: /home/user/documents</span></span><br></pre></td></tr></table></figure>

<h3 id="获取路径的各部分"><a href="#获取路径的各部分" class="headerlink" title="获取路径的各部分"></a>获取路径的各部分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents/example.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(path.name)       <span class="comment"># 输出: example.txt (文件名)</span></span><br><span class="line"><span class="built_in">print</span>(path.stem)       <span class="comment"># 输出: example (文件名去掉后缀)</span></span><br><span class="line"><span class="built_in">print</span>(path.suffix)     <span class="comment"># 输出: .txt (文件后缀)</span></span><br><span class="line"><span class="built_in">print</span>(path.parts)      <span class="comment"># 输出: (&#x27;/&#x27;, &#x27;home&#x27;, &#x27;user&#x27;, &#x27;documents&#x27;, &#x27;example.txt&#x27;)</span></span><br></pre></td></tr></table></figure>

<h3 id="判断路径类型"><a href="#判断路径类型" class="headerlink" title="判断路径类型"></a>判断路径类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents/example.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(path.is_file())  <span class="comment"># 检查是否是文件</span></span><br><span class="line"><span class="built_in">print</span>(path.is_dir())   <span class="comment"># 检查是否是目录</span></span><br></pre></td></tr></table></figure>

<h3 id="检查路径是否存在"><a href="#检查路径是否存在" class="headerlink" title="检查路径是否存在"></a>检查路径是否存在</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents/example.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(path.exists())  <span class="comment"># 检查路径是否存在</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-遍历目录"><a href="#4-遍历目录" class="headerlink" title="4. 遍历目录"></a><strong>4. 遍历目录</strong></h2><h3 id="遍历当前目录的文件和子目录"><a href="#遍历当前目录的文件和子目录" class="headerlink" title="遍历当前目录的文件和子目录"></a>遍历当前目录的文件和子目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> path.iterdir():</span><br><span class="line">    <span class="built_in">print</span>(item)  <span class="comment"># 输出目录下的文件和文件夹</span></span><br></pre></td></tr></table></figure>

<h3 id="递归遍历目录"><a href="#递归遍历目录" class="headerlink" title="递归遍历目录"></a>递归遍历目录</h3><p>使用 <code>glob()</code> 或 <code>rglob()</code> 查找符合模式的文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下所有 .txt 文件</span></span><br><span class="line"><span class="keyword">for</span> txt_file <span class="keyword">in</span> path.glob(<span class="string">&quot;*.txt&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(txt_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归查找所有 .txt 文件</span></span><br><span class="line"><span class="keyword">for</span> txt_file <span class="keyword">in</span> path.rglob(<span class="string">&quot;*.txt&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(txt_file)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5. 文件操作"></a><strong>5. 文件操作</strong></h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/new_folder&quot;</span>)</span><br><span class="line">path.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)  <span class="comment"># 创建目录，父目录不存在时自动创建</span></span><br></pre></td></tr></table></figure>

<h3 id="删除目录或文件"><a href="#删除目录或文件" class="headerlink" title="删除目录或文件"></a>删除目录或文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">file_path = Path(<span class="string">&quot;/home/user/example.txt&quot;</span>)</span><br><span class="line">file_path.unlink()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空目录</span></span><br><span class="line">dir_path = Path(<span class="string">&quot;/home/user/empty_folder&quot;</span>)</span><br><span class="line">dir_path.rmdir()</span><br></pre></td></tr></table></figure>

<h3 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_path = Path(<span class="string">&quot;/home/user/example.txt&quot;</span>)</span><br><span class="line">content = file_path.read_text(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>

<h3 id="写入文件内容"><a href="#写入文件内容" class="headerlink" title="写入文件内容"></a>写入文件内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_path = Path(<span class="string">&quot;/home/user/example.txt&quot;</span>)</span><br><span class="line">file_path.write_text(<span class="string">&quot;Hello, World!&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-路径比较"><a href="#6-路径比较" class="headerlink" title="6. 路径比较"></a><strong>6. 路径比较</strong></h2><p><code>pathlib</code> 支持路径的比较操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path1 = Path(<span class="string">&quot;/home/user/documents&quot;</span>)</span><br><span class="line">path2 = Path(<span class="string">&quot;/home/user/documents/example.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(path1 &lt; path2)  <span class="comment"># 比较路径字典序</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-高级功能"><a href="#7-高级功能" class="headerlink" title="7. 高级功能"></a><strong>7. 高级功能</strong></h2><h3 id="获取绝对路径"><a href="#获取绝对路径" class="headerlink" title="获取绝对路径"></a>获取绝对路径</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;documents/example.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(path.resolve())  <span class="comment"># 输出绝对路径</span></span><br></pre></td></tr></table></figure>

<h3 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_path = Path(<span class="string">&quot;/home/user/example.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(file_path.stat().st_size)  <span class="comment"># 文件大小（字节）</span></span><br></pre></td></tr></table></figure>

<h3 id="修改时间、创建时间等信息"><a href="#修改时间、创建时间等信息" class="headerlink" title="修改时间、创建时间等信息"></a>修改时间、创建时间等信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file_path = Path(<span class="string">&quot;/home/user/example.txt&quot;</span>)</span><br><span class="line">info = file_path.stat()</span><br><span class="line"><span class="built_in">print</span>(info.st_mtime)  <span class="comment"># 修改时间</span></span><br><span class="line"><span class="built_in">print</span>(info.st_ctime)  <span class="comment"># 创建时间</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-跨平台操作"><a href="#8-跨平台操作" class="headerlink" title="8. 跨平台操作"></a><strong>8. 跨平台操作</strong></h2><p><code>pathlib</code> 自动适配不同的操作系统，无需担心路径分隔符问题。<br>但如果需要明确使用 Windows 或 Posix 风格路径，可以使用 <code>PureWindowsPath</code> 或 <code>PurePosixPath</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> PureWindowsPath, PurePosixPath</span><br><span class="line"></span><br><span class="line">windows_path = PureWindowsPath(<span class="string">&quot;C:/Windows/System32&quot;</span>)</span><br><span class="line">posix_path = PurePosixPath(<span class="string">&quot;/home/user/documents&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-示例：批量重命名文件"><a href="#9-示例：批量重命名文件" class="headerlink" title="9. 示例：批量重命名文件"></a><strong>9. 示例：批量重命名文件</strong></h2><p>以下示例将目录下的所有 <code>.txt</code> 文件重命名为 <code>.bak</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&quot;/home/user/documents&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> path.glob(<span class="string">&quot;*.txt&quot;</span>):</span><br><span class="line">    new_name = file.with_suffix(<span class="string">&quot;.bak&quot;</span>)</span><br><span class="line">    file.rename(new_name)</span><br></pre></td></tr></table></figure>

<hr>
<p><code>pathlib</code> 模块非常强大且易于使用，大大简化了文件和路径操作。如需进一步扩展或解决特定问题，请告诉我！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/12/03/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-12-03-python_3_zipfile%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/03/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-12-03-python_3_zipfile%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">python_3_zipfile模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-03 09:00:00" itemprop="dateCreated datePublished" datetime="2024-12-03T09:00:00+08:00">2024-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="python3-zipfile模块-详解"><a href="#python3-zipfile模块-详解" class="headerlink" title="python3 zipfile模块 详解"></a>python3 zipfile模块 详解</h2><p>Python 的 <code>zipfile</code> 模块用于处理 ZIP 文件。它支持创建、读取、写入、添加和解压 ZIP 文件。以下是对 <code>zipfile</code> 模块的详细介绍和用法。</p>
<hr>
<h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. <strong>基本用法</strong></h3><h4 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-创建-ZIP-文件"><a href="#2-创建-ZIP-文件" class="headerlink" title="2. 创建 ZIP 文件"></a>2. <strong>创建 ZIP 文件</strong></h3><h4 id="创建一个新-ZIP-文件并写入内容"><a href="#创建一个新-ZIP-文件并写入内容" class="headerlink" title="创建一个新 ZIP 文件并写入内容"></a>创建一个新 ZIP 文件并写入内容</h4><ul>
<li>模式选项：<ul>
<li><code>&#39;w&#39;</code>：创建一个新文件（如果文件已存在，将覆盖）。</li>
<li><code>&#39;a&#39;</code>：添加到现有的 ZIP 文件中。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.write(<span class="string">&#x27;file1.txt&#x27;</span>)  <span class="comment"># 添加文件到 ZIP 中</span></span><br><span class="line">    zipf.write(<span class="string">&#x27;file2.txt&#x27;</span>, arcname=<span class="string">&#x27;renamed_file2.txt&#x27;</span>)  <span class="comment"># 指定压缩时的文件名</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-读取-ZIP-文件"><a href="#3-读取-ZIP-文件" class="headerlink" title="3. 读取 ZIP 文件"></a>3. <strong>读取 ZIP 文件</strong></h3><h4 id="列出-ZIP-文件中的内容"><a href="#列出-ZIP-文件中的内容" class="headerlink" title="列出 ZIP 文件中的内容"></a>列出 ZIP 文件中的内容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    <span class="built_in">print</span>(zipf.namelist())  <span class="comment"># 列出压缩包内所有文件和目录</span></span><br></pre></td></tr></table></figure>

<h4 id="读取文件信息"><a href="#读取文件信息" class="headerlink" title="读取文件信息"></a>读取文件信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    <span class="keyword">for</span> info <span class="keyword">in</span> zipf.infolist():</span><br><span class="line">        <span class="built_in">print</span>(info.filename, info.file_size, info.compress_size)</span><br></pre></td></tr></table></figure>

<h4 id="解压-ZIP-文件"><a href="#解压-ZIP-文件" class="headerlink" title="解压 ZIP 文件"></a>解压 ZIP 文件</h4><ul>
<li><p>解压到当前目录：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.extractall()  <span class="comment"># 解压到当前目录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解压到指定目录：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.extractall(<span class="string">&#x27;output_directory&#x27;</span>)  <span class="comment"># 解压到指定目录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解压单个文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.extract(<span class="string">&#x27;file1.txt&#x27;</span>, <span class="string">&#x27;output_directory&#x27;</span>)  <span class="comment"># 解压指定文件到目录</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-追加文件到-ZIP"><a href="#4-追加文件到-ZIP" class="headerlink" title="4. 追加文件到 ZIP"></a>4. <strong>追加文件到 ZIP</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.write(<span class="string">&#x27;new_file.txt&#x27;</span>, arcname=<span class="string">&#x27;folder/new_file.txt&#x27;</span>)  <span class="comment"># 指定路径</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-压缩和解压密码保护的-ZIP-文件"><a href="#5-压缩和解压密码保护的-ZIP-文件" class="headerlink" title="5. 压缩和解压密码保护的 ZIP 文件"></a>5. <strong>压缩和解压密码保护的 ZIP 文件</strong></h3><h4 id="压缩带密码的-ZIP"><a href="#压缩带密码的-ZIP" class="headerlink" title="压缩带密码的 ZIP"></a>压缩带密码的 ZIP</h4><p>Python 的 <code>zipfile</code> 本身不支持加密 ZIP 文件，但可以使用第三方库如 <code>pyminizip</code> 或 <code>zipfile_with_password</code>。</p>
<h4 id="解压带密码的-ZIP"><a href="#解压带密码的-ZIP" class="headerlink" title="解压带密码的 ZIP"></a>解压带密码的 ZIP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;protected.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.extractall(pwd=<span class="string">b&#x27;password&#x27;</span>)  <span class="comment"># 密码需要以字节形式提供</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-检查文件是否为-ZIP"><a href="#6-检查文件是否为-ZIP" class="headerlink" title="6. 检查文件是否为 ZIP"></a>6. <strong>检查文件是否为 ZIP</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> zipfile.is_zipfile(<span class="string">&#x27;example.zip&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;是一个有效的 ZIP 文件&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不是有效的 ZIP 文件&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-高级操作"><a href="#7-高级操作" class="headerlink" title="7. 高级操作"></a>7. <strong>高级操作</strong></h3><h4 id="获取压缩信息"><a href="#获取压缩信息" class="headerlink" title="获取压缩信息"></a>获取压缩信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    info = zipf.getinfo(<span class="string">&#x27;file1.txt&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(info.filename)</span><br><span class="line">    <span class="built_in">print</span>(info.compress_type)  <span class="comment"># 压缩方式</span></span><br><span class="line">    <span class="built_in">print</span>(info.file_size)      <span class="comment"># 原始大小</span></span><br><span class="line">    <span class="built_in">print</span>(info.compress_size)  <span class="comment"># 压缩后大小</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义压缩级别"><a href="#自定义压缩级别" class="headerlink" title="自定义压缩级别"></a>自定义压缩级别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;compressed.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, compression=zipfile.ZIP_DEFLATED, compresslevel=<span class="number">9</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">    zipf.write(<span class="string">&#x27;file1.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-支持的压缩类型"><a href="#8-支持的压缩类型" class="headerlink" title="8. 支持的压缩类型"></a>8. <strong>支持的压缩类型</strong></h3><ul>
<li><code>zipfile.ZIP_STORED</code>：不压缩。</li>
<li><code>zipfile.ZIP_DEFLATED</code>：标准压缩（需要 <code>zlib</code> 支持）。</li>
<li><code>zipfile.ZIP_BZIP2</code>：bzip2 压缩（需要 <code>bz2</code> 支持）。</li>
<li><code>zipfile.ZIP_LZMA</code>：LZMA 压缩（需要 <code>lzma</code> 支持）。</li>
</ul>
<hr>
<h3 id="9-完整示例：批量压缩文件"><a href="#9-完整示例：批量压缩文件" class="headerlink" title="9. 完整示例：批量压缩文件"></a>9. <strong>完整示例：批量压缩文件</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compress_directory</span>(<span class="params">dir_path, output_file</span>):</span><br><span class="line">    <span class="keyword">with</span> zipfile.ZipFile(output_file, <span class="string">&#x27;w&#x27;</span>, compression=zipfile.ZIP_DEFLATED) <span class="keyword">as</span> zipf:</span><br><span class="line">        <span class="keyword">for</span> foldername, subfolders, filenames <span class="keyword">in</span> os.walk(dir_path):</span><br><span class="line">            <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">                file_path = os.path.join(foldername, filename)</span><br><span class="line">                arcname = os.path.relpath(file_path, dir_path)</span><br><span class="line">                zipf.write(file_path, arcname)</span><br><span class="line"></span><br><span class="line">compress_directory(<span class="string">&#x27;my_folder&#x27;</span>, <span class="string">&#x27;archive.zip&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10-完整示例：批量解压-ZIP-文件"><a href="#10-完整示例：批量解压-ZIP-文件" class="headerlink" title="10. 完整示例：批量解压 ZIP 文件"></a>10. <strong>完整示例：批量解压 ZIP 文件</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_all</span>(<span class="params">zip_file, output_dir</span>):</span><br><span class="line">    <span class="keyword">with</span> zipfile.ZipFile(zip_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> zipf:</span><br><span class="line">        zipf.extractall(output_dir)</span><br><span class="line"></span><br><span class="line">extract_all(<span class="string">&#x27;archive.zip&#x27;</span>, <span class="string">&#x27;extracted_files&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>希望这些内容能帮助你全面理解 <code>zipfile</code> 模块！如需更详细的实例或功能扩展，请告诉我。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/20/notebook/Webfrontend/2024-11-20-HTML%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/20/notebook/Webfrontend/2024-11-20-HTML%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">HTML常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-20 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-20T09:00:00+08:00">2024-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Webfrontend/" itemprop="url" rel="index"><span itemprop="name">Webfrontend</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="html-实现分割线效果"><a href="#html-实现分割线效果" class="headerlink" title="html 实现分割线效果"></a>html 实现分割线效果</h2><p>在 HTML 中，分割线可以通过以下方式实现：</p>
<hr>
<h3 id="1-使用-标签"><a href="#1-使用-标签" class="headerlink" title="1. 使用 &lt;hr&gt; 标签"></a>1. <strong>使用 <code>&lt;hr&gt;</code> 标签</strong></h3><p><code>&lt;hr&gt;</code> 是 HTML 提供的默认分割线标签。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第一段文字。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第二段文字。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><ul>
<li>默认生成一条水平分割线，占据页面的宽度。</li>
</ul>
<hr>
<h3 id="2-自定义分割线样式"><a href="#2-自定义分割线样式" class="headerlink" title="2. 自定义分割线样式"></a>2. <strong>自定义分割线样式</strong></h3><p>可以通过 CSS 自定义 <code>&lt;hr&gt;</code> 的样式，例如颜色、宽度、边框样式等。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;border: none; border-top: 2px solid #0078d7; width: 50%; margin: 20px auto;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="属性说明"><a href="#属性说明" class="headerlink" title="属性说明"></a>属性说明</h4><ul>
<li><strong><code>border: none;</code></strong> 去除默认边框。</li>
<li><strong><code>border-top: 2px solid #0078d7;</code></strong> 自定义分割线样式（颜色和粗细）。</li>
<li><strong><code>width: 50%;</code></strong> 设置分割线宽度。</li>
<li><strong><code>margin: 20px auto;</code></strong> 设置上下间距并居中。</li>
</ul>
<hr>
<h3 id="3-使用-CSS-before-或-after-创建分割线"><a href="#3-使用-CSS-before-或-after-创建分割线" class="headerlink" title="3. 使用 CSS :before 或 :after 创建分割线"></a>3. <strong>使用 CSS <code>:before</code> 或 <code>:after</code> 创建分割线</strong></h3><p>通过伪元素，分割线可以作为装饰效果使用。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center; position: relative; margin: 20px 0;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;background: white; padding: 0 10px; position: relative; z-index: 1;&quot;</span>&gt;</span>中间带文字的分割线<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;border: none; border-top: 1px solid #ccc; position: absolute; top: 50%; left: 0; width: 100%; z-index: 0;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><ul>
<li>在分割线中间插入文字。</li>
<li>利用伪元素或额外的 HTML 元素实现装饰效果。</li>
</ul>
<hr>
<h3 id="4-带图标或装饰的分割线"><a href="#4-带图标或装饰的分割线" class="headerlink" title="4. 带图标或装饰的分割线"></a>4. <strong>带图标或装饰的分割线</strong></h3><p>可以将图片或图标结合分割线，增加美观效果。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center; margin: 20px 0;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;border: none; border-top: 1px solid #ccc; width: 40%; display: inline-block;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 24px; margin: 0 10px;&quot;</span>&gt;</span>⭐<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;border: none; border-top: 1px solid #ccc; width: 40%; display: inline-block;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h4><ul>
<li>分割线两端显示图标或文字。</li>
</ul>
<hr>
<h3 id="5-渐变色分割线"><a href="#5-渐变色分割线" class="headerlink" title="5. 渐变色分割线"></a>5. <strong>渐变色分割线</strong></h3><p>通过 CSS 渐变实现更现代的分割线效果。</p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;border: none; height: 2px; background: linear-gradient(to right, #ff7e5f, #feb47b);&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h4><ul>
<li>分割线有渐变色效果。</li>
<li><strong><code>height: 2px;</code></strong> 设置分割线的高度。</li>
</ul>
<hr>
<h3 id="6-波浪形分割线"><a href="#6-波浪形分割线" class="headerlink" title="6. 波浪形分割线"></a>6. <strong>波浪形分割线</strong></h3><p>通过 SVG 或图片制作波浪形分割线。</p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; overflow: hidden;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 1440 320&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">fill</span>=<span class="string">&quot;#0099ff&quot;</span> <span class="attr">fill-opacity</span>=<span class="string">&quot;1&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M0,128L40,122.7C80,117,160,107,240,112C320,117,400,139,480,160C560,181,640,203,720,213.3C800,224,880,224,960,218.7C1040,213,1120,203,1200,192C1280,181,1360,171,1400,165.3L1440,160L1440,320L1400,320C1360,320,1280,320,1200,320C1120,320,1040,320,960,320C880,320,800,320,720,320C640,320,560,320,480,320C400,320,320,320,240,320C160,320,80,320,40,320L0,320Z&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="效果-4"><a href="#效果-4" class="headerlink" title="效果"></a>效果</h4><ul>
<li>波浪形动态分割线。</li>
<li>使用 <code>&lt;svg&gt;</code> 绘制分割线形状，可自定义填充颜色和路径。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>简单需求可以直接使用 <code>&lt;hr&gt;</code>。</li>
<li>自定义样式时可以结合 CSS 修改颜色、宽度或添加装饰。</li>
<li>高级需求（如波浪或渐变）可以使用 CSS 或 SVG 实现。</li>
</ul>
<h2 id="html-加粗字体"><a href="#html-加粗字体" class="headerlink" title="html 加粗字体"></a>html 加粗字体</h2><p>在 HTML 中，可以使用以下方法来加粗字体：</p>
<hr>
<h3 id="1-使用-标签-1"><a href="#1-使用-标签-1" class="headerlink" title="1. 使用 &lt;b&gt; 标签"></a>1. <strong>使用 <code>&lt;b&gt;</code> 标签</strong></h3><p><code>&lt;b&gt;</code> 标签用于加粗文本，但不会传递语义信息，仅是视觉效果。</p>
<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段普通文本，<span class="tag">&lt;<span class="name">b</span>&gt;</span>这是加粗的文本<span class="tag">&lt;/<span class="name">b</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-使用-标签"><a href="#2-使用-标签" class="headerlink" title="2. 使用 &lt;strong&gt; 标签"></a>2. <strong>使用 <code>&lt;strong&gt;</code> 标签</strong></h3><p><code>&lt;strong&gt;</code> 标签不仅加粗文本，还会传递语义信息，表示该内容是重要的。</p>
<h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>请注意：<span class="tag">&lt;<span class="name">strong</span>&gt;</span>此操作不可撤销<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-使用内联样式"><a href="#3-使用内联样式" class="headerlink" title="3. 使用内联样式"></a>3. <strong>使用内联样式</strong></h3><p>通过 CSS 的 <code>font-weight</code> 属性实现加粗效果。</p>
<h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是普通文本，<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: bold;&quot;</span>&gt;</span>这是加粗的文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-定义全局样式"><a href="#4-定义全局样式" class="headerlink" title="4. 定义全局样式"></a>4. <strong>定义全局样式</strong></h3><p>在样式表中定义 <code>font-weight</code> 属性，灵活控制加粗效果。</p>
<h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.bold-text</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>普通文本，<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;bold-text&quot;</span>&gt;</span>加粗文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-调整字体粗细"><a href="#5-调整字体粗细" class="headerlink" title="5. 调整字体粗细"></a>5. <strong>调整字体粗细</strong></h3><p>通过 <code>font-weight</code> 属性，你可以指定不同程度的字体粗细，例如 100（细）到 900（粗）。</p>
<h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>字体粗细示例：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: 400;&quot;</span>&gt;</span>普通字体（400）。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: 700;&quot;</span>&gt;</span>加粗字体（700）。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: 900;&quot;</span>&gt;</span>超粗字体（900）。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-结合其他标签"><a href="#6-结合其他标签" class="headerlink" title="6. 结合其他标签"></a>6. <strong>结合其他标签</strong></h3><p>可以将加粗效果与其他标签一起使用，如标题标签。</p>
<h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一级标题（加粗）。<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>这是二级标题，使用<span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span>标签加粗。<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
<th>推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;b&gt;</code></td>
<td>仅加粗文本，无语义</td>
<td>仅需要视觉加粗的场景</td>
</tr>
<tr>
<td><code>&lt;strong&gt;</code></td>
<td>加粗文本，表示重要性</td>
<td>需要强调内容的场景</td>
</tr>
<tr>
<td><code>font-weight</code></td>
<td>CSS 样式，灵活控制粗细</td>
<td>自定义粗细的场景</td>
</tr>
<tr>
<td>样式类（class）</td>
<td>全局样式复用</td>
<td>需要一致样式的场景</td>
</tr>
</tbody></table>
<p>根据需求选择适合的加粗方式！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/20/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-20-09-QWidget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/20/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-20-09-QWidget/" class="post-title-link" itemprop="url">QWidget</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-20 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-20T09:00:00+08:00">2024-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-Qt-QWidget-setStyleSheet-函数-详解"><a href="#C-Qt-QWidget-setStyleSheet-函数-详解" class="headerlink" title="C++ Qt QWidget::setStyleSheet()函数 详解"></a>C++ Qt QWidget::setStyleSheet()函数 详解</h2><p><code>QWidget::setStyleSheet()</code> 是 Qt 中用于设置控件样式表的函数，它允许开发者通过样式表（类似 CSS 的语法）自定义 Qt 控件的外观和行为。以下是对该函数的详细说明：</p>
<hr>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a><strong>函数定义</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setStyleSheet</span><span class="params">(<span class="type">const</span> QString &amp;styleSheet)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数</strong>:  <ul>
<li><code>styleSheet</code> 是一个包含样式表定义的字符串。</li>
</ul>
</li>
<li><strong>功能</strong>:  <ul>
<li>为控件设置或更改样式。</li>
<li>如果传入空字符串，则清除控件的样式表。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><p>使用 <code>setStyleSheet()</code> 可以方便地修改控件的外观。以下是一些常见的使用场景：</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Click Me&quot;</span>);</span><br><span class="line">button-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightblue; color: black; font-size: 18px;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>:<br>设置按钮的背景颜色为浅蓝色，文本颜色为黑色，字体大小为 18px。</p>
<hr>
<h3 id="设置多个属性"><a href="#设置多个属性" class="headerlink" title="设置多个属性"></a><strong>设置多个属性</strong></h3><p>通过使用 <code>;</code> 分隔，可以为控件设置多个样式属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, Qt!&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;border: 2px solid red; background-color: yellow; color: green;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>:<br>标签的边框变为 2px 的红色实线，背景为黄色，字体颜色为绿色。</p>
<hr>
<h3 id="针对子控件设置样式"><a href="#针对子控件设置样式" class="headerlink" title="针对子控件设置样式"></a><strong>针对子控件设置样式</strong></h3><p>通过样式表可以精确指定某个子控件的样式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button&quot;</span>);</span><br><span class="line">button-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton &#123; background-color: lightblue; &#125; QPushButton:hover &#123; background-color: yellow; &#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>:<br>按钮默认背景颜色为浅蓝色，当鼠标悬停在按钮上时，背景颜色变为黄色。</p>
<hr>
<h3 id="使用类名和对象名"><a href="#使用类名和对象名" class="headerlink" title="使用类名和对象名"></a><strong>使用类名和对象名</strong></h3><h4 id="使用类名"><a href="#使用类名" class="headerlink" title="使用类名"></a>使用类名</h4><p>可以为同一类的所有控件设置样式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QWidget *widget = <span class="keyword">new</span> QWidget;</span><br><span class="line">widget-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QLineEdit &#123; border: 2px solid green; &#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>:<br>应用到 <code>QWidget</code> 内的所有 <code>QLineEdit</code>。</p>
<h4 id="使用对象名"><a href="#使用对象名" class="headerlink" title="使用对象名"></a>使用对象名</h4><p>可以通过设置控件的 <code>objectName</code> 来定义特定控件的样式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QLineEdit *lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">lineEdit-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;specialLineEdit&quot;</span>);</span><br><span class="line">lineEdit-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;#specialLineEdit &#123; background-color: pink; &#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong>:<br>仅为名为 <code>specialLineEdit</code> 的输入框设置样式。</p>
<hr>
<h3 id="支持的样式属性"><a href="#支持的样式属性" class="headerlink" title="支持的样式属性"></a><strong>支持的样式属性</strong></h3><p>Qt 样式表支持许多类似 CSS 的属性，包括但不限于：</p>
<ul>
<li><strong>颜色相关</strong>: <code>color</code>, <code>background-color</code>, <code>border-color</code></li>
<li><strong>字体相关</strong>: <code>font-size</code>, <code>font-family</code>, <code>font-style</code>, <code>font-weight</code></li>
<li><strong>边框相关</strong>: <code>border</code>, <code>border-radius</code>, <code>border-width</code>, <code>border-style</code></li>
<li><strong>间距和大小</strong>: <code>padding</code>, <code>margin</code>, <code>min-width</code>, <code>max-height</code></li>
</ul>
<hr>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol>
<li><strong>继承性</strong>:<ul>
<li>设置在父控件上的样式可能会影响其子控件，除非明确覆盖子控件的样式。</li>
</ul>
</li>
<li><strong>性能影响</strong>:<ul>
<li><code>setStyleSheet</code> 使用样式表可能会稍微影响性能，尤其是复杂样式或频繁修改样式时。</li>
</ul>
</li>
<li><strong>动态更新</strong>:<ul>
<li>若要动态更新样式，确保重新调用 <code>setStyleSheet()</code>。</li>
</ul>
</li>
<li><strong>调试样式</strong>:<ul>
<li>可以使用 <code>QSS</code> 文件来组织复杂的样式表，方便维护。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a><strong>完整示例</strong></h2><p>以下是一个完整的示例，展示如何为多个控件设置不同样式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;StyleSheet Example&quot;</span>);</span><br><span class="line"></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Enter your name:&quot;</span>);</span><br><span class="line">    QLineEdit *lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Submit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置样式</span></span><br><span class="line">    window.<span class="built_in">setStyleSheet</span>(</span><br><span class="line">        <span class="string">&quot;QLabel &#123; color: blue; font-size: 16px; &#125;&quot;</span></span><br><span class="line">        <span class="string">&quot;QLineEdit &#123; border: 2px solid gray; border-radius: 5px; padding: 5px; &#125;&quot;</span></span><br><span class="line">        <span class="string">&quot;QPushButton &#123; background-color: green; color: white; padding: 10px; border-radius: 10px; &#125;&quot;</span></span><br><span class="line">        <span class="string">&quot;QPushButton:hover &#123; background-color: lightgreen; &#125;&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">    window.<span class="built_in">setLayout</span>(layout);</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行效果</strong>:  </p>
<ul>
<li>标签文字为蓝色，字体大小为 16px。</li>
<li>输入框有灰色圆角边框和内边距。</li>
<li>按钮为绿色，鼠标悬停时变为浅绿色。</li>
</ul>
<hr>
<p>通过 <code>QWidget::setStyleSheet()</code>，开发者可以灵活地设计现代化、美观的用户界面。</p>
<h2 id="C-Qt-QWidget类-详解"><a href="#C-Qt-QWidget类-详解" class="headerlink" title="C++ Qt QWidget类 详解"></a>C++ Qt QWidget类 详解</h2><p>在 Qt 框架中，<code>QWidget</code> 类是所有用户界面对象的基类。它是 GUI 编程的核心部分，几乎所有的可视化组件（如按钮、标签、窗口等）都直接或间接地继承自 <code>QWidget</code>。以下是对 <code>QWidget</code> 类的详细说明：</p>
<hr>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h2><p><code>QWidget</code> 提供了创建和管理用户界面的基础功能。它负责处理：</p>
<ul>
<li><strong>绘制</strong>：管理窗口内容的绘制。</li>
<li><strong>事件</strong>：响应用户的输入事件（如鼠标点击、键盘输入等）。</li>
<li><strong>布局</strong>：安排子控件的位置和大小。</li>
<li><strong>窗口</strong>：管理窗口显示和属性（如标题、大小、样式等）。</li>
</ul>
<hr>
<h2 id="2-常用构造函数"><a href="#2-常用构造函数" class="headerlink" title="2. 常用构造函数"></a><strong>2. 常用构造函数</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QWidget</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>:</p>
<ul>
<li><code>parent</code>:<ul>
<li>指定父控件。</li>
<li>若 <code>parent</code> 为 <code>nullptr</code>，该控件为顶层窗口。</li>
</ul>
</li>
<li><code>f</code>:<ul>
<li>指定窗口标志（如是否有边框、是否可调整大小等）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>顶层窗口和子控件</strong>:</p>
<ul>
<li>顶层窗口：<code>parent == nullptr</code>。</li>
<li>子控件：<code>parent != nullptr</code>，会自动嵌套在父控件中。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-常用功能"><a href="#3-常用功能" class="headerlink" title="3. 常用功能"></a><strong>3. 常用功能</strong></h2><h3 id="3-1-显示与隐藏"><a href="#3-1-显示与隐藏" class="headerlink" title="3.1 显示与隐藏"></a><strong>3.1 显示与隐藏</strong></h3><ul>
<li><p><strong>显示控件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>显示控件，控件会根据其父控件的关系自动安排位置。</p>
</li>
<li><p><strong>隐藏控件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hide</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全屏显示</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showFullScreen</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最大化、最小化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMaximized</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMinimized</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-2-设置控件属性"><a href="#3-2-设置控件属性" class="headerlink" title="3.2 设置控件属性"></a><strong>3.2 设置控件属性</strong></h3><ul>
<li><p><strong>大小和位置</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGeometry</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure>
<p>设置控件的位置和大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">geometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>获取控件的几何形状。</p>
</li>
<li><p><strong>窗口标题</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowTitle</span><span class="params">(<span class="type">const</span> QString &amp;title)</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">windowTitle</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口图标</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon)</span></span>;</span><br><span class="line"><span class="function">QIcon <span class="title">windowIcon</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口样式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWindowFlags</span><span class="params">(Qt::WindowFlags flags)</span></span>;</span><br><span class="line"><span class="function">Qt::WindowFlags <span class="title">windowFlags</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>背景颜色</strong><br>使用样式表设置背景颜色：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">widget-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightblue;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-3-布局管理"><a href="#3-3-布局管理" class="headerlink" title="3.3 布局管理"></a><strong>3.3 布局管理</strong></h3><p><code>QWidget</code> 提供了布局机制来自动调整子控件的位置和大小。常见的布局类包括：</p>
<ul>
<li><code>QVBoxLayout</code>：垂直布局</li>
<li><code>QHBoxLayout</code>：水平布局</li>
<li><code>QGridLayout</code>：网格布局</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;widget);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button 1&quot;</span>));</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button 2&quot;</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-事件处理"><a href="#3-4-事件处理" class="headerlink" title="3.4 事件处理"></a><strong>3.4 事件处理</strong></h3><ul>
<li><p><strong>鼠标事件</strong><br>重写 <code>mousePressEvent()</code> 以处理鼠标点击：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>键盘事件</strong><br>重写 <code>keyPressEvent()</code> 以处理键盘按键：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *event)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>绘制事件</strong><br>使用 <code>paintEvent()</code> 绘制自定义内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>示例：自定义绘制</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::paintEvent</span><span class="params">(QPaintEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(Qt::yellow);</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="built_in">rect</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-5-获取控件信息"><a href="#3-5-获取控件信息" class="headerlink" title="3.5 获取控件信息"></a><strong>3.5 获取控件信息</strong></h3><ul>
<li><p><strong>获取控件尺寸</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QSize <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取父控件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QWidget *<span class="title">parentWidget</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取子控件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QList&lt;QWidget *&gt; <span class="title">findChildren</span><span class="params">(<span class="type">const</span> QString &amp;name = QString(), Qt::FindChildOption options = Qt::FindChildrenRecursively)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="4-典型示例"><a href="#4-典型示例" class="headerlink" title="4. 典型示例"></a><strong>4. 典型示例</strong></h2><p>以下代码演示如何使用 <code>QWidget</code> 创建一个基本窗口，并添加一些子控件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QWidget Example&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加子控件</span></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, Qt!&quot;</span>, &amp;window);</span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Click Me&quot;</span>, &amp;window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局</span></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行效果</strong>:</p>
<ul>
<li>一个窗口显示“Hello, Qt!”标签和“Click Me”按钮，按钮点击时会响应默认行为。</li>
</ul>
<hr>
<h2 id="5-常用继承类"><a href="#5-常用继承类" class="headerlink" title="5. 常用继承类"></a><strong>5. 常用继承类</strong></h2><p><code>QWidget</code> 是许多常用控件的基类，包括：</p>
<ul>
<li><code>QMainWindow</code>：主窗口类，支持菜单栏、工具栏等。</li>
<li><code>QDialog</code>：对话框类。</li>
<li><code>QPushButton</code>、<code>QLabel</code>、<code>QLineEdit</code> 等具体控件。</li>
</ul>
<hr>
<h2 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a><strong>6. 注意事项</strong></h2><ol>
<li><strong>父子关系</strong>: <ul>
<li>子控件的生命周期由父控件管理，不需要手动删除。</li>
</ul>
</li>
<li><strong>事件处理</strong>:<ul>
<li>可通过重写事件处理函数（如 <code>paintEvent</code>、<code>mousePressEvent</code>）来自定义行为。</li>
</ul>
</li>
<li><strong>性能</strong>:<ul>
<li>在复杂界面中，合理使用布局和样式表可提升性能。</li>
</ul>
</li>
</ol>
<hr>
<p>通过 <code>QWidget</code>，可以轻松构建灵活、现代化的图形用户界面，同时还支持高度的自定义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/19/notebook/Qt/2024-11-19-qt_8_%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/19/notebook/Qt/2024-11-19-qt_8_%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">qt_8_消息循环机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-19 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-19T09:00:00+08:00">2024-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>Qt消息循环机制相关学习笔记</li>
</ul>
<h1 id="深入了解Qt消息循环及线程相关性"><a href="#深入了解Qt消息循环及线程相关性" class="headerlink" title="深入了解Qt消息循环及线程相关性"></a>深入了解Qt消息循环及线程相关性</h1><h2 id="什么是Qt消息循环"><a href="#什么是Qt消息循环" class="headerlink" title="什么是Qt消息循环"></a>什么是Qt消息循环</h2><ul>
<li><p>Qt消息循环，就是从一个队列中不断取出消息，并响应消息的过程。窗体的鼠标，键盘，输入法，绘制，各种消息，都来自于Qt的消息循环。</p>
</li>
<li><p>以Windows操作系统为例，Qt接管Windows原生窗口消息，并翻译成Qt的消息，派发给程序下的各个子对象，子QWidget等，通过接管层，可以很好屏蔽不同平台之间的差异性，开发人员不需要关心Windows或者X11的消息的差异性，只需要搞清楚各个QEvent之间是什么含义。</p>
</li>
<li><p>最开始的Qt消息循环开始于 QCoreApplication::exec。用户创建出一个QCoreApplication，或者说更多情况下是QApplication，执行QCoreApplication::exec，一个应用程序便开始了。QCoreApplication会不断从操作系统获取消息，并且分发给QObject。</p>
</li>
<li><p>如果没有消息循环，那么Qt的信号和槽无法完全使用。有些函数也无法正确执行。举个例子，通过QueuedConnection连接的信号，其实是将一个事件压入了消息循环，如果没有QCoreApplication::exec，那么这个消息循环将永远无法派发到指定的对象。</p>
</li>
</ul>
<h2 id="什么是线程相关性"><a href="#什么是线程相关性" class="headerlink" title="什么是线程相关性"></a>什么是线程相关性</h2><ul>
<li><p>准确来说，应该是指QObject的线程相关性。以Qt文档中的示意图来做说明</p>
</li>
<li><p>当我们创建一个QObject时，它会与创建自己所在的线程绑定，它参与的消息循环，其实是它所在线程的消息循环。加入某个线程没有默认的QThread::exec，那么该线程上的QObject则无法接收到事件。另外，如果两个不同线程的QObject需要相互通信，那么只能通过QueuedConnection的方式，异步通知对象线程，在下一轮消息循环处理QObject的消息。</p>
</li>
<li><p>QObject的线程相关性默认和它的parent保持一致。如果一个QObject没有parent，那么可以通过 moveToThread，将它的线程相关性切换到指定线程</p>
</li>
<li><p>了解QObject的线程相关性非常重要，很多初学者常常分不清一个多线程中哪些QObject应该由主线程创建，哪些应该由工作线程创建。我的观点是，它参与哪个消息循环，就由哪个来创建。</p>
</li>
<li><p>正因为这样的特性，我们才可以理解什么叫做AutoConnection。通过AutoConnection连接的两个QObject，如果是在同一个线程，那么可以直接调用DirectConnection，如果不是在同一个线程，那么就通过事件通知的方式QueueConnection来调用。通过信号和槽，事件或者QueuedConnection方式来进行线程间的通讯，尤其是与UI线程通讯，永远是最优雅的方式之一。</p>
</li>
</ul>
<h2 id="什么是消息循环"><a href="#什么是消息循环" class="headerlink" title="什么是消息循环"></a>什么是消息循环</h2><ul>
<li>关于消息循环的过程。</li>
<li>首先，用户通过GetMessage，PeekMessage等函数，从消息队列中取出事件，接下来，通过DispatchMessage来分发事件。系统将这个事件分发到对应的窗口处理函数WNDPROC中进行处理</li>
<li>在绝大部分GUI程序中，GetMessage，DispatchMessage是写在一个死循环中的，除非程序退出，否则会一直处理各种事件。</li>
</ul>
<h2 id="消息队列的相关性"><a href="#消息队列的相关性" class="headerlink" title="消息队列的相关性"></a>消息队列的相关性</h2><ul>
<li><p>参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/winmsg/about-messages-and-message-queues">https://docs.microsoft.com/zh-cn/windows/win32/winmsg/about-messages-and-message-queues</a></li>
</ul>
</li>
<li><p>系统将用创建某Window的线程来分发消息。例如窗体1在线程A创建，窗体2在线程B创建，那么它们的WNDPROC则是由不同线程来回调的。一般的，我们也只会在主线程中创建窗体，不过系统还是允许在各个线程中处理窗口的。</p>
</li>
</ul>
<h2 id="Qt消息循环的基础：窗体事件"><a href="#Qt消息循环的基础：窗体事件" class="headerlink" title="Qt消息循环的基础：窗体事件"></a>Qt消息循环的基础：窗体事件</h2><ul>
<li>在Windows中，要处理事件一定要有一个窗体，在Qt中，事件一共有两类，一类是和窗体无关的实践，例如QTimerEvent，另外一类就是常见的窗体事件，例如鼠标，键盘，绘制等事件。因此，qt至少有两个WNDPROC，一个处理Timer等事件，一个处理QWidget中的事件。</li>
<li>刚刚也提到，Windows事件其实是和线程相关的，那么也就是说，对于每一个QObject的对象，它必须要有自己所在线程的信息。不同线程的对象是无法直接通信的，要通过事件才可以。</li>
<li>在Qt中，消息循环在 QEventLoop 类中实现。通过QEventLoop::exec可以进入一个消息循环的阻塞状态中，也就是不断地PeekMessage-DispatchMessage。其实，QEventLoop里面几乎没有实现任何细节。</li>
<li>不难想到，QEventLoop通过内部的一层抽象，来不断从系统获取和处理消息，而这一层抽象，是和线程相关的。所有相同的线程，完全可以共用这层抽象。</li>
</ul>
<h1 id="qt-消息循环机制"><a href="#qt-消息循环机制" class="headerlink" title="qt 消息循环机制"></a>qt 消息循环机制</h1><p>在 Qt 中，消息循环机制是事件驱动编程的一部分，负责管理和调度事件的处理。在 Qt 应用程序中，消息循环是确保程序能够响应用户输入、窗口更新、定时器等事件的核心机制。理解 Qt 的消息循环机制对于开发交互式应用程序至关重要。</p>
<h3 id="Qt-消息循环机制概述"><a href="#Qt-消息循环机制概述" class="headerlink" title="Qt 消息循环机制概述"></a>Qt 消息循环机制概述</h3><p>Qt 的事件处理机制基于 <strong>事件队列</strong>，当事件发生时（例如用户点击按钮、输入文本、定时器超时等），事件被放入事件队列，然后通过事件循环逐一处理。事件循环会持续运行，直到应用程序退出。</p>
<h3 id="事件和消息"><a href="#事件和消息" class="headerlink" title="事件和消息"></a>事件和消息</h3><p>在 Qt 中，“事件”和“消息”通常是同义词，它们代表着某种需要处理的动作。常见的事件类型包括：</p>
<ul>
<li>用户输入事件：如 <code>QKeyEvent</code>（键盘输入）、<code>QMouseEvent</code>（鼠标点击或移动）</li>
<li>窗口事件：如 <code>QResizeEvent</code>（窗口大小调整）、<code>QCloseEvent</code>（窗口关闭事件）</li>
<li>定时器事件：如 <code>QTimerEvent</code>（定时器超时事件）</li>
<li>自定义事件：如通过 <code>QCoreApplication::postEvent()</code> 创建和发送的事件</li>
</ul>
<h3 id="消息循环的基本工作原理"><a href="#消息循环的基本工作原理" class="headerlink" title="消息循环的基本工作原理"></a>消息循环的基本工作原理</h3><p>Qt 的消息循环机制通过 <code>QCoreApplication::exec()</code> 函数启动。当调用 <code>exec()</code> 时，它会进入一个循环，等待并处理事件。这是消息循环的核心，它会处理所有传入的事件，直到程序结束或调用 <code>exit()</code> 函数。</p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li><strong>事件触发</strong>：当用户与程序交互时（如点击按钮、输入键盘、定时器触发等），相应的事件会被发送到事件队列。</li>
<li><strong>事件入队</strong>：事件会被放入一个队列中，等待处理。</li>
<li><strong>事件循环</strong>：<code>QCoreApplication::exec()</code> 会不断地从队列中取出事件并分发到合适的对象（通常是控件或窗口），然后调用相应的事件处理函数（如 <code>mousePressEvent()</code>、<code>keyPressEvent()</code> 等）。</li>
<li><strong>事件分发</strong>：当一个事件被取出后，Qt 会根据事件类型调用相应的处理函数。</li>
<li><strong>退出循环</strong>：当消息循环完成（例如用户请求退出程序或调用 <code>exit()</code>），消息循环结束，程序退出。</li>
</ol>
<h3 id="消息循环的代码示例"><a href="#消息循环的代码示例" class="headerlink" title="消息循环的代码示例"></a>消息循环的代码示例</h3><p>下面是一个典型的 Qt 程序结构，展示了消息循环的使用。</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;  <span class="comment">// 初始化应用程序，启动事件循环</span></span><br><span class="line"></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;点击我&quot;</span>)</span></span>;</span><br><span class="line">    button.<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">    button.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();  <span class="comment">// 启动事件循环，等待并处理事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个简单的例子中：</p>
<ol>
<li><code>QApplication app(argc, argv);</code> 会初始化应用程序。</li>
<li><code>button.show();</code> 显示按钮，等待用户交互。</li>
<li><code>app.exec();</code> 启动消息循环并等待处理用户事件（例如鼠标点击、键盘输入等）。</li>
</ol>
<p>当用户点击按钮时，Qt 会触发 <code>QPushButton</code> 的相关事件，如 <code>mousePressEvent()</code>，并调用相应的事件处理方法。</p>
<h3 id="Qt-事件循环的工作方式"><a href="#Qt-事件循环的工作方式" class="headerlink" title="Qt 事件循环的工作方式"></a>Qt 事件循环的工作方式</h3><h4 id="1-事件队列"><a href="#1-事件队列" class="headerlink" title="1. 事件队列"></a>1. <strong>事件队列</strong></h4><p>每个应用程序都有一个事件队列，用于存储需要处理的事件。事件队列是由操作系统和 Qt 内部管理的。当事件被触发时，它们会被放入队列。</p>
<h4 id="2-事件处理"><a href="#2-事件处理" class="headerlink" title="2. 事件处理"></a>2. <strong>事件处理</strong></h4><p>事件的处理通常是通过事件重载来实现的。例如，在自定义窗口类中，你可以重载 <code>mousePressEvent()</code> 来处理鼠标点击事件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;鼠标按下：位置 (&quot;</span> &lt;&lt; event-&gt;<span class="built_in">x</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; event-&gt;<span class="built_in">y</span>() &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-事件循环的执行"><a href="#3-事件循环的执行" class="headerlink" title="3. 事件循环的执行"></a>3. <strong>事件循环的执行</strong></h4><p>Qt 的事件循环会从事件队列中提取事件，并根据事件类型调用合适的事件处理函数。例如：</p>
<ul>
<li>如果事件是键盘输入，则会调用 <code>keyPressEvent()</code>。</li>
<li>如果事件是鼠标点击，则会调用 <code>mousePressEvent()</code>。</li>
</ul>
<h4 id="4-事件的优先级"><a href="#4-事件的优先级" class="headerlink" title="4. 事件的优先级"></a>4. <strong>事件的优先级</strong></h4><p>Qt 处理事件的顺序是由事件的类型和优先级决定的。通常，事件会按照到达顺序进行处理，但也可以通过改变事件的优先级来控制事件的处理顺序。</p>
<h3 id="自定义事件和事件发送"><a href="#自定义事件和事件发送" class="headerlink" title="自定义事件和事件发送"></a><strong>自定义事件和事件发送</strong></h3><p>你可以在 Qt 中发送自定义事件，甚至通过 <code>QCoreApplication::postEvent()</code> 来在事件队列中插入事件。自定义事件通常用于在不同对象之间传递信息。</p>
<h4 id="示例：自定义事件"><a href="#示例：自定义事件" class="headerlink" title="示例：自定义事件"></a>示例：自定义事件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEvent</span> : <span class="keyword">public</span> QEvent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyEvent</span>() : <span class="built_in">QEvent</span>(QEvent::User) &#123;&#125;  <span class="comment">// 设置自定义事件类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWidget</span> : <span class="keyword">public</span> QWidget &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">customEvent</span><span class="params">(QEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::User) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;处理自定义事件&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    MyWidget widget;</span><br><span class="line">    widget.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    QCoreApplication::<span class="built_in">postEvent</span>(&amp;widget, <span class="keyword">new</span> <span class="built_in">MyEvent</span>());  <span class="comment">// 发送自定义事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();  <span class="comment">// 启动事件循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>MyEvent</code> 是一个自定义事件，继承自 <code>QEvent</code>。在 <code>MyWidget</code> 中重载了 <code>customEvent()</code> 来处理这个事件。</p>
<h3 id="线程与消息循环"><a href="#线程与消息循环" class="headerlink" title="线程与消息循环"></a>线程与消息循环</h3><p>Qt 的事件循环通常与主线程相关。主线程是 Qt 应用程序的 GUI 线程，所有的界面更新和事件处理都在主线程中执行。如果你在其他线程中执行操作，必须确保线程安全。例如，可以使用 <code>QEventLoop</code> 或 <code>QTimer</code> 在非主线程中实现事件循环。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>消息循环</strong>是事件驱动编程的核心，确保 Qt 应用程序能够响应各种事件。</li>
<li>事件通过 <code>QCoreApplication::exec()</code> 启动并被依次处理。</li>
<li>Qt 会自动管理事件队列，触发事件时，事件会被推入队列，消息循环会逐一取出并调用相应的事件处理函数。</li>
<li>通过 <code>QEvent</code> 和 <code>QCoreApplication::postEvent()</code>，可以发送自定义事件，实现对象间的通信。</li>
</ul>
<p>Qt 的消息循环机制是事件驱动模型的一个典型实现，理解这一机制对于构建响应式、交互式的 GUI 应用程序至关重要。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/19/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-19-08-QLabel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/19/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-19-08-QLabel/" class="post-title-link" itemprop="url">QLabel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-19 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-19T09:00:00+08:00">2024-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="QLabel-setFixedSize-详解"><a href="#QLabel-setFixedSize-详解" class="headerlink" title="QLabel::setFixedSize() 详解"></a>QLabel::setFixedSize() 详解</h2><p><code>QLabel::setFixedSize()</code> 是 <code>QWidget</code> 类提供的方法，用于设置窗口或控件的固定大小，使其无法通过用户操作或布局管理器改变大小。</p>
<hr>
<h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a><strong>方法定义</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFixedSize</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size</code>：通过 <code>QSize</code> 对象指定宽度和高度。</li>
<li><code>width</code>、<code>height</code>：直接指定宽度和高度的整数值。</li>
</ul>
<p>一旦调用了 <code>setFixedSize()</code>，控件或窗口的大小将固定，无法被用户拖动调整，也不会响应布局管理器的尺寸更改。</p>
<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><ol>
<li><strong>固定控件大小</strong>：<ul>
<li>某些控件需要保持固定大小，例如按钮、图标等。</li>
</ul>
</li>
<li><strong>弹窗或对话框</strong>：<ul>
<li>创建不可调整大小的窗口或对话框。</li>
</ul>
</li>
<li><strong>自定义 UI</strong>：<ul>
<li>精确控制控件的尺寸，不受布局管理器影响。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><h4 id="1-设置固定大小"><a href="#1-设置固定大小" class="headerlink" title="1. 设置固定大小"></a>1. 设置固定大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;固定大小的 QLabel&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>, <span class="number">100</span>); <span class="comment">// 宽 200px，高 100px</span></span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightblue;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<h4 id="2-使用-QSize-对象"><a href="#2-使用-QSize-对象" class="headerlink" title="2. 使用 QSize 对象"></a>2. 使用 <code>QSize</code> 对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;使用 QSize 设置固定大小&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setFixedSize</span>(<span class="built_in">QSize</span>(<span class="number">300</span>, <span class="number">150</span>)); <span class="comment">// 宽 300px，高 150px</span></span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightgreen;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="与其他方法的区别"><a href="#与其他方法的区别" class="headerlink" title="与其他方法的区别"></a><strong>与其他方法的区别</strong></h3><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>resize(int, int)</code></td>
<td>设置控件的当前大小，但大小可能会被用户调整或布局管理器覆盖。</td>
</tr>
<tr>
<td><code>setMinimumSize(int, int)</code></td>
<td>设置控件的最小大小，允许控件变大，但不能小于该值。</td>
</tr>
<tr>
<td><code>setMaximumSize(int, int)</code></td>
<td>设置控件的最大大小，允许控件变小，但不能大于该值。</td>
</tr>
<tr>
<td><code>setFixedSize()</code></td>
<td>同时设置最小大小和最大大小为相同值，从而固定控件大小，完全禁止大小变化。</td>
</tr>
</tbody></table>
<hr>
<h3 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a><strong>示例应用</strong></h3><h4 id="1-创建不可调整大小的窗口"><a href="#1-创建不可调整大小的窗口" class="headerlink" title="1. 创建不可调整大小的窗口"></a>1. 创建不可调整大小的窗口</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;这是一个固定大小的窗口&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::Window); <span class="comment">// 设置为独立窗口</span></span><br><span class="line">label-&gt;<span class="built_in">setFixedSize</span>(<span class="number">400</span>, <span class="number">300</span>);     <span class="comment">// 固定窗口大小</span></span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightyellow;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<h4 id="2-创建一个图标显示区域"><a href="#2-创建一个图标显示区域" class="headerlink" title="2. 创建一个图标显示区域"></a>2. 创建一个图标显示区域</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QLabel *iconLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">iconLabel-&gt;<span class="built_in">setFixedSize</span>(<span class="number">64</span>, <span class="number">64</span>); <span class="comment">// 固定大小为 64x64</span></span><br><span class="line">iconLabel-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/icons/sample_icon.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">64</span>, <span class="number">64</span>)); <span class="comment">// 设置图标</span></span><br><span class="line">iconLabel-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">iconLabel-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;border: 1px solid gray;&quot;</span>);</span><br><span class="line">iconLabel-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<h4 id="3-在布局中使用固定大小的控件"><a href="#3-在布局中使用固定大小的控件" class="headerlink" title="3. 在布局中使用固定大小的控件"></a>3. 在布局中使用固定大小的控件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line"></span><br><span class="line">    QLabel *label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;这是可调整大小的 QLabel&quot;</span>);</span><br><span class="line">    QLabel *label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;这是固定大小的 QLabel&quot;</span>);</span><br><span class="line">    label2-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label1);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label2);</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>label1</code> 的大小会随着布局调整，而 <code>label2</code> 的大小保持固定。</p>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>禁用大小调整</strong>：</p>
<ul>
<li>调用 <code>setFixedSize()</code> 后，控件或窗口将禁用用户拖动调整大小的功能。</li>
</ul>
</li>
<li><p><strong>优先级高于布局管理器</strong>：</p>
<ul>
<li>如果控件位于布局中，<code>setFixedSize()</code> 会覆盖布局管理器对控件大小的设置。</li>
</ul>
</li>
<li><p><strong>跨平台行为一致</strong>：</p>
<ul>
<li><code>setFixedSize()</code> 在不同平台上表现一致，无需担心平台差异。</li>
</ul>
</li>
<li><p><strong>与 <code>setMinimumSize</code> 和 <code>setMaximumSize</code> 的关系</strong>：</p>
<ul>
<li>调用 <code>setFixedSize()</code> 会同时设置最小和最大大小为同一个值，相当于调用了：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">widget-&gt;<span class="built_in">setMinimumSize</span>(width, height);</span><br><span class="line">widget-&gt;<span class="built_in">setMaximumSize</span>(width, height);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<p>通过 <code>setFixedSize()</code>，可以精确控制窗口或控件的大小，适用于需要固定尺寸的场景，例如弹窗、按钮、图标区域等，是构建稳定用户界面布局的重要工具。</p>
<h2 id="QLabel-setWindowFlags-详解"><a href="#QLabel-setWindowFlags-详解" class="headerlink" title="QLabel::setWindowFlags() 详解"></a>QLabel::setWindowFlags() 详解</h2><p><code>QLabel::setWindowFlags()</code> 是用于设置 <code>QLabel</code> 窗口标志的方法，继承自 <code>QWidget</code>。窗口标志（<code>Qt::WindowFlags</code>）定义了窗口的外观和行为特性，例如是否有边框、标题栏、是否是工具窗口等。</p>
<hr>
<h3 id="方法定义-1"><a href="#方法定义-1" class="headerlink" title="方法定义"></a><strong>方法定义</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLabel::setWindowFlags</span><span class="params">(Qt::WindowFlags flags)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>flags</code> 是一个 <code>Qt::WindowFlags</code> 类型，可以通过 <code>|</code> 运算符组合多个标志。</li>
<li>设置了特定标志后，会改变 <code>QLabel</code> 的窗口特性，比如是否显示为独立窗口、是否无边框、是否置顶等。</li>
</ul>
<hr>
<h3 id="常见的-Qt-WindowFlags"><a href="#常见的-Qt-WindowFlags" class="headerlink" title="常见的 Qt::WindowFlags"></a><strong>常见的 <code>Qt::WindowFlags</code></strong></h3><p>以下是常用的窗口标志及其作用：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Qt::Widget</code></td>
<td>默认值，表示普通窗口部件。</td>
</tr>
<tr>
<td><code>Qt::Window</code></td>
<td>将 <code>QLabel</code> 转换为顶层窗口，显示为独立窗口。</td>
</tr>
<tr>
<td><code>Qt::Dialog</code></td>
<td>将 <code>QLabel</code> 转换为对话框窗口（类似模态对话框）。</td>
</tr>
<tr>
<td><code>Qt::Tool</code></td>
<td>工具窗口，通常是小窗口，不会在任务栏显示，并总是置顶父窗口之上。</td>
</tr>
<tr>
<td><code>Qt::FramelessWindowHint</code></td>
<td>无边框窗口，不带标题栏和边框。</td>
</tr>
<tr>
<td><code>Qt::WindowStaysOnTopHint</code></td>
<td>窗口总是保持在其他窗口的上方。</td>
</tr>
<tr>
<td><code>Qt::WindowStaysOnBottomHint</code></td>
<td>窗口总是保持在其他窗口的下方。</td>
</tr>
<tr>
<td><code>Qt::CustomizeWindowHint</code></td>
<td>自定义窗口标志，必须手动添加需要的功能（如标题栏）。</td>
</tr>
<tr>
<td><code>Qt::SplashScreen</code></td>
<td>用于启动画面窗口。</td>
</tr>
<tr>
<td><code>Qt::SubWindow</code></td>
<td>作为子窗口嵌套在父窗口中。</td>
</tr>
<tr>
<td><code>Qt::Popup</code></td>
<td>弹出窗口，常用于右键菜单或选择框。</td>
</tr>
<tr>
<td><code>Qt::WindowCloseButtonHint</code></td>
<td>显示关闭按钮（标题栏需要 <code>Qt::Window</code> 或相关标志）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a><strong>用法示例</strong></h3><h4 id="1-普通窗口"><a href="#1-普通窗口" class="headerlink" title="1. 普通窗口"></a>1. <strong>普通窗口</strong></h4><p><code>QLabel</code> 默认是作为子窗口（<code>Qt::Widget</code>）存在的。如果需要显示为独立窗口，可以设置为 <code>Qt::Window</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;这是一个普通窗口&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::Window);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-无边框窗口"><a href="#2-无边框窗口" class="headerlink" title="2. 无边框窗口"></a>2. <strong>无边框窗口</strong></h4><p>可以移除标题栏和边框，用于自定义窗口或提示框。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;无边框窗口&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightblue; padding: 10px;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-工具窗口"><a href="#3-工具窗口" class="headerlink" title="3. 工具窗口"></a>3. <strong>工具窗口</strong></h4><p>将窗口设置为工具窗口，使其成为一个小型的、总是置顶的辅助窗口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;工具窗口&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::Tool | Qt::WindowStaysOnTopHint);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightgreen; padding: 10px;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-自定义标题栏窗口"><a href="#4-自定义标题栏窗口" class="headerlink" title="4. 自定义标题栏窗口"></a>4. <strong>自定义标题栏窗口</strong></h4><p>使用 <code>Qt::CustomizeWindowHint</code> 自定义窗口功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;自定义标题栏窗口&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::Window | Qt::CustomizeWindowHint | Qt::WindowCloseButtonHint);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-弹出窗口"><a href="#5-弹出窗口" class="headerlink" title="5. 弹出窗口"></a>5. <strong>弹出窗口</strong></h4><p>使用 <code>Qt::Popup</code> 将窗口设置为弹出窗口，例如右键菜单或工具选择器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;弹出窗口&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::Popup);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: yellow; padding: 10px;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-启动画面窗口"><a href="#6-启动画面窗口" class="headerlink" title="6. 启动画面窗口"></a>6. <strong>启动画面窗口</strong></h4><p>使用 <code>Qt::SplashScreen</code> 设置窗口为启动画面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;启动画面&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setWindowFlags</span>(Qt::SplashScreen);</span><br><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: orange; padding: 10px;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见问题与注意事项"><a href="#常见问题与注意事项" class="headerlink" title="常见问题与注意事项"></a><strong>常见问题与注意事项</strong></h3><ol>
<li><p><strong>无边框后窗口无法移动</strong></p>
<ul>
<li>无边框窗口（<code>Qt::FramelessWindowHint</code>）会失去默认的拖动功能，需要手动实现鼠标拖动。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::LeftButton) &#123;</span><br><span class="line">        dragStartPosition = event-&gt;<span class="built_in">globalPos</span>() - <span class="built_in">frameGeometry</span>().<span class="built_in">topLeft</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton) &#123;</span><br><span class="line">        <span class="built_in">move</span>(event-&gt;<span class="built_in">globalPos</span>() - dragStartPosition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>标志的组合</strong></p>
<ul>
<li>窗口标志可以通过 <code>|</code> 运算符组合使用，但某些标志可能会互相覆盖，例如 <code>Qt::FramelessWindowHint</code> 和 <code>Qt::WindowCloseButtonHint</code> 一起使用时，关闭按钮不会显示。</li>
</ul>
</li>
<li><p><strong>父子关系影响</strong></p>
<ul>
<li>如果设置了父窗口，窗口标志的行为可能受影响。例如，<code>Qt::WindowStaysOnTopHint</code> 的窗口总是置顶，但只会置顶于父窗口之上。</li>
</ul>
</li>
<li><p><strong>跨平台差异</strong></p>
<ul>
<li>不同平台对某些窗口标志的支持可能存在差异。例如，某些 Linux 窗口管理器可能不支持 <code>Qt::WindowStaysOnBottomHint</code>。</li>
</ul>
</li>
</ol>
<hr>
<p>通过 <code>setWindowFlags()</code>，可以灵活控制 <code>QLabel</code> 的显示行为，让其满足各种场景需求，如独立窗口、无边框窗口、工具窗口等。</p>
<h2 id="C-QLabel类-详解"><a href="#C-QLabel类-详解" class="headerlink" title="C++ QLabel类 详解"></a>C++ QLabel类 详解</h2><p><code>QLabel</code> 是 Qt 框架中用于显示文本或图像的控件类。它是一个简单的 GUI 元素，适用于需要显示静态文本、动态文本或图像的场景。</p>
<p>以下是对 <code>QLabel</code> 类的详解：</p>
<hr>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a><strong>基本功能</strong></h3><p><code>QLabel</code> 的主要功能是：</p>
<ol>
<li>显示文本（静态文本、HTML 格式文本、动态更新的文本）。</li>
<li>显示图片。</li>
<li>可作为提示信息的承载控件。</li>
<li>支持丰富的文本格式，包括纯文本、HTML 和样式化文本。</li>
</ol>
<hr>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QLabel</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br><span class="line"><span class="built_in">QLabel</span>(<span class="type">const</span> QString &amp;text, QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>text</code>：初始显示的文本。</li>
<li><code>parent</code>：父窗口指针。</li>
<li><code>f</code>：窗口标志，通常保持默认值。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, QLabel!&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h3><h4 id="1-设置文本"><a href="#1-设置文本" class="headerlink" title="1. 设置文本"></a><strong>1. 设置文本</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">text</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置或获取 QLabel 的显示文本。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;New Text&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-设置对齐方式"><a href="#2-设置对齐方式" class="headerlink" title="2. 设置对齐方式"></a><strong>2. 设置对齐方式</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlignment</span><span class="params">(Qt::Alignment alignment)</span></span>;</span><br><span class="line"><span class="function">Qt::Alignment <span class="title">alignment</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置文本或图片的对齐方式。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-设置图片"><a href="#3-设置图片" class="headerlink" title="3. 设置图片"></a><strong>3. 设置图片</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPixmap</span><span class="params">(<span class="type">const</span> QPixmap &amp;pixmap)</span></span>;</span><br><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置 QLabel 显示的图片。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/images/logo.png&quot;</span>)</span></span>;</span><br><span class="line">label-&gt;<span class="built_in">setPixmap</span>(pixmap);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-自动调整大小"><a href="#4-自动调整大小" class="headerlink" title="4. 自动调整大小"></a><strong>4. 自动调整大小</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScaledContents</span><span class="params">(<span class="type">bool</span> scaled)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasScaledContents</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>控制 QLabel 是否根据内容自动调整大小。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-设置文本格式"><a href="#5-设置文本格式" class="headerlink" title="5. 设置文本格式"></a><strong>5. 设置文本格式</strong></h4><ul>
<li><strong>支持 HTML 格式的文本显示</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTextFormat</span><span class="params">(Qt::TextFormat format)</span></span>;</span><br><span class="line"><span class="function">Qt::TextFormat <span class="title">textFormat</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>常用格式包括 <code>Qt::PlainText</code>、<code>Qt::RichText</code> 和 <code>Qt::AutoText</code>。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;&lt;b&gt;Bold Text&lt;/b&gt;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-设置文本样式"><a href="#6-设置文本样式" class="headerlink" title="6. 设置文本样式"></a><strong>6. 设置文本样式</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setStyleSheet</span><span class="params">(<span class="type">const</span> QString &amp;styleSheet)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置 QLabel 的样式表。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;color: red; font-size: 16px;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-获取文本尺寸"><a href="#7-获取文本尺寸" class="headerlink" title="7. 获取文本尺寸"></a><strong>7. 获取文本尺寸</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QSize <span class="title">sizeHint</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回 QLabel 当前内容建议的尺寸。</li>
</ul>
<h4 id="8-设置提示信息"><a href="#8-设置提示信息" class="headerlink" title="8. 设置提示信息"></a><strong>8. 设置提示信息</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setToolTip</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>为 QLabel 设置提示信息。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setToolTip</span>(<span class="string">&quot;This is a QLabel&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-清除内容"><a href="#9-清除内容" class="headerlink" title="9. 清除内容"></a><strong>9. 清除内容</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>清空 QLabel 的内容。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a><strong>信号与槽</strong></h3><p><code>QLabel</code> 本身不直接提供信号，但可以通过事件或自定义逻辑配合使用。例如，结合鼠标事件使 QLabel 响应点击：</p>
<ul>
<li>重写 <code>mousePressEvent</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClickableLabel</span> : <span class="keyword">public</span> QLabel &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ClickableLabel</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span> : QLabel(parent) &#123;</span>&#125;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="function">emit <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line">        QLabel::<span class="built_in">mousePressEvent</span>(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>使用自定义 <code>clicked</code> 信号。</li>
</ul>
<hr>
<h3 id="QLabel-示例代码"><a href="#QLabel-示例代码" class="headerlink" title="QLabel 示例代码"></a><strong>QLabel 示例代码</strong></h3><h4 id="纯文本显示"><a href="#纯文本显示" class="headerlink" title="纯文本显示"></a><strong>纯文本显示</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(<span class="string">&quot;Hello, QLabel!&quot;</span>)</span></span>;</span><br><span class="line">    label.<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    label.<span class="built_in">setStyleSheet</span>(<span class="string">&quot;font-size: 20px; color: blue;&quot;</span>);</span><br><span class="line">    label.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a><strong>显示图片</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QLabel label;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/images/logo.png&quot;</span>)</span></span>;</span><br><span class="line">    label.<span class="built_in">setPixmap</span>(pixmap);</span><br><span class="line">    label.<span class="built_in">setScaledContents</span>(<span class="literal">true</span>); <span class="comment">// 图片自动适应 QLabel 大小</span></span><br><span class="line">    label.<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    label.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HTML-格式文本"><a href="#HTML-格式文本" class="headerlink" title="HTML 格式文本"></a><strong>HTML 格式文本</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QLabel label;</span><br><span class="line">    label.<span class="built_in">setText</span>(<span class="string">&quot;&lt;h1 style=&#x27;color:red;&#x27;&gt;Hello, &lt;i&gt;HTML&lt;/i&gt;!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    label.<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    label.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="QLabel-常见属性"><a href="#QLabel-常见属性" class="headerlink" title="QLabel 常见属性"></a><strong>QLabel 常见属性</strong></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>text</code></td>
<td>显示的文本内容</td>
</tr>
<tr>
<td><code>pixmap</code></td>
<td>显示的图片</td>
</tr>
<tr>
<td><code>alignment</code></td>
<td>对齐方式（文本或图片）</td>
</tr>
<tr>
<td><code>wordWrap</code></td>
<td>是否自动换行</td>
</tr>
<tr>
<td><code>scaledContents</code></td>
<td>是否自动缩放内容</td>
</tr>
<tr>
<td><code>toolTip</code></td>
<td>鼠标悬浮提示信息</td>
</tr>
</tbody></table>
<hr>
<p>通过灵活使用 QLabel，可以满足 GUI 界面中简单的显示需求，例如展示文字、图片或动态信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/2024-11-18-qt_7_%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/2024-11-18-qt_7_%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">qt_7_常见函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Qt-WindowStaysOnTopHint-是什么"><a href="#Qt-WindowStaysOnTopHint-是什么" class="headerlink" title="Qt::WindowStaysOnTopHint 是什么"></a>Qt::WindowStaysOnTopHint 是什么</h2><p><code>Qt::WindowStaysOnTopHint</code> 是 Qt 中的一个窗口标志（Window Flag），它用于使窗口始终保持在其他窗口的上方。</p>
<p>当一个窗口设置了这个标志后，无论其他窗口是否被激活，该窗口都会始终位于最前面，类似于“置顶”的效果。</p>
<hr>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>
<p>通常与其他标志组合使用，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a><strong>常见场景</strong></h3><ol>
<li><strong>提示框</strong>：显示重要信息或通知时，不希望被其他窗口遮挡。</li>
<li><strong>悬浮工具栏</strong>：开发一些辅助工具或快捷操作面板时。</li>
<li><strong>系统通知</strong>：显示系统级通知或警告。</li>
<li><strong>调试工具</strong>：为调试时的窗口提供置顶功能。</li>
</ol>
<hr>
<h3 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a><strong>完整例子</strong></h3><p>以下是一个简单的例子，展示如何使用 <code>Qt::WindowStaysOnTopHint</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(<span class="string">&quot;我是置顶窗口&quot;</span>)</span></span>;</span><br><span class="line">    label.<span class="built_in">setWindowFlags</span>(Qt::Tool | Qt::WindowStaysOnTopHint);</span><br><span class="line">    label.<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: yellow; padding: 10px; font-size: 16px;&quot;</span>);</span><br><span class="line">    label.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后，<code>label</code> 将始终显示在其他窗口的上方。</p>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>窗口管理器支持</strong>：</p>
<ul>
<li>在某些操作系统或桌面环境下，窗口管理器可能不完全支持此标志。</li>
<li>特别是在某些 Linux 桌面环境中，置顶功能可能会受到限制。</li>
</ul>
</li>
<li><p><strong>不适合主窗口</strong>：</p>
<ul>
<li>这个标志通常用于子窗口或辅助窗口，而不是主窗口（<code>QMainWindow</code>），否则会导致用户体验不佳。</li>
</ul>
</li>
<li><p><strong>与其他标志冲突</strong>：</p>
<ul>
<li>如果设置了 <code>Qt::WindowStaysOnTopHint</code>，但窗口没有置顶，可能是其他窗口标志（如模态窗口）导致的冲突。</li>
</ul>
</li>
</ol>
<hr>
<p>通过这个标志，可以方便地实现类似系统通知、浮动工具栏等功能，提升程序的交互体验。</p>
<h2 id="Qt-FramelessWindowHint"><a href="#Qt-FramelessWindowHint" class="headerlink" title="Qt::FramelessWindowHint"></a>Qt::FramelessWindowHint</h2><p><code>Qt::FramelessWindowHint</code> 是 Qt 中的一个窗口标志，用于移除窗口的标题栏和边框。设置该标志的窗口将变得无边框，并且不包含系统提供的关闭、最小化、最大化等按钮。</p>
<hr>
<h3 id="特点与用途"><a href="#特点与用途" class="headerlink" title="特点与用途"></a><strong>特点与用途</strong></h3><ul>
<li><strong>去除边框和标题栏</strong>：<ul>
<li>使窗口显示更加简洁，用于自定义界面。</li>
</ul>
</li>
<li><strong>完全可控</strong>：<ul>
<li>通常用于自定义窗口的外观，例如圆角窗口、透明窗口等。</li>
</ul>
</li>
<li><strong>常见场景</strong>：<ul>
<li>Splash Screen（启动画面）。</li>
<li>自定义提示框。</li>
<li>自定义主窗口或弹窗。</li>
<li>不规则形状的窗口。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><p>通过 <code>setWindowFlags</code> 设置 <code>Qt::FramelessWindowHint</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br></pre></td></tr></table></figure>

<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint); <span class="comment">// 设置无边框</span></span><br><span class="line">    window.<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightblue; border-radius: 10px;&quot;</span>);</span><br><span class="line">    window.<span class="built_in">setFixedSize</span>(<span class="number">400</span>, <span class="number">300</span>); <span class="comment">// 固定窗口大小</span></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后，窗口将显示为无边框的蓝色矩形。</p>
<hr>
<h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a><strong>组合使用</strong></h3><p><code>Qt::FramelessWindowHint</code> 可以与其他窗口标志组合使用，以实现更多功能。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="鼠标拖动窗口"><a href="#鼠标拖动窗口" class="headerlink" title="鼠标拖动窗口"></a><strong>鼠标拖动窗口</strong></h3><p>由于无边框窗口失去了默认的拖动功能，需要手动实现鼠标拖动窗口：</p>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FramelessWindow</span> : <span class="keyword">public</span> QWidget &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FramelessWindow</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span> : QWidget(parent) &#123;</span></span><br><span class="line">        <span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint); <span class="comment">// 设置无边框</span></span><br><span class="line">        <span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: lightgreen; border-radius: 10px;&quot;</span>);</span><br><span class="line">        <span class="built_in">setFixedSize</span>(<span class="number">400</span>, <span class="number">300</span>); <span class="comment">// 固定大小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::LeftButton) &#123;</span><br><span class="line">            dragStartPosition = event-&gt;<span class="built_in">globalPos</span>() - <span class="built_in">frameGeometry</span>().<span class="built_in">topLeft</span>();</span><br><span class="line">            event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton) &#123;</span><br><span class="line">            <span class="built_in">move</span>(event-&gt;<span class="built_in">globalPos</span>() - dragStartPosition);</span><br><span class="line">            event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPoint dragStartPosition; <span class="comment">// 记录鼠标初始位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    FramelessWindow window;</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码实现了一个无边框窗口，并支持用鼠标拖动。</p>
<hr>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>系统按钮功能缺失</strong>：</p>
<ul>
<li>无边框窗口会失去最小化、最大化和关闭按钮，需要自行实现这些功能。</li>
</ul>
</li>
<li><p><strong>操作系统兼容性</strong>：</p>
<ul>
<li>在某些操作系统（如 macOS 和 Windows）上，去边框可能会带来窗口交互体验的差异，例如窗口无法调整大小。</li>
</ul>
</li>
<li><p><strong>自定义效果</strong>：</p>
<ul>
<li>搭配 <code>QPainter</code> 或 <code>QStyleSheet</code>，可以实现更加复杂的窗口样式，比如圆角或透明效果。</li>
</ul>
</li>
</ol>
<hr>
<p>通过 <code>Qt::FramelessWindowHint</code>，开发者可以完全掌控窗口的外观和行为，是构建现代化、个性化界面的重要工具。</p>
<h2 id="Qt-Tool"><a href="#Qt-Tool" class="headerlink" title="Qt::Tool"></a>Qt::Tool</h2><p><code>Qt::Tool</code> 是 Qt 中的一个窗口标志（Window Type），用于指定窗口作为工具窗口显示。</p>
<p>工具窗口通常是一个小型的、非主窗口的辅助窗口，它的作用是提供附加功能或工具。比如，颜色选择器、调试面板、浮动工具栏等。</p>
<hr>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a><strong>主要特点</strong></h3><ol>
<li><p><strong>非主窗口类型</strong>：</p>
<ul>
<li><code>Qt::Tool</code> 窗口是附属于主窗口的辅助窗口，但它不会在任务栏显示图标。</li>
</ul>
</li>
<li><p><strong>置顶显示</strong>：</p>
<ul>
<li>通常，工具窗口会始终置顶在父窗口上方。</li>
<li>如果需要它始终置顶所有窗口，可以额外使用 <code>Qt::WindowStaysOnTopHint</code>。</li>
</ul>
</li>
<li><p><strong>独立窗口</strong>：</p>
<ul>
<li>工具窗口不会阻塞主窗口的操作，可以与主窗口同时交互。</li>
</ul>
</li>
<li><p><strong>大小和外观</strong>：</p>
<ul>
<li>工具窗口通常比主窗口小，而且默认没有任务栏图标。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget mainWindow;</span><br><span class="line">    mainWindow.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;主窗口&quot;</span>);</span><br><span class="line">    mainWindow.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">    mainWindow.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    QWidget toolWindow;</span><br><span class="line">    toolWindow.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;工具窗口&quot;</span>);</span><br><span class="line">    toolWindow.<span class="built_in">setWindowFlags</span>(Qt::Tool); <span class="comment">// 设置为工具窗口</span></span><br><span class="line">    toolWindow.<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">150</span>);</span><br><span class="line">    toolWindow.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后，你会看到：</p>
<ul>
<li>主窗口是常规的应用窗口。</li>
<li>工具窗口不会在任务栏中显示。</li>
</ul>
<hr>
<h3 id="组合使用-1"><a href="#组合使用-1" class="headerlink" title="组合使用"></a><strong>组合使用</strong></h3><p>可以将 <code>Qt::Tool</code> 与其他窗口标志结合使用，进一步控制工具窗口的行为。例如：</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolWindow.<span class="built_in">setWindowFlags</span>(Qt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>Qt::FramelessWindowHint</code>**：去掉工具窗口的边框。</li>
<li>**<code>Qt::WindowStaysOnTopHint</code>**：让工具窗口始终保持在所有窗口的最上方。</li>
</ul>
<hr>
<h3 id="工具窗口的父子关系"><a href="#工具窗口的父子关系" class="headerlink" title="工具窗口的父子关系"></a><strong>工具窗口的父子关系</strong></h3><p>如果设置工具窗口的父窗口，则工具窗口会自动跟随主窗口（如一起最小化或隐藏）。</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toolWindow.<span class="built_in">setParent</span>(&amp;mainWindow); <span class="comment">// 设置父窗口</span></span><br><span class="line">toolWindow.<span class="built_in">setWindowFlags</span>(Qt::Tool);</span><br><span class="line">toolWindow.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>当主窗口被最小化时，工具窗口也会被最小化。</li>
<li>工具窗口始终在其父窗口的范围内显示。</li>
</ul>
<hr>
<h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a><strong>常见用途</strong></h3><ol>
<li><strong>浮动工具栏</strong>：<ul>
<li>用于辅助功能（如编辑器的工具面板）。</li>
</ul>
</li>
<li><strong>调试窗口</strong>：<ul>
<li>用于显示调试信息或日志输出。</li>
</ul>
</li>
<li><strong>颜色选择器</strong>：<ul>
<li>提供小型的选择工具。</li>
</ul>
</li>
<li><strong>弹出提示框</strong>：<ul>
<li>实现自定义的提示窗口。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>任务栏图标</strong>：</p>
<ul>
<li>工具窗口不会显示在任务栏中，但如果需要显示，可以去掉 <code>Qt::Tool</code> 标志，改用普通窗口类型。</li>
</ul>
</li>
<li><p><strong>行为依赖父窗口</strong>：</p>
<ul>
<li>如果没有设置父窗口，工具窗口的置顶行为可能不稳定。</li>
</ul>
</li>
<li><p><strong>兼容性</strong>：</p>
<ul>
<li>在不同操作系统上的表现可能稍有差异，尤其是与其他窗口标志结合使用时。</li>
</ul>
</li>
</ol>
<hr>
<p>通过 <code>Qt::Tool</code>，可以轻松创建轻量级、功能明确的辅助窗口，提升应用程序的用户体验和功能扩展能力。</p>
<h2 id="QGuiApplication-primaryScreen-详解"><a href="#QGuiApplication-primaryScreen-详解" class="headerlink" title="QGuiApplication::primaryScreen() 详解"></a>QGuiApplication::primaryScreen() 详解</h2><p><code>QGuiApplication::primaryScreen()</code> 是 Qt 提供的一个方法，用于获取系统的主屏幕对象（<code>QScreen</code>）。它属于 <code>QGuiApplication</code> 类，适用于需要处理屏幕信息的场景，比如获取屏幕分辨率、设置窗口位置、在多屏环境下处理窗口布局等。</p>
<hr>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a><strong>主要功能</strong></h3><ol>
<li><strong>获取主屏幕信息</strong>：<ul>
<li>返回一个 <code>QScreen*</code>，表示主屏幕对象。</li>
</ul>
</li>
<li><strong>跨多屏支持</strong>：<ul>
<li>在多显示器环境中，<code>primaryScreen()</code> 返回的是主屏幕（通常是显示系统任务栏的屏幕）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><h4 id="获取主屏幕对象"><a href="#获取主屏幕对象" class="headerlink" title="获取主屏幕对象"></a>获取主屏幕对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScreen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line">    <span class="keyword">if</span> (screen) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Primary screen name:&quot;</span> &lt;&lt; screen-&gt;<span class="built_in">name</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Screen resolution:&quot;</span> &lt;&lt; screen-&gt;<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Screen geometry:&quot;</span> &lt;&lt; screen-&gt;<span class="built_in">geometry</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Primary screen name: &quot;eDP-1&quot;</span><br><span class="line">Screen resolution: QSize(1920, 1080)</span><br><span class="line">Screen geometry: QRect(0, 0, 1920, 1080)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见用途-1"><a href="#常见用途-1" class="headerlink" title="常见用途"></a><strong>常见用途</strong></h3><h4 id="1-获取主屏幕分辨率"><a href="#1-获取主屏幕分辨率" class="headerlink" title="1. 获取主屏幕分辨率"></a>1. <strong>获取主屏幕分辨率</strong></h4><p>可以通过 <code>QScreen</code> 的 <code>size()</code> 或 <code>availableGeometry()</code> 获取屏幕的分辨率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line"><span class="keyword">if</span> (screen) &#123;</span><br><span class="line">    QSize resolution = screen-&gt;<span class="built_in">size</span>(); <span class="comment">// 获取屏幕分辨率</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Screen resolution:&quot;</span> &lt;&lt; resolution;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-设置窗口到主屏幕中心"><a href="#2-设置窗口到主屏幕中心" class="headerlink" title="2. 设置窗口到主屏幕中心"></a>2. <strong>设置窗口到主屏幕中心</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScreen&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setFixedSize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取主屏幕的几何信息</span></span><br><span class="line">    QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line">    <span class="keyword">if</span> (screen) &#123;</span><br><span class="line">        QRect screenGeometry = screen-&gt;<span class="built_in">geometry</span>();</span><br><span class="line">        <span class="type">int</span> x = screenGeometry.<span class="built_in">center</span>().<span class="built_in">x</span>() - window.<span class="built_in">width</span>() / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> y = screenGeometry.<span class="built_in">center</span>().<span class="built_in">y</span>() - window.<span class="built_in">height</span>() / <span class="number">2</span>;</span><br><span class="line">        window.<span class="built_in">move</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-支持多屏幕环境"><a href="#3-支持多屏幕环境" class="headerlink" title="3. 支持多屏幕环境"></a>3. <strong>支持多屏幕环境</strong></h4><p>对于多屏幕环境，可以使用 <code>QGuiApplication::screens()</code> 获取所有屏幕的列表，并选择特定的屏幕进行操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScreen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QList&lt;QScreen *&gt; screens = QGuiApplication::<span class="built_in">screens</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Number of screens:&quot;</span> &lt;&lt; screens.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (QScreen *screen : screens) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Screen name:&quot;</span> &lt;&lt; screen-&gt;<span class="built_in">name</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Resolution:&quot;</span> &lt;&lt; screen-&gt;<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a><strong>常见方法</strong></h3><p>以下是 <code>QScreen</code> 类常用的方法，可以结合 <code>primaryScreen()</code> 使用：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>geometry()</code></td>
<td>返回屏幕的矩形区域（包括不可用部分）。</td>
</tr>
<tr>
<td><code>availableGeometry()</code></td>
<td>返回屏幕的可用区域（排除了任务栏和停靠窗口的部分）。</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回屏幕的分辨率（<code>QSize</code>）。</td>
</tr>
<tr>
<td><code>physicalSize()</code></td>
<td>返回屏幕的物理尺寸（毫米为单位）。</td>
</tr>
<tr>
<td><code>refreshRate()</code></td>
<td>返回屏幕的刷新率（Hz）。</td>
</tr>
<tr>
<td><code>logicalDotsPerInch()</code></td>
<td>返回屏幕的逻辑 DPI（通常用于字体和布局的计算）。</td>
</tr>
<tr>
<td><code>devicePixelRatio()</code></td>
<td>返回屏幕的设备像素比率（高分屏时非常重要）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>多屏环境</strong>：</p>
<ul>
<li>如果程序运行在多显示器环境下，<code>primaryScreen()</code> 返回的只是主屏幕，而其他屏幕需要通过 <code>QGuiApplication::screens()</code> 获取。</li>
</ul>
</li>
<li><p><strong>跨平台差异</strong>：</p>
<ul>
<li>在某些平台（如 macOS）上，任务栏可能不总是定义主屏幕。</li>
</ul>
</li>
<li><p><strong>高分屏支持</strong>：</p>
<ul>
<li>如果使用高分屏，记得考虑设备像素比率 (<code>devicePixelRatio()</code>)，以避免显示问题。</li>
</ul>
</li>
</ol>
<hr>
<p>通过 <code>QGuiApplication::primaryScreen()</code>，可以轻松获取屏幕的几何信息并灵活控制窗口的位置和布局，特别是在需要多屏支持或自定义布局时非常有用。</p>
<h2 id="Qt-findChild-函数-详解"><a href="#Qt-findChild-函数-详解" class="headerlink" title="Qt findChild()函数 详解"></a>Qt findChild()函数 详解</h2><p><code>findChild()</code> 是 Qt 中用于查找某个特定类型或名称的子对象的函数。它通常用于在运行时查找对象树中的子对象，特别是在动态生成或加载 UI 元素时非常有用。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">findChild</span><span class="params">(<span class="type">const</span> QString &amp;name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>T</strong>: 模板参数，表示要查找的对象类型（如 <code>QWidget*</code>、<code>QPushButton*</code> 等）。</li>
<li><strong>name</strong>: 子对象的名称（对象名），可以省略。如果省略，表示查找第一个符合类型的对象。</li>
<li><strong>options</strong>: 查找选项，可以指定查找的深度（递归或不递归）。</li>
</ul>
<h3 id="查找选项-Qt-FindChildOptions"><a href="#查找选项-Qt-FindChildOptions" class="headerlink" title="查找选项 (Qt::FindChildOptions)"></a>查找选项 (<code>Qt::FindChildOptions</code>)</h3><ul>
<li><code>Qt::FindDirectChildrenOnly</code>: 仅查找直接子对象，不会递归查找子对象的子对象。</li>
<li><code>Qt::FindChildrenRecursively</code>: 递归查找所有子对象（包括子对象的子对象）。这是默认选项。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你有一个包含多个子部件的 <code>QWidget</code>，其中一个 <code>QPushButton</code> 名为 <code>&quot;myButton&quot;</code>，你可以使用 <code>findChild()</code> 来查找该按钮。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *button = parentWidget-&gt;<span class="built_in">findChild</span>&lt;QPushButton*&gt;(<span class="string">&quot;myButton&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (button) &#123;</span><br><span class="line">    <span class="comment">// 找到了名为 &quot;myButton&quot; 的按钮，可以在这里进行操作</span></span><br><span class="line">    button-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Button Found!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有找到该按钮</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Button not found!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找没有名称的子对象"><a href="#查找没有名称的子对象" class="headerlink" title="查找没有名称的子对象"></a>查找没有名称的子对象</h3><p>如果你不关心对象名，只需要查找某一类型的子对象，可以不传入 <code>name</code> 参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = parentWidget-&gt;<span class="built_in">findChild</span>&lt;QLabel*&gt;();</span><br><span class="line"><span class="keyword">if</span> (label) &#123;</span><br><span class="line">    <span class="comment">// 找到了某个 QLabel，可以在这里进行操作</span></span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Label Found!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>对象名必须唯一</strong>：如果查找指定名称的子对象，确保该名称在对象树中是唯一的。否则，<code>findChild()</code> 可能只返回找到的第一个匹配对象。</li>
<li><strong>类型检查</strong>：模板参数 <code>T</code> 应与查找的子对象的实际类型匹配。否则，返回的指针将是 <code>nullptr</code>。</li>
</ul>
<h3 id="递归查找多个子对象"><a href="#递归查找多个子对象" class="headerlink" title="递归查找多个子对象"></a>递归查找多个子对象</h3><p>如果需要查找多个匹配的子对象，可以使用 <code>findChildren()</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QPushButton*&gt; buttons = parentWidget-&gt;<span class="built_in">findChildren</span>&lt;QPushButton*&gt;(<span class="string">&quot;myButton&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (QPushButton *button : buttons) &#123;</span><br><span class="line">    <span class="comment">// 对每个找到的按钮进行操作</span></span><br><span class="line">    button-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Found Multiple Buttons!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h3><ul>
<li><strong>动态 UI 查找</strong>：在运行时查找动态生成的 UI 元素。</li>
<li><strong>复用代码</strong>：通过查找对象，可以避免直接传递指针来访问特定 UI 元素，从而提高代码的可复用性和维护性。</li>
<li><strong>调试</strong>：查找和验证某个对象是否正确创建并存在于对象树中。</li>
</ul>
<p><code>findChild()</code> 是 Qt 中非常强大的工具，特别适用于需要在运行时动态查找和操作 UI 元素的场景。</p>
<h2 id="Qt-QTextCodec-setCodecForLocale-函数-详解"><a href="#Qt-QTextCodec-setCodecForLocale-函数-详解" class="headerlink" title="Qt QTextCodec::setCodecForLocale() 函数 详解"></a>Qt QTextCodec::setCodecForLocale() 函数 详解</h2><p><code>QTextCodec::setCodecForLocale()</code> 是 Qt 中用于设置程序的字符编码的函数。具体来说，它设置用于处理当前区域语言（locale）的字符编码。</p>
<h3 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">QTextCodec::setCodecForLocale</span><span class="params">(QTextCodec *codec)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-主要用途"><a href="#2-主要用途" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h3><p><code>setCodecForLocale()</code> 函数的作用是为本地字符编码（locale）设置一个自定义的编码器（<code>QTextCodec</code>）。这影响到与本地字符编码相关的操作，如从文件系统读取文件名、处理文本输入输出等。</p>
<p>Qt 中的字符编码处理依赖 <code>QTextCodec</code>，它是一个字符编码转换的类。不同的 <code>QTextCodec</code> 子类代表了不同的字符编码方式，例如 UTF-8、GBK、ISO 8859-1 等。</p>
<h3 id="3-具体使用场景"><a href="#3-具体使用场景" class="headerlink" title="3. 具体使用场景"></a>3. 具体使用场景</h3><p>在多语言应用中，可能会遇到字符编码问题，例如中文路径或文件内容乱码。通过设置适当的 <code>QTextCodec</code>，可以解决这些问题。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为 UTF-8 编码</span></span><br><span class="line">    QTextCodec::<span class="built_in">setCodecForLocale</span>(QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者设置为 GBK 编码（用于处理中文字符）</span></span><br><span class="line">    QTextCodec::<span class="built_in">setCodecForLocale</span>(QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你的应用程序代码</span></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><p>从 Qt 5 开始，<code>setCodecForLocale()</code> 已经逐渐被淘汰，因为 Qt 更推荐使用 Unicode（如 UTF-8）作为全局字符编码。大多数现代应用不需要手动设置字符编码。Qt 默认使用 UTF-8 编码来处理字符串，并且建议开发者尽量遵循这个标准。</p>
<h3 id="5-相关函数"><a href="#5-相关函数" class="headerlink" title="5. 相关函数"></a>5. 相关函数</h3><ul>
<li><code>QTextCodec::codecForLocale()</code>: 获取当前设置的本地编码。</li>
<li><code>QTextCodec::codecForName(const char *name)</code>: 根据编码名称获取对应的 <code>QTextCodec</code> 对象。</li>
</ul>
<h3 id="6-示例代码"><a href="#6-示例代码" class="headerlink" title="6. 示例代码"></a>6. 示例代码</h3><p>以下是如何在早期版本的 Qt 中使用 <code>setCodecForLocale()</code> 的一个典型场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将本地编码设置为 GBK（适用于简体中文环境）</span></span><br><span class="line">    QTextCodec::<span class="built_in">setCodecForLocale</span>(QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续其他应用逻辑...</span></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-现代-Qt-的替代方案"><a href="#7-现代-Qt-的替代方案" class="headerlink" title="7. 现代 Qt 的替代方案"></a>7. 现代 Qt 的替代方案</h3><p>在现代 Qt 中，通常不需要显式设置编码。确保使用 QString、QByteArray 以及使用 UTF-8 编码文件可以避免大多数字符编码问题。</p>
<p>通过以上内容，你应该了解了 <code>QTextCodec::setCodecForLocale()</code> 的用法及其在现代 Qt 开发中的替代方案。</p>
<h2 id="QTextCodec-codecForName-函数-详解"><a href="#QTextCodec-codecForName-函数-详解" class="headerlink" title="QTextCodec::codecForName() 函数 详解"></a>QTextCodec::codecForName() 函数 详解</h2><p><code>QTextCodec::codecForName()</code> 是 Qt 中用于根据字符编码名称获取对应 <code>QTextCodec</code> 对象的静态函数。<code>QTextCodec</code> 是一个处理字符编码转换的类，这个函数允许开发者选择适当的字符编码以处理文本数据的编码和解码。</p>
<h3 id="1-函数原型-1"><a href="#1-函数原型-1" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> QTextCodec *<span class="title">QTextCodec::codecForName</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> QTextCodec *<span class="title">QTextCodec::codecForName</span><span class="params">(<span class="type">const</span> QByteArray &amp;name)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-主要用途-1"><a href="#2-主要用途-1" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h3><p><code>codecForName()</code> 函数用于根据指定的编码名称返回对应的 <code>QTextCodec</code> 实例。这对于在多语言环境下处理不同编码格式的文本文件或网络数据非常有用。例如，你可能需要处理 UTF-8、GBK 或 ISO-8859-1 等编码的文本内容。</p>
<h3 id="3-具体用法"><a href="#3-具体用法" class="headerlink" title="3. 具体用法"></a>3. 具体用法</h3><p>下面是使用 <code>codecForName()</code> 的典型场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 UTF-8 编码的 QTextCodec 实例</span></span><br><span class="line">    QTextCodec *utf8Codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 QString 编码为 UTF-8 字节数组</span></span><br><span class="line">    QString str = <span class="string">&quot;Hello, 你好!&quot;</span>;</span><br><span class="line">    QByteArray encodedStr = utf8Codec-&gt;<span class="built_in">fromUnicode</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 UTF-8 字节数组解码为 QString</span></span><br><span class="line">    QString decodedStr = utf8Codec-&gt;<span class="built_in">toUnicode</span>(encodedStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-参数说明"><a href="#4-参数说明" class="headerlink" title="4. 参数说明"></a>4. 参数说明</h3><ul>
<li><strong><code>const char *name</code></strong>: 表示编码名称的 C 字符串，例如 <code>&quot;UTF-8&quot;</code>、<code>&quot;GBK&quot;</code>、<code>&quot;ISO-8859-1&quot;</code> 等。</li>
<li><strong><code>const QByteArray &amp;name</code></strong>: 作为 QByteArray 类型的编码名称，适用于编码名称是动态生成的场景。</li>
</ul>
<h3 id="5-返回值"><a href="#5-返回值" class="headerlink" title="5. 返回值"></a>5. 返回值</h3><ul>
<li>成功时返回对应编码的 <code>QTextCodec</code> 对象指针。</li>
<li>如果找不到对应编码，返回 <code>nullptr</code>。</li>
</ul>
<h3 id="6-常用编码名称"><a href="#6-常用编码名称" class="headerlink" title="6. 常用编码名称"></a>6. 常用编码名称</h3><p>一些常用的编码名称包括：</p>
<ul>
<li><code>&quot;UTF-8&quot;</code>：用于处理 Unicode 的最常见编码，适合多语言文本。</li>
<li><code>&quot;GBK&quot;</code>：中文常用编码。</li>
<li><code>&quot;ISO-8859-1&quot;</code>：常见于西欧语言的编码。</li>
<li><code>&quot;Shift-JIS&quot;</code>：用于日语编码。</li>
</ul>
<p>编码名称不区分大小写，输入 <code>&quot;utf-8&quot;</code> 或 <code>&quot;UTF-8&quot;</code> 均可。</p>
<h3 id="7-示例代码"><a href="#7-示例代码" class="headerlink" title="7. 示例代码"></a>7. 示例代码</h3><p>下面的代码展示了如何根据不同的编码名称获取对应的 <code>QTextCodec</code>，并进行文本转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 GBK 编码的 QTextCodec 实例</span></span><br><span class="line">    QTextCodec *codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (codec) &#123;</span><br><span class="line">        QString text = <span class="string">&quot;你好, 世界!&quot;</span>;</span><br><span class="line">        QByteArray encodedText = codec-&gt;<span class="built_in">fromUnicode</span>(text);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Encoded text (GBK):&quot;</span> &lt;&lt; encodedText;</span><br><span class="line"></span><br><span class="line">        QString decodedText = codec-&gt;<span class="built_in">toUnicode</span>(encodedText);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Decoded text:&quot;</span> &lt;&lt; decodedText;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Error: Codec not found!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-注意事项"><a href="#8-注意事项" class="headerlink" title="8. 注意事项"></a>8. 注意事项</h3><ul>
<li>在调用 <code>codecForName()</code> 时，如果编码名称无效（如拼写错误或 Qt 不支持），函数将返回 <code>nullptr</code>，因此在使用返回值之前需要检查其有效性。</li>
<li>尽量在现代应用中使用 Unicode（如 UTF-8）编码，减少字符编码转换问题。</li>
</ul>
<h3 id="9-相关函数"><a href="#9-相关函数" class="headerlink" title="9. 相关函数"></a>9. 相关函数</h3><ul>
<li><code>QTextCodec::setCodecForLocale()</code>: 设置程序的本地字符编码。</li>
<li><code>QTextCodec::codecForLocale()</code>: 获取当前本地环境使用的编码。</li>
<li><code>QTextCodec::availableCodecs()</code>: 获取所有可用编码名称的列表。</li>
</ul>
<p>通过这些内容，你应该掌握了 <code>QTextCodec::codecForName()</code> 的用法以及它在字符编码处理中的重要作用。</p>
<h2 id="Qt-QT-BEGIN-NAMESPACE-宏-详解"><a href="#Qt-QT-BEGIN-NAMESPACE-宏-详解" class="headerlink" title="Qt QT_BEGIN_NAMESPACE 宏 详解"></a>Qt QT_BEGIN_NAMESPACE 宏 详解</h2><p><code>QT_BEGIN_NAMESPACE</code> 是 Qt 中定义的一个宏，通常用于简化命名空间的管理，特别是在处理 Qt 库的代码时。这个宏与 <code>QT_END_NAMESPACE</code> 配合使用，主要目的是将 Qt 的类、函数等代码封装到命名空间 <code>Qt</code> 中。</p>
<h3 id="1-作用和用法"><a href="#1-作用和用法" class="headerlink" title="1. 作用和用法"></a>1. 作用和用法</h3><p><code>QT_BEGIN_NAMESPACE</code> 是在代码中用于开启 Qt 命名空间的宏定义，它的作用相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Qt &#123;</span><br></pre></td></tr></table></figure>

<p>与之对应，<code>QT_END_NAMESPACE</code> 用于关闭命名空间，等同于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h3><p>在 Qt 库的源码或插件开发中，可能会看到以下形式的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QWidget</span> &#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QT_END_NAMESPACE</span><br></pre></td></tr></table></figure>

<p>这段代码实际上被处理为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Qt &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QWidget</span> &#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace Qt</span></span><br></pre></td></tr></table></figure>

<p>通过使用这些宏，Qt 提供了一个方便的方式来管理命名空间，确保 Qt 库内部代码在正确的命名空间内被封装。</p>
<h3 id="3-为什么使用这些宏？"><a href="#3-为什么使用这些宏？" class="headerlink" title="3. 为什么使用这些宏？"></a>3. 为什么使用这些宏？</h3><p>Qt 采用这些宏而不是直接使用 <code>namespace Qt &#123; ... &#125;</code> 这种语法的原因在于：</p>
<ol>
<li><strong>跨平台兼容性</strong>：Qt 是一个跨平台库，为了在不同的编译器、平台上保持代码一致性，使用宏可以更灵活地适应不同平台的特殊需求。</li>
<li><strong>条件编译支持</strong>：通过这些宏，Qt 可以根据配置或编译选项有条件地开启或关闭命名空间。例如，在某些特殊编译环境下，可能不需要使用 <code>Qt</code> 命名空间，这时可以通过配置条件控制这些宏的行为。</li>
<li><strong>简化代码维护</strong>：在大型代码库中使用宏，可以在需要更改命名空间策略时集中管理，避免大量手动修改。</li>
</ol>
<h3 id="4-相关宏"><a href="#4-相关宏" class="headerlink" title="4. 相关宏"></a>4. 相关宏</h3><p>除了 <code>QT_BEGIN_NAMESPACE</code> 和 <code>QT_END_NAMESPACE</code>，还有一些相关的宏，用于处理命名空间或条件编译：</p>
<ul>
<li><code>QT_USE_NAMESPACE</code>: 当在项目中使用 Qt 命名空间时，可以在代码中包含这个宏，以确保代码在正确的命名空间中运行。</li>
<li><code>QT_PREPEND_NAMESPACE(ClassName)</code>: 这个宏用于在不使用命名空间时显式地为类名加上 <code>Qt::</code> 前缀，如 <code>Qt::QWidget</code>。</li>
<li><code>QT_END_HEADER</code>: 用于在头文件中结束命名空间的定义，特别是在跨平台的头文件中使用。</li>
</ul>
<h3 id="5-在项目中的使用"><a href="#5-在项目中的使用" class="headerlink" title="5. 在项目中的使用"></a>5. 在项目中的使用</h3><p>在自己的项目中，通常不需要直接使用这些宏，除非你在开发 Qt 插件、扩展库或直接修改 Qt 源码。在普通的 Qt 应用程序开发中，直接使用 <code>Qt</code> 命名空间即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，你不需要关心 <code>QT_BEGIN_NAMESPACE</code> 等宏，因为 Qt 的头文件已经处理了命名空间的封装。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p><code>QT_BEGIN_NAMESPACE</code> 和 <code>QT_END_NAMESPACE</code> 是 Qt 用于命名空间管理的宏，它们的作用是简化 Qt 库代码中命名空间的封装。这种设计提高了代码的可维护性、跨平台兼容性，并为条件编译提供了灵活性。在大多数应用开发中，开发者不需要直接使用这些宏，只需知道它们在 Qt 库中的作用即可。</p>
<h2 id="Qt-Q-OBJECT-宏-详解"><a href="#Qt-Q-OBJECT-宏-详解" class="headerlink" title="Qt Q_OBJECT 宏 详解"></a>Qt Q_OBJECT 宏 详解</h2><p><code>Q_OBJECT</code> 宏是 Qt 框架中用于支持 Qt 元对象系统的关键宏。这个宏通常放在 Qt 类的声明部分，特别是需要使用信号和槽机制的类。它使得 Qt 的一些高级特性，如信号和槽、属性系统、动态属性等，可以在类中工作。下面是对 <code>Q_OBJECT</code> 宏的详细解解：</p>
<h3 id="1-定义和位置"><a href="#1-定义和位置" class="headerlink" title="1. 定义和位置"></a>1. <strong>定义和位置</strong></h3><p><code>Q_OBJECT</code> 宏必须放在类的 <code>public</code> 或 <code>protected</code> 访问修饰符下方，紧接在类声明的开头。这是因为宏会在类的头文件中生成一些额外的代码，类的元对象系统需要这些代码来实现 Qt 的信号和槽机制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySlot</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-元对象系统"><a href="#2-元对象系统" class="headerlink" title="2. 元对象系统"></a>2. <strong>元对象系统</strong></h3><p>当你在一个类中使用 <code>Q_OBJECT</code> 宏时，Qt 的元对象系统会生成一些额外的代码，包括：</p>
<ul>
<li><strong>信号和槽机制的支持</strong>：<code>Q_OBJECT</code> 宏让类能够发射信号并处理槽函数。</li>
<li><strong>动态属性的支持</strong>：允许类在运行时动态地添加和查询属性。</li>
<li><strong>元对象信息</strong>：提供有关类的运行时信息，如类名、继承关系等。</li>
</ul>
<h3 id="3-MOC（Meta-Object-Compiler）"><a href="#3-MOC（Meta-Object-Compiler）" class="headerlink" title="3. MOC（Meta-Object Compiler）"></a>3. <strong>MOC（Meta-Object Compiler）</strong></h3><p><code>Q_OBJECT</code> 宏的主要作用是让 Qt 的 Meta-Object Compiler（MOC）工具生成相关的元对象代码。MOC 工具会读取你的类定义文件，并根据 <code>Q_OBJECT</code> 宏生成一个 <code>.moc</code> 文件，这个文件包含了信号和槽机制的实现代码。在编译过程中，MOC 生成的代码会被编译到最终的二进制文件中。</p>
<h3 id="4-信号和槽"><a href="#4-信号和槽" class="headerlink" title="4. 信号和槽"></a>4. <strong>信号和槽</strong></h3><p>信号和槽是 Qt 的核心特性，<code>Q_OBJECT</code> 宏使得你可以在类中声明信号和槽，并且在运行时连接它们。信号是事件的通知，而槽是响应这些事件的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明信号</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明槽</span></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySlot</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-动态属性和其他功能"><a href="#5-动态属性和其他功能" class="headerlink" title="5. 动态属性和其他功能"></a>5. <strong>动态属性和其他功能</strong></h3><p>使用 <code>Q_OBJECT</code> 宏后，你的类还可以利用 Qt 的动态属性系统，允许在运行时设置和获取对象的属性。此外，<code>Q_OBJECT</code> 使得 Qt 能够在运行时查询类的元信息。</p>
<h3 id="6-编译注意事项"><a href="#6-编译注意事项" class="headerlink" title="6. 编译注意事项"></a>6. <strong>编译注意事项</strong></h3><p>如果你更改了包含 <code>Q_OBJECT</code> 宏的类的定义，你必须重新运行 MOC 并重新编译项目。通常，Qt 的构建系统（如 qmake 或 CMake）会自动处理这个过程。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySlot</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总之，<code>Q_OBJECT</code> 宏是 Qt 的信号和槽机制、动态属性以及元对象系统的核心，它是实现 Qt 许多功能的基础。</p>
<h2 id="Qt-connect-函数-详解"><a href="#Qt-connect-函数-详解" class="headerlink" title="Qt connect() 函数 详解"></a>Qt connect() 函数 详解</h2><p><code>connect()</code> 函数是 Qt 信号与槽机制的核心。它用于将信号和槽函数连接起来，使得当某个信号发出时，自动调用与其连接的槽函数。这种机制是 Qt 的基础，用于实现组件之间的松耦合通信，尤其在 GUI 编程中非常常用。</p>
<h3 id="1-信号与槽机制简介"><a href="#1-信号与槽机制简介" class="headerlink" title="1. 信号与槽机制简介"></a>1. <strong>信号与槽机制简介</strong></h3><p>在 Qt 中，信号（signal）和槽（slot）是一种观察者模式的实现。信号用于通知事件的发生，而槽是用来处理这些事件的函数。当某个对象发出信号时，与之连接的槽函数会被自动调用。</p>
<h3 id="2-connect-函数的语法"><a href="#2-connect-函数的语法" class="headerlink" title="2. connect() 函数的语法"></a>2. <strong>connect() 函数的语法</strong></h3><p>Qt 的 <code>connect()</code> 函数有多种形式，最常用的语法如下：</p>
<h4 id="2-1-基于旧版字符串的连接（Qt4-风格）"><a href="#2-1-基于旧版字符串的连接（Qt4-风格）" class="headerlink" title="2.1 基于旧版字符串的连接（Qt4 风格）"></a>2.1 基于旧版字符串的连接（Qt4 风格）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">signalName</span>(parameters)), receiver, <span class="built_in">SLOT</span>(<span class="built_in">slotName</span>(parameters)));</span><br></pre></td></tr></table></figure>

<p>这种方法使用 <code>SIGNAL()</code> 和 <code>SLOT()</code> 宏将信号和槽的名称转换为字符串。虽然这种方式在旧版 Qt 中常用，但现在已不推荐使用。</p>
<h4 id="2-2-基于新信号槽语法（Qt5-及以上）"><a href="#2-2-基于新信号槽语法（Qt5-及以上）" class="headerlink" title="2.2 基于新信号槽语法（Qt5 及以上）"></a>2.2 基于新信号槽语法（Qt5 及以上）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(sender, &amp;SenderClass::signalName, receiver, &amp;ReceiverClass::slotName);</span><br></pre></td></tr></table></figure>

<p>这种方法是类型安全的，编译器会在编译期检查信号和槽的参数匹配情况，并且不需要使用宏，语法更加清晰和安全。</p>
<h4 id="2-3-使用-Lambda-表达式"><a href="#2-3-使用-Lambda-表达式" class="headerlink" title="2.3 使用 Lambda 表达式"></a>2.3 使用 Lambda 表达式</h4><p>在 Qt5 中，槽函数还可以是一个 Lambda 表达式，非常适合简单的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(sender, &amp;SenderClass::signalName, [](parameters) &#123;</span><br><span class="line">    <span class="comment">// Lambda 表达式内的槽函数实现</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-connect-函数的参数详解"><a href="#3-connect-函数的参数详解" class="headerlink" title="3. connect() 函数的参数详解"></a>3. <strong>connect() 函数的参数详解</strong></h3><ul>
<li>**<code>sender</code>**：发出信号的对象，通常是一个 <code>QObject</code> 或其派生类的实例。</li>
<li>**<code>signalName</code>**：信号的名称。在旧版语法中，需要用 <code>SIGNAL()</code> 宏包裹；在新版语法中，直接使用指针形式 <code>&amp;SenderClass::signalName</code>。</li>
<li>**<code>receiver</code>**：接收信号的对象，也是一个 <code>QObject</code> 或其派生类的实例。</li>
<li>**<code>slotName</code>**：槽函数的名称。在旧版语法中，用 <code>SLOT()</code> 宏包裹；在新版语法中，直接使用指针形式 <code>&amp;ReceiverClass::slotName</code>。</li>
</ul>
<h3 id="4-connect-的高级用法"><a href="#4-connect-的高级用法" class="headerlink" title="4. connect() 的高级用法"></a>4. <strong>connect() 的高级用法</strong></h3><ul>
<li><p><strong>连接到多个槽函数</strong>：一个信号可以连接到多个槽函数，信号发出时，这些槽函数会按连接顺序依次被调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, &amp;SenderClass::signalName, receiver1, &amp;ReceiverClass1::slotName);</span><br><span class="line"><span class="built_in">connect</span>(sender, &amp;SenderClass::signalName, receiver2, &amp;ReceiverClass2::slotName);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>连接到同一个槽函数的多个信号</strong>：多个信号可以连接到同一个槽函数，这样无论哪个信号发出，都会调用相同的槽函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender1, &amp;SenderClass1::signalName, receiver, &amp;ReceiverClass::slotName);</span><br><span class="line"><span class="built_in">connect</span>(sender2, &amp;SenderClass2::signalName, receiver, &amp;ReceiverClass::slotName);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>连接到匿名槽（Lambda 表达式）</strong>：适用于只需处理简单逻辑的场景。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(button, &amp;QPushButton::clicked, []() &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Button clicked!&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>连接到 Qt 内置信号</strong>：很多 Qt 控件自带常用信号，如按钮的 <code>clicked()</code> 信号、文本框的 <code>textChanged()</code> 信号等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::onButtonClicked);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-连接失败的原因及解决方法"><a href="#5-连接失败的原因及解决方法" class="headerlink" title="5. 连接失败的原因及解决方法"></a>5. <strong>连接失败的原因及解决方法</strong></h3><ul>
<li><strong>信号和槽参数不匹配</strong>：信号和槽的参数类型和数量必须一致，否则连接将失败。</li>
<li><strong>对象生命周期问题</strong>：<code>sender</code> 或 <code>receiver</code> 可能在信号发出前已经被销毁，导致连接失效。</li>
<li><strong>无效的信号或槽名称</strong>：检查信号和槽是否拼写正确，且使用正确的语法（旧版或新版）。</li>
<li><strong>类型不兼容</strong>：新版语法下，信号和槽必须是同一个类的成员函数指针。</li>
</ul>
<h3 id="6-断开信号与槽的连接"><a href="#6-断开信号与槽的连接" class="headerlink" title="6. 断开信号与槽的连接"></a>6. <strong>断开信号与槽的连接</strong></h3><p>使用 <code>QObject::disconnect()</code> 可以手动断开信号与槽的连接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">disconnect</span>(sender, &amp;SenderClass::signalName, receiver, &amp;ReceiverClass::slotName);</span><br></pre></td></tr></table></figure>

<p>或者直接使用 <code>disconnect(sender)</code> 来断开 <code>sender</code> 发出的所有信号。</p>
<h3 id="7-connect-的返回值"><a href="#7-connect-的返回值" class="headerlink" title="7. connect() 的返回值"></a>7. <strong>connect() 的返回值</strong></h3><p><code>connect()</code> 函数返回一个 <code>bool</code> 值，表示连接是否成功。通常不需要手动检查返回值，但在复杂或关键场景下，检查返回值可以帮助调试连接失败的原因。</p>
<h3 id="8-常见示例"><a href="#8-常见示例" class="headerlink" title="8. 常见示例"></a>8. <strong>常见示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Click Me&quot;</span>)</span></span>;</span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;button, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="literal">nullptr</span>, <span class="string">&quot;Title&quot;</span>, <span class="string">&quot;Button clicked!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    button.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>connect()</code> 是 Qt 信号与槽机制的核心，它允许在不同对象间实现松耦合的事件处理。在 Qt5 及以上版本中，推荐使用新版的指针语法，因为它类型安全、语法简洁且更易于维护。通过灵活使用 <code>connect()</code>，可以极大简化 Qt 程序中的事件处理流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-01-QStackedWidget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-01-QStackedWidget/" class="post-title-link" itemprop="url">QStackedWidget</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>QStackedWidget类相关笔记</li>
</ul>
<h1 id="QStackedWidget-详解"><a href="#QStackedWidget-详解" class="headerlink" title="QStackedWidget 详解"></a>QStackedWidget 详解</h1><p><code>QStackedWidget</code> 是 Qt 框架中的一个控件类，用于在同一位置显示多个小部件（widget），但一次只能显示其中的一个。它常用于需要在同一空间切换不同页面内容的场景，如实现向导界面、选项卡式界面或动态内容切换等。</p>
<h3 id="QStackedWidget-类的详细说明"><a href="#QStackedWidget-类的详细说明" class="headerlink" title="QStackedWidget 类的详细说明"></a><code>QStackedWidget</code> 类的详细说明</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul>
<li><strong><code>QStackedWidget</code></strong> 继承自 <code>QFrame</code>，属于一个容器小部件。</li>
<li>该控件维护一组子小部件，这些子小部件按堆栈排列。一次只能显示一个小部件，其他小部件会被隐藏。</li>
</ul>
<h4 id="2-常用方法和成员函数"><a href="#2-常用方法和成员函数" class="headerlink" title="2. 常用方法和成员函数"></a>2. 常用方法和成员函数</h4><ul>
<li><p><strong><code>addWidget(QWidget *widget)</code></strong>:<br>将新的小部件添加到堆栈中，返回新页面的索引值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStackedWidget *stackedWidget = <span class="keyword">new</span> QStackedWidget;</span><br><span class="line">QWidget *page1 = <span class="keyword">new</span> QWidget;</span><br><span class="line">stackedWidget-&gt;<span class="built_in">addWidget</span>(page1);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>insertWidget(int index, QWidget *widget)</code></strong>:<br>在指定索引位置插入一个小部件。</p>
</li>
<li><p><strong><code>setCurrentIndex(int index)</code></strong>:<br>设置当前显示的小部件的索引。可以通过此方法切换页面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>); <span class="comment">// 显示第一个页面</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>setCurrentWidget(QWidget *widget)</code></strong>:<br>通过指针设置当前显示的小部件。</p>
</li>
<li><p><strong><code>currentIndex()</code></strong>:<br>返回当前显示的小部件的索引。</p>
</li>
<li><p><strong><code>currentWidget()</code></strong>:<br>返回当前显示的小部件的指针。</p>
</li>
<li><p><strong><code>removeWidget(QWidget *widget)</code></strong>:<br>从堆栈中移除指定的小部件，不会删除该小部件。</p>
</li>
</ul>
<h4 id="3-信号（Signals）"><a href="#3-信号（Signals）" class="headerlink" title="3. 信号（Signals）"></a>3. 信号（Signals）</h4><ul>
<li><p><strong><code>currentChanged(int index)</code></strong>:<br>当当前小部件的索引改变时触发。</p>
</li>
<li><p><strong><code>widgetRemoved(int index)</code></strong>:<br>当小部件从堆栈中移除时触发。</p>
</li>
</ul>
<h4 id="4-使用示例"><a href="#4-使用示例" class="headerlink" title="4. 使用示例"></a>4. 使用示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStackedWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 QStackedWidget 实例</span></span><br><span class="line">    QStackedWidget *stackedWidget = <span class="keyword">new</span> QStackedWidget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个页面</span></span><br><span class="line">    QWidget *page1 = <span class="keyword">new</span> QWidget;</span><br><span class="line">    QPushButton *button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Page 1&quot;</span>);</span><br><span class="line">    QVBoxLayout *page1Layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(page1);</span><br><span class="line">    page1Layout-&gt;<span class="built_in">addWidget</span>(button1);</span><br><span class="line"></span><br><span class="line">    QWidget *page2 = <span class="keyword">new</span> QWidget;</span><br><span class="line">    QPushButton *button2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Page 2&quot;</span>);</span><br><span class="line">    QVBoxLayout *page2Layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(page2);</span><br><span class="line">    page2Layout-&gt;<span class="built_in">addWidget</span>(button2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加页面到 QStackedWidget</span></span><br><span class="line">    stackedWidget-&gt;<span class="built_in">addWidget</span>(page1);</span><br><span class="line">    stackedWidget-&gt;<span class="built_in">addWidget</span>(page2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 QStackedWidget 添加到主布局</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(stackedWidget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换页面示例</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(button1, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(button2, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-常见应用场景"><a href="#5-常见应用场景" class="headerlink" title="5. 常见应用场景"></a>5. 常见应用场景</h3><ul>
<li><strong>向导程序</strong>: <code>QStackedWidget</code> 非常适合用于实现多步骤的向导程序，每个页面代表向导的一个步骤。</li>
<li><strong>动态内容切换</strong>: 如设置窗口、选项卡界面等。</li>
<li><strong>多功能面板</strong>: 实现功能区的页面切换。</li>
</ul>
<h3 id="6-样式和自定义"><a href="#6-样式和自定义" class="headerlink" title="6. 样式和自定义"></a>6. 样式和自定义</h3><p><code>QStackedWidget</code> 可以像其他 Qt 小部件一样通过 <code>QStyle</code> 和 <code>QSS</code>（Qt 样式表）来进行样式自定义。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStackedWidget &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a>7. 注意事项</h3><ul>
<li>如果需要在切换页面时进行一些处理逻辑，可以连接 <code>currentChanged()</code> 信号来进行。</li>
<li><code>QStackedWidget</code> 只会在其当前显示的小部件上处理事件，如鼠标和键盘事件，因此需要确保切换逻辑合理。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>QStackedWidget</code> 是一个非常有用的控件，用于实现页面切换或动态内容显示。通过其 API 和信号槽机制，开发者可以轻松创建复杂的用户界面，增强用户体验。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-03-QMainWindow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-03-QMainWindow/" class="post-title-link" itemprop="url">QMainWindow</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="QMainWindow-类-详解"><a href="#QMainWindow-类-详解" class="headerlink" title="QMainWindow 类 详解"></a>QMainWindow 类 详解</h2><p><code>QMainWindow</code> 是 Qt 框架中用于创建主窗口的类。它提供了一个标准的窗口框架，通常用于构建图形用户界面（GUI）应用程序的主窗口。<code>QMainWindow</code> 提供了功能齐全的窗口部件，如菜单栏、工具栏、状态栏等，以及一个中央区域用于显示主要内容。</p>
<h3 id="1-类定义"><a href="#1-类定义" class="headerlink" title="1. 类定义"></a>1. 类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QMainWindow</span> : <span class="keyword">public</span> QWidget</span><br></pre></td></tr></table></figure>
<p><code>QMainWindow</code> 继承自 <code>QWidget</code>，因此它也是一个 QWidget，具有所有 QWidget 的特性。</p>
<h3 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2. 主要功能"></a>2. 主要功能</h3><p><code>QMainWindow</code> 提供了一些标准的窗口元素和布局管理功能：</p>
<ul>
<li><strong>菜单栏</strong> (<code>QMenuBar</code>): 用于显示应用程序的菜单项。</li>
<li><strong>工具栏</strong> (<code>QToolBar</code>): 用于提供快捷工具按钮。</li>
<li><strong>状态栏</strong> (<code>QStatusBar</code>): 用于显示状态信息。</li>
<li><strong>中央区域</strong> (<code>QWidget</code>): 用于显示主内容区域，可以是任何其他的 QWidget。</li>
</ul>
<h3 id="3-关键成员函数"><a href="#3-关键成员函数" class="headerlink" title="3. 关键成员函数"></a>3. 关键成员函数</h3><h4 id="1-设置和获取中央窗口部件"><a href="#1-设置和获取中央窗口部件" class="headerlink" title="1. 设置和获取中央窗口部件"></a>1. <strong>设置和获取中央窗口部件</strong></h4><ul>
<li><code>void setCentralWidget(QWidget *widget)</code>: 设置主窗口的中央部件。</li>
<li><code>QWidget *centralWidget() const</code>: 获取当前的中央部件。</li>
</ul>
<h4 id="2-菜单栏管理"><a href="#2-菜单栏管理" class="headerlink" title="2. 菜单栏管理"></a>2. <strong>菜单栏管理</strong></h4><ul>
<li><code>QMenuBar *menuBar() const</code>: 获取菜单栏对象。如果需要在窗口中添加菜单项，可以使用此函数。</li>
</ul>
<h4 id="3-工具栏管理"><a href="#3-工具栏管理" class="headerlink" title="3. 工具栏管理"></a>3. <strong>工具栏管理</strong></h4><ul>
<li><code>QToolBar *addToolBar(const QString &amp;title)</code>: 添加工具栏到主窗口。</li>
<li><code>QToolBar *toolBar(const QString &amp;title) const</code>: 根据标题获取工具栏对象。</li>
</ul>
<h4 id="4-状态栏管理"><a href="#4-状态栏管理" class="headerlink" title="4. 状态栏管理"></a>4. <strong>状态栏管理</strong></h4><ul>
<li><code>QStatusBar *statusBar() const</code>: 获取状态栏对象，用于在窗口底部显示状态信息。</li>
<li><code>void setStatusBar(QStatusBar *statusBar)</code>: 设置自定义状态栏。</li>
</ul>
<h4 id="5-菜单和工具栏操作"><a href="#5-菜单和工具栏操作" class="headerlink" title="5. 菜单和工具栏操作"></a>5. <strong>菜单和工具栏操作</strong></h4><ul>
<li><code>void removeToolBar(QToolBar *toolbar)</code>: 从主窗口中移除工具栏。</li>
<li><code>void removeToolBarBreak(QToolBar *toolbar)</code>: 移除工具栏之间的分隔符。</li>
</ul>
<h3 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h3><p>以下是一个简单的使用 <code>QMainWindow</code> 的示例，展示了如何创建一个带有菜单栏、工具栏和状态栏的主窗口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStatusBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QMainWindow mainWindow;</span><br><span class="line">    mainWindow.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QMainWindow Example&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并设置中央部件</span></span><br><span class="line">    QWidget *centralWidget = <span class="keyword">new</span> QWidget;</span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Click Me&quot;</span>);</span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">    centralWidget-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    mainWindow.<span class="built_in">setCentralWidget</span>(centralWidget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建菜单栏</span></span><br><span class="line">    QMenuBar *menuBar = mainWindow.<span class="built_in">menuBar</span>();</span><br><span class="line">    QMenu *fileMenu = menuBar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;File&quot;</span>);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;Open&quot;</span>);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;Save&quot;</span>);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;Exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建工具栏</span></span><br><span class="line">    QToolBar *toolBar = mainWindow.<span class="built_in">addToolBar</span>(<span class="string">&quot;Main Toolbar&quot;</span>);</span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;Open&quot;</span>);</span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;Save&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建状态栏</span></span><br><span class="line">    QStatusBar *statusBar = <span class="keyword">new</span> QStatusBar;</span><br><span class="line">    mainWindow.<span class="built_in">setStatusBar</span>(statusBar);</span><br><span class="line">    statusBar-&gt;<span class="built_in">showMessage</span>(<span class="string">&quot;Ready&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示主窗口</span></span><br><span class="line">    mainWindow.<span class="built_in">resize</span>(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    mainWindow.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-继承和扩展"><a href="#5-继承和扩展" class="headerlink" title="5. 继承和扩展"></a>5. 继承和扩展</h3><p><code>QMainWindow</code> 可以被继承和扩展，以添加自定义功能或修改现有行为。例如，你可以创建一个自定义的主窗口类，添加额外的工具栏或菜单项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStatusBar&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainWindow</span> : <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyMainWindow</span>() &#123;</span><br><span class="line">        <span class="comment">// 自定义菜单</span></span><br><span class="line">        QMenu *fileMenu = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;File&quot;</span>);</span><br><span class="line">        QAction *exitAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;Exit&quot;</span>);</span><br><span class="line">        <span class="built_in">connect</span>(exitAction, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;QMainWindow::close);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义工具栏</span></span><br><span class="line">        QToolBar *toolbar = <span class="built_in">addToolBar</span>(<span class="string">&quot;My Toolbar&quot;</span>);</span><br><span class="line">        toolbar-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;My Action&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义状态栏</span></span><br><span class="line">        <span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="string">&quot;Welcome to My Application&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul>
<li><strong>中央部件</strong>：<code>QMainWindow</code> 只允许设置一个中央部件（<code>centralWidget</code>）。如果你需要在中央区域放置多个部件，可以使用布局管理器将它们组织起来。</li>
<li><strong>工具栏和菜单</strong>：工具栏和菜单可以动态添加或移除，但要确保在主窗口显示之前设置好它们。</li>
<li><strong>状态栏</strong>：状态栏通常用于显示应用程序的状态信息，可以显示多条信息或者使用复杂的状态显示组件。</li>
</ul>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p><code>QMainWindow</code> 是一个功能丰富的主窗口类，提供了标准的窗口元素，如菜单栏、工具栏和状态栏。它是构建 Qt GUI 应用程序的基础组件之一，并提供了丰富的接口来管理和定制窗口的各个部分。通过继承和扩展 <code>QMainWindow</code>，你可以创建符合需求的复杂主窗口。</p>
<h2 id="Qt-Ui-MainWindow-类-详解"><a href="#Qt-Ui-MainWindow-类-详解" class="headerlink" title="Qt Ui::MainWindow 类 详解"></a>Qt Ui::MainWindow 类 详解</h2><p>在 Qt 应用程序中，<code>Ui::MainWindow</code> 类通常是由 Qt Designer 生成的用于管理用户界面元素的类。它是 Qt UI 系统的重要组成部分，主要用于连接 UI 界面设计与应用程序逻辑。通常在使用 Qt Designer 设计主窗口时，生成的 <code>.ui</code> 文件会通过 <code>uic</code> 工具转换为 C++ 代码，其中包含一个 <code>Ui::MainWindow</code> 类。</p>
<h3 id="1-Ui-MainWindow-类的作用"><a href="#1-Ui-MainWindow-类的作用" class="headerlink" title="1. Ui::MainWindow 类的作用"></a>1. <strong><code>Ui::MainWindow</code> 类的作用</strong></h3><p><code>Ui::MainWindow</code> 是自动生成的类，它负责管理和初始化设计时创建的 UI 元素。这个类是由 Qt Designer 创建的 <code>.ui</code> 文件转换而来的，通常位于生成的 <code>ui_mainwindow.h</code> 文件中。它主要负责以下内容：</p>
<ul>
<li>创建和布局窗口控件。</li>
<li>初始化控件的属性和默认状态。</li>
<li>提供接口用于在代码中访问这些控件。</li>
</ul>
<h3 id="2-Ui-MainWindow-的使用方式"><a href="#2-Ui-MainWindow-的使用方式" class="headerlink" title="2. Ui::MainWindow 的使用方式"></a>2. <strong><code>Ui::MainWindow</code> 的使用方式</strong></h3><p>当你使用 Qt Designer 创建一个主窗口并将其保存为 <code>mainwindow.ui</code> 时，Qt 会自动生成一个 <code>ui_mainwindow.h</code> 文件，其中包含 <code>Ui::MainWindow</code> 类的定义。这个类可以通过在自定义的 <code>MainWindow</code> 类中包含 <code>ui_mainwindow.h</code> 文件来使用。</p>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><p>假设我们在 Qt Designer 中创建了一个主窗口，并保存为 <code>mainwindow.ui</code>。生成的 <code>ui_mainwindow.h</code> 文件会包含如下内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ui_mainwindow.h（自动生成的文件）</span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QWidget *centralWidget;</span><br><span class="line">    QMenuBar *menuBar;</span><br><span class="line">    QStatusBar *statusBar;</span><br><span class="line">    QPushButton *myButton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setupUi</span><span class="params">(QMainWindow *MainWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (MainWindow-&gt;<span class="built_in">objectName</span>().<span class="built_in">isEmpty</span>())</span><br><span class="line">            MainWindow-&gt;<span class="built_in">setObjectName</span>(QString::<span class="built_in">fromUtf8</span>(<span class="string">&quot;MainWindow&quot;</span>));</span><br><span class="line">        MainWindow-&gt;<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">        centralWidget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(MainWindow);</span><br><span class="line">        menuBar = <span class="keyword">new</span> <span class="built_in">QMenuBar</span>(MainWindow);</span><br><span class="line">        statusBar = <span class="keyword">new</span> <span class="built_in">QStatusBar</span>(MainWindow);</span><br><span class="line">        myButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(centralWidget);</span><br><span class="line">        myButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Click Me&quot;</span>);</span><br><span class="line"></span><br><span class="line">        MainWindow-&gt;<span class="built_in">setCentralWidget</span>(centralWidget);</span><br><span class="line">        MainWindow-&gt;<span class="built_in">setMenuBar</span>(menuBar);</span><br><span class="line">        MainWindow-&gt;<span class="built_in">setStatusBar</span>(statusBar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在自定义主窗口类中的使用："><a href="#在自定义主窗口类中的使用：" class="headerlink" title="在自定义主窗口类中的使用："></a>在自定义主窗口类中的使用：</h4><p>通常，我们会在自定义的主窗口类中使用 <code>Ui::MainWindow</code> 以便将设计的 UI 和应用逻辑结合在一起：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span>  <span class="comment">// 包含自动生成的 UI 类</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">        : QMainWindow(parent), ui(new Ui::MainWindow) &#123;</span></span><br><span class="line">        ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);  <span class="comment">// 初始化 UI</span></span><br><span class="line">        <span class="built_in">connect</span>(ui-&gt;myButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::onButtonClicked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MainWindow</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> ui;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onButtonClicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理按钮点击事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-setupUi-方法"><a href="#3-setupUi-方法" class="headerlink" title="3. setupUi() 方法"></a>3. <strong><code>setupUi()</code> 方法</strong></h3><p><code>setupUi()</code> 方法是 <code>Ui::MainWindow</code> 类中的核心方法。它负责初始化窗口控件并设置其布局、属性、信号槽连接等。通常在主窗口类的构造函数中调用该方法。这个方法需要一个 <code>QMainWindow</code> 对象作为参数，以便将控件添加到主窗口中。</p>
<h3 id="4-访问-UI-元素"><a href="#4-访问-UI-元素" class="headerlink" title="4. 访问 UI 元素"></a>4. <strong>访问 UI 元素</strong></h3><p>通过 <code>Ui::MainWindow</code> 类中的指针，可以轻松访问和操作设计时创建的控件。例如，使用 <code>ui-&gt;myButton</code> 可以访问按钮并设置它的文本或连接信号槽。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;myButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;New Text&quot;</span>);</span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;myButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::onButtonClicked);</span><br></pre></td></tr></table></figure>

<h3 id="5-Ui-MainWindow-与-QMainWindow-的关系"><a href="#5-Ui-MainWindow-与-QMainWindow-的关系" class="headerlink" title="5. Ui::MainWindow 与 QMainWindow 的关系"></a>5. <strong><code>Ui::MainWindow</code> 与 <code>QMainWindow</code> 的关系</strong></h3><p><code>Ui::MainWindow</code> 是一个辅助类，实际的窗口功能仍然由继承自 <code>QMainWindow</code> 的自定义类实现。<code>QMainWindow</code> 提供了主窗口的基本框架和功能（如菜单栏、状态栏、工具栏），而 <code>Ui::MainWindow</code> 主要负责管理控件和布局。</p>
<h3 id="6-自定义控件与扩展-UI"><a href="#6-自定义控件与扩展-UI" class="headerlink" title="6. 自定义控件与扩展 UI"></a>6. <strong>自定义控件与扩展 UI</strong></h3><p>如果你需要在设计时添加自定义控件或进行更多的 UI 扩展，可以在 Qt Designer 中通过提升控件的方式实现。此外，你也可以手动在 <code>MainWindow</code> 类的构造函数中添加新的控件，并将其与现有的 UI 进行整合。</p>
<h3 id="7-典型的工作流程"><a href="#7-典型的工作流程" class="headerlink" title="7. 典型的工作流程"></a>7. <strong>典型的工作流程</strong></h3><ul>
<li>使用 Qt Designer 设计主窗口，并保存为 <code>.ui</code> 文件。</li>
<li>通过 Qt 的构建工具（如 qmake 或 CMake）自动生成对应的 <code>ui_mainwindow.h</code> 文件。</li>
<li>在自定义的主窗口类中包含生成的 <code>ui_mainwindow.h</code> 文件，并使用 <code>Ui::MainWindow</code> 类来管理 UI 元素。</li>
<li>在应用程序逻辑中，使用 <code>ui-&gt;</code> 前缀来访问控件，并编写对应的事件处理代码。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Ui::MainWindow</code> 是一个自动生成的类，它负责将 Qt Designer 设计的 UI 界面与代码逻辑连接起来。通过调用 <code>setupUi()</code>，开发者可以方便地初始化和使用设计时创建的控件，从而简化了 UI 编程的流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-02-QApplication/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-02-QApplication/" class="post-title-link" itemprop="url">QApplication</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="QApplication-类-详解"><a href="#QApplication-类-详解" class="headerlink" title="QApplication 类 详解"></a>QApplication 类 详解</h2><p><code>QApplication</code> 类是 Qt 应用程序的核心类之一，用于管理应用程序的控制流和主要设置。它负责处理应用程序的初始化、事件循环、窗口管理、以及应用全局的设置。通常，一个 GUI 应用程序中只能有一个 <code>QApplication</code> 实例。</p>
<h3 id="1-类定义"><a href="#1-类定义" class="headerlink" title="1. 类定义"></a>1. 类定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QApplication</span> : <span class="keyword">public</span> QGuiApplication</span><br></pre></td></tr></table></figure>
<p><code>QApplication</code> 继承自 <code>QGuiApplication</code>，并且通过其进一步继承了 <code>QCoreApplication</code>。<code>QApplication</code> 是 GUI 程序的基础，而 <code>QGuiApplication</code> 适用于不需要窗口但依然有 GUI 功能的程序（如 OpenGL 渲染等）。<code>QCoreApplication</code> 则用于没有 GUI 的控制台程序。</p>
<h3 id="2-创建-QApplication-对象"><a href="#2-创建-QApplication-对象" class="headerlink" title="2. 创建 QApplication 对象"></a>2. 创建 <code>QApplication</code> 对象</h3><p>在大多数情况下，<code>QApplication</code> 是程序的第一个创建的对象，并且程序的主要控制权交给了它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Hello, Qt!&quot;</span>)</span></span>;</span><br><span class="line">    button.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>QApplication app(argc, argv);</code> 初始化了应用程序对象。</li>
<li><code>app.exec();</code> 进入应用程序的事件循环，处理用户输入和其他事件。</li>
</ul>
<h3 id="3-主要功能和成员函数"><a href="#3-主要功能和成员函数" class="headerlink" title="3. 主要功能和成员函数"></a>3. 主要功能和成员函数</h3><p><code>QApplication</code> 提供了许多全局设置和管理功能：</p>
<h4 id="1-事件循环"><a href="#1-事件循环" class="headerlink" title="1. 事件循环"></a>1. <strong>事件循环</strong></h4><ul>
<li><code>int exec()</code>: 启动事件循环。应用程序在进入这个循环后开始运行，直到调用 <code>quit()</code> 或窗口关闭。</li>
<li><code>void exit(int returnCode = 0)</code>: 退出事件循环。</li>
</ul>
<h4 id="2-全局设置"><a href="#2-全局设置" class="headerlink" title="2. 全局设置"></a>2. <strong>全局设置</strong></h4><ul>
<li><code>void setStyle(const QString &amp;style)</code>: 设置应用程序的 GUI 样式，如 “Fusion”、”Windows”、”Macintosh” 等。</li>
<li><code>QStyle *style()</code>: 返回当前使用的样式。</li>
</ul>
<h4 id="3-应用程序信息"><a href="#3-应用程序信息" class="headerlink" title="3. 应用程序信息"></a>3. <strong>应用程序信息</strong></h4><ul>
<li><code>void setApplicationName(const QString &amp;name)</code>: 设置应用程序的名称。</li>
<li><code>QString applicationName()</code>: 获取应用程序的名称。</li>
<li><code>void setApplicationVersion(const QString &amp;version)</code>: 设置应用程序版本。</li>
<li><code>QString applicationVersion()</code>: 获取应用程序版本。</li>
</ul>
<h4 id="4-图标和主题"><a href="#4-图标和主题" class="headerlink" title="4. 图标和主题"></a>4. <strong>图标和主题</strong></h4><ul>
<li><code>void setWindowIcon(const QIcon &amp;icon)</code>: 设置应用程序的全局图标，这个图标会出现在应用窗口的标题栏、任务栏以及系统托盘中。</li>
<li><code>QIcon windowIcon()</code>: 获取应用程序的图标。</li>
</ul>
<h4 id="5-剪贴板"><a href="#5-剪贴板" class="headerlink" title="5. 剪贴板"></a>5. <strong>剪贴板</strong></h4><ul>
<li><code>QClipboard *clipboard()</code>: 返回系统的剪贴板对象，可以用来复制和粘贴文本、图片等数据。</li>
</ul>
<h4 id="6-应用程序事件处理"><a href="#6-应用程序事件处理" class="headerlink" title="6. 应用程序事件处理"></a>6. <strong>应用程序事件处理</strong></h4><ul>
<li><code>bool notify(QObject *receiver, QEvent *event)</code>: 事件通知处理函数，通常不需要重写，但可以在特殊情况下进行自定义事件处理。</li>
<li><code>void installEventFilter(QObject *filterObj)</code>: 安装事件过滤器，用于拦截和处理特定事件。</li>
</ul>
<h4 id="7-颜色与字体"><a href="#7-颜色与字体" class="headerlink" title="7. 颜色与字体"></a>7. <strong>颜色与字体</strong></h4><ul>
<li><code>void setPalette(const QPalette &amp;palette)</code>: 设置全局调色板，影响整个应用程序的颜色风格。</li>
<li><code>QFont font()</code>: 获取当前应用程序的全局字体。</li>
<li><code>void setFont(const QFont &amp;font)</code>: 设置应用程序的全局字体。</li>
</ul>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul>
<li><code>QApplication</code> 是一个 GUI 应用的核心，因此所有 GUI 应用必须创建 <code>QApplication</code> 对象。</li>
<li>一个应用程序中只能有一个 <code>QApplication</code> 实例。如果尝试创建多个，会导致程序异常。</li>
<li><code>QApplication</code> 必须在创建任何其他 Qt 对象之前创建。</li>
</ul>
<h3 id="5-常见的使用场景"><a href="#5-常见的使用场景" class="headerlink" title="5. 常见的使用场景"></a>5. 常见的使用场景</h3><ul>
<li><strong>应用程序启动和事件管理</strong>: <code>QApplication</code> 的主要职责是启动并维持事件循环，这是 GUI 程序处理用户输入、界面更新的基础。</li>
<li><strong>全局设置</strong>: <code>QApplication</code> 允许你为整个应用程序设置默认的字体、颜色、样式等。</li>
<li><strong>跨平台支持</strong>: Qt 中的 <code>QApplication</code> 处理了许多跨平台细节，使得开发者可以在不同平台上使用一致的 API。</li>
</ul>
<h3 id="6-示例代码"><a href="#6-示例代码" class="headerlink" title="6. 示例代码"></a>6. 示例代码</h3><p>以下是一个更完整的示例，展示了如何使用 <code>QApplication</code> 设置全局样式和图标：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QIcon&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置应用程序信息</span></span><br><span class="line">    app.<span class="built_in">setApplicationName</span>(<span class="string">&quot;My Qt Application&quot;</span>);</span><br><span class="line">    app.<span class="built_in">setApplicationVersion</span>(<span class="string">&quot;1.0.0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置应用程序图标</span></span><br><span class="line">    app.<span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/resources/myicon.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个按钮并显示</span></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Click Me&quot;</span>)</span></span>;</span><br><span class="line">    button.<span class="built_in">setFont</span>(<span class="built_in">QFont</span>(<span class="string">&quot;Arial&quot;</span>, <span class="number">18</span>));  <span class="comment">// 设置字体</span></span><br><span class="line">    button.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-继承与扩展"><a href="#7-继承与扩展" class="headerlink" title="7. 继承与扩展"></a>7. 继承与扩展</h3><p>在一些复杂的应用中，可以通过继承 <code>QApplication</code> 来扩展其功能。例如，可以重写 <code>notify()</code> 函数来捕获所有事件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplication</span> : <span class="keyword">public</span> QApplication &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyApplication</span>(<span class="type">int</span> &amp;argc, <span class="type">char</span> **argv) : <span class="built_in">QApplication</span>(argc, argv) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">notify</span><span class="params">(QObject *receiver, QEvent *event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在此进行自定义事件处理</span></span><br><span class="line">        <span class="keyword">return</span> QApplication::<span class="built_in">notify</span>(receiver, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p><code>QApplication</code> 是 Qt GUI 应用程序的基础，它负责管理事件循环、全局设置、样式、系统剪贴板等。理解并熟练使用 <code>QApplication</code> 是开发 Qt GUI 应用程序的重要步骤。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-04-QByteArray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-04-QByteArray/" class="post-title-link" itemprop="url">QByteArray</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Qt-QByteArray-类-详解"><a href="#Qt-QByteArray-类-详解" class="headerlink" title="Qt QByteArray 类 详解"></a>Qt QByteArray 类 详解</h2><p><code>QByteArray</code> 是 Qt 框架中用于处理字节数据的类。它类似于 C++ 标准库中的 <code>std::string</code>，但专门设计用来处理原始字节数据。<code>QByteArray</code> 提供了许多功能，包括存储和操作字节数据、支持多种编码、以及对比和查找等操作。以下是对 <code>QByteArray</code> 类的详细解解：</p>
<h3 id="1-基本功能"><a href="#1-基本功能" class="headerlink" title="1. 基本功能"></a>1. <strong>基本功能</strong></h3><ul>
<li><p><strong>定义和初始化</strong>：<br><code>QByteArray</code> 可以用多种方式初始化，包括从 C 风格字符串、Qt 字符串（<code>QString</code>）、或者通过构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QByteArray byteArray1; <span class="comment">// 空的字节数组</span></span><br><span class="line"><span class="function">QByteArray <span class="title">byteArray2</span><span class="params">(<span class="string">&quot;Hello, world!&quot;</span>)</span></span>; <span class="comment">// 从 C 风格字符串初始化</span></span><br><span class="line"><span class="function">QByteArray <span class="title">byteArray3</span><span class="params">(QString(<span class="string">&quot;Hello, world!&quot;</span>).toUtf8())</span></span>; <span class="comment">// 从 QString 初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>存储字节数据</strong>：<br><code>QByteArray</code> 用于存储字节数据，可以方便地进行操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">byteArray</span><span class="params">(<span class="string">&quot;Data&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. <strong>基本操作</strong></h3><ul>
<li><p><strong>追加和插入</strong>：<br>可以使用 <code>append()</code> 和 <code>insert()</code> 方法将数据追加到字节数组的末尾或在指定位置插入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byteArray.<span class="built_in">append</span>(<span class="string">&quot; more data&quot;</span>);</span><br><span class="line">byteArray.<span class="built_in">insert</span>(<span class="number">4</span>, <span class="string">&quot; insert&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>移除和替换</strong>：<br><code>remove()</code> 方法用于删除字节数据，而 <code>replace()</code> 用于替换指定范围的字节数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byteArray.<span class="built_in">remove</span>(<span class="number">4</span>, <span class="number">6</span>); <span class="comment">// 从位置4开始，删除6个字节</span></span><br><span class="line">byteArray.<span class="built_in">replace</span>(<span class="string">&quot;insert&quot;</span>, <span class="string">&quot;replace&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>清空和检查</strong>：<br><code>clear()</code> 方法可以清空字节数组，<code>isEmpty()</code> 方法用于检查字节数组是否为空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byteArray.<span class="built_in">clear</span>();</span><br><span class="line"><span class="type">bool</span> isEmpty = byteArray.<span class="built_in">isEmpty</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-编码和解码"><a href="#3-编码和解码" class="headerlink" title="3. 编码和解码"></a>3. <strong>编码和解码</strong></h3><ul>
<li><p><strong>与 QString 互转</strong>：<br><code>QByteArray</code> 可以方便地与 <code>QString</code> 转换，使用 <code>toStdString()</code> 可以转换为 <code>std::string</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">QByteArray byteArray = str.<span class="built_in">toUtf8</span>();</span><br><span class="line">QString backToStr = QString::<span class="built_in">fromUtf8</span>(byteArray);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编码和解码</strong>：<br><code>QByteArray</code> 支持多种编码格式，如 UTF-8、Latin1 等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QByteArray utf8Array = <span class="string">&quot;UTF-8 data&quot;</span>;</span><br><span class="line">QByteArray latin1Array = utf8Array.<span class="built_in">toLatin1</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-查找和比较"><a href="#4-查找和比较" class="headerlink" title="4. 查找和比较"></a>4. <strong>查找和比较</strong></h3><ul>
<li><p><strong>查找子串</strong>：<br>使用 <code>indexOf()</code> 方法查找子字节串的位置，<code>contains()</code> 方法检查是否包含某个子字节串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pos = byteArray.<span class="built_in">indexOf</span>(<span class="string">&quot;data&quot;</span>);</span><br><span class="line"><span class="type">bool</span> contains = byteArray.<span class="built_in">contains</span>(<span class="string">&quot;data&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>比较字节数组</strong>：<br>使用 <code>compare()</code> 方法比较两个字节数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">byteArray1</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray <span class="title">byteArray2</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> result = QByteArray::<span class="built_in">compare</span>(byteArray1, byteArray2); <span class="comment">// 0 表示相等</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-转换和操作"><a href="#5-转换和操作" class="headerlink" title="5. 转换和操作"></a>5. <strong>转换和操作</strong></h3><ul>
<li><p>**转换为 <code>std::string</code>**：<br>可以通过 <code>toStdString()</code> 方法将 <code>QByteArray</code> 转换为标准 C++ 字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string stdString = byteArray.<span class="built_in">toStdString</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>操作字节数据</strong>：<br><code>QByteArray</code> 提供了类似于 C++ 数组的操作，例如直接访问字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> firstByte = byteArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-文件操作"><a href="#6-文件操作" class="headerlink" title="6. 文件操作"></a>6. <strong>文件操作</strong></h3><ul>
<li><p><strong>读写文件</strong>：<br><code>QByteArray</code> 可用于处理文件内容，可以与 <code>QFile</code> 类一起使用来读取和写入字节数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;example.dat&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (file.<span class="built_in">open</span>(QIODevice::ReadWrite)) &#123;</span><br><span class="line">    QByteArray data = file.<span class="built_in">readAll</span>();</span><br><span class="line">    file.<span class="built_in">write</span>(<span class="string">&quot;New data&quot;</span>);</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QByteArray <span class="title">byteArray</span><span class="params">(<span class="string">&quot;Hello, world!&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Append data</span></span><br><span class="line">    byteArray.<span class="built_in">append</span>(<span class="string">&quot; Welcome to Qt.&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Replace part of the string</span></span><br><span class="line">    byteArray.<span class="built_in">replace</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Qt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Convert to QString</span></span><br><span class="line">    QString str = QString::<span class="built_in">fromUtf8</span>(byteArray);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Print the result</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; str;  <span class="comment">// Output: Hello, Qt! Welcome to Qt.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>QByteArray</code> 是处理字节数据时非常有用的类，特别是在涉及到编码转换、数据传输和文件操作时。它提供了灵活且高效的字节数据处理功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-06-QTimer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-06-QTimer/" class="post-title-link" itemprop="url">QTimer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Qt-QTimer-类-详解"><a href="#Qt-QTimer-类-详解" class="headerlink" title="Qt QTimer 类 详解"></a>Qt QTimer 类 详解</h2><p><code>QTimer</code> 是 Qt 框架中的一个用于定时和计时的类。它提供了一种非常方便的方式来设置定时器，并在定时器超时时执行指定的操作。<code>QTimer</code> 在 Qt 的事件驱动模型中非常重要，尤其适合在需要周期性或延迟执行操作的场景中使用，例如动画、定时任务、用户界面刷新等。</p>
<h3 id="1-QTimer-的基本功能"><a href="#1-QTimer-的基本功能" class="headerlink" title="1. QTimer 的基本功能"></a>1. <strong><code>QTimer</code> 的基本功能</strong></h3><ul>
<li><p><strong>定时器类型</strong>：</p>
<ul>
<li><strong>单次定时器</strong>：定时器触发一次后就自动停止。</li>
<li><strong>循环定时器</strong>：定时器以固定的时间间隔循环触发，直到手动停止。</li>
</ul>
</li>
<li><p><strong>信号与槽机制</strong>：<br><code>QTimer</code> 依赖于信号和槽机制，定时器超时时会发出 <code>timeout()</code> 信号，应用程序可以连接到这个信号并执行特定的槽函数。</p>
</li>
</ul>
<h3 id="2-QTimer-的常用方法"><a href="#2-QTimer-的常用方法" class="headerlink" title="2. QTimer 的常用方法"></a>2. <strong><code>QTimer</code> 的常用方法</strong></h3><ul>
<li>**<code>start(int msec)</code>**：启动定时器，参数 <code>msec</code> 是以毫秒为单位的间隔时间。</li>
<li>**<code>stop()</code>**：停止定时器。如果定时器正在运行，它会被停止，且不会再触发。</li>
<li>**<code>setInterval(int msec)</code>**：设置定时器的间隔时间（单位：毫秒）。</li>
<li>**<code>setSingleShot(bool singleShot)</code>**：设置定时器是否为单次触发。如果设置为 <code>true</code>，定时器在超时后会自动停止。</li>
<li>**<code>isActive()</code>**：检查定时器是否正在运行。</li>
<li>**<code>remainingTime()</code>**：返回定时器剩余的时间（单位：毫秒）。如果定时器已超时或停止，则返回 -1。</li>
</ul>
<h3 id="3-QTimer-的使用方式"><a href="#3-QTimer-的使用方式" class="headerlink" title="3. QTimer 的使用方式"></a>3. <strong><code>QTimer</code> 的使用方式</strong></h3><p><code>QTimer</code> 可以有两种常见的使用方式：</p>
<ol>
<li><strong>直接使用 <code>QTimer</code> 静态方法</strong>。</li>
<li><strong>创建 <code>QTimer</code> 对象，并将其与槽函数连接</strong>。</li>
</ol>
<h4 id="3-1-直接使用静态方法"><a href="#3-1-直接使用静态方法" class="headerlink" title="3.1 直接使用静态方法"></a>3.1 直接使用静态方法</h4><ul>
<li><p>**<code>QTimer::singleShot(int msec, const QObject *receiver, const char *member)</code>**：<br>这是一个静态方法，适合用于只需要延迟执行一次的操作。它会在指定时间后发出信号并调用连接的槽函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>, <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">doSomething</span>())); <span class="comment">// 2秒后调用槽函数 doSomething()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-2-创建-QTimer-对象"><a href="#3-2-创建-QTimer-对象" class="headerlink" title="3.2 创建 QTimer 对象"></a>3.2 创建 <code>QTimer</code> 对象</h4><p>你可以创建一个 <code>QTimer</code> 对象并手动控制它的启动、停止和触发。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyObject</span>() &#123;</span><br><span class="line">        <span class="comment">// 创建定时器</span></span><br><span class="line">        timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 连接定时器的超时信号到槽函数</span></span><br><span class="line">        <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;MyObject::onTimeout);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置定时器为循环模式，每隔1秒触发一次</span></span><br><span class="line">        timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>); <span class="comment">// 1000毫秒 = 1秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Timer triggered!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QTimer *timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-单次定时器与循环定时器"><a href="#4-单次定时器与循环定时器" class="headerlink" title="4. 单次定时器与循环定时器"></a>4. <strong>单次定时器与循环定时器</strong></h3><ul>
<li><p><strong>单次定时器</strong>：在 <code>QTimer</code> 中可以通过设置 <code>setSingleShot(true)</code> 或使用 <code>QTimer::singleShot()</code> 来实现单次定时器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">timer-&gt;<span class="built_in">setSingleShot</span>(<span class="literal">true</span>);  <span class="comment">// 设置为单次定时器</span></span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">2000</span>);  <span class="comment">// 2秒后触发</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>循环定时器</strong>：默认情况下，<code>QTimer</code> 是循环定时器，即每隔指定的时间间隔触发一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);  <span class="comment">// 每隔1秒触发</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-定时器的精度"><a href="#5-定时器的精度" class="headerlink" title="5. 定时器的精度"></a>5. <strong>定时器的精度</strong></h3><ul>
<li><code>QTimer</code> 是基于 Qt 事件循环的，因此它的精度受限于系统的事件调度机制。在处理复杂的 UI 或繁重任务时，定时器的精度可能受到影响。通常情况下，<code>QTimer</code> 可以提供毫秒级的精度，但并不适用于需要严格实时性的场景。</li>
</ul>
<h3 id="6-定时器的线程安全性"><a href="#6-定时器的线程安全性" class="headerlink" title="6. 定时器的线程安全性"></a>6. <strong>定时器的线程安全性</strong></h3><ul>
<li><code>QTimer</code> 必须在其所属的线程中使用。如果你在多线程环境中使用定时器，确保定时器与其所在的线程一致。可以使用 <code>QTimer</code> 和 <code>QThread</code> 的组合来在子线程中处理定时任务。</li>
</ul>
<h3 id="7-常见用例"><a href="#7-常见用例" class="headerlink" title="7. 常见用例"></a>7. <strong>常见用例</strong></h3><ul>
<li><strong>动画刷新</strong>：通过定时器定期更新 UI 元素的状态。</li>
<li><strong>定时任务</strong>：在应用程序中定时执行某些任务，例如自动保存、定时更新数据等。</li>
<li><strong>延迟操作</strong>：在特定时间后执行某一操作，如提示信息延迟消失。</li>
</ul>
<h3 id="8-QTimer-示例"><a href="#8-QTimer-示例" class="headerlink" title="8. QTimer 示例"></a>8. <strong>QTimer 示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QMainWindow mainWindow;</span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello, Qt!&quot;</span>, &amp;mainWindow);</span><br><span class="line">    mainWindow.<span class="built_in">setCentralWidget</span>(label);</span><br><span class="line"></span><br><span class="line">    QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(&amp;mainWindow);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [&amp;]() &#123;</span><br><span class="line">        label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Timer triggered!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">2000</span>); <span class="comment">// 2秒后触发</span></span><br><span class="line"></span><br><span class="line">    mainWindow.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>QTimer</code> 是一个强大且灵活的定时工具，在 Qt 开发中广泛用于管理定时任务。它与 Qt 的信号和槽机制紧密集成，使得处理异步操作和事件驱动编程变得更加容易。无论是周期性操作还是一次性延迟操作，<code>QTimer</code> 都能够提供理想的解决方案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-05-QMutex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-05-QMutex/" class="post-title-link" itemprop="url">QMutex</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Qt-QMutex-类-详解"><a href="#Qt-QMutex-类-详解" class="headerlink" title="Qt QMutex 类 详解"></a>Qt QMutex 类 详解</h2><p><code>QMutex</code> 是 Qt 框架中的一个类，用于实现线程同步。它提供了一种机制来控制对共享资源的访问，以避免多个线程同时访问同一资源而导致的竞态条件。<code>QMutex</code> 类是 Qt 的核心线程库的一部分，用于确保在多线程环境中的数据一致性和避免数据冲突。以下是对 <code>QMutex</code> 类的详细解释：</p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><ul>
<li><p><strong>定义</strong>：<br><code>QMutex</code> 是一个互斥锁，用于在多线程程序中保护共享数据。它确保在任何时刻只有一个线程可以访问被保护的资源。</p>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>保护共享数据结构（如变量、对象）不被多个线程同时修改。</li>
<li>在并发环境中避免数据不一致性和竞态条件。</li>
</ul>
</li>
</ul>
<h3 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. <strong>基本操作</strong></h3><ul>
<li><p><strong>构造和析构</strong>：<br><code>QMutex</code> 的构造函数创建一个互斥锁实例，析构函数释放该互斥锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMutex mutex; <span class="comment">// 默认构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>加锁和解锁</strong>：</p>
<ul>
<li><strong>加锁</strong>：<code>lock()</code> 方法用于加锁，如果互斥锁已被其他线程占用，则调用线程将会被阻塞，直到互斥锁变为可用。</li>
<li><strong>解锁</strong>：<code>unlock()</code> 方法用于释放互斥锁，使其他线程可以访问受保护的资源。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex.<span class="built_in">lock</span>(); <span class="comment">// 加锁</span></span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line">mutex.<span class="built_in">unlock</span>(); <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自动锁</strong>：<br>使用 <code>QMutexLocker</code> 类可以自动管理互斥锁的加锁和解锁，避免因异常或遗漏导致的死锁问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line"><span class="comment">// locker 的析构函数会自动解锁</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-互斥锁的类型"><a href="#3-互斥锁的类型" class="headerlink" title="3. 互斥锁的类型"></a>3. <strong>互斥锁的类型</strong></h3><ul>
<li><p><strong>递归互斥锁</strong>：<br><code>QMutex</code> 可以是递归的，允许同一个线程多次锁定同一个互斥锁而不会导致死锁。使用 <code>QMutex::Recursive</code> 类型构造递归互斥锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMutex <span class="title">recursiveMutex</span><span class="params">(QMutex::Recursive)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>非递归互斥锁</strong>：<br>默认构造的 <code>QMutex</code> 是非递归的，要求在一个线程中加锁后，必须在同一线程中解锁，否则会导致死锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMutex nonRecursiveMutex; <span class="comment">// 默认为非递归</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4. 静态方法"></a>4. <strong>静态方法</strong></h3><ul>
<li><p>**<code>QMutex::tryLock()</code>**：<br>尝试加锁而不阻塞，如果互斥锁已被其他线程占用，它会立即返回 <code>false</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mutex.<span class="built_in">tryLock</span>()) &#123;</span><br><span class="line">    <span class="comment">// 成功加锁</span></span><br><span class="line">    mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 未能加锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>QMutex::lock()</code> 和 <code>QMutex::unlock()</code>**：<br>这些方法分别用于加锁和解锁，不同于 <code>tryLock()</code>，它们会阻塞直到成功加锁。</p>
</li>
</ul>
<h3 id="5-性能考虑"><a href="#5-性能考虑" class="headerlink" title="5. 性能考虑"></a>5. <strong>性能考虑</strong></h3><ul>
<li><p><strong>锁的开销</strong>：<br>使用互斥锁会有一定的性能开销，尤其是在高频率锁定和解锁的情况下。合理设计锁的粒度和使用自动锁可以减少这种开销。</p>
</li>
<li><p><strong>避免死锁</strong>：<br>使用 <code>QMutexLocker</code> 可以帮助避免由于忘记解锁或异常导致的死锁问题。</p>
</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMutexLocker&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">QMutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;mutex)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Thread is running&quot;</span>;</span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    <span class="comment">// locker 的析构函数会自动解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QThread <span class="title">thread1</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="function">QThread <span class="title">thread2</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    </span><br><span class="line">    thread<span class="number">1.</span><span class="built_in">start</span>();</span><br><span class="line">    thread<span class="number">2.</span><span class="built_in">start</span>();</span><br><span class="line">    </span><br><span class="line">    thread<span class="number">1.</span><span class="built_in">wait</span>();</span><br><span class="line">    thread<span class="number">2.</span><span class="built_in">wait</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>QMutex</code> 类在 Qt 的多线程编程中扮演了重要角色，通过提供互斥锁机制来保护共享资源的访问，确保线程安全。合理使用 <code>QMutex</code> 和 <code>QMutexLocker</code> 可以帮助你管理多线程环境中的资源，避免竞态条件和数据不一致性问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-07-QThread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/18/notebook/Qt/%E5%B8%B8%E8%A7%81%E7%B1%BB/2024-11-18-07-QThread/" class="post-title-link" itemprop="url">QThread</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T09:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="QThread-类-详解"><a href="#QThread-类-详解" class="headerlink" title="QThread 类 详解"></a>QThread 类 详解</h2><p><code>QThread</code> 是 Qt 中用于实现多线程的类。它提供了一个平台无关的、面向对象的线程接口，使得在 GUI 应用程序中处理耗时操作时可以保持界面的响应性。在 Qt 中，<code>QThread</code> 是线程管理的基础类，但 Qt 推荐的使用方式与传统的 C++ 线程管理（如 <code>std::thread</code>）有所不同。</p>
<h3 id="1-QThread-的基本概念"><a href="#1-QThread-的基本概念" class="headerlink" title="1. QThread 的基本概念"></a>1. <strong><code>QThread</code> 的基本概念</strong></h3><ul>
<li><p><strong>线程与事件循环</strong>：<code>QThread</code> 继承自 <code>QObject</code>，因此它具有信号和槽机制，并且可以在子线程中运行一个事件循环。事件循环允许子线程接收信号并执行槽函数，这在 GUI 编程中非常有用。</p>
</li>
<li><p><strong>工作者线程模型</strong>：在 Qt 中，推荐的多线程编程方式是将一个对象的工作移到另一个线程中，而不是直接继承 <code>QThread</code>。这种方法更符合 Qt 的对象模型，也更易于管理信号与槽的连接。</p>
</li>
</ul>
<h3 id="2-QThread-的使用方式"><a href="#2-QThread-的使用方式" class="headerlink" title="2. QThread 的使用方式"></a>2. <strong><code>QThread</code> 的使用方式</strong></h3><p><code>QThread</code> 可以通过多种方式使用，主要包括以下两种：</p>
<ol>
<li><strong>直接继承 <code>QThread</code> 类（传统方式）</strong></li>
<li><strong>工作者线程模型（推荐方式）</strong></li>
</ol>
<h4 id="2-1-直接继承-QThread-类"><a href="#2-1-直接继承-QThread-类" class="headerlink" title="2.1 直接继承 QThread 类"></a>2.1 直接继承 <code>QThread</code> 类</h4><p>在这种方式中，你需要继承 <code>QThread</code> 并重写其 <code>run()</code> 方法，<code>run()</code> 方法是线程开始执行的入口点。你可以在这里编写需要在线程中运行的任务。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> : <span class="keyword">public</span> QThread &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Running in thread:&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">            QThread::<span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyThread thread;</span><br><span class="line">    thread.<span class="built_in">start</span>(); <span class="comment">// 开始线程</span></span><br><span class="line">    thread.<span class="built_in">wait</span>();  <span class="comment">// 等待线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：这种方法虽然直观，但不推荐使用，因为它与 Qt 的信号槽机制不太兼容，容易导致线程中的对象生命周期管理问题。</p>
<h4 id="2-2-工作者线程模型（推荐方式）"><a href="#2-2-工作者线程模型（推荐方式）" class="headerlink" title="2.2 工作者线程模型（推荐方式）"></a>2.2 工作者线程模型（推荐方式）</h4><p>工作者线程模型是将一个 <code>QObject</code> 派生类（工作对象）移动到一个新线程中，然后在新线程中执行它的任务。这种方式更安全且与 Qt 的事件系统无缝集成。</p>
<p>步骤如下：</p>
<ol>
<li>创建一个工作对象，继承自 <code>QObject</code>，并定义需要在线程中运行的任务。</li>
<li>创建一个 <code>QThread</code> 对象。</li>
<li>使用 <code>moveToThread()</code> 将工作对象移动到新线程。</li>
<li>通过信号槽机制启动任务。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Working in thread:&quot;</span> &lt;&lt; QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">            QThread::<span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    Worker worker;</span><br><span class="line">    QThread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将工作对象移动到子线程</span></span><br><span class="line">    worker.<span class="built_in">moveToThread</span>(&amp;thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在子线程中启动工作</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;thread, &amp;QThread::started, &amp;worker, &amp;Worker::doWork);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;thread, &amp;QThread::finished, &amp;worker, &amp;QObject::deleteLater);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;thread, &amp;QThread::finished, &amp;thread, &amp;QObject::deleteLater);</span><br><span class="line"></span><br><span class="line">    thread.<span class="built_in">start</span>();  <span class="comment">// 启动线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：这种方式使得工作对象可以与信号槽机制结合得更好，<code>QThread</code> 仅负责线程管理，实际的任务执行由工作对象处理。</p>
<h3 id="3-信号与槽的线程安全性"><a href="#3-信号与槽的线程安全性" class="headerlink" title="3. 信号与槽的线程安全性"></a>3. <strong>信号与槽的线程安全性</strong></h3><ul>
<li><p>在 Qt 中，不同线程中的信号与槽可以跨线程连接。当信号和槽位于不同线程时，Qt 会自动将信号的发送和槽的调用封装为异步事件，通过事件循环来处理。这意味着跨线程的信号槽连接是线程安全的。</p>
</li>
<li><p>线程间的信号槽连接默认是异步的（<code>Qt::QueuedConnection</code>），即信号被发送时不会立即调用槽函数，而是将其加入事件队列，等待事件循环调度。你也可以显式指定连接类型，如 <code>Qt::DirectConnection</code>，来使得信号和槽在同一线程中同步执行。</p>
</li>
</ul>
<h3 id="4-线程中的事件循环"><a href="#4-线程中的事件循环" class="headerlink" title="4. 线程中的事件循环"></a>4. <strong>线程中的事件循环</strong></h3><p><code>QThread</code> 中的事件循环使得线程可以处理信号、定时器等事件。默认情况下，<code>QThread::run()</code> 方法启动的线程没有事件循环，必须手动调用 <code>exec()</code> 以启动事件循环。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> : <span class="keyword">public</span> QThread &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">exec</span>();  <span class="comment">// 启动事件循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-线程生命周期管理"><a href="#5-线程生命周期管理" class="headerlink" title="5. 线程生命周期管理"></a>5. <strong>线程生命周期管理</strong></h3><ul>
<li><strong>启动线程</strong>：使用 <code>start()</code> 启动线程。</li>
<li><strong>停止线程</strong>：调用 <code>quit()</code> 退出事件循环，然后使用 <code>wait()</code> 等待线程结束。</li>
<li><strong>线程结束后自动清理</strong>：可以通过连接 <code>QThread::finished</code> 信号到 <code>QObject::deleteLater</code> 来自动清理线程对象。</li>
</ul>
<h3 id="6-常见问题与注意事项"><a href="#6-常见问题与注意事项" class="headerlink" title="6. 常见问题与注意事项"></a>6. <strong>常见问题与注意事项</strong></h3><ul>
<li><strong>UI 操作必须在主线程</strong>：Qt 的 GUI 元素必须在主线程中操作，如果在子线程中直接访问 GUI 会导致崩溃。</li>
<li><strong>对象的生命周期管理</strong>：在使用 <code>moveToThread()</code> 时，要确保对象在其所属线程中被创建和销毁，以避免线程间的对象访问问题。</li>
<li><strong>避免阻塞主线程</strong>：长时间的计算或 IO 操作应放到子线程中，以保持主线程（UI 线程）的响应性。</li>
</ul>
<h3 id="7-常见用例"><a href="#7-常见用例" class="headerlink" title="7. 常见用例"></a>7. <strong>常见用例</strong></h3><ul>
<li>在后台执行耗时任务，如文件读写、网络请求、数据处理等。</li>
<li>使用定时器在子线程中定期执行任务。</li>
<li>在子线程中处理异步操作并通过信号槽通知主线程结果。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>QThread</code> 是 Qt 中实现多线程编程的重要工具。尽管可以通过继承 <code>QThread</code> 来实现自定义线程，但推荐的方式是使用工作者线程模型，将任务放到一个独立的 <code>QObject</code> 中并移动到线程执行。这种方式更符合 Qt 的设计理念，并且更易于管理复杂的信号槽连接与对象生命周期。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/10/28/notebook/Tools/2024-10-28-CSV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/28/notebook/Tools/2024-10-28-CSV/" class="post-title-link" itemprop="url">CSV</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-28 10:00:00" itemprop="dateCreated datePublished" datetime="2024-10-28T10:00:00+08:00">2024-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CSV文件是什么"><a href="#CSV文件是什么" class="headerlink" title="CSV文件是什么"></a>CSV文件是什么</h2><p>CSV（Comma-Separated Values，逗号分隔值）文件是一种用于存储表格数据的简单文本文件格式。CSV文件每行通常代表表格中的一行，每行的数据字段由逗号分隔。它被广泛用于数据导入导出，因为其结构简单，几乎所有的表格处理软件（如Excel、Google Sheets）和数据库系统都支持CSV格式。</p>
<h3 id="CSV-文件的特点"><a href="#CSV-文件的特点" class="headerlink" title="CSV 文件的特点"></a>CSV 文件的特点</h3><ol>
<li><strong>结构简单</strong>：文件由纯文本组成，行表示记录，逗号分隔每行中的字段。</li>
<li><strong>兼容性好</strong>：可以被几乎所有的电子表格软件和数据库读取和导出。</li>
<li><strong>便于编辑</strong>：可以直接用文本编辑器查看和编辑。</li>
</ol>
<h3 id="CSV-文件格式示例"><a href="#CSV-文件格式示例" class="headerlink" title="CSV 文件格式示例"></a>CSV 文件格式示例</h3><p>假设有一个简单的学生信息表，包含 “姓名” 和 “年龄” 两个字段。CSV 文件内容可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名,年龄</span><br><span class="line">张三,25</span><br><span class="line">李四,30</span><br><span class="line">王五,28</span><br></pre></td></tr></table></figure>

<p>每行表示一条记录，<code>张三</code> 和 <code>25</code> 之间用逗号分隔，表示姓名和年龄。</p>
<h3 id="CSV-的应用场景"><a href="#CSV-的应用场景" class="headerlink" title="CSV 的应用场景"></a>CSV 的应用场景</h3><ul>
<li><strong>数据导入和导出</strong>：CSV 常用于在不同软件之间传递数据，例如在数据库和表格软件之间导出或导入数据。</li>
<li><strong>简单的数据存储</strong>：CSV 文件常用于保存简单的结构化数据。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>分隔符</strong>：虽然默认使用逗号，但在某些区域（如欧洲）可能会使用分号作为分隔符。</li>
<li><strong>转义字符</strong>：如果字段内容包含逗号，需用双引号包裹该字段。例如：<code>&quot;张三, 李四&quot;,25</code>。</li>
<li><strong>不支持复杂格式</strong>：CSV 文件不支持单元格格式、颜色、图表等，只能存储纯文本数据。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/10/18/notebook/Diary/2024-10-18-%E7%BD%91%E7%BB%9C%E6%97%A5%E8%AE%B0003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/18/notebook/Diary/2024-10-18-%E7%BD%91%E7%BB%9C%E6%97%A5%E8%AE%B0003/" class="post-title-link" itemprop="url">网络日记003</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-10-18T09:00:00+08:00">2024-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Diary/" itemprop="url" rel="index"><span itemprop="name">Diary</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul>
<li>一定学会Qt的基本使用，能够设计和开发常用的人机交互界面。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/10/17/notebook/Books/2024-10-17-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-%E7%AC%AC1-3%E9%83%A8%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/notebook/Books/2024-10-17-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-%E7%AC%AC1-3%E9%83%A8%E5%88%86/" class="post-title-link" itemprop="url">C++程序设计语言 第1-3部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-17 09:00:00" itemprop="dateCreated datePublished" datetime="2024-10-17T09:00:00+08:00">2024-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-致读者"><a href="#第一章-致读者" class="headerlink" title="第一章 致读者"></a>第一章 致读者</h1><h2 id="1-1-本书结构"><a href="#1-1-本书结构" class="headerlink" title="1.1 本书结构"></a>1.1 本书结构</h2><ul>
<li>纯粹的入门教材通常会这样组织其内容–所有概念都先回介绍再应用，因此必须从第一页开始顺序阅读。与之相反，纯粹的参考手册则可以从任何地方开始查阅，因为每个主题的描述都简明扼要，辅以指向相关主题的引用。</li>
<li>本书包含以下四个部分<ul>
<li>第一部分：第一章是本书的导引，会介绍一点C++的背景知识。第2-5章对C++语言及其标准库进行简要介绍</li>
<li>第二部分：第6-15章介绍C++的内置类型和基本特性以及如何用他们构造程序</li>
<li>第三部分：第16-29章介绍C++的抽象机制及如何用这些机制编写面向对象和泛型编程</li>
<li>第四部分：第30-44章概述标准库并讨论一些兼容性问题。</li>
</ul>
</li>
</ul>
<h3 id="1-1-1-引言"><a href="#1-1-1-引言" class="headerlink" title="1.1.1 引言"></a>1.1.1 引言</h3><ul>
<li>接下来几章将要简要介绍C++程序设计语言及其标准库的主要概念和特性<ul>
<li>第二章：基础知识。介绍C++的内存模型，计算模型和错误处理模型</li>
<li>第三章：抽象机制。介绍用来支持数据抽象，面向对象编程以及泛型编程的语言特性</li>
<li>第四章：容器与算法。介绍标准库提供的字符串，简单I&#x2F;O，容器和算法等特性</li>
<li>第五章：并发和实用功能。概述与资源管理，并发，数字计算，正则表达式及其他一些方面相关的标准库工具</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-基本特性"><a href="#1-1-2-基本特性" class="headerlink" title="1.1.2 基本特性"></a>1.1.2 基本特性</h3><ul>
<li>C++支持传统的C语言编程风格，第二部分重点介绍支持C编程风格的C++子集，包括类型，对象，作用域和存储的基本概念。<ul>
<li>第六章：类型与声明。基础类型，命令，作用域，初始化，简单类型推断，对象生命周期和类型别名</li>
<li>第七章：指针，数组与引用</li>
<li>第八章：结构，联合与枚举</li>
<li>第九章：语句。声明语句，选择语句，迭代语句，goto语句和注释语句</li>
<li>第十一章：选择适当的操作。逻辑运算符，条件表达式，递增和递减，自由空间，{}列表，lambda表达式和显式类型转换</li>
<li>第十二章：函数。函数声明和定义，inline函数，constexpr函数，实参传递，重载函数，前置和后置条件，函数的指针和宏</li>
<li>第十三章：异常处理。错误处理风格，异常保证，资源管理，强制不变量，throw和catch，一个vector的实现</li>
<li>第十四章：名字空间。namespace，模块化和接口，使用名字空间组织代码。</li>
<li>第十五章：源文件与程序。分离编译，链接，使用头文件及程序启动和结束</li>
</ul>
</li>
</ul>
<h3 id="1-1-3-抽象机制"><a href="#1-1-3-抽象机制" class="headerlink" title="1.1.3 抽象机制"></a>1.1.3 抽象机制</h3><ul>
<li>第三部分介绍的C++特性用来支持不同形式的抽象，包括面向对象编程和泛型编程。所有章节可以粗略分为三组：类，类继承和模板<ul>
<li>第十六章：类。用户自定义类型，也就是类的概念，是所有C++抽象机制的基础</li>
<li>第十七章：构造，清理，拷贝和移动。展示了程序员如何定义类对象创建和初始化操作的含义。此外，拷贝，移动和析构的含义同样可由程序员来定义</li>
<li>第十八章：运算符重载。介绍了为用户自定义类型指定运算符含义的规则，重点介绍常用的算术和逻辑运算符</li>
<li>第十九章：特殊运算符。讨论用户自定义的非算术运算符的使用</li>
<li>第二十章：派生类。介绍构建类层次的基本语言特性及其基本使用方法。我们可以实现接口(抽象类)与其实现(派生类)的完全分离，两者间的联系通过虚函数提供</li>
<li>第二十一章：类层次。讨论有效的使用类层次的方法。</li>
<li>第二十二章：运行时类型信息。介绍如何使用存储在对象中的数据实现在类层次中导航。我们可以使用dynamic_cast查询一个基类对象是否是作为派生类对象定义的</li>
<li>第二十三章：模板。介绍隐藏在模板及其使用方法之下的基本原理</li>
<li>第二十四章：泛型程序设计。介绍设计泛型程序所需的基本技术</li>
<li>第二十五章：特例化。介绍特例化技术，即如何利用给定的一组模板参数，从模板生成类和函数</li>
<li>第二十六章：实例化。主要介绍名字绑定规则</li>
<li>第二十七章：模板和类层次。介绍模板层次和类层次如何结合使用</li>
<li>第二十八章：元编程。介绍如何用模板生成程序</li>
<li>第二十九章：一个矩阵设计。</li>
</ul>
</li>
</ul>
<h3 id="1-1-4-标准库"><a href="#1-1-4-标准库" class="headerlink" title="1.1.4 标准库"></a>1.1.4 标准库</h3><ul>
<li>实际上这一部分可以当作标准库组件的用户手册来使用<ul>
<li>第三十章：标准库概览。给出标准库的概览，列出标准库头文件，并介绍语言支持和程序诊断方面的支持</li>
<li>第三十一章：STL容器。介绍迭代器，容器和算法框架中的容器</li>
<li>第三十二章：STL算法。介绍STL中的算法</li>
<li>第三十三章：STL迭代器。介绍STL中的迭代器和其他工具</li>
<li>第三十四章：内存和资源。介绍内存和资源管理相关的工具组件</li>
<li>第三十五章：工具。介绍一些重要性稍低的工具组件</li>
<li>第三十六章：字符串。介绍标准库string</li>
<li>第三十七章：正则表达式</li>
<li>第三十八章：I&#x2F;O流。介绍标准库I&#x2F;O流，包括格式化和非格式化输入输出，错误处理以及缓冲</li>
<li>第三十九章：区域设置。</li>
<li>第四十章：数值计算。</li>
<li>第四十一章：并发。介绍C++基本内存模型和C++所提供的支持无锁并发编程的工具</li>
<li>第四十二章：线程和任务。介绍支持线程和锁风格并发编程的类和支持基于任务并发编程模式的类</li>
<li>第四十三章：C标准库。介绍纳入C++标准库的C标准库特性</li>
<li>第四十四章：兼容性。</li>
</ul>
</li>
</ul>
<h2 id="1-2-C-的设计"><a href="#1-2-C-的设计" class="headerlink" title="1.2 C++的设计"></a>1.2 C++的设计</h2><ul>
<li><p>程序设计语言的目的就是帮助我们用代码来表达思想。因此，一种程序设计语言要完成两个相关的任务：为程序员提供一个工具，用来指明需要由计算机执行什么动作；为程序员提供一组概念，用于思考能做些什么。</p>
</li>
<li><p>C++的设计理念是同时提供：</p>
<ul>
<li>将内置操作和内置类型直接映射到硬件，从而提供高效的内存利用和高效的底层操作。</li>
<li>灵活且低开小的抽象机制，使得用户自定义类型无论是符号表达，使用范围还是性能都能与内置类型相当。</li>
</ul>
</li>
<li><p>系统程序设计(system programming)的含义是编写直接使用硬件资源的，严重受限于资源的代码，或是编写的代码与这类代码联系紧密。特别是软件基础设施的实现(例如设备驱动程序，通信协议栈，虚拟机，操作系统，业务支持系统，编程环境以及基础库)大部分都属于系统程序设计。</p>
</li>
</ul>
<h3 id="1-2-1-程序设计风格"><a href="#1-2-1-程序设计风格" class="headerlink" title="1.2.1 程序设计风格"></a>1.2.1 程序设计风格</h3><ul>
<li><p>我们可以简单描述软件设计和编程的基本理念：</p>
<ul>
<li>用代码直接表达想法</li>
<li>无关的想法应独立表达</li>
<li>用代码直接描述想法之间的关联</li>
<li>可以自用的组合用代码表达想法，但仅在这种组合有意义时</li>
<li>简单的想法应简单表达</li>
</ul>
</li>
<li><p>C++语言特性直接支持四种程序设计风格</p>
<ul>
<li>过程式程序设计</li>
<li>数据抽象</li>
<li>面向对象程序设计</li>
<li>泛型程序设计</li>
</ul>
</li>
<li><p>但是，<strong>重点不在于对单个程序设计风格的支持，而在于有效的组合它们。</strong></p>
</li>
<li><p>我理想中的语言特性应该能优雅的组合使用，来支持连续统一的程序设计风格和各种各样的程序设计技术</p>
<ul>
<li>过程式程序设计：这种风格专注于处理和设计恰当的数据结构。支持这种风格也是C语言的设计目标。C++对这种风格的支持体现为内置类型，运算符，语句，函数，struct和union等特性。</li>
<li>数据抽象：这种风格专注于接口的设计以及一般实现细节的隐藏和特殊的表示方式。C++支持具体类和抽象类。一些语言特性可直接用来定义具有私有实现细节，构造函数和析构函数以及相关操作的类。而抽象类则为完全的数据隐藏提供了直接支持。</li>
<li>面向对象程序设计：这种风格专注于类层次的设计，实现和使用。除了允许定义类框架之外，C++还提供了各种各样的特性来支持类框架中的导航以及简化由已有的类来定义新的类。类层次提供了运行时多态和封装机制。</li>
<li>泛型程序设计：这种风格专注于通用算法的设计，实现和使用。在这里，通用的含义是，一个算法可以设计成能处理多种类型，只要这些类型满足算法对其实参的要求即可。C++支持泛型编程的主要特性是模板，模板提供了运行时参数多态。</li>
</ul>
</li>
<li><p>上述这些设计和编程风格的强大在于它们的综合，每种风格都对综合启动了重要作用，而这种综合实际上就是C++。因此，<strong>只关注一种风格是错误的，除非你只编写一些玩具程序，否则只关注一种风格会导致开发工作的浪费，产生非最优的程序</strong></p>
</li>
</ul>
<h3 id="1-2-2-类型检查"><a href="#1-2-2-类型检查" class="headerlink" title="1.2.2 类型检查"></a>1.2.2 类型检查</h3><ul>
<li>静态类型和编译时类型检查的概念对高效使用C++是极为重要的。静态类型的使用是可表达性，可维护性和新能的关键。</li>
</ul>
<h3 id="1-2-3-C兼容性"><a href="#1-2-3-C兼容性" class="headerlink" title="1.2.3 C兼容性"></a>1.2.3 C兼容性</h3><ul>
<li>C++从C语言发展而来，它保留了C的特性作为子集。</li>
</ul>
<h3 id="1-2-4-语言，库和系统"><a href="#1-2-4-语言，库和系统" class="headerlink" title="1.2.4 语言，库和系统"></a>1.2.4 语言，库和系统</h3><ul>
<li>C++的基本内置类型，运算符和语句都是计算机硬件能直接处理的：数字，字符和地址。C++没有内置的高级数据类型，也没有高级操作原语。</li>
</ul>
<h2 id="1-3-学习C"><a href="#1-3-学习C" class="headerlink" title="1.3 学习C++"></a>1.3 学习C++</h2><ul>
<li>语言特性的存在是为了支持各种程序设计风格和技术。因此，语言的学习应该更关注掌握其固有的，内在的风格，而不是试图了解每个语言特性的所有细节。</li>
<li>请记住学习C++细节知识的真正目的是：在良好设计所提供的语境中，有能力组合使用语言特性和库特性来支持好的程序设计风格。</li>
<li>学习C++最重要的是重视基本概念(例如类型安全，资源管理和不变式)和程序设计技术(例如使用限定作用域的对象进行资源管理以及在算法中使用迭代器)，还要注意不要迷失在语言技术性细节中。</li>
<li>学习一门程序设计语言的目的是成为一个更好的程序员，即，能更高效的设计和实现新系统，维护旧系统。为此，领悟编程和设计技术比了解所有细节重要得多。</li>
</ul>
<h3 id="1-3-1-用C-编程"><a href="#1-3-1-用C-编程" class="headerlink" title="1.3.1 用C++编程"></a>1.3.1 用C++编程</h3><ul>
<li>C++程序设计的主要理念与大多数高级语言编程一样：用代码直接表达从设计而来的概念。</li>
</ul>
<h2 id="1-4-C-的历史"><a href="#1-4-C-的历史" class="headerlink" title="1.4 C++的历史"></a>1.4 C++的历史</h2><h3 id="1-4-5-C-的用途"><a href="#1-4-5-C-的用途" class="headerlink" title="1.4.5 C++的用途"></a>1.4.5 C++的用途</h3><ul>
<li>C++有大量的支持库和工具集，例如<ul>
<li>Boost 可移植基础库</li>
<li>POCO 网站开发库</li>
<li>QT 跨平台应用开发库</li>
<li>wxWidgets 跨平台图形用户界面库</li>
<li>WebKit 网页浏览器布局引擎库</li>
<li>CGAL 计算几何库</li>
<li>QuickFix 金融信息交换库</li>
<li>OpenCV 实时图像处理库</li>
<li>Root 高能物理库</li>
</ul>
</li>
</ul>
<h2 id="1-5-建议"><a href="#1-5-建议" class="headerlink" title="1.5 建议"></a>1.5 建议</h2><ul>
<li>每一章都有建议，给出该章节内容相关的一些具体建议。这些建议都是一些经验法则，而非不变的定律。</li>
<li>对于初学者，下面列出了一些来自C++的设计，学习和历史这几节的建议<ul>
<li>用代码直接表达想法(概念)，例如，表达为一个函数，一个类或是一个枚举</li>
<li>编写代码应以优雅且高效为目标</li>
<li>不要过度抽象</li>
<li>设计应关注提供优雅且高效的抽象，可能的情况下以库的形式呈现</li>
<li>用代码直接表达想法之间的关联，例如，通过参数化或类层次</li>
<li>无关的想法应用独立的代码表达，例如，壁面类之间的相互依赖</li>
<li>令资源是显式的(将它们表示为类对象)</li>
<li>简单的想法应该简单表达</li>
<li>使用库，特别是标准库，不要试图从头开始构建所有东西</li>
<li>使用类型丰富的程序设计风格</li>
<li>如果数据具有不变量，封装它</li>
</ul>
</li>
<li>总之：<strong>编写好程序需要智慧，风格和耐心。你不可能第一次就成功，要不断尝试。</strong></li>
</ul>
<h1 id="第二章-C-概览：基础知识"><a href="#第二章-C-概览：基础知识" class="headerlink" title="第二章 C++概览：基础知识"></a>第二章 C++概览：基础知识</h1><h2 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1 引言"></a>2.1 引言</h2><h2 id="2-2-基础概念"><a href="#2-2-基础概念" class="headerlink" title="2.2 基础概念"></a>2.2 基础概念</h2><ul>
<li>C++是一种编译型语言。顾名思义，想要运行一段C++程序，需要首先用编译器把源代码转换为对象文件，然后再用链接器把这些对象组合生成可执行程序。一个C++程序通常包含许多源代码文件，通常称为源文件。</li>
<li>一个可执行程序适用于一种特定的硬件&#x2F;系统组合，是不可移植的。当我们谈论C++程序的可移植性时，通常是指源代码的可移植性。也就是说，同一份源代码可以在不同系统上成功编译并运行。</li>
<li>ISO的C++标准定义了两种实体<ul>
<li>核心语言功能，例如内置类型和循环</li>
<li>标准库组件，例如容器和I&#x2F;O操作</li>
</ul>
</li>
<li>C++是一种静态类型语言，这意味着编译器在处理任何实体(例如对象，值，名称和表达式)时，都必须清楚它的类型。对象的类型决定了能在该对象上执行哪些操作。</li>
</ul>
<h3 id="2-2-1-Hello-world"><a href="#2-2-1-Hello-world" class="headerlink" title="2.2.1 Hello world"></a>2.2.1 Hello world</h3><ul>
<li>在每个C++程序中有且只有一个名为main()的全局函数，在执行一个程序时首先执行该函数。如果main()返回一个int值，则这个值将作为程序给系统的返回值。如果main()没有返回任何值，则系统也将收到一个表示程序完成的值。这个值：基于Linux&#x2F;Unix的环境通常会用到，而基于windows的环境一般不会用到</li>
<li>基本上所有可执行代码都要放在函数中，并且被main()直接或间接的调用</li>
</ul>
<h3 id="2-2-2-类型，变量和算术运算"><a href="#2-2-2-类型，变量和算术运算" class="headerlink" title="2.2.2 类型，变量和算术运算"></a>2.2.2 类型，变量和算术运算</h3><ul>
<li><p>每个名字和每个表达式都有一个类型，类型决定所能执行的操作。</p>
</li>
<li><p>声明(declaration)是一条语句，负责为程序引入一个新的名字，并指定该命名实体的类型</p>
<ul>
<li>类型(type) 定义一组可能的值以及一组(对象上的)操作</li>
<li>对象(object) 是存放某类型值的内存空间</li>
<li>值(value) 是一组二进制位，具体的含义由类型决定</li>
<li>变量(variable) 是一个命名的对象</li>
</ul>
</li>
<li><p>C++提供了好几种表示初始化的符号</p>
<ul>
<li>符号 &#x3D; 是一种比较传统的形式，最早被C语言使用</li>
<li>花括号内的一组初始化器列表。最好在C++中使用更通用的{}列表形式。抛开其他因素不谈，使用初始化器列表的形式至少可以确保不会发生某些可能导致信息丢失的类型转换。</li>
</ul>
</li>
<li><p>我们可以使用 &#x3D; 的初始化形式与auto配合，因为在此过程中不存在可能引发错误的类型转换。</p>
</li>
<li><p>当我们没有明显的理由需要显式指定数据类型时，一般使用auto。在这里，明显的理由包括</p>
<ul>
<li>该定义位于一个较大的作用域中，我们希望代码的读者清楚的直到其类型</li>
<li>我们希望明确规定某个变量的范围和精度(例如希望使用double而非float)</li>
</ul>
</li>
</ul>
<h3 id="2-2-3-常量"><a href="#2-2-3-常量" class="headerlink" title="2.2.3 常量"></a>2.2.3 常量</h3><ul>
<li>C++支持如下两种不变性概念<ul>
<li>const：大致意思是，我承诺不改变这个值。主要用于说明接口，这样在把变量传入函数时就不必担心变量会在函数内被改变了。编译器负责确认并执行const的承诺</li>
<li>constexpr：大致意思是，在编译时求值。主要用于说明常量，作用是允许将数据内置于只读内存中以及提升性能。</li>
</ul>
</li>
</ul>
<h2 id="2-3-用户自定义类型"><a href="#2-3-用户自定义类型" class="headerlink" title="2.3 用户自定义类型"></a>2.3 用户自定义类型</h2><ul>
<li>我们把可以通过基本类型，const修饰符和声明运算符构造出来的类型称为内置类型(built-in type)</li>
<li>我们把利用C++的抽象机制构建的新类型称为用户自定义类型(user-defined types)</li>
</ul>
<h1 id="第三章-C-概览：抽象机制"><a href="#第三章-C-概览：抽象机制" class="headerlink" title="第三章 C++概览：抽象机制"></a>第三章 C++概览：抽象机制</h1><h2 id="3-2-类"><a href="#3-2-类" class="headerlink" title="3.2 类"></a>3.2 类</h2><ul>
<li>C++最核心的语言特性就是类。类是一种用户自定义的数据类型，用于在程序代码中表示某种概念。</li>
<li>我们只考虑对三种重要的类的基本支持<ul>
<li>具体类</li>
<li>抽象类</li>
<li>类层次中的类</li>
</ul>
</li>
</ul>
<h3 id="3-2-1-具体类型"><a href="#3-2-1-具体类型" class="headerlink" title="3.2.1 具体类型"></a>3.2.1 具体类型</h3><ul>
<li><p>具体类的基本思想是他们的行为 就像内置类型一样。</p>
</li>
<li><p>析构函数的命名规则是一个求补运算符后接类的名字，从含义上来说它是构造函数的补充。</p>
</li>
</ul>
<h2 id="3-5-建议"><a href="#3-5-建议" class="headerlink" title="3.5 建议"></a>3.5 建议</h2><ul>
<li>直接用代码表达你的想法</li>
<li>在代码中直接定义类来表示应用中的概念</li>
<li>用具体类表示那些简单的概念或性能关键的组件</li>
<li>避免裸的new和delete操作</li>
<li>用资源句柄和RAII管理资源</li>
<li>当接口和实现需要完全分离时使用抽象类作为接口</li>
<li>用类层次表示具有固有的层次关系的概念</li>
<li>在设计类层次时，注意区分实现继承和接口继承</li>
<li>控制好对象的构造，拷贝，移动和析构操作</li>
<li>以值的方式返回容器(依赖于移动操作以提高效率)</li>
<li>注意强资源安全，也就是说，不要泄露任何你认为是资源的东西</li>
<li>使用函数模板表示通用的算法</li>
</ul>
<h1 id="第四章-C-概览：容器与算法"><a href="#第四章-C-概览：容器与算法" class="headerlink" title="第四章 C++概览：容器与算法"></a>第四章 C++概览：容器与算法</h1><h2 id="4-1-标准库"><a href="#4-1-标准库" class="headerlink" title="4.1 标准库"></a>4.1 标准库</h2><ul>
<li>本书介绍的标准库设施，在任何一个完整的C++实现中都是必备的部分。</li>
</ul>
<h3 id="4-1-1-标准库概述"><a href="#4-1-1-标准库概述" class="headerlink" title="4.1.1 标准库概述"></a>4.1.1 标准库概述</h3><ul>
<li>标准库提供的设施可以分为以下几类<ul>
<li>运行时语言支持，例如对资源分配和运行时类型信息的支持</li>
<li>C标准库</li>
<li>字符串和I&#x2F;O流</li>
<li>一个包含容器和算法的框架，人们习惯上称这个框架为标准模板库(STL)</li>
<li>对数值计算的支持</li>
<li>对正则表达式匹配的支持</li>
<li>对并发程序设计的支持，包括thread和lock机制</li>
<li>一系列工具，它们用于支持模板元编程，STL-风格的泛型程序设计和通用程序设计</li>
<li>用于资源管理的智能指针和垃圾收集器接口</li>
<li>特殊容器</li>
</ul>
</li>
<li>本质上来说，C++标准库提供了最常用的基本数据结构以及运行在之上的基础算法。</li>
</ul>
<h2 id="4-6-建议"><a href="#4-6-建议" class="headerlink" title="4.6 建议"></a>4.6 建议</h2><ul>
<li>没必要推倒重来，直接使用标准库是最好的选择</li>
<li>除非万不得已，大多数时候先考虑使用标准库，在考虑别的库</li>
<li>标准库绝非万能</li>
<li>一定要了解各种标准库容器的设计思想和优缺点</li>
<li>优先选用vector作为你的容器类型</li>
<li>如果你拿不准会不会越界，记得使用带边界检查的容器</li>
<li>用push_back()或者back_inserter()给容器添加元素</li>
</ul>
<h1 id="第五章-C-概览：并发与实用功能"><a href="#第五章-C-概览：并发与实用功能" class="headerlink" title="第五章 C++概览：并发与实用功能"></a>第五章 C++概览：并发与实用功能</h1><h2 id="5-2-资源管理"><a href="#5-2-资源管理" class="headerlink" title="5.2 资源管理"></a>5.2 资源管理</h2><ul>
<li>所有程序都包含一项关键人物：管理资源。所谓资源是指程序中符合先获取后释放规律的东西，比如内存，锁，套接字，线程句柄和文件句柄等。</li>
</ul>
<h3 id="5-2-1-unique-ptr与shared-ptr"><a href="#5-2-1-unique-ptr与shared-ptr" class="headerlink" title="5.2.1 unique_ptr与shared_ptr"></a>5.2.1 unique_ptr与shared_ptr</h3><ul>
<li>标准库提供了两种智能指针来管理自由存储上的对象<ul>
<li>unique_ptr对应所有权唯一的情况</li>
<li>shared_ptr对应所有权共享的情况</li>
</ul>
</li>
<li>这些智能指针最基本的作用是防止由于编程疏忽而造成的内存泄漏。</li>
</ul>
<h2 id="5-3-并发"><a href="#5-3-并发" class="headerlink" title="5.3 并发"></a>5.3 并发</h2><ul>
<li>并发，也就是多个任务同时执行，被广泛用于提高吞吐率(用多个处理器共同完成单个运算)和提高响应速度(允许程序的一部分在等待响应时，另一部分继续执行)</li>
<li>标准库并发设施重点提供系统级并发机制，而不是直接提供复杂的高层并发模型。基于标准库并发设施可以构建出这类高层并发模型，并以库的形式提供。</li>
<li>标准库直接支持在单一地址空间内并发执行多个线程。为了实现这一目的，C++提供了一个适合的内存模型和一套原子操作。</li>
</ul>
<h3 id="5-3-1-任务和thread"><a href="#5-3-1-任务和thread" class="headerlink" title="5.3.1 任务和thread"></a>5.3.1 任务和thread</h3><ul>
<li>我们称那些可以与其他计算并行执行的计算为任务(task)。线程是任务在程序中的系统级表示。</li>
<li>若要启动一个与其他任务并发执行的任务，我们可以构造一个std::thread并将任务作为它的实参。这里的任务是以函数或函数对象的形式出现的。</li>
<li>一个程序的所有线程共享单一地址空间。在这一点上线程与进程不同，进程间通常不直接共享数据。由于共享单一地址空间，因此线程间可通过共享对象互相通信。通常通过锁或其他防止数据竞争的机制来控制线程间通信。</li>
</ul>
<h3 id="5-3-4-等待事件"><a href="#5-3-4-等待事件" class="headerlink" title="5.3.4 等待事件"></a>5.3.4 等待事件</h3><ul>
<li>有时候thread需要等待某种外部事件，比如另一个thread完成了任务或是已经过去了一段时间。最简单的事件就是时间流逝。</li>
<li>通过外部事件实现线程间通信的基本方式是使用condition_variable，它定义在<condition_variable>中。condition_variable提供了一种机制，允许一个thread等待另一个thread。特别的是，它允许一个thread等待某个条件(condition,通常称为一个事件，event)发生，这种条件通常是其他thread完成工作产生的结果。</li>
</ul>
<h3 id="5-3-5-任务通信"><a href="#5-3-5-任务通信" class="headerlink" title="5.3.5 任务通信"></a>5.3.5 任务通信</h3><ul>
<li>标准库提供了一些特性，允许程序员在抽象的任务层(工作并发执行)进行操作，而不是在底层的线程和锁的层次直接进行操作。<ul>
<li>future和promise用来从一个独立线程上创建出的任务返回结果</li>
<li>packaged_task是帮助启动任务以及连接返回结果的机制</li>
<li>async()以非常类似调用函数的方式启动一个任务</li>
</ul>
</li>
</ul>
<h2 id="5-7-建议"><a href="#5-7-建议" class="headerlink" title="5.7 建议"></a>5.7 建议</h2><ul>
<li>用资源句柄管理资源(RAII)</li>
<li>用unique_ptr访问多态类型的对象</li>
<li>用shared_ptr访问共享的对象</li>
<li>用类型安全的机制处理并发</li>
<li>最好避免共享数据</li>
<li>不要为了所谓效率，而不经思考，不经测试的选择使用共享数据</li>
<li>从并发执行任务的角度进行设计，而不是直接从thread角度思考</li>
<li>一个库是否有用，与它的规模和复杂程度无关</li>
<li>别轻易抱怨程序的效率低下，记得用事实说话</li>
<li>编写代码时可以显式的令其利用某些类型的属性</li>
<li>利用正则表达式简化模式匹配任务</li>
<li>进行数值计算时优先选择使用库而非语言本身</li>
<li>用numeric_limits访问数值类型的属性</li>
</ul>
<h1 id="第六章-类型与声明"><a href="#第六章-类型与声明" class="headerlink" title="第六章 类型与声明"></a>第六章 类型与声明</h1><h2 id="6-1-ISO-C-标准"><a href="#6-1-ISO-C-标准" class="headerlink" title="6.1 ISO C++标准"></a>6.1 ISO C++标准</h2><ul>
<li>在C++标准之下，很多重要的功能都是依赖于实现的(implementation-defined)。这意味着对于语言的某个概念来说，每个实现版本都必须为之设定恰当的，定义良好的语法行为，同时详细记录行为规范。</li>
</ul>
<h3 id="6-1-1-实现"><a href="#6-1-1-实现" class="headerlink" title="6.1.1 实现"></a>6.1.1 实现</h3><ul>
<li>C++的一个具体实现可以有两种形式：宿主式(hosted)和独立式(freestanding)。</li>
<li>在宿主式实现中包含了C++标准和本书描述的所有标准库功能；独立式实现包含的标准库功能可能会少一些。</li>
</ul>
<h2 id="6-2-类型"><a href="#6-2-类型" class="headerlink" title="6.2 类型"></a>6.2 类型</h2><ul>
<li>C++程序中的每个名字(标识符)都对应一种数据类型。该类型决定了这个名字(即该名字代表的实体)能执行哪些运算以及如何执行这些运算。</li>
</ul>
<h3 id="6-2-1"><a href="#6-2-1" class="headerlink" title="6.2.1"></a>6.2.1</h3><ul>
<li><p>C++包含了一套基本类型(fundamental type)，这些类型对应计算机最基本的存储单元并且展现了如何利用这些单元存储数据。</p>
<ul>
<li>布尔值类型</li>
<li>字符类型</li>
<li>整数类型</li>
<li>浮点数类型</li>
<li>void类型，用以表示类型信息缺失</li>
<li>基于上述类型，我们可以用声明符构造出更多类型<ul>
<li>指针类型</li>
<li>数组类型</li>
<li>引用类型</li>
</ul>
</li>
<li>除此之外，用户还能自定义类型<ul>
<li>数据结构和类</li>
<li>枚举类型，用以表示特定值的集合</li>
</ul>
</li>
</ul>
</li>
<li><p>其中，布尔值，字符和整数统称为整型(integral type)，整型和浮点型进一步统称为算术类型(arithmetic type )。</p>
</li>
<li><p>我们把枚举类型和类称为用户自定义类型(user-defined),因为用户必须先定义它们，然后才能使用；这一点显然与基本类型无须声明可以直接使用的方式不同。</p>
</li>
<li><p>与之相反，我们把基本类型，指针和引用统称为内置类型(built-in type)。</p>
</li>
</ul>
<h3 id="6-2-2-布尔值"><a href="#6-2-2-布尔值" class="headerlink" title="6.2.2 布尔值"></a>6.2.2 布尔值</h3><ul>
<li>一个布尔变量(bool)的取值或是true或者是false，布尔变量常用于表示逻辑运算的结果。</li>
<li>根据定义，当我们把布尔值换成整数时，true转为1，而false转为0.反之，整数值也能在需要的时候隐式的转换成布尔值，其中非0整数值对应true，而0对应false。</li>
</ul>
<h3 id="6-2-9-对齐"><a href="#6-2-9-对齐" class="headerlink" title="6.2.9 对齐"></a>6.2.9 对齐</h3><ul>
<li>对象首先应该有足够的空间存放对应的变量，但这还不够。在一些及其的体系结构中，存放变量的字节必须保持一种良好的对齐方式(alignment),以便硬件在访问数据资源时足够高效(在极端情况下一次性访问所有数据)</li>
<li>例如，4字节的int应该按字(4字节)的边界排列，而8字节的double有时也应该按字(8字节)的边界排列。</li>
<li>alignof()运算符返回实参表达式的对齐情况。</li>
</ul>
<h2 id="6-3-声明"><a href="#6-3-声明" class="headerlink" title="6.3 声明"></a>6.3 声明</h2><ul>
<li>在C++程序中要想使用某个名字(标识符)，必须先对其进行声明。换句话说，我们必须指定它的类型以便编译器指导这个名字对应的是何种实体。</li>
<li>大多数声明(declaration)同时也是定义(definition)。我们可以把定义看成是一种特殊的声明，它提供了在程序中使用该实体所需的一切信息。尤其是当实体需要内存空间来存储某些信息时，定义语句把所需的内存预留了出来。</li>
</ul>
<h3 id="6-3-1-声明的结构"><a href="#6-3-1-声明的结构" class="headerlink" title="6.3.1 声明的结构"></a>6.3.1 声明的结构</h3><ul>
<li>我们可以认为一条声明语句(依次)包含5个部分：<ul>
<li>可选的前置修饰符。static，virtual</li>
<li>基本类型。 const int</li>
<li>可选的声明符。p[7]</li>
<li>可选的后缀函数修饰符。const noexcept</li>
<li>可选的初始化器或函数体。{return x;}</li>
</ul>
</li>
<li>修饰符，是指声明语句中最开始的关键字，例如virtual，extern，constexpr等。修饰符的作用是指定所声明对象的某些非类型属性。</li>
<li>声明符由一个名字和一些可选的声明运算符组成。最常用的声明运算符包括<ul>
<li>前缀 * 指针</li>
<li>前缀 *const 常量指针</li>
<li>前缀 &amp; 左值引用</li>
<li>前缀 &amp;&amp; 右值引用</li>
<li>前缀 auto 函数(使用后置返回类型)</li>
<li>后缀 [] 数组</li>
<li>后缀 () 函数</li>
<li>后缀 -&gt; 从函数返回</li>
</ul>
</li>
</ul>
<h3 id="6-3-2-声明多个名字"><a href="#6-3-2-声明多个名字" class="headerlink" title="6.3.2 声明多个名字"></a>6.3.2 声明多个名字</h3><ul>
<li>C++允许在同一条声明语句中声明多个名字，其中包含逗号隔开的多个声明符即可。</li>
<li>读者千万要注意，<strong>在声明语句中，运算符只作用于紧邻的一个名字，对于后续的其他名字是无效的</strong>。</li>
</ul>
<h3 id="6-3-4-作用域"><a href="#6-3-4-作用域" class="headerlink" title="6.3.4 作用域"></a>6.3.4 作用域</h3><ul>
<li><p>声明语句为作用域引入了一个新名字，换句话说，某个名字只能在程序文本的某个特定区域使用。</p>
<ul>
<li>局部作用域(local scope)：函数，lambda表达式中声明的名字称为局部名字。局部名字的作用域从声明处开始，到声明语句所在的快结束为之。其中块(block)是指用一对{}包围的代码片段。对于函数和lambda表达式最外层的块来说，参数名字是其中的局部名字</li>
<li>类作用域(class scope): 如果某个类位于任意函数，类和枚举类或其他名字空间的外部，则定义在该类中的名字称为成员名字或类成员名字。类成员名字的作用域从类声明的{开始，到类声明的结束为止</li>
<li>名字空间作用域(namespace scope): </li>
<li>全局作用域(global scope):</li>
<li>语句作用域(statement scope):</li>
<li>函数作用域(function scope):</li>
</ul>
</li>
<li><p><strong>在块内声明的名字能隐藏外层快及全局作用域中的同名声明</strong>。换句话说，一个已有的名字能在块内被重新定义以指向另外一个实体。退出块后，该名字恢复原来的含义。</p>
</li>
<li><p>我们可以使用作用域解析运算符::访问被隐藏了的全局名字。</p>
</li>
</ul>
<h3 id="6-3-5-初始化"><a href="#6-3-5-初始化" class="headerlink" title="6.3.5 初始化"></a>6.3.5 初始化</h3><ul>
<li><p>顾名思义，初始化器就是对象在初始状态下被赋予的值。初始化器又四种可能的形式</p>
<ul>
<li>X a1{v};</li>
<li>X a2 &#x3D; {v};</li>
<li>X a3 &#x3D; v;</li>
<li>X a4(v)</li>
</ul>
</li>
<li><p>在这些形式中，只有第一种不受任何限制，在所有场景中都能使用。</p>
</li>
<li><p>建议读者使用{}。使用{}的初始化称为列表初始化(list initialization)，它能防止窄化转换。这句话的意思是</p>
<ul>
<li>如果一种整型存不下另一种整型的值，则后者不会被转换成前者。例如，允许char到int的类型转换，但是不允许int到char的类型转换</li>
<li>如果一种浮点型存不下另一种浮点型的值，则后者不会被转换成前者。例如，允许float到double的类型转换，但是不允许double到float的类型转换</li>
<li>浮点型的值不能转换成整型值</li>
<li>整型值不能转换成浮点型的值</li>
</ul>
</li>
<li><p>当我们使用auto关键字从初始化器推断变量的类型时，没必要采用列表初始化的方式。而且如果初始化器是{}列表，则推断得到的数据类型肯定不是我们想要的结果。</p>
</li>
<li><p>因此，当使用auto的时候应该选择&#x3D;的初始化形式。</p>
</li>
<li><p>空初始化器列表{}指定使用默认值进行初始化。大多数数据类型都有默认值</p>
<ul>
<li>对于整数类型来说，默认值是数字0的某种适当形式。</li>
<li>指针的默认值是nullptr</li>
<li>用户自定义类型的默认值由该类型的构造函数决定。</li>
</ul>
</li>
</ul>
<h3 id="6-3-6-推断类型：auto和decltype"><a href="#6-3-6-推断类型：auto和decltype" class="headerlink" title="6.3.6 推断类型：auto和decltype()"></a>6.3.6 推断类型：auto和decltype()</h3><ul>
<li>C++语言提供了两种从表达式中推断数据类型的机制<ul>
<li>auto根据对象的初始化器推断对象的数据类型，可能是变量，const或者constexpr的类型</li>
<li>decltype(expr)推断的对象不是一个简单的初始化器，有可能是函数的返回类型或者类成员的类型。</li>
</ul>
</li>
<li>这里所谓的推断其实非常简单：auto和decltype()只是简单报告一个编译器已知的表达式的类型。</li>
</ul>
<h5 id="6-3-6-1-auto类型修饰符"><a href="#6-3-6-1-auto类型修饰符" class="headerlink" title="6.3.6.1 auto类型修饰符"></a>6.3.6.1 auto类型修饰符</h5><ul>
<li>表达式的类型越难读懂，越难书写，auto就越有用</li>
<li>在较小的作用域中，建议程序员优先选择使用auto</li>
<li>请注意，表达式的类型永远不会是引用类型，因为表达式会隐式的执行解引用操作。</li>
</ul>
<h4 id="6-3-6-3-decltype-修饰符"><a href="#6-3-6-3-decltype-修饰符" class="headerlink" title="6.3.6.3 decltype()修饰符"></a>6.3.6.3 decltype()修饰符</h4><ul>
<li>当有一个合适的初始化器的时候可以使用auto。但是很多时候我们既想推断得到类型，又不想在此过程中定义一个初始化的变量，此时，我们应该使用声明类型修饰符decltype(expr)。其中，推断所得的结果是expr的声明类型。这种用法在泛型编程中很有效。</li>
</ul>
<h3 id="6-4-对象和值"><a href="#6-4-对象和值" class="headerlink" title="6.4 对象和值"></a>6.4 对象和值</h3><ul>
<li>对象(object)是指一块连续存储区域，左值(lvalue)是指对象的一条表达式。</li>
<li>左值的字面意思是：能用在赋值运算符左侧的东西，但其实不是所有左值都能用在赋值运算符的左侧，左值也有可能指示某个常量。未被声明成const的左值称为可修改的左值。</li>
</ul>
<h4 id="6-4-1-左值和右值"><a href="#6-4-1-左值和右值" class="headerlink" title="6.4.1 左值和右值"></a>6.4.1 左值和右值</h4><ul>
<li>为了补充和挖山左值的含义，我们相应的定义了右值(rvalue)。简单来说，右值是指不能作为左值的值，比如像函数返回值一样的临时值</li>
<li>在实际编程过程中，考虑左值和右值就足够了。一条表达式要么是左值，要么是右值，不可能两者都是。</li>
</ul>
<h4 id="6-4-2-对象的声明周期"><a href="#6-4-2-对象的声明周期" class="headerlink" title="6.4.2 对象的声明周期"></a>6.4.2 对象的声明周期</h4><ul>
<li><p>对象的声明周期(lifetime)从对象的构造函数完成的那一刻开始，直到析构函数执行为止。对于那些没有声明构造函数的类型(比如int)，我们可以认为它们拥有默认的构造函数和析构函数，并且这两个函数不执行任何实际操作。</p>
</li>
<li><p>我们从生命周期的角度把对象划分成以下类别</p>
<ul>
<li>自动对象(automatic)：除非程序员特别说明，否则在函数中声明的对象在其定义处被创建，当超出作用域范围时被销毁。这样的对象被称为自动对象。在大多数实现中，自动对象被分配在栈空间上。每调用一次函数，获取新的栈帧(stack frame)以存放它的自动对象。</li>
<li>静态对象(static)：在全局作用域或名字空间作用域中声明的对象以及在函数或类中声明的static成员只被创建并初始化一次，并且直到程序结束之前都活着。这样的对象被称为静态对象。静态对象在程序的整个执行周期内地址唯一。在多线程环境中，静态对象可能会造成某些意料之外的问题。因为所有线程都共享对象，所以必须为其加锁以避免数据竞争。</li>
<li>自由存储对象(free store)：用new和delete直接控制其声明周期的对象</li>
<li>临时对象(temporary)：比如计算的中间结果或者用于存放const实参引用的值的对象。临时对象的生命周期由其用法决定。</li>
<li>线程局部对象(thread-local)：或者说声明为thread_local的对象，这样的对象随着线程的创建而创建，随着线程的销毁而销毁。</li>
</ul>
</li>
<li><p>其中，静态和自动被称为存储类(store class)</p>
</li>
<li><p>数组元素和非静态类成员的生命周期由它们所属的对象决定。</p>
</li>
</ul>
<h3 id="6-6-建议"><a href="#6-6-建议" class="headerlink" title="6.6 建议"></a>6.6 建议</h3><ul>
<li>尽量避免不确定的和未定义的行为</li>
<li>如果某些代码必须依赖于具体实现，记得把它们与程序的其他部分分离开来</li>
<li>对于字符对应的数字值不要乱作假定</li>
<li>以0开头的整数是八进制</li>
<li>不要使用魔法常量</li>
<li>注意带符号类型和无符号类型之间的转换</li>
<li>在一条声明语句中只声明一个名字</li>
<li>常用的，局部的名字尽量短；不常用的，非局部的名字可以长一些</li>
<li>对象的名字应该尽量反应对象的含义而非类型</li>
<li>坚持一种统一的命名风格</li>
<li>避免使用全大写的名字</li>
<li>作用域宜小不宜大</li>
<li>最好不要在一个作用域以及它的外层作用域中使用相同的名字</li>
<li>使用指定类型声明时最好用{}初始化器语法</li>
<li>使用auto声明时最好用&#x3D;语法</li>
<li>避免使用未初始化的变量</li>
<li>当内置类型被用来表示一个可变值时，不妨给它起个能反应其含义的别名。</li>
<li>用别名作为类型的同义词，用枚举和类定义新类型。</li>
</ul>
<h1 id="第七章-指针，数组与引用"><a href="#第七章-指针，数组与引用" class="headerlink" title="第七章 指针，数组与引用"></a>第七章 指针，数组与引用</h1><h2 id="7-1-引言"><a href="#7-1-引言" class="headerlink" title="7.1 引言"></a>7.1 引言</h2><ul>
<li>我们能通过名字使用对象。在C++中，对象位于内存的某个地址中，如果我们知道对象的地址和类型，就能访问它。</li>
<li>在C++语言中存放及使用内存地址是通过指针和引用完成的。</li>
</ul>
<h2 id="7-2-指针"><a href="#7-2-指针" class="headerlink" title="7.2 指针"></a>7.2 指针</h2><ul>
<li><p>对于类型T来说，<code>T*</code>是表示 指向T的指针 的类型。换句话说，<code>T*</code>类型的变量能存放T类型对象的地址。</p>
</li>
<li><p>对指针的一个基本操作是解引用(dereferencing)，即引用指针所指的对象。这个操作也称为间接取值(indirection)。解引用运算符是个前置一元运算符，对应的符号是*。</p>
</li>
<li><p>指针的具体实现应该与运行程序的机器的寻址机制同步。大多数机器支持逐字节访问内存，其他机器则需要从字中抽取字节。很少有机器能直接寻址到一个二进制位。因此，能独立分配且用内置指针指向的最小对象是char类型的对象。</p>
</li>
<li><p>有一点读者注意：bool占用的内存空间至少和char一样多。如果想把更小的值存的更紧密，可以使用位逻辑操作，结构中的位域或者bitset</p>
</li>
<li><p>符号*在用作类型名的后缀时表示 指向 的含义。如果我们想表示指向数组的指针或者指向函数的指针，需要使用稍微复杂的一些方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pi;  <span class="comment">// 指向int的指针</span></span><br><span class="line"><span class="type">char</span>** ppc; <span class="comment">// 指向字符指针的指针</span></span><br><span class="line"><span class="type">int</span>* ap[<span class="number">15</span>];  <span class="comment">// ap是一个数组，包含15个指向int的指针</span></span><br><span class="line"><span class="built_in">int</span> (*fp)(<span class="type">char</span>*); <span class="comment">// 指向函数的指针，该函数接受一个char*实参，返回一个int</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">f</span><span class="params">(<span class="type">char</span>*)</span></span>;  <span class="comment">// 该函数接受一个char*实参，返回一个指向int的指针。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-2-1-void"><a href="#7-2-1-void" class="headerlink" title="7.2.1 void *"></a>7.2.1 void *</h3><ul>
<li>在某些偏向底层的代码中，我们偶尔需要在不知道对象确切类型的情况下，仅通过对象在内存中的地址存储或传递对象。此时，我们会用到void*,其含义是 指向未知类型对象的指针。</li>
<li>除了函数指针和指向类成员的指针，指向其他任意类型对象的指针都能被赋给一个void*类型的变量。</li>
<li>void*最主要的用途是当我们无法假定对象的类型时，向函数传递指向该对象的指针；它还用于从函数返回未知类型的对象。要想使用这样的对象，必须先进行显式类型转换。</li>
</ul>
<h3 id="7-2-2-nullptr"><a href="#7-2-2-nullptr" class="headerlink" title="7.2.2 nullptr"></a>7.2.2 nullptr</h3><ul>
<li>字面值常量nullptr表示空指针，即不指向任何对象的指针。我们可以把nullptr赋给其他任意指针类型，但是不能赋给其他内置类型。</li>
<li>使用nullptr的好处很多，首先它的可读性更强，其次当一组重载函数既可以接受指针也可以接受整数时，用nullptr能够避免语义混淆。</li>
</ul>
<h2 id="7-3-数组"><a href="#7-3-数组" class="headerlink" title="7.3 数组"></a>7.3 数组</h2><ul>
<li>假设有类型T，T[size]的含义是包含size个T类型元素的数组。元素的索引值范围是0到size-1。</li>
<li>以0作为终止符的char数组是应用最广泛的一种数组。这是C语言存储字符串的基本方式，因此我们常把0作为终止符的char数组称为C风格字符串。</li>
</ul>
<h3 id="7-3-1-数组的初始化器"><a href="#7-3-1-数组的初始化器" class="headerlink" title="7.3.1 数组的初始化器"></a>7.3.1 数组的初始化器</h3><ul>
<li>我们能用值的列表初始化一个数组，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">char</span> v2[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li>如果声明数组的时候没有指定它的大小但是给出了初始化器列表，则编译器会根据列表包含的元素数量自动计算数组的大小。</li>
<li>如果我们指定了数组的大小，但是提供的初始化器列表元素数量过多，则程序会发生错误。</li>
<li>如果初始化器提供的元素数量不足，则系统自动把剩余的元素赋值为0</li>
<li>C++没有为数组提供内置的拷贝操作。不允许用一个数组初始化另一个数组，即使两个数组的类型完全一样也不行，因为数组不支持赋值操作。同样，不允许以传值方式传递数组。</li>
<li>如果你想给一组对象赋值，可以使用vector，array或者valarray</li>
<li>我们可以用字符串字面量常量初始化字符的数组。</li>
</ul>
<h2 id="7-4-数组中的指针"><a href="#7-4-数组中的指针" class="headerlink" title="7.4 数组中的指针"></a>7.4 数组中的指针</h2><ul>
<li>在C++语言中，指针与数组密切相关。数组名可以看成是指向数组首元素的指针。</li>
</ul>
<h3 id="7-4-3-传递数组"><a href="#7-4-3-传递数组" class="headerlink" title="7.4.3 传递数组"></a>7.4.3 传递数组</h3><ul>
<li>不能以值传递的方式直接把数组传给函数，我们通常传递的是数组首元素的指针。</li>
</ul>
<h2 id="7-5-指针与const"><a href="#7-5-指针与const" class="headerlink" title="7.5 指针与const"></a>7.5 指针与const</h2><ul>
<li>C++提供了两种与常量有关的概念<ul>
<li>constexpr：编译时求值</li>
<li>const：在当前作用域内，值不发生改变</li>
</ul>
</li>
<li>基本上，constexpr的作用是指示或确保在编译时求值，而const的主要任务是规定接口的不可修改性。</li>
<li>很多对象的值一旦初始化就不会再改动<ul>
<li>使用符号化常量的代码比直接使用字面值常量的代码更易维护</li>
<li>我们经常通过指针读取数据，但是很少通过指针写入数组</li>
<li>绝大多数函数的参数只负责读取数据，很少写入数据。</li>
</ul>
</li>
<li>为了表达已经初始化就不可修改的特性，我们可以再对象的定义中加上const关键字。</li>
<li>一旦我们把某物声明成const，就确保它的值在其作用域内不会发生改变</li>
<li>使用const会改变一种类型。所谓改变不是说改变了常量的分配方式，而是限制了它的使用方式。</li>
</ul>
<h2 id="7-6-指针与所有权"><a href="#7-6-指针与所有权" class="headerlink" title="7.6 指针与所有权"></a>7.6 指针与所有权</h2><ul>
<li>资源必须先分配后释放。指针是最常用的资源句柄。</li>
</ul>
<h2 id="7-7-引用"><a href="#7-7-引用" class="headerlink" title="7.7 引用"></a>7.7 引用</h2><ul>
<li>引用作为对象的别名存放的也是对象的机器地址。与指针相比，引用不会带来额外的开销。引用和指针的区别主要包括<ul>
<li>访问引用与访问对象本身从语法形式上看是一样的</li>
<li>引用所引的永远是一开始初始化的那个对象</li>
<li>不存在空引用。我们可以认为应用一定对应着某个对象。</li>
</ul>
</li>
<li>引用实际上是对象的别名。引用最重要的用途是作为函数的实参或返回值，此外，它也被用于重载运算符。</li>
<li>为了体现左值&#x2F;右值以及const&#x2F;非const的区别，存在三种形式的引用<ul>
<li>左值引用(lvalue reference): 引用那些我们希望改变值的对象</li>
<li>const引用(const reference): 引用那些我们不希望改变值的对象，比如常量</li>
<li>右值引用(rvalue reference): 所引对象的值在我们使用之后就无需保留了，例如临时变量。</li>
</ul>
</li>
<li>这三种形式统称为引用，其中前两种形式都是左值引用。</li>
</ul>
<h3 id="7-7-1-左值引用"><a href="#7-7-1-左值引用" class="headerlink" title="7.7.1 左值引用"></a>7.7.1 左值引用</h3><ul>
<li>在类型名字中，符号X&amp;的意思是 X的引用：它常用于表示左值的引用，因此称为左值引用。</li>
</ul>
<h2 id="7-8-建议"><a href="#7-8-建议" class="headerlink" title="7.8 建议"></a>7.8 建议</h2><ul>
<li>使用指针时越简单直接越好</li>
<li>不要对指针执行稀奇古怪的算术运算</li>
<li>注意不要越界访问数组，尤其不要再数组之外的区域写入内容</li>
<li>不要使用多维数组，用合适的容器代替它</li>
<li>用nullptr代替0和NULL</li>
<li>与内置的C风格数组相比，优先使用容器</li>
<li>优先选用string，而不是以0结尾的char数组</li>
<li>如果字符串字面值常量中包含太多反斜线，则使用原始字符串</li>
<li>const引用比普通引用更适合作为函数的实参</li>
<li>只要当需要转发和移动时才使用右值引用</li>
<li>让表示所有权的指针位于句柄类的内部</li>
<li>再底层代码之外尽量不要使用void*</li>
<li>用const指针和const引用表示接口中不允许修改的部分</li>
</ul>
<h1 id="第八章-结构，联合与枚举"><a href="#第八章-结构，联合与枚举" class="headerlink" title="第八章 结构，联合与枚举"></a>第八章 结构，联合与枚举</h1><h2 id="8-1-引言"><a href="#8-1-引言" class="headerlink" title="8.1 引言"></a>8.1 引言</h2><ul>
<li>用户自定义类型是能否有效使用C++的关键。</li>
<li>三种用户自定义类型的初级形式<ul>
<li>struct，结构是由任意类型元素(即成员)构成的序列</li>
<li>union，是一种struct，同一时刻只保存一个元素的值</li>
<li>enum，枚举是包含一组命名常量(称为枚举值)的类型</li>
<li>enum class(限定作用域的枚举类型)是一种enum，枚举值位于枚举类型的作用域内，不存在向其他类型的隐式类型转换。</li>
</ul>
</li>
</ul>
<h2 id="8-2-结构"><a href="#8-2-结构" class="headerlink" title="8.2 结构"></a>8.2 结构</h2><ul>
<li>数组是相同类型元素的集合。相反，struct是任意类型元素的集合。</li>
<li>结构类型的对象可以被赋值，作为实参传入函数，或者作为函数的结果返回。</li>
<li>默认情况下，比较运算符(&#x3D;&#x3D;, !&#x3D;)等一些似是而非的操作并不适用于结构类型。当然，用户有权自定义这些运算符。</li>
</ul>
<h3 id="8-2-1-struct的布局"><a href="#8-2-1-struct的布局" class="headerlink" title="8.2.1 struct的布局"></a>8.2.1 struct的布局</h3><ul>
<li>在struct的对象中，成员按照声明的顺序依次存放。</li>
<li>在内存中为成员分配空间时，顺序与声明结构的时候保持一致。</li>
<li>然而，一个struct对象的大小不一定恰好等于它所有元素大小的累积之和。因为很多机器要求一些特定类型的对象沿着系统结构设定的边界分配空间，以便机器能高效的处理这些对象。例如，整数通常沿着字的边界分配空间。</li>
<li>在这类机器上，我们说对象对齐(aligned)得很好。</li>
<li>通常情况下，我们应该从可读性的角度出发设计结构成员的顺序。只有当需要优化程序的性能时，才按照成员的大小排序。</li>
</ul>
<h3 id="8-2-2-struct的名字"><a href="#8-2-2-struct的名字" class="headerlink" title="8.2.2 struct的名字"></a>8.2.2 struct的名字</h3><ul>
<li>类型名字只要一出现就能马上使用了，无需等到该类型的声明全部完成。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Link</span> </span><br><span class="line">&#123;</span><br><span class="line">  Link* previous;</span><br><span class="line">  Link* successor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>但是，只有等到struct的声明全部完成，才能声明它的对象。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">No_good</span> </span><br><span class="line">&#123;</span><br><span class="line">  No_good member; <span class="comment">// 错误：递归定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>因为编译器无法确定No_good的大小，所以程序会报错。要想让两个或更多struct互相引用，必须提前声明好struct的名字。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Link</span> </span><br><span class="line">&#123;</span><br><span class="line">  Link* pre;</span><br><span class="line">  Link* suc;</span><br><span class="line">  List* member_of;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Link</span> </span><br><span class="line">&#123;</span><br><span class="line">  Link* head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>如果没有一开始声明List，则在稍后声明Link时使用List*类型的指针将造成错误。</li>
<li>我们可以在真正定义一个struct类型之前就使用它的名字，只要在此过程中不使用成员的名字和结构的大小就行了。然而，直到struct的声明完成之前，它都是一个不完整的类型。</li>
</ul>
<h3 id="8-2-3-结构与类"><a href="#8-2-3-结构与类" class="headerlink" title="8.2.3 结构与类"></a>8.2.3 结构与类</h3><ul>
<li>struct是一种class，它的成员默认是public的。struct可以包含成员函数，尤其是构造函数。</li>
<li>如果只是想按照默认的顺序初始化结构的成员，则不需要专门定义一个构造函数。</li>
<li>但是如果你需要改变实参的顺序，检验实参的有效性，修改实参或者建立不变式，则应该编写一个专门的构造函数。</li>
</ul>
<h3 id="8-2-4-结构与数组"><a href="#8-2-4-结构与数组" class="headerlink" title="8.2.4 结构与数组"></a>8.2.4 结构与数组</h3><ul>
<li>很自然的，我们可以构建struct的数组，也可以让struct包含数组。</li>
</ul>
<h3 id="8-2-5-类型等价"><a href="#8-2-5-类型等价" class="headerlink" title="8.2.5 类型等价"></a>8.2.5 类型等价</h3><ul>
<li>对于两个struct来说，即使它们的成员相同，它们本身仍是不同的类型。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span>&#123;<span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span>&#123;<span class="type">int</span> a;&#125;;</span><br></pre></td></tr></table></figure></li>
<li>S1和S2是两种类型，因此：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S1 x;</span><br><span class="line">S2 y = x;  <span class="comment">// 错误：类型不匹配</span></span><br></pre></td></tr></table></figure></li>
<li>struct本身的类型与其成员的类型不能混为一谈。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S1 x;</span><br><span class="line"><span class="type">int</span> i = x;  <span class="comment">// 错误：类型不匹配</span></span><br></pre></td></tr></table></figure></li>
<li><strong>在程序中，每个struct只能有唯一的定义。</strong></li>
</ul>
<h3 id="8-2-6-普通旧数据"><a href="#8-2-6-普通旧数据" class="headerlink" title="8.2.6 普通旧数据"></a>8.2.6 普通旧数据</h3><ul>
<li><p>有时候，我们只想把对象当成普通旧数据(内存中连续字节序列)而不愿考虑那些高级语义概念，比如运行时多态，用户自定义的拷贝语义等。这么做的主要动机是在硬件条件允许的范围内尽可能高效的移动对象。</p>
</li>
<li><p>例如，要执行拷贝含有100个元素的数组的任务，调用100次拷贝构造函数显然不像直接调用std::memcpy()有效率，毕竟后者只需要使用一个块移动指令即可。</p>
</li>
<li><p>POD(普通旧数据)是指能被 仅当作数据 处理的对象，程序员无需顾及类布局的复杂性以及用户自定义的构造，拷贝和移动语义。</p>
</li>
<li><p>我们如果想把某个对象仅当作数据处理，则要求该对象必须满足下述条件</p>
<ul>
<li>不具有复杂的布局</li>
<li>不具有非标准拷贝语义</li>
<li>含有一个最普通的默认构造函数。</li>
</ul>
</li>
</ul>
<h3 id="8-2-7-域"><a href="#8-2-7-域" class="headerlink" title="8.2.7 域"></a>8.2.7 域</h3><ul>
<li>看起来用一整个字节(一个char或者一个bool)表示一个二元变量(比如on&#x2F;off开关)有些浪费，但是char已经是C++中能独立分配和寻址的最小对象了。我们也可以把这些微小的变量组织在一起作为struct的域(field)。域也称为位域(bit-field)</li>
<li>我们只要指定成员所占的位数，就能把它定义成域了。</li>
</ul>
<h2 id="8-3-联合"><a href="#8-3-联合" class="headerlink" title="8.3 联合"></a>8.3 联合</h2><ul>
<li>union是一种特殊的struct，它的所有成员都分配在同一个地址空间上。因此，一个union实际占用的空间大小与其最大的成员一样。自然的，在同一时刻union只能保存一个成员的值。</li>
<li>语言本身并不负责追踪和管理union到底存的是哪种值，这是程序员的责任。</li>
<li>使用union的目的无非是让数据更紧密，从而提高程序的性能。然而，大多数程序即使用了union也不会提高太多；同时，使用union的代码更容易出错。因此，<strong>我认为union是一种被过度使用的语言特性，最好不要出现在你的程序中</strong>。</li>
</ul>
<h3 id="8-3-1-联合与类"><a href="#8-3-1-联合与类" class="headerlink" title="8.3.1 联合与类"></a>8.3.1 联合与类</h3><ul>
<li>从技术上说，union是一种特殊的struct，而struct是一种特殊的class。然而，很多提供给类的功能和联合无关，因此对union施加了一些限制<ul>
<li>union不能含有虚函数</li>
<li>union不能含有引用类型的成员</li>
<li>union不能含有基类</li>
<li>在union的所有成员中，最多只能有一个成员包含类初始化器</li>
<li>union不能被用作其他类的基类。</li>
</ul>
</li>
<li>这些约束规则有效的阻止了很多错误的发生，同时简化了union的实现过程。后面一点非常重要，<strong>因为union的主要作用是优化代码的性能</strong>，所以我们肯定不希望再使用union的过程中引入隐形的代价。</li>
</ul>
<h2 id="8-4-枚举"><a href="#8-4-枚举" class="headerlink" title="8.4 枚举"></a>8.4 枚举</h2><ul>
<li>枚举(enumeration)类型用于存放用户指定的一组整数值。枚举类型的每种取值各自对应一个名字，我们把这些值叫做枚举值(enumerator)</li>
<li>枚举类型分为两种<ul>
<li>enum class，它的枚举值名字位于enum的局部作用域内，枚举值不会隐式的转换成其他类型</li>
<li>普通的enum，它的枚举值名字与枚举类型本身位于同一个作用域中，枚举值隐式的转换成整数</li>
</ul>
</li>
<li>通常情况下，建议程序员使用enum class。</li>
</ul>
<h3 id="8-4-1-enum-class"><a href="#8-4-1-enum-class" class="headerlink" title="8.4.1 enum class"></a>8.4.1 enum class</h3><ul>
<li>enum class是一种限定了作用域的强类型枚举</li>
<li>枚举常用一些整数类型表示，每个枚举值是一个整数。我们把用于表示某个枚举的类型称为它的基础类型(underlying type)。基础类型必须是一种带符号或无符号的整数类型，默认是int。我们可以显式的指定。</li>
<li>默认情况下，枚举值从0开始，依次递增。</li>
<li>C++允许先声明一个enum class，稍后再给出它的定义</li>
<li>一个整数类型的值可以显式的转换成枚举类型。如果这个值属于枚举的基础类型的取值范围，则转换是有效的；否则，如果超出了合理的表示范围，则转换的结果是未定义的。</li>
<li>对enum class执行的sizeof的结果是对其基础类型执行sizeof的结果。如果没有显式指定基础类型，则枚举类型的尺寸等于sizeof(int)</li>
</ul>
<h3 id="8-4-3-未命名的enum"><a href="#8-4-3-未命名的enum" class="headerlink" title="8.4.3 未命名的enum"></a>8.4.3 未命名的enum</h3><ul>
<li>一个普通的enum可以是未命名的。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;arrow_up = <span class="number">1</span>, arrow_down, arrow_sideways&#125;;</span><br></pre></td></tr></table></figure></li>
<li>如果我们需要的只是一组整型常量，而不是用于声明变量的类型，则可以使用未命名的enum。</li>
</ul>
<h2 id="8-5-建议"><a href="#8-5-建议" class="headerlink" title="8.5 建议"></a>8.5 建议</h2><ul>
<li>如果想紧凑的存储数据，则把结构中尺寸较大的成员布局在较小的成员之前</li>
<li>用位域表示由硬件决定的数据布局</li>
<li>不要天真的认为仅靠把几个值打包在一个字节中就能轻易的优化内存</li>
<li>用union减少内存空间的使用，不要将它用于类型转换</li>
<li>用枚举类型表示一组命名的常量</li>
</ul>
<h1 id="第九章-语句"><a href="#第九章-语句" class="headerlink" title="第九章 语句"></a>第九章 语句</h1><h2 id="9-1-引言"><a href="#9-1-引言" class="headerlink" title="9.1 引言"></a>9.1 引言</h2><ul>
<li>C++提供了一组即符合传统又灵活易用的语句。</li>
<li>一个声明就是一条语句，表达式的末尾加上一个分号也是一条语句。</li>
<li>与表达式不同，语句本身没有值。语句的主要作用是指定执行的顺序。</li>
</ul>
<h2 id="9-2-语句概述"><a href="#9-2-语句概述" class="headerlink" title="9.2 语句概述"></a>9.2 语句概述</h2><ul>
<li>分号本身也是一条语句，即空语句(empty statement)</li>
<li>花括号{} 括起来的一个可能为空的语句序列称为块(block)或者复合语句(compound statement)。块中声明的名字的作用域到块的末尾就结束了。</li>
<li>声明(declaration),是一条语句，没有赋值语句或过程调用语句；赋值和函数调用不是语句，它们是表达式。</li>
<li>for初始化语句(for-init-statement)要么是声明，要么是一条表达式语句，它们都以分号结束</li>
<li>for初始化声明(for-init-declaration)必须是一个未初始化变量的声明</li>
<li>try语句块(try-block)的作用是处理异常。</li>
</ul>
<h2 id="9-3-声明作为语句"><a href="#9-3-声明作为语句" class="headerlink" title="9.3 声明作为语句"></a>9.3 声明作为语句</h2><ul>
<li>一个声明就是一条语句。除非变量被声明成static，否则在控制线程传递给当前声明语句的同时执行初始化器。</li>
<li>允许把声明当成一条语句使用的目的是尽量减少由未初始化变量造成的程序错误，并且让代码的局部性更好。在绝大多数情况下，如果没有为变量找到一个合适的值，暂时不要声明它。</li>
</ul>
<h2 id="9-4-选择语句"><a href="#9-4-选择语句" class="headerlink" title="9.4 选择语句"></a>9.4 选择语句</h2><ul>
<li>if语句和switch语句都需要首先检测一个值</li>
<li>条件(condition)可能是一个表达式，也可能是一个声明。</li>
</ul>
<h3 id="9-4-1-if语句"><a href="#9-4-1-if语句" class="headerlink" title="9.4.1 if语句"></a>9.4.1 if语句</h3><ul>
<li>一个名字只能在声明它的作用域中使用。在if语句中，一个分支声明的名字不能在另一个分支中直接使用。</li>
<li>if语句的一个分支不能仅有一条声明语句，没有别的语句。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i)</span><br><span class="line">    <span class="type">int</span> x = i + <span class="number">2</span>;  <span class="comment">// 错误：if语句分支的声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-4-2-switch语句"><a href="#9-4-2-switch语句" class="headerlink" title="9.4.2 switch语句"></a>9.4.2 switch语句</h3><ul>
<li>switch语句在一组候选项(case标签)中进行选择。case标签中出现的表达式必须是整型和枚举类型的常量表达式。在同一个switch语句中，一个值最多被case标签使用一次。</li>
<li>switch语句可以用一组if语句等价的替换。</li>
<li>谨记switch语句的每一个分支都应该有一条结束语句，否则程序将会继续执行下一个分支的内容</li>
<li>有一种好的解决办法：在那些我们确使希望继续执行下一个分支的地方加上注释，指明程序的意图。</li>
<li>要想结束一个分支，最常用的是break语句，有时候也可以用return语句。</li>
<li>C++允许在switch语句的块内声明变量，但是不能不初始化。如果我们确使需要switch语句中使用变量，最好把该变量的声明和使用限定在一个块中。</li>
</ul>
<h3 id="9-4-3-条件中的声明"><a href="#9-4-3-条件中的声明" class="headerlink" title="9.4.3 条件中的声明"></a>9.4.3 条件中的声明</h3><ul>
<li>要想避免不小心误用变量，最好的变法是把变量的作用域限定在一个较小的范围内。</li>
</ul>
<h2 id="9-5-循环语句"><a href="#9-5-循环语句" class="headerlink" title="9.5 循环语句"></a>9.5 循环语句</h2><ul>
<li>循环语句能表示成for，while和do的形式</li>
</ul>
<h3 id="9-5-1-范围for语句"><a href="#9-5-1-范围for语句" class="headerlink" title="9.5.1 范围for语句"></a>9.5.1 范围for语句</h3><ul>
<li>最简单的循环是范围for语句，它使得程序员可以依次访问指定范围内的每个元素</li>
<li>for(int x : v)读作 对于范围v中的每个元素x。程序从头到尾依次访问v的全部元素。</li>
<li>命名元素的变量的作用域是整个for语句。冒号之后的表达式必须是一个序列，换句话说，如果我们对它的调用v.begin()和v.end()或者begin(v)和end(v)，得到的应该是迭代器。</li>
</ul>
<h3 id="9-5-2-for语句"><a href="#9-5-2-for语句" class="headerlink" title="9.5.2 for语句"></a>9.5.2 for语句</h3><ul>
<li>如果循环不符合 引入一个循环变量，检验条件，更新循环变量 的模式，则它更适合用while语句表示。</li>
</ul>
<h3 id="9-5-3-while语句"><a href="#9-5-3-while语句" class="headerlink" title="9.5.3 while语句"></a>9.5.3 while语句</h3><ul>
<li>while语句重复执行它的受控语句直到条件部分变成false</li>
<li>与for语句相比，while语句更适合处理以下两种情况<ul>
<li>一是没有一个明显的循环变量</li>
<li>二是程序员觉得把负责更新循环变量的语句置于循环体内更自然。</li>
</ul>
</li>
</ul>
<h3 id="9-5-4-do语句"><a href="#9-5-4-do语句" class="headerlink" title="9.5.4 do语句"></a>9.5.4 do语句</h3><ul>
<li>do语句与while非常相似，唯一的区别就是do语句的条件位于循环体之后。</li>
</ul>
<h3 id="9-5-5-退出循环"><a href="#9-5-5-退出循环" class="headerlink" title="9.5.5 退出循环"></a>9.5.5 退出循环</h3><ul>
<li>break语句负责跳出最近的外层switch语句</li>
<li>当我们需要中途离开循环体的时候，可以使用break语句。通常情况下，应该让完整退出的条件位于while语句和for语句的条件部分，只要这么做不会违背循环本身的逻辑就行。</li>
</ul>
<h2 id="9-6-goto语句"><a href="#9-6-goto语句" class="headerlink" title="9.6 goto语句"></a>9.6 goto语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">goto 标识符;</span><br><span class="line">标识符: 语句</span><br></pre></td></tr></table></figure>
<ul>
<li>标签的作用域是标签所处的函数。这意味着你能用goto从块的范围跳进跳出，唯一的限制是不能跳过初始化器或者跳入到异常处理程序中。</li>
<li>在一般的代码中，goto可以用来跳出嵌套的循环或者switch(语句)，这是他为数不多的有意义的用法之一。</li>
</ul>
<h2 id="9-7-注释与缩进"><a href="#9-7-注释与缩进" class="headerlink" title="9.7 注释与缩进"></a>9.7 注释与缩进</h2><ul>
<li>如果语言本身能说清楚某件事，那就不要放在注释中，而应该让语句来完成。</li>
<li>好注释负责指明一段代码应该实现什么功能(代码的意图)，而代码本身负责完成该功能(完成的方式)。最好的方式是，注释的语言应该保持在一个较高层次的抽象水平上，这样便于人们理解而无需纠结过多技术细节。</li>
<li>关于注释，我的习惯是<ul>
<li>在针对每个源文件的注释中指明：该文件中的声明有何共同点，对应的参考手册条目，程序员以及维护该文件所需的其他信息</li>
<li>为每个类，模板和名字空间分别编写注释</li>
<li>为每个非平凡的函数分别编写注释并指明：函数的目的，用到的算法，以及该函数对其应用环境所做的某些设定。</li>
<li>为全局和名字空间内的每个变量及常量分别编写注释</li>
<li>为某些不太明显或不可移植的代码编写注释</li>
<li>其他情况，则几乎不需要注释了。</li>
</ul>
</li>
</ul>
<h2 id="9-8-建议"><a href="#9-8-建议" class="headerlink" title="9.8 建议"></a>9.8 建议</h2><ul>
<li>直到有了合适的初始值再声明变量</li>
<li>如果可能的话，优先选用switch语句而非if语句。</li>
<li>如果可能的话，优先选用范围for语句而非普通的for语句</li>
<li>当没有明显的循环变量时，优先选用while语句而非for语句</li>
<li>避免使用do语句</li>
<li>避免使用goto语句</li>
<li>注释应该简短直接</li>
<li>代码能说清楚的事情就别放在注释中</li>
<li>注释应该表明程序的意图</li>
<li>坚持一种缩进风格，不要轻易改变</li>
</ul>
<h1 id="第十一章-选择适当的操作"><a href="#第十一章-选择适当的操作" class="headerlink" title="第十一章 选择适当的操作"></a>第十一章 选择适当的操作</h1><h2 id="11-1-其他运算符"><a href="#11-1-其他运算符" class="headerlink" title="11.1 其他运算符"></a>11.1 其他运算符</h2><ul>
<li>逻辑运算符，位逻辑运算符，条件表达式，递增递减运算符</li>
</ul>
<h3 id="11-1-1-逻辑运算符"><a href="#11-1-1-逻辑运算符" class="headerlink" title="11.1.1 逻辑运算符"></a>11.1.1 逻辑运算符</h3><ul>
<li>逻辑运算符 &amp;&amp;, ||, !接受算术类型以及指针类型的运算对象，将其转换为bool类型，最后返回一个bool类型的结果。</li>
</ul>
<h3 id="11-1-2-位逻辑运算符"><a href="#11-1-2-位逻辑运算符" class="headerlink" title="11.1.2 位逻辑运算符"></a>11.1.2 位逻辑运算符</h3><ul>
<li>位逻辑运算符 &amp;, |, ^, ~, &gt;&gt; , &lt;&lt; 作用于整型对象，即 char, short, int ,long, long long 以及对应的unsigned版本，以及 bool, wchar_t, char16_t, char32_t等类型</li>
</ul>
<h3 id="11-1-3-条件表达式"><a href="#11-1-3-条件表达式" class="headerlink" title="11.1.3 条件表达式"></a>11.1.3 条件表达式</h3><ul>
<li>某些if语句可以改写成条件表达式(conditional-expression)，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt;= b)</span><br><span class="line">  max = b;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  max = a;</span><br></pre></td></tr></table></figure></li>
<li>这段代码可以更加直观的表示为<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max = (a &lt;= b) ? b : a;</span><br></pre></td></tr></table></figure></li>
<li>其中，条件部分的括号并非必须，但是加上后能使代码更易读</li>
<li>条件表达式能用在常量表达式中，这一点非常重要</li>
<li>此外，throw表达式也能作为条件表达式的一个分支。</li>
</ul>
<h3 id="11-1-4-递增与递减"><a href="#11-1-4-递增与递减" class="headerlink" title="11.1.4 递增与递减"></a>11.1.4 递增与递减</h3><ul>
<li>++x的值是x的新值(即，x递增之后的值)。例如，y &#x3D; ++x 等价于 y &#x3D; (x &#x3D; x + 1)</li>
<li>与之相反，x++的值是x的旧值。例如，y &#x3D; x++ 等价于 y &#x3D; (t &#x3D; x, x &#x3D; x + 1, t)，其中，t是一个与x类型相同的变量</li>
</ul>
<h2 id="11-2-自由存储"><a href="#11-2-自由存储" class="headerlink" title="11.2 自由存储"></a>11.2 自由存储</h2><ul>
<li>命名对象的生命周期由其作用域决定。然而，某些情况下我们希望对象与创建它的语句所在的作用域独立开来。例如，很多时候我们在函数内部创建了对象，并且希望在函数返回后仍能使用这些对象。</li>
<li>运算符new负责创建这样的对象，运算符delete则负责销毁它们。new分配的对象 位于自由存储之上，或者说在堆上 ，在动态内存中</li>
</ul>
<h3 id="11-2-1-内存管理"><a href="#11-2-1-内存管理" class="headerlink" title="11.2.1 内存管理"></a>11.2.1 内存管理</h3><ul>
<li><p>自由存储的问题主要包括</p>
<ul>
<li>对象泄露(leaked object): 使用new，但是忘了用delete释放掉分配的对象</li>
<li>提前释放(premature deletion): 在尚有其他指针指向该对象并且后续仍会使用该对象的情况下过早的delete</li>
<li>重复释放(double deletion): 同一对象被释放两次，两次调用对象的析构函数。</li>
</ul>
</li>
<li><p>重复释放的问题在于资源管理器通常无法追踪资源的所有者</p>
</li>
<li><p>在一个规模较大的程序中要想确保准确释放掉分配的每一个对象(只释放一次且确保释放点正确)实在太难了。</p>
</li>
<li><p>有两种方法可以避免上述问题，我建议程序员使用这两种方法代替裸new和delete</p>
<ul>
<li>除非万不得已不要把对象放在自由存储上，优先选用作用域内的变量</li>
<li>当你在自由存储上构建对象时，把它的指针放在一个管理器对象(manager object，有时也称为句柄)中，此类对象通常含有一个析构函数，可以确保释放资源。尽可能让这个管理器对象作为作用域内的变量出现。很多习惯于使用自由存储的场合其实都可以用移动语义代替，只要从函数中返回一个表示大对象的管理器对象就可以了</li>
</ul>
</li>
<li><p>关于new和delete，我的经验是应该尽量确保没有裸new，即，令new位于构造函数或类似的函数中，delete位于析构函数中，由它们提供内存管理的策略。此外，new常用作资源句柄的实参。</p>
</li>
</ul>
<h3 id="11-2-2-数组"><a href="#11-2-2-数组" class="headerlink" title="11.2.2 数组"></a>11.2.2 数组</h3><ul>
<li>new还能用来创建对象的数组</li>
<li>普通的delete用于删除单个对象，delete[]负责删除数组。</li>
</ul>
<h3 id="11-2-3-获取内存空间"><a href="#11-2-3-获取内存空间" class="headerlink" title="11.2.3 获取内存空间"></a>11.2.3 获取内存空间</h3><ul>
<li>自由存储运算符new, delete, new[], delete[]的实现位于 <new> 头文件中</li>
</ul>
<h3 id="11-2-4-nothrow-new"><a href="#11-2-4-nothrow-new" class="headerlink" title="11.2.4 nothrow new"></a>11.2.4 nothrow new</h3><ul>
<li>有的程序不允许出现异常，此时，我们可以是使用nothrow版本的new和delete</li>
</ul>
<h2 id="11-3-列表"><a href="#11-3-列表" class="headerlink" title="11.3 列表"></a>11.3 列表</h2><ul>
<li>{}列表构建的是某种类型的对象，因此其中包含的元素数量和类型都必须符合构建该类型对象的要求。</li>
</ul>
<h2 id="11-4-lambda表达式"><a href="#11-4-lambda表达式" class="headerlink" title="11.4 lambda表达式"></a>11.4 lambda表达式</h2><ul>
<li>lambda表达式(lambda expression)，有时也称为lambda函数。它是定义和使用匿名函数对象的一种简便的方式。在图形界面中，这样的操作常被称为回调(callback)</li>
</ul>
<h3 id="11-4-1-实现模型"><a href="#11-4-1-实现模型" class="headerlink" title="11.4.1 实现模型"></a>11.4.1 实现模型</h3><ul>
<li>lambda的主体部分变为了operator()()的函数体。因为lambda并不返回值，所以operator()()是void。默认情况下，operator()()是const，因此在lambda体内部无法修改捕获的变量，这也是目前为止最常见的情况。如果你希望在lambda的内部修改其状态，则应该把它声明为mutable。当然，此时对应的operator()()就不能声明为const了。</li>
<li>我们把由lambda生成的类的对象称为闭包对象(closure object,或者简称为闭包)</li>
</ul>
<h3 id="11-4-3-捕获"><a href="#11-4-3-捕获" class="headerlink" title="11.4.3 捕获"></a>11.4.3 捕获</h3><ul>
<li>lambda的主要用途是封装一部分代码以便于将其用作参数。</li>
</ul>
<h2 id="11-5-显式类型转换"><a href="#11-5-显式类型转换" class="headerlink" title="11.5 显式类型转换"></a>11.5 显式类型转换</h2><ul>
<li>C++提供了多种显式类型转换的操作：<ul>
<li>构造，使用{}符号提供对新值类型安全的构造</li>
<li>命名的转换，提供不同等级的类型转换<ul>
<li>const_cast，对某些声明为const的对象获得写入的权力</li>
<li>static_cast，反转一个定义良好的隐式类型转换</li>
<li>reinterpret_cast，改变位模式的含义</li>
<li>dynamic_cast，动态的检查类层次关系</li>
</ul>
</li>
<li>C风格的转换，提供命名的类型转换或组合。</li>
<li>函数化符号，提供C风格转换的另一种形式。</li>
</ul>
</li>
</ul>
<h2 id="11-6-建议"><a href="#11-6-建议" class="headerlink" title="11.6 建议"></a>11.6 建议</h2><ul>
<li>与后置++运算符相比，建议优先使用前置++运算符</li>
<li>使用资源句柄避免泄露，提前删除和重复删除</li>
<li>除非万不得已，否则不要把对象放在自由存储上；优先使用作用域内的变量</li>
<li>避免使用裸new和裸delete</li>
<li>使用RAII</li>
<li>如果需要对操作添加注释，则应该选用命名的函数对象而非lambda</li>
<li>如果操作具有一定的通用性，则应该选用命名的函数对象而非lambda</li>
<li>lambda应该尽量简短。</li>
<li>处于可维护性和正确性的考虑，通过引用的方式捕获一定要慎之再慎</li>
<li>让编译器推断lambda的返回类型</li>
<li>用T{e}构造值</li>
<li>避免显式类型转换</li>
<li>当不得不使用显式类型转换时，尽量使用命名的转换</li>
<li>对于数字类型之间的转换，考虑使用运行时检查的强制类型转换，例如narrow_cast&lt;&gt;</li>
</ul>
<h1 id="第十二章-函数"><a href="#第十二章-函数" class="headerlink" title="第十二章 函数"></a>第十二章 函数</h1><h2 id="12-1-函数声明"><a href="#12-1-函数声明" class="headerlink" title="12.1 函数声明"></a>12.1 函数声明</h2><ul>
<li>在C++程序中要想做点什么事，最好的办法是调用一个函数来完成它。定义函数的过程就是描述某项操作应该如何执行的过程。我们必须首先声明一个函数，然后才能调用它。</li>
<li>函数声明负责指定函数的名字，返回值的类型以及调用该函数所需要的参数数量和类型。</li>
<li>函数的类型即包括返回类型也包括参数的类型。对于类成员函数来说，类的名字也是函数类型的一部分。</li>
</ul>
<h3 id="12-1-1-为什么使用函数"><a href="#12-1-1-为什么使用函数" class="headerlink" title="12.1.1 为什么使用函数"></a>12.1.1 为什么使用函数</h3><ul>
<li>函数的一项重要作用，即，把一个复杂的运算分解为若干有意义的片段，然后分别为它们命名。</li>
<li>我们希望代码是易于理解的，因为这是实现可维护性的第一步。</li>
<li>关于函数的一条最基本的建议是应该令其规模较小，以便于我们一眼就能知悉该函数的全部内容。对于大多数程序员来说，函数的规模最好控制在大约40行内。</li>
</ul>
<h3 id="12-1-2-函数声明的组成要件"><a href="#12-1-2-函数声明的组成要件" class="headerlink" title="12.1.2 函数声明的组成要件"></a>12.1.2 函数声明的组成要件</h3><ul>
<li>函数声明除了指定函数的名字，一组参数以及函数的返回类型外，还可以包含多种限定符和修饰符。我们将其总结如下<ul>
<li>函数的名字，必选</li>
<li>参数列表，可以为空，必选</li>
<li>返回类型，可以是void，可以是前置或后置形式，必选</li>
<li>inline，表示一种愿望：通过内联函数体实现函数调用</li>
<li>constexpr，表示当给定常量表达式作为实参时，应该可以在编译时对函数求值</li>
<li>noexcept，表示该函数不允许抛出异常</li>
<li>链接说明，例如static</li>
<li>[[noreturn]]，表示函数不会用常规的调用&#x2F;返回机制返回结果</li>
</ul>
</li>
<li>此外，成员函数还能被限定为<ul>
<li>virtual，表示该函数可以被派生类覆盖</li>
<li>override，表示该函数必须覆盖基类中的一个虚函数</li>
<li>final，表示该函数不能被类覆盖</li>
<li>static，表示该函数不与某一特定的对象关联</li>
<li>const，表示该函数不能修改其对象的内容。</li>
</ul>
</li>
<li>函数声明成下面的形式<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">  [[noreturn]] <span class="function"><span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> *<span class="type">const</span>)</span> -&gt; <span class="type">void</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12-1-3-函数定义"><a href="#12-1-3-函数定义" class="headerlink" title="12.1.3 函数定义"></a>12.1.3 函数定义</h3><ul>
<li>如果函数会在程序中调用，那么它必须在某处定义(只定义一次)。函数定义是特殊的函数声明，它给出了函数体的内容</li>
<li>函数的定义以及全部声明必须对应同一类型。不过，为了与C语言兼容，我们会自动忽略参数类型的顶层const。例如，下面两条声明语句对应的是同一个函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;    <span class="comment">// 类型是void(int)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>)</span></span>;  <span class="comment">// 类型是void(int)</span></span><br></pre></td></tr></table></figure></li>
<li>函数的参数名字不属于函数类型的一部分，不同的声明语句中参数的名字无需保持一致。</li>
<li>对于一条非定义的声明语句来说，为参数命名的好处是可以简化代码文档，但是我们不一定非得这么做。相反，我们通常通过不命名某个参数来表示该参数未在函数定义中使用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(table* t, <span class="type">const</span> <span class="type">char</span>* key, <span class="type">const</span> <span class="type">char</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 未用到第三个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一般来说，未命名的参数有助于简化代码并提升代码的可扩展性。此时，尽管某些参数未被使用，但是为其预留位置可以确保函数的调用者不会受到未来函数变动的影响。</li>
<li>除了函数以外，我们还能调用其他一些东西，它们遵循函数的大多数规则<ul>
<li>构造函数，constructor，严格来说不是函数，因为它没有返回值，可以初始化基类和成员，我们无法得到其地址</li>
<li>析构函数，destructor，不能被重载，我们无法得到其地址</li>
<li>函数对象，function object，不是函数，不能被重载，但是其operator()是函数</li>
<li>lambda表达式，lambda expression，是定义函数对象的一种简写形式。</li>
</ul>
</li>
</ul>
<h3 id="12-1-4-返回值"><a href="#12-1-4-返回值" class="headerlink" title="12.1.4 返回值"></a>12.1.4 返回值</h3><ul>
<li><p>每个函数声明都包含函数的返回类型，除了构造函数和类型转换函数。</p>
</li>
<li><p>传统上，在C和C++中，返回类型位于函数声明语句一开始的地方。然而，我们也可以在函数声明中把返回类型写在参数列表之后。例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">int</span> a)</span></span>; <span class="comment">// 前置返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">to_string</span><span class="params">(<span class="type">int</span> a)</span> -&gt; std::string</span>; <span class="comment">// 后置返回类型</span></span><br></pre></td></tr></table></figure></li>
<li><p>也就是说，前置的auto关键字表示函数的返回类型放在参数列表之后。后置返回类型由符号 -&gt; 引导</p>
</li>
<li><p>后置返回类型的必要性源于函数模板声明，因为其返回类型是依赖于参数的。例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">product</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; x, <span class="type">const</span> std::vector&lt;U&gt;&amp; y)</span> -&gt; <span class="title">decltype</span><span class="params">(x * y)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果函数调用了它自身，我们称之递归(recursive)</p>
</li>
<li><p>函数可以包含多条return语句</p>
</li>
<li><p>与参数传递的语义类似，函数返回值的语义也与拷贝初始化的语义一致。return语句初始化一个返回类型的变量。编译器检查返回表达式的类型是否与函数的返回类型吻合，并在必要时执行标准的或者用户自定义的类型转换。</p>
</li>
</ul>
<h3 id="12-1-7-noreturn-函数"><a href="#12-1-7-noreturn-函数" class="headerlink" title="12.1.7 [[noreturn]]函数"></a>12.1.7 [[noreturn]]函数</h3><ul>
<li>形如[[…]]的概念被称为属性(attribute)，属性可以置于C++语法的任何位置。通常情况下，属性描述了位于他前面的语法实体的性质，这些性质依赖于实现。</li>
<li>此外，属性也能出现在声明语句开始的位置。C++只包含两个标准属性，[[noreturn]]和[[carries_dependency]]</li>
<li>把[[noreturn]]放在函数声明语句的开始位置表示我们不希望该函数返回任何结果</li>
</ul>
<h3 id="12-1-8-局部变量"><a href="#12-1-8-局部变量" class="headerlink" title="12.1.8 局部变量"></a>12.1.8 局部变量</h3><ul>
<li>定义在函数内部的名字通常称为局部名字(local name)。当线程执行到局部变量或者常量的定义出时，它们将被初始化。除非我们把变量声明为static，否则函数的每次调用都会拥有该变量的一份拷贝。</li>
<li>相反，如果我们把局部变量声明为static，则在函数的所有调用中都将使用唯一的一份静态分配的对象，该对象在线程第一次到达它的定义处时被初始化。</li>
<li><strong>static局部变量有一个非常重要的作用，即，它可以在函数的多次调用间维护一份公共信息而无须使用全局变量。</strong>如果使用了全局变量，则有可能会被其他不相干的函数访问甚至干扰。</li>
<li>除非你进入了一个递归调用的函数或者发生了死锁，通常情况下，static局部变量的初始化不会导致数据竞争。也就是说，C++实现必须用某种无锁机制确保局部static变量的初始化被正确执行。递归的初始化一个局部static变量将产生未定义的结果。</li>
<li>static局部变量有助于避免非局部变量间的顺序依赖。</li>
</ul>
<h2 id="12-2-参数传递"><a href="#12-2-参数传递" class="headerlink" title="12.2 参数传递"></a>12.2 参数传递</h2><ul>
<li>当程序调用一个函数时(使用后缀()，称为调用运算符 call operator或者应用运算符 application operator)，我们为该函数的形参(formal arguments, 即 parameters)申请内存空间，并用实参(actual argument)初始化对应的形参。参数传递的语义与初始化的语义一致(严格地说是拷贝初始化)。</li>
<li>编译器负责检查实参的类型是否与对应的形参类型吻合，并在非必要的时候执行标准类型转换或用户自定义的类型转换。除非形参是引用，其他情况下传入函数的是实参的副本。</li>
</ul>
<h3 id="12-2-1-引用参数"><a href="#12-2-1-引用参数" class="headerlink" title="12.2.1 引用参数"></a>12.2.1 引用参数</h3><ul>
<li>引用传递的准确描述应该是左值引用传递，原因是函数不能接受一个右值引用作为它的参数</li>
<li>该如何选择参数的传递方式？<ul>
<li>对于小对象使用值传递的方式</li>
<li>对于你无需修改的大对象使用const引用传递</li>
<li>如果需要返回计算结果，最好使用return而非通过参数修改对象</li>
<li>使用右值引用实现移动和转发</li>
<li>如果找不到合适的对象，则传递指针</li>
<li>除非万不得已，否则不要使用引用传递</li>
</ul>
</li>
<li>在最后一条经验追责中，除非万不得已 是基于： 当我们需要修改对象的值时，传递指针比使用引用更容易表达清楚程序的原意</li>
</ul>
<h3 id="12-2-2-数组参数"><a href="#12-2-2-数组参数" class="headerlink" title="12.2.2 数组参数"></a>12.2.2 数组参数</h3><ul>
<li>当数组作为函数的参数时，实际传入的是指向该数组首元素的指针</li>
<li>数组类型的参数与指针类型的参数等价。</li>
</ul>
<h3 id="12-2-3-列表参数"><a href="#12-2-3-列表参数" class="headerlink" title="12.2.3 列表参数"></a>12.2.3 列表参数</h3><ul>
<li>一个由{}限定的列表可以作为下述形参的实参<ul>
<li>类型std::initializer_list<T>，其中列表的值能隐式的转换成T</li>
<li>能用列表中的值初始化的类型</li>
<li>T类型数组的引用，其中列表的值能隐式的转换成T</li>
</ul>
</li>
</ul>
<h3 id="12-2-4-数量未定的参数"><a href="#12-2-4-数量未定的参数" class="headerlink" title="12.2.4 数量未定的参数"></a>12.2.4 数量未定的参数</h3><ul>
<li>对于某些函数来说，很难明确指定调用时期望的参数数量和类型。要实现这样的接口，我们有三种选择<ul>
<li>使用可变模板：它允许我们以类型安全的方式处理任意类型，任意数量的参数。只要写一个小的模板元程序来解释参数列表的正确含义并采取适当的操作就可以了</li>
<li>使用initializer_list作为参数类型。它允许我们以类型安全的方式处理某种类型的，任意数量的参数，在大多数上下文中，这种元素类型相同的参数列表是最常见和最重要的情形</li>
<li>用省略号(…)结束参数列表，表示可能有更多的参数。它允许我们通过使用<cstdarg>中的宏处理任意类型的，任意数量的参数。这种方案并非类型安全的，并且很难用于复杂的用户自定义类型。</li>
</ul>
</li>
</ul>
<h3 id="12-2-5-默认参数"><a href="#12-2-5-默认参数" class="headerlink" title="12.2.5 默认参数"></a>12.2.5 默认参数</h3><ul>
<li>一个通用的函数所需的参数通常比处理简单情况所需的参数要多。</li>
<li>默认参数在函数声明时执行类型检查，在调用函数时求值。</li>
<li>在同一个作用域的一系列声明语句中，默认参数不能重复或者改变。</li>
</ul>
<h2 id="12-3-重载函数"><a href="#12-3-重载函数" class="headerlink" title="12.3 重载函数"></a>12.3 重载函数</h2><ul>
<li>大多数情况下我们应该给不同的函数起不一样的名字。但如果不同函数是在不同类型的对象上执行相同概念的任务，则给他们起同一个名字是更好的选择。为不同数据类型的同一种操作起相同的名字称为重载(overloading)</li>
<li>对于编译器来说，同名函数唯一的共同点就是名字相同。</li>
<li>模板为定义成组的重载函数提供了一种系统的方法</li>
</ul>
<h3 id="12-3-1-自动重载解析"><a href="#12-3-1-自动重载解析" class="headerlink" title="12.3.1 自动重载解析"></a>12.3.1 自动重载解析</h3><ul>
<li>重载解析与函数声明的次序无关</li>
</ul>
<h3 id="12-3-2-重载与返回类型"><a href="#12-3-2-重载与返回类型" class="headerlink" title="12.3.2 重载与返回类型"></a>12.3.2 重载与返回类型</h3><ul>
<li>在重载解析过程中不考虑函数的返回类型，这样可以确保对运算符或者函数调用的解析独立于上下文</li>
</ul>
<h3 id="12-3-3-重载与作用域"><a href="#12-3-3-重载与作用域" class="headerlink" title="12.3.3 重载与作用域"></a>12.3.3 重载与作用域</h3><ul>
<li>重载发生在一组重载函数集的成员内部，也就是说，重载函数应该位于同一个作用域内。不同的非名字空间作用域中的函数不会重载。</li>
<li>基类和派生类提供的作用域不同，因此默认情况下基类函数和派生类函数不会发生重载</li>
<li>如果我们希望实现跨类作用域或者名字空间作用域的重载，应该使用using声明或者using指示。</li>
</ul>
<h2 id="12-4-前置与后置条件"><a href="#12-4-前置与后置条件" class="headerlink" title="12.4 前置与后置条件"></a>12.4 前置与后置条件</h2><ul>
<li>我们把函数调用时应该遵循的约定称为前置条件(precondition)，把函数返回时应该遵循的约定称为后置条件(postcondition)</li>
</ul>
<h2 id="12-5-函数指针"><a href="#12-5-函数指针" class="headerlink" title="12.5 函数指针"></a>12.5 函数指针</h2><ul>
<li>与数据对象类似，由函数体生成的代码也置于某块内存区域中，因此它也有自己的地址。</li>
<li>出于某些考虑，有的与机器体系结构有关，有的与系统设计有关，我们不允许函数指针修改所指的代码。</li>
<li>程序员只能对函数做两种操作：调用它或者获取它的地址。通过获取函数地址得到的指针能被用来调用该函数。</li>
<li>对于直接调用函数和通过指针调用函数这两种情况来说，参数传递的规则是一样的。</li>
<li>函数指针为算法的参数化提供了一种途径。</li>
</ul>
<h2 id="12-6-宏"><a href="#12-6-宏" class="headerlink" title="12.6 宏"></a>12.6 宏</h2><ul>
<li>宏在C语言中非常重要，但在C++中的作用就小得多了。关于宏的最重要的原则是：除非万不得已，否则不要使用宏。</li>
</ul>
<h3 id="12-6-1-条件编译"><a href="#12-6-1-条件编译" class="headerlink" title="12.6.1 条件编译"></a>12.6.1 条件编译</h3><h3 id="12-6-2-预定义宏"><a href="#12-6-2-预定义宏" class="headerlink" title="12.6.2 预定义宏"></a>12.6.2 预定义宏</h3><ul>
<li>编译器预定义了一些宏<ul>
<li>__cplusplus: 在C++编译器中有定义(C语言编译器没有)。在C++11程序中它的值是201103L</li>
<li><strong>DATA</strong>: “yyyy:mm:dd”格式的日期。</li>
<li><strong>TIME</strong>: “hh:mm:ss”格式的时间</li>
<li><strong>FILE</strong>: 当前源文件的名字</li>
<li><strong>LINE</strong>: 当前源代码的代码行数</li>
<li><strong>FUNC</strong>: 是一个由具体实现定义的C风格字符串，表示当前函数的名字</li>
<li><strong>STDC_HOSTED</strong>: 如果当前实现是宿主式的，则为1；否则为0</li>
<li><strong>STDC</strong>: 在C语言编译器中有定义(C++编译器中没有)</li>
</ul>
</li>
</ul>
<h3 id="12-6-3-编译指令"><a href="#12-6-3-编译指令" class="headerlink" title="12.6.3 编译指令"></a>12.6.3 编译指令</h3><ul>
<li>如果可能，尽量避免使用#pragma</li>
</ul>
<h2 id="12-7-建议"><a href="#12-7-建议" class="headerlink" title="12.7 建议"></a>12.7 建议</h2><ul>
<li>把有用的操作打包在一起构成函数，然后认真起个名字</li>
<li>一个函数应该对应逻辑上的一个操作</li>
<li>让函数尽量短</li>
<li>不要返回指向局部变量的指针或者引用</li>
<li>如果函数必须在编译时求值，把他声明成constexpr</li>
<li>如果函数无法返回结果，把他设置为 [[noreturn]]</li>
<li>对小对象使用传值的方式</li>
<li>如果你想传递无需修改的大值，使用传const引用的方式</li>
<li>尽量通过return值返回结果，不要通过参数修改对象</li>
<li>用右值引用实现移动和转发</li>
<li>如果找不到合适的对象，可以传入指针</li>
<li>除非万不得已，否则不要传递非const引用</li>
<li>const的用处广泛，程序元应该多用</li>
<li>我们认为char<em>或者const char</em>参数指向的是C风格字符串</li>
<li>避免把数组当成指针传递</li>
<li>用initializer_list<T>传递元素类型相同但是元素数量未知的列表</li>
<li>避免使用数量未知的参数(…)</li>
<li>当几个函数完成的功能在概念上一致，仅仅是处理的类型有区别时，使用重载。</li>
<li>在整数类型上重载时，提供一些函数以消除二义性</li>
<li>为你的函数指定前置条件和后置条件</li>
<li>与函数指针相比，优先使用函数对象和虚函数</li>
<li>不要使用宏</li>
<li>如果必须使用宏，一定要用很多大写字母组成宏的名字，尽管这样的名字看起来会很丑陋</li>
</ul>
<h1 id="第十三章-异常处理"><a href="#第十三章-异常处理" class="headerlink" title="第十三章 异常处理"></a>第十三章 异常处理</h1><h2 id="13-1-错误处理"><a href="#13-1-错误处理" class="headerlink" title="13.1 错误处理"></a>13.1 错误处理</h2><ul>
<li>本章介绍如何用异常进行错误处理。我们必须基于一定的策略综合运用各项语言机制才能高效的处理错误。</li>
<li>本章的内容主要分为两个部分<ul>
<li>一是异常安全保障(exception-safety guarantee)，它是程序从运行时错误中快速恢复的关键；</li>
<li>另一个是使用构造函数和析构函数进行资源管理的资源获取即初始化(Resource Acquisition Is Initialization, RAII)技术。</li>
</ul>
</li>
<li>因为异常安全保障和资源获取即初始化都依赖于不变式的规范，所以本章也会介绍一些关于强制断言的内容。</li>
</ul>
<h3 id="13-1-1-异常"><a href="#13-1-1-异常" class="headerlink" title="13.1.1 异常"></a>13.1.1 异常</h3><ul>
<li>异常(exception)的概念可以帮助我们将信息从检测到错误的地方传递到处理该错误的地方。如果函数无法处理某个问题，则抛出异常，并且寄希望于函数的调用者能直接或者间接的处理该问题。函数如果希望处理某个问题，可以捕获(catch)相应的异常。<ul>
<li>主调组件如果想处理某些失败的情形，可以把这些异常置于try块的catch从句中</li>
<li>被调组件如果无法完成既定的任务，可以用throw表达式抛出一个异常来说明这一情况。</li>
</ul>
</li>
</ul>
<h3 id="13-1-2-传统的错误处理"><a href="#13-1-2-传统的错误处理" class="headerlink" title="13.1.2 传统的错误处理"></a>13.1.2 传统的错误处理</h3><ul>
<li>当函数检测到某个无法局部处理的问题并且必须向函数的调用者报告时，除了使用异常机制处理该错误，其他几种传统的处理方式都有各自的不足<ul>
<li>终止程序，这是一种非常极端的处理方式</li>
<li>返回错误值。</li>
<li>返回合法值，而程序却处于错误状态。问题是主调函数可能没有意识到程序已经处于错误状态了。例如，许多标准C语言库函数设置一个非局部变量error来表示错误。在应用并发机制时，用非局部变量记录错误状态的做法不太奏效</li>
<li>调用错误处理函数。</li>
</ul>
</li>
</ul>
<h3 id="13-1-3-渐进决策"><a href="#13-1-3-渐进决策" class="headerlink" title="13.1.3 渐进决策"></a>13.1.3 渐进决策</h3><ul>
<li>在异常处理模式中，对于未处理的错误(未捕获的异常)的最终响应是终止程序。</li>
</ul>
<h3 id="13-1-4-另一种视角看异常"><a href="#13-1-4-另一种视角看异常" class="headerlink" title="13.1.4 另一种视角看异常"></a>13.1.4 另一种视角看异常</h3><ul>
<li>C++的异常处理机制主要用于处理那些无法在局部范围内解决的问题。</li>
</ul>
<h2 id="13-7-建议"><a href="#13-7-建议" class="headerlink" title="13.7 建议"></a>13.7 建议</h2><ul>
<li>在设计初期尽早确定异常处理策略</li>
<li>当无法完成既定任务时抛出异常</li>
<li>用异常机制处理错误</li>
<li>不要试图捕获每个函数的每个异常</li>
<li>抛出异常前先释放局部资源</li>
<li>尽量减少使用try块</li>
<li>不要让析构函数抛出异常</li>
<li>把普通代码和异常处理代码分离开来</li>
</ul>
<h1 id="第十四章-名字空间"><a href="#第十四章-名字空间" class="headerlink" title="第十四章 名字空间"></a>第十四章 名字空间</h1><h2 id="14-1-组合问题"><a href="#14-1-组合问题" class="headerlink" title="14.1 组合问题"></a>14.1 组合问题</h2><ul>
<li>任何实际问题都是由若干独立部分组成的。函数和类提供了相对细粒度的关注点分离，而库，源文件和编译单元则提供了粗粒度的分离。</li>
<li>逻辑上最理想的方式是模块化，即独立的事物保持分离，只允许通过良好定义的接口访问模块。</li>
<li>C++并不是通过单一语言特性来支持模块的概念，也并不存在模块这种语法构造。取而代之，C++通过其他语言特性(函数，类和名字空间)的组合和源码的组织来表达模块化。</li>
</ul>
<h2 id="14-2-名字空间"><a href="#14-2-名字空间" class="headerlink" title="14.2 名字空间"></a>14.2 名字空间</h2><ul>
<li>名字空间(namespace)的概念用来直接表示本属一体的一组特性，例如库代码。</li>
<li>一个名字空间应该表达某种逻辑结构：一个名字空间中的声明应该一起提供一些特性，使得用户看来它们是一个整体，而且能反应一组共同的设计策略。</li>
<li>实际上，在一个名字空间中声明的实体是作为名字空间的成员被引用的。</li>
<li>从名字空间外引用成员的其他方法包括using声明，using指示和参数依赖查找。</li>
</ul>
<h3 id="14-2-1-显式限定"><a href="#14-2-1-显式限定" class="headerlink" title="14.2.1 显式限定"></a>14.2.1 显式限定</h3><ul>
<li>我们可以在名字空间的定义中声明一个成员，稍后用 名字空间名::成员名 的语法定义它</li>
<li>一个名字空间形成一个作用域，通常的作用域规则也适用于名字空间。因此，名字空间是一个非常基础，非常简单的概念。程序规模越大，用名字空间表达程序的逻辑划分就越有用。全局作用域也是一个名字空间，可以显式的用 :: 来引用。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;  <span class="comment">// 全局函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> f;  <span class="comment">// 局部变量：屏蔽了全局函数</span></span><br><span class="line">  <span class="built_in">f</span>();  <span class="comment">// 错误：不能调用一个整型变量</span></span><br><span class="line">  ::<span class="built_in">f</span>();  <span class="comment">// 正确：调用全局函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类也是名字空间</li>
</ul>
<h3 id="14-2-2-using声明"><a href="#14-2-2-using声明" class="headerlink" title="14.2.2 using声明"></a>14.2.2 using声明</h3><ul>
<li>using声明将一个代用名引入了作用域，最好尽量保持代用名的局部性以避免混淆</li>
<li>当用于一个重载的名字时，using声明会应用于其所有重载版本。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> N&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(string)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> N::f;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">789</span>);   <span class="comment">// N::f(int)</span></span><br><span class="line">  <span class="built_in">f</span>(<span class="string">&quot;Bruce&quot;</span>)  <span class="comment">// N::f(string)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="14-2-3-using指示"><a href="#14-2-3-using指示" class="headerlink" title="14.2.3 using指示"></a>14.2.3 using指示</h3><ul>
<li>在一个函数中，可以安全的使用using指示以方便符号表示，但是对全局using指示必须小心谨慎，因为过度使用using指示会导致名字冲突，而避免名字冲突恰恰是引入名字空间的目的。</li>
</ul>
<h3 id="14-2-5-名字空间是开放的"><a href="#14-2-5-名字空间是开放的" class="headerlink" title="14.2.5 名字空间是开放的"></a>14.2.5 名字空间是开放的</h3><ul>
<li>名字空间是开放的：即，你可以从多个分离的名字空间声明中向一个名字空间添加名字。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A </span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这样，名字空间的成员就不需要连续放置在单一的文件中。</li>
</ul>
<h2 id="14-5-建议"><a href="#14-5-建议" class="headerlink" title="14.5 建议"></a>14.5 建议</h2><ul>
<li>用名字空间表达逻辑结构</li>
<li>将除main()之外的所有非局部名字都置于名字空间中</li>
<li>设计一个名字空间，以便能方便的使用它避免意外访问到不相关的名字空间</li>
<li>不要为名字空间起非常短的名字</li>
<li>如必要，使用名字空间别名为长名字空间提供简写</li>
<li>不要给你的名字空间的使用者增加太多符号表示上的负担</li>
<li>为接口和实现使用分离的名字空间</li>
<li>当定义名字空间成员时使用 Namespace::member 表示方式</li>
<li>用inline名字空间支持版本控制</li>
<li>将using指示用于代码转换，用于基础库以及用于局部作用域</li>
<li>不要将using指示放在头文件中。</li>
</ul>
<h1 id="第十五章"><a href="#第十五章" class="headerlink" title="第十五章"></a>第十五章</h1><h2 id="15-1-分离编译"><a href="#15-1-分离编译" class="headerlink" title="15.1 分离编译"></a>15.1 分离编译</h2><ul>
<li>任何实际程序都由很多逻辑上分离的部分组成。为了更好的管理这些组成部分，我们可以将程序表示为一组源码文件，其中每个文件包含一个或多个逻辑组件。</li>
<li>我们的任务是为程序设计一个文件集合，使得能以一种一致，易理解和灵活的方式表示这些逻辑组件。特别是，我们以接口(例如函数声明)与实现(例如函数定义)的完全分离为目标。</li>
<li>当用户将一个源文件(source file)提交给编译器后，首先对文件进行预处理，即，处理宏以及将#include指令指定的头文件包含进来。预处理的结果称为编译单元(translation unit)。编译单元是编译器真正处理的内容，也是C++语言规则所描述的内容。 </li>
<li>链接器是将分离编译的多个部分绑定在一起的程序。编译器有时也被称为加载器(loader)。链接可以在程序开始运行前全部完成，但也可以在程序运行中将新代码添加进来–动态链接。</li>
<li>程序的源文件组织通常称为其物理结构(physical structure)。程序的逻辑结构和物理结构不必相同。</li>
</ul>
<h2 id="15-2-链接"><a href="#15-2-链接" class="headerlink" title="15.2 链接"></a>15.2 链接</h2><ul>
<li>除非已显式声明为局部名字，否则函数名，类名，模板名，变量名，名字空间名，枚举名以及枚举值名的使用必须跨所有编译单元保持一致。</li>
<li>程序员必须保证每个名字空间，类，函数等必须在其出现的每个编译单元中都正确声明，且对应相同实体的声明都是一致的。</li>
<li>对象在程序中只能定义一次，它可以声明很多次，但类型必须完全一致。</li>
<li>如果全局作用域中或名字空间中的变量定义不带初始值，则该变量会使用默认初始值。非static局部变量或创建在自由存储上的对象则不会使用默认初始值。</li>
<li>在类体外，实体必须先声明后使用。</li>
<li>如果一个名字在其定义处之外的编译单元中也可以使用，我们称其具有外部链接(external linkage)。</li>
<li>如果一个名字只能在其定义所在的编译单元中被引用，我们称其具有内部链接(internal linkage)</li>
<li>在名字空间作用域，包括全局作用域中使用关键字static表示 不能再其他源文件中访问，即内部链接。</li>
<li>关键字const按时默认内部链接。</li>
<li>链接器看不到的名字，例如局部变量名，被称为无链接。</li>
<li>默认情况下，名字空间中的const对象，constexpr对象，类型别名以及任何声明为static的实体都具有内部链接。</li>
<li>为确保一致性，应该将别名，const对象，constexpr对象和inline函数放置在头文件中</li>
<li>我们可以通过显式声明为一个const对象赋予外部链接。</li>
</ul>
<h3 id="15-2-1-文件内名字"><a href="#15-2-1-文件内名字" class="headerlink" title="15.2.1 文件内名字"></a>15.2.1 文件内名字</h3><ul>
<li>我们一般最好避免使用全局变量，因为这会引起维护问题。将变量放在名字空间中会有些帮助，但仍可能引起数据竞争</li>
<li>如果必须使用全局变量，至少应限制它们只在单一源文件中使用，有两种方法实现这种限制<ul>
<li>将声明放在无名名字空间中</li>
<li>声明实体时使用static</li>
</ul>
</li>
<li>使用无名名字空间可以令名字成为编译单元的局部名字。无名名字空间的效果非常像内部链接。</li>
</ul>
<h3 id="15-2-2-头文件"><a href="#15-2-2-头文件" class="headerlink" title="15.2.2 头文件"></a>15.2.2 头文件</h3><ul>
<li>同一个对象，函数，类等所有声明都要保持类型一致。因此，提交给编译器并随后链接在一起的源码必须保持一致。实现不同编译单元声明一致性的一种不完美但是很简单的方法是：在包含可执行代码或数据定义的源文件中 #include 包含接口信息的头文件</li>
<li>#include 机制是一种文本处理方式–将源程序片段收集起来形成单一的编译单元(文件)</li>
<li>建议将简单常量定义放在头文件中，但不将集合定义放在头文件中，其原因是C++实现很难避免多个编译单元中重复的集合定义。</li>
<li>使用 #include 时过分卖弄聪明是不明智的。我的建议是<ul>
<li>只 #include 头文件。不要#include包含变量定义和非inline函数的普通源码</li>
<li>只 #include 完整的声明和定义</li>
<li>只在全局作用域，链接说明块及名字空间定义中 #include 头文件</li>
<li>将所有#include放在其他代码之前，以尽量减少无意造成的依赖关系</li>
<li>避免使用宏技巧</li>
<li>尽量减少在头文件中使用非局部的名字</li>
</ul>
</li>
</ul>
<h3 id="15-2-3-单一定义规则"><a href="#15-2-3-单一定义规则" class="headerlink" title="15.2.3 单一定义规则"></a>15.2.3 单一定义规则</h3><ul>
<li>每个给定类，枚举和模板等在程序中只能定义一次</li>
</ul>
<h3 id="15-2-4-标准库头文件"><a href="#15-2-4-标准库头文件" class="headerlink" title="15.2.4 标准库头文件"></a>15.2.4 标准库头文件</h3><ul>
<li>标准库特性是通过一组标准库头文件提供的。</li>
</ul>
<h3 id="15-2-5-链接非C-代码"><a href="#15-2-5-链接非C-代码" class="headerlink" title="15.2.5 链接非C++代码"></a>15.2.5 链接非C++代码</h3><ul>
<li>因为C和C++关系紧密，extern “C” 指示特别有用。需要注意的是，extern “C”中的C表示的是链接规范而非语言。extern “C” 通常用于将函数链接到恰好符合C实现规范的Fortran和汇编程序。</li>
</ul>
<h2 id="15-4-程序"><a href="#15-4-程序" class="headerlink" title="15.4 程序"></a>15.4 程序</h2><ul>
<li>一组分离编译的单元经由链接器组合就形成了程序。其中用到的每个函数，对象，类型等都必须是唯一定义的。一个程序必须恰好包含一个名为main()的函数。通过调用全局函数main()开始执行程序的主要计算任务，从main()返回后程序就终止了。main()的返回类型是int，所有C++实现都支持下面两个版本的main():<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>main()返回的int作为程序执行的结果被传递给调用main()的系统，非零返回值表示发生了一个错误。</li>
</ul>
<h3 id="15-4-1-非局部变量初始化"><a href="#15-4-1-非局部变量初始化" class="headerlink" title="15.4.1 非局部变量初始化"></a>15.4.1 非局部变量初始化</h3><ul>
<li>原则上，定义在任何函数之外的变量(即，全局变量，名字空间变量以及类static变量)在main()被调用前初始化。</li>
</ul>
<h3 id="15-4-3-程序终止"><a href="#15-4-3-程序终止" class="headerlink" title="15.4.3 程序终止"></a>15.4.3 程序终止</h3><ul>
<li>程序终止的方式有很多种<ul>
<li>从main()返回</li>
<li>调用exit()</li>
<li>调用abort()</li>
<li>抛出一个未捕获的异常</li>
<li>违反noexcept</li>
<li>调用quick_exit()</li>
</ul>
</li>
<li>如果使用标准库函数exit()终止一个程序，则会调用已构造的静态对象的析构函数。但是，如果程序是使用标准库函数abort()终止的，析构函数就不会被调用。</li>
<li>注意，这意味着exit()不会立即终止程序。在一个析构函数中调用exit()会导致无限递归。</li>
<li>函数exit(),abort(),quick_exit(),atexit(),at_quick_exit()都是在<cstdlib>中声明的。</li>
</ul>
<h2 id="15-5-建议"><a href="#15-5-建议" class="headerlink" title="15.5 建议"></a>15.5 建议</h2><ul>
<li>用头文件表达接口，强调逻辑结构</li>
<li>在实现函数的源文件中 #include 声明函数的头文件</li>
<li>不要在不同编译单元中定义同名但含义相近却不完全一致的全局实体</li>
<li>不要再头文件中定义非内联函数</li>
<li>只在全局作用域和名字空间中使用 #include</li>
<li>只 #include 完整的声明</li>
<li>使用包含保护</li>
<li>在名字空间中 #include C头文件以避免全局名字</li>
<li>令头文件自包含</li>
<li>区分用户接口和实现者接口</li>
<li>区分一般用户接口和专家用户接口</li>
<li>若代码是用作非C++程序的一部分，则应避免需要运行时初始化的非局部对象。</li>
</ul>
<h1 id="第三部分-抽象机制"><a href="#第三部分-抽象机制" class="headerlink" title="第三部分 抽象机制"></a>第三部分 抽象机制</h1><ul>
<li>这一部分介绍定义和使用新类型的C++特性，主要介绍通常称为面向对象程序设计和泛型程序设计的技术。</li>
</ul>
<h1 id="第十六章-类"><a href="#第十六章-类" class="headerlink" title="第十六章 类"></a>第十六章 类</h1><h2 id="16-1-引言"><a href="#16-1-引言" class="headerlink" title="16.1 引言"></a>16.1 引言</h2><ul>
<li>C++类是创建新类型的工具，创建出的新类型可以像内置类型一样方便的使用。而且，派生类和模板允许程序员表达类之间的关系并利用这种关系。</li>
<li><strong>一个类型就是一个概念，一个思想，一个观念等等的具体表示</strong>。</li>
<li>类是用户自定义类型。如果一个概念没有与之直接对应的内置类型，我们就定义一个新类型来表示它。  </li>
<li>定义新类型的基本思想是将实现的细节与正确使用它的必要属性分离。这种分离的最佳表达方式是：通过一个专用接口引导数据结构及其内部辅助例程的使用。</li>
</ul>
<h2 id="16-2-类基础"><a href="#16-2-类基础" class="headerlink" title="16.2 类基础"></a>16.2 类基础</h2><ul>
<li>下面是类的简要概括<ul>
<li>一个类就是一个用户自定义类型</li>
<li>一个类由一组成员构成。最常见的成员类别是数据成员和成员函数</li>
<li>成员函数可定义初始化，拷贝，移动和清理等语义</li>
<li>对对象使用 . 访问成员，对指针使用 -&gt; 访问成员</li>
<li>可以为类定义运算符</li>
<li>一个类就是一个包含其成员的名字空间</li>
<li>public成员提供类的接口，private成员提供实现细节</li>
<li>struct是成员默认为public的class</li>
</ul>
</li>
</ul>
<h3 id="16-2-1-成员函数"><a href="#16-2-1-成员函数" class="headerlink" title="16.2.1 成员函数"></a>16.2.1 成员函数</h3><ul>
<li>声明于类定义内的函数称为成员函数(member function)，对恰当类型的特定变量使用结构成员访问语法才能调用这种函数。</li>
<li>由于不同结构可能有同名成员函数,在定义成员函数时必须指定结构名</li>
<li>在成员函数中,不必显式引用对象即可使用成员的名字.在此情况下,名字所引用的是调用函数的对象的成员.</li>
</ul>
<h3 id="16-2-2-默认拷贝"><a href="#16-2-2-默认拷贝" class="headerlink" title="16.2.2 默认拷贝"></a>16.2.2 默认拷贝</h3><ul>
<li>默认情况下,对象是可拷贝的.特别是,一个类对象可以用同类的另一个对象的副本来进行初始化.例如:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Data d1 = my_birthday;</span><br><span class="line">Date d2&#123;my_birthday&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>默认情况下,一个类对象的副本是对每个成员逐个拷贝得到的</strong>.</li>
<li>类似的,类对象默认也可以通过赋值操作拷贝.</li>
<li>再重复一边,默认的拷贝语义是逐成员复制的.如果对于类这不是正确的选择,用户可以定义一个恰当的赋值运算符</li>
</ul>
<h3 id="16-2-3-访问控制"><a href="#16-2-3-访问控制" class="headerlink" title="16.2.3 访问控制"></a>16.2.3 访问控制</h3><ul>
<li>标签public将类的主体分为两部分.<ul>
<li>第一部分中的名字是私有的(private),它们只能被成员函数使用.</li>
<li>第二部分是公有的(public),构成类对象的公共接口.</li>
</ul>
</li>
<li>struct就是一个成员默认为公有的class,成员函数的声明和使用是一样的.</li>
<li>但是,非成员函数禁止使用私有成员.</li>
</ul>
<h3 id="16-2-4-class和struct"><a href="#16-2-4-class和struct" class="headerlink" title="16.2.4 class和struct"></a>16.2.4 class和struct</h3><ul>
<li>下面的语法结构<ul>
<li>class X {…};</li>
</ul>
</li>
<li>称为类定义(class definition),它定义了一个名为X的类型.由于历史原因,类定义常常被称为类声明.</li>
<li>如果我认为一个类是简单数据结构,更喜欢使用struct.</li>
<li>如果我认为一个类是 具有不变式的真正类型,会使用class.</li>
<li>C++并不要求在类定义中首先声明数据.实际上,将数据成员放在最后以强调提供公共用户接口的函数(位置在前)通常是很有意义的.例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date3</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date3</span>(<span class="type">int</span> dd, <span class="type">int</span> mm, <span class="type">int</span> yy);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_year</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> d, m, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="16-2-5-构造函数"><a href="#16-2-5-构造函数" class="headerlink" title="16.2.5 构造函数"></a>16.2.5 构造函数</h3><ul>
<li>构造函数的本质是构造一个给定类型的值.构造函数的显著特征是与类具有相同的名字.</li>
<li>如果一个类有一个构造函数,其所有对象都会通过调用构造函数完成初始化.如果构造函数需要参数,在初始化时就要提供这些参数.</li>
<li><strong>由于构造函数定义了类的初始化方式,因此我们可以使用{}初始化记法</strong></li>
<li>我建议优先使用{}记法而不是(),因为前者明确表明了要做什么(初始化),从而避免了某些潜在错误.而且可以一致的使用.</li>
<li>通过提供多个构造函数,可以为某类型的对象提供多种不同的初始化方法.</li>
<li>构造函数的重载规则与普通函数相同.只要构造函数的参数类型明显不同,编译器就能选择正确的版本使用.</li>
<li>注意,通过确保对象的正确初始化,构造函数极大的简化了成员函数的实现.有了构造函数,其他成员函数就不再需要处理未初始化数据的情况.</li>
</ul>
<h3 id="16-2-6-explicit构造函数"><a href="#16-2-6-explicit构造函数" class="headerlink" title="16.2.6 explicit构造函数"></a>16.2.6 explicit构造函数</h3><ul>
<li>默认情况下,用单一参数调用一个构造函数,其行为类似于从参数类型到类自身类型的转换.</li>
<li>我们可以指定构造函数不能用作隐式类型转换.如果构造函数的声明带有关键字explicit,则它只能用于初始化和显示类型转换.</li>
<li>用&#x3D;进行初始化可看作拷贝初始化(copy initialization).一般来说,初始化器的副本会被放入待初始化的对象.</li>
<li>省略&#x3D;会将初始化变为显式初始化.显式初始化也称为直接初始化(direct initialization)</li>
<li>默认情况下,应该将单参数的构造函数声明为explicit.</li>
<li>如果一个构造函数声明为explicit且定义在类外,则在定义中不能重复explicit<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> d, m, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Date</span><span class="params">(<span class="type">int</span> dd)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Date::<span class="built_in">Date</span>(<span class="type">int</span> dd) &#123;...&#125;  <span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Date</span><span class="params">(<span class="type">int</span> dd)</span> </span>&#123;...&#125; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li>
<li>大多数explicit起很重要作用的构造函数都接受单一参数.但是,explicit也可用于无参或多个参数的构造函数.</li>
<li>列表初始化也存在直接初始化和拷贝初始化的区别.</li>
</ul>
<h3 id="16-2-7-类内初始化器"><a href="#16-2-7-类内初始化器" class="headerlink" title="16.2.7 类内初始化器"></a>16.2.7 类内初始化器</h3><ul>
<li>当使用多个构造函数时，成员初始化可以是重复的。</li>
</ul>
<h3 id="16-2-8-类内函数定义"><a href="#16-2-8-类内函数定义" class="headerlink" title="16.2.8 类内函数定义"></a>16.2.8 类内函数定义</h3><ul>
<li>如果一个函数不仅在类中声明，还在类中定义，那么它就被当作内联函数处理，即很少修改且频繁使用的小函数适合类内定义。</li>
<li>类成员可以访问同类的其他成员，而不管成员是在哪里定义的。即函数和数据成员的声明是不依赖于顺序的。</li>
</ul>
<h3 id="16-2-13-成员类型"><a href="#16-2-13-成员类型" class="headerlink" title="16.2.13 成员类型"></a>16.2.13 成员类型</h3><ul>
<li>类型和类型别名也可以作为类的成员。</li>
<li>成员类可以引用其所属类的类型和static成员。当给定所属类的一个对象时，只能引用非static成员。</li>
</ul>
<h2 id="16-3-具体类"><a href="#16-3-具体类" class="headerlink" title="16.3 具体类"></a>16.3 具体类</h2><ul>
<li>C++直接支持一部分抽象作为其内置类型。但是，大多数抽象并不直接支持 。</li>
<li>如果一个类的表示是其定义的一部分，我们就称它是具体的(concrete，或者称它是一个具体类)。这将与抽象类区分开来，后者为多种实现提供一个公共接口。在定义中明确类的表示方式令我们能：<ul>
<li>将对象置于栈，静态分配的内存以及其他对象中</li>
<li>拷贝和移动对象</li>
<li>直接引用具名对象</li>
</ul>
</li>
</ul>
<h3 id="16-3-2-辅助函数"><a href="#16-3-2-辅助函数" class="headerlink" title="16.3.2 辅助函数"></a>16.3.2 辅助函数</h3><ul>
<li>一般而言，一个类都会有一些无须定义在类内的关联函数，因为它们不需要直接访问类的表示。</li>
</ul>
<h3 id="16-3-3-重载运算符"><a href="#16-3-3-重载运算符" class="headerlink" title="16.3.3 重载运算符"></a>16.3.3 重载运算符</h3><ul>
<li>添加一些函数使得用户自定义类型能使用人们习惯的符号通常是很有用的</li>
<li>注意，赋值和拷贝初始化是默认提供的。</li>
</ul>
<h3 id="16-3-4-具体类的重要性"><a href="#16-3-4-具体类的重要性" class="headerlink" title="16.3.4 具体类的重要性"></a>16.3.4 具体类的重要性</h3><ul>
<li>具体类的使用就像内置类型一样。具体类型也称为值类型(value type)，使用它们编程称为面向值的程序设计。</li>
<li>一个具体类型的目标是高效的做好一件相对简单的事情，为用户提供修改其行为的特性通常不是其目标。特别是，展现运行时多态行为也不是其意图。</li>
</ul>
<h2 id="16-4-建议"><a href="#16-4-建议" class="headerlink" title="16.4 建议"></a>16.4 建议</h2><ul>
<li>将概念表示为类</li>
<li>将类的接口与实现分离</li>
<li>仅当数据真的仅仅是数据且数据成员不存在有意义的不变式时才使用共有数据(struct)</li>
<li>定义构造函数来处理对象初始化</li>
<li>默认将单参数构造函数声明为explicit</li>
<li>将不修改其对象状态的成员函数声明为const</li>
<li>具体类型是最简单的类。只要适用，就应该优先选择具体类型而不是更复杂的类或普通数据结构。</li>
<li>仅当函数需要直接访问类的表示时才将其实现为成员函数。</li>
<li>使用名字空间建立类与其辅助函数间的显示关联</li>
<li>将不修改对象值的成员函数定义为const成员函数。</li>
<li>若一个函数需要访问类的表示，但并不需要用某个具体对象来调用，建议将其实现为static成员函数</li>
</ul>
<h1 id="第十七章-构造，清理，拷贝和移动"><a href="#第十七章-构造，清理，拷贝和移动" class="headerlink" title="第十七章 构造，清理，拷贝和移动"></a>第十七章 构造，清理，拷贝和移动</h1><h2 id="17-1-引言"><a href="#17-1-引言" class="headerlink" title="17.1 引言"></a>17.1 引言</h2><ul>
<li>本章主要介绍与对象的生命周期有关的技术：<ul>
<li>我们如何创建对象</li>
<li>如何拷贝对象</li>
<li>如果移动对象</li>
<li>在对象销毁时如何进行清理工作</li>
</ul>
</li>
<li>移动和拷贝的区别在于，拷贝操作后两个对象具有相同的值，而移动操作后移动源不一定具有原始值。如果源对象在操作后不再使用，我们就可以使用移动操作。</li>
<li>一个对象在6中情况下会被拷贝或移动<ul>
<li>作为赋值操作的源</li>
<li>作为一个对象初始化器</li>
<li>作为一个函数实参</li>
<li>作为一个函数返回值</li>
<li>作为一个异常</li>
</ul>
</li>
<li>在所有这些情况下，都会应用拷贝或移动构造函数</li>
<li>除了初始化具名对象和自由存储上的对象，构造函数还用来初始化临时对象。</li>
</ul>
<h2 id="17-2-构造函数和析构函数"><a href="#17-2-构造函数和析构函数" class="headerlink" title="17.2 构造函数和析构函数"></a>17.2 构造函数和析构函数</h2><ul>
<li>我们可以通过定义一个构造函数来指出一个类的对象应如何初始化。与构造函数对应，我们还可以定义一个析构函数来确保对象销毁时进行恰当的清理操作。</li>
</ul>
<h3 id="17-2-1-构造函数和不变式"><a href="#17-2-1-构造函数和不变式" class="headerlink" title="17.2.1 构造函数和不变式"></a>17.2.1 构造函数和不变式</h3><ul>
<li>与类同名的成员称为构造函数。构造函数的声明指出其参数列表，但未指出返回类型。</li>
<li>构造函数的任务是初始化该类的一个对象。一般而言，初始化操作必须建立一个类不变式，所谓不变式就是当成员函数(从类外)被调用时必须保持的某些东西</li>
<li>为什么应该定义一个不变式呢？这是为了<ul>
<li>聚焦于类的设计工作上</li>
<li>理清类的行为</li>
<li>简化成员函数的定义</li>
<li>理清类的资源管理</li>
<li>简化类的文档</li>
</ul>
</li>
<li>通常，设计不变式最终会节省我们的总工作量</li>
</ul>
<h3 id="17-2-2-析构函数和资源"><a href="#17-2-2-析构函数和资源" class="headerlink" title="17.2.2 析构函数和资源"></a>17.2.2 析构函数和资源</h3><ul>
<li>构造函数初始化对象。换句话说，它创建供成员函数进行操作的环境。</li>
<li>这种基于构造函数&#x2F;析构函数的资源管理风格被称为资源获取即初始化或简称RAII</li>
<li>一对匹配的构造函数&#x2F;系统函数是C++中实现可变大小对象的常用机制。</li>
</ul>
<h3 id="17-2-3-基类和成员析构函数"><a href="#17-2-3-基类和成员析构函数" class="headerlink" title="17.2.3 基类和成员析构函数"></a>17.2.3 基类和成员析构函数</h3><ul>
<li>构造函数和析构函数可以很好的与类层次配合。构造函数会自顶向下的创建一个类对象<ul>
<li>首先，构造函数调用其基类的构造函数</li>
<li>然后，它调用成员的构造函数</li>
<li>最后，它执行自身的函数体。</li>
</ul>
</li>
<li>析构函数则按相反顺序拆除一个对象。<ul>
<li>首先，析构函数执行自身的函数体</li>
<li>然后，它调用其成员的析构函数</li>
<li>最后，它调用其基类的析构函数。</li>
</ul>
</li>
<li>特别是，一个virtual基类必须在任何可能使用它的基类之前构造。</li>
</ul>
<h3 id="17-2-4-调用构造函数和析构函数"><a href="#17-2-4-调用构造函数和析构函数" class="headerlink" title="17.2.4 调用构造函数和析构函数"></a>17.2.4 调用构造函数和析构函数</h3><ul>
<li>当对象退出作用域或被delete释放时，析构函数会被隐式调用。显式调用析构通常是不必要的，而且会导致严重的错误。</li>
</ul>
<h2 id="17-3-类对象初始化"><a href="#17-3-类对象初始化" class="headerlink" title="17.3 类对象初始化"></a>17.3 类对象初始化</h2><ul>
<li>本节讨论如何初始化一个类的对象，分使用构造函数和不适用构造函数两种情况讨论</li>
</ul>
<h3 id="17-3-1-不适用构造函数进行初始化"><a href="#17-3-1-不适用构造函数进行初始化" class="headerlink" title="17.3.1 不适用构造函数进行初始化"></a>17.3.1 不适用构造函数进行初始化</h3><ul>
<li>我们不能为内置类型定义构造函数，但能用一个恰当类型的值初始化内置类型对象。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">char</span>* p&#123;<span class="literal">nullptr</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li>类似的，我们可以用下列方法初始化一个无构造函数的类的对象<ul>
<li>逐成员初始化</li>
<li>拷贝初始化</li>
<li>默认初始化，不用初始化器或空初始化列表</li>
</ul>
</li>
</ul>
<h3 id="17-3-2-使用构造函数进行初始化"><a href="#17-3-2-使用构造函数进行初始化" class="headerlink" title="17.3.2 使用构造函数进行初始化"></a>17.3.2 使用构造函数进行初始化</h3><ul>
<li>当逐成员拷贝不能满足需求时，我们可以定义构造函数来初始化对象。特别是，构造函数常用来建立类的不变式并获取必要的资源。</li>
<li>注意，当定义了一个接受参数的构造函数后，默认构造函数就不存在了</li>
<li>我使用{}语法来明确表示正在进行初始化,而不仅仅是在赋值,调用函数或是声明函数.只要是在构造对象的地方,我们都可以用{}初始化语法为构造函数提供参数.</li>
<li>处于这个原因,{}初始化有时也称为通用(universal)初始化:<ul>
<li>这种语法可以在任何地方,</li>
<li>而且,{}初始化还是一致的:无论你在哪里使用语法{v}将类型X的对象初始化为值v,都会创建相同的值</li>
</ul>
</li>
<li>与{}相反,&#x3D;和()初始化语法不是通用的.</li>
<li>注意,{}初始化器语法不允许窄化转换.这是我们更倾向于使用{}风格而不是()或&#x3D;的另一个原因.</li>
</ul>
<h4 id="17-3-2-1-用构造函数进行初始化"><a href="#17-3-2-1-用构造函数进行初始化" class="headerlink" title="17.3.2.1 用构造函数进行初始化"></a>17.3.2.1 用构造函数进行初始化</h4><ul>
<li>使用 ()语法, 可以请求在初始化过程中使用一个构造函数.即,对一个类,你可以保证用构造函数进行初始化而不会进行{}语法也提供的逐成员初始化或初始化器列表初始化.</li>
<li>{}初始化的一致使用自C++11起才成为现实</li>
</ul>
<h3 id="17-3-3-默认构造函数"><a href="#17-3-3-默认构造函数" class="headerlink" title="17.3.3 默认构造函数"></a>17.3.3 默认构造函数</h3><ul>
<li>无参的构造函数被称为默认构造函数.</li>
<li>如果构造对象时未指定参数或提供了一个空初始化器列表,则会调用默认构造函数.</li>
<li>内置类型被认为具有默认构造函数和拷贝构造函数.但是,对于内置类型的未初始化的非static变量,其默认构造函数不会被调用.内置整数类型的默认值为0,浮点类型的默认值为0.0,指针类型的默认值为nullptr</li>
<li>引用和const必须被初始化.</li>
</ul>
<h3 id="17-3-4-初始化器列表构造函数"><a href="#17-3-4-初始化器列表构造函数" class="headerlink" title="17.3.4 初始化器列表构造函数"></a>17.3.4 初始化器列表构造函数</h3><ul>
<li>接受单一std::initializer_list参数的构造函数被称为初始化器列表构造函数.</li>
<li>一个初始化器列表构造函数使用一个{}列表作为其初始化值来构造对象.</li>
<li>标准库容器都有初始化器列表构造函数,初始化器列表赋值运算符等成员.</li>
<li>我们想要使用接受一个{}列表进行初始化的机制,就要定义一个接受std::initializer_list<T>类型参数的函数,通常是一个构造函数.</li>
</ul>
<h4 id="17-3-4-1-initializer-list构造消除歧义"><a href="#17-3-4-1-initializer-list构造消除歧义" class="headerlink" title="17.3.4.1 initializer_list构造消除歧义"></a>17.3.4.1 initializer_list构造消除歧义</h4><ul>
<li>如果一个类已有多个构造函数,则编译器会使用常规的重载解析规则根据给定参数选择一个正确的构造函数.当选择构造函数时,默认构造函数和初始化器列表构造函数优先.具体规则如下<ul>
<li>如果默认构造函数或初始化器列表构造函数都匹配,优先选择默认构造函数</li>
<li>如果一个初始化器列表构造函数和一个普通构造函数都匹配,优先选择列表初始化器构造函数.</li>
</ul>
</li>
</ul>
<h4 id="17-3-4-2-使用initializer-list"><a href="#17-3-4-2-使用initializer-list" class="headerlink" title="17.3.4.2 使用initializer_list"></a>17.3.4.2 使用initializer_list</h4><ul>
<li>可以将接受一个initializer_list<T>参数的函数作为一个序列来访问,即,通过成员函数begin(), end()和size()访问.</li>
<li>不幸的是,initializer_list不提供下标操作</li>
<li>initializer_list<T>是以传值方式传递的.这是重载解析规则所要求的,而且不会带来额外开销,因为一个initializer_list<T>对象只是一个小句柄,通常是两个字大小,指向一个元素类型为T的数组</li>
<li>initializer_list的元素是不可变的,不要考虑修改它们的值</li>
</ul>
<h4 id="17-3-4-3-直接和拷贝初始化"><a href="#17-3-4-3-直接和拷贝初始化" class="headerlink" title="17.3.4.3 直接和拷贝初始化"></a>17.3.4.3 直接和拷贝初始化</h4><ul>
<li>{}初始化也存在直接初始化和拷贝初始化的区别.对一个容器来说,这意味着这种区别对容器自身及其中的元素都有作用:<ul>
<li>容器的初始化器列表构造函数可以是explicit,也可以不是</li>
<li>初始化器列表的元素类型的构造函数可以是explicit,也可以不是.</li>
</ul>
</li>
</ul>
<h2 id="17-4-成员和基类初始化"><a href="#17-4-成员和基类初始化" class="headerlink" title="17.4 成员和基类初始化"></a>17.4 成员和基类初始化</h2><ul>
<li>构造函数可以建立不变式并获取资源.一般而言,构造函数是通过初始化类成员和基类来完成这些工作的.</li>
</ul>
<h3 id="17-4-1-成员初始化"><a href="#17-4-1-成员初始化" class="headerlink" title="17.4.1 成员初始化"></a>17.4.1 成员初始化</h3><ul>
<li>在构造函数的定义中,通过成员初始化器列表给出成员的构造函数的参数.例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Club::<span class="built_in">Club</span>(<span class="type">const</span> string&amp; n, Data fd)</span><br><span class="line">  : name&#123;n&#125;, members&#123;&#125;, officers&#123;&#125;, founder&#123;fd&#125;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>成员初始化器列表以一个冒号开始,后面的成员初始化器用逗号间隔.</li>
<li>类自身的构造函数在其函数体执行之前会先调用成员的构造函数.</li>
<li>成员的构造函数按成员在类中声明的顺序调用,而不是按成员在初始化器中列表中出现的顺序.</li>
<li>为了避免混淆,最好按成员的声明顺序指明初始化器.</li>
<li>一个构造函数可以初始化其类的成员和基类,但不会初始化其成员或基类的成员或基类.</li>
</ul>
<h3 id="17-4-2-基类初始化器"><a href="#17-4-2-基类初始化器" class="headerlink" title="17.4.2 基类初始化器"></a>17.4.2 基类初始化器</h3><ul>
<li>派生类的基类的初始化方式与非数据成员相同.即,如果基类要求一个初始化器,我们就必须在构造函数中提供相应的基类初始化器.</li>
<li>与成员初始化类似,基类按声明顺序进行初始化,建议按此顺序指定基类的初始化器.基类的初始化在成员之前,销毁在成员之后.</li>
</ul>
<h3 id="17-4-3-委托构造函数"><a href="#17-4-3-委托构造函数" class="headerlink" title="17.4.3 委托构造函数"></a>17.4.3 委托构造函数</h3><ul>
<li>如果你希望两个构造函数做相同的操作,可以重复代码,也可以定义一个 init()函数 来执行两者相同的操作.</li>
<li>一种替代方法是用一个构造函数定义另一个<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(<span class="type">int</span> x) &#123;<span class="keyword">if</span> (<span class="number">0</span> &lt; x &amp;&amp; x &lt;= max) a = x; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">Bad_X</span>(x);&#125;</span><br><span class="line">  <span class="built_in">X</span>() : <span class="built_in">X</span>(<span class="number">24</span>)&#123;&#125;</span><br><span class="line">  <span class="built_in">X</span>(string s):<span class="built_in">X</span>(<span class="built_in">to</span>&lt;<span class="type">int</span>&gt;(s))&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>即,使用一个成员风格的初始化器,但用的是类自身的名字(也是构造函数名),它会调用另一个构造函数,作为这个构造过程的一部分.这样的构造函数称为委托构造函数(delegating constructor,有时也称为转发构造函数, forwarding constructor)</li>
</ul>
<h3 id="17-4-4-类内初始化器"><a href="#17-4-4-类内初始化器" class="headerlink" title="17.4.4 类内初始化器"></a>17.4.4 类内初始化器</h3><ul>
<li>我们可以在类声明中为非static数据成员指定初始化器.例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a &#123;<span class="number">77</span>&#125;;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">88</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>处于语法分析和名字查找相关的很隐蔽的技术原因,{}和&#x3D;语法能用于类内成员初始化器,但是 ()语法就不行</li>
<li>一个类内初始化器可以使用它的位置所在作用域中的所有名字.</li>
</ul>
<h3 id="17-4-5-static成员初始化"><a href="#17-4-5-static成员初始化" class="headerlink" title="17.4.5 static成员初始化"></a>17.4.5 static成员初始化</h3><ul>
<li>一个static类成员是静态分配的,而不是每个类对象的一部分.一般来说,static成员声明充当类外定义的声明.例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> node_count;    <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Node::node_count = <span class="number">0</span>;   <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure></li>
<li>但是,在少数简单的特殊情况下,在类内声明中初始化static成员也是可能的.条件是 static成员必须是整型或枚举类型的const,或字面值类型的constexpr,且初始化器必须是一个常量表达式.例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Curious</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> c1 = <span class="number">7</span>;  <span class="comment">// 正确</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> c2 = <span class="number">11</span>;       <span class="comment">// 错误:非const</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> c3 = <span class="number">13</span>;        <span class="comment">// 正确,但非static</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> c4 = <span class="built_in">sqrt</span>(<span class="number">9</span>);  <span class="comment">// 错误:类内初始化器不是常量</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">float</span> c5 = <span class="number">7.0</span>;    <span class="comment">// 错误:类内初始化成员不是整型,应该使用constexpr而非const</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>当且仅当你使用一个已初始化成员的方式要求它像对象一样在内存中存储时,该成员必须在某处定义.初始化器不能重复;</li>
<li>成员常量的主要用途是为类声明中其他地方用到的常量提供符号名称.</li>
</ul>
<h2 id="17-5-拷贝和移动"><a href="#17-5-拷贝和移动" class="headerlink" title="17.5 拷贝和移动"></a>17.5 拷贝和移动</h2><ul>
<li>当我们需要从a到b传输一个值的时候,通常有两种逻辑上不同的方法<ul>
<li>拷贝(copy)是 x &#x3D; y 的常规含义:即,结果是x和y的值都等于赋值前y的值</li>
<li>移动(move)将x变为y的旧值,y变为某种移出状态(moved-from state).我们最感兴趣的情况–容器,移出状态就是 空</li>
</ul>
</li>
<li>一般来说,移动操作不能抛出异常,而拷贝操作则可以.因为拷贝可能需要获取资源,移动操作通常比拷贝操作更高效.</li>
<li>为了避免乏味的重复性工作,拷贝和移动操作都有默认定义</li>
</ul>
<h3 id="17-5-1-拷贝"><a href="#17-5-1-拷贝" class="headerlink" title="17.5.1 拷贝"></a>17.5.1 拷贝</h3><ul>
<li><p>类X的拷贝操作有两种</p>
<ul>
<li>拷贝构造函数: X(const X&amp;)</li>
<li>拷贝赋值运算符: X&amp; operator&#x3D;(const X&amp;)</li>
</ul>
</li>
<li><p>拷贝构造函数与拷贝赋值运算符的区别在于前者初始化一片未初始化的内存,而后者必须正确处理目标对象已构造并可能拥有资源的情况.</p>
</li>
<li><p>从拷贝的目的来看，一个基类就是一个成员：为了拷贝派生类的一个对象，你必须拷贝其基类</p>
</li>
</ul>
<h3 id="17-5-2-移动"><a href="#17-5-2-移动" class="headerlink" title="17.5.2 移动"></a>17.5.2 移动</h3><ul>
<li>移动赋值背后的思想是将左值的处理与右值的处理分离：拷贝赋值操作和拷贝构造函数接受左值，而移动赋值操作和移动构造函数则接受右值。对于return值，采用移动构造函数。</li>
</ul>
<h2 id="17-6-生成默认操作"><a href="#17-6-生成默认操作" class="headerlink" title="17.6 生成默认操作"></a>17.6 生成默认操作</h2><ul>
<li>编写拷贝操作，析构函数这样的常规操作会很乏味也容易出错，因此需要时编译器可为我们生成这些操作。默认情况下，编译器会为一个类生成<ul>
<li>一个默认构造函数：X()</li>
<li>一个拷贝构造函数： X(const X&amp;)</li>
<li>一个拷贝赋值运算符：X&amp; operator&#x3D;(const X&amp;)</li>
<li>一个移动构造函数：X(X&amp;&amp;)</li>
<li>一个移动赋值运算符： X&amp; operator&#x3D;(X&amp;&amp;)</li>
<li>一个析构函数：~X()</li>
</ul>
</li>
</ul>
<h3 id="17-6-1-显式声明默认操作"><a href="#17-6-1-显式声明默认操作" class="headerlink" title="17.6.1 显式声明默认操作"></a>17.6.1 显式声明默认操作</h3><ul>
<li>使用 &#x3D;default 总是比你自己实现默认语义要好。</li>
</ul>
<h3 id="17-6-2-默认操作"><a href="#17-6-2-默认操作" class="headerlink" title="17.6.2 默认操作"></a>17.6.2 默认操作</h3><ul>
<li>每个生成的操作的默认含义，像编译器生成它们所用的实现方法一样，就是对类的每个基类和非static数据成员应用此操作。即，逐成员拷贝，逐成员默认构造等等。</li>
</ul>
<h3 id="17-6-4-使用delete删除的函数"><a href="#17-6-4-使用delete删除的函数" class="headerlink" title="17.6.4 使用delete删除的函数"></a>17.6.4 使用delete删除的函数</h3><ul>
<li>我们可以删除一个函数，即，我们可以声明一个函数不存在，从而令(隐式或显式)使用它的尝试成为错误。</li>
<li>这种机制最明显的应用是消除其他默认函数。例如，防止拷贝基类是很常见的，因为这种拷贝容易导致切片。</li>
</ul>
<h2 id="17-7-建议"><a href="#17-7-建议" class="headerlink" title="17.7 建议"></a>17.7 建议</h2><ul>
<li>应该构造函数，赋值操作以及析构函数设计为一组匹配的曹祖</li>
<li>使用构造函数为类建立不变式</li>
<li>如果一个构造函数获取了资源，那么这个类就需要一个析构函数释放该资源</li>
<li>如果一个类有虚函数，它就需要一个虚析构函数</li>
<li>如果一个类没有构造函数，它可以进行逐成员初始化</li>
<li>优先选择使用{}初始化而不是&#x3D;和()初始化</li>
<li>当且仅当类对象有 自然的 默认值时才为类定义默认构造函数</li>
<li>如果一个类是容器，为它定义一个初始化列表构造函数</li>
<li>按声明顺序初始化成员和基类</li>
<li>如果一个类有一个引用成员，它可能需要拷贝操作</li>
<li>在构造函数中优先选择成员初始化而不是赋值操作</li>
<li>使用类内初始化器来提供默认值</li>
<li>如果一个类是一个资源句柄，它可能需要拷贝和移动操作</li>
<li>当编写一个拷贝构造函数时，小心拷贝每个需要拷贝的元素</li>
<li>一个拷贝操作应该提供等价性和独立性</li>
<li>小心纠缠的数据结构</li>
<li>优先选择移动语义和写前拷贝而不是浅拷贝</li>
<li>如果一个类被用作基类，防止切片现象</li>
<li>如果一个类需要一个拷贝操作或一个析构函数，它可能需要一个构造函数，一个析构函数，一个拷贝赋值操作以及一个拷贝构造函数</li>
<li>如果一个类有一个指针成员，它可能需要一个析构函数和非默认拷贝操作</li>
</ul>
<h1 id="第十八章-运算符重载"><a href="#第十八章-运算符重载" class="headerlink" title="第十八章 运算符重载"></a>第十八章 运算符重载</h1><h2 id="18-1-引言"><a href="#18-1-引言" class="headerlink" title="18.1 引言"></a>18.1 引言</h2><ul>
<li>运算符重载最常用于数字类型，但是用户自定义运算符的用处绝不仅仅局限于数字类型。</li>
</ul>
<h2 id="18-5-建议"><a href="#18-5-建议" class="headerlink" title="18.5 建议"></a>18.5 建议</h2><ul>
<li>定义运算符时应该尽量模仿传统用法</li>
<li>如果默认的拷贝操作对于某种类型不适用，应该重新定义或者干脆禁用</li>
<li>对于较大的运算对象，选用const引用类型</li>
<li>对于较大的返回结果，选择移动构造函数</li>
<li>对于需要访问类的表示部分的操作，优先将其定义为成员函数</li>
<li>反之，对于无须访问类的表示部分的操作，优先将其定义为非成员函数</li>
<li>用名字空间把辅助函数和它们的类结合在一起</li>
<li>把对称的运算符定义成非成员函数</li>
<li>用用户自定义的字面值常量模仿传统用法</li>
<li>不要轻易为数据成员提供 set() 和 get() 函数，除非从语义上确使需要它们</li>
<li>谨慎使用隐式类型转换</li>
<li>避免使用丢失部分信息的类型转换</li>
<li>对于同一种类型转换，切勿把它同时定义成构造函数以及类型转换运算符。</li>
</ul>
<h1 id="第十九章-特殊运算符"><a href="#第十九章-特殊运算符" class="headerlink" title="第十九章 特殊运算符"></a>第十九章 特殊运算符</h1><h2 id="19-2-特殊运算符"><a href="#19-2-特殊运算符" class="headerlink" title="19.2 特殊运算符"></a>19.2 特殊运算符</h2><ul>
<li>下列运算符<ul>
<li>[] () -&gt; ++ – new delete</li>
</ul>
</li>
<li>与<ul>
<li>+, &lt;, ~等传统的一元或者二元运算符相比有其特殊之处，主要是从这些运算符在代码中的使用到程序员给出的定义的映射与传统运算符有轻微的差别。</li>
</ul>
</li>
</ul>
<h3 id="19-2-1-取下标"><a href="#19-2-1-取下标" class="headerlink" title="19.2.1 取下标"></a>19.2.1 取下标</h3><ul>
<li>我们可以用operator[]函数为类对象的下标赋予某种新的含义。operator[]函数的第二个参数可以是任意类型的，因此，它常被用于定义vector，关联数组等类型</li>
<li>operator<a href=""></a>必须是非static成员函数</li>
</ul>
<h3 id="19-2-2-函数调用"><a href="#19-2-2-函数调用" class="headerlink" title="19.2.2 函数调用"></a>19.2.2 函数调用</h3><ul>
<li>函数调用可以看成是一个二元运算，它的左侧运算对象是expression，右侧运算对象是expression-list。调用运算符()可以像其他运算符一样被重载。</li>
<li>运算符() 最直接也是最重要的目标是为某些行为类似函数的对象提供函数调用语法。其中，行为模式与函数类似的对象称为类函数对象(function-like object)或者简称为函数对象。</li>
<li>函数调用运算符通常是模板</li>
</ul>
<h3 id="19-2-3-解引用"><a href="#19-2-3-解引用" class="headerlink" title="19.2.3 解引用"></a>19.2.3 解引用</h3><ul>
<li>解引用运算符 -&gt; 可以定义成一个一元后置运算符</li>
<li>重载-&gt;的主要目的是创建 智能指针，即，行为与指针类似的对象</li>
</ul>
<h3 id="19-2-4-递增和递减"><a href="#19-2-4-递增和递减" class="headerlink" title="19.2.4 递增和递减"></a>19.2.4 递增和递减</h3><ul>
<li>在C++的所有运算符中，递增运算符和递减运算符是最特别的，因为它们即可以作为前置运算符，也可以作为后置运算符。</li>
<li>前置递增运算符返回对象的引用，后置递增预算符返回一个新创建的对象。</li>
</ul>
<h3 id="19-2-5-分配和释放"><a href="#19-2-5-分配和释放" class="headerlink" title="19.2.5 分配和释放"></a>19.2.5 分配和释放</h3><ul>
<li>运算符new通过调用operator new()分配内存。相应的，运算符delete通过调用operator delete()释放内存。</li>
</ul>
<h3 id="19-2-6-用户自定义字面值常量"><a href="#19-2-6-用户自定义字面值常量" class="headerlink" title="19.2.6 用户自定义字面值常量"></a>19.2.6 用户自定义字面值常量</h3><ul>
<li>C++为内置数据类型提供了字面值常量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>;  <span class="comment">// int</span></span><br><span class="line"><span class="number">1.2</span>;  <span class="comment">// double</span></span><br><span class="line"><span class="number">1.2F</span>; <span class="comment">// float</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span>;  <span class="comment">// char</span></span><br><span class="line"><span class="number">1ULL</span>; <span class="comment">// unsigned long long</span></span><br><span class="line"><span class="number">0xD0</span>; <span class="comment">// 十六进制 unsigned</span></span><br><span class="line"><span class="string">&quot;as&quot;</span>; <span class="comment">// C风格字符串</span></span><br></pre></td></tr></table></figure></li>
<li>我们也能为用户自定义类型提供字面值常量，或者更新内置类型字面值常量的形式。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hi&quot;</span>s <span class="comment">// 字符串，并非以0结尾的字符数组</span></span><br><span class="line"><span class="number">1.2</span>i  <span class="comment">// 虚数</span></span><br><span class="line"><span class="number">1010101111001100</span>b <span class="comment">// 二进制数</span></span><br><span class="line"><span class="number">123</span>s  <span class="comment">// 秒数</span></span><br><span class="line"><span class="number">123.56</span>km  <span class="comment">// 注意此处并非miles</span></span><br></pre></td></tr></table></figure></li>
<li>上述的用户自定义字面值常量是通过字面值常量运算符定义的，这类运算符负责把带后缀的字面值常量映射到目标类型。字面值常量运算符的名字由operator””加上后缀组成</li>
</ul>
<h2 id="19-4-友元"><a href="#19-4-友元" class="headerlink" title="19.4 友元"></a>19.4 友元</h2><ul>
<li>一条普通的成员函数声明语句在逻辑上包含相互独立的三层含义<ul>
<li>该函数有权访问类的私有成员</li>
<li>该函数位于类的作用域之内</li>
<li>我们必须用一个含有this指针的对象调用该函数</li>
</ul>
</li>
<li>通过把成员函数声明成static的，我们可以令它只具有前两层含义。</li>
<li>通过把非成员函数声明成friend的，我们可以令它只具有第一层含义。换句话说，一个friend函数可以像成员函数一样访问类的实现，但是在其他层面上与类是完全独立的。</li>
<li>通常情况下，我们可以选择把类设计为成员(嵌套的类)或者非成员的友元</li>
</ul>
<h3 id="19-4-1-发现友元"><a href="#19-4-1-发现友元" class="headerlink" title="19.4.1 发现友元"></a>19.4.1 发现友元</h3><ul>
<li>友元必须在类的外层作用域中提前声明，或者定义在直接外层非类作用域中。</li>
<li>友元函数应该显式的声明在外层作用域中，或者接收一个数据类型为该类或者其派生类的参数；否则我们无法调用该友元函数。</li>
</ul>
<h3 id="19-4-2-友元与成员"><a href="#19-4-2-友元与成员" class="headerlink" title="19.4.2 友元与成员"></a>19.4.2 友元与成员</h3><ul>
<li>到底应该何时使用友元函数，何时把操作定义为成员函数呢？</li>
<li>首先，我们应该让有权访问类的表示的函数数量尽可能少，并且确保所选的访问函数准确无误。</li>
</ul>
<h2 id="19-5-建议"><a href="#19-5-建议" class="headerlink" title="19.5 建议"></a>19.5 建议</h2><ul>
<li>用operator<a href=""></a>执行取下标以及通过单个值查询等操作</li>
<li>用operator()()执行函数调用，取下标以及通过多个值查询等操作</li>
<li>用operator-&gt;()解引用 智能指针</li>
<li>前置++优于后置++</li>
<li>除非万不得已，否则不要定义全局operator new(), operator delete()</li>
<li>为特定类或者类层次体系定义成员函数operator new() 和 operator delete()，用他们分配和释放内存空间</li>
<li>用用户自定义的字面值常量模仿人们习惯的语法表示</li>
<li>在大多数应用场合，建议使用标准库string而非你自己的版本</li>
<li>如果需要使用非成员函数访问类的表示，比如改进写法，或者同时访问两个类的表示，把它声明成类的友元。</li>
<li>当需要访问类的实现时，优先选用成员函数而非友元函数</li>
</ul>
<h1 id="第二十章-派生类"><a href="#第二十章-派生类" class="headerlink" title="第二十章 派生类"></a>第二十章 派生类</h1><h2 id="20-1-引言"><a href="#20-1-引言" class="headerlink" title="20.1 引言"></a>20.1 引言</h2><ul>
<li>C++从Simula借鉴了类和类层次的思想。而且，C++还借鉴了一个重要的设计思想：<strong>类应该用来建模程序员和应用程序世界中的思想。</strong></li>
<li>C++提供了派生类的概念及相关的语言机制来表达层次关系，即，表达类之间的共性。</li>
<li>C++语言特性支持从已有类构建新的类<ul>
<li>实现继承(implementation inheritance): 通过共享基类所提供的特性来减少实现工作量</li>
<li>接口继承(interface inheritance): 通过一个公共基类提供的接口允许不同派生类互换使用</li>
</ul>
</li>
<li>接口继承常被称为运行时多态(run-time polymorphism, 或者动态多态, dynamic polymorphism)。</li>
<li>相反，模板所提供的类的通用性和继承无关，常被称为编译时多态(compile-tile polymorphism, 或静态多态, static polymorphism)</li>
</ul>
<h2 id="20-2-派生类"><a href="#20-2-派生类" class="headerlink" title="20.2 派生类"></a>20.2 派生类</h2><ul>
<li>派生关系通常可以图示为从派生类到其基类的一个箭头，表示派生类引用其基类。</li>
<li>我们常常称一个派生类继承了来自基类的属性，因此这种关系也称为继承(inheritance)。有时，基类也称为超类(superclass)，派生类称为子类(subclass)</li>
<li>但是，派生类对象中的数据是其基类对象数据的超集。一个派生类通常比基类保存更多数据，提供更多函数，从这一点来说它比基类更大，绝不会更小。</li>
<li>派生类概念的一种流行且高效的实现是将派生类对象表示为基类对象，再加上那些专属于派生类的信息放在末尾。</li>
<li>派生一个类没有任何内存额外开销，所需内存就是成员所需空间。</li>
<li>换句话说，若通过指针和引用进行操作，派生类对象可以当作其基类对象处理，反过则不能。</li>
<li>将一个类用作基类等价于定义一个该类的(无名)对象。因此，类必须定义后才能用作基类。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>; <span class="comment">// 只是声明，不是定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> : <span class="keyword">public</span> Employee &#123;  <span class="comment">// 错误：Employee未定义</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="20-2-1-成员函数"><a href="#20-2-1-成员函数" class="headerlink" title="20.2.1 成员函数"></a>20.2.1 成员函数</h3><ul>
<li>派生类的成员可以使用基类的公有和保护成员，就好像它们声明派生类中一样。但是派生类不能访问基类的私有成员。</li>
<li>通常，对派生类而言最干净的解决方案是只使用其基类的公有成员。</li>
</ul>
<h3 id="20-2-2-构造函数和析构函数"><a href="#20-2-2-构造函数和析构函数" class="headerlink" title="20.2.2 构造函数和析构函数"></a>20.2.2 构造函数和析构函数</h3><ul>
<li>构造函数和析构函数照例是必不可少的<ul>
<li>对象自底向上构造(基类先于成员，成员先于派生类)，自顶向下销毁(派生类先于成员，成员先于基类)</li>
<li>每个类都可以初始化其成员和基类(但不能直接初始化其基类的成员或基类的基类)</li>
<li>类层次中析构函数通常应该是virtual的</li>
<li>类层次中类的拷贝构造函数须小心使用，以壁面切片现象</li>
<li>虚函数调用的解析，dynamic_cast，以及构造函数或析构函数中的typeid()反映了构造和析构的阶段(而不是尚未构造完成的对象的类型)</li>
</ul>
</li>
</ul>
<h2 id="20-3-类层次"><a href="#20-3-类层次" class="headerlink" title="20.3 类层次"></a>20.3 类层次</h2><ul>
<li>一个派生类自身也可以作为其他类的基类。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> : <span class="keyword">public</span> Employee &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> : <span class="keyword">public</span> Manager &#123;<span class="comment">/*...*/</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li>我们习惯称这样一组相关的类为类层次(class hierarchy)。这种层次结构大多数情况下是一棵树，但也可能是更一般的图结构</li>
</ul>
<h3 id="20-3-1-类型域"><a href="#20-3-1-类型域" class="headerlink" title="20.3.1 类型域"></a>20.3.1 类型域</h3><ul>
<li>为了使派生类不至于成为仅仅是一种方便的声明简写方式，我们必须解决一个问题：给定一个Base*类型的指针，它指向的对象的真正派生类型是什么？</li>
<li>C++提供了四种基本解决方法<ul>
<li>保证指针只能指向单一类型的对象</li>
<li>在基类中放置一个类型域，供函数查看</li>
<li>使用dynamic_cast</li>
<li>使用虚函数</li>
</ul>
</li>
<li>除非使用final，否则方法1依赖于所使用类型的很多知识。</li>
</ul>
<h3 id="20-3-2-虚函数"><a href="#20-3-2-虚函数" class="headerlink" title="20.3.2 虚函数"></a>20.3.2 虚函数</h3><ul>
<li><p>虚函数机制允许程序员在基类中声明函数，然后在每个派生类中重新定义这些函数，从而解决了类型域方法的固有问题。编译器和链接器会保证对象和施用于对象之上的函数之间的正确关联。</p>
</li>
<li><p>关键字virtual指出print()作为这个类自身定义的print()函数及其派生类中定义的print()函数的接口。</p>
</li>
<li><p>为了允许一个虚函数声明能作为派生类中定义的函数的接口，派生类中函数的参数类型必须与基类中声明的参数类型完全一致，返回类型也只允许细微改变。虚成员函数有时也称为方法(method)</p>
</li>
<li><p>首次声明虚函数的类必须定义它(除非虚函数被声明为纯虚函数)</p>
</li>
<li><p>即使没有派生类，也可以使用虚函数，而一个派生类如果不需要自有版本的虚函数，可以不定义它。当派生一个类时，如需要某个函数，定义恰当版本即可。</p>
</li>
<li><p>如果派生类中一个函数的名字和参数类型与基类中的一个虚函数完全相同，则称它覆盖(override)了虚函数的基类版本。此外，我们也可以用一个派生类层次更深的返回类型覆盖基类中的虚函数。</p>
</li>
<li><p>除了我们显式说明调用虚函数的哪个版本(例如Employee::print())之外，覆盖版本会作为最恰当的选择应用于调用它的对象。无论用哪个基类访问对象，虚函数调用机制都会保证我们总是得到相同的函数。</p>
</li>
<li><p>无论真正使用的确切Employee类型是什么，都能令Employee的函数表现出正确的行为，这称为多态性(polymorphism)。具有虚函数的类型称为多态类型(polymorphic type)或者说是 运行时多态类型(run-time polymorphic type)</p>
</li>
<li><p>在C++中为了获得运行时多态行为，必须调用virtual成员函数，对象必须通过指针或引用进行访问。当直接操作一个对象时(而不是通过指针或引用)，编译器了解其确切类型，从而就不需要运行时多态了。</p>
</li>
</ul>
<h3 id="20-3-3-显式限定"><a href="#20-3-3-显式限定" class="headerlink" title="20.3.3 显式限定"></a>20.3.3 显式限定</h3><ul>
<li>使用作用域解析运算符::调用函数能保证不适用virtual机制</li>
</ul>
<h3 id="20-3-4-覆盖控制"><a href="#20-3-4-覆盖控制" class="headerlink" title="20.3.4 覆盖控制"></a>20.3.4 覆盖控制</h3><ul>
<li>特定的控制机制<ul>
<li>virtual: 函数可能被覆盖</li>
<li>&#x3D;0:函数必须是virtual的，且必须被覆盖</li>
<li>override: 函数要覆盖基类中的一个虚函数</li>
<li>final: 函数不能被覆盖</li>
</ul>
</li>
</ul>
<h3 id="20-3-5-using基类成员"><a href="#20-3-5-using基类成员" class="headerlink" title="20.3.5 using基类成员"></a>20.3.5 using基类成员</h3><ul>
<li>函数重载不会跨作用域</li>
</ul>
<h3 id="20-3-6-返回类型放松"><a href="#20-3-6-返回类型放松" class="headerlink" title="20.3.6 返回类型放松"></a>20.3.6 返回类型放松</h3><ul>
<li>覆盖函数的类型必须与它所覆盖的虚函数的类型完全一致，C++对这一规则提供了一种放松机制。即，如果原返回类型为B<em>，则覆盖函数的返回类型可以为D</em>，只要B是D的一个公有基类即可。类似的，返回类型B&amp;可以放松为D&amp;。这一规则有时称为协变返回规则(covariant return)</li>
</ul>
<h2 id="20-4-抽象类"><a href="#20-4-抽象类" class="headerlink" title="20.4 抽象类"></a>20.4 抽象类</h2><ul>
<li>具有一个或多个纯虚函数的类称为抽象类(abstract class)。我们无法创建抽象类的对象</li>
<li>抽象类就是要作为通过指针和引用访问的对象的接口(为保持多态行为)。因此，对一个抽象类来说，定义一个虚析构函数通常很重要。由于抽象类提供的接口不能用来创建对象，因此抽象类通常没有构造函数。</li>
<li>抽象类只能用作其他类的接口。抽象类提供接口，但不暴露实现细节。</li>
<li>抽象类所支持的设计风格称为接口继承(interface inheritance)，它与实现继承(implementation inheritance)相对，后者是由带状态或定义了成员函数的基类所支撑的。两种风格组合使用是可能的。</li>
</ul>
<h2 id="20-5-访问控制"><a href="#20-5-访问控制" class="headerlink" title="20.5 访问控制"></a>20.5 访问控制</h2><ul>
<li>一个类成员可以是 private， protected或public的<ul>
<li>如果它是private的，仅可被所属类的成员函数和友元函数所使用</li>
<li>如果它是protected的，仅可被所属类的成员函数和友元函数以及派生类的成员函数和友元函数所使用</li>
<li>如果它是public的，可被任何函数所使用</li>
</ul>
</li>
<li>这反映了函数按类访问权限可分为三类：<ul>
<li>实现类的函数(其友元和成员)</li>
<li>实现派生类的函数(派生类的友元和成岩)</li>
<li>以及其他函数</li>
</ul>
</li>
</ul>
<h3 id="20-5-1-protected成员"><a href="#20-5-1-protected成员" class="headerlink" title="20.5.1 protected成员"></a>20.5.1 protected成员</h3><ul>
<li><p>当设计一个类层次时，有时我们提供的函数是供派生类的实现者而非普通用户所用的。</p>
</li>
<li><p>例如，我们可能为派生类实现者提供一个高效的，不进行检查的访问函数，为其他人提供一个安全的进行检查的访问函数。我们可以通过将不检查的版本声明为protected来达到这一目的。</p>
</li>
<li><p>在类中，成员默认是private的，而这通常是更好的选择。以我的经验，总是有其他代替方法，从而无须将派生类要用到的大量数据都放到一个公共基类中。</p>
</li>
</ul>
<h3 id="20-5-2-访问基类"><a href="#20-5-2-访问基类" class="headerlink" title="20.5.2 访问基类"></a>20.5.2 访问基类</h3><ul>
<li>类似成员，基类也可以声明为private,protected或public。例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>: <span class="keyword">public</span> B &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>: <span class="keyword">protected</span> B &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span>: <span class="keyword">private</span> B &#123;<span class="comment">/*...*/</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li>不同的访问说明符满足不同设计需求<ul>
<li>public派生令派生类称为基类的一个子类型。例如，X是一种B。这是最常见的派生形式</li>
<li>private基类最有用的情形就是当我们定义一个类时将其接口限定为基类，从而可提供更强的保障。</li>
<li>protected基类在类层次中很有用，其中进一步的派生是常态。类似private派生，protected派生也用于表示实现细节。</li>
</ul>
</li>
</ul>
<h2 id="20-7-建议"><a href="#20-7-建议" class="headerlink" title="20.7 建议"></a>20.7 建议</h2><ul>
<li>避免使用类型域</li>
<li>通过指针和引用访问多态对象</li>
<li>使用抽象类，以便聚焦于清晰接口的设计应该提供什么</li>
<li>在大型类层次中用override显式说明覆盖</li>
<li>谨慎使用final</li>
<li>使用抽象类说明接口</li>
<li>使用抽象类保持实现细节和接口分离</li>
<li>如果一个类有虚函数，那么它也应该有一个虚析构函数</li>
<li>抽象类通常不需要构造函数</li>
<li>优先选择private成员用于类的细节实现</li>
<li>优先选择public成员用于接口</li>
<li>仅在确实需要时才使用protected成员，且务必小心使用</li>
<li>不要将数据成员声明为protected</li>
</ul>
<h1 id="第二十一章-类层次"><a href="#第二十一章-类层次" class="headerlink" title="第二十一章 类层次"></a>第二十一章 类层次</h1><h2 id="21-4-建议"><a href="#21-4-建议" class="headerlink" title="21.4 建议"></a>21.4 建议</h2><ul>
<li>为了避免忘记delete用new创建的对象，建议使用unique_ptr或者shared_ptr</li>
<li>不要在作为接口的基类中防止数据成员</li>
<li>用抽象类表示接口</li>
<li>为抽象基类定义一个虚析构函数确保其正确的清理资源</li>
<li>在规模较大的类层次中用override显式的覆盖</li>
<li>用抽象类支持接口继承</li>
<li>用含有数据成员的基类支持实现继承</li>
<li>用普通的多重继承表示特征的组合</li>
<li>用多重继承把实现和接口分离开来</li>
<li>用虚基类表示层次中一部分类公有的内容</li>
</ul>
<h1 id="第二十二章-运行时类型信息"><a href="#第二十二章-运行时类型信息" class="headerlink" title="第二十二章 运行时类型信息"></a>第二十二章 运行时类型信息</h1><h2 id="22-1-引言"><a href="#22-1-引言" class="headerlink" title="22.1 引言"></a>22.1 引言</h2><ul>
<li>一般来说，类是从基类的框架中构造出来的。这种类框架(class lattice)通常被称为类层次。</li>
<li>我们在设计类时，会努力令使用者不必过分操心一个类是如何由其他类组合出来的。特别是，虚调用机制保证了：当我们对一个对象调用函数f()时，对类层次中任何提供了可调用的f()声明的类，以及定义了f()的类，都会调用此函数。</li>
<li>本章将介绍如何在仅有基类提供的接口的情况下获得全部对象信息。</li>
</ul>
<h2 id="22-2-类层次导航"><a href="#22-2-类层次导航" class="headerlink" title="22.2 类层次导航"></a>22.2 类层次导航</h2><ul>
<li>在运行时使用类型信息通常被称为 运行时类型信息，简写为RTTI(Run-Time Type Information)</li>
<li>从基类到派生类的转换通常称为向下转换(downcast)，因为我们画继承树的习惯是从根向下画。类似的，从派生类到基类的转换称为向上转换(upcast)。而从基类到兄弟类的转换，则称为交叉转换(crosscast)</li>
</ul>
<h3 id="22-2-1-dynamic-cast"><a href="#22-2-1-dynamic-cast" class="headerlink" title="22.2.1 dynamic_cast"></a>22.2.1 dynamic_cast</h3><ul>
<li>运算符dynamic_cast接受两个运算对象: 被 &lt;和&gt;包围的一个类型和被(和)包围的一个指针或引用</li>
<li>dynamic_cast要求给定的指针或应用指向一个多态类型，以便进行向下或向上转换。</li>
</ul>
<h3 id="22-2-3-static-cast和dynamic-cast"><a href="#22-2-3-static-cast和dynamic-cast" class="headerlink" title="22.2.3 static_cast和dynamic_cast"></a>22.2.3 static_cast和dynamic_cast</h3><ul>
<li>dynamic_cast可以从一个多态虚基类转换到一个派生类或是一个兄弟类。</li>
<li>static_cast则不行，因为它不检查要转换的对象。</li>
</ul>
<h2 id="22-7-建议"><a href="#22-7-建议" class="headerlink" title="22.7 建议"></a>22.7 建议</h2><ul>
<li>使用虚函数确保无论用什么接口访问对象都执行相同的操作</li>
<li>如果在类层次中导航不可避免，使用dynamic_cast</li>
<li>使用dynamic_cast进行类型安全的显式类层次导航</li>
<li>使用dynamic_cast转换引用类型，当无法转换到所需类时，会被认为是一个错误</li>
<li>使用dynamic_cast转换指针类型，当无法转换到所需类时，会被认为是一个错误</li>
<li>用双重分发或访客模式基于两个动态类型的操作</li>
<li>在构造和重构过程中不要调用虚函数</li>
<li>使用typeid实现扩展的类型信息</li>
<li>使用typeid查询对象的类型，但不要用它查询对象的接口</li>
<li>优选虚函数而不是基于typeid或dynamic_cast的重复的switch语句</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/10/17/notebook/Diary/2024-10-17-%E7%BD%91%E7%BB%9C%E6%97%A5%E8%AE%B0002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/17/notebook/Diary/2024-10-17-%E7%BD%91%E7%BB%9C%E6%97%A5%E8%AE%B0002/" class="post-title-link" itemprop="url">网络日记002</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-17 09:00:00" itemprop="dateCreated datePublished" datetime="2024-10-17T09:00:00+08:00">2024-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Diary/" itemprop="url" rel="index"><span itemprop="name">Diary</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络日记002"><a href="#网络日记002" class="headerlink" title="网络日记002"></a>网络日记002</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul>
<li>现在是周四，本周工作还差用户手册未完成。本周主要完成了参数配置文件功能和贴合流程优化。现在有些空闲下来，在考虑未来的职业方向。</li>
</ul>
<h2 id="当前现状"><a href="#当前现状" class="headerlink" title="当前现状"></a>当前现状</h2><ul>
<li><p>浏览Boss直聘看到的一些求职关键词</p>
<ul>
<li>良好的3D数学基础</li>
<li>熟练掌握线性代数</li>
<li>ROS&#x2F;ROS2</li>
<li>笔试</li>
<li>机器人软件，包括应用软件，人机界面，驱动程序</li>
<li>Qt在windows或linux环境下进行应用软件开发</li>
<li>熟悉面向对象基本思想，了解常用设计模式</li>
</ul>
</li>
<li><p>有一个疑问：找工作面试和实际工作技能是一样的吗？面试会有面试技巧。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
